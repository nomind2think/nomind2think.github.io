<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1347aa74d7d678b5281bb7e5f33309421e253164d6c6d4f0d2ad2559c0bc7acc9e53c2a59b608100686e15eff1c4077262c4d7333c6f8b82cbf35de09610f9de77b48151f40853886b52f431d01cf3bb9964b1efd7b071cd528815da3cf2c8a905526ba47bfc2078d21fb4d799db089b1e51c22eff8d5bc3c3191efa87e4b0702a461b1fa7365b0464da73d86d1edcc78b0652160e9a6b6ea3c81449a12f5c2366d5cbc0c08db125f48f0d545e15334c4ab6625e00f985c013f9552acf0ca40e23694db352bfcb06120df28abb9f91ed94f76357d9b1cbcf2504127a28ee442e4470e2246dda3290d83df7b7d64a3c4442de6d0db863e082fca12f2ddcfb12eda4db5ccf79e383ec1d6324a72c9d3170eb623f1faae500f88ff5046f662b1eb8516660d2bab7c51ed2beaf1695af295a9f923d8a3cc77c4381f2d110221473e36be834086992e07570768b9da815e8069210b56d15a3887fbec09cb0eaa969fba4dc4e081152dbac7c262adab585386e2b45fa2e8d97b63c9177fb9c6459d247df2e451085207726d57896eb1d1a192a3575984c92ff34f71de93b5add923b586508da516ce7838b0c786bcf7c3183e0e55b85764d8b8eed52d34daee64dce2fd74829922dad2b8ff1bd8d8c263dc50e50e9e9b91a3bed2f08ed0132654748bf5a64c56419cdf6e8d90e496d6dd5fa1102378943b66ca3008ed9673bdb3806c956afe0e068f2cc8a4b636dc74afe215a7f1ac36223b2ca07ed19ac2b3e9846023665fd3e0ad04f97e501bc354167a3edfae227c337a6e802e769eeec09aefd62a88fd6ae91ae222270fa3279af691786e79d9986f912b5169deea4d34a5bcf9a4249a45780fbcb7a4641f04b8ac062b8a7d3c818216bcb0452b3857d313f7c62f78c81a00964e71b46ecac8ff9348e0a9fb470da6c0f2f66a76ba767661ba130d2e39273e9fe3a35d2e474ebe97640d6be165324dafc74132b6c7c5d44986b0ba2823b0f70519aed9e5e3743666b34f7c97f87ea5ec644c277bf94961ea238a2419508a9f0855f36fb092ebb3b5b39eaf21b38f808008d2aa7a9ff8bd11ad39586d6a3e61d4619316eb1463a598bbf7bd51b6d665d285bcb31d8fd2b6a181099187e468c87fdd2f0a7bbe5da230ce2445396512a9144aa7f4e68e045ee307f352a2d30a99e266513cb5ffcfd6493a2012c903629f16d987f693e132352e4e447df6993889d837e1afa2d42fed5b2d25974039bac1741af53938afd465e80a80b40b4a40ab716e191e6915f556b5e6065bc6c7d22d5c1e187cf80339d9b3bdac3c2003dd4ff215d1f29c8f3e7fa5bea175c92e24505e25619ace3e3158dd7c65b81a4c2e8705038e24a3db7c325bd0e75c78e71a6eb8940963aaac4868df429bdd75498c5ce96faa36a0f960b5bc7a56c52284c8c265e2c37849ea69d10f69b3eeadc38badf31ad3c3a6bb3ecadbc1242495dd4c5805a9030f07ac3e4e293b204683f59f8d89de1c6f1356b644ec53bbdd67a9c141c27a7c3a3bb9782ceeaf3f1262a431b4face522a6f18059322761e13cff4cffbc22cbb117cf5a625f40ff8d48a20aa49562ce5e078628ac51d733802cfbd577fe0fdc0850152edb306f5e170428c2e1a7d797ddb2cdc1cbc9a25571ae525bc6406cf268c7bc255274ea92d127ceae79b22807d6867a362d0201641c18dc0a2ab69ba228c9aa296ef8ce2b3ada193ffa3d57bbfcf9c070662b8937ef1f1ec3d31f74bcc26cfae6736c0654a1d058cf0182fdb367654e30fba45d2c91132ed167f40df104a500613d3ae53a72f27a18ff3122861a8fb0223b3d927f47f8336ce7040169f0c1edb4cc1747a75be814d6e1907eb9d85299dfa57289163c401b7aadf6e9d70e634acdde7e939e4be1b16b8638b343c334fc3a324e0e3978f1e96cfcf99a25e7c8912ddffa67d4ce142c174e8c3ad35a29617d8aa7af27450078185c27791c1b001c44a758a5a51532ffdde119dcf9216aa97fea29c466dba911e9d4edef56f17f9fce24d4a999e561b7e70b8ee105987b79700e533150a7bd27bd5f1aa16cd0d70c7c86111cf8508516c046a424a95589a67cd4898155f66fbc7a4131a81260ca6da9830ad473db196495bbc5ca8748014b5b9148086b12089c49a1ce62124a890f4c0039ee3fffd2dce7b5eaf44c451ad0f4dc5409441f96e819cc0dbd6666f2bc25ea8d84d381e281cf64c29acac2a9ae119890ed98ff55199193efe4bfd88772dafe211fbfca731fd67262d7b7a65bec1bb8425ac2b559050e96e94d3b5e3e3990a55691dfdec06d2fedf9da9fad6d5dd0d5e677d2345c327be0efa2fd0c881e82d30b920faef6e5e4dc814c37094019c4047407c566f8ddd6fdf329113db6aba5d514874aabb90aa86ce9cf4474dcf743106d6c818b7c48ab55535d98d21b9328850065b3e95873eaf6529b69dcd6d663fcbb746055c65d5adafece9d4eba6fe04a8d28e8bd1c9291f67f5a11e53f26e4b5226f1418d69e11faed71e8c9101e3a5f53c6decaf6c4422558a4bdfcb418cfa71725a3b1241c1a9ee11c2262c1d3c563cdb4fad31221a42c17762c4216184650e39ed0bed8cc111fd6a596cc5cc9d38dae83ec63e82c30c19efebced7e425fb36fab544d3be99344313698bc5f0a9ac16b3e2029e1cbda2baa0ca1c2888aa15aadee595f2c2d9dd3a0022f0e9cf3633a0529d82bb8b44a192c11ff02bcefe275367638165979c8efb3cc618dfdf9e0e4a9d53cef3bed8a402668f294db45624669544e6fe5acac77fd4fa433788fea91ffbefbeab26b817590facf00ed8fe383324297f957f778a4691ded8b0a547b2ee9a9d4785a57b96afe00ac3801aa4314c551f526bac9119459348e0e0ce66a01d0303dd3325ba11d2d03d7e7daa91bc33aa21e08e61be2bb454c51b0e7febeab4e56877feb9b60f07a076eab33a028ee50901173267ff69f968e975c9aa8818c02e2aa7dd8529bebdc0d78c2dbe0f702c3f7fa92f8aca523be064cce94c25129e8bad86d3b44f73d54a480e13b8f57fcdc4fd69f6e44cb93b20391623c4e520676d4c81d48badb47d1a468f16d9a620550ef299e4096523c5e2ced9ca3be254daa0940249cda7a7778a982abb5f726ddf2fcf1a141d9e55576f17b04084bae9c42a3048042c5c8c12a6019f1d4757c8419ba79fb101b08d4ef807bf384224f31f8bbd5fbefc74748f22978b647cb3077aafd0f93b0fbef2d0449d9ea395af404ea3a14b672485d7ce15bafa1bbc01b80c777029961ec881a1b70a15b2ab58b6ac500cdd2e6af2a8272d6d9d07f1d9b98882bdc0e90886b432c070522086c6089da899b950e8646f2136d40f47073432f74316e7323da281d2340fe9110d4d8a1353a7a0354082c031ead68d2c86d90cae6e2908c980367821b6157fc87668b9a3ecd08bf4b9558d2fd8df44d50af20d774623c341b0c169985beea42697988bb4fbf328c383bea8a30561e3d03bb058417b2d11ae6e97218f7725fb657768be72f2b3cf97087bb467bdc0316ca73b0343268138c96ccaadc7377fb2b2ebefbc7d91533b19ca6b55153c068df86c44c5ea47db9982cccdc18373d649608adf2db417bfd0481862919df360765d76c03915f04267e60191993eeff0964a841409f67001b3ea7c65f7c4b98808535eb5839841e30f8d9c5194d269d41d0a7cafc004d5dcaf2abd2e5a0279ccaa5318add5f6b6f237873c9be623dd360a15a69882d940b99c76c88f32f460a4b6d540df6c5ee7fe84b7226a35e102b69c698bd755260c6290cda2c20661affd95f2fb153337bc07c1d20cfc10fc8f923a12f56da8b4a3a841303a7a530090a1cb218059cd799747a7523912d13d3c0364d89d3cfbd508b857cc31e831a7c8678a3d2e74192a39ceac89c8b6b2238b03985838a511da65a535b16e38eb3c9619df7fa81956238422a0fd5ec39737bbb32893556ee40df6e488424bc6b82b6d48758712b94ef85e51d599a2139198b47c6914c0e1e773f71d5757844428914a3ff95660413db4206a995f1d34698e43bc3d283021f2330329ca31eb89f0c0fc2ba65d09b9dcf7d8b5efdc89f8a1525f29a05d598c32d093dacbad2b15d19c6c48487e5b7063654e005a963d504ad7168ad4bb26855a9a9c60ca0fb490cc99f5bfffd36fff9d2827aba43220c55473deed6a99420a3bd5b85b51dfe1583744a42b186bbcc229e5340118cf20eea1e58baed9246e6e453267aaf941e657c0f58c91a3b14f556ef7a94ad8ba1828231bfa69ae886884c2faf6aaca444e1b3181be907cdfce55d00a3c08f30894978d0d9b77b40bc60a7763490705bc2a1e63767b857e5612a69ded9841232c6dd87630f0306dd263f3d085b8b16c4fb3610e1a196dc9ba388c7d88a6b1d409ef208199c260320567292eb1fc560f8e11c6a9f7a3092d02a6085723c089e9d07a3b3a535bea932ae5071fcb35060ce93161e6f72c849c0654e4b209b40899ddcc1008bfd6953889b99b95989dff9a6038b9ee618f77fe2824a704692f44ba49efd6c91556007386f06dda1e555688a56a72d7a4e7e360a842a4be5273377798058629cb3e4c2c3ec1f2a035f429193fdab78fddaf5c11cca868ebc9c59fa1b4588d6c31559a2a0c20a4812bc5b1bdf0b86716dd5e784d7debcb0c6d7aa6ded72ae8148cf02d37a8dac4942fae0764c736638b3982039db8b1059243a186a3f23bfe45f7292c587767bbea9985d530aa684a928e1a4c51ca96d6b12468d1d58b961352ef4b2de821936a5298b6d7df80a3fc462c19c8eab720c16f7473f3ea31dd882ed35c85a4a3f0e70ce1f2470f5b5cd3047740ee129095207619a49dc37a245c4b61477a2e7831fadba9fd7a8acb703438252da8a3cf350d51c2de0196048416a51526df49e5ea24cee543110eab7e6c9d9958f558d178ef6fde7f271f7c90dbe8c733ccbc22abaca739c141028cd5d15234098b4e896ee74858d6ce14dfa844677feae68250b13e8695b73c30225cbf230af7a982fd6d6cd99b3d2498b8b5d2ce5ab854cc78d98befd73251938eef493c59133750608a5331449214640e53e33932a26a3447c9479fbda6d86f940695f216a7a33dec206c776dba6d334cfced89cc957a180e7d88eda7c4f6e26a00cc8c874912fa2a4c40995bd3166960245590bf57e6b2e03dd03d404c8f4fada4bdf52f51306dfc30025c2be0fb9c198126ae91e50353f0e34ddf55e940bcbfc518b19801fb15b1bfc6deb75e6058f3f0e78c18f34e9b8f2e33d944aee659f08db969888d1624ef739ca1bc4410c3bd10f4237d17af67b038e369180897d2885a13267b0b8107f209a6a5497938c3fa4a9fffcccd5b91221af445b3a65834ee3835f796cdeb9ad55cc608d05389dcb920d0968c8fb19819c946a924f3dd911b5f0a10ef92a968e2c60106ad23bd898ae3f33498ee3138fa6c9efab0d6b8692b13d6ae9d716ee60075af4ac79b064f4de449c7af5aec187f0a27851f47470e7851a0c433d279bbf6fa9e6ddb36fda95efda3814060e9e3890c4c437e4ca424e6df2ea326ec1836424212f1f220ae45bfbbb9f0f9ddf46a2bf2ab47296c5d0472c4b377f89a5ad17a046f7daf2ba3d934a0af6a4543f79843a6796549714ad789db1a232eb81ff72ed81ff335ad9f27e3ab1fdb05ca73ac603453d6f83dfe43854f449dcc699af38d08a6639cf5f5f1f91e4874f3a2e80d5c64ec95a2d6882799dbd2b8a92e949a1f17f5b05fd9494aceb9d09a809d18765c3c0aa4c0013bf48684a90373986aed28db8c627083946fe79676252b28dde35171e45a8b0bd6b703d830ef0e7b399a0bbf77a9a363c541b2e4285daf5538311b7662d625574d67d4f5bfdb5b9662acaaf5022a5a7d5103bfaa2e92e272c3667e6fbc2c38ac3ce93da6620d91a666f299a5c08b5e60e18ba2c414e4e815f6d8e6d6eb183cdae8c69bec8af3b5b8079f54420268eebdc8a332393a4178066706aed2cc7d71796954a1821c792d459e369372031a7efc7dd66052c694dd37751ed357c31c3a70ca6e9699d84a7ed9da6daf5a500393ed696d858b7cec2198981501448cd8cb957d287082f82dda19dc3cb9acd0b505e303032bc780e9f8e424215e1662887bbc95a1cd03e3370957a767c87957c4ca5e4738fc7032175e96aea06b8538255475af8b6cc943245094a57149faf0e843a135035a7e9e25f04ee2a8190443ceaf1a3af7c1b75bd7fb0bf80039e2ddea13e7b5045ebede7c4815360189750c766591dc2d25731446f76832ef60fd516229f8e8e660de4b027d659f43a1e7c27f84a67eea81d198a0caa9797415f8039e1f9a82795998fa57bc308ab6b6699b5b7ab5c248187f80ff71b38faccc9ac687f3b6434002b85a650318dd46f4a132d3910fe321e1e5804aff14a329655fc53627fb2937cfce4892f6b9d6439103314ea773e03ec538b635188e3e98c339be4124ef65971007469c26fc32cef08de666ceecb1fe62273a4f5d054bc54925fb47f654ab69331ed07909600e3d653b948cebbd518216ea52a5ac6a61a4cfb33ce51d24a1ec2f64818cb99430d6ee5ed5b32e549e08df6bd79c01a7a16c09fed04861ce8ba6784be5379ecc02b40ede65b2cc36d58583dde0a7e0feef4536cb101fa5c9ae148624af3d8d8b5b0d366185279e350faaf63a60019a145cf87d75e62570fa59f49af65c1bb3b84caecd15689de12d0ff2fb9895681b0f998039eafae075dc316dc7c19ff8a7d627907bc97f7e59e52f8bf649d783c2b27468f326269a40dfe2c17cd23cc204e034b84e232e49f55083a1eb32d49d7ab9ee39d755826515da7a89ee3bb619e5b03832a0d9b7bb455eccc074391a58da475b59488ca8f599bda1228162ec0c49ce9ca5969638e97a612501b556ce68b58e0a81fbb578f93777ec9f755930eb3f6aeeceebe0322e101b5c3ca5d5ddde9791d6cb60970dd971a358c6e3ccc1215701f6dae58ddd44187603f0dc4dff40d47b03b7ea211611b1160b76a4fdf75651feb0eb3a07804cdbc3ce78be6e084897f704b1debeeb9767f763d21a381a9a0c9d6869821cb999526bf286190928b63ef28177f63a46e808b1a20fc1ad8a2a4749779f0a35ad310ec471b384726399b903c2e9565bc988247f2a3f3a791b0818f457b88a477de250a949e214d1d1e0cac79d6bbe9d699405c4d46efc6b3984846ce557d80a0f42eeb067f11470c20dda980d50aef5002460aa6e55620838f8f494b8b82adeef7619b2ea1d650eee2a8254cbb5e19eb7fcc051422769d1a26895419b2e0b0f8f514a7fcea913b8970920d0a1b06dce5d62159a6c22a371ce92d0ea4a9242a8df8ad83ea9a204945786ae8aee8ecda5a6275ce783829661428538fe3fb9350196ed09408d1f4228df0a91808c2f8a02aa2b7a30fa15463fafc565352bb6cc2da76e570668d9b75eb45ce29250f3f2e93d5c63c7c124b1b90ea6fa2ac697e20dea61cb6dff2f2a1359a7c94a35c46ba24f044602cddf542cbf249592ac4958bd28c077045fdf293dc83eae6826c4d7a04f174584b3f9dc485ea18729ab4b88bff30d48581a3a877613ba587f5e13dded25d7bd091ac1f5083e0ec65af7e0ea884c55ba378c48caded8c8d5cbe00d30c863e0fd2df2aa18fa7244f108c0a352128ce2c45b62526274aa79fd4708d50997a1066c57dbb1832e50c2990931beeaac8a8ef8d234dd6c8da6d1c57bdc5e074de8f69d7849aef76a133b48de866ac7723fc6a542d0e08b83bf5c12694736ee6bf5d39236a82288d6ddb2e8f1726781a8f083b880031aa05d8ccde9eef3eab6ed18a7cda06e21a89d6340b5994222bc7ec8397c8f30ce78a016d0dd343f653b4c38ec244de5438e7c0c89d4c2182e1ff33825d6bfae4a27385e952f577c06aea01b95ce44344d03de8188e133701ea0a6f609ce57a266c2d086e0bfb7690f4514b0412b5b34594893cae63eb93ce8dd1608821a6d7ecd214e8e1536d7e4ad1aa1910cd2b4da68ee62bd272e8766279eb29c48d2389e6669ca5fa4614d5f66da728769c5e6606fef813fc56bcec583a2bfac6b6be8d3e8e33de73e148f31d7d0888fe30a059c74724b98d36576f2101476d05326e2cecf70e53a44d4525fbda1256dbba1cb4695265ee26cee7ddb37ef51dc250a8f2eba02911be9902b79a2d920530990a5e8f394cb3a3666a551b8fcc4780f83e1847fc3a5481c0ff903a165836a9148d0e0a5ee137f02501a06300c08af1b4dfc48c45f1274760033696c5c32fdec82c2d77f9b5a94fb889ccf526d20f578002dbe75aaf69bcde8ab6cd930cf1f9552c7ee4fbeb08df639ea6a2c7e35d406931388702570f737824abf235b1a02612e87a741da3f07c1caf304e22371cf99a9957e4c41566b1e9e92e256abbf39073e4e604cea509570da8de2f360109e61527607ac28dde5efc51f5cba8c91239158b77f1f33e96ce5f8a020d67e461bbd1633c658c0b8594d765dddd5d6e657d053edbe9d4399321644a23dd8263ac0f4c4e574457a262b933ec4f653cdbecc29d3ff693a4302cb22cc029cd5cffade6a733a0734a13084a16ad631b80cae172566e69d921f8863186887a7daaf44c8804d148c1933f7559b6f5524368c20f4d428da0d6a00c4e4c33942283470f6c7b517858022499df2e589b75b19fec498651704e25d430092919c3760c88bf6da332a0ec4070f2812405478249001e0bf1de8dca511406c08ae30109ad4ba8a40b5193160d4af942548a1c3e44bff11a27574536a0ce7c742bb27305c608721e5208467f1a187269bafea8b56439be6c3a723714d74e984e884f5a58c1f9daafec9f05d1875c71b5a2b5b3a5511987931aa276c4c444c757bee74f81a1f6e484de0e9e668a7240437c59e745891a3f6f2d510715eab2ee3862429821fba55381e5681da4a4a0f8cfb2aaf5aeff1f0a3ad3b4bece79027524f98fb1ef6eb8bdd9bc22f0ae19d9a4eb1f36d369ca6aed9a268233c96f5388aa4ce52ce2b24617b73e1a78128f591f5067875b9495d277d72575bb1358c04f237d611a94500a089dc7cd8482f87721ed6237f75575ec6fc40a30b6126e2457a881bf02d8e8bf87c29f0ba3170679b65ebc70f799f6cc50571b203dcd469d64a5114ac2a00b3db0927217afc534ce7994c31b9b101da00cb05d073f2e84a99989144ae1c93475862540605acc76d3c9908a4ff93a87a1253795f8c098fff3ac0b006d4d2c9c5f47bbcf9382e3d90e9f4124dd6ddbe6b48401c716c5d73cac935ec3688c07c44e9d06e678c0d855a3e1c3b56d51cb8988ebc3e88fddf774b5dd62bce922de81a0051d4da209e34b72406d1fcc5652dd4641919313e38da9c7d045fc06aeb99784332b4f47179e86e3e04916e03a26b90b9c8b6c58edc83faca3abf1a6139616f5b404921a3c888c9a7728e273560e71db225412fa7a991a71a682ab24889de0df20af3e3a3723cf909502e6ef083904af04db9b89510a289e2ee8873d8b064013470a261dbc1fa5ae814b7228f743cbb256ab1043f93d948ea5f7cb0b1602cc58673a9edc39ba1b1523b517a18cfc7f56e2eeb65cc33de4ba2e11384497ec5587c5d7649e3eeefc06a0ad70616d9caaa83286d9e4894fa4a57a173a742c63d712a7484e5bb86fed3cf64863e7991708ae357fbd9cadc4ca3f06a3f45963068cba05cf9da53df01dc35b99343c6e11094f15d0ad8a5ef9035fe019dfb8bcf8a4292d8639f9fe15e65407792054dc4478714e20308d97166e9d8478d6201aa71f73b53c75dc4a86dc54bace1c7f5d11bb555775e0193c8cab43fbbdacd6f6e1699da223ab5dd92938a9b817def88ed2226168ddbe3e5eaac7aa0e8aebce35689730b0179314ead9049a95ead9190c23b9f1c0bf3bf9af7e953104e8ac5585006f6061487c4b199c5f55ac1210f15c5de33d50767fde97521fcbce671e2b3c2f88c65ab8e6941ba43fcd72c2d2ec65dca7d187b4c65bab50e89dc546043393b71028e88bf6fc91718b3f651c32552e8183c1d134d9855a96e4c503ad5a904b79ed544e49581d88382f91c58fbaea6a4222d940330a8f95dbc83f631ee0513be009ebb4a5e13eda1fada7404297f804d0960ccc52d89529e59f7d3417ce5a41bf4d7ca5acdc510adea2df4d66a5a14c00c7a70761e872a17f8eba671ec37e2e4fef29cbc1b3cd3bd50fc739d193b84b2597d91bf1cb795844b4fc012674423bd6cba8166dfc5fb0c886079f1c842f6a6d26cd21ab7f0f41d5eb859f17aa0f6a72be1d01ca7bd47fb42bb2bfe14d95053b4e827bc6fc7de3a758d0b0a822c7285ce95c9d9e0dbc5603ad17ea759908e99b537e0720d625d7acd67bb2342fd871e0e10b3bf5ec738cdbd131ed90c462752a3df001cd7d007748fd1884861cac4865a8f885675413f35922f7ca90026b39f6d894d0f18216b126e344616cd1d1583457d32307bc677dcffc2b3465ff76105cd7a42e78a3d23357a51b58e92cd33d11867368c9c747000660ac9e4aa5329cd559d2d78cd0c2cbfd5575ed45a2374dd69bae91e62d792051c88897f14148df86a0675f1c7aabf728966cd079a490f02532bdd3a350558a02abf1970422058ccbb259f7d43981915616d51ec5ad6d64593d25d0ea27aeb9d97a97d6c219e2e787e3d89ea0edbeebf788503d74622e91c1c347bf98bfa83a6585ac393c47a893296d3e6616b30e9893b63046444b0cd5cf2e5f3bc11d887c578479a49d749ec4dfca3a5577a90847b6dee5d7e34bccd9b52ba84f06041db012db924b3d26adcf83aa336babea9861df2194f540dc564ca4d1207d9dedb34363cec56e2146d12bea55ab46d7891f1df3ccef5a6bac32bed384878423e7b0f96ee0941762004c28b2e2ea820a9370c0a4ae361d7f069e5c42b2a003008483529364182774aaf652ed0a6c931c3e7b48e8be6daabf56b31e957ed4467fe70176d8b1892db79b8f68d698b0777ceabaa7f5780a1bb15b7e8d6b3c4b95c1ac7fa50d7b3ed08b570e7919849b451f11a6d306231fc70df3e01c95359b183a351e1625ea8182e51920d728fafed1e980fe1c548626ca8584ade2cac7260d8126643ed4c9eaf911c9ee0a8f52fa49c0c40f60cf9ef7624f60d31900e8a8a9d603550ba0153336194375b77fd40084084f9ad922dbe798e8cf85f37238fa4c8e229ccbdff24a7bc8cfe19abb13d20ea3404a8e6d760187782bd43278a4270166160b9962a60e7f82ab3e1659cc89ee48c5f238a9050bc6715842bc33afa3b551f0225888ceb1f59acd894f049bba0a19d32935bcd4f366687c32fda497f4f59d64c8c32e7e752c72367de84fe91a00d7987509e7108acdca38c16b11062326205ba53bd24e7023eb4426722b688a1be2e1c52faab32c8ce83e87b148e0ec4c4364b563a1ccdcf38c2273d6ab7d588536ef21d5cb109f8d1f141dea749307f6ab894f3cf399969dc21a88bb747e683734ebe6fd19960481f93e74fe2ed004c54b8b53f077140435208aa4dc27733d6d4e458c7543b32c3736f321ca5d963d1fb3a687f4b799e0a5769d19f243d64ea066f7ac697f5fd01640564f7475f672069801f192857e4bffffef887f3f828e62fbf7a71d694bf30cb6c8094228205c10adf8a38c514b0de7723eb1079ca01cdfbab62a1e511b17a1c88a236d9113224e47573e8919af4eb5b0bdd40d027f55727457d6bf703a2fe4fb5ef05bb539a9e8a5ef2def13542b1d6a5a79ca743e2d57053c92e182fc1d49db35fe6ffb116cfd12bba9d7c91050828d44c2de7244a540c931560c56cf0be8d687febafa56a32a9c460149f5723cd23362f1675bdbfb12d2c078cb06040ce9663a9e7c0728e37b5bbf28e7e7473fccb26881139658e70b1a59c3e34a2916f23e59f0bb228840ad5480711092750d9d7426bd295ebb48be1eaaa3ebffe764f392b1541cc6b022f35d838e71286411b82b4d0e0f645ea5529f5f554b45819afa711185e31cfafc3dfc19c5692a5d7ec024983fbb3a6c188089fd40f4875efa907befd8d1abd62bac1c7997b98e514412a80b714a9f47e36afa562b5371fc969b139b882c1a3076d6d457921776a37dc88b4dc32cf2a1cc193d67eff1df87f298d9527dd31219c00fa48b83516bd332dca75594544ceed8a3a5f0de52d03081cb4fe24b3b56864ba8f5f2340d9a1ab4ad9e24bc0d34faf86988e342b8195f448a2d027abf5c859c6cd1556a1d5184c2d5fbc5de249f771c2d9bb733a55089c1df60ba25b8a8bfd00ce8e8891e400f2d9636befc53832f163a8916263ce80018f55a31de69d2783df0ed45aecc92aa1f197763460a0a88a7a6a8f2f3cbe37776bfe3c1639551ccf782f2b2e63ecb54e31343a1f597cc7b77627de0209a0f80abe25ff0647f71fc62bda64bb0d48ea9d745b6ebb6b6d206ab592f82fbed1c92297894919ecd702d08c563997e09ffd93ed2fed9167f40ad82aaf2183f5b6374734f3665f545aab36bb36f40aa6a582f87f3f7d498ffe646f0b616324767239568a02a0783c3f30f0de3049b49e914fa278e4112725579f4bc4ac735c6929e0d2e95e0712b188131b8242c4a388b7fdc19ab093cc9be706f59f522eb19ec2e71517f3de4fb1ccbc759294c1d07a31715c2e36f4784367753f1aa1eec6c0dd28184d47e06c46fa903d999332148ef6ac511b248eb833f57edad662cebb4cde30cd1ff90ed898726a34eab1021fb8a0066e52501f8fcaebe753d388ae0f20ae672a58914ce6b3916c5f05fe50d3991418b7618e66d2bd79b2f764120ddf6e0ac41ea22b95a4a91d9f2ecc20142a118f2371309620b6aff52bd1428b7f5f0e730f8eb8530a75d5bba805999d20075d790890a9af52fb42a4d0a6d40f520126f9d97fc3369b914f3049cdfb1763da55c4b9e5124546b2a6976595693327f20300eb84a69e85229a0e4e0206d27fd79eaad72df85fbfcaf00f67b7de8fe6dbc971f52b1fd9526021b406868d76777b13edc84988c3d1c6fc7f8d1f7dd8fd13ee9025580427ceaf15ebe6b7e640975052ad0f37229c76af46dd4e83441ddd4c54737fc936fe2f924f14d339abdfb0e34c9aa2276e5632ca29e2bcf6f12af958825505f4b19e13cd8082da75e2e008d7818d68d856e7de5a86c37d11a857dcdeb88b8c50b37fae86370c5508c02f6b684da0931a2ee11a82c049147195bc2c1aed6cb5fc2d77bf5d36fb430f860a056c614afecee62554c1ee7a7f42ff36b4193c0aa50a0f464767ef8712d40d84fc29f04a4de5b98c9ca288a1e6b5217b52485abbbb77572ea0789437d101acff2e2ecde8b66f1df61a87187bc99565cf6ab93606a4f14c38a5900a3045edc22d4bb5eb82d38baf77f9bffe020eb5a5985659897637cca4edc70fc720b91d46c438cf0fe93b659b320356cf08aac16711f73ba7cd6038c9a0543949fd15dbf16f4ea30fe91f47822400c09681af941fa510ba235473a84cccb61adf94a0e01cafda0d61432924890c1ae51835c6a82e2b6eec89cde4801d5ebab1fa79f61eb5535f2cc8443d77272689f195b30ccd30bbaaa98f956c3a3c2f7ec17f5612e0275983e243dec8ad93c17b9ae222f756f87f94249112fad856dba4b76797bd917bd22aaca57e5650598f5c5eb2144d58de283b4596d1a8df6d98c42b7bb4fae6accb1e8131a359ce6795ec8f0d99e5687881b8dc30eb17b4918ef7816bfb14e7b19888fa83b4cbab00e9137ae07a3ef0588bb5bbf5b1722d4f6434052d7b31629d7aa94e40737ed9d1dab4a98021c4b48ca93350f65c6c56c6b9d81fa7e0a4703b1be38b2a2c1aadd9ed16adb9885f380bc0d4fea1cbc14b0f24330dc108f1d94b3674c064745d30139c067813fa431ed6d0866224729863fb75e9fa6b669cf90c08746c14406a8de3af702a76d284fd7ed38cf55bdebcb7a7ee0b007da93436ddfb0d6b7fc839413eda8cec63f6b35449e266d04e005dfffb07c6d7584271f45d504e7bcf74320562c8b49e8516946abb0facb859099245063b542dae12f2395dc8a3e63ae8925eab53521fb847ba1bed01b3c920d2f56472b55f1636d153086a2be60b3db38c9d4908f43d738cbd40dc8280e14af7f50cc0022b6436090714d5d95b5ac0c8374c872c135360cccb1d65828b0cb33373808e1948818fe1f08844a343df60c1372e90b4c95c32cff2bf57e91b9ad38d6b5dcfe4dc5d96251da2abbdd89bc0ba571da08ceb2a97090330c2f5b4238b80ec31b7cb3e6f26b4b5e7bf7507a383b9df1e4417a307ff9645b2b281ee8e74a0f4360d57098defb9de7a4075daafc8eac574fdf75bd48aeea6058b717850d88a41f68f46c7fe3fcddd7343366e55ce88c35771670e13a3fd28f075e28fbcc3a6aa9ff549818dda0f6a76187e0aac05ce9113ca24bbba084de76794c04dbb283e7a2749a905f84369923b7adda328703f4ab3574a3c2529a4fc6c44bd0d5f71fb68df9fac8428c45595fd023bd97bdf4df496717fa308282092f1a968d807a02064c9a03e68f443f3fceba943d8611f0878ffd75140dbe26328649a268ec4925b524832d4d7d7ff07e83661056492aa6fe9a96cc7ec332ec731ad00e09220c6a5f77c01f0ffe974f2230e193e7ad2c5649f4a78af3e63d4ed493360b201c64e2397ea54ee449aa38faa1c78892c4daf500fd7253c3b81476be9baad1189985feaef7a42b37a6b62a396befa214d8b8a51c18f74607bb407a5bcfe58d185a3abee08828670bbc8a174240fa178d918125bc814ba104f63bb5a6b0961e6bd31be207526c477ca1483eaaf2b1271a5f386a2d845aaac3926b8d1a2cf4705ad578cd4fa0a1a95c039797d83b171e7f3f5a3b2b0efdbbc00b6ee0f9d0ad6fa72196672ee989397f65c285d00de4702ca09f089412e33462c25775c44b0692b7404099591726df8cb1ddef977320d748632bbdca956b85e5d64dbc4931c569707f3764aa410800687b60ac0077309822a31a388807cf8844ef3e5fe494fb6260b9a527328c962bb40cb6766163669676a7e33b3471852512f195ffebbd77ef4aeb2b0422411fd53a8c24668113e29abb1eacf8ea77a64160069bd140a029c98298f94d24484fd8b8038b954f132d44c60a5a7a4322289062a776925d0dc394dcaf61f4d2484e34a950e6eb8995c8cde8b4162ab652a853e95583fea934458dfcddb997c8e610ba5736909dfee7efb3f124c92c8fb923f6b8794ca6ee4564b645aba7d86b1bda041afccc7014c484d0d63b6fe6ec280878c95b8daaef62486152b905cb2441ab82eded9b514aecb3f312ff0a220f197ccf98933a4b48582447ee32a825660c3840e9256d988af3001e4b1a13339b9213c2001bee8d915421b1279f333a886a1ef70a7c93a9103ca8848973558bdf5b4be068b524dc1559158a1134eccdb1f884b3a09c4380a0846a028637c79d7e0b18d9bc0afd04e579014ad9bce97fc40394daa42fae355bd4053b7c20a7919fae8e77bc12165ebe87d8806bf3f78950fe97aca54a1ba34b6f725d6512910387994cd084411c650599294cd31ebd1a3c44654198cb53ffb8b7d696df122bec95508d5f447555c5ac9843afc01f87aeb9b0d7742e39e041b2597a1b0d88f07b1faae635a525d308f287d2eccd798d3a61dbf547644ea2fb3c3c60255e4c08b9fe4a21a15a16d1440a1e302002e2292c319877c188eebddc0b3ab6aa7ba1cf6038c5a8699651bfe5bd3f7da3fde0aebf69e665271053105dc5777ef7e7b3ee230ac271943eb543cefc42463c8242268edccfee30bbb5e9c6a5194d8f029d69d5b0d6868941593a4932b80fa35235428ea5e4168072c89dac17c0a196d0d855bb8a239b03e02ac5cbbb9c4a3d7c45c82c05e4fdfb0b4ebdd16c792782a99a28c4a2ba96cad79eb8c34696365265345c397894f52da9baea66558f49f39d4be44ca7097b8fe8eb75318ea5c7bb599e6331d5c355cdc2390d8a7d594753083d7d922d96fb48a7dd534d64cd02f95ba2c2a203e388091a26c55ee9114652f03713c72d02ecfec1184efc82cb2e008a6ddcad4b80cae35bd10e6ad5d70dc8ab5127139028278b1cca4ef4b3d047c04aae0380fe3e730d43efb977d18259f4d2a27c2de64cfa7e71a5659441d355f2660ef162e3b1cb90bca5a3473715b5e0688b1b76c450a8903957ab11a22dcff454cbef77779374e05e6b16fe496434dd35813aca21f2897f3db0847e7a871af457c565ee909ce96e8ca9c936fd7378f49d8a0f67fb51134a94c95b40bb16c3e4bada0dfd818679fd5dd67e5c7ec89b95b1623f6560b527783e1ebf8adaec61bed2a6957a051252ef840784374f9297ad42fb87adf06fb8f8d7e3190a6312322949ded13a7d6bf0d755661a1b4957b2f1cdbbefac3712bcbf1bfdab015e268ca1276817028a0a034a80dd651b1f94f155d6f2c15d1859126ce9163a7e360b168f84eea46f356a5021047d3df78f8309bc8ee4a657f78b9a5d43ae5275105f883f08d92fa3ee57823236d8fe9710168262d6883d0ef41e29ec02ff6ab9f44805308ded445a622f20686c5d389e49d8423c8dc778ae763dd91a01f3b30cb0ae32e251fba7227f86779218db8d865eb84003d995bbc80e4ed9b6f5c06dd336f70bf5feb4a3cb9db5e9697efced0783396b03c4cab37f4f3a89c685938fed4078ddeec26bd53339771e3455d0a8557adea0673ea190f6ae29bc8372f6097f99ac1b86a681ec44461e27a433f1a4c27377319b4481ed7eb3e117795e093ad03a1f5b8561c0960d0f5165daf3abccd44ab93cb617713efb1fcb75e33780f4246e5cbf485b43719672ebcad3d4a6da89559f573a1fa14bba0cedc3f695c2bd10b0101336d276e7fc68a0b51014f28f75298840fac23c054124ef61828a66f5cfbf85f68a6b768c622736a7dbe3491e96691641faa89cc459c3dc8d4978191756cfe4ebe51f62cbee73a4ff478f075e9efa62f039d007777de31e23921d01fe379208cdfbe19063e0369826bca3da274991d30d7e284170798eef242cc9f0e70e565f40b514f738a135407000bea0a161af1c55f55ce41a70df03ba26948ec1a5cbe473bfc3636f133e9e9592200cb0daf9c397c8a73e7fe1f6e0342d6e0b443e236a1ac29cb946d621730f3e9dbc031bdd02a9b80fb257ef624965e4646da4c31a039866655342f24805db31ef876a3e20bc4fee13909dd2fa65970f4e9328c9106611c4a2ec0f20047de62ab40939865e0081be251e4c3d0ed832245360644e24f0c57cae66aa13ab2130732506a07f0efec52e603c30b0a7767e40b9ab13d34ac1993da654b0610916df3b3636cb08e933112d450d48755ef4fa4ec5ce9f04ec97db25f53f220ef727a6b2e377851ff07d041c9c220bf250b0022501ab4270d18b84f0dac6759c9be37e0e419de6e24886f801a42f4c4c405081644d3fed90a40c497163dd9557e4aa79a4c6924d466e4c35863cb97e4e9b123debc57a0422c6911d45785779cb5933787fff5ec8ec73828e91c780b4c4912d971fb0b4f54f52f0ce4e7dd1023c6d30b3687d2254db51e55e3aee5988113da97751c21d5df8f8a20b8757b6964cb68804","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
