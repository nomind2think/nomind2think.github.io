<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c79941568a0f2500794a751e3fedd812b35accc65b617e2731d4ca5b378c6233579044d46acb5acac24d063e5e2d1b9be20048e247e39609bd8fc57b87fc59da6d5a3064cd11a3e9d3efa3546e0ed9ce4b6cb2ecf725b06b2b4c0979c5e5176a2651860dba357a809cb8958eb45f943f1577401a70cbacffb3d53b988a8315ce39ac149aceb91ca734826bd163b32b3ef23a8d3081820db90ff7f2d86d381deaa6860ebcab44073e7254423d5ebc3528de7e40c1da09dbc199d3b7ebb1a8139afecdacdccc39be389622870a11703ffc9e7aefd4806e285ade25c1b27b38f3c19a7c6b70fedb4c2c45aac20463b42b504f79e6b8efc35365d5bcbf0f16edbd0c38837bd955cc9a002311513e5f17eb26c661d4af3ea059dcbbca2aac895a5112310a9abdfb587dd2c80d19b8b5677eabf6bd0ef8aa1277a8358a61d236a8b5597962ea28ba0ae59c2d086c1aa235e539bcb8f5a70adc8b7dca499dc9c33d8e964028da517951a822681e10a317c07c690f8e6bfa6a8b1e64b6b0b4891efbf4d004f4543b9a76c825af163b09d5322e82d86b87eeffb0dc605a1ed56441f4b113f726959566fc6b817f3721069b56f484703cd39727344695dd5d37877c3e272136ad7adf4f3406463e408b917e08862c61cf74ff36cf79d4f5cef77542d9e7435a27bf7676357a9bdfb9ca89898852315d4141d6f0826e186215ecc1d66861204e293edf149201e59435e632f51ba8cf72963eab1cff95cb6a7d3a8281bd92b7342cb635cb8a3920488016707df54d773b5049f32018cbafa2628875b27fbf74a3dd4ddd0f43022b7b8d4e1798f0dc12b3223ca0bba0dc42af0dc6902646358dfcf2b2eedf808896c33b2ec2d4afedf1300373c39bc80da9bbab5f6ae0fd9da23a5ca64077cfc1725aee2f542f6799db613af8e9214be088f46f36a7540978c91fd1bc5309bbe43ff00169696a75021cc9a51af437cc9cbe09047a6d0ead75599cb6edaa694991749b3a11e980014f04fb8107e93fbb235056078225caf1296baa16cdd074e1c66dedbdaa7f671380d9a524552dcf989e94238828a9d801d8c135ce42d8e40c28141631dcf7d07241090d760bc1ad8cbd524d83bbd77bfc4f0f6a526e89ae37be1a69adf11ce3011173baa1e13737ffd47a1fa40c2c5929946d82d5c83c65ccd1223d3cd4640fb50eff2fe370150a32eac5393bb77943a44301949b36ce1956f716a11e9b0ee016fc51d2e00de26e549034bb1bb186ca3518035003ba980854f5f9f448403f5ae38bf342e05397f9cf75c7ae41e4226ae5fbe487bfbac35c472f5410c1f0c7cb70c80a975831edea8ab35658f14899d46d75b7ec0e736633857a49d472197515ecc3c99ca6be84810cc8ec2845d47374bd7086556430d070533ab86f0fbd661f83100885527c3546ee4c577bc122bac22da2f9df58eb9ee41cbeaf542140080786faa8fa90bc89ad8c5e0c2c8f8470c073eefc4531bf75db0cab51baafb7a830848b1ae5b9857316bc23b321b97b9a67488576563bd0b590e143271f358492aee54f4faa1982fbad0a24315630601b2bddc83363636cb2fde8be043745743f671cdcfa3c6ccd2e77e36bf8925a6a83ba6469d46b49d58c2e161870077f2cbd41cfee3a97a52a7ca7f9972d2a987c3abf6fa9266c454c14f4033f2d07e070cb01704881143d80d182dbbc847e07ae9005c8a2c56fec9065c2498d09effe2cc88c62a956e0d80f79ed69ee5980c39a64c8b9c41f27d67eabb0451924f4733a2c0207a5792dd7ff276365ab2a7fe2cf36f4f167941418c40cc364aa997c055b14501122b9833c27078d9e0bd312a0c7fb86f0839759291793186314431f7be6ef922a71433bb85abae42b94b4b08ca8ef90515cc448fdc45737918a933b7b35ae2c5ed3cd709733a76f0054ba2d3eab0dcafab7b2281dcc7abf5ba4484abbc6c54b9fd2973c592c7cfa152a7047f73a6d6a6f6db20e318416f020eca8dc1c13ba3a2bb0654b0fe5da78b6eb177b92e8644252c6eadbb38b22eb9496c62c89ea31ff2b516c5f5bd6b772f696a3b31f353fb3ff2ea00bc5b1690d22da2ebfaf8445d84ba9cbdedbddb8b71c6922fda3d7e566c1233eb266b9113518bae5c6831963b220c67bf348d4abb57e9c51c0d0f0ddc9729b7e6a5b3331c163036bd884dd6e0f776dae75756527e9deb81c396078a5d9e3f8708f0f1a4f9cff8a1fa0a6e81d6e7f31ec9f4debe090b62f0676b33e5efe8a7623dc090c1f09888e643a5e720aaf234dbbe77f7d3add96a39b1c88ddcadbad757882005b41f5293b69d839a83f79ce546b1a20d95aa1e2831ca96d84cc57aec307f5f16fcd35a10bb87c82915f40b2a41f7bb53a02f3a72c030bf625ebda4b941195a06f707f91930f5bd5b697babda66239ad204e23173275d4dae31acc469f888970c2137148fae57a75298dcf9d2d0b56d6691a178e768b936bcce4030aee66d710d3bdb3d83418acc10e880c5d61ba7ce350f20b5e09b2fcc73e86b3e3983b43ef5dd50f94bfe4b8e4fe47a307f987e5372430eb7b2318a34a00dbb46ffb745db496e2c267b23004b336f7aa7ee536a8608d31c9817214e7d8296013274c446af3c6715341a2db72aff758fc5666b2e538580744becd491361d8aa7c28c5e17107865454395f046909e03c1507c23c2c3bc3cd329427e7d05e2e4178eb7dc3fe9f01b40b59d025420890ebc93c6510c7e861c0320411c3f3a232beeedafeba991d59c05b7bbc03809e05674f65fef7e5f8cc7eb83a0ff7195b8b80985b06a6ac732539f10f2662d37db9e23348bc9a82d4ffbdd1bfa5f3647b1de6b82f2fbac1133cd04c7772534d466ee6690dcda6abf3cc435927702be777761327ae38b12d40a48f835b110c60846dccac2e057cc6be4c285627afadc79ee82553233eed04d442853893ba6d857b615e03de763a4444a5083064bf746fde59da6920a052ef10823fa596793a185cf1c0acd3c7c852f172651c395d1833a51b0161022012c2510ce1e81185cfc62102aca4079f6c43049118739326161431710019a138f9a34fb5db19f7c251d578cdb897675989f459bfd544a2646acfe4e15865563feb75bece3a0ac9d858c744e7f0b99379b878492575ae3b502f223beb237831755cdca0355e156f1c8f26f853de00bd5c1c8bc1cde9edacbfa4293e0ddd9fd0a0d2850364a0dab1541f0b649c384c63ba770eb13a539fc8b9045728e9401879ebc731a76d8f0570b89b7faaa560956a9c555c897487471d188962692175c2b9b31a2097889520fcbe749de30db87c97fc574e449d14afd0de2433de79064c857110754b5c1f9df843477bf0288d489a1da81042ed2d10aa0fa22107ef72d351331b84c0b73af7845044075b619165a3aaa0a3355ceb0c1bcb92404fc10ed83386b8d72307b6b1ca8f0b0b19b09be1df4088eddd7e50c082ef129a204c968c128e2b09a07cb52234426884de8516b3a4277e776cc52ce9a3c93b23085b5dd4ef415f307a9bb8cd7645aef6e7c9c836b646e0c6de30d1a671f5563c028bb646c7a3c98fb276e62166cb85aecd27284f3a8a386840028e66f8b37c9afe9d987b6ca6fe6c79e6a462b164df5bf3f905fabc7381f766adad5edbe8f13db57d924bad5af3c81dd2e29f199bfaad3edb661d89795612efcfabfaea70556b567f02dd34b65dce8af170515aa25f6edbc9befa9463880f137871519fa51ef862d9dd78e423edef331b1f4651963852263273d9a0ca9caa2b917ace3a4ad7a1488cbd1c044fd0c5c4e9f2ab5efcb525f6c9e1131cf19f1f8aeefc57a79ddbd6db5899930bb9cb9b2008b234f1bc879badf06174ba05acb4b13614740613395a53f0ccc154e4d89efcd267874fdfaeac88179972ecb1551c93e41c733aa7e748cf39d8daf91791e7da183b248ece175523d61e53d08040060898f8a606dbfb327a239a484b4dd3aefd18e600c8e231a054ce3a71a8d28bd5dad3ebbb2d6737d235bcc3f297266f5059f9691201c660862a909d156be839c897a8bc6d1f51ae08c61caf8db1013dc3a4fbb9741d942437b325968287926a8d3d7d13596f456bdbf7d44b32c1e31e72fa56dd29619cc44b15c5a222b774707a015c5c62761c790c3f66e7607a7e7cc160f29a0c76ad7e4466e9c64f25062cf333b8b6d0e6c440d3bbc19c82a4c61669901a0ca29fdbdfd7f41378bd8345ee0edf11221aba9102b294c51bbff03e71502ac5c76c018fb316ad6a24b8b55a0ca829846021b4de094f8922809a1b464702bf8a7750462673e6ce3dba6bf7e9b5b8db3990d77c3cfcf35f8c80bd1d9cf5c75fe488505a187f5fc4d651f6fcd70fd06df92b399a9d83fbf707367f4350d9022bfd217746eb0dc5d2ceca6b184cb74320474ab7a0df887c0df8e110e1d6fa23ab3aff2d549e23e8c8971365dd5952b8b529624fb58d13f9c40abe378ee853cdf979d354824646e1664edd6db9a880f1472276bb66569adc4080360a438ae1575ea755294bb162250bded507440baa273bcef69153f0884463588fdf2f15bea4429f1eac014b3312075d4c49df649c29b81955ea65f86c2b2d2394567692b44b69aa150558553eab6ebcdc4ad6d8c27dcabdc0a1f92ac7c13b8a484be323a902b00f6bd8eb40e2a47688dac9fac5b2a149b34bce25838a5fe129484caef96a3cb4961bdd237657e453e51308da72a51365e9394e5f8c5a33e29d511470d8dd68edd57fa3266a7d8cb5dccb19fe5034c7882aeba0d8d7e801b359bd973403d97368d0f39207f1f8ab66d9c9ffc060fc5d0c7858e9b8196cc7a3901a5a9cf4ba08e9fe95f41269c3cafe350d805a92ba9d42e7a721585e8a8762ef27e447bad4d9e44aae20a16ae8143d6b03a2b6d68de85cd5712d323e40afb927f296fe70cd8a6ac6878d45b8cd242a30987bf06e78fd80923ff3ac71288321b1502faee110091098521aaa593b3d3c8e5c524d240a55b149cfbcbe405c8d9eed43d03df116d6ac239572c84f5862005aea640b67f0cec97ebf1dcc3d969877c889461c6c9cf1185b2fa741ea0d2b09e3fadf0925b192c6852676c7b73e993647cb2b5d5a456b4e1218aa6d841b577a8799de908a9e5886deb22d5b1c1a1a7bd803e5384a9bf0699a2c44c05e3041dfe73505e4e1de4e210447eb813743b72b9e30b0b861078e368c5f8bc646076ab867bfa9a56ff463bcd0822d58c2372cc56fe1aca4e835d771cbe402263576808234cb8850051b4d35920e0911129476b2a019d442309252ed84f0b0f7bb1b5eae38b0ac701022c95c8993b38d1e2d7424678e43df830e4fc378bbf063e7b245a0cb74b00c3c641346cd8cbd8f5266c28d1db7adb021ad274d2392b025eb6c34a9b40fe73ee1db49b1500a7a5a9c02cf09219f072283163a8bf0246b19b76ffac97ae548dd2d29ef9d5f3f0aa4f1ad8bebcda2e07430a5d5d32d6b2dc3b3c293eb813d2d590715a3138096d70df71e88b4a8670405039b95535e2dd5149837eacce155929007122d6c642015d789ace4b900c10a648923930643fc4a3e124b8c8dcb948fbac65970bcbc31c6cb44e3a6d414ad608433390057001a7a192574aa8612751cebd51ff13da172835e778c0b5b3008318c3ac723814010a95b38478d33d959ac177141081bc732930680570e27f32895be541c5862c9802a463c00ccddd349e820cdc72067b368fcee4c36596b03c5a57a01a4bfc6e5b436798ac8ca662d68a8693d512a204f36fe9df3d9f9e382726e232f2ab5bf16449c5718100287ff53ee3c573670e802a8a425642658f38f621fb6f6d6679f9bec17dabd8425830ebb08ce0b8d034acb3ad5db90a9b59432f6a2493c1fc2a2f7c029d768c6e9b69fd841fc46a661592ff3b99d59354b280b9f7c678fae5aa627b6fce85dd05d5d01a9a5d6f6551ec1d9dd1e9fab52cd126a46df0885facb912799fb4df23e63ca7e97285aebc0848ea33a02df9d61ced5ace9b0e06a25b6afba3366aa44960118beabf0e40e73eef58c8d89183d3c91eeb6dee08317d69980958e6c3c56154a1ce37f54166e28cbe958fc33de8fcba6109c925496c36693324fddd10dd85079562c1ce760c857535528678e6d791ab7b636b40fae930e07620fba84c71e306669dac088ce80187379b00079e9c9df9a2410c454450b2eee2b43b943b8ddd4cfe82e714cc3f91794879dbe17e7de1095b1539c51b91e4d37ceaa664adacdc801974ef703088df19f69df2f1b8e56f4b96c2f0c0b3b7209c08dbb17cd98537e8a982a283f60e8f5829041697545a967847f60a0069ef69ce9419d99ffa3dbc4e6de4636243a0fd2a26b4fb873e9043477bfb4df9798b903a3387ec64bad854b51268ab56c23508c8f175cee88a705210ba3abac2e66cddc79afbd3759664e319d2315b276b9d5c0741c1ab64a24c6e338e576cd553824ec6ae22a65dce982b6f3f8694c89f23035f47dd5c3ba48a2b3f7da172021a9087e8129e7836ee26ff973b1f321c4593c477e1e702b6bc1a24a02d241387b52bf8833a2261dd46920f81085baee3337bf2b81d1045dc34730f09e679d23c86738b2bb05c9976d68d0f475bd6b6497b18c4b61fbc0285011bc369c855ec91026acabc7d2cf5667d41ffad97be3bde00f9bba9510e5915c621a89bd4137e4a6868852ba7453212e6604d9f3bd2312cb87321f126ecdeb42823103a317d69ec54e15b6c28adf02a464c5f95b607fd8144e70b4c8a451851492f5b40710bd31303fcee8cbc913d8e5ad62d629f3551d5c75b96fb0c85588f584806ae915f71fa5ccba6852ad90d7f16d9b807bfa931324eb983dcbf92b4bbff8f87229788bf4cdb68451ac0aa75d482d7695c63a870185580b4b1a5b2c47069c29824b8a73dde0a04e3bf32741a88fe2817a575d57c11abea5e7e101f0a1f38798714ddbf5ead21e3b3229e70bb311eb716605fcd2e2e5dc56cf60dab857af447a1a390fc0c50cf997a54d883dca3054d9c0f9dce35caebe18e51e5e0df551bb2ee9f0801b8f28c39d8fd9cdd116edae46bdd5a2f68cbce62b3a0c436c0a29f7a23df8db6d4ae645a3ce5a2b277978adb997e62aa24700e572f5b167c1fd5dc1f383de042070a00d20978ed589bf275aa6fa7133592d022e92eb559714b6ebc92942e3e95e3248faf180240a2219306116128012f9f3169fe08506cb657e6f37b8dee55dc86e66c3130e856b307252b71b414baba082a6d41e08b56a046d1c375898e869441ba553807bb5ab07e6edc0617b14dc2756d1179e87df2de4352b39f4995adb73f9167e61c2cc51e90f76520b76879af27584ae565cc9f6a2bfcca22821cc745f857bb78017c84ada68bdec02f414ac2075780ffd72f3982ecadaced1107845378c93dfb5e21f628e4a870d0051650ffef052d6da59147aa48239bd7a71db1c0e8c07c29c90084209dcb5c666241a57e577c9c1072b297d594ff94b31b5d741fb6b0fc20ffc8b17e34df6541eb62665e171f5501b0194f67f7dfcdd24e4daf21cadab6b2beb4a6e70148f44df506db1088407b787440141e3edf9a3cafc2109fa5c383ead6d45ffcf3ea6d2364117640184f3ea1a65f8f00e86683d5c22e63c632ffde5a349e8ab9c70c038a43959001f3a8cac6c747d2c36c4730478d1c5c18c37f529c854adf5e8afd965985dc7b780b7352c8e2da4f01b94e4d72ecd7cd2441640b9d54760ded5f9d144f4c634eb2f596a9db02b2c8dac8c40a17a1bc12ea4ad11bb466000f6e0e0053d23f8f8e003307625e10bb98533904c31a2c335410593d38272eeb525dcd88a38d66f74c62cf5499b849e48d2982a494bd9999799f8afda08f5c9704d32f3884d4212cf29bd096f127d42440f33337e1171cf1d17a6dda6eec134d01cb0fe247be9d10ed3cff2d4898c02419cfb572bb281af49b12b81f64d9a4ecd03d73584d6ca643401e21d5252105960bdbcdf8482486492c254e2f8519f704560b9288dc9dfb62d9cfc5294e3ae6b99f9af66a971a0d0fcf586c4bee9c28c9b5e3ccbea8d765a44e009b8cc5fbd3badca1bfd0f92017d84807c0889531b71880f4c768dfed3e3963b3f9c0bc6290594794c6eb3b436ef31494720b1d7ff7300e9d27632fd6610369b48141ec138da2a873962abf7b02c28a74edf4e5b9880604765fd648e6da8d8d74ad76efdd22fa01fed6cb8a43df0512897ca250ccc8470d832e67c72afb17f4a4ee6a6d5d97af63973a553ef417a179bc874dd71802854108945feb2c2f0b18544ee3f22dcc3f9b6d63efc247382969ada5d912fe2de5e0a5cd75b9e9492900e6dff14a10eaeee3b29a18927fdb91b34d3245ebc14a852ab57de6008be96096b5f4e9ccc19f8e096c311299b1f4a176524c3ad19b5e8a19a32d851a7cd3af91eed37b22a6624c013691533e1fb6479f78ef97c15f88b47866434834f59fbba3f6334833b7b14a3118cc4f26a69319ee6c970783f110dec1806b0b8b84ed8c146f9468ffe559dd1a6deac5f657fc025c771fc42e7fe42b3ac47f4b21ab189b09c9e97fa9511c938d81f76fce4b89f095a4987e13c86e99a1aa896cb934b9cc36a07472a39705413e8088d98b8c55109657de5d1df4fb83851bb7f2df6e9e9449eb6045aade956ca55322ba13aa67561701b834313e6f50f57797488c24097f7dafc380d6d734dce2c1729db1c6a0c33f42d2d97598742e097a505ba994f0b9bab8ab83c89b32f3fd89bf3a5dbe4b54f69ac9038a077375c4fdf71e9427bbe87a213cf8972f4f7c700cafaff99c053fb1d24081ac1b746d6ec96bcbd85f49b6475641372702530a9228c3c76d45fa5c9ea5f6d25714d94291d03d8f6e7554170b396f31f4051d094b66e62bc527028c2fed60e3bdf4e44fac5553d0f8997fee289482db8fda15362eebd2a5fe6012f1c7bd7e65715b9f2de3433d281d9b088cbc8e0d70ec6ef0656bdbf74445db0de564f7cabf9b6fd4f51cca45d6fea333542d816066e88e9cc89bca641b1839078b34f9c5bd556e93476d1b0d3c349b5dd9ba5a656c9a2c8e59b3c3ef68c4eaed660648c7642f58fcb69945de7d07d7b63671a69e6ada9f4f0513cdb992897d63bcfb415763ce8cea848a188c4f38dabcb8b4724941a371b5abe93ab9fcbbe470751fae7b6d087fc98097f1f2ff22f27c8695107a734604cffc38fc77f0c24932905fc2a3eb716c47117c9887b05b33f8dc2660dda7c592eda1bacb484c974b8a64ee2c3c12c59f57bd1b5da2a3a87d3beb9efdce7e58e078496a9be628e667e19a74332bbaa11c7573c381d55e6b94cbe468d7e652d148870a801bdc5c3a0d8e7d009a38a92edb4c8e2923fbfaa95dd1568131a863c44d12acf3b25cbe22b08cb1f654fab9ee795c59d344d394526c8dddd2184025ed14df065df40661f053b7d7cc5357910b61e9d20e3bd65619acecf3651bce0970093468fadb842549bce2d10226dc7b657e0a221720dde5dd23a563299a6ece13a16e262c60c85e23bdbf7ea6dda5972b9e731bf9d1b28cc7822ec9139b82a380704bcd14aa9e5e286d955da5993a014de31cfa57c5bb259817cc06d8b19a736d3297a36385687f9e22d1a4ac97fb3ac4feb146c91448b90bd8f4aa73a598452e465bbc4339d7557ca0133206f950d23ffdb5de8fac2586f272cb2c8f81a6a82cbef187458e8e6ab2f201295eb313ce4df975e6f66037ddc662533ed448abe268f810b7eae8663fe76def73feb032084efd90c83472011ea1a70144319f3c06434518caced676482c1661be6263e6637ea6254a918305dbb48b0fc1b64fe5cddbac3bd95bd291ddf393f01036003b6de23853ccd6b3067caeab24436fa81c1e0b419da8367770d66cb70c0edff1795e22a6b983f37f2fd852f176a826731ffc2001ceeff107dc8bf476f26cfb82d5c0f604d56e2419a85eb1f3ffa24584dfb3545cc1e7d909dd679ba5793fff88443d657fa524dec4a746f9ca9e7684588fd254a26043f06a87745a8a417d29a9fce9b43a232e5978606356056cf7d6e567d0b4fdd213a360e458dd641e492d4c8abdba11fffaf04f9d38dd66ce8b522d7a4281924ed325968499c408bf8dc84d94cfce9f2253e31bbc49530b8fa9501583c286809a64ff3d689192fb6e77bee4c077f58fe5482de1cb1403d808cdaa51e1a3336491c1216067f9f3f544783bed1d9c0c62ffffcf4afa49202c10bc58bdf0f2e3ff7fc572a8fbbaa2102ae8136e9d74f9c34c45d08e96361d10948fc3f2e552e8f37475b8948792ff99b67f6e0b299b1ae3617f5c0c515553a13d7694ebea1a58eebcc4ae8c52d2678974f26d61c7a7faa2699d1c85a077e0b9a58d03fa926f5d6156681ccfb072faa4eccd80e04e165b821ed059ed2338c16f4f0863c52df626da9c123f1c48e98944f82854932b7b2c9ecaad1619222a8ac18b53822ef3537e2263a21ba4c4d6879104e808fef64f7eaf71e72d90baae049564fa9d5490db60cdc56a6ee7d885e646025274546c3a6d4e436618a2324f5bc3c57b29b9bb3f327126ec67d6003c687ccfb31da4478ab3b6bfab2b30e1f8160d17db0c30cdd21d9e0af63536685124d5047cbf93719c95075d77215ab012102a438f5a6f98556ef3dac0e4e36811e181af120cf28721d21c4f8c880322a732160e7795502ad3c0324a927b9c582b1bc832dc6f5c29be7c6522a146ed3f23c62734ec186d72e2266318a5c81474e8e78f5a67ba3c7b99f7f4f71e398b77e030397ad54adad3ff39a2c4b07ca05f6f54a6a3e2a766d5e7fc333e8a958891a84de49fe790fa192d8fb37ee2adc9dd4e43e5b19660607f7c25d676520cb099d1de3e1280f91b4d971388a84337d35e657610f11f7a62bf5c95e99b838b26da642f94fc7b3eab6bc2baac2c32aa9387297d83b2d5472b7e95d1ce4990cdaeecab7b5155e32e3ade916eae600b32dda9c9af52b11f13df460d4bac8f78e1a30f48db0129a8d1af3680b976c5f8038c43991b785e4ff345e7b6667c137d7b2d2692abbfb3926669133389c4acd601ddf08c000e0823530204294949bf64c9ea6cb4d4cb184a4d534f46683fe7d33e845c8ef7ce29d25060a423eeba0cca41894f94997a64e6300c9102a90f77c54478ab261ee874e27731ed3ea5ddc79d4e8b75f78b44e143748458861405661c4426101b1d4a0b0827ec1ba73ef7a59f489aa0c3acf41c08cac90890e54e2cfbca102312d4b4ca91f0152a558a1c536c93b998de9bef10f5932a06edc71cf52050cbdb525b0fb2d31d6570e3b3c2605bbaea1b7d297cda8510115472c38a6e83272f04d5f07c4aa2d75757f374ec9e0ffd6f514a9804a9688db165186478f0c36be6a522d2c60030d21a29c73e88447e7fdcd0c61646cfcbf41e25fa50394d257992b66a57f330ff07db7c53d9564ea849d08da86b398ac835eae27f3504ab3c2552db6002b0d1681cdbf34466ebf2702fae82a7c2dff60f199b00fd17cac897cca70eccbc853aee0bbb2b3969dbd5d36aeacd8a1e5beacc90cae628ff382fee5cbb3b89d37d5561f71ebaae60937eac6bcad2791e1f1598bedc938f96d4f7e67d618df5257b45bcfa524745fbdffde604e50ae5bf1a500addf217a8289951d8228d8b9803c65834c8c4019688a13e23455db3d7053f580d42428dac690ebc7e5d30a1ca88b20065defbe7fdf322cb2e07753b5df628da2ad1a7a683a39c7127ddcc01004c63a3fc638629eaa0bce276720a7747e71de6543ef69e843f532c60bc65ceb57eaff67d3fe0ad939875131a37a03afb78b291c6597768b9c359f5deadb2e766edf0f2672de997b3f15303ad26a61d7b618a81f26362d11a0207afd7ec25a45bfebdaaeec4afec88475f9f331500c78c4bc2e5bca5956dcaa0edf6dc90bffbb06f5b722127f026a652ce68c29fb99d549e8eff5e6f1e5b9c4993cfaa69f8e3334077db8df75821bf5d4bca877728f6c0c192785a4340a23ac1f9182f465c57f255b6c8fb47babfa11acdc0f379a2447f7cab060029671f19a954e3e910650a18f690be497af4bbac0d648ad4493136a13df7b15a95d963639f9341123a2253428541b095d5d2b9cb472453068f4d9bba3845244b0512fe721a2266d12fd0ad2e63a4395036b18127775c4aee94eae708f9c58d6d5168055188cc71067afa6343ecee326b75f5d162cd2dcb4f424b6c3655e7cfa4cbceee00a3e6b58d1a0523966a3c62ba23a9aec8b3801ecf98ce99b7c38459737ba9facb7b03655e8d5e40a07368e964fca90c76d336dff3824ad0ab11b743e6c01fc6694d90b6462f581bf6ec09c111651ef3f5898773c7d4fb20217ef428b99ae5b985e1761c788baae98acceec1392c5ae75461e80f19715b71a14ed57c0c89b1dcb454f5ee415b4d27f52b68dd39132472b48c795eb1408f1a9e695b724936bbc5a0f1f6d664c321dc9c2dc18ea34be8c8d90e81fd6afbdc5a837d1b0d794fccc55cec99779adc3eeba7b9ed36fa36eec35401fbaf49a22aa156faad31a19090c1845bf82c3a4ade79f62a417f8460ef24573aef5927ef4b0bad2434c8ef5baefc71b0f0845504b8e9ff395a705978cdd1c96d9ebf2a94adbb3b432604e0be2d475f9dae3a0e3b910e3bbba4ee98d306caab8697aaac65770d4a70a8fd38cf70ef9a3d28dc0024e31131ff7d70286f60c3d3bd60139ea13c4cd777552ed7b8664225c429df90f4eb51e67d56e432e73af6c4ad0b56c35394b0fda78e0051fa254a22cef1399c20aa21436f6ec7eaeee1d85b8b8c26a3732f6ba4ada936c211b8fad90ee0078031e466144e1709b6082674119e76e80c88fd70e34813a236f9ec24a12672393b5cc75577ad58f98f8f99256defd4b5282c1e6d51e04082780f024c51f2c15f8c76ed2bdaf4afe89af9dfc4e7d583ff7a44f1badef21d86b4d7b38500b4f17ba39672a7b8ab2c2ee7905d74224182c617a2ad4dcfad0c6a6f688ea307eb9b2d1779ef1a3acd6a07ba5f55257e2f8e12e0e3ae4316611ac870d5c6dcaeaba45d73943dcd748d872b4474bf646255e4b366a8289bc5c7f43bbc4d1e8f74ba87d694b1763ed925d985232998ffcdae6f0e00019c68081a854d280660a1f1b1caff54be788fa7167131c1d9dce5f7ea4d0325e046da64fea6d88034ecb784376cf5d6d037519ca175f4dab6e0fd91b2bee24889608e3fc3e67677e8af12be4a94136677848db86cc0ae7f4189cfe472b5cd3c0340a5ebe9430b60088523fa4ac73d2d655c22699ca7b13e8dcf85ee39a52839b15439e7c21a3024c00ece0a9a9b765626833226be3fa8f54161bf9045b05b775dbed7de1ed18934b65655bd7b9d79a030b120d1bcb390666d9ad6289b1ce6e9cb2bbef9bbecb75d8db83ec176e6316583aceb712a4e31ce28ec2bf7329f80fae725999ecffe8904dec7c828206616ada34e6f3a9effc6358925cbc322808fa6283ef2c7ade23ba8a24fcc12f9aa1f8f2aeb5d6a6f8e0f407615d900fac0929f764bc626492298e904041191f34d0e344e5b57369bd4c04f1446977a026d747f52cdb1ce9f0de3715a4d8c0ae28b4fb385df5e649b25768801d4a84be49de2e8d76c8b33585f2e3f09d455f5c11a96b36676bc5d662ae762d464493928c5ddd92a985759f14be4f6b8d481976f52019551c427095b3320c1373508fb8bb3e1df25c7bfe7aa8edc59b0fdcb5174d0be501a31f2afaca6ca31447a2c92f43a2883420d9fb9272b056852b1ceaa8164efa1174108ef1e62028149ae9281101fc0b107526f5d8ecdd587bab4e38e18361e195533d9257c6c8a4c0d0082244af219f2890a35ca1262da492119febb3bf25a0d82dcb644ed9f8907ee6f12403da5efa6e3809f7cf13f56c5803d7a4f0e64719da80142c58a2cd4fa2ae917341066fdd825033c719bc39e431b84cb7bfc80db977ef542b472d6dda4df4eaba4be859b3221e9bdc514b60c2dba96d95327b1345c583b8d2f5701815d8b9a47fd97a551f0c9733459a83d500535b66c808e2cd776dffc387300f4584108b825d73738d503483eba82b06f7b25047a0e501dac7a427a436ab56b9400c7dd473ae4721567225d006cf5150b22bcc32026fcf311b1a232509a421fc8304f2f23583358dd3b81c8c2c0f4f289ae99bb53b9e4e84f909ec7a804b4d803d0adb70077cacba14488cf6fa96d7da2c0e0cb927043c112696b40cf91cea3fe973e1081ba87710e91190d3d92f40345ba7cdea8f114fee954a1eb9ec2790c826b2fd3a8d9ac499592581a125345ac30a28cfea409d3f506e4ea0f5060ef37185d1f2f6071ab27c7de90832beeaeb6fc6830b57352c75369341eb511a6326b9d0bb1e4cdc04d778393d166cace313615cc35cb20414bba5dac40d239d4a1645810a72e6ca7c7ef30210adf98d0338806de7986b92caae73b2310c9810d1506b51443b33b96c24e6ed5967a7a9f5b052369ed6d7d32c7ac9c6a6fb6d416fe0209689c73e5f9e7ed4ef03b66073a0eea6634c058e3254f130573162ff822b0c49499cc880c2c9908c118f363e1d2955fd53b5727acc89a3d83ed32a0392cd2d4442abbc8b77bc05e8ff67c69d976f2e41a75c35c58ac24430679922f9a201cd0f0a7f82b07176b6d98927879bf0cc9665967e95e2af942bf04a34e53511ae09fd3ff17811164368c704ea9c1b375c4431204c6e3ef8b81771dedbef53c064f8ab3750bb2aa8af791f730112f0700044a83ca715b9df98b568252e36d87299a2e19289cc4d39e3f252f1346d4d6f898da32e1ae90862dfb172bf3e7d76276d1f98e95ccdc1c3f18460f18c799488aed5fe39931f4e867400286b189c61980912b88575b5e9b45a9435ffc3e83b9de459b22a692e6cf59f9dbdca5e0548bce0cb073f4500774cdf09f2077b09d215bf30be5e1031e5c890983e4f2a20df99f315fdb37898c0d34bd7212dccea783fa4243a06dbe76ed3393374945af0143a25a14ebb91ba93efc8b6f066ee4b29232fff8023614fef44e29afb536cef013e1fc98e7b8457e2982e7ec59735c9b139c6cf6bca21d6e083e37680f1293bf4fd251e84816f1b6e03954b0090502b0894f0a607fddeb00315dd5aa4215885f70aab2e42251c5e560c0909615c4ef5164e336f0a23ce996148c9f09dc64495b249f890c9600072d629660741e77e0d6f0ab5caefa16eac1039fb4ef5bfc1ca9e9c447d147befacc5c2475e5489244134491e005faa129f00e96c69d537864ad05bcf7fd3db105cc5f2cff4c71c02a5205322a1e5577d236ce775783494dd98a696b367c6676a23587c2c3a7bc4c94134beefe301287a3442c098632b13f1da87f43331320a6e31d5f2e2408045c13f395b61b21785413fea9948422a4f6c8abb674459ccc03cb0c2a4ac124d71ecaf81455afca1086b912ed7a6c8c127306e66a1ceb1ed98372de56a6980a64fd1213547c57de5b1e9be7f02579a2fcb2407bfad5912394fe32a6ff666d8e19dcd2e3209f5a478bdb0bfbe286b4265bc74c10c175d2651f6584aea2fef003f1ac14619e0b765110c456e34bb61a4d7fdd4fc57e9dc3a99a167f557bdfa8b54b35bf957d16ecb143a2a88ebd984abaaa3449c3af5e4792fc59c726f8abae6c59824f645f4c459718f5b730f4bb62683cbd49ffc31211febdec35989fe3013dbfe2e1f571aee90062ffbf327db54ae88f04e9cdbd292b7b345e241979f4c75629f600b7dce285d45ba7b8bb05e283195be1d392be7754d6f00f6703c75a248e78ee0cd12c548c340c95e688e0a06ea1040fa531b215883f247b10ba3c17415ee62bb02acdc32d4ede3bc334d49e846043c7ef09e8005415693c33d96fe3740ed5bf2b9f40998e4aa4f1eff9d15fa0ff8f4e58828209bfec2040625a536fe90c723a0dfc406838218ec31a337ba539c9502852c82abd8f9263c24009d02ee27c89db42fde9d8c0cbf5da8a2bf394d51e41fd202ac25419344901ffdf377e3c683d7a713e82c914a189d8c6c0437dcd5e6d5d6e4b65154ad5aa3d0109fe210efbfcb0e3b7ccc479e6a7e38dc71d568ecff33dbfc24a6e0165c60b02685b4bab9369a361ed9ef99f76892ded3dae0d8012123b705ecdd23da1f6cbb1424f591359a28d2e446bf7b56aed5825b71247c3d84c7dfad4fab005e123b72efc6a1e26e6aa36bc9bf44692b8e5ed6411c6ccd1f0ad8ecb5b1bef31e7677cd5eb92ccce4880958bb4e2a5b7cc5f7cf7eb5a36fa13fc33deaf2020a6bb3a2f1649f66bb48d1cfe3b9a73c49af54ffb6e7d402fe0288860296e7713a15112ba41ed27a94e79ec0c93d1971eb42262b34553d7610536f955ce0262ac8431fd67cd27da124dce1e0f192c18bd572bc790db7de2a893fed9321978c18bab3df5f0b3734f8f55b271a6826cbd89f61523a56e35a758458f91ff03c8f58470f1fb7baaf60e1c61ddaa9d6f1d5b35928d6fc3ff68bef32e4dc19003e076db16b241cb425fd732af2d88d1a33cc4f9e4a5b5fd5b8f3faa896b5e47043956a3516ed10c719f177ba257eebc45e0c2cfbf7e9467753b49c36c93744f6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
