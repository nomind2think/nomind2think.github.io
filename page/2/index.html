<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"078058a2152adf098ad3391e4980c832e5637727235c7490476e2d5fa73ad328a34c6052fbc328b33c04e7cf8b2b519f3950c58eede6b4df1af2b97a66f8f72924808c59ae49bd8effd7ecc5649c0a92fa6940caaa3904bfcca452e8691efe6590dea2bc828796a59f0f7c7cb6179ab1c123b3559bd6dcd75fcf6bd761b493272cd227cb5d1b602330df8f75844f83a8f916ed394c3416bd2600e006e9568be177b9d1342c1f5116961e6669082e2dd98d5818a743c39ab07fff799cb109e8945e48afdc4e661a03bce3bac5607da3cdf904e0c50b57855de8e001b5d75ad01a0056bda2ae6fef96d7bf48c38b16f0dcd8817e1ce8f86a909639c67e263443980a1d296cb5a7766f9423287cc936d78381964cc602940fe2fd5136e1b86b0f72b474ab5510cd114ac55a6948959907a5038889751dfee388a6bdcf67470be64cd326aa7165cb132b318ca2d67d833c52a875d65739b890300327f179cecd9964de525001dc896297b4414d6644a6fc5ed2545c3fba1af6a8b89cabb7c213e4baa62bcccc6815d911443fb1685c2938d939a92ff34bbd35fdc320ad1df4589e59c9f84e45f0749656d77af3699af559fab0ccd38c84d39e037f01d05e23d5107919fd7f4b4136eef276930f62afd731dcd5c03ef7fc3d90007e45e9e69583167d37d960f4c1ac0682c70f1f45ea4e91b9ebf3da9b572c7256f6aa7f01055bf37f06617e2413f2af17b5c83cb5dc4c032f9946642045ac1a062689c1cb2eda8be2ca2f0f285689ed7fd2931cf133fe9dfc9e506aac2141672e2c0e0b5e601f1595f46bd926860ff4fa4319aae70821817075a21a266cfb270091ba4e97c789e91bc354312be4e099f7424b26fdc526b29ed06a66f2271bc82a53cb9334e63bcd04a5ae6bfa68d719cce676d19a9e5491424b7db95d211a7e817883d2d766123d532310c9ecfa49971553e18c0704e56cda011baa802433229e84c2ab8a03633dbe7553c4bc4bbce567ff880862532b81433afa78b58bcab64f7df1075b11d1f2abe35595197ac6c2e4e6beca7086c70cf0b2f247f1a8b67063a882c77e469db76688810c50f294c41e12e4dd8a4c0188bccaf908322f6760084b4101795a497fabd6e765adbb8cdcdbba912fac000fe650ccdc806913f5ebf5a09f55db73d314e1467f09a23f3dccedabc3ebcec0a179dbbab98a679d9de1172a56703b441cbcc33979870ec1a7d2a0f260507a988bb7bc476a1281492e98cba847ce5bb3fda83866d61f2d4c02c33305b0c42c242d28a465ab54873052b24d7dd9ccb908f4cb946d2fe090e2388e11f501efaa609420328d83a55af052d64bdbd140892742605c49f6076a44efc78cd4715630ccee3d5814bca62bfcbe848723e7e8ab1357c6de1b862de553bf0242efe79879a8295a76cee55f0cb08e46eeada604d77640c3c51eb04da7f07a3ca26518a5b271667ab8a9e0927cbf3395296c9b31e5cc246a47ca3b2e35177c40964070d43e416ffd48b6471098425fd268caf7150181ae23a1699a1dca07a215c4fab2e0ddab2a1c02832cd33fcc95256dfe25accf83a30180fc8937087a40ada11b9b1b6698031e2e7f5f8f95addcdb5c55aba2c735272b9938298a322e419402067ce55ae90a8b95af6e97487401a10bc6218ccc67510bf550ad7308d765c37facf2d322a7e21f069347a11cb505850f2a7fdcc851dfe08a79f4a2eb6d844baddbfc74a32bc153dc1b3f269525c1523cfd4c2b9e8b5828535198d4e8a852e97b61d0a1a92a8862ce82fadfc9975be33d3d22211f8b390de233124ff4c389aada48b8259ac8b064dc6abbb3e769fd440c81c2bcdeeb1ef5607f9bd89de021360eb3924f905d5252fd449f87293af6a016c0794f5c0dbcd6f2f9271c91278adad85462a058bbc6f9f5ee715b00a9cba0cb2924d090a4ff9bc59df07e3f68c7b9c96e3af84361d052778ab90c6976db3dead06a8496e941f3c583eaf431451130afded5d17000bd538bb03fde3d5f39682c8eefd63f5ac0623c3ece940573140bee8bcf81e793aad6dad8f705d1489e697a5fa84409a31b103e56c9f89c15e940e82544af0e15d43b0c4cb6124fcc2cfd2816bb1db0c0fb29bcca9a64edc7eb520477a09ad6f05f85c025f16b09190708c1fdc5b8c7a679ff2e63c57ef6d88f2a7e74657e82769c965ef844048da0a8d82856e17a079cb720686da95d7076c3cb87089f460502e27eaa9fb4c157c096fad70ca15c83f3f787f16d1557b58dc7f1f2b732910d977bb84171df696d55f3ef61716186fc8ab298b8cc1a6510889f10608f41a2ec589bcb50b2f4be4eb0206310b7ca395f2697022145698ecad439f49e776194e813df6b0d55f8023db501978410752b7647c778010ec374ccc3572c6857b99a9e91016bbbb693b3ab79c83799dc5b494931601e326105e784cc345deff764413209f1f0db7080fb73900aa77d72ebf69ee94e09b3236ed317861f7c36d6e1e9058cbe2b310ec936502774490176a2a95cf84bb5d9f575f198ea4b34f94d11f8adfdf5d11c4269c867eb37fa1d9e80d111881b6dd6594ae5725d317cdc4f2316ca119869777e710e992e27560ab1899aab01644866b1c9ac0bfdf9b9fa5ca8c6e241d03a60d3087c747a88c242d1175b545a515289087b5d6b9956fde277e006cad4bddfaad6231e35d4870d653445946e8812b0f83a7e1ea146ca8caa69290c9527f8ca183ab581e5ed77e726b8e8b75b2ca284fa9133148a2f49a9f8bddf09ed5be25e7be52e2c8d9179b95e1cc29832986b2eb8b083b7d40867f47d4a90d9967414ad03f7844774506c92e05d5a40f2094fd53281064caf245c75affefb3552b0d54eba2e40802d6c2dbad32ac2916133470a957f332fb277c0ab6de619f5f3da5e315a31761ce38f604fd553ea2904504e0b28a6403faeb45d08ae07750c13b089a6f55d32e3f22750c4a017814f55f377cc544c9b07517a8a47a06f78ca67b09a8ffb7fde45b702496a80acd7f8d964094acf5f9d8b80e343e5beba13aaf3ad77c0b0ed92b29536c50ad6f0f9716cb48652ddff9bb961adfc8704d984d9df2c888901a3e36694f25f0c3af8de0dca9d9ec41d380e9c8ec8a2e088b517a8dc44a0234fd75bd96615ff04e66c34717db08d1c88555e6339d34f4d0f3984b98970444fea7df6437d43954ff54c8b90baa9f0f0e7a42a7fab97b8286f5e4ae6f0a16d95919e95d7d5f45e10d4cbfe12a187041289a86449d378ddccc1d03bd4097f59de020f8e9aadc3535beb31953d16de0591a8fefbd0ef2bab6b8e95a9e5f2df93a10bb8ff0fca0172fe1e0e18b7832c79d42d44f7a3ec3e64bdca372936e9265584f6399fb92c216a4291d56d36ca4caadb4bb25716007c4fa06991783687a0a8d0c7da32a7ba43df6a47c5608b481c66dc875ad2e0c99a7e7b53f98c7519a9fbf434a955a1bb64868f9cecdda84545d1de9fb659d92aefcfd9350112e98fe00e8a4aead5218c75827ee00c194932e9456d4acca17ab66b4b81f7aed873105afec9a5a3ce127746607c0d314dfa9ab7ec5ffb95e71822de0ce6a0b1fbc7e3550cbefb1814896859b66e381b8eef569343b47cda55717893c38f939bef9dca0834fdddf08af57cc0e465a4504163b6ca0e417f83b6cd56810e5188ba3564d3b52a65246b4c4218197e3d0f3258641147abff0da6c972ca00ba78ebeb2051b01756ebfa6c0b2bc65b59cf6ce8b9f221201cd0add5f6b628dd83d33e27d7179f1459180dae31efa31f71233b2a2fc8a98b7301ed91f3c774130fa8f1a68364ef8518ce57dd07a982328d681dc4e29cf144b784b00bef77f13024ae908d7d354ddeb8d3e929c6ed41be6de27862fc4abeb89d87cedf6f37e7ba69eba7f71ba86239d0f33828554a4aaee202b2fa35713e094110b222b153862f17519c540a7a29b65b1a0550065bf16b7e3d07f3d517c6b6d03715437a2a3b46d85c62df2a11a252f6dcdeb77938fe030131899214b2002871c854b7ca2f0e553194a67cbbb1b0d59c702c9043ea6351af215eaa5ea151b9b1bc8d10080e3c7d67eeb988877b47a1892e2a69aa5f6cb259ceab71916087d9fbdc4398928ac5631112d0ad2deb7b36b11425cb91ca6b838d1b40c11b2973045a690d3192b1bfbdd1073d51c3fde10aa9ea1d39f8629cf8d5e36369ab594739d9c3977dcb09911432c902561519a3cee337c3606aa548932c5592bee981a116a2d1afc1b3e1d0bbd97b103d981d1398b27698cb0327956335d96a5299aba40f7af23d8a14ebcba159a61b3a1c6771ca77c18976914c2c2c395bbc6618f03bc8cacf7db622ec01b1e5f53f67525519144728f2ffe36dfb0495dcd8d5e1eb3e55d48972902d03513d7c28d695abb8363050dbae789035e6ede758fd4a8ac31a6601d3a716efd335d30b9d99bda2f2889e1085be9ce9b29c0026855d26ec268ec792e4278d21e0ab3ce1011eb830a3849ac1cfb1fc41d52d7dee9a5ea274a3761c30d36e24a1b46cb8858c5324fe3c94965177b682ddede3da2195a24efd50a2eed446c62210f3e1e05668e26d0acce31b055bd867e49bc94690dfb131dfaf967566af6684bdc8ca655e1b7cdb485cdf09db787696f82e2a8bae7e7ee7b7705dee071f3d3c9eda36b93c4dc781e8a7b0dd5ba3a098175643fb13eddb8c1507070e07cb334a35ede2f1023ba4dfb9e63583a5b13c7d0e4f0e64a6b712773116637ff7c21efc350a9605feae47df2e6f14cfd93f11834727da72fbbce8c85f2ba67623302eba5591725aedf11a2a8879cd642b19cb55f101657aed89b6feb82ce14a4326a075ab2af5b47f81a7ab2dd3514924f3ef7013528771aceb022711826fc4ed4596569b5a0700e64a1413ed7b6fb817e9e9d061922e139c08915da430d48f1ccaf73a4cb749a4912112cabbd394babf1ff5fe356b17c547be69e7ea352785ab00718cee9ccc5d7e78989a50e3c6c537173aea3b3ace13ad3d988174babd747e96035b77daeac7bc3c82db65b80944f57c041f6e5a7af0e845265eef3a138f08f7ef560c88af3187c26131b06bf2423ed33dd6d10978030dea05ca7e85b17dd039b9ce672816c5828505a90766b3accd372fe72ad4981b930e216452eb5f5175be4e1514b524d9e5a2049e3529551f309ba5c4f5b305dee7dcb255736e400416ed57a08d2ee64b7ce4daf9b754a439c003dab0654c99398f6e52499da31922674fd85fc9d15a2adc6c0753d9d2c6b8f2c6aa83a8d87856395d5f6de83c1b38fe5dbe24e8fe547a318b460d92f08e36169004d3ee6a95fd8b89bb8661fbe7d0d9d64856ed173fb2fd5bb0149f828e727906942a9788e0b04fc66baf58406419cfa66c5300a08cf48b14e79e99969c35a873c0b5fc81bfa530560e2edf3d24c2380b4ddde392748b78e59ecb97ce3d8d48d7a98efb341f63973e3ce2ff90729fd3b8db7c2a999341acbc9f0eecd1a32ee87ad072fab9b476b873437f650e434632a0efe4155a1b3848bba705f41c1dd0c3b631a817e65954d347fa078fa9b9c87c52b990b2259be5d69770fae23b7b72e154d042b03241ffd3e45bd161446487a84b69ff03eb21558cd781dfb7f6f399650f9227ac8ae50fed1a89f7d6e86bfd4eb69f368cfc1da770d6c0db4ddacc59e2496cdfe1e23e77b2e232c84316d80d77bcb7071eec58867bb5b7b43b1fba48f9e9ad16aa57f4bfb8bd2f0617622ef4c5adb834093de9e31d036f2ddea3c4be095b7478ffddb806cce2b731c202efa7b95dfc2012d1d0c8dec05f00af3d081ce9bdbbb08cca148486220def8b5a4ea2c1f93895be36d8a0d3b2359138636deec80a649b03c8723826727b71c0c78c3a971f5d2ab86f7d7862117016b7da2e0aff765738b5250f6a4a6b19ee532116eb4ecf927b5a930f1b621d232838f39de81357c6022eaea654b16d0a4fdf7fef44ba6ad24514d3854d582d8004912b57349e391874aa4ffa3f5e7348332a6cc823b5d8d3ade4a1005f5defe893a2da858d4b13bda858ec9b9972586591c74b74551809c6bef504155e7e2412e9beab6afead13037ea749fa8fb9ec1900d835241a0dd0737d3070009799ff3096a2755c6cd046a696e57eedfe84ac3afa272c97916aec52312eeb1922874fc7a10830f842b9a5151239bdffd3dab9dbce2f616a2b8fae85fa52a2e6525dbfe6d077fd2674651c46c1e921a7b021dd26bc7c452652e1f8765f26409fa64b5dbc9a0d9a40d8ea4f2b38ff5ca1d7a397ea5497e3b21f2c4aa0d5fca0c130a794cd06e9ce358d7e1f7b5f8fe78dc552c4504c3a6d291affa148405498c6909f4e15299f80fe905120f1b58f320f3af56428535cf2e8fa52a7bb7f576598087151ea71b4e0479c67da0f9fb2f82686f1f55b3458379cc48b31c33ef650df3a96051625b863964af1d22d7c9c6d76b41bee1c58f644eb420853d2411551f9cda151db4b9f62c500621502b33be0f5231adf5094ef2679fdf6db19ae7c8688c372502686458f588e608deb996110e324a1e4a98eb29bbaedf144a06bb4fff09985dab07367bac61f0f7df548a4229d92c2ffc808b8c6e6c4245a65f3e8534da7d334d704c6b39f111d037e0d2df1d75a429dd3b2038103f2a3d60ef2ebb1ef01d5a2807cd5503e2e085bc3b10e6b45e94def9a63b248530b0fb244c313c91d13e523a9c324d04b803d9c67f3e4fbb72fdbe3efe56356fe0c71c0c207233798be1d414fe7be4dacbe874b4faff237b2fd1a5a080202c713f581fc05c42cabfa52c44f0f4d39411bba7be8e218667169ead4ad7e82f88061edb34f57110dcd22c257e2616324b2c5e2b3bd46e77f3e4e69183983d0791419c429cb1cb3bd304bd8c9d36eae3838fef0fefb7ddfda597fb23433e52c8d6c9ce6095cc5c9583da27d8f9729c481f3bd06b54145bd838d36a282a4c7c84451f16834310e2a024bae1808736d4d97edc9d53de987e001016c2402a4f456bd2e48ec722284586735b64ba359c91e15534d463fe89d8184556f9d21d9e1a3d12ed0b036224227805dc44c83847372f979263e1c011d7f6e811af26d9f5a9f09e1340e3441c7275d7009393cf230b97e1240a763596dc531c10f93a064c91f0800d5e13e32f465466c6988adaff90204e221ef336068801ee09bd110df1d97a5697dce360394149fe9c429048c1906afeddf5f28e1c1d6f32f481e8c9c599b029ce768897ef270abdbdca290f17d1faa5e27b9990c10638d0932fab7f87b525d8be81063701e4f558edf86f25444d44ed6abd2d44c591a3e4062539792080c839765eeafcae193f6a6233eb19597d9ad8de4d3d7ec2ed2ada2135577e9eedb3b013cae0e6023a631dba469287201c629b2ffd04b25237414fb487348010ba7ea932dd2a7d991688f08d5827133924eea5868252aa655f13c42266c68356738350597bf5f255f3db3b8d632f8ac951fddb2985e20edc9b3c66ddf89ff890d0738a571e23ff765be4927877456ce81c1f1216c8fea96b3174c24698c45f17822cb58c4a4f804b3e4c7ecc25aa02c7fc4b6467542c1ea1bb4defcd26175adceaa0d80164c2fbf3dbb892db7067951f85bdd83906baaf229194afd84e31355ba002d70b6f049ecd9943f56c8533bf9e9204c4c85a4bb5491a48951a8e5876fe3ba1ab11bc2f2b403cd7e353df207ee002cd002f892fe36eb12f9b37dace56c6b993deec93ffaa1e29e2010aa10fa03b9bcd5c01b4428985b3ad08874ad745774f90740a5c5f47b20813d8e26c13e237ca95dbe8c9b49c50f8bab50fad0c6eb9172e9cea75eb7b7b83782310afa92aad429631201841c843d0f2f823b85ea2e55266e319ab379d9e1faa426a6cbd7a63345734d8bd40dae5d12eb9350f5303e4aa68aba5722c305d4f245f101feeccdb95ad2b5bf85dcbb8320475fd9fb0a61764c67d471343ce26edabd1a409f77a75e43a6978e145f67b106b8086fcee64849f6c9a00266604cef73a9dcce587d277b801226ae732b92c11d8da7e2469df0a65d15891e11150c98a53e2db22618a1188a8c3e456c69894a9399bbdcbe21611baa90096a659839a2026525f8778456c38a16ec892a0fab13cfebf2629d9b1523dc20654d83e78ff694ec1b26cc7735dfd3c1dee937d5fff06b378e36b382bc7cb7e2a2b301c14cdcc5750d8b08e1c66d2d08ba3ccdee7930fe2f95ee8eb10fc76cfe5ee91875e5d2ad66ea9bc8791b66df92013e10b9afebb870d807800817cfed897f5b08dfd6f92b2ae4ac170389fe04ad149447ad371627a890dd24a3d16998d7f08ac722ac1ae6fa4dc3c0e72e419cc14447894f7d6cc6e254bcc1a439beb2a73b84a006ff22d80f54c04f96fe16b76a8b4156abcea633f210bdc5532ff18084d452c938351325c84e525e21c8d9f6fc32124d81e3f649391e2c9745562909e44c38a5e70ae6f9b7d534a8f2532bc695a69ff1811c93ba36d07fd599a70a1a7e953210db7f2e1d30139b53bbe4d95c4967966394a4b53f59d81e55b08d4526c454219f15d5723885546984ea1c1f9f252ef676dd5803bff8c43073184562e1f86853e44bbd83e49d55a6033fd398421c526a711611eb8971083d206bd053a5685a783363a6011467b95683d5a5693a812f4a747b3cd81ba2de3a0f13ab8b28e195799cac76a47212c4da5e77f2e4a5e91857f978e83fa7460874bdc2d2998cc817513f5f1d62f67c22dd4ae9fe1c5bce75319d7e68244ef31a977bcc73207932a70a85d81636a6ac4b346fe344826bdf45e2328879885fdb9b9c92719b4f10c887d121a87fe33b7deeb5cf95cd658c29ae8a28980523431f58a4cc357c23ef74b36a3bdcc1b2dec4433f4381729706d40ff6448baa5740155757bb017817ce2c2fb31a347595f96d3c577f7a309831607147774b42622c8c0a9564428dc5d18670a8b3eb44ff1305ec3b2c4400cd61323b6b5525cc7525a388409ea2a7977bf78f04ed71aa38b2dc2ee7e7eae749ffffffdd2d08cce4bd3b49bdedf313ecc97ba90d8b1e3acdd54fa5507e8d419e689efcc6cd5a53b3d9c0bd632ba055ac12dc1c233e82c975f61cd19e057a0b4f7a2fd9af22829615524f5a361c90f8120569f1d418bc3cf0090b6d6f3acdfa793da7c21880eae6194052a2378605a9fa1587f63037376ce93ef85f4a57b6db0e53591f7662413d8cdaeedb6d6f6992121fac14fbdbbf7f82664c5ec8cedaa6c482b4de9ff9f0f1cf2a4e195f70406ec66c9264574b0c1fc38ef42557b39a7fe1f72c270202b1e9b2f8d73a1c0edf5e05f262beb1cfb142b181a661de29b7c537b3dfe4171a3d9228b40678499f09a0625e9c7dd07405210831d01a58dbe36b0d1cccb56ffba7266539634e4590bdaee073df147523f9c65601bcf0ee59afe1bacfa149d1d7031a57c824ad3199738b8cfdb5179670499335dd2a5339acd52f4f8352023b62449ba533e71d8b0e253d89710d438c104ad8c441a220bfd3511abf687f53de5a26245cf019e5c5efc83d88d69edd05ecffefa52de52ace2c7e57076c267eb17c9d7872353e5386f303796093f21413d8c084ff8516760d89f82c8c706ab254ee171cdd206fdb4cc610d5bcb534441a3aaa929b129caf3a71082e0c98ab5888591063476b7546075d981dfcc06c1445e747fb0976d7e73c35e39142bd28d17d52e3db3aaa6e2a99bcfea55016f462915a155cd7bfc7fa5ad96a9442e722abbd6a0ddd23bd24fd462d3ce811b070f0bc081c222dabacd9dc2f8cc2da4576eed1db113db8f03a8ca2bd7db7618cd61c4191f849cdd431425a88c45092aa62a18cf87b56a851e60a0b204ab0861e586109fae1db1f7037ca568c014cd4653ed3138b7a6dcb69632d34079860cc4f4efe3dfe0f2d302d23e09ba8173efe901844c40c4d021693973ca716d3e856f71e3fe0cd473cb2359b207b59312e0b54292b006d5798572e2ec829342ab90dc5dc529218988479761f14a826134a1d0cbb6281f0588ae2cde7235f4bbd1c0fd7b4d87980634f9061f38eed8434de737ee18b124a22628f5b6843b6f46bf4fa65c18d81a3f55857a7fcc7592bfbb5aa924100de94bdf1c32ba2a25b62ec9df407fb63606992a4cdc6009beb11aa0f2ec45513b5cfadeefcbc96b28ad2141822d41f2cf9d4cf40da904b6501d3e210edc38a4ec368a19410704a94d733466293e768c22dea6cb6eb1c3c5604c9888d4c0abfb88f5fec3a648c8b18843bb907ef0c171afbc78658cea77a06ade85a4396df35f1b3aa7fe67d746ed23c5a33b1fd843fe97a52d9b7c3ee426323febd16a3c1da69566769087207c20ceb318df20e63fa6356e2657cff4c8dca8ed704f43124a72df94b3f6d36b8c5dfcd6f2db2d4a2aa0338b28b4c40e4e7e0a2173381d6c4791249fdcc5d8de923b180a8bd54b6c4406766042014d9548371ad749cab7cb671eb15a5e430675664c79fdfe1b324d4bd5baaa9e8a33e1c3d44de7dae10bfba8771b6e8ecb489d5c7ad62175352fa289c4949d14f5f0bd696001b1513dc34df9717e8d85309d07b9eb0a58400490905f037565accd975acae15837b81ed78f7164827883d2bc71d746f548b832ddc3028703b03a5b4bac56d99bf58636ab7d40b2cbe555fe9c846f102d16f2a06ae2658711b0c4452b52dc166066082d13643fae3011ddd9d81f3d6c22b20072b09f8e0d4440dda5d5ef03ee49fa998d1c4141cf1d08aa49510d329335f5e4f2f51d7c44e6b6dba14e033e37765b48800ed7e788bc65153fee3c6001d4aecddc5a5b72b9e86cec8126c3899700dd681b413210af32d5296a2a1c78ff669d73ba148ce73195f9b78ad8e9420d6468c717fb96f684d423d444e157bf279810ad8791b6c62e338fa1caf587d34ff3a3e374f81147dfc9e5e56b932c0c22586fac97b0aec1a3f99fd2a20fdbdfbaa41f2fcc3e40a655502ea7c95cb761260a79cda72618e1f16d3df90f0fd1c2275f10272d797dd716274f46680c9584e1cce6143b130c0b3621b10b96335ba35f4a1f1b7f6d30ca2e658215cfc410129c18e6d48b8989172cbbad506224aac6dade9eb30a85ed1c77fb9b26924b157c9f5a937be86d518b914d624d3471a22b8f61d2fa00292cb89dfe8919b3a1214bc4e48346ea3a44c247f7f2d1544022dae0308461e71b21b821ef680f663b5471d020ac10437e54c5cf39201e4801b16673cf17f4f891e42a883987755faa50820f799424c923d18e93ceaba9975b7020a3d2c1b8dfc4aa6ff8beb08a6a5a668f0ee8eff808e2ada5dd3442a98b80a5d841ccd2412a30cf6163a379f7a474bfcda8cc41e12ba66775102d461cfb81746ffab9ff09e6f2e7fe33a392fef3f22d835dce08dcdec936d86107f207700cfe5a18af7540cfe782594b6cfe12669161f895154caae5bb1f212bb0c3b168dd33262efc3ae5a591b810cb0afc978178fe70035b10ec906923682670665585ff518884ec9c61d6f11d72f9df7c0d6f779c0bb71b3300813532dabb6aab5fef3058b366b12b4e670ea766694154dd649ae8124a8d4fcfe3e6bfa54b568d0e2d4246264acdd895f359cb7871b51c03a3a3fb8b3d38098923a9bdbf1a6b24e5a54d7ae336ca96b6645777918603a9e2a5429dc03cd37bf3fc0dcace8e436878c4e00d0a9b86ea8b76f22d58c135b9d70785091ca913bfc6309099fd60a3ff6250ea7972c7606000d23edfb106b3bf258cb350e2dd0d0d56583ee259f733b5902c586beeb0434fdc6e9f3e3bc90b046c60396c9a6603d0ca1a648e2e0738653c23ddd35cd227053c723f3b61214955e5a027902ad70658ffefa49794befac1707d54e2777f3c5f323a0806e65f1f43e5069996e93efcd372bc3cb2735e784ca7af271689aa9def313cd0f9943c1a6ead38513d5684d83dc3440580a9b8ced3c913ff950a4d5d5f046f644bb406d47475af56da9163970a5493c52fc9a23d751f4f0646dff8f61b3887b7564e34946a9159b7c919055ee99c254bcdef36cb8909f2a9aea0a84761a7872676a105a0bd995e7ac282670369e5fc10ea0ac2da1107889d8a50ba3245fdf09f3bd3bad7208ec2bd8b374b7ec0229b2912c0a208a688189b75f48046793d6a650bd684d05df874a4bf588576bca78feecb769679366191679daab0b33455bb95fbd61bd9219c93c038fd29571fc9c0955171ed91800e1ba9e7c5ed5bd809a266315e1fc6747fffa2f33279b903b00bddc3e53b52c628c6663d8bd5394f0521fd42185a85dfbcc2141256bf320a33cb453b9a33265e602425d8d35b3254d3dcb191a676ba021cf567f67c4141d37b8b7da19b1d826007720193621fde5f7c22b202642686927844ab889b1aa8d2d48ac5d65557cd10b9b865da774e4dc2505f386ff2073b9e21389367c3f63fda3df138a52ba83e19dfde56b1411888aa620ded1717b2799fe54dcfa6c128994968e05b78a23f5bb03427d37762bbfb5349e6c3a60791b19999a19974d8f1aa51bdb6e0c172f6940484612561eebfd96470297645cc62dfec105cc3ddceefe940d5e42442ae0b4325f09228c872015c4a732b78922a5998680273d2271e766eecf2c860309a86017117d3d0d88911762e020e5d3c12d35942ecb511cf33c9a61c0ae05731d7c72a122a1c9281431eb104ac7451e2eee83ed30c469ca050f01464e77852fd89899fcd5a1a47254bab3a5a65d64cc5e68ee07df13ada4c21c85a42e750283cc40c231794f7127ffe909398e3161c8bbb08528125def521ddc80b0974c0e2e5e8ea9a1c1651db53ad49f725eecb3ad62ea32a930c63894d49dc11f7261002ec9003fcfcb26c45d3a0b800ad0b6ae8908f23efed461431ff53056042ea76f28a82bfbdcedc846ed11b358a22ae55c94df6600a4ffafbc8cf30812e4742a8e54f1196b733ff8ffacf2d2fe3932db01ee16c78fbe0cfa66f409cf56ec7577c2b57a402d9170bfdf3bc162c3eb8ecdacc7f8b0e4d6a97b4f750923907c096fc1a89b8f7ebe8507e3b9c6ac865501fff33ce5a095cb61eb2a742f128fb6b888b371eeb59749e0506f3127ef8d0d92ce259dd9ede40a7083a341b8885aea21e56446c8377b20cc92dda20b308fd7310bfae7e5b151878bfa2249e23070fc37a9bbe475ed9b51223c8f8a005c1f5945bac96d3a29bc8271cd802d8dcb8becfb2cdbee765ff8b44f8724a1118f39a7a7e3e188ea1a2dc1bdb3e43997f2d71e820ccb020b237469c7cac177d072355915ec742c4b5dd170de9037aba8f2353a160c78cd52470a41c1896436027ab2452bf188acd69128f5e4b084152ad6f61868f276dc1f620296d4739e592bb580d8bea6754d7570b9fa1080924c42e275405ca88011449a58a1c9b87c63d461f3e51e120e8ef060b25f0bba4dfe3138d088a9af395e96514bd50c1d228a663efc4a89cbd6d106fe2d2008f7b81ba1e89cdd7a1a97c40b8718a83f9644a7cbfa8ce8c436c2552006b377ebf4d67be9224a8423f8980443de906568a9e29f82ecf81573bf9358cc2225c7af9b3a2e87bd103bd8b2f62cc3021222106463107256242b43b7c9023eb904a27ba1b4fc1dd20ab3bd42580398578af11097a4de55773cb10d0c9e4c2306f4585ea8c51ae22a7673f77a730022c33e647b35682e47f7ba9977b1dac476c03180d8fbab0ca09468bd7c4e6970f9c0012db8e0a124db0ef62cf022d65e1f8a415e0b3c4cc68e1f689af2c9b5fb3895d566b870553bfaa1bbfdec086fe63d50a7a662e95b44f850e1701f73e1264a92a35eb5bfe47bdc7bd3806fceda5f8ff6b713873c579fcb92eea9c1c0f3645feaee4ba1f56b3543f5c7eb0f69d9ab38db893f233b9dbc7a588b008cacb3bc55b2c1dc90587ebef0851b37cc43c8d8000183c6e132abf6d6086d47b93f6846872f03ee5c9c7c0a06aa2b14b1850519ed5f1f92d7b21370406679d0860f56d6c20eeb332433b429881c6fa7d6767e24c98903c34cd6725d272637dbb239caf63e9ca0f9130d08aedb2be6863da6ccee8f5d2185f4d37aeec545a3aae043f050f1009aa70d82108f8c2253fd36d279a5ecf99c63b7169b39289b55eca7ff88f03fc59cd46754187923a34b636811803375751cbf6e2dbdd0420b0c7ef648feb5d347e411be5858b6455ca2fbd01638324b69dd6493d5d4ee1e3f1bed61a9c3eb703888615ad4038861263c713443873db5cdd37c423bf5c16c86a4c6c55845f647e4c8bba52a430d8224acd5ed0b1253a8ca5b3e0853928751c5b9df49d97301f862c37549d50103a1cdb1b6adb42d75d61fbaff22c3a7de201881a706ab23fe823d69e21426069849824f09df04f27a9e3ed2e53686941b445034dd73088283ae5ae01ce49a16da81ddb308f5ee40a6a05d120e5033e2f6a365265490d3c11d4a5bb338d4a00c823f51ad45cd729728a347de699e78e4f3ea688bf6f664956babdc1f937021116713dfc97173b479033dd96b6c7be0dd4ea3f6fcb4d734ef938db3e432c9f4b65f0faa35aed68e30215964cc564354dab60c2d46a3d5947ec3addda830ce3d0adc0f26b575fec3df6324cd4b49b831659edc06713f194127b399057e542b835eaf3e071dd9226fe730c28a1beacd24ebd9c3269f6be7f957e5d18989989c1eb5b67cdd32c1b4130e04c7f5d7525524db4686ebe32f8f3e6398f22800beb00fcb302491a30b315ce950f25916c09163cdb6d53f3b3704cf8eaa2c38e83ed508129d356f1b1307a3fa5b24784c52cc81c5c824eb3ba1de173dcb3c0d3218c22f675a2d1c39bf0d7a3162f4b086bd27fdc213218ace6ee26733df902c948e283b8eeeb5784bc79b244bccbc6eb34b64eba08071be52fc2c81c7cf48db001550d67ef3567904b71c884d080f8f598b304085537a44e51177aa52077dedab89596d6038065cc3de73021bd2e06d168cdc105f54d9d00c9bf74822ad42e47e56da0081b383f8a0ac9b30591a7e09596541e28555b43837045566e413d9bc5afcdaa4ab2ca9e4aaadc7d107693de60ea6cb06a362a56d465c724551792a9617a115925aea6353a3d593dae7f22c562bccbdf7eb0bc1ed5908468613c0158881fdeeb74110468672dbb25d713399587eff7610fe7fefda26f731fba6978d1f6acfd627295be07c9a943d9f13b7bffa35730863ed137ff92a9d1156c0d07b1847c4c707455114c9c34e95dee603f7ed9427bb9ccf4d9c43e97bf0168c3660e56a636dde16888a2dfebae04a4f8f3964414bd10a6b8211413defd493a4c1ac1ed424fe891b490e9df7506ae6ccefaba3f09880020eae2f46ad9acffc4640940739542898767b57c1b6ccc94868cb9aedb7f3cb823e856faa5dfa6c6cbbc87ab647250b514496f781bf457a01e8b0d690c8ab1cccba3e118de545398894fe92b11f4a5746bbe04ae9713a3b5ed522683d54cf764fa904141a27ee9500e4a7321c40c7fe40dd066053efae88cf7b9891a06cbac4c275de9ac3ce8429350f893755bcdf2fc7b79c8d1d566faf56ced63cfa02ffb06bf739398aa609714c27b253bc08268c63cf774374720f1d89fa17cd783a7608bc52a344f1c339bea4979dcf66dcc4dc82212b9068b2ee9e7dddc40ab38a856024788e358ad4dd14ea415c4270268b940be1a1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
