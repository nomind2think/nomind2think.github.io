<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75d60278af3d6654549cf4eeb21c5dee5548c6eba38b635f644e07bea4d674199a3bbf2486817bb741128c83726dc7e3886cd230f2237ef10223ee114360a2b4156da8a5932c8877f1fb8b0ca11ee0a19f56b59e1b8d835269eb065b6f5c580e4fc583562c73eb8d97d9982567a68c8612ffe45411bd0d87a9b3344c5d2def0cfb913ada90b7f32970854c11755a263e3699e11a96fa4549d42942cdb820793a6390f249301c4a40ebe981ce8d1ac03ee3fa5d64f4c70da0ff172074fdf7339627cb747e20f5b88260da94684336d6b38c87ba0c9f3ffe8e435f7d2615a9c9071cdb2e18994658a9b67ffe1de206c1a50dfc014e3d5b5604886afa4cf3a14603d0069c8ed4296f8b2173a84b84db0b0be17178715145699e707970597d753f9cf13a65d8f7b4094cb135a3641c91fc5feff342f2f525e492c24767b9e88cc4ac19c40829ec40037f728f11c22c50709fa8d9fdbc4bb3ee8413053e8d769afe4bc16011714259d45ddf3027cf518d414bb4dbf6e1314bb4e43640fd1e303e4bbabdd3f332b2d4b565f0a980f7764ee4ca66f165ceef1c3b04797cbb3f866671a323b796beef00ab22e0032c89618c6fbb6c96a754a7fa3816483d9f147f98c393626d2c50168c67a53feba6f9e5d780b4f21910f4bac290e3192aea7f23b2e79103a01b09c48b3726f510fdb47814929ccbc1a27b5b23c4cf1c87fa151b700938edf84160d6ecf155090628c9e6b5c59b0230c86d365796510a2aedb8b89f283397377daf6a9c9f30e672d162d9f3de31a80f91d37a1a6f56e733991b0c69a33c5250abfffe25aa85e5f27e22d3161f0f1f90e05d818cbbf0ac685dc79e7e8736c293c2958a6e865f09de15c3e572efefb0f7ea8c73b0cc60a86950af8b9f4787eae58387f902e301f593307736a90cf87967ad7605e987f1fc039aa5c27addb7a5ef0282fb1586e19b2dbe1afc20cfe1da4cd9323b0dd7c7d70763a69157968c1f919ebfa307e50482a3875e1a017da350582386360a434f076a99eaaf8f733435d4df563c846274a9cd775a1d370d8acdc614a9d9375444859912d211fbf02b12291a7594f35d37e43b8b161459290df979f6ae1151a695799b5e915251d1823b858316702829747990f226cdfd7c400834abb6bba2a65ddfffdb234c32b7ccd6ab0c01298e9cf0ba9540553bb101d1f0bf116f31a5eb5b2f8587349e2fc349551851717c91f3c070c579d5546b8d47731c1eca3641dbc6888dda5480735b80d8eee6a4ad979164f2745b9cc26625adee75023e6d2df1f7033800e7b086977c37639fafd57bdddead74f3fde2fb53d35842dae30ee359263ec955990d191f7d5d8882445d6d54d03e1dde202cd104c571e24b373c0c73a653c80d69b913ebd247705440cdca0bf485787f081cafe9c654e2adbb3b008441400a17786b1779d948e84cdc4c8cca54195dfbe315633f1d39bda78503f54e23546b96c7dd5b8bc949f9acd9f5f7f1f3dcff6eba695dd6fe63377a30ff3b8bcc739d7440a396d2b52c3f8bedab8370a34811a5bcebe485cca73d65533a194830e52c0feaa65c791da7cc69073de64cba7a66ac3eeb02ff165fac6bc4c21bb7094104668e6d69d99fe8d8e35d45f413f0aa830bbd7124c7312949787a8790738b32c74a142d93509a06b92d12145e66462624f8272fe6df592707535b6ed424c01fe032039ff6da2247866d9d62c19b36091ae832b32d468575afa445e2f96e87a0957d51d0299a7f0eec16390edcea90d8692796ebe464a303c2a2d8be602f4d5057cc2a48880dafc67cceb41f9299c074814742023bcda59a8a74eacf448d16209c1e342278dc0fcad09fcf94392f3374e3adbc32b4e4263cb0c96061a0bfc1dff28ba7da3ead6fcd0c8c4be273e2320361e20594ecc1b2dbb4d9d0dd5262592cbb72baaa3b89374be9b96e68f5c4bda0ad7b5c621edcb85ab38b354c3b990dc44599452463236a75eaa74fb2096e95e55aafa62c7e389c427505297f4a642c06000b476161be324d0b2e088d0a2aae5bcf1de8374c90564c12837eb41eeca0e628086bfd5d94ff3c70045c6b190839c91b7173a4e9441df37ad2e5c205b59c0e5ccfd07341669125d78d0e9eee76eabbe082217ea3a488632d1a38871d3b0d781dee3f96aa34201280d79a18cb15a281c8ee52d22e10cf5e212e4a26c764f6a5785ef2b2daec76a76442383e6473a56921e8078eda242c600c9173c4a32c94b55d56345ad9584ef71a5aee9fb1389645d21e6a07dc555eb601597de55417d928cd1d4de2773076cdb8bb76c6a0ac7120e3913f911035ef9827d3ae7bc47495e8657dab9a17f07da6e13e399f53038dea58458b2faeb058574189746f298c373f7e32f4c33aaf7399be0dc967c868fd246a9e8b4ade90bee6a1c1e080919dc176084cae9494a47fe56a61a7c4465968c4c58413a5c115ad576f3c95735585d81883a8a0c6acc8c6b4709b42496f7af19d2eedce6a7ed40995979da5acf1796513a5e63ea0c458b9a1296b8ce4b67cc2a26ada730991264767ae53cd7e602112765e72593ad38915b5fd370a3fc7c3333d1beffee40a4ee181baaef5dcb7cfdf1397f696de6b14a63c62ec78f243fade1d12db1333cb18cf4fd6b8691636592fc035a3076d377d746928962d6240c8a89b96f4babb52a98d56795e28697e9d01f67a2fa920df105da1d7f3bf1936f835058f1fc0fc5abf7e36392791fee0d5a1a4d1b2d09e4ad733e7d352e1b2f188f53972452b49ed411a2f9ba02ee7b1a0eae10f4caf9b77e5342c993c482b2113524546353c3ebe8e44f26a374ad645cca0b51aa6e2c38d3464a02b0499c653334959ce10c69852c9c3420ef4a0636dc6e7bf1fca42d3351353668c9391c2be07dc7e328b807dcf2f1e746493744a42bd6e63db9054ec690ffbeb8a08e8b5197e8371e2af6510f22b1c7c45372d1f6d2e8330a045b0d16a923538f44f0b3ab675f0ee1e41affd6fdfc1a177f30070d8ebf0892e2a2c623e21f25c58b6a055b1a2a71dca06ab2de6c924b9ab9d89188a3ebac73aa54aa218c97800d7e4e10fb0e1544f0bea5b0ad94c17feeaacff1e5fd69800680704b9e01c487b7c4f30740567e74b0d062db79ee23ec5597f721aa9fa3716a70363f64bac4d6e26d4256b6b184d1fd1c8bda42341bdff8be65a9288f579419ccb325900401e883dab01af82a2e00e3e040f40e1eb0180d94ae1e3e252e3ad0734825a5aed6727e9eaa72865b7def7d1b1ce7b873a19bd32fc1a21cf9d33386c09ec9794e4bf7ca975c5ce50cbdb8e54491ae91b914864964d6d8a360f1d8c6c1f46e052d9df48e865ee427de64a323ac1bb5702f210439b16d4d55d8fefb0260e9922564df667b875684be827fb483499e2b4cd2506b2bd9fdbd9c232e834a97f4f448f87fcb563c4b5b4366f21fbd5a04767637d38a5df63030ae52432615f7f04029a009ab660d36e7ca13d182ed721f61248cddd0a410b24e926b5bf55f584dcdc5a8661cbdd978aeda324205f4e157cb6ce0adb298dc336f0d749106e11234e1a143532fef7d87ce17ee6490ed02abed6cbe1bb074e71e09691a0e2928f5fa43a3efd7142f99571f1e1895975a1c93666fe026807b1c84fd49c2fea41ff4e6d2b9153322026ae92030a924251fc9d38ad91e0420e28192da8d3a85f62508a6b8768b4a2969df6d4c95f2091d5d6ed6eff5867cf113ebae121a25b053358712de1fbcbc7697f9232fe76c4631a60aad859c6fc6a398733a2023e7ff466bf932bdbf53e857c55571e421b22583255a345b3abc8223c86de781dd9401d34096ac16e4ecfe4905d7d6a6e4d4bd9525b9bbda4cb87c47934d3285329e572ee9207d9d45d67fcff65e530bd8dd0449380af8fc82c3ba3a125a8967ef2830d40e586166bc6c2489a85f345b1d43868654f6cb6f9d722153ad2849b10485a9ef37151124c1553b1e020dbcc2835da061c75d1b9ea696689d49a796502faab15ab87173df1ca06290b9cb0d1b0e1a1e3f1050cf70e28799f0e32092064567bff643f0732573dbaba0e7ddf9688307ef9ad37686c15a647be60abba48a84a9248b18df9e19663e5416cc968a0847d7fcc15e7ca70b2d6a9906e311860930ca7ce697ddaab8c82c229b5b36ed76fe3b7e4ad0c9b4012d78ff912edf016afc3706885de4f6ba7857f47fc14fac08884445fb5fd0b0c82be4724ba6d77bdbc47a478c7bd3ea163221a66ef5ffe13adc6b9c8ae1395c50e3cb71ee82af61adbfb92a47907c197c67b802e373efef46e7e3d9489ee47b96b262f392da624cc0950acb2da9336e5eb89089aeadea8bbc9fd37f478db517402ed069496171b62fd037a69a395bb10eb312665218641a8861e6a65b1840ced6255be43094aeca387947287bc60aeacf0898770eceeb3aeecfd31dcae72a89c2fc5146ae54c42e8f4e7bbd759b93232daedaf45cef7a66da61102401b024c309cac9091b6a22530408e4d1bd4fa831e6589b9203d1839ca22992fe4bbf7ca044d00191f5915fda1e06e85a12c43a42f2ef47eba15a83a7cc0a24077729b60418a4a9b8027a69471384f7e76bdf04a93dfe2d3de4447ef26beb2cebbb894d102474583c92fb583926d61efae5dcbbf4f01eb44b79ea0e40631d2988622fa1c480ca1dba4715591fa7101778fba9dd76cdfd7254c161460cbd48d1750cef7ed0618ad92451793f862fb9e5cd9bf75993302b2dc4e973facd8c0f74f9ba8725ceef5f4984b46b8405d14e98e15e0a1e093c182f1259cba6873358fe930333036e2595d8c60e766699dc84d7483f1294972a746336bed74c9edb780b396cf3ed6f0e3a39daad31ca93b72eacb3193e7293674934ef50725d3b6fd3cb8351c350064f8de857b4759b31e4eea559706726c73bff1e42a56d6a1ff1e2bf2c57e2c81ea9fba163ba14d06204318d904aa90b04ac983ffb460a7afcafa973d039f041ada23b46ca7488d421da454e2b9e67c26515eed21078d408da390e9476cb2e5126a1c34ac913cc357a73a5045e937116bbe943f4decf688c0c77dac8177e9113daa792647c564cd3308b23c4c342f48d6d4ca87166fdd58bbd49c6498389b47b2053e00c102bde4b56a4079d0969bf1383be2bc83b2fa19d814d25b655219fbf485a6becff5e1d4ea921ed3a8df6125c126331270214e208d90f15f0ffd422771e2cdde53f166d5d73025383c530b43c9e74c97d414616eb7106562452f918a3f9ee401412462bfc4f8d4688e28e7369336625aed0e102ddd990543d7ff47ac93ad85e23a97e5ce1ab569498b0ec874fa276537dd2d4115f01a6b5b7f544c451226b334dd4a79390cf581ae833a0fdb04ac2eb491106d4b1e23524903a3416a8f3df37799b1e59af9226c9b2c1547a3997e11d8e29bffd42a27c090740e1be2e8beededf6eabe02c65d68912d4e1f884800f600f846618cad553923c41ae4246781ab070c46ca4bf8c02fb83c422d5e1d2593665160a5c10a828255c17ac296d269f337517e46e5b1ac322b995c81ed88e9fa8027a7c9870bc5fd120222f9bdad1f162d6f2cd17ddbb59bc26e38073c3b2198e4d7805618edbeba764d9c93a2a053cb2b72fe676abecaf9a33ae110b93209ecdb7a7b0fdc2adb6779e53f1c90b93cdafb83a3a84f28d5b9460fb054eed245312ea8c29f6858ca3e53865358d7825b94dc3de57353125bace1183d553b78b570632a063d232307584469b19cc55e9dbf1333fb7a5e3f4131f6c21eca7610c6fc3ba4ca9419fb2fb7821024f9a798fe801b708d637a9ca99e32758d535b5d7dc13542b36e06209412a9c6a4664c917059fee7d17e47c50f1208669b6487273e5d6506440b0a4f1c6de8b2d29071b94a94bd264955b0d8c058cd05ffc3e510e0e9c3c4906787c47bb8659f50881e805c293440f352cd1e88070e605b934489a3abef5f651721790eeaab97d91ab53d1f78c3bde1f95a79b8b47448df2e77a08a95738cc895a22582af37685208eb15971d323a3e2b567dc87c2635e1a910c1586617fe1dea4ee6e08e92ce3e5307d548a6ba1d7d21f998c4f1fd254644a1c2c9d05e7f7cb8efefc83f98f765806643d6c5c6a988eb31ed4c60d80197ad248b71dc03f84a2cbed1eb3d2615747e8e9442de5e31540764d25d27c81020a24f14fdab41ac6b8d9beb56ade302da022f8d831a7b28fc6a631f8055df630b12d7ad43cb320302196739e491a2e75cc368ea7992c9a0e08f7f9605883050e71a7f8db7f64cba7c044e5ffc32dad48f1cd294a20cb3b36e6a7193f19fce52886d4e0b3593cebd02bd0572b53130a5c2b319f25e4d8455ef4568653f26219732fdd052f1cc7a1c06f874406c0f36b15eb38401231d585a88cfbf46855543fe283d321ba9260a67e8940b0ed17c1ff62b88de9d9787a096cdbec08cb952f2acb580d389cd0d466e4302ed994dca54f5518449b8a2afb88974da9f32479e1615393bae7f8567ee26469ab87a277dd8127ba847a967a085d7c8a625be070c957194aba721a4a240f79d18fa2471fc653dafcf0b243d09e74d446d1f197f6161c7a663397e177036a77abea04c5b19d898cff1170f79f112992a92d7b9131b245d11799901532409beb468af5d98aeede31e4b403126d3a562c970588b76a99de70d0784e2cc4e94fd2a3aba0e9d474e5e79af4ef92c20a4f3a8bd9929f158292537ba067f2e44faef0c9085d49edd06b4d44460db73e8ca087133c1ec36c3821fcd28e3a649cf80d236d98730b71bf982d25a2b42e3ca8e23a7f8284ff60429d299fa9368c005df1125a7ae2c6cc42e3af45832281bf83042184ac881b73ebec711e62efcbd8216fb38aa0618be0319734e6a21393dd1b65b9bd4f24893f7ce1911a295dafe37792cf4bd240ab76845aec9bb7cad865a5618d589f599fc5b0c788ef919581271c3a3a2f5e37a02c8e23cbcec37d6c308ce7362cdf185abfb2c001a40f04052dccc789a77a6f9d3113476d87c33bd4ff06db84eca85491806edcac377dbbac4a0297c09926c9f62b9caae25419478eda170e8601b102c8afba6d784619b414e0b0fe9db70c569dbee34db34bab85c54bcdbb51b5855fcec8248133bed388f37b85ee87d3c48cb67eb0e0abd24f6be030c8f8b162c5a9250f496bafa0a79e1aa7be8e27a5d274ec78fe714d4fd0d16e4f76b6f2e8db7d8184aafe391f5640fdcf6dc89211988f978d37714431ade402b9972a2d5b12ba50e3149e1501c4c7963f50dd7a9e920f99aee7b4310e9e93b2b3bb955f8952339bdf55aaf6812f8ebb665222a1137b21283aa9206323b9696f76fb595e3976a5eb15603b925ae485bfc34b56ffe423585422179bf6b594a146ce31d0490cfb1d1cfc04908512d411eb36b04146101c2051adffca899d02351eace54af2f9fa7bc9b95aee06530f3c64170913baf3dee955cff9e9b7f18d92c71108a265f2192c6e90b2fb770512209e598a47c7be44661cbc02908dec1c73860b08d6bb61645a808d7d6f51f4d20b8d5e6b09bbf7f7d0dbc33d540010071eb3c58bb0a24367a8b7afbc050cbdeb186329dc18093aaacc11bd7143c168ceabd3114d74a8b600c3d46d1196c7acde48b404d6fc12d78613f33cf923dccea025674f4cbcd64944129519324807d7b925a03190ab5284ee2fc84b64bb1040532b7a99718e32c721d5ea534bc53849e5ea92e65e42ceb20a3dba4f7fbaaf04016bb90b1617dc38d0134c90e88f796672c976902b65ad8233b6213104d8839a19479624f064f950f86ef49205f5948ef65490765b2e35879621703d1ff9819d37e1584374e2757783eaf9cc81c59b7f084c9932611115bcea40889c21860317a9dd84d8451562c005a924f1796940edd2ad8881204857496f32e65993bd70d88228476ac4a32f048085c144d146b07436fc95614a9afb2bf570088aa1fc0cd66e82532210fd6f661352d57f2c88dd74a53825ce6ca435f186e816448d078d23fa208cab71481717c4bedba602c49a2b99423b41c7b614812b006fba626111bb0758916c60f9e2cc340cfa9a24303458d3c9a8497b7cda7dcc596c4a03fb37132cfb9073637c5d2492117fd4a54fd27b6589df088d733782971f2f87395842a49fcbec695fe94eac5e14831deaa2cfcf4a9135902eb1c97ec0f80f80b8631add498258fdbce5027c7e24385bc25935cc4504b786c86ebf20a84962f72f47e39ee76d12179503023510109bf8e7742a841b19d0d1df0c92a1a5f9d224ed46140b354155169b1e513d7a84cf38228dc6b1ba6911f6de8b4835659da6a601e136f975913186e501abaa4f7c9112e921d82ab74ca7d6f8f1d765b9afd9735a8a5fcea35d867d8c572eabeb4c5746da09f722c9d9ad799ed11808ee425e571c68be08a1e130433a6c45c86e1b199eecb935cdf1c9eac93b88f77e882692fe5ebc9af100435caef889d8934753263b9a8b3f98bbe1908ea1d6aecd9e72387c86911537815d0fef629e555ff86db64fe2997b1e1e38d791ebe43f7fdbd0559cf6c0641a6a25d331f4bfc974b7d25b25e6604b4433aec640da1afd1771b84ee1ece61dbc184d7a90e9ff98655074fef292f11a0020d58d78e99e3564f3e9066b2aeff2241fce496bd356c9a2dbe910a045a7b46c91a2505cf9f00b53ac535aca409a82a8ea3be431aa34cbd81cbe4c8b18faf9146b22dd83fa657ea11cdf1bbe582c6f629b34107bf43286f5e62cd655f0a0deb3a87fb875bb3af4ef6d5e8ed4a5282ae9d4957028695d866577310ff33b85eff770b896e2f39239ab9b5611dbf5d148fbe8efa0e0acfdfca92dd1a9e19b052d44dfedeca4746425420a9bfd949a448cb9ca2ae1e13e0669924fc0d5acf43a15706605f1a8835755bf9333202877dd98b17987ae5834da15543acd83ca60f2d408c955f7f1877be3f7ed469fd548a16df41db41011f849ef8aa36505ac945b1e4c9828ba0e31e3a4f8dcf361aaff31f0401f4ef9e903002f5ae84a79798fee14a970a6585b95cca57b8a9ae1edafceb01273f2225d5c53cb7c4f226107ea7ddbb451f179a925214b2f3e00c099743fc7dba7dfcbefa01e7eb7c322f97dc85f3d2a20a8b8ec0ace3aebfd0a9c591904fbf5981a05134b04248e8629f4a938ed89713ee0a1a3be72398520b7498a300136ef31ea41d518cd22fb665431df97e74650b7ab85e93db8f95aa592713dc6acfe3f311800d1be72a196c96eeee6248e604c8eebe4d8f51bdd3c1af07a62fb649c6bcb00742e197899ed5054ebbcabde3c0dddf4c08014577ee94464dacc8c329f2122e4d6d93c30cacfd26a2bb6f66d310f675eacee1c9ef17ba8502f058db8ebcf3e346f64fa1920cd06c13be886fe8c7a6410b7089da8db60ec09b989673eb82d876107a1ec32cde16447451228af7ee17ae60a13c7e4364abc38d8175116244e327ce8662fea541f92e71a9c65b560d7dd65673121401e1092a5837fafc3a5624b8d322e977de1bdc533d767aff188383092e85410f5acd36fcfff279eb7891966b03366cd5e865d654ec522ab51fc5f9e3823b4c0774e8de115a537dd9ba015ca468f2d78ab1921169ce0f95dab8a7c1d2b00236d958700d84903beb28225cbd2c2a5a07bb05827dff34def12df5f4753a32eabecad21f25f205873ceec2a88dce19b634da100df19e966c17b41cddab8868f43b17c136464e56142e24acebe79cb03c64998c419ca03967f95d81796677684f42482fe0cdb81a77e46d2cdf136df47c421d00f8b68949f25ea516a232dc153c26e3bc78c3642d6c123a4159f678cb4a7bc2ca283316d0674fdf2b9954d51c1f8e725c8b15e0f15c3ae7d20bb8c2eecc687f253d80b3bdbbee78e26ea8cea0660a5067e8c6f4ef0c9909fff8f04226ce92b372fea7f1c0bf1c61cc70f3fa637b5a52227e48f4f2f58d75d391df5c7f183352aa3575ec72dba336eab5035e09a5519792f7efe1f38188ae00e0d1361108e955c617cc2921575ebb388a11a5f5f7bc6aa6e8b853003bf9def4d27cb76b45afbd9c09f5f679aae34b3f64fd314d5b4e09657bf3d0778db3ac56307d41a3559cbd95f3dc09d7dc67573abb1e1069396fb4de1139ca87710758b215a9a4f8ca3c50f321a1ad7ac8fc8f97ec18739daa4de780ff8348d5dec78cf32cc8d32a659f48c7cf2a29fa96a09c3aa5257660a1c40fa05c8051d5390baffa0bcaa6f04a5d40ea74636e7289fbe5b75b0608d600316b4a60c599c622745378c00faf4e2582dc674053cb46246fee00b65e62113c1c5d72f4802eae6584a68e9491c50316d051ece1364fb672d953ce60b7a4d8969e8fca25542febcd3ffdf2450a018120fa67efd65d16df4b4448005ae35c23aa463177c93ee40a501e8a1d34cae0661406a29c867e4e339c44f1a26fe136113b4d5467268fde3d701f5ede95b88bcebf95e819079e6e9082d3f88307caef25f644a5e973549b248a64b921910f72835faf86010c8bbc7c088a7f60cbf57220c89f78701ce6e77100d033598edf116d1ef2d862dc81c76ee53a75eb29fba553270089ecc209c45696fa9f4635122ecd1957f0007714ca7d05b18416d9b520ea7d7d333862236b01abd786847a5abb80f2fb2a69571cdc3bec4d288355c38e6f44178ecdad906859ea9336b03d847af67df3d8c3ff89533baea109504b8e93741f050e2bd80d5e48e2924a3ac6bf6bdc05f3717ea0ba86618d894b5621862366da9af133346c5c25c733d752bdc023013af130df6927fb205b0fb1ad5a34765c2d63bc813fce3e89c0f189ff43d37224d3790790ac4f325f96af4351b0c83d7713bb16487b4efe94b0f65045b50bc930b3174e294748ca8b26dfd2f6dd822435264f6ddac43ffa11d9fa7f623a854d428631e225942a16f8bd930c26d5b9b0030788c6e7838da005a39a5b3756d41af328b869f9bbd07c807e39cfbdc07b2d3a5f3329de37320c172bf307351e6a16b24765ee7ea7666b7872edbbf48f1f676f50150b09fed79c9567a5c45b29db1b7cfd4e767b2bd076bd39a0d58c87fd3a9b860809aea8f9c89058e4ed6bad5997c7a6add81d8398f6e1d9f22e2204947957d21efebdf200fd854eb382fd9e7aa626ad7712f45d88e96150a2562bdb31e2c1bc54c1b66e1f02a8278f8d706db61aa9a821b6185d58202077dd4397cb3525266c67334fa412c5ae33e389b59e97a99c0785ecd08c78bd40b6793f417d96853c70ab571d279d46369c86f289e9438611d2024ff13559e0af10348e41fa0af5133fa047b4ab047d63fdf946f92fa41fbcb295c0790b911fd13290b21411200dc71d7727fbcaa8a46b30b7fc902bdfd2c5a0a93daa81af65e8854d5cef3c1811afa7c96392bf2732280f44a01edbfcffdb1052715436f87da3c565a22a851d9c2a69d0b02c67e4a826aaa15a14efb725a5d7b507b025725d477dd539679d19bbfa2a4af0f0df6a154359024440759ce9d5107b15db8ede8b8262c7f2ecab3b744e7b106ce04017ca5c3be110b6c688581e611a05cea0dbddd97452785d1d48eb3c938d94cb3bf19226dfb21559bb77c4a1740b3f57c045caaa1157e16a4e8ca3af8226c4e9b0482cfb08557961f607e4d735ecc2772dfa5d617b0d63e8039e49e5a8823efa3b7b7b8580ce25b6402133eb5b21e1fe29c5970ccf4bd8d1c1b94b698af6875ee2b0296e8908370d0964c9a11e4e981fae9a470df4c891633f4c85a9896185d1b9619c87a2219e1d91b2444614a685bc52e21d21a1512da2e919d8863d35d408f527e7b5da39b4eb65338e2540d114bcffec3d295941b47ccbd2fa0fbe36c373b6bc4627f73bb5bce7e1468e6fc2bf2d8ff222f2ac19a29b0bae1c1838ea9a86ef063810b484f7ae684af9b0da3cd1c25fcbb63f1a3941876d31faad50b1da3277a639853fac5875f2ce9559dc17c23cb2806bf29866106175e952a13a71b7e45067f8948862b79d36aeba4c08ed00ba66195a8890162662c11766a03b091dd2d2a5def28bdf72389fb30ca90c8aedfafaeb24610b53d2973fdb0ef249bc114bf05032c1f948506d1651e2728215144b225c735956b5c0b9b7d414d8cb6a1e7c581610150b2e931a02789977abaa3390a602026591db5db74b8513505784dda4e0fd8ae9bb2dc33c45afc95722735e72629f2d4755634705fbd0f6ac1c8fd47d665547719b928cb464dfe7af7def790feeed3ac385c727615567257923c190fd6205fba8c70b6d75c423a2d2ef7c375e9da37b897e96d3ee1f02a4b1a617f5effe0e83491cd879a4c25c3d35061700e04b6fe4f47a8fe836c234a7e1fd2f073fa23517e5a5a71e4493066fca0856068a944c27dcdaf1bdd0abdf3f0a291cb3689ccd9da9130c9824764f1f8aee07f595b8d52f71db5a39ebe2de0bfad2502047f8af36eb7e630b1f906583dc0b0fac9b3894dcc79f537e9069abac362d0e92243fbf4fc813669d49f480e178d5498b946a6a42661e401386420c0c6f520e3f41e0c5840d4240ebd5272af1b0c8084c11932138c58b00b103ff8957b248b610f6671b872d61a12059e417e15895224d4bd59a2e1cb9b7130d4dc45460ad39860bc8b1526e698c33ae6d330071b7256c3314bd5f47e76300974e37a21f5b4e90c7da2ed01dca242e4bfb02545da637833916956a563668bf298650074ecbd475da787f70d8462b5cc50e919722e076eaf45c8a92ec0de821ceb00193e58e5748ed969a05ea22774b2dbce35c25f5e7ee6421c7bf4c71262d779cc489b0238a7b62d659cb39e8b9caef49355a548dca502845813aafc0378022a7358a15579ca2493800465b242530734cbbdc80874b50f5e5657483c5c7fc7c7208336b420e9f498f4a58fc1381a9b824e36238e1d383bbc3f82ce12176a2f261237e5367ff916c38ff213f1ed8ad7fb1fe4da8f39f4f0dce945206430607309bee2f96fea669dab7ff828d915a53f4189d8a5a7a45b1d23c74be4c4c0360d5c0a69493b4036c4edcad409bfb63daa1f6a74cd0d39974beb03be99471a3cef93484fdeb5780855606da79702a56b8fc88365216d695409177da49c3f44e58dd2d000648f69708f0cd48bb61fd7f99969e38869256e1b13b6ecb7eb09b7de0243c60bea2673b634a8914e1c2ea8c66458ec5724b25bb018f001b641117c3655e73ffb3d45ba7a6315fb3625f8779fefecebaa43750ea3dda3979de8f57b195798113b532306400b40ccaa24738ba9a5225fe5829881dc120614a75101a4033eebe92e4af3be9ad95b8e30fca7f5d441b9b2164a05ec5ca86297db2f85d55a62996ecacdbaa41da1049a21c415b5e84ed25067a69c1a8525e430528ccb4bd122ba7c2f7c49905b3c4dc71f5d7907fa16a8256e6bef5165ae13b097832c668f208c8eab27f086785e1835b2f6a4526990b8d965eb14b44c50668f63e257c520e727f888a3f0d1cd562ae7b1181483cdfc7ae331695da866407d7f76f7eb7bf20086eccfc1120cc45665e6ddbfd13cbc44e9d689f217cff1d1441e07acff663b92934a39ffb15512eabd674654217d3f9b83fcd190c2a4e6e0ba803ba9f7146bf649b2611bbbcfec17c7d37e7082486ee33a7c8ff961bf102e5125a1d18f56ac019c7885c84250ad4d712b49df840ab09f2adcd6e9e3774eca78bfc86ff52b0ec4a51f4b25aab73cca0c1b16dff7195557bf35c6954573c1e5aeb3e53d789546dae49a68788142bb9f06c2f5846257d397d63e10ee20dade39ce33ab43389982795f348e665785fc7bd007917850e0d4d4753998b3d627b1e3b8eadbf40f99074443fff4edd0a83b0f26ce44a632741b85722e598e498ed9f9bce6215ffdbe75b47949e42b8e746ba2df3e85954115b746bac7d102affefea1437202563994dfa9b01d37520adeba515cf19ee3781733331ac1453cfe3c8aac63bc0bdeaac0f4dd54d63c1f805f73e54a7cb4d2dc30bfb89031006798b2a5aef92d33afdb819e2d20ebb7c9a8534a1c035fdbd2a977c2434234424763bd4addff9517cd1c0ee265ffbaed7440763693e112b4263bac56a9c7574b282b26a08b7e255557903c76a493d1f528617dadfff12dfe9e2dd207571e36cedb5e3bff8b9c85f8aeaa46b87cfaaa12a5f4ce9e67cf34b5906f5c1c47f7220972e939e1466935550169447f8ae403d9a742db4f39d120bd45ed7f136e9e2690eb5100ef0f69eb82588a68bb97d77ff0c507ec2a0ce8938774704e55be8df78bf3d278d0903f8048e28acb036a362375e4f4614453f8186979c3e602370d39932f6ad1cd5b7a844804cfe90480c6424f6f2eebddfbfd76c6f508f252a9fa514073962cbe8b36711da35071ca0f19f0c609f1500d45265fc667bc71c0a301bf8e54f0b5299a955d6b7a956de872435c45e7b418b6a55603bb3f41c83cb0586e291f381ff6a593174369adaee7b3b0fdb48d19f88b209e25060e261fed849704d289654ff05186e3915fd7e0d4d2a582bc008bd68f3ea23d537bdc33aacc420c1aee10104ed792c7642cc59d426e4b34ee3bb03bfea33e0e9dac2814554c150bbcc71a53a0ddee607b539fdec4f9b38847eae81977a283c1f495437b47558d558ab9d39749f16a9d0e7627f70b6df0b4a64e9f2934cd920a6fa0cf45f61767abe520e2af6dde74712b8e6ae58f2f193dc691eb30c8163d31df0fce9f3267aeadfd81bda408807045db6d09b952802d26249e57cf98c4ef42386a3714d0ca11c37964a3288e4d48a1b3a69febc2ede10c4432c9672b3894873799912484f861040368706520c8bc9e37ecaf3f02738960626efc51bf7765ffde9c2f02114a358cbc35d329720f70cbdb0564bb2a0c87c76374b44ae10a58d5cea5f2b0da3e018f2a50154cf962725408813c8a94f397157b59a681805bcc8a466048cfa74332ef33e208858be41b564912126b1a346b77e73814c9a1bc3a1ef9196a83a1f2c81c88f46516b5d57b3f9b1cbfd608e01d9094b5d4c3b8324bc314e2ac31564a548d727cf48022da72cd6587fc4dcb58455f9cf2f77fde03a4efa3d0ead04656943dc49e8e6c179b857f303f588db8f85d5aba8f8adecf4f5321f83b5600d6c2dd4bbe6a9f3a675c08565a66aef031aba9cc0a07f767caf569cc054ab17ff6115f6b3088e3714bfaaafbf495ddc8781f7a826b01f79dae25ea5dcdfe42e4addc0176b65e720ed3c62ee00512d68dd2aa94050ca623d5faaaeb5179ecabfb0c0c1ca60ed14120f979297aec5d2ef9e7915978bfe96b9baeecd6ddb56d119dd378dfc7902ae57e4158becc411c1f7e068b58b4e265a5e4c7d36e506323d3fd0054cbe3b5017dcf6d8799ee4422fcd8d598fbf8fd849addadf846147b8370c30e31cd094e7b499566a73f59a6568226873b3660a758ead178c1981a4fd88f355db2fc674d0890f25529da57bdfd0869a77d6beebddcf0d675f0dec02b33c68f0d148921559274c8f8f5463e47dad52bafeab90f0b5e81a68bd57331ebc76e5ae0d2d08f85e06b4780ec355311dd731a1f23cefeb91a2c696b2506877b1abdd84b0e8bdbd5f403ace6c8664641aa7c7545928db819b5c0fc120319408f2e69138d07e1bdb966cdb51eb99e8b4ed81b2476eb57e13d5390d04b64536d0368a61f2b6f46e08a67c89c244458da8de71da5852c63aa5168607b7c8b1bc807ab982e1d1001ac1995ab7f1bf257ce91675b5b45e422d00f4b17132a87b5755b651e4dfcd0e57af680750e7da8d69c486d99351507d20c9e37da244866783710459290b2549d2784ddb8b8bae299f66366476a36a317256360662622b70bf8d4c3183a563b2dc12b8bdaa776b58526f8714bd02628a081137e043c5f063ef4de5e03ebbdb1887e1fce261e53af7820e9ad584d38532e1afb7f8a700eefac67e6c77616a79b560f7376d13f5d005d5f8c5443f985e85363624ac9bb1716b55bd4c3cb150776e3831dca7e41f86919fcb8deedea579f9f0aa33b70813b8d7e5182b189273710bb5ec82aa6c6c691ac1e80ad997dc1d67af9924ee64e024c52374a2d3a6be16c73c6a906dfe52ad88a352e99639c56113684debb0cea4c94eec5227cc4c7d26d7aa9eb2ee4bbbfad7914dcbf8a2c6f5c95786d46018d0af6c002be5cbe5efa4d093fe30fbe50b7faf93732f97fa98d32ecbae1742eb3e9ce5fd740f2b447f0780a2e496992e984bb38ee568706c45df3084069672a852bbedd4769ff8d6d6ae6fd684874c5de3c64a7a78c60ed745aca5bc2fd80dabb6a140e1613412944edc676569514f24cefb75370ce0a701c2dca3fadce71ee70f6ea682eae0aa287a98369ce1c55e1dc0b507b0b7856cba6c7efe1b3b6b91b8ff7925e9da178d07fa24d5370f1d5b48b26724b35520decc9ceef769291fdc821b42f8567f0b4a4e88431f6e70171d4b5afdebaa8eee8611a620f4be932d8c29ab90fa36c013efdc7d3c350c42059f1d4e84afb36ab3a0f1373e21af1d5975334c077d0e38c81bfad7fe61fcdf8558604c54b7eedd5ba3353b50ff90e0a97378a8f3f87cf806ccf2597aca46862eae526e4836b996ba5bbe3e7fcc53914e7fc999027ea9daaae862228296fd59ab117c2a59033bc0a1dbde007fe1628e8a0d6d0ffcaff79b6f3267876cd1c64abca3539371f7c2161abdf7a6165f93c967c199b09759907565d085818220ef6bfd84e07192d9dae709afc98bc7fe1aed5445de285c53a38160e97317806e3c0ea9ba76c921862f8faa0d6f89eac7ae547668cb63d7c891ca49109fadbe0d9745ab388c0609eba7a32c8f68db0233f7f59ad3f8d90c8b87542f33315865c083e0aec788ac2e555013d05ad09b5383cdb07c7dd12bfff2736d6f57e53ecc2d871d8dd5d23e8423938c2a6fe028baac6b903643de43d2122b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
