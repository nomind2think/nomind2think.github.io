<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"059999f838820e2cc5602cc3a468a096260199025abbcfa9b0b5945afc61ec56e909bede1f025903925dff8c90350e43654de8afd87504f02284a5cb54d1ee9693107c385eafef4c93973eefbe060543c17ac2f3cde6899757af7c57aa7690e46e33af002b223528dc5b8fcad0e79e779bbd096e981f1a93889d901a2967b56253b3ccf630dbbb51be156a5357b5bc0e4a6a67886f6a5a97a30f86b192a4c24c825db29ebcae4f4afe6573820f35ba99c27923134ca25cf35a6f84f5c634a24f8a84ea737a462609fec1064c3958aa29bbebefb0bad153da9826ecb14c82f6cab39510bbc2f02173c46ed5ee468f36418fba4336670aa83dd6a2b1d5eb58cfa00e9879577eeef7ea5708da7497eadb2e7153276745f3bf3bf4f9d1dbaa47dd6b425c07a856f3bc6939b2bb8376ca97cef077d247bc9cbd201d25d5b3dace7220f72aff0c28f5cab2334e6ed205c05fbc4ebe4c99d53b1c1e127603086266d9c14d131a4e0e85e02795513a1d70d5094efa3a051cfa9dedb9fc173c844469e2afef1d36d54273720e8fe82df4fb1250d8cbc9a0468ca777b6ad2a986ace977e4c262fcd03a5d6db508ec52ba83d9bfb6c4464f88370d0e422e2b0a128d428f2d0998a2909017e656258683150286eb5fbef8b275d29544ba8e4c1be764acef47443b8c7709977721ec54ac027257b33058df7372363bea66189baa20339d2f1efe6143ccb13006249272b16677079d1007bb5411aed212a7bc338cf876298bd15f3c809156b227e0e594daf00c7cc1af0b65ca084f7a27a1535b517ade2e66fb5f207382697965f35eb81704383bda8d4998c949eab964fe548f32006083114959f48f4e0ad0b47ae9f16c6248f08da6c78234af3d743283a69ca437de65e777a9bde0fc173015214add2175e3be45e8eae8ec2218a5367581d8409c28eac20d46ac0b3b5a26b401c1fef60ec38b9aed33de784666fb8d74cfc0d35eb87eaa95512b6b6f8a6ff1906b8c0a5bef8b1039ce45235aaa8c2dc88a68aa5075f98986105290d68ec25faed2b5e59b8c4277310c36ecae5c817ac44cf59fc17a43186fc3051c099fb8b0a1f84032f02f4d52d0f3bd6e3c86eea1c6e2e7fb361dde3ea5c1c3f9fc8338decdf65f7824b0136d29ded9fc15fe4b5291acd6db459efec7b6d7d4ce9eaa95dc991b9594b0e9bae26e12ede33aff1ccaaf118b98f0d83be821c9d0b77d3a15de0b2cd146cacda5004b06c2e5f2c69801a51dc24a4ce3bfdcae9b73f5fed8a2e89fb377e34113fb0d6aa4ad9953a15e8a314e0795f84ff8860cd5fad7cbcfb426191eacc2776fb47cf665fa83d4a4a1462b66f590c49d915aa512cc2395bc9703dcd7cf3c2a81042e9ef96a5b045796af0067341509ea19527793218d768568b167142720e9abe5f1335cc50d4d780af8815add78373ccfb54579e600427cfd7f495c0f33b6989ea886fe5bf10b36045e14a3f186ab073d1da20a2ab458ce4466193596a8dbe6e1bf671dd82df50cff4aa8f765a3c96ca54e6033e7d4addf4a7f7ed142164a1eb2d17db3f6bcb188de1f234f92aa0164dc9f2859af84ee04ed67ed3f5badeffe8e0ca63517144d9a20be3a2e8068f2198c8dbcab1351b27e35e39d49aa0fd8bc9a691ca18add06029c7b9b6d814a2529f06f9f66d88b98d8c5272bb063baef397ac3bf666c45b4218e673c3306d7cb14c4360866fa3c8b8eaeccf8b900093689c5dfae4c58fe942cc0749d732e6815fb647a0082a688cd1b29d321a0ed650b8b59c5d678ea346b16f712e813562c88a42d12fb9eee26b8313911d6d861a52998c192ea8709761215846b0d11bb9353ee0d6389ad2300135dfca2dd002c5d79131d11f02887fecd4923a6243bdb0dcaddb385286e90e2764c4bba7705842cd19804996dd995739fa0e7a8c3959ca907c4f56bf795f4c1506d883444a5862a373664f6e3aef719e902dbfa3650a12e0df5baf6d3da59530f3dcf9b75d01eb4623bc3c7fe7da5ef2b2cdd1b7bb5a492c1fcd8880a6bb3e06ad87b9d2c4a31beb0ff333350b51fafc9024cf6b50fa8a382a233bd935580cf573501274af0e030e655faa6e48eaa3de9a1ea8ec36dd562b1ac5d59ef9f3fcd31f4e02afa9f55418e85d7f5c9314baedcc67a329fe3595b6b72218c1f0d6375e01e3a2bd46249c3fd38cfd4394db5c21577397788008a2a8a496fc89c081cc25ef093ea72d7fc3af16ccc05dfe436f50c65aca38f42fef695f77fbfdb26204b893d326395f942d9a7b9ba14e36d896b06713e4e3cfcd5af4fccd47c8755fb6bbdb86a91039221e40e5dead42b000979d3f12acf92c1c742427b50d747956e5f12d3de2c78fa23e5dabbc1f2f1535bebb425303186706fc3bd46b49d194d9ec2907275c9a17df310638116602f08c4585c4c11cf0596b4a7b64a5a947f9a134d90790e8b280eb10fbcd4e06440930dbc074eca0e8387eceb1897f775ac84c523a700437fb8f382dbaeca8f65138efc40a605198a0af922869fb78da8c090ea1c40fba337817c4887c44a45156f1387ba48c9cb3fb0fd9986b6ac3e3012db9e605a8a7e3a74f76d2c7a7f3c7024f78040d9bb57e65dfdd0ec0354dea53712f6ce2fdeb4cf2f263933a5432d027ce020782d786282d836ea820ec2620ab57ebcb6847f47d164346877ecdcd1a8462f203d119424a26b49158a6011d12e4e09838f2556eae25f4797dce4aa55a2e378fe8b129d66990fd701a5791e620e3d36c262747fdcbe5be48581bb7ff5c1d700d26055b0ce7254373d9d92edd72a44506a2302f70852899015d1c06e71cb899b7a2a79a15d90a31150d196ddb05aca23250acbe645f95742c43155e29f05771537f2dcad0ad30d8d6f31e2ada2655f79882a7e052f3715ace788a18b6aad96a8bcc006d0e63c38e8a1caab03425aa1cc24f88180c3d90b6a0c1a243298a0fc56a9392dbb11562222b79cfd63297e68877c369439447b7c91cc385499630fba209329f9018c065e9ec702a1de20385d0e73710485a7d6527bf3a329d5207b7af629b6306d999c660b6765314b08277e2955239184cffd35a441e0a93d8f317f9770877e9d739c35db43d5d81f3a2cf98897ace5bda28af043bc986de9da1753ccd31f968630aaacc6810101ec7024a7485a79333a8c7c468144de590cb9b8005b6b8927dbfe92573168a4f8c50821526740a18703d9b56ace363ce1c113620a589f7890cd6d147d55eac29c309f14b3383523113c1d478f8bd98b21a40e1efa8955220f77c5ca68fcbb43f5c947e9478a758be58e29b067a90cbacdab4cd38291f4fe1f4088493f7fcf00b10903ad00176bee42a99857b6f336d88166ae7552b16b9a5082176ea1640b422c20fc2e3e490456f42b774014ef6e75b03b27eab06918495352ac3875a1d596d442a38b165020a9acb4c782031874dc574a0ab7f72c5cb6190de1d328d0d97cd7a09c09c1961756ae8ad2721932b56a979d45d20e4358a5e46eea67c56bb7be4c80efc8a4d398916320130d2175bc587b895c84ad30afb87286ab2a556312af6b76e91a55a7034a1b0c27005db524e6383805e93f811bb7f400544685aa4dca6c19f3110bfcfd1b5a7b01a32694d54304ca8354294655b129a319f5d73641d9f1787d378717aa02cd9fd5c2df8b92840ede92734d9a584ec27e37389b8ad0593c0661102d2083e9366ba8dc9b92f000a02de45fa82380d9ba65457fb1a9446a076087211ac6891285674d54ff9132f356dcf7d2c97e87a32c5761298084522405d7034df6937feffba7e42b17b6ff3017c9003fb978fcd445f482b4c42c43b18ed730e1b834ff921128a59765c538aea4f3e773a1f40c147d6076bc1e2c1757a05689b56a4970ec83912bc55cb3863003d18081351cb9dd661c503a5d0014da3f2ed7226d0942f5ed598ed6f2b6de9922c261b47481893afc6ab9566fdeba7885582f83401fe010e4a8a2f98b10e4b4a438f4330fa7ca81a491538870399f09082eec8bd380e57199c7ce8e0d1262f82c15360aa9ab59f9c2adf8e73aef0af6c52a1236ad8cfccf61eabc104dddf8aecdcb5722a55c3527658210301a0c354f9631e4c10146911fb92cb60d2f8751f3adc1e70b463cf3d1bd461fa296bf5fed83dfa466bfab0695e04b3a1d9453330352298dbd9781b8b72f6f455c2b3fe563df1b881eef2964b013b28b9b7904bf2d6cc04880bde36d610bcf2940c0e9b5811470ddd02a9a538d4311d3c5ae77d82604150a119aa636cbc985b45af0a02dab25680530e1c8e934eaa2448d6e62b0dc48566e943da1dc6733f28e0c21162ea96909f49bec22c9e974027793d25366522d6ce110e007c702b38add5aff1ca58f7d99cb5721a9a440d17f32524d525bcbfb08c02711327c2f28527caa4ca091f63001e66b2800b8dd8efed9d6301a8cb3788837b8c5518ff52f69ad1f4d77b6df6dd3142ad84493089c6802c643affb7945b7ca419b5d4ccaa8fa047c824ef58b835238021c393b8e68c617288baecdcb3bc6362e8654d02de4884e99c61ad997e9fc4ed9c827052ace0075970753b641b84e6abf99442ca8b788f1872c868fbcb06ed9a774dea0a430d749d25d034fda3b6a4c5dc0add571a1103d8f31cb1ff630ee14d4b9958ddf4b87606c8bbe9c620805a15a6ea65a87c32193541349943658b21fea4facddf2ee65be2dff127dc845dce55e7801026d8e3f9276014aa2b24715849e1870e85ff5e611479d8d4c2f0b6805ffa1f535cdfc31f8b4f2a4ab3ecebd2849ca97f1f0cdece12576ca6061f4bdd806ad866874556aad8581502b502a47037be8e30ddfa3a12f8ead7d98ee5dd8c58ae40a62aa921bf5d70ba453d59db73ad61e88e4996286c4c91720160fee562bf87a37ed2d76e4d4899ddcca64fb776936fdee57a4dd1102b62e7d0e7bea952e1ff34022d87663ed58fcda1b6fb20279457a0a28dc04a0c66d339688046f3a414290a74a38717b3e39c4c1f0ef35da5e4f34d7ef1acc4d89c64882d5327c6f6aea085c485e4b260c1b206cd24d65a0086896cc98ac1776ffacf81c79a1f7cd6bafd28c9930126c641910fb05f18ca9754785855920d164a2a3ca85b96399bb17b94945f693fb911aff7b94eda676e2d43a753bf2e82ec673c2318418bbca74b4e616f5e80f2766b81467c24fc98712cd32298004aba248106e6e2bfb89ae4a5814bcb636463136a3645a5d9a26806e474616cf158ad2ef8d4fe0f63aabde1dbc25c0cfefd172752c648d77ddda4e30cd43962b614ccffda10d39d3530d56b8516e0d47dca8950d27916c7c3cca8d5a765a773d33b67d1ed936387e01a32f51e2dde11f95f5b80b71f9abe8e2b657f4cb46ea4ff1e6bcbcc30a5e8d4badbdcf7edcf06dc43e8ef8a77ea244b03fd2ebf73b573abe8cac104a6af100489e6f13c439ab9e71b953bf9425645a27ff0d547697570b772ed971bd826549168727ec0fd8911f1597f5d9df2650851c2ace3a8f59cb414dd54bef673f6d8d905d77d50ee6728792a1ab14acd01f5a98b65a5782d1b5ebf25eb43266a819baa7f36fb7ee483fdfd2dd12d248bc97229d49084ca8559c66a8f3596b65f420e7addcffd75714fd29f64ed3f508855097604a32d74f8a1e2e78b0334b84c5d076b09143087c1e89ab7939eadea6b78492b970deba110b095daa7d25d6416f3b229d9a96991cb8f3e9b14ba4eb38c712e23e0002533c5aac22e6fa48da14bcab1d91824d32a4988c90d905c8e1cd44eba42e61c1fb15c82d2e604f5c13961935ceb0f5edf04afb0548c37acd3fe1d6a035ea617d0d41ab48fbe2c8bbc2053ac3b1cfb176f0cfc7aad69ba154e5596d5f6cc4425674fbf53ce8fc17ae466cc06c840de9e6119be6bbd97bf0f954bd1dc2bc56eeed575cabcc61a16100e9aca24e311c2f0bc216af8cd81701f74e63d413f937195b7d07169f26b55708a2c2b032ba1e11b80ac5a040f10ff99000e6b709049e30205c8c9504491d7b200747080432cb72820e97355ca72c21bf75bdf50be0bb02ffc30724015e7a18fdfc467da7731b876ddfdb88aad15b5e8b8752cad6317be5de9536f77c53d538807bbc766ff7842c6696424592506cb6503377941dd3627eae0c29bb83d81b5b1538beed20151cb9d98ecfdeeab3085c84ba357d58e506281f616f04655f5ce54b5b4e1f06a39e1407e2d81f2e4089bead600127324bed6328f1e6f50fcf99c54d134d98a3d5e66e179576cd9ac1dfaffcf7f02b33b2fca7e2d1d2ba191698128d9030970a881988ea95499bb2c7fec2451a72404ff95c102fe719ad99a2995b77a69d36250095ea87923f756c99e1e899747fcfa64eea16bff6c6c8b636d22002874c3a398f8367ab18a2d8e6111cc87a1a5c1d90affa9eb21653c4dfd5aa7bbba659ba915a5c67087814320e7649406099f41ee7ec67a2cf7615d8817ea6352d0abe9bbac24ed73bef426b10efba31f2d0af7a2d749eef52742d9d8fa8ff301887345374f18e37a0073e9feeb3cf82283ceb6d58e65e6734d9f626e4378c8ec830462fd8532ae9ec3e3a852c112bebd5d1c787c921354331789e84eb811172ee2eae7cf3c62651433ede953e5a16a156b09ba0abfabd70fa9660bbb0a9f15f02d30d1d23ca90c23d10ead15b1d2c2b7cf29b0f4fad86798b197cce86ab0a32e71d819a5d8f9fe59684ddfce6f708bd4af43334c78d658b6b908da878bb9172c1402703173a74da4d1560887722e65269bdd653e0043e857e2122b77ae2f3906f7f586967249afdae6ac124002fbef5977b5cead1f32b0bd077ecabc8a255b9ff904beb2b8942907e35b3353a6d46a0adb9a8ef5e20b57867ade27a8eb83b1d9958587e0f6ba3fefa13448eab118d8fa0b19d78412f2157af09b4debf991aff67927b13bb2a4b01e2e70b5a76ea67e4d25df758408f7b6262d29de8cd35c15f0d0ae1fae094a344499058857e6c6167fb9afaf40b8a601e55096041b6f25778f47fb7a32c07ee1ee38663ea00ddeb92c72b78a7ac556a58964173ad4100582a6540e7f37833e0dd55e7d9759c37b04bb0eedaafb8568e322380f73b2bf8c663143e6983300cadb16372828d7f752f8ee1471d99475e5f20cbcaad2b9db8ff039988141a7f8be5de2780f8eaf079eada54292f5388a60f9d4e3cb7e471dea957491d19669aa3507632b3ecb67777fe89901bb8508d34348e7e62bb3ee011d21c73fb5aeaec0481d9b33f7382208f2a3e6fafd6088798cbe7691b822af1f25cd1224fd28d5562054038c0a4d0fcc06d29efc86ed422da58c2a90e37f20891b436629013696992360c2dafbf6f3e597e3a8aafe325ebe3828f7700d225fca055375ae223edf501ffee78bf1eeff25447570deda41a73e56f01cc369f7b111d5401057dfafdf805eb0c6d58f1aa0c365182e4968cb193945b6e6e386fdfe246e593403dcdcbd47555848f53d61334c3367da869d90687ec98b1d4cee1419ddab4ba9cce973bee62de9f5affd4aeb2a5a6e9de2f4abc451ae9784c314f28de2c9a2ebaf4bbb4a1f05381e5595e58a91c7285c96a0906d3662753bb4f667d765e3a2d8ba5a3e43f4f352f0b5229ae7da2279b9ac35f819f572eedd6281e4bf224815d35273951206c750c9854dd760c4728b152e88a8b36a61876f6d7a040e9439141e89bbdeb212e4a7f83788b539b4e95007b2db50f76db14136c7d4118054386b08fc7585461fe60e6b8ce966ea51e29a0cd923acbcc0d56b4ba24ce94441356bbcd8f0df02a1753fe9bb9e3233ab2529c11328fe3b0e2b462219dbc241e3c68aaa37c1df3710d4c52d5ecb368a3d483339506164136c9dc9581cbed71bd919df762e7dc05e628a8115fbd5fa12dce1373a2b0d73d56d95067eb6736735aaf4ba438d883029f2da0f6206d0a27eaeef775970c443b9cba516b8e990b8e12c672b1c81dc831d6ed96643a1078b62cccc1659e40db8e714e6d4ec52fc15df04204d33740d6f7e4d301b53e61dc5f59fc8d5a5851360c7744e9ab612c929346c2d60c5dc6b447e811675c5e791cf4245cae6cf2c8f0e835e7b9427bdac3c2548033c3cdde6e96d960a7920d7aad90643a13c10a1bfae3c6e3cb9edb1ed25ce3efde7a7713e3a0157578959fd3fa57b8e5dce71df15aaab941c1ac3ea5b509bb740a2d04ce720c9ff3d89e9bda35beb0f339d8b7a80cff9fd0d7c89f87485186d86c8ef5403f40ca55b2f5f359cb204c31cdb4a220f50411abf4911d147be8b724b24fb64777a2c1e6f7464e087bd293df76e233955e999e0a2eb5e400628f90934978b7abe3054fc3d295faf0980d8c015f0d328759ce0c62c958592855fc126c7035448d7975dbf046c0f3b78113c1f2005cbf940d93e3507c5f17d48eb9ffe68cfd422bc365cb55ae2e1682398e322abc18997a717212cc927bf63778157a4c761f28ca0f049ca20f178b9fc722d6f8ce5adde1755d391c937d80faf69d9263257f0f603bc39aadfbbdcfbbe3644a942a93f5ea67097570de1e73b406f34dd2561db08e905c61ebbfbd3347fe0e9ed6dfc25b32bbb72408b978cce72210ea0aa4a018169a2fae937df9c121af026d6019f01d121248fd5578d32074942ed637e41e4f7f770335121904fbe39c9fa433a05ab95911bf2ab2cd8ed439f6c9aa750fd048f5329a3b34f39be0ded6b31d1cf63f2a964178f4e11d448f6415725272d36236f45ceba737f756e86731c228ab20f6f52cd69faf8311d796717f7cb71043757d6d5ab2eb4b79e9ceb5839313bf36b1ed3009a2b7eaa9e7d5311cb8f001068973c2814e594656f29648a7bb5d19f9eb34c8461e3fa4aa37d2ab5725bbc7bc14343375b63f826d8f104fe2b069ac8124b157e4ed98a2dddccde69098228c53ad24dbfa592a3c389e275cba38291fd1a82ef8ea903d73992f28e861627ed6a6f27dcc1c4b92da6f94b688eb1e8386f452253e2accad3a9eea86e440b7630b63f60fc2ef59f7a0993cf6c68986f166c3f9a19abc01b266706b5333fa23993faa9267befa8cab67efc01f2bf3bfd28e3d14ea969b3586a6f015c79633eb5080781de13d54407188a1f2d7dedf3947271bb26382143cf3cbba085c789c6ab11a46af7f9cc3fb7335f7a7fe7788e7c69af3921e31a03261f53c5fd751f578e9f18b8d2d0be99ec02cace88a6d43cafd832966ad7d9ed8471d548e8616459cf8746164f4c3c94fda1b7876088ff2c0fe2935ef3f049cb3d848558f4c611e17358bd953bd7fa9e20c77641ee36e4f4530d6501d71a8ed48bf16bd15c7475ed739118cd23136a4a83007b982f9abbfeb08b63402d22b517501b3b163df282b2abfe89749bfa59c560eaaa07e6fa02e4728545b2ed2b660e0b1d647b122988879e0bf26d4051822a653be3ca02d2a4c7eb1c3ce0fde2baa6db13cd310f25a8810044e891a6865e6eb2f052815560c2b3cb9325c2abba30159c162fce771e68a6c5526d5388113ebcfb1a7daca233f9cf8f3690be03db7f0b7f182f950f1ad66c8bcf13b9913c8726b8a96bc4b87926d647665dec39255ad3ea5f3fdbce9e3803bdb7e9064b6292f3f54f5ecc5a840d9374d37d78795c4181783ed5c8911060f3ce8186ed7bad902e5c83c9b2c9b14ac0042785b59b56a91a342d142b1ec4e37a033d48d4883e09e36044e1db93b5225ace1a32d5fd38dcacdcdfb97c4e76d1fbb867c277d87509aa97d3d81287128e58bb12d67fa9ec7578dcdfc4475a9c468311d05079e0c68c604da1cd97eeb03a3ddf12b250f46c97597b9e1aabb3df1d5ddbeed4a57c0abac53cd9b4d40b0963231cab64cc44fc876108b4e72bb5ee38306a14bab05b3d53e3fb91f48e2364fc19598fd540806ff5930b953c8c5f98668e704514eb7ef39d10399b063c26f5af920d7ace576f4d65f12963782a26bbc0afe2d67454813872cd720a01c0348f70385fab585efc958b980c6d24755d4c83e2e236bed270ed6da13ee869d5f35518e245f0b2613c633769199ef0f2dc8a10c8bc11fb0efe0249dce21ccd82c90cb0aa98715e01cfe849202c0fa1ff22c4095efc619fc225f4f4e84e59f846d0f59c1524544f40f64a299cb8cdd5048d034cc0f5d4dbce6bed0a76f84856a006b89aee801cb4c6d9110a2487ec227ccb5224b81a56ace9b8fee96007e9b69e8aa258e34c25f5bdbb26fa83874e9f996616bb52166556f39a215fdf697ce04f8224611c76926f984bfa12771152a980da63985d83e7cd65642fd7734d104795f27ef68cccd278a61d7d6bded487c9d15f851097e5e3fd68c5b0fa7e3ee867305796dc438e699620e1729363876c3592888c035f2e44ce8ed2cf9ec8daa6aca03eb6e1f42ca3e1302a9f4a4a3f4b310d1532feac9e04f34d3747b12969a288f66e8f2d985300830da25e99d875985bec203ac76b2b063a13ddf532dd8ace525ad779d52f685dab509be5d460ea4dbf51d52687d6d4d1b7afb8b4cc7bd0002a2d5a810b682daec158b24bddb8115a885c3696df09bed650352e76d5a18e4b028143936c83b84b8d27bc6a128e7fdbbfb3abb8abeb703aead55754528d9a43a596874ae715a112","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
