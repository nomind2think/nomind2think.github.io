<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f4d1969544ecb978867115de12d79828d7ec5514a15fbe624c8dabde0aa23f82ef6a4443fbe711fd299a7a1d63d68b2759ae9c0529ffbb6b1178da6cd8330536972be46637ba3c577331f770d8e0116091d037b08a94c85320b8d510cd74c422f2ffad4e5a846ab489d30142e83eaa02b298b59b73f6359777ba5cbd4b16695e21c44e06b0358499e0e5c7af36bb157b09a98c8c809a084cc2287882e712f4ed2fea5aee5135fab8d25809c95f24309f65e261574cd84dff5064ce1ea127801716d1b8671de3048c3bababab189b23c6a8dab8089e9bfd3a1c29ecf53914f3bc879b128cd942304e11641fa203df45564231a715d5a8d7cdcfdf065c1ab5fd5b4dfa4f0d417f9347bfbcf64d11eb0b0c2390d68e489459693d09add0d2fa54649cc2d0b89abd2bc62c57425e842595d46364bc96ab84b015417cd4a7b48d7e0184391e48a2b024f61425ce521640aeb1caf210ce8c90d3622cbfd256bc9c77fb1e72f37f5fcd0eb040b06f0bae50e256dabcad07478f3406826e7e7f6f751c079f64e3aa54519b04e6f34544d5095f56aafa509f92621b6ca717ac01dafbf6446f5f163f4d7b0d8fb05d0c0dc1889fc6a26eea9c4ea1a070654fc939962a78d11bc0f28be48f179ebe6ae65b0d51d69a359f34ba7e9bc1ef2f84b21c211c45718c912398601dddc7d017e13018ef5f94232dedc10f8a7cad62f77362f4898047b5afea2cd307b6f1309c39f8fbbe8c0c23ddadadba1170a51567b8a4022482256753798dc5a044f99445d7cafd2a0bc3aa337c736644a0822cc106fea3998ee041db3c49dba781a87f145d6da90d6af3dd582ac97588ab8dd5f3ca265b7e3449c464d8d32c77bfe8bf8d51d356e20a43bfd361d75ebae641f63b925a6b8acffc0bd9cc38d6c6da5bee52e113ca0fa1f0ae02a4cc0dd568271b86bd1c30dacb2fabd594cfa89cd1ce1379bc7065b847868e97df2e6e0cc4f50554bcaabf95edcac560bf3b13246e13979a59593834e7d58286e111f2dce687457f30b4781ebcffe31f70582421bf1e3c8a6a3f4b5e741de3bbc587818e296ea96655e303e603662f48467acc9a72cf439292be495b02016d7d185d739affa23e2d58e9f479fe036336ccc97b0639689891bf25c19a4328015b3fb195546696c57a4cc107153834ace91a244f06b38f1a6a73d5cb33ea461d9378f6841f6f57879ffdbfba2bec0467fc3ce4de944231bb19cb94c263309c5e2bffb1ad8d0f0529fc4b888af3ada3439a625dc4f594f0c9a0b2d662d5ea50626290010a90e748e7b6d0916b0fae971044cbe56df9e0606145e46272ba39d278aa2e136448c993ce1df8f3e5d08f290777fbe9ff6598101ed605d3d6b2ba99f35bf75030db3c03705773953fc9e93bf6814539a971d1cd75ce0c162f6f26f8fbe8ad60991a43a29782108055d0dd14fb15d67b4ce3ece3dbbc01768a73619d0637e5be01688ad3a82e89a8601a9d9beb059021bc71719e142f51daa7512af346e2d33c78d0869aac6f47ab76988e3d23b278dc7cb23a6c4d4f64229dfd354d320513da83bf3b39b529140cf829de84f98387e3acb846c8e4861a4acf8d2a3a3380b1f182575dfae5a3a5f7f37baf1dc274afe744fd022492246beab0f093ce5f510dc0d79ce71e45fcc397aa753cf4c596389e2e6905a65a27317b4faccf032bc444a21859f2cefaa85097a1adf250bf94515eab4fa0e48a609c46d33d5d597b60afc46ab6d03d34b5521b27786103f2f6ca757a0c9ce71e664d66011739c4743d31f1bae52b78ed009a3a58b513cc1605362c28411ea7657ce0d4e162c8ef33b59301f5a6710efa1548411a00a72cca284ae84cc86c353ff5c65ed1cf0d72f00013a99b83440df51a24e69d1d5dd3fa2d32e0a625709a0d98ef9756d1b5efbdd567570f9f8072cef1d9105d9525a62bd3ef3a665a5ddd141c383bc4f28792d8adaf0efc6de286c70f110d79cf22417416df9ea2602e6721fd9059348d871af4301b7406bf7e25800b5f1ac155b682abc78e1aac2d5f36abdaa036dac52df08e1e21239bec4af7a770280b9ce82bbd95898d0c7856c34254e55dc110e8af8282609fa2582c4b654281c20bf65face6cfd50021f6f4a22aa03ecd58fe62c0a614832c6c7f3916c95f3b5ae2a414b75cf35e28189de5ceb33244ff19588a4206ac9ac04795317e5b09388906828308182dccecd4d60b5bae6a70c0eeade32f83f0c76fdfe77578e1a5ded28edb5a2bd214d8b8ec4372afe60a032cd14f251e95dd0005b73086701faac616012540f8f661dfaba67981f1773ec5a71de4a456082249a8f0da29eed093d2e14d11979a5d96d206f4acb7c9acd96b2ab6b18a5392508f90a81ba19aca204f51148bb7fb1222968afba7668a72f9afba9d04980f647b42670088a85f98502a555a20a53abdb9290c2eb4da9f542c6af5395543f2b7f5cc392a1a7a55ce3c320f4725201f401f8fa633e1014194a6d4e81921871d9a9506a7e7e07fe000783cb2855bbe7c8535594b7b56251cea79472b131059f1cdcb752b4627886989e1e01440c327fa889b056067e27cd98fe778349a55f2e79cbc1ae6caf9d03fefef85f4e256adfd57decd4e0fc7267c005e93c4903592fcf0fda1b868a963d0cde28452b5195d8f25cd8098ae698cc4a223f9bb215cb3644f34c0fc32abddeeab1d8dc558eb9bc5a1922fe2a04e8a6595994485a37cdaa7dfb721cc206de72dceed544bd0d1b12b7dd0e2526cb1b5d69f8110184345ac83aa49f3b969d2006361a5466d620c19f3eb8c57405f7cbb1ef2258779707b064611cc8c8714f82824b259f20ecc6e0771547fe9126aa9c870b1664aabd5ef7ec17f9e28840418455ecc540442d3b815492130f20d87b19a2e0e8710183d711163d3805000e9356df7a45e1ea4ce91cb1c8af5c43ba27924cae5e4ca9dae0ada6f9f1e804f8775e2fc74ec2a9dcb016bd92248872f1c5524445f7df544b473cdab912c7cceb03ee2afaf79d654fd9e5cabdf9d1bdbaa630a35b04c943c829cb8df1a14092de42100443bba3f753c5406fdbd8761b241b3cb9206f04f1182b11e3271266d810032914c8fc6fc04ab14116699d6201b0b85b67f15eb4c8743ed18642b49ff3a98c90a5f091adb8970041bd6f33253fb9e1a765dc923e7e3f0fc8068be3e2641e392d27a4e41fe238bd22a529b0974f6acedb1b9684dc8adfb2fcdd5825590e4ccce397f338fe6e253b22aef37521eb8669b61c278bf5b2f2c7d12af20b24c0d48fa39af7bae2cd540b3cb06a36023516efc6e328c5be3b39108dcf64cf19cb1c5cb0a7804cd0919ba6765cd1d3c3a7b893d04bd3602d6d7967cd5d647f923bc7c6ddd232fad581c21855c347cb72a8e8b11381da60a35bf36a9e2fa417979c9e44afcb516ffe3335eece419fc18ca66a8aa86137c6d187d4477f3c1b224a4570e777a82734d8d91b3a3f6a1b2b592e834876bf87b83fe26f73afee4d1baf620a284ff267aebdef796c2f77ab4ef265f75db2d2dcf1404fc278335b42ab937d096dc668222819c4b7e001550bad7348f60ddaef1f870ec87a7e5461a18e40b3bf2d2c33b15d27a91162f135cd9d9f137950444ba0d4f8158fc048854032d2380a8e3ea0b9486c43fa7881ab2a47e66bc65226c89a41bdd9d224cdc4e130ec7a188e272c0a918b7a7c34405cea61fc625d8d00a2e95d25127d8ffbb0e4a0d376046dbfcfe0d915df86990c8c2120bea40a3e84bc95549c2e87905a9b93859122ce8fd27ea352ca3e2dab368f72c28540be4feaa8003b83b8ca0d57d97babe6fcf090acd7d03904873b36fe6a747f22bd012d9385443dde0881f3eccd0e1d3f011663db221fbc1d5a6237d9d4fa5e0e344274d7e4a624c835e971624d89f4c2755875fdc975c7d66ce458b76b6a96b18a0aa87f6b774bce02a40459eadeeab69d978dcf2832732b33e60886c1ea3d229a88391ef036c97197d260d007317ce7ecb11dc6bb6bd01446398aa239c61b4b72fb59fa30ec49edf71fc3f6d88163b52f53c69f543aa41d9b27c25b6671336716978b88f380c2aa66c2d5c4c344d04ac2c3d19d7c195ba63b51e8a4c2fd3c7410c198179e24cbf0c45cc47fe426bd8714eb2c713ac6a26efef0cfa00654cdf8793f1fb73d83cac7460ccd3e803e50000cb3dd5a1ddf7de3b89923adbcbe87dd356c98efed6df7401f8e345af1c6a21aae99cc274990a090e996a06ea87a144a2606edd4aace9cb7dfe9c9ca43944b1d0405c2520115e273d0d25f518d29e825d28cc8276d42f6535b17f1caa165e01cdd932b79f79cde1bd3096e326862b07ed307c9a2e8eed207b20743b9cc845337b9560bd26aa003a050c76ed37479d1d10e1750bc22a87bbf1753a122edd46a0945beefee678133acbc7990b0c7e08e805ed081ce8139cfe9f82f95f03bf0e444984981df05f1473026f3315a711ada087b792817e52dee2a4440f964eb3dd11dc091cc03010867adfb3c5de5830906c22568bd891cf05d7b972c2ae41d0addf355a8d65bc5d708b167d53ee0c9dfa1bad1075e915ab905846755f4f5ebad17aa8165cbf267868acaee4d23cdbfd76bce7e721f88664c48965b72bf13451fdeff2f0a19854f7422a6e581ac62ceab9133a90e7ea5580684bed3bd6e4016751ae16b7e8a5bbc72648e4c0956d8a71c5a919b86df7a218cca83f80cc9da222705fdb70b75da3eaaac9773acb7cc835b05abb6ba6ec62010027c9327da8d058070f37fd0b6ad4dd5f4a2b8e852252286acb925415532bebddcd832edafe4e37759ec4d3749be801e0b7209290e9f23de5486de94ca48b179548f7a123a28a2a86c4cc2bcb732086420b285fa62549c606690e42ce4fd29d3388c44cba27f0a2561afa6a469834bd94904ec11cf45c12e9ed91e002078c62d61f9a760143690d3bc91dee5fae67612e1c44a0b5427508f90595e1ca4c7852a02d6f265fc6e79bbfefac861dd103d7ee20d6431989ebef90ef19048282dc781f70967896537eeeedc2eeda4b5379c56ec91f81549927e8bad118dc4bab5b844e3836cbc537a474e8215c276cecc1664d799b88ce5dbae912bf14aa30a296bf99c1aedf8bab2f558f63c26657656463523d5c0b4611876e4d36b44a57570be873eac737a0bec952b829080dcd414f99e597c9ad42af8d1e6de4bbefae577922a823368a4eff324f4873e56ff4d3ebf2624a74e3db4128e99f2a034efc17b8ce7c06289b768ade24c5cc4acf06a9e77fc9bfe9dcd3e5e4766c0518828d912172f76f4ac76df7038fceacd97a9df747595417afbb37f2a0dad95f274a5eb7e3366c837a4e656fd85d6229528312d29dbee19a96d70aab0cd19b13a70db0c7494a0b67aa3ba728a2cae85d6b9cbc5354bf16bb31c9648fdbaa9f81629d9b9895be3c3cb4ceea1948227f91fa93df06334f2579fb6ecd3fe1c60c1936c36842c259cca1fa975971028b0f0487847ff5e73934333cd404b2ff9989d9eecbfe8a0b155dd3034821292100ae78b480a734caf9d16778e78a9b4f6e4686c67eb66473aafa34128fd0e157f91648f752d2f9b0c33a5264d0b0bd7e9594fa4e2ddb4ed88fe321283ee71901276c69abecdb682e1dda81842b8ab71339338829861ac317c65bc43ab86e66640c2e8c175e1b6e4e7db9e7be03ce9c81b64914b42154bf80abd1a1cbadd259998581034e6c8f66949abcb537f13fafb7b42581844f567822992abe3b3a62599cda7124b6fd4b6899958aa1b8200aef594bf165823212d25f4e9159b6d3148029faf766acdbb7184b542f11bb67072d1c639207b2034b3db1a775e9da8c769fb7ed3782a412516dff6cbb01c0290ce48dc316b48cf6707341e917e2fde269a79c7a83b5a6c587395ba7f8a32ab3ad5a4e9b8b7308bc4a855a3461e4c4bb22712463df799ceee75191c49094a4179914d3c977d3b225b669fbe84ac6b30020edbe571d4931679a84475afd468bfb46d84d14b72bcd1efe0dff0c58983e33bc0341a88e6ee1556eb01dd2c46345334a1ce150c1221259969d4bb2853048774b7e6e9dcc787f5764c9e11e9c6ba6efa2198c2ff499bbeb638fa275200349872f1e322bda9b6fcff0ac981a1116daf47c91308c6cdd652f11d94d4c7a0ac2f4c4819f3cd460d1b0efc996b1d1839b06f453b513e9a5742ab8935cac8040fbf1182e300393592b602890b817383d46e78ea98b5d36775c93e6e1d202d4c120d7ad7fbb4fd7317d75970816f97243d7e3c13f09e2cf8f18fef080becd882b6150f02108fa03204e295f82e588bb17216a671974c5056945f8c5070f5c1c17ece4504273a3f38f53dc28886772f786572c9933de990e3538b46e0d5f4c06670cbf8a4aa1f2307bf94cf3d30fe311f9de07466e9d191d39d8592e83674370a45f0ac094f0c72ca22616036cfc76f4d9d325bfc834f1692f07498f05a739922940b0ee9db3d8519c14373c935b55b9b150ddc6356d790497786e22fef87c2bff7c437ca9d3072ed6e05d0d46a30fad13b11f6574a5ee3ff1938c8394836cd48453e50cb9cc5322913ab5e117dca6477bcac488ed203994ce9d7cdcd04429f35d865633ae241f0d5d96b448c663258664853bbfba44f7db61a67b7286972b9886871dc74ff5d588b9c9adac3452588d9134c0b4167678ac481de034fcd6ff702f05ce0526a4bac9b7eab4544c1103979435b57b15321bb1c5e158a9b428b0902de28e11282b82dbf53f50194079ec2bf9cfdcb3c67dfce1eb52d71791590bb8fe0e361359eefac150e132cd5da1a596e3048e89e70fce8fb99dd2a3e12578355d9ecadb0b49700158c7d5425ea3676c154cdb58aead46e261fd122886196ad6befed033863ce41ba3622675b55fa4091465750c1335174c9b96e0ae778c434c3b83293ee0f374d77429bbfd994131d76be962ab5a4f571cb6c568d325eb090fd16ab51a907d1ef1f432a4534a1ce251e7b78b993ba3b70b5be49ee93a429653891c36894dad288a91215132c153404fe72729600cbc8f97ab9c92993d719666a7b49a1f8a1a10da4f430f0ec6c3548ddabee727a99ee74c4eff5d2972b80ec165dab9d45cea00bcdf6d36afd2f26175193cf0a217ab118ee394153a6108bc9e23a0fa3f751f69fbc22dc46ea1b1b430683d71bf25265eb78522a296b83edcb400c52074950375938fef21a9f5366c1482c0e04bf0063d5e70f0c29ca5605c03173c4be40effe656da3a6ccfd0fc010a8cb84024882d9531ca04044af6f58d298e1b842be0b389c163cec0929bf993f536e412bdfe31c77be8e181fa823a6b9167399028d05df1e1c5ee1790ee16dd19affb8a65f2a197ac23cae673085ab2b0e68a9b4fbf6ff36d81f999f12de436f1d94915d7a45befc309f14eb9a588d9714a7ecf978df17c9e5743ff9dca042b2d545545e15cdd6251752c9217e11dcede57aaaccc200ed4d2b7ecfd48bed58be4b8561b36d694e8653b607167c66654dcbe835915383f4bbf52f8b0ceb8f309551a56351e62623060c14f34815565935ecc9510b8797499ed577f04ec11808827b1cca186c1ca1ba5d666f64c7c32672d38ee7233e285c443ad5ffd304e21ce0771ab12c2a9069d3705e762003248fcb72a9eceb5dc2d3cb95abd02eef9757d8fd98f44aa4d5377a798f09a2b9af3cda5833287cda9458fcdbd3baf9a3f29c4e4b5d35be448f593b1b96879b3107ba1ae94e291e364f7ade03a4c8ecc7e526bfcd5933f285d565abdbaa893a7d385650c39624752b867c8d5a366f75081c4294a2642115d60789f08d4198f6a3759fb7bca1a2aa6a34847bbb7e13d032698d2f39d035aad0f435193e406ea85b2dcb5adcb0d1b9163a41752c4ba46c88e6e3229200075884ba4cbc914ff9dda7546c28f13435ee1f160e972b1620926cc59ade9e53bfae92e2988134d33201c9be9032b3bf9ec6a2e7552c8cc34c7c6202b103fb2805a8922b4054406c6f61ed0c1054815f5143c4446e2f94b2d80f9fb28bbed5629c6d604fd1dda901211565869dd4e6d920cc51eb872f7ffb286de41877bfd79b1a63861bfb8695b650ed3df4f68526b30cb57f2dcccdbe21f022d4b46b14d1962ec2e11278ed8eec68d57274e3274683408353f8f793bc9953814da687893401fd1de14e4c486245a1685f76207a54920387398f54b6e01640aaf6b41ca4e7755bd5ffef1c82934c849a6d0696ae87bf80d0b23c4e04deaa35f44f0bbdca2314a7d13b9b6f43243fecbe5b2b26883c4dac999e5552b6242f5ef04c224216bbef424ed0f095ae5878e2d0fe26af9b1a3fb6e7a8b05965dfd9bf3ef8a6f5520702ddfb0053ac71fd1c9d1fe6f0c0792b41582d802c2fb8a6a4d849b774cfab6e20617e8cb0c5248d4c89ac753d66694d65def922700dae8a4492ccc928375a6ec366b37ad06c51215d11bae78fa8e9fd17a3f0c5b5c916b1455c30a883c7971830c3d5fe4acdf56f38e29ad46dac581ddf1fdf44a3f686c7ea8e5cd1ae73202256efa617ca297bc69fc77fd32a0cb7ebfd280f24cd075f55e4f21f791361a444278ba7b29cec38769b7f2d46d13f1f7c3939f746036d577fceff81818cf0abe00ad9047bb0ddd2201c6a95d606a3bf6e59309e521a6a9d6973e8002449f0a23948c3bc572358e540d5192c80bbf609eb2e9ee8ee609242fd95761da0bbf585ddf20b54fb44e7824feb954b17b07bbcd71e3db16f17f259f0e675598b4e5c0f7d1b93acad719c800ac43108bcb2756ee47d186ad8d4a0ecf3bbbe82a12c791523073df6a809b959bf71a4ccec1a1b0134107e9da570824e533cb62d48deffe74fd40f0b60cb398a54a5346b753c6fe26ba7ce484f7ac1885bbdb428edb5fa26270a04eeddc8150d62123a853ddc3415b881343901ab63ea7a67c1eadb819e04504ac1d8313bd5e93ec4fcaa68233753ea1d2a0701117d37d9540bc2e4f469bd6189a0f36a6892ca125bbeb19f34eff60f37549362ab8b09f1325bacdc8fa35884c8b2f1b429bf89a8feb1ce22dbba4fb3371140f973b721d0742950c6ba2893d258639e8e04dfaf2df43eb07df345133054bb43f28d72d193633b8315fb952488e706a900b8c399c03e48e79e1361941f140de864d56dd1d1db28e9bf55008ea1f4740fad4afb31f179732ae8f78eba753c37ffc807210ddcfcfb035e250d3e5d865da17a0b93de4a6d534b79343f5b43ba2f6636e23e6eef773a103756b319bc184a5e28b3d1f88b1f41b2a312c1608652feed9b2622c579aac5879c0e891c41d8fc58d1ded4a13db736d8f03aedb190ebcde8cf4d4538eca15f3d6208452a3c39fb0d7fa9149aff3744c49a22028075fbc623d2179c54f0a276f76dd8dd40191c3a2becdf1d3c55b34075ebbcad67b112f3ebeb85672280e2005bbcc4ed8b8bbfc72d1b17152c67ec612d8c6a14af8d11dc9c60b988b5c327ef1b20ddaa97512b734ab1cb1a64540446f33557a86f8a112b62d5bc97430936f569dcf9af100da948cd16f32f0689432b5d28bda8894879631d6d269b76b9fb635501191ddd82bc45b0bf0f9003ab193551863b7a1e1c9fac9c0d3285c7b45f4fedc6e76f59e77a66a33082024cfbf642d1ab5dfc416fe0f0dc2050d4cbf5fd50d6d83c9dddc6d4463e7cba0b9bd301b6fe7b3def0c894b329c9b75e53255145736f7b32b50eb8db5b484dd4bb9949d90ba53eb0a726c8e2477505f048a8074b5d323687872df7825a7e026d43edd146c7a6925565310a581f2a2146f232c155f2cb5f5cf3b8c8bb1694d2266cd6d218503e4adc893d22d31a133eec4fb4d6ad566c4d5c7e5174a84a3e4552eab158132f20304a1ccdc0c8b4e8054c9952cb07ff48417f3e6aeb16499a5d4eb725b015c115cc468904cd10ba7bb176bec330a71d6e07dd0a03992b2864559c0dae00926d3402977d4cd2e0416e20599eb93346da7fda49f93868a632c9f801aa9da1e721c4a4e8482e86d0450d445cdc9c44955fd8e9e526313777781f8891350a1ac83bbc2394e06f27c2940af6b6b04aad1142f604778844b956786d1175a4c407b2231e8b671060ba0e9d2466a64cd26efc83ed25d68a6b60776d3d937ca4e660c4e36f6dd83d2cc96c7bfc8e74a5dc9fd394e1f5428d938ee767c3febc8564e5cae16fa257089578235f8832c1b90b5fcfe0f5ac49903e64f38a50f883efdbab923f09eb47736b703c9607632ab956360bb66a0ab35d5c99f0dc262d06e56203b4222c5252b73b417259976e6734ebb6ea76237ce1d838d26d8f6a79a247c215a319c070788d98db04a4a8e6e1210b4bc0f5341ded8ee73b87367c536b3e75c8669aee0c42239d9aacc250479655943cda30a1ce9cec909b12afbcbaaa83f1c2fc8fa98a00dd0814b6f9f1f381b193dcd9238a2fdca029214e05d44f785ace03a2dda12e99efeed5e9ce9a3fff31213ad384fb49e1a220cc1a3b3dbfef05402da0686fe3f74f2cb410493af572925d0be4060676c0228b194b66dea76d04448971c8ea360d8c968dcef72e172a213852deab1469f4975079ec5cea6be25b532ac34c8547860bf5987a0b921839074adec97a71fa17ef36051bdc9db0de9d615f6bb341eeaa660cc7343402c09887bace604c4204038321d8c1a6ace8b738a3c2a304a257ec2a5119037a2e88ab8c186c90969479afb88fe21713977e03e6c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
