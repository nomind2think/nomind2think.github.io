<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3f49fd4d8dfbeb80785c77eb670ddbe08f43bcd73e0ac2a7ff10ccc16ef40e7f7c4c319daafca8f41b55704ea1294053e35d53a06c141bb78bbc5fef9a25c2582b3764bdbda5512673f29ec565347e06bee38ab415f4de72a1dff266cb95c577e60d06ab3200543bda6eca969a882cc289f003eab98a559873a10a2e5a136c04ff8947c96bbdfde4f7fddb7acb190455231b52c12dfb764f8ddd182dfa068c02b119a44c4fb72b1a1f89c08de5942e7bc56f1d421f04bbdb668162904ebaf1a6db77ab54c7a655087c12e46615e75b651024f4dfbeb77bcb17f92527c0c296c5638a959efd70690c3fdf7f63db07ce2f292dba407e16f538fb94927ee2192b37df2c9bf1fb7a0084d30e9e36549b5779f3c7a8f07d46a664acb6a5ec5f7cf1f40058072b91d9b8bf55e38f14cfcc63c63f7a6ba1667a24095d0554a3e4b5d64b883618ab919aedcfd694be34ade993af3b0e6037ad142638a91faf0a4929228837290028dcc1aa837b154baae1fb73e1d802e307a16d536e1970a25de147a957dd12bdd146bbb1126d180f3efb26b4abfabc5fecfe1d994ee412310236a8f35650832137cf21c91fdb2460299dbcbb3056e5daa91efd804adafb6ab1ac18c7564e68ef65e4ea771e402926850c5fbeee53b76be2ccd884c72f316b9f8ef23de6dc9b05cadc1baba343a58bc8533a5132331df258b6b1f32c5dcd56df2e1e3ed8bb05abee0127c673daa4f9a2ffe1ffcc4526af75d63c31d8973c996535dfe979d8cafeb0b3ae62998edba5e9da2a584d4cba9dc2560364727e454441aece72f976ff077f6ed26141126ecd4221bfe5dd93bad0bdd5b850042121d161467c953026b4f9119f17769b4d8219ea7a6fdcb07381a3a7f8763dbe2b7993c9e240c7d9d13936a7338a5651eead244181c16cb55403668d48107e1a457f3c2b41c78515a70841813091a0546f495f7bed553b0bf88addf2c4462b653d70bb6e6a146634546cd0eeacd1a96fe216e061cb34ae7dc1f5a34efacfbf88871ed690343779c1fb1265938d359886607db65e07a912f84c1a64ee2cf674af9b38592695ec1d7739976d0a0210be481336246baf02b8ebd8097fe217b79d84ef2f570e354a9cbc842cc3ed53ead0ef725aca0a7bb9f2a992ec8c36445bd476eb2bd8ccf284de16c1c00e49c8c7ab11326fd911a6c6169564cf24a4cc8b0578a3851fa4bdc18eecb9a74d240eedd1e34f769435bf6771b3f774cd7beeb27442d6cf30fa1b3dc4f910bf6b9dc7c876aed7c7410064a444aa0da7ace90b3721065f6837e81ab35a4acd00ede84c5b2dc08c51474a48d111d8b52a6d688551b978f420fc08b82929c551e262a88c131a5286c27e3ba878c3a3ff5f81585204f9e54fc08d515c4b9e5f403753d7c2d3192d13612cac155f8fff36e6ed02804e713be9fb594bc5d4af96c917e5678aa6d2b1bb11c8a07ee482dc94d407244a5bbbc903ca3b89bd93a561da8de9fe9c470bd813c03cf8efdd9c91ff8021998955c85914fbe51750ffb1bbee3670050ceb36bb0ee415ecae0e77429feda40d13fd834f4b53e7defbc2cb6e522972728bc8f25423d9cf412ec7993d70665afe64c68ae29ae2b84316fb8acfabdb349f31b4fa090aee198f5d29b17dee22fd330298bd20cf992792bc74b83e8319eeaef95ecc3ffe7fac9a8817442ec6956ea7ba4a111663f5e68487f28a803070c31329cbdef1b11a016bb2a8588f116cfe3af24a838240c2c7fefca2a4e74d107f24c03ecb06cd28951ae88dd93bfda5cb14bdaf572762b3eead7abe2e6b8e6084b0eeaf1e3d5b871e076203436d71ae4ec27f2436285070334fe3cd6b19da71f21a6ab1db89d88c3af3a17db53c480ea1ebb3ff9b40e8e27bbc5bac6091b5dd04059a52ad167dfa2a8297e640f49634d97beb53e124c205482b14109a6e2182433dbff0604774e1c19da8801afb749b8d5377c9763c271046ec6a29f812e958b3ceaaf712392a14df98f1e67aa0d182cbf400062cd2a2e8a98f2a176e5277a0673ed436cf94fdd22e0397ca71d5b269d2268fd70711936787c1f6ea7bde144e164ed400f577ed6cefbfe64ae8f48302ca39d899c59e171da0cbdd45dc8744071b8a362e61a8c1ff28a414820d467cd3707328498cc9c8c2b0e37c74dc67371c2c0c1289f506cf69a910d20e8ad8bb4a989fbc33d99a5c59f74132e400fa91c5418612c9cb6e04334dfb1fd3e4f2b7d76318a8c8c8028acf37a779fb955ef4a626898fd186eaaebbbbb950a73f0505c8eff5390339c67be400fc851b6c2100f7d64073304a58ae24607ebb3c86a78c73341f79fb232eaa901ac4306717bc951a39da074e8b267ac01a333ef98e8f724720f8c6fb16048a40317d6c810f2512b0c4df17866056547638960aec618e944c2ed6facf192ca73752aa7910d8913e3474a736f15492b89b11839d9721fdadc92053972bb91365e94b4d683f8b65d372fc6f6b067d04417bcf5dc9e6c1bdfc037471f336e01b861980d4c73a93f27e14bc3ef1ea9c3bd5ec0b5e534242deda53ef490ff3e8faf54a444e6d6f49dc55169683a6ef3b2980b3ea7148baa2d2eaa9b9656149e8dd4f69e5f096d4176c38988adfbf6efd985def06e0fe82e81841c3d7b3a0e4f56a71fe8b1dce10c3743f23b69fca10de64a7d181cb413d91575dc3abc1efd6ab72bdd6f522dd5c42e6f907f768a3a596c8c9f4158a81fe328c7caf2bfa1ecb56b90a2a348a9f7e4fa11f1a1a1810e7a18e89a278b2c7e392f3b5766f608ac4f8c2dab9f8ac3b665b7605c0d2fe6371ce0fbe38434c81477c10ad4ad80535dd603612937ad2aa3f4023057c26dd3ed90d915a2d51a974ecf2609a6fb0799ab0bb6b2c1b1a4c991706740ce149724d549b034123cd1993524a2425052410d2a02e937a7f70db9217d57cf147eed8dab0b69c525c5b4fac3636e79597b7220dbdaf488140bd4da59f05c31873cb2c1825ce26bafcf23343958cac3d9e298811dc8899c67adeb1f70645cf912f6c3e370a11d99251771e4bafc0d16b0510ca6715baebed6900c8979ae80d4d99d362ac7a8dfa0408b420f22465f9df99222c3204a917d780041e4bbe71665849398cd36daed028549da6b8daa15580fabe2ef4930ca9f120496a175e6dcc58a2a811e790a4636784ac9def3dc268eca2f2aa1a571cdf9abbdfd3ca597f2a0cf037e7588c6e98d76dfb397fb70dcb92489c3a31e117a22bdfe4eeded7ab781bb82b7fa8eda354b6e52a49245153ffe58f7291248c89449433f3f0f6b94ecf748e25eb0087b2cec31ad6c71d32f2135584622b05370cc4bad5e406e061d87510853412984449d6bc666854cb61f9a6f4ba35916190bf9deff867b5d6b4534abc658b2171c50961fc82f6236f71cad21d48a0d0fb30b0a3ee5c6baadf059745be7b73b6f201b75bba856140bd8f6c2220d33d5a0c791021d1c3f3297ed57c271b5acca085c5f14c29002a4413361751d0a84bc514d3c76fb5b17b0e47e30802f7dcfd96625c4a97dd03331a71965056a828d1e98c76f301e92b7f9d0cf280fb6f0d58623dda54042899eb1931438e46ee9eafcd73cec46ff0d9ff11a9e0d629effccaa72e6c4710cd0141e511aa6833644ad6576fe3f17d50c6ad0b37cb03dcc268c75b60f61963dfecaa4c474894da56a343d170521ec66812b48915b53c9c982fd038c72715bae1e86ceeb93207d402c0fd35c9dd30c7be31892322f44bc70e48de62917c0573fdef35bfec3021b8aee98c150bf8385cfcbe2ab6ef21105020cb29dc5422a9f63c30bce4c0090384c3071411f984fa92c825a7badd0f395e45aec490032db91ce2fa0a2edd84101fd9c2195e930ea65462ebabec14e5844e389171648dd9a26719d4e36a6102218a2aae2388ce4a03f0e19461eef1eae40e3bea313b630f2fdf30152dab15f81ce2b8ef52932c4680706b1fa9df0739abb98c884ed2f182c39f583bd3656a884d20130a9cacde0d98005edb0e948db9ef1ef669a9eebdd342eadefaeb6fe1dfd1491edd4ec27eccc2c33ba7ee737cec2696950b640710b7bfd40a21f6a4a3de76a082df4b0738678a1180beeb90fd232e7c1e4e1ab5064d938f5dba7edb77d42e8a6d5b33bdb68fb55878d4794dc00c9f44b3c043d2a953ae3cf0e5b006220b5697b969092f222ac90d9fc12a8067af8c954e2456e199f48b339a9c3ed4f747214ab1928574c582d2d7a2068218096e12f646122d7b241d84280d9310b4252a50090a31c62e0bef265113c5e9406ea3970e3118a43ee949612dbee9921f14098ed098ab0a884cb34980974516b7a96c029b0ab115642a7ff5775bb95e8eefc525d476214ecd01c15d5bef8ba22e5d85bf181d47cf07c60b89bf4651a778f8bb6bbe70879b097e6632309cd67b9e4c6e7fc23b0a18ed46dbbe464490f267b724a926cb5fd12e63bc97e5b496319bcac9ff7b3ce34142b0ed151b5c05e435a3280bdcee9a475376c688615d651b64f2148e9f877a6a3f71da720efbf3bd7b3ace129be39c530354b698157b71a5ccf723ece40a009e66e913229c8e7c5599cb50ebc1a6d0f9e6b07167fe2e6b26865afe1309c12f181bd5a63232f980ca5414c87cbcc1f9c5a43bfe1dd5a3891883562203b68f449e48d2eea6314ea46e1dfdd5943a78d8bd8d3ee9af7de3b56ae595036731705bbb0a87290cdda1884e5bdd2fdcb05a62a0e5bacf713191765a493b8ead510b12885330d07076dcbc0a560aa7805237f945439016b9d8a7c04335391482c1522e549e31d8e2fabbbc3cd82a24ecc1e042793085aab0fc339ba6b947229f9d062b29ebfdb530ec5b80cb0acc6af378557fe9d61ade124b908436770fb1682b1db9e83577a503ce15ccb47c92f736c8bcf2482e557d083db5cc1c2295fe73b65283d5867410463ac1c524fc197685c3a12e425e454349183359b023673402584079a4457663b65fb5e03e0921eaeb355b0e9e3646404585ffa1a60a17a5779414ed097be13d3d64d84975e5891fd48486fe585a5b161af06d185c78f1bf3c9fd4f35f856a6688c0537a3af5b5127fe4d983003a1e62f58b3c66d5954f6a6bd3e8416fbee338bcc88e5557402c17c112cc6484d9c08e43390d52688d9ed94762bdd48562e2ec9a1d650b6a5ecc2762e09dbae47cc4706482c3fecd89a767c76831912478e5dfc507389801eb258285b9e3975033634e4c13158a16ce152eab9ad518bca707fc68ab1ab671c5047a1c0ab81e47f2a54efd3a254d8f3fe7fb0f772cb91b4dfec18d426d7546e4163c2d0cde4087f9489cbf565cc6daa3a3abdabdafd4d85e335b00993a0efc42ab69a47a68009601ee4d234f746aee9bbc750408da9f81bb71f3a3dfd707d5829f00b2401745d6870987b49a1bc69b09808f8fd370adc589ffd1b854077520769be6da1a162a1f3c002675475748c9cd27b2075bee003ba012b06bffdd2fde7dc671117b9963b5986eb0ff34b1ed229ab0679edb4b38fa02a696c299d5b0fd09e81001ad9dad6dd9b6e3e83738734ec769b6978f93f493aadca63672b5e3a2317ef1fc862852a511273f44b598389be3bbdad0d101388ddbecdaf288f5fef8c1501805f31c2f1597e26bec7fb854aad7649c88d1fb6cef20913a44dcc0d7eb11810ab59136012cc4d60989ae57af710582a0065ff1dea612e93a640b581a7f0a51627636dfaf274981264402240eaf62977c2f7ccf832400d4021c298bf07f34fc6e1dfe19b3a0276beb30f3c75cc8a91878e44b5d89f059a02e5b69e3b5eb79ff8dfc65a03a0b27bf3d202a519415002ecc557bf788e18390cab4524f0fb516433be1d6e12fad3aa4d07e191b3ddb1621ad5ff54dce886514e6a2859593b938aa842d748fae1f6def3da7d351a561c91f881dd0b5b9820c555ab12d08430b2722657f9dd5398d62d8b196cd2ba5a248f6f6fa4f5efde0078fa30b0d1e3debd5a8bf4522f952e8a60ca2073a238a8484cac094d0ef0eee51f29f94abf0a5671db685e3554a493dd4f3f9b662cea0a8d99f5ac1e5e75f0656ba647ff3bd5a27e13cc833b29ec78e84fe7709f094e88399aca49dfc0d31f62dace0668b5ddebc890df712df0ff51be655998d542b4977ed85b7893da041ec20dc71bb2452b1dd4e871d8a2ad0b8ad96016d6caee40d908a81e6ef5a11b917fad6dad362bd164295cdbc07eba8ba1fba7df6d00eb49445e26c8102eee3ff9e96bc2850cf58902b841be8d45e884e1b25dc7ba6a9585b0a57a72fa113029c4940cfba1cd33e38248f211d52f9b0194286dce0030c4a7b754a289815e8a044a3fc97afa6bf7032299ce020b15a7260a5844f1f0f1d5ddec7ed6784c1c129e20ec3cd4d37922e4ae58690dcd9e27b03a240cc686962915505d78406a2fb57e82f8f4422bb999f4a7aef9669c673bd67c003206478c632578645464e075283198827ecc489e1577c25bcc085af27c40c9a81782fae76c3d3afd8859d446b0292693b9e1316d6dc77a4487f46783fe92abefa527de37883de59f391c0b8fcfaee0102a67d0b8be4aec147fce38df5c7129dfd433978041a3391ba904fdda0aa8c04fe43cd04a95e5b1b4ccdcba348c2b6871c72a4f123ae95f3d1c642335ffbca088bf108c9da0b456e154a65294bc29aba8b69b98e92cced4455ce9f634425f33c6602623461b62c213cbc0969d90eb33e07586ad7df20a0e6a4d6cac60a3df9f886f86d499002b89357d1d60710ae4007072648852765125726f01907761673023119a1442852ee44ebb3f59a52c5cb5f15e5f6913dba0cd2b52f1816a67504b43510014ff00f99445b1e280763e7a6fc31fdbcb63a4c68495fe1665b55b4ade43e651ead249c24966dfb8f160d0a371d2ac1555dad699ed193367e90a82f184b930d455f957f2cfd38fddb9efacc6839a81762d921bfcf9c8b30a0d438fe0d9f6bbe33dee92f57990f0df591063bfee3ff8170c4a55fd6154269bb85d723fc27b4b8ea6a02b1ff9b136d89678054bc0524d56cf10dd2100b9683590da5743892e4a3745ea13c046e34d7372e4b1dc81b26df1c25b6326521e16677dd32ce43126e74c6dfdd93d756cb5d45e6df7df8931ef497fc6ef01d9114fb5337d309b0d3dcb0ea9ed9cad9428906835807b3e4ae0500484c54c2ca13ef73dd44641ae60dd67d04d842e81458e0a5c493b46591f58e633d695800b0dac36dde43683aa9cb13c5443cad22345083e7c56141f63a0e33091b6f9b695535ce0ae7a5a47a8b4712623c19ed610b7d0889870502b3c6bac4bbeb637f16f0be09c727ea4a8ad62661fccf5a2870b91970813f0c3bc252580f84919b7f695b20921b04a4108787dcaa107c4ecd835d244e07588d6673909d524f7f6a27de0b9d68c5107c2b136331c23e0b8a260365bbc119b46d0f4ef42e98d8ac6edb8395034df30da216223c66e6456edf0c2cb4d1e5c01e86f4f3861d4c8c1be4970fec5d22dafca780cd7e6ffb2ecbcae66c025fa1f8e57417e98711b87315cbef808127f54de4db92e2563eafce23fdaa3f1e66ce5fb729d63cb9ef220b7372bf623e03b2e6ecc3434470a1a1be4b4c22a99e45e206c9e8864dee0e8460d02444cec6cd7bade9696e57d6665c7d2c6f864e070f9e7d169b236af9e0e6f94f6db350618601a979b6576079315dab2a467f0a41568f3be90a77db568a27e9f1f31071da8374b77e7e0cf565430f9c57c1a99f012020850859faaf1ba0ebd54c42313fb4e869fc8ec254fd9e88f11a2da164df4080f4dac82c7fab79ede5026bc0c12c3a1ccdbb81802a17a67731b80853120c5dd802627f09f6ea9a96a0d1d8343a99b3e87b525a3b8da557608c1248a03a6af528d904e5258098900c386f5e4ccda68f8e4f7daeec2afec6801671ba657f98fcabda27cd0f7f2a25971ed8257dd2d4d91e75409a50f8918d091b978f7f082f9e27e1cdcedda717eb16086d381ed687aa5acac697847ad00f4db86e869222700a852f80b281fce5a95f483935f9fa8c3551465c4127d91fd51e9495cbeaf10730da2e6b14ed9527a2d1aa4f19c6a8e5c9e2c65d1c660b8528c4b51a6bf0a8d8b347a9b4c5d9be21d96ecd32975a943dd5fb16e1856cdf1fd7f1cdac20a3757ac4b86258b4f2abcaf39803d8c20a37591554384a02d751f266c64b4fdb330def5c44e34e1b54bf803f77c3d1077b616dcfb78d0cd2da0986e8f84c79b884556963ac641c593a36885e7ebac17951feb83165fff2d56cc3e1c8fe95d9ec1884fa2e4aa952f018c915c09b7f672bbfc358a6171642f75e38379db4d33ea20f11ec43f37846e7aa5d6f950903cb5f15caa74c208ad53d75abf328a9cc7bffe5646adbb50b8e421fa0f61ee94e0dd3ddf05b400f8943e5560ddddaac8390e792cff021915e5a5104d07c744501770cbac9d100722b136debfe9c079989fd7d08b0096dcddf5b438318f0f8348bc98e0f17511eaffceeba84309d88c8bfb87996df25fef9a5037586a6b2bb6d836d1e1ac3c2d018bcb5814e8f8be84d0cd4db1350f6b9f00b4fcdc21e8d81259c56c7c5d92f35eb46f525465906c3ba7b4a3d82c68f1ae1f2166f9d636fe074aa5b33c2ccceb1d0ab8e9af6d31f6119b6d84d19cebb11185e1130084532b92474d450007b500939356d3d25704a20e2704b91a725c9f094b8531ccd11cf22d1fc53f41941a4efbb81cc93646b46aeb83043c4b4d8a309b83e74e6e5870b6045a383e1790ce270249c74d2ff02d39be875b0b87aa11cfd15e00106912b8c2b6d8bdb315a4508d997a29e49dadabed41b00e3303d14c81f7b3b7496514d6b540da4ab71fa361e8f7205017a89ea2a7f7c7b144b08f2d3a3f5cfc46fa81d208b31d17e85d386f2b40b8d76e2a789055835b0d3dc9c05c64142f2bb5875cea3353b90bd29639209001ff240da7670eec94ffbd5a8631a51cdef9e551166b56c5a9ce7a12a8176feac97f10bb7144899a5ab3ba7ba8a0fff024c07f68cb1a4322dad481e4bf0fdf6ed76703e8930e94df1162506431559ce86eae93db56147b38d2e6ed632cd710b8198297e47a7918568d026b989b854e2b3f2b00de7dbc8f248051ba794ca3b2ebfdd79d8592e62af3d451c09aab820253bdab163c0398e13677c6bf73b0caf376466325236cf795acc9678a09c3622fa57c8e64f76c93163ac564bd8bfb5b20b8b5164f9e4488692861d72e6d629f284b5f251e32cd11009f6d7a5c910b86d1bd16e137b8428d6b0b4f22cc91722544d83aa1bf4d8786e31c45286e69e8f233835996e33b3f7863c7ec708f92b51ce400b41c89e3145d170f1b88732e84cd28fdd23403d4fd837489c3b1a842135c2463b397f051bfb188e8dd73cd1426b1d35337ee5f16b0144bfa398f45cc3068b538cecaf9c19f937a077d69557b3a279356de3b2a2f8e9ac964a6b34bd0a1a418a672a037096b575be9f609edf1f827f0245657c3133d8ed79dcdbe2ff9b9beeea614453388f9cc46134d7fcf52b61ddd2da855932f6032dac2d0781d6e8275cc76c09a21e52987331bfa59dbab629d774bca827fcd4d21892ef75d040388859cf51d6ada5cb3d8b72ea03166ca8448f62c36b70e868f21d9833c77e80b1df08745bc184038141315a448cd507b4a03832d7e06e07ea567adbefd39f107191f5078c16b296bc6aab4d0f8ec9def95044b63bd0ae3faf04adf84cd6b13a5645e94c542475c644b65db160d13a419113c4c9e949043fdc4559e514915a53e1a51df250f0a120c0562fade9cb01d180be51315de502b1516a4f783fec92693427962d9a9daec92cc234841141815f6337979752432c9062094066361944a2defe0a35ade8f45deefd6b58f982fe2b51cd3469ddff4a4eeef5b59f73deff6c86dc0dac04cea221a440b604dae5514c0f9113119135b2ebf6c8fdddf8cab62f47487ea51995df238be5625378ca65f904375e09516f1e035a92c547d001aa58b9f0ab1f16f82d576aa5594cc1dafee08abff128d427f64e87873b92893b68d0bd51e07980c2cdef0e9fc582bf7da70416489082940e98a615fb9a6cca64c099f224f68030ad0a3b3f03fa55227ea3e6e58cf447ce12f6593308957c1b56d03ea3f7f615fbe3232637fca2e2c5dfc648574f685606f52fc745c4de090b4275db369f159c3e6c276da19efc06a8e1cc4095c6212108a83549992bb637643056ea632d730f0d314590be0910ff04dad8380fd9a4e3cc0e37d98c0d1c72ea8de893a5ba72f612e90e92b196b3742e9d3f1d1eed54e6b072aba00ea53c8d2f004b2b085cc76cf5b845cae46214cf8abfdb27f5177eb9b93f5cc0fcee4d6e66c1156ef785b9b9376252263dc732416141f26794c3f1f225134109fd62af93f78a42bc383f0a37c85c94b5a64da79f57ae4dc553b7d722d16424ac99c81679584a3131f7e33fd5f589c3d1b3b2254fff8b0898ea4036448c880a14bc2d94f98db5c27ff9f7feff614f46cf30a18fc03a17b2248d3364dce56ee21a165eeb789022cbdef42da161dac9aa270cff7f344200f84dfffcf403192dc8a82df05f0ff7fd7db47a831c20542adb056eac83f6d989215302e5ffda6ddb6a1d58edc43347a18803e032d88a5faea184129cef99091dd532093f161d263572d63e6336d38b6286dd1a5ecc6c6611dae177bdf6fc809795c3a4573e118cad20c3a6e85eb1b47e88c91fe90ada48749319e28e8971ad364bc28934470884a2b7bafa2131ca0f893ced84ccf5580a5628689a155b614ee3e4e7a5707eed40a685bcaf406dc83ceb462fea5f81f402db6e354020c338ee735fb596a5d860187fbb39d163d87b471beec9e7de8d3f34a3729621d9db5db387a73841958687ae114c1b2d13589bf30844cb762128c1e1f9472c5fe9ccfe4560c6f2a69bbf8195a89eaf365254d8753d1e0c347890d6ddf8916b680e1181dfdfda133479045bd65b7d97e1e058b1204e23b814138a0e0379d18ab26b8da6e89a48860749f51d77359ec3bc106db0924649d13f3ca9d6b394604b288299f4c6eebb05d23cf58f85cb6fff84ba512ec97fbc0539e17f8454944fb50266e6e872360e952c6aafb101a372cb5905202ffbfd7915076d004c0cd4177503e3f69f745baf705fa0cfe2ffe2bb90c0a8f43d3557aeb921e14066b85fefb895f129e2f69f2ef581526907ee1796c2f6197d70c9ec08b17905cef5511c32f220b741d0ccbbc63b6b4c15ab0d44b17d0278919a1ee1860ad5634ba7735bd3b3749e3149b00384fcb7fa1373304443bdfd74182f4af6541e3b272ff585f692f910b587f647dc67b23a5635ce2c177581ca57e97b4c96739b82bcfa95315c52ec473e04a7bfa94b058f3cc6c3b14fcb268b0d5b72f85005edd0005777dbb9dc95782fbc7943ab29958ec0635cc0e601e1a0b5258056fc306d61b6219fd3e06b1d2417e7b84ce992a6a2fb7bb157a077badc1be1d2f5df1f26413c956dcef2b1ac00e9b3f976a6e2464525ee0e43741ca40f63f5a07668134aec3488ae9389a28a14268b66f472df325c4b6d79f6eb04708083c82018b37f9ff34667395145eef22fb83d7da8c582b2b0725429956509079e5c0364244616ebfe49bf4de21d4e85cc34b4c207fd3a836edd07d3a7cbcd8363554f16445ba443b27992b829c51ad28ebccc5523b716a3d4d6460d0cb068184be7e37978ed21bb53cb9ded5a1f5ff6f17fa850ac92d5bc927ba31f4e4ca086577626b547f788de1bc85479e2b478ca2f4616e1bf9ade7390dc9e7bc6852cfc351cc52f06b4cc817209bef71dfc792e493b0d44d16c976ea3096c9758e094b0cf6e9d785fa40c5056bbf1f2c8c36b97088e87ff6fc1f0a14cc49c4e444718745ef14b46c6e27b2cd5437279df708407432b6f1ffdb6e88e46d8ca281576e9b298b93296358fc45091cc4fc579bbc5a70f46a4066ffecef406f02050a1da1ceb71bb51b069c3c1840c3cdfe6e1e9e5210b17a989bd6c76fee40956a95ea6883bdffef12d8aa2dfcb54912b5572ba8af066f81d01ed4c25b0407cab2d892cf85979ede566d9427c817fe9b68d8941f055464222e3424dfd052c80787541f359b23807ed06a0333007943fe1adb55fed8a9f122b37aef3c3f3ad32b3795e1dba58771abd55ed09cde678793ff473fc48c0f66cd6366f5b864ba226a808b9e31f203ab09f2b2179398e8e4f78a7c0c38eb0e189341ac87a9f5fe155118d1cc82750cef6717888d33ea4ad9435929c1b821f27405d109e9257273397a28c078379f3c545bc94494e454c496738490e2924913e8f3636781c23d7808d4c9f6455dfaaac00df825d0a6d533463f342ba1a2e9d92418792d2ed7497acffc603932217d454699c9ead3a353303401dcea1962b75c87ef68a82771c049c7a117f3c18b2a739fc7d3c6f78e4dfca9c862170df537b977dd667a8fbba1b854ec220642f9aac7a927ad07aa767846461f5d1856456eb9e9d689ced65d9ae097329769bfd27519aeccaa6977afcbcd770c79a51d072bf5113bbcf37601e1e3effdade9f9dccf9836801324e07bebbab64c3b85f83e16d65c8749398fca25ba32026bbee213abeddd0e1cf226d8d46199d0c489ea1d53a5f44c88aaf8129550987d821ac199f7ff0bed7d78dedeeeda7e2332d910a5cbafce3d17764b6b91b66ae7a2b9064a832bd9d786bf3e176df4f8e01b16d35cdc1c41d01bb27284afe520a7aa3845d5b51ba92dbb177f0bca011255e82823cc7105037cd62a8b523c609d02a9d353515fcdacb47864a6f1d1b8f5bc58b76196fbb23565a118cb425a3580bef0423d5d5067ec61c03f94eddd0d28d4ac18b1f5909bfe69a710a0671ccfc98ac598c37ee9062a5c809219a577d0d836f031c194838423e34d0d32c84da92ed439864bedc708d096756d7532a4d9abf8a2a92999d98ed131802d8e01cef4b61e3a2baa39fae7b6d4ab961ea1daf30eec0786a803a769542b1cbf2e00e674bbd97d4953a96b487aa657462799b24b5b7713bd268b40216febfcf466d8605c49f684494b203de718f4aabb6bf50461ab2cd2d75b47a68875f9a3fe9b9a2898f9446b2eae1711343572efdd623e9b862472c2f30e27a2ea66f73259e39db9ec2f19f6d7d7bc3e0c8320b6e659f8359731aa7fdaab3d6a9d08a7b56c6f5edf3602229c3c428eb2c882720dbbfa392168a4525159c37a9cdff2649c2d5ddee467335e01928e010a05b2ea382eb372db41211e0f33deeec1ce6d49c7c6f3e54037425f5ba2901cd4ece7adb35af256ef553f9c670acf3a364e25fef9a8bcba722df62769ac17cd7026ed4154d22c389cd390247d666c6bec35cdd9e4b46850c2f6dedad84afc0c2fd3d953676b973869739cbdcfe8bb970ba6ff627684dc75df40eb7ce9937d1d24826ee4cb514f4112e69deea4c765e7e1b09674ee8c7707f4d358f87209518062cf0c800fbb399c8c73650ef48d957790ecd4ae0681642771a90f0fb41a64afb1fe72af7feecf51873a95f3f5ff02c7ae5622ee79279dfc42fc1e7ead5176c382200708b1fc6c8002081c73c2609d029f1695b41260fa5eae6c2ce3e82e186be1c58b5f377041bd9cebd4e853666871ccd1c306ee89dc2b36cc4eec43a33571d23062736ddbb5ab04ed866f5331b7153e3009d0092f10f2fb4f53eb402fb93e2e32d39e6ddb360be6c08258c9bb6ec0508115877881d3ed92dd400410e475d450b6d1426864fa4a5d1c1c06eb7afd26b986dd45479ca02834832ab1f8ad19cb6f2e7901e8ef28dc1ef579f053afb5d0ddf637be17183494f28787753994805e34d4e5b1df5675c6fc38bb858e5e5473fd757080510cfcc2461b755055db934d9c32513c3516c9762da43e934b7f247519ec3d69ab9b4f3c6da07d27b9d00ad2738b2f27b34bbad865d441b0f146dc305f8f99b99f7d800d289b5b1ef56ffc1f58b92b8838fcc959dcb40b97c6d6780f4ee583bc2ca9180c2092ec0b047cba5c1330acf6f6c301208f277aab9233fe25bd9bf6c08d38cf1a1dd08089bf2a2d28955a3dfb021d32c00bd595cc61231716e02d206905d512c33853816f5dbc0d6c5874a0d2e9a24472bd22c71306eb8b78186bf5dd46647e6f5de3528f29636cb697580c9bf0f398c5d3f39aa7756a1c6c9a09739d7c7da2dce0e6d9bcb10ed8c9d861c876e646f29a63f8937ff3cb9f685d8d9dfae20d48779a13e2e1cd0b5a73fa267b5f9456d41a6cdeba1fc4470057d341e97245ded8a03bd0085e56c70f15c7f8158b28de053c43062a9d43a59a56c9e786f19dcbe8f71b983aabb6bcbff19b3692f5ad69fdaff8d20fa422e180459a965010757d0bf3f2ddbbdb5e294a1cef88c301b8139ba41cfc0108a655b9b8adfb52694bce6b338bf818340620158e5539d9bcfd7e03b71bef0b91387483aa1beb78cf94ab472ef00d6e6ac3ff123b89639f625e507aba9ba0f1a848daadb99a8268d980ee057424dfad831efafa8e83f2a4f680e51d4effd90f3dcabc1362568a372db344e0b5a832d40041d9dec8af53a2763054e415ae14896757e54c3da2b12103567af7d66b786ac621434a6b030ede28c832ccaf51047532c183a47400b2b779e9c5c71cedd294230a0de25eb8a9cbc17ec4215c9d08df5adc2dde9864b0821a8f94dc0d6446e2f027e67fb3d87a5b32f5782bd97725ab1d82a6f3f21ff6a6d92eaf4873bd1cc62ad54c97fba63131c4742ba8367c051a0abdb64e7d44dc3c519c82f367f9bdd34b604a77d37e66ab51598fdaf0020bacf3e078636634262cab63b219bc777447351ca62a9ab7f026457b78f4e11d35bcc6d5b5b5cd9fb530a40054c47acf8a9378713dace3f6d73d5481a924d6c7ca0c839ed309229d97074b8ae6c75f245dd4fe6cd18e07ce7b651cca6daa1b8db4115135717c207dbc1c476eb64470439358e7618a935defb3e04bd3d34f1c06c19be1331a0f550b3b124531135ccd5d9d0ae9d2d74f13d59a9a250e4459ac94168a6b29f300b0df0581639caa558f3f96c0d08d02e98a5ac519991a055a59d46968a19fd636e3c1074acf4988cbba9c905f581a47be35c4c424239848445cb5c9bf3eda15f641a4395dbab688132da003f34a79968ddafd6844ea1d3a9a83e92b749b743d1b39550a49852367342afe966694f9c86441e2791cbe042449aadbc819f01afddb47c9f0e39271c2b0da8ef129e0e4c581d147d69fc415dfd1c6b58ab94ca7247049ed1cb443598365061b44b9525a58ae522a05f68dcd5a0a0e441bf1faae4c3f73c0bc4d4fd2763a8beaf28f7b4a3efcebfc56d87286625f52bc101d5242a8a5cdf042ac55c34d62f6d929b043fa024e4f2de03f398a858f7625fcfec18344c2eddc05fe6fc0aa9d9435833ff3ce2669ebb3ed6655af0fe6c4974c4e7a436b94ff8f1725ff173d15d15fc5f9874091a772e096a9ef8fbb947a5e6820a32be6aa0d2b3ed1ad490c484c16457021aed4a587de6eb50464aa21e0c5fdd2da73b05538ef7d1536240d3bd3bd4e0613b320672305261a18b6825654a1695cbddbae777a35f8c2826790a41c8ca94ccfb131a3b1a471804c50e5f757217c14cbfa57432b0b76a6dbb8eae063edaea6cc1e21d9b9f42b43620768df79b7004cbc3c3d45332bd9699d21d15b7310e492b04dc8cf7e07ec94d38c2ae48cefc85011646fd659c3bdde53f11c414a373d8baf07e0add460af3e2377ed277c46359c56cc7c737e478ef007296e61aa0e5863a52485855bf6110ea17b3263b7b270aba3b85507c00d178af4bb58d24fbee1a411384a5a866a4d39a3088df4ec405eaa96989c191c646191eda1011f794c8ea6a438b61a7dd934d1b99bcf4cd0b0a4ec36c00c10376ac55a907e53087396e9ea25b867fd227df185da36aac09c9106d16cbdaf8f0118c4a908ebb4a28eaf53661b1638fc9a7ef9611bbbd058802dde03fc2b2c9e7893f9ce77ec51e1dec3eacaf367fbf1ed053a7e4671d165aaa6765f7b1154e73b72a7460b0158365035dc1ea7e0e0e9def90d6019beeb9b6fbac55edeba3c47b65b0b2fe5937450d7b60400df0dd717c12cf8b13a93ba978d4676a51b9a6966efaf31d3d3c629f17a6633e12294c0a5165a17bc715e31651cab9e52500d30beeb976a499a540d0878614e50cc45b67015a94392e94efc65e65754aef6c115744f49fcdf3b28946be44742e13f940c6b6ee213426d3dc3f2e1a24a1e1ced25bb2a5935e5d8ed203c19a2c10aa2d1cd715f2ab2546382f4b353b8e125ad860dd6dfc0b9f67780e9f0ad198a95344875b0a760a76eb581405b915946fb1ff5d9b3ffd96b4b2dc82cdb073f07e6d753f48af5fc115bf283ae2d84b489def65f48aae522b460f026c80bbe3ff34ad2b45a5135e7c100a52f438cdf3d0c057d9710e39ff9d330bcf549b3e6dbfd62ece29bf050d5e64a0ef291343351e58f523755f844c0e7eac6175cd18ae83a503b746634461e10dc673a6bdcf296348ddea7b1a70b03a369e90a2ce1130c844c2fcba065c3a5a7364952e71a888292dfff20e633f477dc182dcf89ab0809e1a45cabcd2e5736131dcd90d26ed020f6e808163e2075d8769503d96a57525e1d35d64adb8f099bfb6d233469154e30a5399b5bf0ba50f248a49015344b6368e71d28ce48ce62284665eb5c24db35ddf7e8ab38e5e8a56f22ab806","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
