<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9cbf8cbc182484dc69e40e206ff1bf987bb40c74f521219c43f1061cf308a62bcb34e7e11427976b61cb1839d43519dde6b6e0118b14bed1dd08f0e8edb5720bdc14fb22d26e979cc1ece04e46b17e089d301a9d7ab9f2bfc73cd37d892946fd0b2be9e758998d9497a2709f800bdd0d27ceeab2fdd811ddbcf4692f9c2ec394863e97f7aeeaf83218f69a219c8934d434f3ee6b20d4619058ec55c446904a71c8e2f2743fd838bd27c4c4ca8eea7a250fcd2434f1d9777e8b2d75802393b614faa5ad75e289fd406db5700177dccee7ec87e205bf324d51cb7f28a7fc7cbb97fc20f27ce055d949de75d480a7a76a0ef3b292cf8ba1b808b8a35399a42f2e379e3e916b7b82ccbe49eb2869a238b78796d2ae7c45562e9d3e089fcdfeb9c9319b2d6f37d6e2402ed5e34df0c5d26c32e65fbba85936102691f48bc55011332c87d693b5de9a89186033e5afea48f71fa0ff4cb461a43c86e6aba340c5d3d53567cdbec5019cbf7e101e91fc3bb7d177758d46ff72a2fba08f422537ae475a014cee171c6b4cf1b12fbfbf981d0f4ea307fc979aa4ca5806b1b1dc84d849f3d5a1558373e63c0653be458fff230d95b1ffecf09ca8926cfd0d6de9652ed40458a66e376c961961c98122adee6d5c3d44723d19703b43d55b410728dc218ca8abbd4e48bf25811cc0dd624f99f791dc20ad49974a3e456789108e8792e2072fef44f77f3ea1d026d7f2a41b65acde16e386d95fb1d499d5dcac2af48c7f606c1bb2ed24a5231ec3e3ce1176c1fa92e0431790f0dfb90118195c8ab4fb971e9138343a1b64ae4156d648fd745e5f85bff1b91ce858b5b9ef8a17291472d3010e13831b40314661426db8d44845bff9debf8c053cf0dfbcc584b2a643c48f7e4ae326982d33c96d5c7bf142c2ab92a96d614c3622c16d92e31ff26bd5a3e95f9f2da7b392c9e2ec3fa335c1fe5dab81298fb07dd4bdfb203bf12ef3bd28dd376b09ddaf9a4e63cd21dc469de4621d92ce76ae980996cdba4c21961fed02d08b67ac847d1dd5c281a0ec58dd72c375b19b6e3c584954ecd45e6df14255ff3098358dcdb69c9b782e19f33c64ed1e843f5913791ee848bfb2e3fb9599ef177286502e5fd1ab698ec62c6acb042df78511d7565092c0ad3d5d40c7ca93159ac3888b48c34ce38ab71559b57f42da2c86fee826383096d187557cdc94278995d3dc6825e8b2f05c8eeff0f6fd272614941e5ee695758f7ff4cd9be85dfabd98e1bb9dd7c0aa04a75ae884cb91badfe532df22b65c6c2fa5fe582131b1a664e29195a3dfa4ee92cac7ebf294c4d540be268727a001792885b9013e0a2be376f6833bb7c94d9975294bce3d1c06e8d42733c1794b044250f1c3293cbf20ec69ce0772f006991ce91454d165fa85d39656972e26417051cb65de4cfbe1df15ae60a46d7f1ef4520f2bd43bcd039b7e4b6f304c306a659bc4d8a52d1a34cc63d305b0b9dd440b5e82083a24dc8a6b051b6f3afcb7550d48800db63da64ec814c4852013cc3dfb1009745e061390a84511eb0e0613feac771e3246ec9ccf11cbee5a68bf4d45397a92ce6f593ea3dde53a4ccf33dc4b1ebac5b46d0a0c077656ca1f8aafed477ddf8fb74ce665ea8193f5c33cf74ff6eeba8bb8a772731883c73106b0f593b51d749f23237349a875f9abb652d3c5467357363a84103a3621ef608ce29cfae79b872d4ab1ef09d0e49ff87161ef6a269f920cccfc964845322bc9e79fbf90165862b23fa010b315bc5c3c5f993503620500a7578c1ac96bb51ecfcc361427582095b3b496bda3133cdc6a497e42f03aab0f7d9021e5e8bfc58505ab63aec813172abfeff69f523210bafe7050f916575b72394e8a78203804c3cffd5b558780401a9f1a782a8df9a5bddbb2e9e5622836efe50d2d7454f1b444bc7215565c7ac823cda9333e542050ff90700dba5965ad048c39206b7f2cfb45ba2b506b1f3ca80dc8dc55c807583c4db99227ad52ac5ee88ed3d0eaa2ab7e12db08ba2d3a57eb95b679c361b01b4a5dbef750d450454fb0e40495b31afd5ec9602f1a6ddac24f20914357588d6f28e06f1b4f5badb86b71d683d842aeeb039c7d43f211f620dded68c649e82881525f0b68f60f2e628125cb358d413aaa1a48e10525400fb1fb4916d0d99ba038c2585ccd77e7abd85542bc7b8a9430731075924b284889ae74e779fe79b9625f94592574bb898827afc829fac3297e1c41739bc9e1fa2fcafb32cbc20fd55fdc88a47ede1a29379399ef7d941117f1ded579a226b13d82258d56313b1c45cca69efe8c25e5a905cd8880c1f2f6f7e87e60d4ca6cc57d2a855c4f12ced8df65b14a6e2647880c2fe7c5e4eaeff5e0141f07dbab3761500b4d435edf7698f5a42c5de830fa5964300f57a6d2a967194ffab30fae56b5a7480d96a69d7f49da778b142388cf59d4cb9e3dcbce233ea0bd0b138b534916dca7d8c2971bb1be4482904c2f9e2576433c112e59b6bdbe8786283f78cbd90722d273b73a8fb993f4e0c83ceac0b62ac497afa505bee827cfbd8b6930d1f84546f4ec5437180d6b0fe5d05552a0be705f67de6d7c794b574e18929ccf3cad47b0f8c940acb35cd411f4ee32767822b1b721242989f785c5d84ad0bbd3d882029308e7ac16c347ba31a6e27a72dc12abf3e188d3c8a13338c1ebf93d45602ccec271ecdb937bb46ec86f6333788df7bcdf91c453cbe26f219f03aa94c76bf385687df265509d6ee9bc5ad1cfbcca09151d3836edd42c186535f742f8d5c8d0e72de26bc1d63519847809358bfaf6f177e137e2fb88b79c39ff6666239dfbc8dc93ea6c51ca76b2ec2757435c4569488cc84bf3ba60e17a98ab105ad2952ea0b3fb5450928d76c6fcac89ca517a9ca5c614a11025a67088e1e3b12856dbecd84a57e2d51c10e515bc71fdcbd99a30d4e4c22271dd15b641d743941c6912bce105d3f39f25cad7f614887022a79fe213a323026196917ae27342384e85099f70e5ad27e2bca44ebed27a98331196c14747a3417603a57ad7df9d4e20761957746605fb9ea12fdc17f6f10fb55c857faf14e6a5801159f91a0857fd2cc9a316399a45ccb581266fcd04368b12643d7253f8fce5a940e5323c22089a13b31353acb499febf9a4e23e7e8c6f808006dda32edd2dd7eabf68b32d2d421f168b248ec6a52deef93717a5ae0bbd5886b1b9a0f2d249c213a1901bdcc3b63f3c9710c265f625b166e7e66f8089f95bfd1ea0cebd5c718c090acf51a9541854cd98b34ceb40239bb2f97de76bf88f7cbf76f7852f5d9083fdb6410692c1277d406e7a07c71d7ef236c22d49f58ae10bae66e59d193f4b0a181504785dc97c812b863c59812f4dcbf4e5f56de9873f1e7da41756aefa53ab7544b1d92519e398c786e08d171a4c666b19681813c44146de513a99d635c079501c7abd862c050fa8ee4533566c21a4a35bf9db5c01a876c71c52a83f380fb6bcc4b8f18e7b46870560644f78b8fa6244d40fe203809c5e1bf8453413fa2bbc19447bf34786b2e893169ad017d03ca2c56e91c1c1fe5d39b5c205962ed87d57a0d123bd2ba298a3eb735e11f825f60bbeca8a4da1ec343ac7e99e1484f95f819e2344e203df100b57233795011c117a6272b0dc08a53926a70f926e3da32ebd508482f4d6c04b895f0a7ee961d3b4612e0395c3d9b82bfac5be8bbdef9edc185b7838f367510191ad41728746217d86e1f9feb07fe8cda7a6271910c7d24b7e2360e219d5da549c2c4d133edbd3b6018197dfaed61dc466f92cc9c9d2a56f6627193f15f7491fd3a6770b4dc456204b8836601b7c8377055ac33c930c6f5ac9f017a908051cc84e795628e8a9ae3e5c0b295be66e4b099ec1832bcd7132a0e82d3561bd2edfd3d64cf94a36e1eae2e7408481f2d1cc59826b09e9011069936fe7c31e1dbc05cd2951345578dc44ab09ae9136e3325184fe9703c06d9b9da48f977a2ef6c8c4fe805d40e036a118831579ca0af547968000f81bbd47d824edfe25c358c9dfaaf1d67f093c21405e3e2ca81a106c8c221fc9ee830a5dd5a0e87200c6153a580f4061c7a9e267d282e5e6c61ab09ea4ded601999ae787967f1820445cfc25f55c29f23b2d4cf36e70fb91748989d3767a54723e0a26b38c9b9a4b6cbb3a0e51302a77185a22dd3866396e7fa0170efd4f7225182b475e902b8fdd02e2ee6c9909406d9dcd978c0eca2db83c5e08a046eacb6b69157369ecee3e7532ea67c26cf38d113d349c7c3871e67dffec43d38970fd3f312533b937bb9470b89d1059088b4dd3f55c87659e0102a01b91b80c010c312b5720341a007a1a8c2dda5906692349e2e7fba0a6fe31445ff4fe81d28d24c302625b89c1b94269f4de00b7b041ec4fd30be46c289b74c761343c91d52f1b229f7d85408396c77728b6991517951bcc2ec628e884455ea6db9cb2764652e04f4973c3dd2170d79e91855ea209efa41e1ebca278868045301d4c02f8ddc0f60f60eed6ad26a137306b14e1dec8aca94332fa092288c03dfa48f1b5e274a7b6b7d1fdcb1965fc2a209ad5beeacd4ed917485380502d6c5fc0043b4dbc5684de6b29791e1149892be6de44e5ef96fa7590cc953a86adc643a319d2e5cfa0a3f39db131a9e1fa2938bc443d1bc587a463b746a931095f52bb20e028ffc10175d40b5861b17ffda79251f31347884c3326d5227484f80f3dc60b0ef1400dc69cae5cc6ca59abd68269da4e8e1f8c425f2deb67dc13ccdeb73480388c4b7fc95bb9d34c468cd8646689a2ae5f4ec253d2fed79a82ddf42da0b2a59ffa8a362124dd31961d1af069c851b3ec4b51aaf9d7a9267b942e9ac4704720d3a7957cdd8eeee141f2166cc20404c22d94832b2661edb23de029d5844a3068ab32a45a8adb17965e77977ae4cbffbc118307f14fd8a5314160a56c17ca830e086a3f7d25bf365a130ed1d67caf48526a7fa08db0b9826a554f8c18e2f4e3497ec600b9b1e0f190a881b2de8dbcae705140b442c4c65a8a4fc859075efbd672a755693f11191eef8f7fce73e009478b7eda97483e66d925e2e4b0926d9752e072a6f80452a6c9136ed6aeb6fdcb3cce9d16725d9c7b88c71200abb8d16a91b5a5d409346b88c7dc83a1eb872c1b1cd0bf128b0c5d98087cf7e57f11cc0583e629aacf4113d449396d66f306165ccf568e1e1d4a8e5969d32b5e47102ec9db8966792501167867ee9f89f088e8d7c666d2d55a3e8679a594da9b5b013e96a1b6d3e6bd9e737b3f0a3f9d1ac8581663d5b76e924468c9af0c536cb7fc85525a8679637e681d9353e64dd3994ba9be274c5e8e53ce2caada5fe8cabd6f15acc0436b3ff7a287a08d7940f98a381562bbe8d41bd35c75343ec77c6765807d1ee2b81d1b51593f45ab59e97ade9aef8cf9a93872c42f5830baa92633d87f7f3171404617c996d45566ad776caa0bc8b9d20d21c9ec035d5353fb314175e82fbc8cce577c0b4b918ddd237ffb2c163d5d3206a1acd8c5497c4dd586d3fa4d48739d4b8e83dd3885fc3bfb04c40f13f3da33bae5f14f7b3bf5e46d7978ce51aafc8177ccc115cfcfdde65485941347c5532b59d9b91b97e25e506332f5bcc1f5725b302290bdeab5660c91d1a871f8c61b9bc0bbb0b5e6197b4e83619f321373e8b5e919be5e7ec1658447fefec28ea7dc80d8884df7244aa02becfd75f83d5c33e45fad75fdf7197f4638a491efa4cf63cdb62f7b5f7a9d68acce6ae18e926d20125da4a04349ef8cb68a33ffbc4113ff52866139330dee53ad0a65c7a52a12e662f8ae37e50e696f069dfced78cb1fa1c3c0b967c42eed8943112ce77f10b44311216fad5fa633d4b8c4b7fa1e3accf5e6d17fd7eb73620380a2710c0b19f7431056afba9463d05e2a82b7db5243d663be2487041f684cb914f6253b8ec6c45b2d4bf17c44e90a2cff941e455bb3cefb59b8c542110bff356251bb33b68488df3ef51a743ba738d030b8b24e5c2802dab97f92589ac2a5592e0cb050da1c49ec25fa5896419551a8f27cfe5624c9339202c2b8ccbeb42de26d576a3996ae156a09aa59773a9dd7c396158da3036d85fe90c807bcee0f975cbdbcbc8919ab70e7376b4b707deacb946f18df4ce0f29701939c5f47bd3c5510f6319bf49e0d2a439c1ab04a87c6da0b20cdce17dbc047854d69ba4b96667275a56bfc40f97929b94b65f077712e650cd0fdc15e427688a9743b578454cb8ca17ae357ec2b3173d9ac253783b7e1910865b66bd83202942950e1ea31862107d74e556fe16826754b21fd48e4daf11165039cd08fb5032f7dd1cbf766d89575209dbce71d57a129e7af8cd228640c96093b129c257ef517d8df729f28d34138d75fb3e4d3dbc6369a201be2cde3d990f38051bebdb76ece869269850b1b9316cfb8090f922f7b136a889d552110712c36322715acbc71e957526d3f85c4f7400257a0b4b921c7a169f3d6906e0e41cee00a03a865dbc403096b43d3188887c2b5bb614884abee719f989a127845e3e7f2212ffb61681e5c03df7a5f45dc24042bdfd350323604fca4cfcfbdc16d14f04ec137ebe3e0d5776d8e8a507cf98a253833560a9d22dc281acb0be5187bd9d6800b09fd6bfc03e9d41b8927e96fb6e4cea3de4ad5fc64032f4031d062cd256e355108ce371f041c814978d288692ba0d2124448f6a54a8225d067e17bcf3af9e34c857975fa04aacab67ea8abfca11e1ad5a1ad9af0f04ef499e327cd2fbefe3edd093d094177ae5906b8482fb31afcab8b78918bd63effced4727ef9077366e9065d67b6405920a52dbdcb4ccfb0ebb6cd2d873f78c2d0f16a42f41223135fceaff2262226aeb06b6e88638b0366e2683a48fc631d4c74085ffc4a37c28559cc3c60baaae7c7e59bb0bb04e6878ab26b7c2e22304cb25ad5c80b5e29f9c5408343c2ffd87e775dfb023756672b8afd0e84394c3a42df9eec50e37f723c8500aa9a9136fac5f729a931ab17c0a8c88e514c538d61ed37ed96eff19eaf8cd68da031361c74156c84ee273471a74b79d082e8d19709c23ff1f216d79da2cd63b2fadfb6e7d6a645f5bc78127cb3cd8387356b1549887b06eed0d6c368410a1eeedfa48801b4fa65518c07e66ce53bf1e80aab228f0d835369988e2194f44752be8b55939d4a45746c7963c2bccd43e229bde1234d516eccf1743ff95c860121d9907ce28def7d618a1cf9155b6f68dce3d894bd9145b47f004ac2fc953accdcb95cca826795f573b4a97513a4f8e3909a7f9e842cd3e7e0f674c117987806d1847a5c7ef07b6987b958e40d944aeda63f130eb006b42aed941cc5ca9db1f4548d131f59d304eb45d110a6975aeb694cd1bd24560713a8b50f5d645c87e02472e17fa7a8e642ba65e6dd40789db75fd16e9b694c3ccb884ac74d4cd8d1ae1c8ed14e2278fa5d0bfc9f110e721274f632d468eb537d20acd7d052823a06ca309ba541ebeec6e389d1d1c19f1d38578647a1c99997bef921cae5960bfd6c2d3f922ecce94afc6917dc4565b248f1e9b4bcaac2334d93e3525a48bfe01de54cdc76a0484717d6d3e475c7e1590fa9cdd86852e487a9022714c1172463f5ced7690b19c410bf4ab7f9e33afb0ffafa11f4d8439c624963969c09843c7028e180a5fa80dd8cfdeefcdd712e98e1500aec394aa5c01b04deed438a4483dcd4f938e9e674f0c3de88220dad837bd1d585de189433ecb297efa1604902d59837427fb91719effb115268798292966394d4d6dceeadb0189ccaaa821b5e3830c785eb47d3fcbc947e6ce113c9a4811e25c92aebff71b99090be0595d3453d6cde1db75d3d720ffd49971e53a22de332abd84cb76221983361fedd574abf05d80f5dcf29e213db8145fe9af77f15dd3f2a56d23e210bfe24e3244318bd4741251d4078f5937416fe41c22cb99f090adac56a5267017f2d00fb54ec780f97b3d77428f381b020479b060cae8fd264f072dec87891687f75c8fedb6f21b26f045ca40ce0c416eddc3182470afb811db0e455bc27c4f2411d6058f1d5eb92819b2f03f4540339db3985ce94ee38864fd053f820814c63e840418e43b9fc493a26d88bc92c7149932dc73fc1abf74300b37af4afc2e01a199ec94edf19e13b849628b0003d404c5c15beb2a298492066d3b73d1a87c7374f36f8d127f0b4e9aa3c0e43c07fdbd4ac690b3fd16d380b19e733a9c0b2494537ebee86f8ba6108579759b10b0095eb511d624de75136b7898ab6b54687af1b3442d33c1d4c71f8a9b0637424a665765456d46387f7f477ec6e0c99986922518a66017b162d869e3217cbeaa485995d07c535ac8d4a26c46fe82331914e9613399495d9851e5f9cd9c359b0d2c75fadcf5d4f6d3892edd2db6805a3e411b828bad8d0ca2b4f1028a39474ffb4d95c3cf48d0c8717ea290541fd02119e37baf4ee1141380476a796309a721b5f5145ff8dbe47e645d7a4de0f8a539bad9bdb02c7df716c3ccff7be298d010a93b598d4aa3929d58ac931e7862fea15db62941f921413cc957be45c442ffe81034ac85fc5c3fd8921bd44fe153a3012785486426b8c9343d41f747463d7a206eff3fb593a1cda54ef22d3a669a6489f5c5795895db808ab1fb1e90b78a596830484ab147c5eb83f2a490158cad39518ce1877ee82154fec55e0f32887fa39fdef27edcaef7c30e27e84e416e308c1c7ae98b2221164afd1fa0cd0eab6cf4380b628b8bd708d2035dffc457adf29cb3fba377a53cafa424cbac81691c4af1539e6ffec1a805ec0416e86bccb2de4c571fbf4927f40bedfeba3183fc3980726c23446af5a864f0102399aa667b1301c3061223f23b03064162a6fe7fba2f9aeb868b41b72476020b0c506574441af32377ba9682accb471ad6a5a0902a5c3f4aa263b90f870379dad1381a974e5ff5dd72a5dcf3b6fa790d7e0dade59a0d714e3bcf08a632dce1f434ed1549144fd6c0b7f4ff4844b75b8704bca7e77faa130f74830ed36a06255ebb0fec20816365f9e2b094d99389e912443f37b6fb42aa37437567a0af2decbc06fc2cb01720b1c56cfd4ffe2d3774775dff9d8ad5a326d49309b024146ca08f2ae9c35211298c75028661598dbfd7ce715e7d68f723c9dcde129cdc1faf29507734419cd380ad1085deabd64735d4218a8997cddeece3e8b3fb3d1a08b9d9cf981ed8484eb3877b2abb70b0ed620f1447f778bd360af033e214b3acafbd51cdbbf54515433cd1fa70fdbffd57d0785c27bfeaa0ea8074b38ab84c0b9e52346575117ba7b2c0185546419ae9eaf467f4529aa712630aa74c0b2042b52a02f57353dbc0dc66114b2af13d34f44322fbf2e2526aa7017f60b8415438cb5b1caa24707f2fe57cf6d0388ce4ebab4e50d5abdeae7c6e341e6b22c3c92d293e92c8797061fad88a0428a0d5a9713beec50a88f149fb6d18922e771b3d019962036b76c030ec5b107276724c66ea00a51278d3a82dced3d28fb999d8228ea84ac14a6a79ba0a36c4151f0cf4992837da120b9987f76b6f1371e73e3d0491bb86736cea6fb2428f1ad09c5a071116ebad57aa0cccd488be14392ff084bd2ba4e1cffb7249f74dbe783d60d3c9b4da0fa7edac82096e2838d33b2c44f3790e4a0a3420fd87e5a60839722feaf1b7eb88f20ef76c63d33322ac8840e90bee671d819c540f5cf2f1efe6c7f2edf9384a0ab58a5bcae9d2207d985f08e595f910a9f6d4b2f4c64c2332393d05a1085ce0931d256a1e4b88b8be59713d99fb5a171265de1e98e63aa7f3269f50936394d3d96bcc8ba732209dac7f50364dc66fb3bd6867ef5ffc1bd462ac71a47878ce8a6a5855f68ebc10e7d7112aefd95091f477a69318a1c0e59ae768daf17c022b9bdb1440e37f0df25bdca94d78ce666d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
