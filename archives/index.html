<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd5f5fe80f027b9356bdc29dc71185ded2a02c3065e79415c23c3c1ce4c3861d0779c915db5350f3341e44672f638d7fff1feac2b5285a52ffd7c005260142c20e0120938bae7db98a643422059818b02d86c9947af42741d747e4f737cf4e49e98821c2ef02f86c8bcd3fde93e4f82bbf4cc48c40187d3d3b732debb67145c89969c5f6664cf23667445e32dd32d729de07b6d9ab6263cd4481b14a42e338769d77614956ee1a705c9f863c7960122da2622363d0b00fae64b0608a112646a94a775308806bc2b23dee1f371a0a85ec63924ee68d1c301df490196d19b40e6b30e08ad335c00ec136660610877aa8550729ac587f25498306fb4d7caabe0a04af7535b05ee5079dd956134bd0ca85c027b36b30829af719f4a7dbe1c093e78b2b3e0e347acf5f4ea6e2904673f662495cfa094b64dfe05c632a701eba9634202a221c4421e09c8b1c4b6e0b268121c2edd6a458fd8e58c8cef4bd4a3d08e87b0d15259cb47dd9be5fa2cc5384485556f98ba3619efb01d549617c3157d5cca3ef56bcbb6aa1d94f457002f97154ae81f8764a38201730967f2d089a75d047de695cae17d6475e2d878d17911d9e7a2ca0a01d1cbb600f7b0841926ed3898ac57e266425eaf95faac44673a64afad89fb1ee11baa84a939fc528b4324615f519adc9123e59aa1ee5b32c28138a3c8a83666fe8e4d2c24487d279f0aa8b925e9cac9610c3e5ce934b159871f1d179678cd0b9b951224659ef7cb0781a39eb6614fb0f22430fdfa1a3318d598bbfbb06b376facdac7af676927f41ac753e14b2f64efed921bff842c91db7645413fc176ad2c7d656e4db9c7a3dd3d6e011464c2cc699d6867738c449e13de50966c9636faa8f5780e0310ad1f4eb8ec0dda694fe36143befa11c0f670bc27d9bb0bd474301ed40a8be6e967b1d9a12fd55a64135f55eb7ba243677074538645cb94531da88f0735d0bc517406477c46059f3079ea746ac36964825c7a4860bf71fe1f954fddda93790a89115c381c14d0f92b70d2351f5230711b477903d9c5d6580024ca56aea738e2bc5357e731453c33db9ef344f7776436450c735f809819a96df4c8699496e95448ecaa5a4ff4f63f044f661fab2a154a02211d5818722c195663975bc93cd9bd77484c9b9db5a8eee4134ea18a91012c5f341b2bb8e8dc2bfe9e081b37e8b56b76612e0e4023f6b43f3d1cb7857f23938e5637d04f8047b2e0639235b8104c969d0293200c8f3fb1463839f2db2524e0d9006c7fa9e24d8c27d14e3ecab38a2d39aa8550342b481f6389f34caf5c3b15f7631dbc6df09a9533d911a76eb1cede8335337546fd71aafbb70fa8b5ca886747d15a80a5c14a5ac131c10d11b9e1e7ec7c1220737c26ec3885b1e9b631d05462d85a554a16c7df96ff2d53a0e62269b62dfc340f5710d087ae7028197745233bed0208f539b4445794c13192ec2243aafa61ee0fb47e23083454f0db9eb5c459cf382ccefdfd44e15c29e97ccb7f5bea0ec2ebd7e92ba12435fb5e2a01a3eacdb4bc3c27b1d06457589d3dff527fad683a31b46ab659336a703cfbd151120975c3bef57817d63ac3ac662282775c03bf461f291ddaad2e3587688cbcba9508b2f04cc33c7c487f9ab68baedd3bf92fe905fbb2544bd85fb16f89876ff4c6604c58839fb16ed83cb6076765030e2acd626adafbf126e103989a4781894835806a9364a92790c0b8472bd8620ed5de4fea4fb0864411b671b508681b31d1290019a80a306981ed0794d4978c5fccb034d2ee9bc0f347847fa1e2886a8ea3688ab2b480a6e2da3cfd7568343a7419256c6e40862d449023c68356856d8f87bc0ebfdc79075c98f874c933c139b7c58ee1755af11886a12c53f44faf5163e4a0c39f7f713b48340bd2f2dcd796622114f6c758b678ef0dba989c903abe969f4c9999a2d9bc72e00a73ce021e1d745619ea5ab88bedd9c77c87b82f237c212aa0572dd586181b3ca854c6b900afa248da9609f280b900646f1d2f68e00c159e0816cce49e8beee5f69830b71b98285213b48b355fb3210ba5ce2c44ed10907576377760de960c7f66c86cb06f35642e9a9ea3803a97ab6fc735670c52f4d96cfc351399b40712d2b3f6718c2988cb5e7e1d3d57445b283ee119639aeefa5475d1656bf165067179edb98330bf1eedd49633c1049cede58374565874e89b6a75cfe0bb6042e6096905cfca25bbd04444f9867aec0ca66ea6d8ce5e17e4270518ab1348d7765a3027108b4ae604b9c8b85ffc04139c22be6b7ebb24849af716d5728cd146c7bab53e18feb42c0c6d45052d097c3f20b15d0f588e2926d663687547e3a75460a02f3d3c7157698c0ce78ab9ee06f246bad3941d3d562e8003bdc2fc0f52dbe5bbede2d33d3df092a56f7415999360d55191548739b16e380f43870d4d18973fecc58686fa76c6f167e439f08fe6868ee998827b84333ecb6e984a0623dc5d2b2d3ed115484fdd90fb6ca668d3d81887e80ac770379b91fc8ad81cb899ddb84bf9b8f087e9d26a8ee250bd83eec88a9d229a86b377ac789432dbc8f364d0e20bbce7b0c4ba36cb4d4cc9b26e416cb43bf359b16a04e6e0d011e4d6d5e4b2c5fec46daa14752afa94bb5dc1fa909db721be7080e31e2cf004baa93235c09665e9366a65ced713c9a627c46bd9063e635e1b7ea851354ee370f4c64d2deb6223c2bf3bcf04b9cf23b9c0cdb6ab5799f060f80a49968fc594cd49c869dbb3dca4e7e7a25f5708561db54e47062f1d1e92ff4a032d49a5b3710bbba94c86948533f464f4e786fced46ceb9289c0d2bdc2d7fc2ff9fcc85a419310dfb9d339a9f66d0a131daa87d7ade0516d054c110cd7a2f75968324660bf7b68e2d838a5850f60f94a2c109fd5e39c022b2662364170789271943f937f89908b6d61859c4b885f99784f4c262ef5b02c9fd5a952b5ce2422dc5c119ec73161896eee4309a72abd21e8ef8ee3800060c2ceda3201b59b8fa3104f9e4085890bcc838f8ab7cb079f27566a1e1c039289c3e5b98f2f3dff714e3ede718e42ac61c1102b926ebf976d80153346f178cf84883478e837823624f1c3f5976e142ec75db5d9c55534f7ab14b56b87714c4ae86c4ad41b05a826236c2c60b08ea6ba683b1cb9162820cacc8c6c957c7fdf9ee862e426cdc378240dc8ac01fde48de9b1d72eac2c1bd84a370570a8a6fe14ee39bb7a29fdd6782d97302c7e821d825354ffbc2665fd69da5435a1f601618f9bb7311f7cfafa49b8d3a4f1552e24e3fc96f55294c86d676dee3a1bf7cb8a1e848e1c3971369dad18818145653b17a3fa0f71b5b8d792e37d2e324fc0b635db48eb8aa38b822431d6c7e75c5d5bf52064fb22485a7f4a657f3a292f96c17a4f92326ad43b2887d10fdb9bba26104f33167b5fb67a1040ee8817167ef836abfc59861acd35b2b8c5a6575ba99c26e91f915232157e25548b3463cb54a9827dd42509ab83cde508e52dedb9e058788d60a9a82dd34b4a59fffefbdbb0abcbc35f4c46186b7a0d1acc961e309647928f518e7268380f5517ddd0c28219768f5c1fb1b6a5f1774384d6adabba3f5a5b6efb844fd771da132605b4054d7830a655e1afa64888e539939aeb578f110cb8af46299bb3ca685bd466d8ac98361e7ae6e27ef3760e0981a4c6f30b00e3db6ec87d31b2868e80010aaec359d71995b31ce885e7f94ed6df3ce76a49aec4e4f6074beef32b75e2965612407535c011a5b13137638546fac61dd06262558b653202c36092466d818db202b72d08fb5bcff58b7e947842413e01b1fe52112105f976b769201332d5d39b6b9786d5ab6fbdf23d31d69fe0a1d4795b577a73ba4762682a413355f2443cd55b151c09413f769ddbff617c1e7e7439b6aebffdaf710bf31950a2f995f5d3147dfc30bc7fb36ec826151223c93c89052a58dfb66ea1b9e4a1c1e8768e0a417b392d5a34f54faebba0c03b1efd339dd211f6c9388620a1aeb88628398ee667371998f5bb9e2b0d466cf12bc569cd189d056fc545e079770d94baeb5b8f7b4440a0268df8163e923b0389cf0441b117feca6969718b49ca1072a4c4c3cf41fd990270215f4045bc48a55e749905ce91dfcaae42b2db2b7481f9eff601bb5e049c21388b173416708d0a9cfb1c77e2fe48ce6e991fdb56f5db1fdab5ea31ddc86e874743ee3db0a1e4c0434e90d79f429ed3ced26c1adbb0b2a68f7107ea485bdbb45820881b1687873a3b2153dd679aee2f14c5b972eb1cd6c4728ac44d562db4d48afabde663716ef69c8189b5c49e60e77da13ce2ab5c31ebb991b66d1576cf648f510429ce66ff6e7846642fe29dd37deb63414c3ab63772581018e1d436d2c149ad71668e8fa67e2e7f8e92694d12a3053298460d7c6016782d6a9bf98f48a027cd54b8aa94de0e1cfc6c66de693d9c7f5dac764b68c19c5b6fd7f6b07cb0e2d1d2409d9fa0a2c0ac4b8b6cc63627686c26d773394a2c8eca45491e00b45bb43f5f59c9151972d444c6135b0d0c74a7676b7cc1f45056a621157df4f7d338be439267292bbfa0f31f1a7b5056f27f0e7931abd98984e768cd567a4613c00ba2f8adf5678caf9ac84cc87615b03cd9f8e96953b63a8d388e8bb732c12c5f03284e0551a027edee5c2eedd0c58a957f1e0195c445cab22b7f77951a5d7f254fe6cd0aa7221dfadee4219adc2096c4b5a9b42b59dabb6560d0f0decbad209709d4c5b607571a1802f916659d51d57dfa6d9b26704e8721d80ad0dc86bbee00f7c0981e5590cc5183c3b641d290bb616aa1ef824dc7f316bd4e320cdf07bf8b2df19d33dd1c8c12247c854d90da38a39d5bd972393027d2efc78622785d34eef6cd047a993852ce09ce1491cd8092f08e9a6e0c3a98b591c3f28235f799f7e8f70e48642ddf739e2a740b6e9bbbdda35448b3420915c45d8bba9f40f6a816be28cb20771253c1f1a27fa88c25f4b8492321d9741feaf9e2bfff0cbbe92568eb5a7b3a216a93f588a2cfdc3c4bebff411ff93ba8e00a9c14855a094b8732a48e748b4d37bb4d7754830f038dc8004f7a541baf9c17f30f82ef447887240b7da412e5924d3cfc574fa5acace5451c03a95c5a2e5f23a149e3bb6a2c84957d8d6becb2b19a16cdcebc7cf48d10f250590b816a5475803878c90cd963ef52d836ae4ec9ddc1ecd538914240c24834e492ce4d3498cf6f0f19703f5059df4f2da96e0b8f094030edb1b192d007100d4112a4cc6a360e9232867d27f3be17a445fc9a73677ba9ef6a73a4b2a09b0217eae973889b2180426ab5c5959987be5c325876106bfd931b4590e6f4ce1f1b1a392daac2d779f13f22d238af86ff24db3d0731ff1bcad71c44ffd021a27f0a05b5742b8b684cd35b865c832f0625fe60fd95df3cd56c7bf52a7cdb70883eb2e595ac8c2213ed2bde88f4342c669acf8284cfc84e238e540402bb680f3cd112924a8a5dce38918db00333a5566752d5158d2df901f73bdb54b100c37153c9652d8e38936d0b23810e693c8b68e8ecfd1dfb558f796261f794e75725fb0abe2e744a3df739716658f82fe5651bf631cdf7c1e362a3a4e933beef3ed8dada1aba994e8eaecbbd9fd738a75923961f7bfeaa48a42df86bc9c9e7d631e5a4c3eb243e13bacb31954ec12292f0a5a4fbf6437246e9a014e22fee4516e8c50677b7323b1bcbd7ec945f74dab6beba8852e8e71b02d02e3c9b96e308fc26fbcd019cd20e38feabcbcd1613a6997571b88828c9c985194779bda5ef8058926d2b557d799c0adbecb031045596b9c0792e4c3cdb1eecc45358663426f1bacd3447d1e96c12b3702132d181720a2fcaa2091f72c1e6ccdcc6464cc601eba69045fb3c09939ac3f91dd34b6f17ed1a42eaf3056f894a07d29154101a119c993c7ebbdc90d363bf9e613b3b2813bcad4853e308a983c60bf1ddb9bd9a804ff1d934416216952e51b9f6e12d1d433785af579d7a3c5a008bfbd589f3b13f63c8001ef420866dc52ad663c9dbf83e60aa29a076db38fab21729a95af4fd61233bf9baa70b378c0436c37a6bc9f708cdaf80e262a3bf78a1ee953b94e26fa471083c305b91c02a4230f2bf3c7a0c102eeecff334ff386fd30a55d66cdd20e293395219fc856cf033e02492feff99e446a05566ff36c6bb8fb462ef14fe4b77d31975b4dc8cfd176cf13ee4767fc713f3e9e7b6c0d2c86fb0055f940ca52fb74fdb8bc50490b2e80146b78e2ec7e760199f7c3850fc59033b0691f66c0e457fe076db5be7f6713a4f3293b1b434f1074ba1258e968c291bc9906f4aca323c830af28d1e4a3ae37f4173be37770425fc8389eeb7a39ec3bd645026710fddc4f62685203497754429cf9d95491630a3d19f9c0c530cf9093ccf2faa4d589b485f6ed37f7f7348b304ea9f09a3b72ec9ecdcc7cecedd789c28d0e1f3a606a18885759e988f2f66d9744577db08c62a83ba16cab5eeeca4152f067708e5e2880e7545400c0f1bde0f34771dd905498413ca3d5b0fb10310d416996a3863adb65dd7e171249ce998730216daae3643b126c6524de99ad57e3792c87e5f1e5d2bb0ef39a3008322f78e7fd2ca31a16fe230b70e1a7e1134562e0ce961c3a89a599678824b8273e5aa1db7b1b6c87adfa2b3d9ba5cda636b3bc0cf543c6ee98448a06a23743671b1d607138f9e76b45c6f1717c49894794d7864d42b2576fde952654b79a2d9e264ffebca10283c22277ec20192a05243a8fae9e7ff6555dc622aa03bbba938f957fe0a899465825f51dc311abfdf94a68ad48a5b93d133b0b1c9b2ebc1366bfacf5511210355599f59cc2a557f711d7837d122bd0c87590d677edb114ea5b8829b615a654479f3c50fd76255370ce6e5a1af069f580eb7479ce211591ae36c02405136e5e9170fc3258e93417ab361c497abf1b3602ffac0f230de8509eb40c13beea6e4e17334caeb2a65fbcc5b722bf9a87dd8869f431872716a868426bacd4d85c738a565764b77efb37ed661170e184f33fd5b4d7d75243f5f015bc0dc479cc09ce6ca90bc0a9163aae21c7c46c80d849a5d435190d05ab608d800fdb139df06af72a266d03ecb291787038052dc3d9d91230cfb08bfa26280df371567a640c7ed30345a1ccaaaa321bc139e50cd1f65eecd07be8d6db846c7c3654ce07f05a0baf6a9731247e3a92c34ff7ae53f4ac86a18cb67ebb713ebf63eb19fadd01447535004d5be871d93ea996dfe24be6184914e65c65c3c104746dd8010a434b1852a63aac0668d8a7c6e10fbb8ff21f986d278493baca8d6b1de1f7d6de7010ddc9f7b1fc02f8422acfe47ea2c51d6814eb239f96b8d51348eab4218002f9d7fcdcb7cfe57b7b57d97ce58932eac3e4eec3779e2382dc22b078eb9de6fcc65adba6bac8ec825ec41c79dfa5aedebd0a5de2c7af61a4dcbdf465f096e9e41663bdaffd15274d5e918acad085b83a0fe17f6ca7c7363bb1e6b70374c8d8573582af9089aebc5be301b0a82a12ad840fa53760a1c6583ff1950e632eaf1f7a5ea4dc2c88ab2eb7d7ae4c6ecd65943d38a84db81cd491b74bf75c1a53136bf6bd7e97bcca59345199151a22453c4c7c089d4484e23eed1a820963397397e0b0d6204b36598d40f6e72c491e07adf102bbfa1375f790c54891714bf6734a68d707ba9970397c77644cb6a879816c24dec6e491ede82386694f83ffeb13fae740245153fa0b3519bebdd356df4920efc8d699666afde96ade77b62663f746d2ce753c9656a49a74864f8424c26e796a8c218c4094e6830c6f16fdb21d1b96de438011cb9be0f241d0457f2251cbf03e464277d85f82eaeeb16ff55aaabb487673ab2b06f9abc71b2b036a744fa8125056c51b894b31fda46f03bd34d7cd616fc2d5f7305d9af7bf7860c869246960a88f3cf8a4949a60ffa3050aa930c5e2d31b879b24d4d01460e096622f075d329d1305629635bae311bbc8980a0b8ba3c2ac24c14654dfe8f1a016c2bb944a855587dc98d8f1623814ccbb900767d50e8dc171432b3c8c7db53b0939ca1dd943b4ec951f9b7b33d595fd3f7c9b00fd2676fc4fd40bf05ccffa174648bea47a6ceea3c1bcee87af99c38b728cec6723b12de10f939cd3832474d63abdcdb17ca94c0a41da74209b3f2970b19e854a449b546af5a4606baf0cb1e480af7e01c635e238b43d3168df01fe6f83cbb223b486222555b6403da73ef5dce86c0b0bbe97f5b2c0f5c9723a8b677c1f530e1a7df9e4eac5d168e1031e937189bf0e367661680f2f5ce071459a947c60d8aea02f35223876e726b73510a521eec3a2352755fe4e0d51d0cdc62537f047c05cd4c59d815bd74f1c6ec64959b221333016eec91d5f28408867e27076848442f28616f0fda25841876d307c6961f48bf0cf0592a8b967997d6ab551fb58cf630e5b48ced35526aba9e40facdc372205b0f05c5948e4c94a91999213e9365eb668be45182de18c7ad8fe44d7d54fb2590fe8ae413835636c794357f61e5bac13f6fd5b84481b02cb146c9f66366602641e7514a5179748022543342ce24099dc7475474b79479896dfe83619e91796318652b423e410d57f0eb4e356c92d41ae5017f636b86ed6a315de37a18cfc39fc1b033f09168fcbd7cc68f1ffd0ab46623c68a5ba12d3e430a105cae1d3f303295db89f274617f34dcea39a6e39b32f961bef81947b10c1a77e7e165dfb68b92dbc1c89e5608e0895ab830b775ba9a6afea42cf892cf33e87ecca60c49905ebd3041a6f76ae6b6045064d24fabe4a54952bb25f6c02c11f75c88d2f6aefb9eb9744bce69dda0fb2353d0d522e62d1b1d74561dacc6a62fd288708c70dd4e63f5d3d881a9e909c9ff7eb86ad81977ddcacc6dfd04b16f8a8f69a3c685b356a2add18b8a1defd1bda7151bf8e93932dda249d18cf2ef3170d017476add082f8bb502d503414cd9c1d805d20f97c36851bee1f081c95678c9dc68debd34cdebe26a0c4c40d58581030b37730e27014803554d11a5960c552fba287901a8e5252cc5877f5e031f1400f8a7bc2b859b50722cbbecf09e2325b4b8ee5fa96fab202a75016ecd9496b45be8761d24526bc9f1d65d799c4685d314625a250e88842685756177a3bfc5c6c0d95cd66fc58db76fc561b854c5cedff3c2483129f5f073186e1edcb3f121f5bb4d5ecd6de3dfabce2098f3d9af991885b09a963f089e88090d6e50dab130a1f8030772ef2a523f089dca29902ff1df12fc5f18deb9f59f7ec89747daae4a56519096e63e7e57bf50b8d8ba91adf8b797f751da682c1ccc53bfd98e375165530d038279303fa86b877acad408ff297729ead03772a6b0a27e7d222852b5ca0059baff5eac097f986a50da3f023a242dda6c56e81bda9711eff330f282bfd9632fa4186ea64c709e5c56b59f4cd7cd14c53ab793167c2f4e977858448d5e291b4d6d601f485a3050d7fbbd84d9953e3f184a387ed0ca4f71ff99310a60bc34dc180f7a677d20a23fbd15eb14a0166da2b5060efdb9ae9bfbfcddfbf1d3d2919ceb67d04e2022f63bb10cc64f0909b8a53b57457267082a4037fb77281511f7883dbecd4a60ead0af1d27823f9a5aac35f13ddce83279bf5a11261f2088ced36baef192f77745fa41d47697c47fd9aea845d6fe623919943fd8d872819a2610c5192dc2c87023ffc36836cdf48a039f273481ac6a65980e21cc97d7ae37f58129307106c531ed8452f82ecad7647ba17a67bb06c91f550c10f91175dcee9d74295f9050b01a72a8c1e77778bc0d68480467923d56e7fe177a2230adbc6029fe567b5e55baec41332cb0ad55f98da1d67c0f641f517ba6db44198bcb8638cdc3397a1da8b11e5d7123ed416ba684284f2a747ea4314d4bcf5a4b831d6c9ac8824451d91933a25b9050c4c3355f5945d9584178f1d353dd4c0d9d8be8c67134e9e0e0e593274afae5b003013338dc43d464d3ca6d8e641f14e4468d72be155e5eb3b88654dc56fa6cef7ef916bdc57a7079e098ac6568e95703366fbebc34d0927ca217809f6832833957a5715e4b5a6775fa50adfdcf8f4838268db1dc1ade2048d4f4a0205b31040bc916c7f93121b510c1bccaa6a88cf0c6f8b6f5ac28ece73353703b1cbf66ece4d0d1e4892f893159246347f26a317a90cf1a17fb95c7b5a92b653f6b467e6231717b5d121adc260f5daeb445bab397bd92bdd16d40af4cb72ddcfb8aa326d7555d782813047dc24c5eafc943ae1cf58d869dfaea536e26f8a90ed2ef405cf1fa91c7efa9186181c91664d177f0bc7d3a7ea121b4f30b72cfdd792ce9ddbb6ddb10065ae80f27b6bd202158e77ba402a60ec778c43950186ff12505bf71fc1dd16d912139b8c50acf451a6cc7bf3d98df6ad9260bfc4a72649371f42f7f00f3cac42b68de24653796fac5ef0b65f0f252e84a21a1a5cec8175e1dfbfc61f12b27f9c77616ec064573723131b3e4b0460db6fe8a46b1705cc628941cf646e241f6cf6ba889aae5f69ff7bd53788d7889845c72716a24c188185373c229db6f8dc6fb8bf3835854a48174394fc146f2866ae864a1a3feedb58b4c982c70da2c259c8f0586801bb67d6e3481e33cd7b4bcde09cfad16ff68b346965e0642b4f54302a42e1a142a496bdbb5545694f2ab130ff280755ae34eecb5c48fd6902f1f431348551e872bcff041f6d0f6be14b8d2804bebc81b19e5f0ad01330d16a3df22962f8f8b988230a97aee3c3e224c87ff0f3c96534b339a2210593592f65470821df1b5ce85ffb2ff17c2ae52d5021c673c25f285b1a501f14e88ee5cd7d392d50284f87c20aec2fad943919aa8ae465347b48878166bb989f18e781f88d04ef80c7e28e0635a81c421e75f1b366f9adf6d6202fd346759994fd273ebc0ce332a390bae8d557d76e4edc71a3983c8cb0cc9d90ba3b712a7220e5d89250afc36ee8b3c37b9e42e744041e3b282553fc1904808fafab4d26bc5590b81fcddb67720d7ae2d60ce48d4f67b96aab9bc82a936296ac150f2062ec22a612918d8028464b2a68d7dda31d8a6dc00d2df56523b620c1d98b3253e8a0c7924d8f090b8147c5afa234c3ab5658a3d84275f0b7bdb29582a8e1d084b1063170664d0369946326cd2ae6d90ef24253a7aac714997a37da668d6f47ba715bd229e594f6254e5c70e92618d0194fba4a7c285029561bd8be6a5aca55b00187d6b06230451501e78bd26518af760253a4bbf6c170ccedae5078f8f638f7ea6f6e9752ea43895d07dc96aa4a544c92eb1ef6c0be72d54be674e13e0669fdae9736801a34c3ddfb6520614cf2426eb66a6b78cea54149fe72c83f0b7d4d440c793c8d4e067b9b844b114886624ded8964e583a951a7a9f823fecefe8eabeda29e886ece46dbd55dbc538a5d3b2418920b5b4b49c16d3958155b207a0c4223ff69963f0cd43af75bc8905b4102bf36c7d8990adc58647492fb5491685c2f3575f6f209e2307e6bd004ca570dc7823330737f1610a9b385ed85945cc84996e33118f06652ff1bf42556aacbfe55c532bfb75a93df3d28cb6164b80eff3df9e29a4550ee7e337bfe881a8b308909cfe786d3ca00f1c4f9d88efd63e6645bfa32d68c0f5c679f756c9913eb5d4ec8c69317128aa2086e9957ddd85ada7afce6422d0a4104cd6512b1619b70444b73b5f30d4d72d46f405466fc14bfecfc6377254d7d2c9a82ddc8790459743c043f700463c55e3f3bc76d6e8d9a5a24eb0b60c7c67878287053c9a6eec7f3d383327f67022caca30bbb518af82686f6d5b1c30726b442a79330b89945757f7e2f2de8ebee104aa0d613cbfbb2e3f9363fd3db1396b404b69f7475419b8a83ae5f17b1795733e7760928db3af95e4abd949512b6426e10ac82fb5d785bd48e9eec43b826ff774f56a47380a95bdfd7214f05ca392de23d0ef6ca08fa377c84f3fdd3791d713592d17ee6fc2ee3f49d3f3cd94a7886177a593bfc8f999d3657e061b4ef900577f2e6a087b6baacb134f926d32bece4ed6252a0f9ab9785bb79a30dee4d22518b63f2952a4b4a050943109f4ddb98b5ac956ef56ad9e5f3f47f4a148e5356b0db3cee3bb2fe468a161a4a7a4a769f1296286456f3a94d9c32ee0c14a06d18e852774a8de5c57a361b3b265d0a3ce42746adc8ce2077c9e60502cd6cb1d0b22d744b809d78858e356731ee702d0e3c58d31647196c32ba087bd67ecc27988b20e9c1cd33bf6d71740759f3635693835172f8b35237fc3644fb48602376a20880c1e1ea4a3116871c50b9f5f77d38e60b7a4c2b33bb200805fdef084fd291faad2fd08e74cf916f8844ac98da23ee7e1d874280d36d614de31d7308f564fd716a12fb479e58efb8e0913c814135bce5dd08f511fda31c407c7d6232695e08ed8c5a235c9392e9b2771a4aa64d8f78f1b1546f038289b9772ebf34b867e14ba3b4619fd6711215dd6bceb46ea80e96a1c97e9ac5ad97f4480f5747578c1536f43684fcb5a932755eaa9b3d5c075328610672bee75ad611b84243b0356841c0ac85dead48c014b88b6eee523d4d83c0db8fb6da39cd0aae2038f835f1c8974073a4c1e541238318d303418103ef0fc169080028273e87504b3099de969e8309f81842d38e8734f560e269ed56d463644ae913973cf1106dbde8807d0454659a41d06cbb23975f22f4de7a31fcad8cbe9359660227d1830ea76bba2a79a3f5a6b6d75512429a1b8ee7de8940a8f67c62ed9ebd79e85d799f17ed4e15edcd3f38692f2166655daf73f23a0101d844509642ccc6b9c41c43b6baa8960bfd7404df42920e0efe1768d4b06a8fb34107bc10443bea2cccaca1dffa0deb75b2b5858da7457e4ba7804633154858f99bd0cf35bdd6ba4edd097fee9aa9d2c0b97a803acd4521f92a10c9ae39d6e9f528637b31c6113942cd87d829e58224c0999eeca224b49d78ccc7d20f9a364fbf43797b0933d59016f4f0d370d4a4d36072ecb5fc81e0c4930caf3a1e6fa450c4ac055b0d8c48e26a05f7fe39c4724cdd9d3c3e74e5dfc6359781cbe9a2b590f8daf8cdd542ea586181b4c5524e6b69419a473fb8aac50c1eaaf160db45593c3863ff008ea0a28573af524b1c87502009e90d02f7f8885490aaf0d58f8f58610922dd2c0d2e0f478efcb2fdbff0c754b71f8c43619712a0cd96f26382176fcc9487adb183e67ceccbb74d2b66ebe6f620a5aa33e752ff02d195a056aa86a53132306860036a475003a4fe167ca9167b75dc91d86cab328f89a15c9f6cf4f1a75396d54f483f58f69988fc78c15d80b76f97941c00f61a84d5c837789ec5583fcbb11af12d9767222fcb1b24889fb9b0bad5280e33339701c6f2893600ac424e2b8e57bd84733b4c02625f41ff282ba3995a2794e805b4f5cf308e2db808808229ab93a07e96977300a4c88e65ef6c31710bd19abb4cffd9638e18c80e923e5062b0828051375d37b99438b6159ebfb48be1d62e2ed98adc27d16a65456f2688f5da6992d5927b4915b61202c3c95de17ea680cabf9b295d23a2157a6b443f0a1f94fd83dd746f2bff783df261e2ebc79dac42ab5cab2d580fa84ef665f1a53cb45eb57da5533d2034b37837f101a59076d27aaa0d936dd9c85576bdaaeb0882394488412c9dd1cdba9b470ebf2ea744053223a62810c8eeff8e9df2b6de769d47d9d18d0d8fc67a1c099d0066db0e79e473d989f71cfa9743c9e3ff34a0b82912b16c8b6a8efbb320150c3a0a0b555eb1a284cb1e90da03acdac55979517ed42f4d2a7f22e9085806389c6ef975da3ad4a8728d1d3bb3d326797276fdb8b83bd8cfe45893fb061a3512c8a074a37eea1da3982f981eae63f3e2c4b35a3b941cf5d103c66161e5ac5a2c77a08e0940f8fc617536f92025ed9812222ea5dcf07bb6c44cb069dc0c81c67b9622fea07e34a3b985bb2e6e069620f37c9e840ed8375c91f5e98c69b1b2117dcfcb39ecac7d20fd0756a890710f9b53ed3225e70f140886b457026d8fcf5a25ef1a3f89e359860987987c6746f5d66636c86641145de2767184b903da7a10e0206093da9f2ea238be14dc1884ec336d62ab3e65e585a4ff924129a3626603ede9f814b82e805957cce198d941296b8e50571c64e6b3c275d7a91893b79e13526aee08e1a2a3f61aac37b8713300d70c8e1949c54d38a0f19976219a0ac96ee908ad457309c6d7d3c8ab6ba7d85dbec218a4633d5c9df2e12569b22231e2fb447896ff1dcef86de05243fc1351b451ce8bad4021c2bd54e9378464e8ad92c6d673502766f62faa9cb577122c173d67af8fe7c90f792cd4ce8b3bc8c9c54679037f0db331da6ed71bdffc2aec3c05d9d9a41559a91e9159ea56fdd3f66c2c31f123067197db0b8fe99eaed3b122a56172a373894645e3c26f4fb7949abd8b868a1bb48263614f31c4bbecf03e65d28ca6ea072549e216b4d78ec7c00b9b9b740e5c69597941125007303aaa0d80030d7e43153e193f5a90a8906816da034ae06101fb663468caae6ca15eba12cca52989d89acc86a2f590ecf690ed043c12c3038ce350fec06f2ee1865c39208a275489da407296ee3664578e2a5653c32ae3a6bdbe9a8d98dba72d0a0f393e388d4815d65aa4c30cd2eda26163509c1a11859382c6ca48dbdf250c911e7b1d5d61c3f835a040516dff85c87ddafc78d18290eb585aed987fad8d0e95ba2783056f556a57a4de5add116dc0a6a6d7be3a4edb4eb0dfa18978093baf56b72aaa4a31a2ec2345fccb86444d406e8e349a87d9d56cc0ead6b41e62f8681d6ad5f8e6505fb67626c0d84f4b65d100ff111e7c956b8c4f5a2b31b6af6f1243db9a959e36cf66f14b3def4a1b0f1742876cb2ea18400cad16fa2989a9c6816583e1f6ac873a0d83c9a6590d5576ca8b6ef7fde2fe928de65247afa0dde428dea5494fa6327bb3d3eea4d081077fbd14d53c7707f128b730324a59a7fb26f972b3a5f458302e000823c470057fd8134d21fd09ab5a60d12b33f731724ef43cb2e3fe3a4502a791b9923bf3350c2a47ddc75321a2c04feec4097d808faa3f89641354f86a99f5100624cc46525c181cdd411f3067eea71ebb048eec758b1cf4816266f71bdcd0036097a00ae099c31e8ffc356f044340fe51d1b3941c0deaf9c8470b894949bfa657282720f28a95ff9378ab75f450da3dfc36f32d1d4f4c8f7ff77a41e7f056acb92a10804ec4b101028ea0c48515c896b2d3021861dcb3d388e91d0e04894fcfca7bd201fa28d7e9e74d286ee1b916db07441c7bdfa435bc1e3f742deeee658c2f48eb97bd09ad24bb96186fbd9eec716e855ad146f3c5d241cf2c51892a8473b5ab6891e8c0a0ae2700aa5bc6e0f1793349c154c697d4483cc6b3d5e17bc8fc904e74e02af05a0e238dc88bd80c4c9030da07b79b85642b3d3b4a12899dbfaf2785ba229768032b36b392ce85719d1092744433ef9b76f4f06ad8f6443fac54ade16ae65e54701c1ff7950fc6d56d126a13534d0b383e4498bd784f39bafa6e58a8313258b1af8c72368eb4d58ca2c11dc1f9aa8198d50f13aa6f5da59af0fc5d9b37c3783315f856d7d408366d2f22f3be9f36a45c1eb6d3c9549c059fd4e7336a08a8ab62bf0e10766e20e3e0a5ae64a285441eb7b134d883f6ab0ca2869eea4d6b796fc75ff88e1552051679040cb13baad8891e7b48c3d6d8c8c23429039dc9892ad83cc8a646f8de6b6769344c294b7f8d4ac589ce349cdc6d5ff22b9989a5f0c6dc29d7d8de8ba3d86bd9d91dd4d74b6178bfaeebeefdb9039e366fefafba94d0c9da254f74240aeac96cbadefd0bec00684bbeb6cdcca0b8e69792a5e83fc45f19ab78510ddc4548bc15dda3996bf136fdd445749a0f15a3bccd3cb5272952b95fa862abddd83d707e9db6cafbd4ec85477c7acd4fef606611944f176824fb15f5ce7f8df3b4cd67374f29d2e806b26cae8ab3b4a73affd76320c4d5c7bed898c1cd624339a5cad19ddddb3aeb0eb889183389620b4567f81138f5faec7d511507a0a3689dfe5bf4e07ca6bb7254be603274cd38ec91a110163b95df9c49dffc7f64492aaa51bbe429d35b93e52e64b6cae69342b3e06314e3d6a65f8d29c837b90c107a12e8c509b2cc9de8b73e9123b352ffb436c7ba66b03a3992d0ff8de2aa99a01e51cf00ea229784dec72eb0e8914ba9ce0130f4993f63b4f2193616f4fcb5ea3d7cb33e3968f8fa7e7337c44405e9dc7b7d46991f4b86d39b6590f3d9161895d91a6b1b6dffa26f31cb1bc117d7b93573aa0238378e15d49afab3066fa1d5e2ea43a53b52d91003801151c46c9cba0aa7fc54b2948123dba0e767a2181167aceec81739fde01fb8af32f93f75a2bca8b0b12748198a6ae7b01d3fadb697308c84ac885048f3aba9e97cc7ddcb28323fe13f3f2a328285b9962d6976a0162a4c7a685c0a71eb1683abb80917a9c4cbe565060a4ce0b317df059354819725a52f57199026210e51695d27855f7a18bfe0bb7466d1c54bbde5b53981cd6beba74729a850f14d083d0382bb8314f7a5dc9102b6ffc02c367d3007cd4a40a688f689e5b35c7875ef8109d9aec804c9f868e41153d84ff20158b6ebf97c4488d69d57e44d872f814fe17f36fcf8b30142085f29b6e7c942d2b0a31bad7cfb2d7c5fa1895adcab3abf48f8bab88c2211bcf97446d36b0e216f55bf927facf059b69f0e2a39ed559313935d75d69066ef41c3b5990ead30469e856127b57e83c0a12d6a87e929d5c4ade05f434031bb3b56be0435284e6801e929c6af3775fb26700f56370d79549a61a8c5f1ebea82ad85ae80d9f287386948363f6a5c643396983a33b19f80c6a6d0537bc5d1f3529cf59622403326706cba5751e8eb5dee93b2aa3340348180b153e87f27fd1f4505290012bcd57f10fd7c66f6de509e87e021d4ba7799b36b93a1607175881997d474dd8d10d0e0e0c656e629b1eb88de8b9f859f6bb099de0b80e88f4187aac385ea0fd591f73dbe6870a0812dee97b9cc03e94fcb3faf372bf0cdbe9c53ed98f2d070e6ece23450f81e714e1a28e00bc3a307c2fb827ba89318da130b89031e88d7d4069d87ed72e37e8a82e3cfb400f65aa829d470dc14499aa304965764d7a6e26a29da784c39ad60380bee91e27ba0715b37fd84fd9e15ea7a804b3767b4d1e91555d065204e68f1fceba735c874201fde4cca8c6641251b7992b901e898969a08d7f0764b3b40fb9602b201139b4ac39e939b591b2d617ec29ebc6cfaa69bc538f4884fae1854f41fc016027736472f6923f19e161ce7f5fe3bfed6eeb32169d42cb96ea35231c35d2d2aeaef964cbcb0b85a5615ec01072842de1d8bbd313890e962f6a12e897d888fbf49040c72369bf1bc0daff88b59f4e30850aeb25403f4375112ce55effd604d108a896ea0eb97ba1f14711e21e93d2f666c930d3041c9af85e3455a4d5a59e22f8061445e053b846ed95f429ebdb24f444ced80f74feb0e9ac7b24ad160f68dcb24703145db84fda014e1a6e16cd83702c147014a0203bae0d36f57259296335aa4964feaf8705b998235b08ce546fb70f69e376f065b7316cfda17d73e0746fabd865bb83858122f931655252d357bbb75c97f19a410c0a8ddc5252838df9d5b01e9f2127624d1ca8c902e85654e0ca80fd096377391a0bc2a0592a15443f602663da7685783c38d2ce52363cf89d32f93346d6060b0834a2a152903ca0b456b5730390b8a5c48fab9df4e749c5dc32558361dadc85da80165750175e0c000e46f5dc39ae24f493ba9f3cc7580554f385b3babd208d7e112dde9a8813132105288c533f4a8c5c268317a226e0db0ebb67582bdc049578dbb4723265c960704465c34d3c466cea2e3b8a109d776356e136621b2d85f1e005882b57f0cfa6f643c728ee25312eba931b53049d324e113a9ca3c7ff3b0db69abaff790ae7da3882e5242c25608c6fd9b55bb8cef6d1ce16d49e8a2fb4303829760ed829f92cc57ef159b2ab3a884b7bd27d881eca1bf542a52ead0a9a402003a2d27a0b7a47c0608d25f0ea84aee604c24501a123149c727d40971b69ec121ed6eb7033cc01a137ed546ae049ac104e0ce5d6cba0471644fb35150ef8952fb12df9a1b3666f5823403b2e4f333c3ce4f46dddb373b0759733381aa644836ec18d6755c162660cb7b3e32d111f779fc8625d918eb9397eebcefb9a0d1b2a88f546b4e7de7a9849715d510682ea8487858eb0224b90347d9c48f844e648f490285361c9cccfa5c8c25ef7af1c3d276e00864510c3151da9009895fffcde9e721149b71c75b8144df1ee2ee6e2f9e9057edb082982ee7161dded1f92867fbe432221267641be8a2960fca4066002763dba7df2b96fbc53919030140a293e0520e90529442ad7a8ce142606b0b7869403a8728541bfd52ddb4b99dc36bf5eeed67baa3917cf52a207a4c76658946d9286fe7542bc6648e42244efdff2f7cfba6c76bb14e07324ca6be1570531eec53e052b91cda6fedf94b26b930ec540b1a3b934a1e880e3bc8dd19c0f5756a015ed230918d87b2ea06a66c86cf2c32f832d1889c9ed6af6c3d8032bee633e4cf45d63b915188e77f4c850a0f323b82dca02a420ed1096d141165ca77944ae4f9758a261942dcd71c6628937a1ba66fb3a28a3dac435b462c9856c181cb88298cb882f9dc0360a8ab065080ff5280155b9863349c6766e6e856af19f75833e56a90b35f12026b1512a46d70ba1015d6bef52ca85ceb06859779e857a52d473ef6c5c877921f36f7b57030bb2d6a32c53b494f7d6bf62db59ec1fe0888a9e1797113677a6f920053b25bc24eacd1b61768cc7433c285d28f4a2f30ef24da1eb20333d75f25efc28df794e39210c1440c6c0740ee8d3640974c89d676625951b72316ba0b643e3014c315cc5a55eea61c52e1839bb6e5d41a0c9d4656839081485a907ac4b9079622d4e0e9a61dafd2ed930b450a7f9a0c334df3df201aec479aa3cc9f9ffb31bf327668f11c37b5451cf9414fb19efef78059ac8dba3faa672cfefc14e9850c58f5bdcaefe9548f08f71aa710529bde97b9848f55e7d7bd3b8e17d0c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
