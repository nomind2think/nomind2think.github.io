<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36bacbdbd41cc121ad8d02f108b475f4b55f33ff0db10f8f26eec8d31b251946d4eeb38bca0b81a9a39ad9c3e3bc9e7e673e3238c2ef5b22ddd1f1bb18dd995a43d33a73af42a6a96e146e89493d8b8cd7d08370c737e1a9991e080468bca4b46d0060e16b8bf1e67b54c91a508dbec85da555a890124798fe3eaa3cc5099e584e2c1e997bc381f4612440c54f373f2ca370c335ff4e5a089a807e5764a34fef126a3be1605acd2b69620e3666687e03ac98618a1f7d16692343bc1627311003769e978c749d2add7fdd9b2c4518037c0d36e95f6f767d0d14ffb944070a42260c6c20232bd57d582e3df19e2389d97e7930bc8e0217fd8c60d49133144e2fe878f7c1d1719897d34b4f1d65f7438394cad15d9ca3cbed4230cf928701b66429547924c97f1ce7696a969706d9efa1e034dac63854ecafc987e847fdc2f0843639b17ecb4977375f2a33e8731ac3d0c4df0420956b63581b3e875fda448d60ef4ae927085dd931abe34f9f82ab3f75e7abe56442cc122e3db921b47cbefc2fb887b9f503963e89c3f83af6ac70f943d40830c6e53b827d4702f1575fb2c7aaafe777e8e7cdb2c3b1dd1e7d70123a9a908935e3536a4259dbf39793f9ea0cb088b2517c3a530d3a121b0e02f1cd229bf55e24962b58d2a9378ead52b2b8f16462c7143eaa00bde7b9f08902261ebbc735f5c7e0ca48959d2d36a91c04dcd03857bc8d8a3fa9dfb957c994c49b3be2d07fee77665f7231ead2cae26c0c2b3cd25a068bba9b4dc5e5793dd7fc671de4dc9b03f72e9fe45b364d9471e8c3f9698a8856d0110d932ceed93a791926936b2be9e27376c6f7c1883233aff4a0c5b6b1bbe4b70291a4a485680814c42739bec146060bd2501aa3235b481a9904625e2a35b7110a080d6da81bdd81056b8e9e86e233dd6aa6949192e680bc738959d675c8e34208759677b9445305494d0d1c70ead4ec8afa8e737c8a58e39e652524a12647a5bfa45eaaba2b45db83c762bd0c8f10a8730b129ab303a7c4b1c2b5271e4f38b7d91b954dd942d6dc919d80cc0265e6222e47ae7a15f6e8f62cb440b7486091c2e3d7fd135c5c805e7c798f75c1083a93ced41dbb382999876fa7986ffd2a014401f9450781b1c89963dd98f7383945d92a897367727e9786332397b5bafe97594786d3096775153ec5a25fb03e931b5a17e43475c61236469032ff72d25fbc4b05b5b55e055841426d10c7daeb5959f88c90454a18494ea960748ed71c400479ac25f737e61c33df177d3905ebbc24276a7030c132f77235586311789a4e36d32fc381ab1b6ce536f765b47eccd565b8b5aff2dd3acf0b04cb10b75a23d167767a529612152c4cee9073604b7a0e129c1f23e99d86964501c75befab4444ee44df1a5615a350864c7406e774b9cbad3c49ea4d186b415fea750c5cd18fd9178f225faf85962de94c6ca040632ba15ffa891f66312808bb858428b04b7fadc514e5d913550504d5e4202c44a10a09f11bbc37a28ef9948c4d0f369bd834be47ab84d3a2187ba92c9cda23aa70be9258abb5de45bd2c3789200241f455ee42262d133e19367bc86feb0d40f66a5b0e328139d77a28ec7d04f170413cd453489614b99de508c880c614c12bf9bfcac37655a83593e25291399522ce18de6bebcf3a304cdce641a3a2cf8c48d698ed779f408f1e055567967bb479b8a38fcb460d5e496fdd2afa303eaf4de44392df2302d806bef8e1206f059080c59987e79b62ff45f1629a9c83d50063cf02fbf589d3ce88844c0262e62cd055e87611c1c2c5bbe7045f0d66682e26760e4bafc79c168023c760db4ada77954a488c821bf82f2bc6761845695f2661b255f5b3b0c19064c5c8c92f51af6d31c09fa629c794ecab4b1f67ccab0ce9812c36b003eed10d2381e884ccae22b225edaee032fce0eda430e3f4c79268b198d8db241b448f76961455cb108c8a39340c7c96b799b7dea709e5ce638d5a733a3ae3bcb399a57e28dceb2c4d41893f17228cfd7e4dd6dfc7c14ee090a318eaa742a8a7ea44b3e45bfd114eb2a92e03be634c448974d601b2eeccce1684573485dcae13a5477eeb7b6faa614d6a57fb32ac0962c611259fd2e41452b16a22e03f03727a471e4e2e9c328345d9c6aa56016b8c3068e5be9ee7c05a9387d9a9d598a19b3b5a3abcbbdb78c6168a2a26b479215a56113b18122ca26a1db75b9c8b02de547932bbc12d641ab6e083954e9df13fda22ffb0d3615aec58a656e2c67cfece004e9618858ef4fa227cb36b052529376c431e6c71ebf3c5a24a6ecd5e41c46f3b24931037bcd906689c4406801d5dee106548e3b45c2c0ad489a34e9547c2f6a9aaf0ed3bcf8c31c6e6ee2c8c3e0c0d37760fe54ac749ff197eca50246b3c2c94e887bf184c7ae32cf4b97d11f5ff41851e75c34e80872f7ddf760802067f174f924288f90d6dae25bf4add1fb7caf1316e3f09595c566ba8d10be3953bb65d18f34970a1a4dcaa7f35ad8bb3217fe186b86bbdf488954b3f4d3cec812eb83893da2de74a2526fc4bcb61788260f27c6b928eb99be527681157e52abdd91243b0c8e524a055a7cdd3adaf2d6716129b47ca67c6b3310930b4020068aa4230653e86fd252af697d0403a60597b9b9e8012783c3eb1d4103b6f595d8519faa566be53591a5a774ed73bfbe9969ba96ba553951abd216c2ae5e329d371dc3b77aeea8e181acf18cdffb0513d52e03d76945862f94c87eaedc70a7a9da3642bffdd53f637a21c05a9122960a5bb16bedc48497deb301091c920b02fc2c951173704d0649e86a90cc1ffdd4e99ac8147711f7ccb5626082cd91ac1fb7b0593dde793f8b1debe651bbb74475644aaa344aeb1b7e95ba1933012396db60b14cfae0af5dbbdf48db2e303a08393f900bc13b40cacb6edbc745a6d3ce7ba1c02063e709b52e04ee6a8d80a024554c8be924baa63d82a27b0f47e6f2bbefe62b8e7668e0bbe11a32fe0d978d767a4895b1b076d1129b9422b953a49a4625ebf4dc5a99b4a6236a0186a22668d335a71bbf06b0773d1b216ed2df14d69f36f1640eb251ce58e295c2c272a21197673f04ed3ca9d26e4e15ed2cd95a8781909e3fb66f41ea4bc333103241d0dda10ed0d54a400c0e999b09c3efd1b42aeb7c9200a2eb6ff16220bc51c08a528584c4c147be00e8078e46735fd970130169bf019d301a38072f5be5a0b06e317b7ae8d365311d2a8db60b61c9788f1fca64f1f008353e2388c563d7c07580092f515c99251ecc342634e2a2937bc26cceac928b3927189d6386ae86905eb5606624c73ada5b6ccde21c1904b11f29b4b99c207b7612e7cd2bda02fe25b109ab15d1fa0cdad7598ec83f40c10ecf808fc5e1d62fc693ab72005b49ebc101f0bbf29051b99d394e3c7949ba8a3eb3f15e6489e394d43d108482731e8b49259c241c27113c26a7b27d70f5cf20149b99329ec64512cd301155c9e86cc072c1507591e45af9d2a7bf1a0bb6ff18b19bd7f3bba626543b22bcb74e7436adb6a86279f086a31f79fd151166c7d05b32e46343640c6b15ae57e9420cc3f481040d7b950cfc79e956b24e0114a0f9b769ab82d19b80f9874932ab564548b744627d0fcb95ce59db1b047237e6b140ad8e0fb492e4512c031b7cb7b9d5b59deea8e738430dc7cf44c45a5051d24ca5c382c02b816a800fd4f6cb14cf6e838a34b7a28e08526d8a98d5e4393423209a766a26ea881d727626037926be05b58a3cf3b67f5c7033e80ff69c083299428611680eec58b5f93c78af909e697bf372fed66972efc3436f6c5da8c45c42e81dd59c0b58025357234a3ddded830e7e48f5ca036e0cff960f634fc8a99f5df50ad73962eace6e13a9ed8f1e8e58057ba03d33d0da64c3a8943a937fbb2bf9dc79b77447479b5e4ccbf7373da2b76d75580186413e9669965d598c11986aa4de0d833a36a2102e6a458b22e38b18576f965b0ac292c979fbfd88834c968aefcfd325a6e4bfd3d10c0a2e6d5b4f71e7c900e1c375aaf02c807a3523564dd2ff2e40ea2018e05cb119f11aa85df793757d77c8e95e521066f6f3aa88588baf94f57a4805ec326eaab891358ff1ab0a3a9fad795a139a8b00a85c8153038630eb6bcb2f24b546f2fcbe29801858b95640f633399fa764f22fe5af890ea9926d68b75504e051cb04f3d35934d6c4097ba80b2a3647dcac5309320cf689dde8e8acb65a89653ecc8489d0cbcd1addc6eb8b1517f71cf0435505b61b0e7f01267a29118f5305f4d8a0bd4f45a8b07ed1db25ac6e8f87f65a1cee7d5b7152ee4c404f3be84bb89b9f6448ddf51d69d3e63d13a08c40d2f4b022cd98e367693c165f24d10557dbb108022cf1c408619c7a5179f6f67fa2edf4f6b344ce352fec1348b027cef7973f2ce9517f6d9aa14d7c091bce78e8fdd874b8282592a88932f70a72bf7926a6c115520a95958e59b1601a19f9b0e6043d54735a676b2b32722f24cac592459a55cf1a7c5c03ac3d59a741a71c1df8a5dc5010d6a54de0d36a8d6b8d4265d1a434e528a4fe2d9a315a51433f492a293dae499268084a7163678846811ca85fb0a917b3c61960fea5461ca0281da6d5621b99b66cc8255dae02084fd574700083fcd829145a03b42552cf5d88eb03187c23d10cb4a14bebe6ba6cd6bb7a9516f7df17cbe8a9638642254086752376704aecbd4e56b6c2a5820bda836ada416d6f87280e1f2e989a3e56b621bd76fc306b41c875083e6f4170d60910d3432bc61d7d9e3d12b0e0eeb6b32ef02e3f8df117d44abcf3d6e8fa3f835f854d32fe2d864225e2c75b06574d8352593de4916a6960f3a407ef4205651fc842a26efba99e250aa216846221e16174ca95850639a82a3532b78195dfc644db72c5f84d8fc784b62bfb864d181528883a7f8a07b641e666faece9d3743220f9d08fb27c87de28125224edfd413c25e68832c998433f90f35f0468d9fd6bb67c3c8de5484cf0eca0f1483eb897afa1ca8e29ad94c08cdc92ced3bc7575139ee158e64c6b6ea52e8ae3960533467c3e9445dbee2d6b3809d2ba03ba8d13ad20d80059dbd8502c01adb3a449264a6b0fdb6ab504868f8fdcfe8b1d9d8d7e328690fead9ce4006561c412d923a71971ddcaad20fd9a2aa962862a126bdf60b628da5eef5d94291288a2a0f13f6f9e7d01a5fc3b56225359722669d22f0476bbb213d9542f263adc8ebabda2d4004d98fb130e1447c6048db1b8db529d1400b5d8a3851bd4b499ddca3f2c824e383e52f3241b4b7567569a9235983956acb8cd984a944077484ba93b501053a9f9dbfe70c6fe2509eaf9083103f8da54922e030fadf1716394a6d6689659e32564eecf4c1dc054a6c1680d720cb68f82a8bf2d7562b20498ed67aaa96c3b8e2f5b05d0a0971edfff74c376bd334d2aaba959318194f17c1998862f988fdf4f788d2625014d879f9ca298c346d997e09d119548824c053cb576e07ce9fe60851e2124a4837ea9c111960b941948b17e4e2f2b18d1c7283a6675942fd1555186a537aad9677388196bb6d1b5a7b4df153c3a7497d31d5e311ea4e0fa0fafb74f7283eb316992b8519bd301ba56e5db90b665a54652c662560a9f3c0c2a131eb46aa141489533ccb7f2b323b0247e7425f0835810507839db4af2ed078fe48355eaac0b8e6a6816ca7457d70be8f0757b0200516770a6e6604c37f390b90a14f4438fc01f7c5b22727356009fa95668c3b383e14458b58c519b0461b8bca3aa23242e4bcf582c839a5f77f4d6ac294990b9551505c6a6a263590dad54ee5cb692af99db1694914fc886353d994e80b043844a19634d0bb7779be64b059e9b9952fca013e0738e8b109421897722a4062c67bfd23f377f467e6dc49c725c534bdfd804994b9d1d8cea53562cc931ec068b8adc9734eeee2112d077bb4332fff7cacf508c8a6dc8f0c3d04029dfa139d0b0d4f103066ddc1e6d5f5e5155d56e15f2080f68e57e04736d39b6aec0773f381a99a5e27f22d36485afcb6c0c355c15a4c80211bd4a8753d117ed1e07413d54d9847019c18f992463f72dd13d490748e5a6edc101bc9580e3507414c45924239875b1cecebb1564229b0a1a5114106905b28d132579275981d18e7f04482e526cdbe523eef6968d4e94bcb9f9833f807ef18568e5f051890f2e70f037f683ffc2a992dcd83b3c16e1f3bbb12169df9bd9fe3337e38e5e1d5dff1be337583788b222461bb4dd592e3fc3a98b51bc9e336c46831e2514cb903bc8317632810457295ec01660e6ebd1f539fd6318a84cacab22427e48d2215c53eeb097aa7ec76f539ca7b038ad80d207558cbdb5f1583964f23eaac008ffe2e91ee6e9d25ba814559eda82f719ed13eae2cafdd6b202f225fd25ef5210d5e3bd62ee1b07180ba99336929b0ecae9f87add60c59a8693210b16660359fac245ddc5f072d26663670f618931aec39a3c11b4c3c6f5fd19646423816ef097b9081cbf14f44458383dd84ffe18a4723abbbbcfa1ac7ddbb15ca64f051d6e07d8b9ced8690187fba56c865e5faeb944a0e5552974b2a1c7a9c722e8706f6b9aa9a5022022a3b2fd9fd0da8b6efb0fc3ba9e5cf010f8a39276840429f5e3683f3fbfca8fe450838a16e1b35335dfa67d4b05de4cd7a207516ecf6d278bf9e383d3f379cf4930622aec5f050e95c28decf4a63fd8df2f696f94ade6fa802ae1f3b2e047119252e956bc718ab243c7c51647bb88f64ec9d0430be8c916c372e8e44d0a918374a41257c638fbab5f80eaaa0832ef751de89e1c7431d15de603957e746666c182322343cc6c198a4c596676904b1ad0a00d2cec9f5c1d5666465245bb12622e199d45bfaf6f63c2812561845d8570aa9e44df65bf1edfc17b56d5022797bde0a66dee4cde965fc7665e44550d2fab7c4ec57edd838797404101d829ec15ced9ceb766925c5acf371c6e2fe786700e312c4a44eea8e365d2532290ba696d1179f3ac3f6cbd39076faef6b30f6b1735a147614fc46921ee321de4fe674863263bf09baf42225ec52827a16cefb6da73edf69e424987d20a254fa808d3dcbf40c6e6a8474fc9b00c546d4253ad8359482854edb24063750b17f9b9fca56ffe8d65bb08ce93207d2e266d4b757a322c13e793ce15332c021d209eb43abb44bff33f1bebfa51a513efd427d09fb002997791b4696e64f698bc4d38034b8072c627b27f3cef85632dcb9fa0129d97774ca0c53dc451fdf6e73227f84819813fc79f6cf397088f7974e852bc604c6a4a7dabeaf0aff09f1572d46230e90ee012043ad3f0e9edf00f6dc3b54e886b51133722e75ab1dafbb9aec54e7772085d02602ad1f14001963906371d22230d106ed7bf8e93be6ca355897600fa366c8fa6ff645706af287ea9c802729d2dc251dafb732fbe2d605367198dd6dfa68b6c628f681a827dc56cd8ca51bfdf7de0fda2b30524c694a9ea90bea61a10cf07174f29b477b4f231704112e2a5cbd17e632dc7196f942c20ccb70dcbaee60088cec7a951bdf1fa613ee93d666d808b235818c639b255ea40a4579cba3ab8a285998a28ef8443643b2990cd48954c17c83717324147e194a7729adffa8eee4a7b12a1ac6df0a6ddd82f0628ce959361d8a784339cba377c98243247c1c2885ffacaaafd3540276c5d5009cc698194903e3dde233a8780a73c2d5fd18c53b21657fd2c6d974b055d355e405bc914ce3fa21f0b2acc68202546915732930b044a24df39e3285dcb560a3da28709a6119e9caeace542d724547328a47fcbb53d6b113dbdc9c989b3e532c899a5ebb5ed423573bfc5c3c7ea683ce75f870c84f4ac0e345e2307d4e8f0d919cb32b79480f8fc72301064ac977ecf1f1819a864dc74dc256d24d8c8b2a6796788ba8d4c7b637db9dd3c7c2bf8d6c8d3ed2be2b14ee09c2e96cc196eb20c5688da09c115a772f5e20b16a47bb1aca758addc654715ff3968d17f1f1f16f8732b5f20e047d59b8b86b432aaf41860f7af590538fb531243f214f43732c4e6cc1bb4818986fd51e644d70e255536b5e2382b41fd5e1c70b727ec566c09a8ea76a0851e130a53252aef33c868f298ac687af8712e07cde2fc9ad6611af6fa2604ecdd2efac40df800d8b4b91e9f84b7bebd6eb96971318244ef53a5b5e889d8dd5366181bc5127982d915544a02cc8e6248215963ecd64a5c946b5adc1c6101202f54bcbe29a211033e7b92f5c546d49d8648b62e043d5509fe612023f24bb98ab251f17851ba989d312993b9a059a3031587c030d3228f5a05aaf00112f17132cfbc3eb0f69471f822bbf661065945e5430abcef7c68553ef10bdcfa9b5a80ec91990d4d4681394626276c113a60b7b586f85063049c93689b7fab408cded6bbe5041352800dfc130c247ae5cbd5696247b170eeedfccfea04d2622d0b4050d760691f3f6afb20ad07cc59384ba5e510df3dec68eda38904939ea35b845a5c0b9d08948a725e66542301910cac182a0586af96ea75d29cbfe4f2a88e84a71aefdbbfdb0455df62c515a3205a43de09104f49629a8ba279704ad835a9013ae268a7533d82ece4d54e2a476a80743b4e86891510994b5e5f1373525bee372fd9605c5094e1ed9ebb1009be7f7c83f8970c47a7504af9aa09a996f023eeb482de746b054d0b1e613fa53dc81b29af03cef0ee3247c14d2abc93467785d532147eae92640f7202396e047e6e068cd95f843ede04c490ffcef8ad79e60bada96d10cfa51176cdcdb2fa01788ba6cec2c0a2adf4545e64e6a090052de33169430600bdc51d14f43656487e96493becef86180a95664afe0e18e5774eafc0343d5c8a0933859665d35f6225b91c331db68a0a8bcba09dcac8c15aef05323f9767848fb09e840b9e95712471d1976f4b03614f6222772661f672ab3954f2731c378be9f29fca35b6e43bd3c82f9c42077c06c58c787f975f513d198c5b89fddf6f5492884ef1a77e8f525e80e655a177b22809b506b18caf7733b713c4de8d742826d8cc33ace5b3ee3e25916108865733ad48ba22f5b87f41b51dd7c49184634315837887f8a40f4fc349e10d9cca3d4ba1c1532d6e3c0acf28618c028c603ec87a85f2164030867716b2553846bbec746eb358ad28e242828e51d9c50a6c6a24e24c3f9e3acbf5b5cabf91ebd1d536cb63a014ae4155106a68bf6dac33bf111869ba18764a452d18038d6f7a24d6eb29ad9e4a8582972e99b2593312cda95d1f7ad6a4983d6897b20059fd219407632c6186cf45adb8fb02304af6f21c9c0e366321d1ed45d1f70efaa7f50299ace566213c7ca13a86c4ee690bd6170c1bdf1fd9439d4a1fa6d91dfde2792cff736c24a93912ccdd7c8ff98db13ce2ecb5b6698a6fa1eefea05d00ac05d75bcb203b50c2697a89a493f6c3575961fbd1f939beb2aa5e4e0ae49886357a4a32c4787de079434808a3c917f36dfed97ddcf95a67c522e481ef402841340a9616404c3032bc085ce3a61a7baed5e24ce97ae204e91ee8b5c5ec08f300e3bc6eed15ebaf0365339fd813a01417c09da04e67ec6fee7cccef44028d24b75e2427873333b9b4eb6690c411f7b1fd439146be7e7b7739038127c33d8780d7237dc854f9a17671c1081e94c523a0757c75d13f6f57d7b1fc407d8a3474e9ba822471912bef02ecba5089e613d6d783383430aeab58165d409d07d31579a6dc3f3e50ae26ba38bd3bcda4eaaae97bd45b3a1bc111ef5e2081e2fdd9b4ded0e338b83413fc0572f860ba0611225f32b86a7d6ad4fd841fed18ad2a114742bea4f11069972e6baef07efac81f029426c882db0205d4c2877097b382365b0acd1c5d633ef1cb702a0c0a25b8cc97d9793a4a0c3bdd6a3610379cad4721ec2d41582b5eeec281ac16261d1926f554662fd67f5f0cf0eaa14a7122335be0eca156b627564837dcfab9b703c36152edf3ef580628e2febd974d5b06c7eb5e4a88aa8014fea1995ee7ec2ea76d8c1fcfe6ac7591d157b00bf21348a8f54735922903d6360a22f0a969d5ebea55d68e796b8098d6f8c76243bbe20d546f7c6ad0840ff0816a5319835980a7feed4c0e56dbdc5b1f678f21e1f346b6218babbbe21b9b0597e2d590b21fcac8a500816c3e8ad66422af7a7f96a4edde27461491ccbb09b558adf3327f3d334818b965f78196f0aa55fdaffcedf4db51b1804fc5b93351dba7bff9da1429ba3f8c48fe7a7514c2bc4964064a5ba09886b577f433c07a042150e294f6bdb2e6098dbe4841c79a681e0b827ca211e4defc6c93d97715c03f7545baff876545202a5a8eb1a158713fecf735ebc8569f055688c9bf230eab2a27ce86f51722290568f528f81f47b8d299b154822bac257a7410718b36ec8fa108635a309babebf3281ae96fa40e1318d3c5bd56da152732b9ae0dae927a16e05e7a2acf1526d7c228019ac468c4baccf55efed118592413d27dd79281fab2003c386e874f82673af572cfd01e3bb2dcc2e4d13fa92bba16fdcafd653b10c23a0164b793016228c8e61b09246de143456fa4c7b0d4ef7807015e41b8380bbb47e55a29c190e6feb502c366960c6849cad134e65a4431521e6ab7f5a30e5aaffce031d09f471bfe1fa83e8c5508ac45dfd6f8b99da726c9254278d235af02b4e120fbf2becb0dc87dad21e468941ed3979ce148c7e99eb1f63d9da9a9eabfd851e23cc7296d5526f1719a9a439c43d076e7f59b4d09c86bc0ba7d632ed42c12b51bfe28c714b9be20f1115daa28b6b11777ec1f9c36f2d7a7838acfbad0279a390c03685d6ef95794b44ce2254aa626f7a43368a82de76e11cb63c43bbe122ebfea9257e239383ffbe5e4e2c0696aa05bc453127f0975d1f201d4b601d750acb43f514339f11ae91bb02f8f22f9526afea417b6b3858f41719fb050445b409d98f1c86cd19e6faae007313d212cfecdd1db2b8aca3d3cb204eac3d7d13f1d5221822e3fb3bdf21a4535d1cc69ffe5a2a11df1e76535caa29d510fd8d3e20a74623f5fefb5260be17a13716267c113aebebf9895c3d43f907325142d4c2848288f009c823dd4ae6ad84975b954e493bd0cf7062086e50531dbfb0af1558425d77b99988c8b259c4127cee8c89b2d1489f1c4d073d5f00b05603b0cc637e38095520760e8a736fcffae45ca97cf59efb40b0e41a1e162d3d204ee07c0c46ff35ceac4ddc54aa6fe7003517df88cc0e6704c69277202be3bc964824fccc457c2e2195ca2cded9f91dac9846f56b8b68b9fa52d13cab55490f7f02b6ae30d6de9df2a63da9433968e962748a5673c2d07112dbedb6a9a90e1ad48aef11e70b6a80de61aa0cdb0650ae95b4e596b5677b84da32567060009bd9f3bdea7045d6fd2fee31e1f50a4e818412dc661646fca265ced91ffca93115fae465fb48426e4633e088fcbe57d246cf4db22cb0046e68d596f1a6f4b0565e8d249e46034319e0b74119e45bfddb26aa4479101ab774d6dad5b30aa00c8e51018861815cb931135781c7ee53e742e0cd5a9f418574285e388a78c1549c8e44e905ee43765533c79bf082f3faa91de942217a0361bae4ebf86642e6769aefa7d0aa28ed96e576a6983c8625a540b1026797579cf0470294b188368b804f4bd78f9914d4278deb092f3a084ae0ee14eb45ebd36bd5ee52fff8179a846127276c597aabaf2f66d165be7e38533ce2d89f75f3bd4ab6f413a5ec47b91d58a11702196f91b75e09c750e7551df2e7f4a5bfaf2109c0c74ba6b7111e96e878c8d199c50f95863072934752880ab0131c943e2bbbd5460437fd899fc008c800b6d1382e82ec1b79fc004f6e9c07991f129a3245afd3b7d85b679fdf476768a3100c6308a7af49a3b4c58a1237a3038597af398f6f562639ff4eed19c252d0c7cd10b13fe9300b8a8a9bfd82deb630c85d2b723d6a68bf0a084414d97a25b1384ffec0bbf4ba49751d81d95b957268c4b24795f67530138d672ab2ef41537adeb18ea0d546f6ff50049d6959577df8839cd43f0023723f689a75a51e82e1f9943750e50925d6f336ebde510a96f693ba096c011ef2185a9e3cb9955f93782a9c95b70e63b150072c0664d5193e306a373aeba07cad68705df1a6d010df67e0777c234caed4da3bea6ac2e6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
