<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64e7888a8dc114ccc3035656783a2b2a1591dbe45a76079d6645b585922352559887bbb8491cc9c779d0f25eb622e0c628d4761ebae69bac8c2455efc6b705b0b198d717242628c2bc726ef6140cfd6182b68b3f8fa2fd0001d31ab16c092e9192c4ef4741ddff807baf8b5af0f6dbdf8300ba385cfdce07d8bab177154e301f86b41fef54d9f296143c5c0ec82489997cf3207c8624d0f460400154954553baf2a18d825875f8e2b93f6774219dca0fc82b1660ec4c85533b0fc735677c0061b42545308b3714172a88ffde6dce75e34fa4ddcd2eeb3048c375214c5ca1c09dfc17090074c6a6f3fc5b49a8b16297e33264047bac288f6cd45077fbfdd42adbab017f906a52185c574aeb26580abf8158b0bb9a17e8cc2f38a334fe138aec974669a656ca9960358e21c5727105b1ae7c714b8f9916c1aad97369e65c5b1f0a099effda0ad305d8f223b5c6b2f26b5eccb928c855d6fdc3d28151ce3cd447224ff10c9da7f05d1b4e9d5338b062c0d76e7a2fdf8d5eb5b9f915ee799b8cdb2708a96e3a51354f96b11fecaabfaa60926be5b0f852afc1e9678d5655e97cb33a7a45fd1ac6b58d05a00812bf3b680b5f88443d11ff5f5db02c2d622f83a17a3817e9278df5a2abb80838498e8cf54e299e15faf858a3ece33be6c176ee6b3799869c91a9567cab9b2d7c0e87d5adc9a064d8b3e5f085cd915d703fcbabecad2703f3167c38200347cfa3f21071c44fd8b87d4397318a6c2491f315cc944040e1b16a5a63a48f07a1c8012be0e74e7dc61e69997706db6fa7d260c51edb08f0a3c4168b471cfa8ff52d540f1af7beb5a33a135e6ccfa7fe0b9c6d93839a7e95afa398f246f70005698a0ccad19851ebd149710e4c147220c2dbea266ae4c0b603b5c9944e8e69dd55430d54e22f6477bd43c2976dbd43e25d8973ae92cb68305ebbbbf04d6d8804296b172bdb6db01c629d0baa5a256a522c2bfd7efacb4f6cc3c0bfa6d4de302a7a6abe0b0b2e78e321715ecbba149edebb347d11dca2ab1db1b48b91b1be2f5bef0305f537640023d5081754ee6c9c34a88bbcd6d0d473b0b3af186bf98b385d7af9b284f32f2fad6526ec97327d74e196d02a0a8872ed6e28c272d229d23278b334510b4bccd2bfa1382a134799a31935c99a31d2a6af9859c81a1cb5e82b0c18d0abecffb3701ce7721242f9539301f6570141894aebfb96f32bf17bcdc9fbd284f01e289df27ae4d27c24d4513c2cb5fa71215cbc29ecdd81510f89b35320c185c28e1907a4fbdb91bfc28118ff7580d71b2512ffa25f990ff1d2fb11ac91fa73492fa064779d64a1f9200a9bfb44d4d6621707d7191f3d8c7b1169d8bf16e4fcd390a9792a180f41955eb6337f316383fa9d7ec2f3fb306cbf95c8129ff956c9641926ab5145f1d7767346cd85bfa1e6f2fa5e14e7707d2a7ac0d9ae98ad4c7d256c2a7b747a22c2fda42ff92c1a62ec45a6c7390472ec30b0474eaeca23f05fde3897c4363c46d589067ade887da264ae84b3f0a5a04cc8d6ea660032165dbb3f0e4a97482e84261331910961da9d3fb16770edc6e8563d7d807d1893ccc64d6fc5792feb3fd1859ec0a6836b734519187da05d342da6ac58f05b652678028281f1f37b94174d393772f6b032ff84d7837eb27331387b08d2e7f88c1afc0da6ba8347f21231272dd49696d320f2f36415e59d13dc47414fe96d0e604362334fc61feb12424cf4872c6e07da969a99824093570e2a77412a20d5a1ff7eb4913c8057543325cb46db378baa7048951764974b9a365db5b448208bbe52101caa0f7f338d0d6054bffcd12d105399b8dd40ffcfc18f745498816bb55d0c06e5fafa17a072cf3167ed292f213990e37e6be06a0ec49d4c7bbf3f7ce25f546829ac8c6f48e4103e873b78703c944a49d872c40edef801556da170a2ea15b357cdbea617ad20146a42c1d560d78052b5d8ba497eb5637205f72e7e359c48cc577a0c69e3ddef32697282e34d370a1fa18f780a6d45aebe75257246e4894b020f20f4f41f01c4245f0200e3bfc6bb51fe7b031a9b791a00e51651b385cb7b05fef135fb71e6610600815ce33c0fc8e9952425b81562386e3ce55d6406a15ed2358e453e1f9a4795c477b050400008a94cff46f025f2b979f3b402a8333d91a524acf472f9f6ea5b30aa52618c0176c1ee385ec2f93bd7699919bd6c6195ea25308ebad36593e36ab8c4406fdf72161759330ce1fd99e32ffc707680d9f622fa8035625986f53a7cc2c9f5d011ceb8ecb95138985661c9c0bc7375466a97b26f7bd76f741a971986855fcb862e9d7c44475c9697ec5157504800425d37eb3c6b8d9e00b10a28fbb6857a269bf43d446d788ed7cf69e82bcb6801c77c345198ba1fb9eb4b3ea5d6062f627cee5c676cb15e067aa25853fc1017ec479e25034e800652b772ae46b7155a94066aeceddbb8bce982d720363520d7a8633bbe7be86d1d59810aebe057056b05ae03d83e070a0e14ce070867d6a6e95d9eea10f472c02fed639b573d75e79abb8bb78df4310c10b694638c8370475426621081967f0c07b4ded56616c340c36b7bb64e0cd1382e660ca1af622ea76989414590fc663d60111b59f21b0bcf18a42e83536a78dc0ed7d84889b52ef429f86c30cb49d88615bcdd821f49311255e7835dc0d939643e146e4f9ecd73a708d02eeaa29abbbecae032ad5957d05f592ab287e1e5eeeef0423c4322082c3f3b1663ca7bba9023659ca5251ca228110e109ecd230a6fdc762d32df14cb853625346b4e33e691429a4b98b5e576dfc40089f21626dc7e3d19b4efcb581870bdea5040da062b2c23be2227228c666752deee4cbd16a4bf3707d284723a34ccde7dcb191f2efb1176049eb6c5b466f5df8e7a0ffa9bf7703a0615aa2c43939d25015aa3873142a574f7f133217fd26cb69f1b20b304ef99afa513091a0bfc4a2d8d3d90a331c4d587f5275b1b9df2b004f303c1a665f66d1b2681349902cd32a587e68b3328370e2f427f8eda7843b1adb2aa2e4d34d63c7471aa66090ce19db1722878fa4b72112c9876898d7f2c939cf1d9e614db80d411f7cee896ebfd9f7124dacc595f793ce2757b008589dc85813006ad18739a95edb48df097e51608691abd8001b03d262e7e15d0491aef13c98a9a087131c18b4fd68546755ca3b0972474372fe55e6ef15fb175277271577c5ca45f929b83195ce29841a46caecf945b5336a1f39308052297f1aec1114ca8e8881348e00d766f3d14f703bf694075fce71b924fd23181358f5c6257c758fac329803c7710b0465bf37500ec17d09991efb09b1ffeebc0e7c28b86374e4d935d80c8e883645f700ea38a0a528e208bc30eddb03762105ae3aaf290feb86e3a589c9d1dda27e65d6b29c6e86fe8923402c880c99aee65c8b52c42d4c94a7b0dc5571d2ebbbb14614250fa85766bb4d28c889861c298131149f1be8c0e3bd5fdf642610279ddd3a556df074212e36b9eb4873e44fc75a6a2813924ebb6a29e5d246d7c20df89a8c640b92aea9e2604747397cab3458c0a9ff6405b4459b839944fea33575630c4502b240a61ab80374b609866d12cdc468f11e96bbe442950d44ac0031357b478b433ec5c40de0fbfcb5ba6b9a2ca3282d2c1c39617a45a98367e3d73075f876b49e74d9017f0d514345f2d1aa7bc79ed33068bad125f36b198f1125618fe732817da23104650a64543ba9ed348082a2ad29192a4f24f9f7b50fc89bb1395e22d8c938af4ac32ea6209d6b6587fb30e884eb1271ff744ddd8f5fd69d7eae3e86023d68d9a53c3692119f164ad63a2d11ae9e31532456d254cbc32237bc2ad693f196723624f123196c48535c61d35c96179b99e8921615e5c4208ddae0b330556f6103069aca6db7dee1667272877e4d82450d73893b04fdba9c7a1002cc3feaa81043cce2d2f7efc83ac6b0db096bf2ad6c51891fb6d431940bf4a750f7401b6d8db1389577228fa388e0fa0ab3d9c22727654dea5bbe6db94e470d9b9efe300f8014f4f9d1938ee77ca3fc57924851c9d9cdce8e34658b183530e213e868ce7b4eec8fafe27fe27de6975dfc0cfb370b5775f212cea890e17f32b52512038215a578ceee657e5a51a03ac35d336a7bc507b71b1c56f36e822706fb0a36486edbec89d8999718a4bf1e8437860e30fe9d822807d73704c64947a95f5a83b99f8988b57ffb1e60fcb951ea2fafea67f916ed0addd3c8620a0c5afd472168dfbaf26b99d6b22af4692db374ac907118483812befc81d30bcf2282f5cb7804a0a135816b008e102a28b04d22d48fce01ce6a4bf4d2474c2c501375ac53511dfec232c519e40790867506c5039d436fb912beceada0c95b883c4d9c78b9eac7df5ec4a02f8900edbf7d943847db77b3e763e6c11e8e1a2d5c043a87f4bb0e23f309c9e3c7acc8efdf39c4d9b8186a4552e1a8328d16867bd482d3ae8cc039169113016a277cc894299d827455e8f7020095ab1bd843e4aeca3915235f0a90ab9f84e605323c199f7f53eb26d70912c740601349a7e8ab5690408f0f9b10ed584c5281b2f05bedeac34749bbbe109a49061be8d3028df14b125747b4f7594dd1c80e02f4193657ff17c09e19ee51d3ce80e84d66a5b645603c731d6646820b21c2b76d6b85d44a8952b23a0f535132890064db5e2762d81441bc8b1e3f1747b1681001cce82698287e311da6e292f076a92458a41a0afb6d1e6ed7b422d9ff30a5b64e79c612eb8dcbe973e24891b1581f312225a66411560724e3edcaf97120be446854d4f2dadb211f0d768bb5381ad93b823318e32dd498dd1076fcd6e4c7e280e47a991fa28bacc2707d8b8671e1d62fad9136c27f243ed4f186541cd08b3b4dcad7b9ca8bad0f804fba5bf353a797dca98a3dfc7b36e2478cf6e3397172421c5bfe6ceb0d22481e2b67768ac0b3b160b590ce59f891ef9d9fc0370a95cdf21952b457f2cee53f8f057913e3e72ae8c22289b886626f8057d7c16bbc1a8c868438897c85cc8e717d946054a4fbda0b5c1de3b8e5a0b3a6ea21de81768608ea85331e48c37b8912f526137b898cac9ea35de5320a01c1463af0ebc8dcf066f32fbcb24ca234137607303e4f44186a56c72dcd6a00a1d4961f920a123b4fdf60765d7015c65b3d87169ee3893d78ca4470100e2a8fd05203bfa46d52247b5ac2f35ed21d253689f649ebbc41ea39c53ca81bf8ac02106dd35d108d2a9043bd5daef86d05a8b348cf1701e8f1083bd46c348b84556ced6e75c40209aa5b5965573088102b29f8d4d712143a8caca37d06df90d70b043fcd406a43f7c1b9743804f968523c158bb359b94def754d97fbef94930fe6d015351d742bdf6518bbdf906fc8f50a2f5b34c2b39c4812da3818728933b13c594a5b1d76d0c0ded79607ee17e3e752ab24eb8d7f1c1eb2b0c091e45b072c342ee1161270c138f68df8ba12b3c8e58d565f65754a67fe8e29b5d9f53ff5cc5f810952aef6fe7052b77922eaca0dfa7272adfa33ad7ab7a9656d1c88eefa51003e46829d27df1a5131a65a694603693fa2f5c424aa1a96149898d351b6d1a23a213f3e45e176c2e435bbfb2bf2e0310e1b622dae0199ef4eb1a881270f1ca09c9a5cb01d7eef744cd7f9fb58e325fe17f943f3aed551fc09a68c741df6a184c97e82aa6e70f13a50b472024fd76154900599b37b3419b3b41895d8aef9c935832bbe017feafc088d34e2da5696f54cd79d41e86eefd8bc52ae13edf7519f832f137cfd5522154da2e7e4a80f1b2993594f9ed15d27bf946bd5407738f7ec3deac41a5d78f3c630e51b76b84121d4216306fcc73039e820b618ec2e665111921fe08ee3e7011ef39ab943e0571c777fea5281370a0ddb462dd8af97b121c54e9940c0a979ccd7598236fbe2faccf552877ab2534466a9847e524f056a54171f21117248849c8ce847141deee213bbe9a5c4f14025723823ec1330500dea1a41c245de6cd575a4d387a888e691968b71c2d8cc6484a7aa97da240cfc21287105f4285e3c5a20a83cbde651a1fa22c84100add633400a3c9e31fd5637039e5f4a6be21b980f779239e02d424e1ae2eaba5c6f3a9a5c8996ffb6400a134fac7937c23a2cc69ccd9b6b0176f3b3128506acc8dafd5da8de10b874140dc027717c1f758e312e06386b61f1081a3ca9147f3d362238d0a303288311388d3669a4159c7d3c240c3fdb3d16d4c5435cefa8dc945dced973b062ec1bd705c08a632d8f13df9cba983b3e0c62b718b35dbfd7db3e44c45b3186fb12d08ce49b744e9dbcc70d8af17c3aacf4064cd50a991dc0df48747252c7895b7aaea397dc9c11eff7eff650c4a4a70d323ed1afe8e0f43bd6b030cdccdce00ef8aa2ad3ae100cb816b3fdee9c2ff93f860bf49a763383f1b9f09de18ba4ee0a635ac75abc71002a541b103a1b13f4f8970ff9bd9fb1af7cbd098dc7312adc9bbe624214506e9a9532c84ca1b91ea4e9404e70867b875e49527b612164efff5d01c744a5063762e4dc028c9aad838bc2d9fb78b2333d3f28f77b74c746727cc3df6c2d7823935099849bf94ad769b0e6f132950a89fef4abbcaa76b71f17169c8d524b8947f7291fcd13d65cf74fd659772ea59a7974d33164f596589dbce60cda4142d616b9d3c38f0a1375b6aff71bfca3ed47fce8ee240fa85d5e37a071663e88a3dc7b0c1d78f6592c5c9212f9272ac64f2b73e22ef72661937402ec4afbbbdf8de42ed277883e70978d04e8557704974284d8f27c035002c6c72ed6440e36807b34cfbc7c4dff74cfee20294df848709bf57d581ae3e792abc5381d29123e3f853e53304edf2ef4d7fe7c567b80ea2bb0a7fdd2cd5d19c16e63452baa14b29c00d42b1fa6d22e997f3f36097f9edea935b8b8ec073c4ad0732786350a6257777a623bcca07cf6da0ff95a52a2912f731c85505ecbbab4769696448635800728e88737be85fa880f2c0fd8d87da2b9baf0649d91c6aa57e46f8203d841b1315dd1eecb8dc68c5339b8e9284558810cb12dc3830288a2b122b1887d795f606e06a62d9aafe6d268ed173c5c5e7189b82561bea7a54f1df1cf6105e0f2dfc4391dc744c3750a39214d354fe14de5818daea267708cc911845a94cd00bf6de76bc8edebdd6064b3af26336e9411262bd93020b5c6275228c530fb84e378dff3f634159a398ade4efaffb380b52c088a1fd83c8e3366fb03544809b76639f1efed271cac9dc8c87e9ae42f48ba5db526818cc09c52a03a694d1a1315ce13a10f984345a0547a61e047f5d776dcae93e839853ba0ede50feb1baff1a3eddf002f5563cfc8068ea9b4cf5a6865f19630c473dfdb14ce8107acca33ac73b8b8a54d4bd5f6611256de08cfc76e1003b1f211f1670bff8122ff192d6edf3dad7f6f79b0fe5ce78fcac35b58bf571ebaa97a29308e4ba340691160834810140697248b3fcc50543fda407df1fb9d3a5d8b9cfbe6dfb3bbe8dc0983ea05a987f7fb06fcd9793e976f749821f8c451988add8054dd6f1516ffb4c382ddf41ca73710c8053f82e79d234a4aca913d5ba4016f661945d2632a0e227e0b049321b866f26749385542f3f3745547dce7286dd133185de98e016593ead7cd91ec24907cdf8dbfec8c0fc080d0851d0ec1d8600f8da2447bb7dab75bbaa4c14bb43275d94cde683ec2b80ec52b417f6fb48cbf2280fe038bb7f5fdbdbc57e251880c9bb33b0deacc49ba3cf6416769dec064cd9f11c2dd129342dc769aca152aaaf9ffb258c76a4c35e71397d75a4519dde56908838fb08c77bf8c15c1e5fdd437d12c2e9e31adce9cc553f444ce5fb6e9795c74e00b4d988061585c91d64db92ee5567428e158c0126035582c16d4942d98a71defca1395be33bf742daeeb25aacd915970423d4ccd8f8cbb0d6dc1424a4d8ad3c5dbb9c8ae263ccdf7570081e572eab29f5cf9423a7475084c9ac2e68fc546f45eedd46c6f3a1317e32c1d8b6d1c301770f924778dea9aa2b78a95b75ecae0c08987e3c69997fd17318313f2aa61bb064a7bb197131a59ec9acc7b8b062e51100e91c602e88823717aec60ca09c1877d5c5034824033a0f2993c6407696d08724a3a9165f7c40fdbf2669635bb4a32ec77619a3af17f1744a5b51060bbb6711e22e2cfc77f0f386e703e9a7cc15de969f8c0dad695aea7364eea3c6260903dce1e1298d8539db92eee931ed5706fe088ce2cc485ff1051541065a0dc441695bc73e52eae78b32231f06cabde66a8f9b1edda67ccc68619fd6b4e9b6b5c4a248f9cae73fe8e2e25205a7c984ec493b5b98494350f4f249bac24879b5dfdb288f51b1d3b690cd0bc2e920e18b717db54cc8eefd5e35a9f4d8160efa3c9cbf3350b92bb07d143475856947954f071351032c78ddec4d2aa15c8d4f6cb0c6cab4c5907997c840b17a3a86a51e9b25ca4cd97eb96c358d825682142aa23650f3605d08e3defc2534c004a19685e7550064742473fafb577b3f5c951d9668086051e3a3288ec6a7f1aab201cd35bf62524172cbb49c36d035cc79ba2dff01bf126ffe17d6e6dafc0e22084906292d6e7a54a6b59c0da86f2c7a73b1434cfc30520627d03ea5dac83bcd5d7e125db22c77ebce4e9e003a8470ce9c92c2a90480b8f5f1640e5d132a2806c8eb34dddfa4f71d3ddd69d4b1ab1b9fe55895e52a4310863441dcd7d32009f9da3b4cdb2245dc6eaeb08f72277fcc8564dbadf02c1c1227068e39c56eb766fd9f17d02c52ac4bab97cc9290c92e6a8ab5b61f3f70cb771c4f22ff094364436197a9bb36a68f652b7116bf96392382f5ab6cec9eaa1bd32720d85c22edb1e6b73682449ebdc99e6975885da550c7684f6e24269b9fe037c31b264055758335a2805dab60fe2177fea8f32c69d30651cefb28dc64da12c586485641e80b56f6bd5fa458c105debb895d23f6bcbff4653ac1d8bd38cb40872ba7d9a3cfa64d9f404f4efe6a9c68e4a6731d59821dddcf24013c4de5d46238ecc1d5e5850e0ce6c01799ee9373d3f6eb845de33d07cd072cafaa2ef4a638efd7bac203f3e76af6a34fcfa6ee3fc9fcb92dc4eff136c2e4914b4c7f2d2d4d6e8d80c4286500f15e3fb2b768343e0a5af586c201aa40de4ae80c9964772e5e4717fd9d5f10bd6307713ce23d76fc0023d961c888774e3d464ca0fb2726d5aeb8c1d883442c4fddc2aae8f753b6754eab6d036091b2c3a91a93f4c1d8056d430c9458595c54dd7fd83aefd824d49eea2a7cd531e13aa7cca1407eab1d56bda3dcaf45767852de4c0ff510a9d872ada3f157806c57b4a0204aac6866caff92c19f1d9525d16089bbdc8df164c32bd3cb9151f3de19c3767d0e5301e5a383e3579e3322884cd6dcae1a9b04e9a2c927dc72d2049ab3ba100052d493c4a4e6628e694f1e3d8b9e091e5f5a5d6bf2fc1da89b30fd88880b380e53e712d0aabd65c6d532584b2c4fc7a53be63306162adf2172cbdecd758643d146b2d08e4422846d31a6955b3e1ece1c0b04e9f355ec920a1feb123355c1b695f4170171313e2fc2900c1d69d4f4594f063eeebff276189a186a9f55bb4d3665b8c35985031651b464f083b97d2eece822e30afc3292b5bceb881ed9e093e316ddfbb938f55c8e26d9d8816f6e7c04430863ed9d5880cc096edd6e645b19c6977c44aa2f553a50f44bc1c7f01f5b7a516f86b340111d852adb6e58344d3fb76bb190b72b81c8426dbe903bf19ec26f152de2374d3776e001446d7b880e4f1b898f82f5a283165a236c1140db64521dbc23eb45084831a61cf2d41993f69620e0bffca049aafee0865c062fc609a66bde0544708a5fad9333f6bb0e95c795d89036a8fae24a152db6c58a04c7205fe20b784a94363b5ee5c5e1180178458b4392353a254e5a562dbf3c4c86672846678205f408a742b205593ce2650e1b61ee4431d7a7725e292f84736a9833b89d5e36c16fd0becb8803e8f3f17011b8f801fcf0242d5581bad0e6cc60238f74ecf9b214e265c2a7ee46072def01a6160afb082ee0f20ec7e8a330196c4ac53c21f2228b6fc03ae7abdc525b4eef286d88e4052a06df79cb645f44bb136c34aca9c21a5911db63f73e19a423692d3b532ef2babdf548857fd7d51749dae5ae1d2dfc84afbe7f1535b28a78298ba640b5593c4205be8cc289d51b85419b4cf8b0273b9cfe06eff8824c90da26e24e8ac7ec80756bcf2c3c728b924a13ae7c72336073646c5299427c9dd2faa396a505df168376af7330617a37d903848a8ddc51fdc76541fc58dd5e7a605c078e75849be545afa0e5f56b238ed97eda6b1546a3af405968f4ea11adf1a0d29d2ce76b050011cf00bdf0c275bcd941b585278caf7a0b31d5a3f982155a9a940e31820325cb83d51405d62ca59ffce68f5491ee119aae37621dd992db1e41a39225731be26ef50165b18c402d61fd27102d4cc513165812789b13099748e9f88b6c8c706ef997181614c290d29dd48e4e4dc275fa54fe034721e0d6a661181cb07505e0b3e0ed25d933b545225e3b53ecdccfe1291e6a2919dad86894a5de444326a0c1b48e7c5f8b23a233fbf9897e94d91586ba975bf3adc288657abceb0fdf5b67b49bb33ab0dc0ad3de29785463437f564924bb25e6c74b47d8d01a4c24bb376a0f9db3594df027308cde34780699fdda7238373cb74162170c6c660acf7ca97d668b54340d4b46abfb705d64b22f312888e52b44870a6684f4182e9053f735ab963cd67cc2529e2e7629544926f6c5e1137d62411887825dc7624f1c582ea088c863c5f8c2a6a179894accdd2311f965657cb0498184b86a2db23f4e7118522948d3ad6e9abaeca84baa878cf9f92648c219ff79bae10719e8b8242d10dbedc75cacfecdcfec7264522f1fba9949f1778dc17940e3be3b111dc28607d5b7bcb8a1fca815f1f793f1ce1738ccc37adb13a526b59c02b8f7933fccab8a0844cabfcb0b542046f13747f37385491df83788ca96373f43af9a5989f7d3c5231deee354d999566ceb930a6432bd149bf03b8863069ab6ef7011d395e2beeffea645c8a484ab2174e0e7fbfedf3b0a223392bbd4c4b36400430c35f15c8320e9c04281c0fb7724abdd8ee307c4392d9aa97c962d542e278cd91334cd6c00201bd2875c7499759806d53d86782d88e540a37aa21dbb000bfdda19eeffc9f5fa096bd1fdbbc4afa7ce8fff26714f66b1b8af42f8227022b2ae057ca4091993ae4078164f42ab84937143b40b0859a655ea10565217ac0739b0fc5e9a3334c8bf0deb99894cebf5825d470a30611f0a40bd5e4ff5c079626cb49106f7bac6d4906265941a8cf9e8a62a5e63ee3cbaf738fdac67d7bdecdeae05af8458fcde1f3d3556f1775643b221685af4fa7c74dd8fab6fd97cd5c01e5a75a8a28e89d682918e6257fe2b6515172551d4fccc6914b4cbf09a665265efa96eb50edbf436c08b51c90284daed3eec517e146715b0f9a991a37cf15aaa8bf53d299bea9b29a8af2290e34c6e8d43f92eb3e44a455203e29891d62ee74a7a8659d9f7fa84d14d70117d22a9d3c3347e0147ed51c284ec19902059b9295c11fee57b94e65fc225476bf7db7551bc0174d73314a8ec5077bbb4a385823df378c931295019b372f1216b809943537042d6bc36a9556d36f34f68224d2f8d9247424e53b338c3a4e0f330dcd02404dca02b9097d7b43323074606244da0f181f2c7182715a3f58d08dc837c1b8928e5bb28e8940dae054f40499db49ace81a6ad062d5a14665325788840cab39a29d46cbdf47406731fe65549188a98572c8e18d8a81cd1b390b37991fc4a7b257afc104332b92f6f1bd2105cb0c7428547eb695ea98d5c048071a2e4ddf231a9079f45410b0909fa0f110db17ed06fd3ae2fb285f182c89e0349de1161a560ef769d7c2a19b826a4ca79137aa9b340b401c58bf4c39373afe6b225a6b03a652ed5e42b6d682d508543dcf819e46658710d5984a7613630ffe056de3fac05830cde20cc6be12b5409348c010a6a1b12c9dea7deb577b23d529a5fea429e716d1c0c7fe70b9d04f5d527f3b62c5e424e8d752b906fa1550ee1a8bb8e0fc6eace889cd903f75d1968f6bd8e5e6a69ba30348f296b7d6ae8f0e19998390d191233ccaad65179bbff3dd138611ecad996b2e001d57e5672bc0cba9c32618da0f5959b45b41d0899507df9899e81639149e538a096a6f2745d306cb103248191fea646a8cbba0ef7ea9b80046d2dd69357b5fa98796264c36bba96a1545335a7a532290a6feb3b39f29f4e95b82e3c065c5a7727c64f3c5ce5135f59aef73979a1d014bbeac60282d2f645cd88f4ddc6d3a4ee62ae1d5e9db5d7a356ee2d8b5863134a5a0e700f443175f76ea969363f3bf84c19472d2fa1d6a29b270a5584e5731f3ac2e530f00fcdf5ac8b55d5cf08aeb1d6f535d3444aa01bed9e2fb9ff7a888c7f5a0576119597b34576b59c7bb11b9f0a175e75fd31ee040c88fa8456aaa36d7866ad5a87ff2e9f81ddc8f639f4b7a58211f1674dc74aa536df00dc3db8d611ff8974f3d8a16a8e6af348632bc39ac9ca88426299a5d2075663bdc399d408836dd9665dc26c8b484fb3b9bcb6f24e18a28e7da143347ff795e76fd8d4a30b8e789e8506cceb18153987b88403fadfbcab00489f80fbab9f6fc30a265f0560332f339ea535e2051526ad3d27d31537b57f488f614ae788e0bb6091c9fc273324e73465d2ba6eef53663712b03bbf3a41ceecd9414d0763817ea63b5024f09b724cf5ab8d7193bdf22919577a85c380e015f4cf3e9ac3b0d83dcf7eeb81cfd3110cb6cf75d9f49fbb495bf140332715c2676e07c826fc260d8ca3968a8185bcf8f9fa6e67d656c611c09c1c83ba9a9ac79b06e8166025cbfca2299e67daf8cfe46e750436e7be1e4fea654ed8cca2b07b5674351083084d76c7fe03fa45f3a8b7a7441c41c2941c6222865b64089186c29988d0d689c4cc2bd61fc9752ed26e111caa6fa783700bea3ec685157bc18305b3ae935f282315d4a364f8fc1e06cd656901d5973cc36bb9f5088290b7de8c770f0d0117b0a52556e4010dab22794f6d7070a1adb813d2765dccdfe5d35cbd8e6da8ced63cdbf33bb72bda935bc845562f46f43cab185deaad8d852950c0fa9229b066f50699b6612a613946e47e2951a461001842f5485f2c94c7343ec599fd10ae18dc87d67708ae1077581b86b1c50576ee73e61802d764a59a1345bddb91f138e2c730f1b7ace3d59d6629eecd8e986d8d3e81cffa774c01833c81b6d22aa12a738f64fdfa8cf755259248bb3b35ec22f63d424291ba7f6477fbeae88da9ff86acc67b80266b17cc94d8072e420d29bf47bf741a1859ad5c4c4922415fff520015a61a8000554ce471e14e0f9c9c2505642f6ac9bdd2bc4a9b8526af7d619943413e18206e2233ace62804667f8a54a88bc5123cbdd1b8d1e17cff68db1cc93df1b7e575e761e8b6629e940121941d2ea381c4854465f771938f89b19fc0f37e87d2a349bea43fd19fee61ce6d4b5f5a592740dc16f240200964c803796a4bdf875ae33aec0f83b6466a2eb0d46960155503f4bdf7d6d684bda1347315e67176d3021ff0f6e47cbb8c66efca53795dc6e111dce6fc97b3af160dcf09f5a4a45452c9617ed6f2cf7b4220c38737114edc58debc5babdf0f53c68886d9746d41ebf82da2b9600045575f31b1c829aa883a440597047570676a71bca750fed3b1ef1b76e7f2683bfbe1b4432c1dd16dc1fde6451cc6e086f1233acfc5349f02a141c576d9486b6ade9052eb7909a06bd3f5869e4e98d8721c365f804b67d094d17207b1663174d6d8b65283ba016a8dc2eab94b5dcf813d61703bd86f0d68d02d59ea37b0da7b6b544dab124ed4b2992196d96a129008085f1caf97302ece2776d70801e83a20e7a63289af8162b4201f147910f02d2e11af04d36d8ae1056e009850113cf4ca78190f699e8cfdf7dae46152db355c57b2fd5a5e5012d962ab32343813560e6579b434592f940a89ed8cd4f9bcd821185f03e5b3989ffe8fefe70900a1be913dfa2d2649e31131fa1e7b5c95331e0f304291e2d9b80d3942d646d733fe48348f7dc01cff1126f8190ce0ac1a6e42ed442160a7e520068186372c186d8ac8791a180f07ac9a7ba2c5e82750dffbfa3e21a256","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
