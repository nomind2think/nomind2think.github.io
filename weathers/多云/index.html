<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1af48b9198821a287dc11d99160671b9fc2ef1142de98ae2721afe674217b5103d649b9947648e41622329a27930fe02b0f9d0dbedc2369c06ae786412de47f7cd22bee9825414b3da57bade17339b6f18e98974460877f8f7757654644c18cbda04c9606b36d992d24745e330bdef58910bd9a16ed4faa6484e1dfc3864baa284ee4ce45b24230cb4c840a727318f5a690493dea1c01b75d975e6effdfee047135a2dbaf3315b1049f75f5b309e7b4d13317c81c0538ac1202c499da95c2b6ca9d2e2ca24d7b4bf3d9aa779eaad4bf9cdefb3450611b31feaee5637c47b4a3026f14bdccc7e4b5d3fc9bbaee7256a42fd86606a5df8a7ed2efe4a1943bb0fc3288811ec7f0f7bca676e9baea06692b24f029392e5fb7ec5df828d50fe1cef22ccd4cd6d3b8b8c2904671f33948546087866b5640eacfc8dc98751fb655aa4e1670a33c024e7b40f7d3cf10727b7790fe4e446c583be64bc9f1e0ff4a1c2f0b04e557e9c3643046a2bc5e7e18a66a431a079160bce726047f176e41bde03f063260d378022462db67d2a91e6e55e56f5ac16ac615c086ac71a264cad1115babd07c3cb24278e23bbb1d053064e005a4185a2fa78f8aff91a2fd251b707ad4682b54e15dea5bb30e87bfb1dcf0ec0c827cd4d3d5aef7d1a27c63d1899d152129fc983308a4452b98d72a04a680f13b28fb488d5b8735d614f27c89e759e4a91661d0c51af5ef395b049e08a4f6c6fb890153c0ff91290ed61a84f0d203a8e7d827dd7aca357500b149a62e6c3c49c24efbd37f928de15d73f983864448f6567b062a101f6bb0d3947ee0700caa95c331cb9602680c7da703a74865bc09be4c0555f82c012d8341f7a6cd070534f72d52abd6d0386ea7af6363222d17f967fb10a50b1602c185416673d66fbf476eac1c18570160e7b12f274a4fd579690e04bdcaab37ac8c3495aabe75be5fa8345fc0fb96d80c2ebc64d916d3aa0cae42873db6e8764ba2f3277c80a060791fad9738fd889684a7042269300d1cec38ed502c31c3755e939057519f7ef8def84a35dde0950c38874d53520bc6ba0e44212d0d58f6225fd7d6ff75f668bdef50acd07674df88d57e07d7b6e241867f5214cf1e8dd9499a72802932e785b39c0fdc9521da7adf9579ffd11a2401c653762a5a5ba6a24fb42d8712f1aaeaf08bec2dd8b688e6c8529238c8aaa7c9dc93670e1b99cadb836699da2dbc1badcc889eac412d5cabec2966c0c0a83ff992c7d85fbb8cbc1036b4e9d36f5fb61910fb3b3862d6f4e7832b9714b8b7c6fb88ed1cdadfe9453b4adb8da5def2ff074b8a95fcd70b8006785c29f1157cf87e23e58c79ffb68b354f3a723a8918c9b11cebea297708b576ed7801d958e25677b9efe86e8f1a37c61a2cd9ad17790b9bc0a1025f464e3435a4b5da8f123e4e4beea94f63cad3715ead0614084f677c961705e4e1627c2dc21de99263f22d776104ee9297f53d66c70ba0c038cda459d3a5fa8f742432070f761edac027b7cabf56c1e8a5c1999eca8d347d40a076af68d20fb5a7727b9afebaea4a64368483cad7e8f593b04d98b43a064cc431b47c4f33b98620db9af7f22e9a2fb80700e7c1a415e349924c3ed17475435f7419c9f336abd0cad0c2bac95436aa29156bd9fcf177f37862198c8fe9c1436c5eb41de16199a0d10559ebbea13ec31f23aa54b4dba923b723d6368868a55eb1dc601022a3a1b05d50bca80b8637efeb124ab97717d5e76bd1b3e2ac8d72e74ea7a45e364d7d57aba4a373c93d720742cf5543ae4c107d230af4948904527a6eb2430e2cac390b7f18052842cd0df397e950aa3c3534e042c9560c192f3c1d015ab4efee3e1f4709ea2bb778c5012dfa4556f7969f170afebce6d0140476de38c407236d46c794a08527828a211710184eac5662cf20a0163b82ecc50028a9b9bc0d8af37d125e96337c4ca9b4488ee7598f7824cea3fe1125e23016e8f726ac1373e97daabb1839a51da449823a9553ed50b49e10fa048ee6c11ea23402442607215634890430f53bc4b1e85434fbb07509d60986186041be7a89688124ce4cb84f7df3544c7b9ffe2a7a10a7b23207cb76bb967c0f5b5354ab24828e5a452a00b8deb76f5a93c5bdf5625388955ecbf36053aadcf9ec7f1e026c7ae942c5f4589b75820f57efff7e749bf879eea5c32226c7fb6364202e900b5d51ecb93602b527239e53e7342c57584f0b1301aae9c2b1cb46c8b70ee51f561805eb9252430533e27f01a7a98e3977b785eff9583009114a4fa3ee2d8ffbc30597c6ef19f44bdddbbd1e84cb1e00da85389c9a5efd0ba466131e4a12d30722c6ae1f99eac131be2f6df62b671e92ff767acf12f6316b982a02d94e8e242aa4a714949a773c06b397be811af8736624d1e20384eaad0c7d053262a99d10fe00c5289a298db52c563e9523f4eac10883fea14e6f88fdd5da21144ee71fc3631cff830c2436a0bc4c59975cb3c5d2133b46d451c990b096f0ccabd32160f2764de67258488387502e65047204d61e117b80c87bc61fbbe3f1bcfff7b9a498d43fb3a7637592b675bb99b4dfb3ca3fb6a5fdb808bd70f0827ef50d63920936e4df277b5a494fdb5923f31d933e204b6ec73232a1d290b9294aced473d712a7886ff368ad96954ab68eec32023ec4b7eee04b6cb7191cd86761d1de56b708acf3e2795558bd9af4120344c7b077a1542a42f25f999595e7e528b04bd85236509628bd6f2481de70b21e8f98ffb9e1bf7c194535062806b75a9998f46931a6e8bf774b5361a2a1d5ddc214c489ebfc7562fd3f3feb97a2cfb36d09155ecb0c2c6c0ceb3b9a37da4ee59ac804cbeb6dab32aa0424dba99bddfb450dd5c85ce5b91229af174b5391daabe2e4b63d5716f913a45a5e6eff8ab5c2abc30d8ec5471bbebd006c1be68adc66556cfa500ea873c6c0ac69207f2df323a09a2d97a2b0871c6f70ad134ab4d75f426e24e458de674e64a2e8a46573d05376ef3b501018259ea3d5b2879a5b32b8646b74e98bb09756e37639431fd10ebe2f84aea35566379a9bee3533f0acd5c6c8a8e3b9b505a6505d4039fdb1c94211d46f85647766fc20c5367382e5405d48524e1cbc17d18646c50e3f65b297e3a41fe78dbb9827b7338819c9759421f8eee819b9ddf7e951aa85d44dc4b26f6bf865d92d1a9a04b218696177ffc3dae07ff466a1c2ada766c2501489fcb62593eb62f106b6946ea01955eba29b8eec124a9a42c6d1309193b1437bc937718c5b666e5b3d3827c6c9ee48f128bc8090290cec87240f77dc3ad57090b394045ec1cafe9f59fe862aef9b215ddd11c7d96df038591655d526cef00f6066301a186dccf21064b00042628702e0b8f3d1f7691e10fcc87e1090e69e6354bde94ecfe82003a106fff50f4ad164f80f2bf98b8a79ece457552f1d47a77e835fce95f8ef9f9a981b7a9a154587733e7bc2a4d4155742af53172c1b8094b462c24e7c4ffcd6171de805653807b571b48df6b177519f247ad5fbc788571da8dc55488f752abcbbd0c1cc9f3b6801fa0bd9522f8fa1ac91c997b1e1f71b1548abb12f1f2152db8444ebf46b374d06f9524fa7a056d01908bb473a78bb2efad8c4e15e71ff452d9d73923970b606d72d233d215fc9b581dc009b8e0fecdf1d902e276c9435c155b571b999d6db47192b19310f9f10f6435e3e3b9f40f871319f02d70e321b52b496de36a2b401d9068cf07e491b79020b849a516e071cabb667b3926b4c11f64c40bcfc095f99324b156da6665881a333132c9fc8afeb49f79d8f7251cb976dd45b3934c2a984768b59c88d9762698429fcff3ea8abad93c7a46c07a89b938d908cbd3700c191c7a3ec0cfef14aed7a83737a40f9ddaef5c87319b5a3ff3490034bab3758cbd022af1958e2d6081804b21d1227de55a8994d346d386981daa169a0c21047f59f1edcb09bbf2f1dfb466c2f5de848a6a59afa9b53ac4f839e78a262afa2522a57fd3eca37977dbb4b245e5f1bfcf538fe2ce1fe42b6c201f4cdf62d5a021d3075c52cfe9796ee12075b1ed171036cfd3b2a617e2739792ab03aabc8fc754c35fbce0cb3302b99a50522ec4958da4611255657ff25a5f5079f2d5bddb2c6709baa150f2d9f89678ed286e84a942398d5a7da33d7eefec18ab2d97bf10afe41d6a2f01476c88c4b977f212dae543d34c0ab2a59baf971e3ccd999950e4874a96d0d844b574ea41f6a051d2fd6492ee4b0aee506a386e248517efde6759a280582de5a38ce4f85f7f1bb3f48535f024be04a0cc2208179576b403416008094252aec84b7da2896c95465153e7cdbe6fb04c99bbef53e6d3debd723137aa041196afb72d856c9376b26c49a4a74c380e30710c8928a93a5cb51b3f83abd1a1b6c908908bcc30533d1973527ab4f90bf48e16fa7de3261eb4e4c7e24e4bfd2e32bf09219f4cc28e260263b5ba3b1a1dce239023e45f3a65f2d4412b335daf36ac2ac1fcd8ac38df596813e96176c6bbb81851a435b6969d60808b03bd9c45417219375663ee7d37942df7637b7b5070f407e5145652c1eda31be55806613b985011cf8747e0fbffc3e215f3673bceb7d0968addb0eae164a10e19f837c6557e353e4c8357858f6c71718d75f3d34633dad45c91c25be8699ea1c2513973dfef7a7f1362411112af33e0ae8cbbe005e1424de3c1d9aa3b164cc4e66797157cabd8921fb25de74f304612de8262416fc93f47e6a8bd594bfdf32486c8db4f35bb3cdd357e2350eabe16de91eaf1da2afbd2f655e63c0a68fde5fd324181fe19aa0aa85756a935085b6b970619a337ed0a6b491ab3d112f1e24dc2eeb3e437a7d6d9110f60adf142702a94ce06ae59bb4941b2f22aba821f596fd7f106d43e35c136b20727cd53b282cb0a0b91894eeb7635e2728d4f0f6694a79d90b54daaf8f1a38fcd9bf676c05e2a9afb75e9bbbc6966be5c1252f23fbe64d0810bb41290d59ef685e2221d010091d51e43d31e5a3d202235aad5555517a4278cbfcd43279ea8dfb8560f26d2933914a683bc9d7fc680e168fac92b864dcc2cd7067a10faba0c978bb9207d8b882600755657cad2a8f7f8469e4fee89367e8916a4062b49659093fad2b2951fa9b17a55974071329dab5dd16ae71a858476baa60fdcb95f3a1026c6e25e17fd425c7bf327042dad03782652452fa95c92bc89af15a776374e66bc977c92738f039402c35d4058e3db5bbb99b34b131f985015ae04363265c37917be51dbcaa48d18f1e54b67575219671ebe023c37ebcfcf67742f8560bc8984acd997159541c0902d301e68b4571b0e7ccd36ae36ecc14e4f5fc666caf4f1db4485823a095ffcdab9ffa862c9a22e6e97b6b5e32164c7799db01f5c690cdf6c51319fb4685589dc79206bf26f534559d0a12553cb647be4d7f9b1ad611fcaca904c4d02fa854e52d928c4ce1c32188f20e0c8b834d6b2387d9ca835cf3aa0fd6943ee0936d7711133d2e40b57447cfc9fc693cdd0fa4fc19570776b3c37e7022e3e2d74952a48f27cdd46231daebedc89b8179b9a54d20038a213a28ee8ce95dfcb09cd54c341240afc379050604c38846d88ee4fbc7f2bdb80a48adf0e75596704e32ca1ac2b6df5871159571498bdf412ead6db10d4c0cd16999c8d3853de53ff377e8444ee02b0347d3bc2cc14c72c79d5748eae124e76fc74ec4738f1a4fbdfae238579549715df4ebdd1cb3e1d663d62bb596dc5fa8e2d2eb2e1a0b3de5d52007eb120edcbf7d7ca67fc38d054dcaec27208b9327c3327f192530bfd6222c3efd00b89dcefc3b171e9e643fa44bd0ef7fe0268d287deba452cdd96adf5bb837c2a39d86ee59fdb852c56d52ba17175ed77c5c28860aca46c02b9d5be1766919cd364297e8462997fc683ad063cd3a2dffff71989e176babfefbcb1e7f7fcf5437e7c523baf5bfa9f0c71d48ae316f7785cd89ccbaf1bab1f1c582837112b161700d4b99ed3cc43476aa7b44694cee3c6337b33ab8195758686bfaa756b61982b14fb0e723e77365c8fccfc4f7dade7bf80aa1950ca962737d94ff9f54a98a5d35a728bf23f4775fc6270831faf4537c7f7f5f505568620223fd00739d8455ed5a2fb05600826f65ff09eafad6ff73f2bd398b308f79ae4d3306dc26dd349a8f18bb0731bed3a25224cdbc53e4a8eb0b8ff72afde7d4d161cb84c89df03ddfc3d73049502917b455321076f8d18aac7daab616241dd6415523380f2c7f461410477675618d983b129ce44fe08895917dc5aeba591d0968071ae4e8ecd9bfd9e6879a4a6771e64fd155ba1d2f810b9396e0d7eb4765ede3b5378335351740fcddad78f570bc24d7812ae563415664e4d12ad86e5b4ca59c68dc495f323d657b3ece10d2c328943a433a7c98fef6bc80df2c9de82f872f068bf062783894699939b84e6c50dc9a8d8f229b1c57d98d9ebf76a77a91dd4b7d3091be77ba51f0d48b3ca192fadb4ef0e1f433af51c61bf9b5326df7be1f92bc2f8fb94b8e0c106b3bfea4208a4edfdc6245f28e3e7b8a350185feefa6dcede1c101cc1195ef1e3117b03604c191be0204a35b736e3896d8bb09c0be201cdc66f82243b148ff805151dc072dac7171f1976b5aed0e7b6eaa116ae370f8ff80e46aa9262159159241fbbcb793286469a499533bc6079cbe014ebf24392f04880fc21b3ea3d0129daa63f878a67ce44f9c7b418108b64ef583b3958473d13eefb12c3e07ee03d137fd1e57efa24eec4bdbacb58bb322fe8c0ac071eaa024fbcc11d3e3a0c2bd1ecce251c4c02f5f58ed407e30ccfe5004af81889ccaef791f49066fb6d1066ebfc4393844ac997775f942bc0e9b1c58c1c1641bb2e424543015a8f0dcdbe63d0fcef0653414d4e5389300b2cb8450df2b73fd87537c2a5d92bbbec884c4a01cea870b55dbb78037cd4e94a593d94aac1571f0b4b25d5cdaac5686e3af708fc0ecaceba50e3fd14e879b2c09f95ddb32ec98c3625a719dcf34656e5ac8de0cbeb244418a4796dc67c0e8096c4ffedeeff0ea9d1daa75a7344d1863dcd41421f833bf3d9c1432aa7d237525933de657d63331a2bc19ee0575698452664c627dae05dd4fcc3c30e9bf5a1449c3a95c00dfcc32313490333acde12642258cf984b6baac177af68364691f4a007a1d66088bb09e6b8e9f6bf5b19e48ecb2d225e61274911be30b9eeb89af86bb739784f7706bad7ba98f11862287a1d83850d76fb5f93020a83abea95631597d63cd88bf07155b1d1a4c5d7df4986232a6a84378d1f066401dc7db0224dd1a767d0b58dae4cfd95a2f512fe78d74713da78b16a86ed1dade22d27ddb2899d5072f5ff26b67c3e938026a6dd3d15a8aa26b9be0e86facd755d0445ead990731d8e66533f4d0755d7a5abe77bcfcf34470bec82b5c746044057fde42cca48988d998de7732e35785d2f82765cfe10d560f911dbf00d4321fc2192a29252cff4e2000d9598089fad23340bcfd3221e9f54af8912083ce6b835cde9b00e8fb56c2f4424e6b6d8f8ed2e701f9ecd40579399d08f60b9b0371b181c60bd74ab012ec8270af5cfac027f36e4115fc586f01f6ae6e74af4dba97dfdd00cd54e8af5a3d96522e83e4c9da74d8649dae8d307ad9b546261a9d47fb571a0ce62aaa6df2ce78e3974ea09cf24b86cf40698bfa0f4b553394df276e58a3073417b370136c1807cca670edabc0026c56b9a6a6ff8d5c2e02dd4e8ee064bcc3de3896e8458563184e29877c767617d2d6a0f0fd6f6f6ef1e3e6213fbcbe0046a4a98506729c5d12fc6cd3441c4bf340a2ebb9b64178acb296069447fcf4cc3767ecbaf99b26c46921d074b93c6483e72c2100ec2a8e185f93767a19564a6d06cd0808b1ca466ca273b4f265c8e9f3a92227ef6f6a6be693f6426a4a2fc62c1e44f62ac5bdc81750853e89c87b41b4d1d52a90f840aa563610ba061b16380cb9ebc00a71f531821d2049dcd8d1bd418b8a60e1325246ebb688adeaf734145fe48547668335528d947d8403edab9b2c994bc4f227d26554b157945f98aa21af5e05e51e0177734f1c47a9115be0f7f2947ac94fe1bdc0d238d90114b98e675608156e0026c8d98fa186d4b6c29bb3bfff9a376b5b20b4bc398bef5e703a9c410889fbdd0440476b619b1a4a6e93370a19664ead8e1985884994b002a176cdb71e728f06b57dadb1d2eb48cbc6bdeb50f3b4e599882035c031ebef8d1b315a5e94dd83b7fc931866f30e0cdd048c850c991f309f22794068a42b8473d82d25412fddf87e677f6f4be1012442d9c001e475a02b73b1ccbcfda96316d12365fbdf7b9183e71fbd69c2d32bdfb8b8d177985f694490a0cd0b0b9e87b487cf67e52229680836200f65b4143281b7da1bf20745ecc59e9adb65734ceb709584ce010d82e4bfb5277b20fc388ec38e8f534628dce2e464e69f34b166588170792f8264d2be088966d5d448b4ffb24964b38049f9fadb077fdbbad9268c4364f94c72bc9533d9acf10efc9b87cf3e590772000c5c6a2f5275a7ef3797441aaac8e99ade764c80129f0ab23185d37f8da66446bc677632e6e52c39239303d289e29f408cf92f86355e1c8285ede5b2401cbbe54afac0f7e3277dab9e82583339ce210bd0c25590b839b797c78cbf5831edf96c2ff740219497fbbbc4729b2d794e9f262addd99165ed602574f463c116472ac62d472e7398b2ead98072fa6c13b047b242dc7cd80e85c7798f730d416566b2a077ec6c2078884a0404504acae17ec32463e989cf72987d04d0a12a7c09570144d72f23f68c9eb61994a1ae3be5d4e705db45e428f57fbd1e1fad992344c15889df07d045dae98b961ada427f7944795201a444dea72c0b631fb799edfd1974481488dee7d17f8b16f4146465d6ec29a4464c16ceb7bb77df029ceb2a0b4afce339719fcf8351e43f7d0ae2e686be90110595711f6536fe34fca217e2b5e53bbce0f869d1e48a60d0a253b8ae3f8dff1f5efe4c1fbf9d5da187e382b23cffb84d180370dac0f644bf0a7591972d72f17e0cfc3adc76ec07272c007dfec8666e7e108b8dac0a23c54577f7d7a3538d6c6b1197d516fa84e1e7a85bd4439dc1778c8c72dde2f293466689e939b1c4141dbd3ba1bc489c90d773a00ee2475a0e6977ef38c3b87ce677080e70caf62ee8af1242279688c6cee2c41866d162a909e3cc206e6129bcec3ba278c486e90dee224d12dfef0716d3fbd05f68b39bc9be73c999255adc6680764bbfb64844b777058d3ec30268e187fccaf970592b3b9e3963cf80368c78b0505791d2038efa4243340e26cf5ef8f3aaeab1bc7e2f1d3c9a2344f1d970ca1de7861ddbd1650fb79c3509a04bdffee905c0908f00c3a2f20e1a701ff21a6d67887eb18686426558d8575611bf0c695e86d0a57d2e0661c2a99586cfba2c1946db526cc65039b2e14ee59ac95a83f4da8bd93e24f1e3a9c725adce297c349779b2f92d11093344d81c7be1217e838ad4f0545b26df5b4f8ca699634c107dcfb502a5953a4b213c2cf92eccdb3c884ee35fb2b0c4f2a116870cd71b32dea2b566262ecd3a85d0521041762d0d1263c830ac140a7c7e01c9b2ab2b778d44f93bf11a36b7cfa0118ffefead36ebdcfb2db753ab720b05190020ae59c620df30656f9ee09dcd0f26dde94bda17e124c98b726ce54e4a0e4024e8d61a408a7fa158b0cc083b885d739ea9f0389c43e080d5bfb0b5cea072761f977faad4743aee52e3d8f47392dfab280337ee8d879dc4782afeda3413d7cf14de0b049d3e41568b1d89f054ddf9e0efdc93116f00e5c189ae49dfb647d37b8295d43e3f17a21d211f0e3093155caf1b2268650ecfd64a212a45d2734148605e62ac1ff28a5f4f156d1fa9cca12d1d8868edb21ce52d057ffd7e0f067b1ea3a57ccb42d9f72c262904cf85808bb6394c92bc3d12f3ce9d3328f9b9a8dec7effec17ea0322b1535860553359927cb1f65533e5453ba1c5561e9123dd0270cfba3aadb007829494787c92340bf314c990f28441379c2de4e12b5ea217bb780bd40b03cc7f1313634c3dd5b5425d21355164630bbe736d44ea6f9ebb96959b43d25129295e61ab284d710d9f77a7ebff6ab9f143f5fd80343aaef8a2136dfdbe1c16d0b51bc2a9a3dce6d623850c490903d7d08e8d292aaf62ee35a03a74b1d74bcb8090ea723abbf29ccb08c1f47d5426f20dab53d85d01312ccfe73470944cd4101fa95da538984e1318aeb468ed723993cf4373ca4696218e74f00e33798d3029637787210a478cf850edbb331842b0f987d50d2c2b8908bce70bab1cc00270c00bfd1f610b9da0219933e1c4c75b382ff4ca93fceb826db7447761cd3c0016026dcc0878312f5e51300c3a2a24bda89f90bf0ff9fda9ef13bd80dc83738f34c133fbdd92a4533756a8ed289ae236fe9008f74e8009b14b6a7584d28eb5e7fcd5db5569d1ce428553dc90dc7eab0e9793823cb0efab66f8e2872c6b60c329f44436bf47a1195a067dd47cb477900298ae0955020bf2629eceb066ceaff31467e47a73f37f9df23c4422671854db1e2a13adf376d5c7738f6020c81a243577ec76d93869afbc961fe97c94d2d32b74db66c3de6483f12acb0432f056b405c022dc5115850be158aa5d070ac3fc20dd141437199a44db7492f86105747a024b495e54d7f0cd76b0d85e9f052b290e8453474949fcc6f233f06c4f7ee8c9759a679e826262e1f91da8919951b316e40ba6d318a69ad600d7a5ca4ed063bc99136e2e42ec0c6b6c29561d7ef288f6bfe0438773c69e9916aad7dd2838854766ea5311bad20ba727b89934dc5c94efb2aa4d39a61a198db9ce064e05caa2f6590a0313b194bda53bb6b55ea96612121ba1e51e113796f16717ef5eac2527a8752c9953280c5734f0345e9b300f482b411f3431aebc0993d76a41bdaf9f0b0fa2467366c444201383df0e4106cfb928bea636cbd18ec4515a6c0030c9c2a6a9f5c717276b78f602f8ff869619b3b574643a69dc39802ecfd85a71febce970eeecdea14ad78b3f12897c42bafd6c2fbe7cdbf1371dfcb572670f1c60f6bcc4741fc6f81bf1c7a8222e1ceafe4b12fb59850aa177129e97c557faec1a56689d8460ee29fb7e2344ed0ba0311ee1277282b708b7ac0a553b6c1dc8a71afaec676ebec7b0d6f60e009938cec22421c78ace394dc2131b95dc43ed0b8a860306c111f2602a22467b3b872a5d44317b7d1f1f4dba0d038682fda72966ee4d7db2847a3270bfefec68593eda33c7429bcf20299a4e1f94cb90be9f511ed91ef5018fe6dbce60ffa08a3950da3ae8c04dbbde28e9d9b6d85cd5c55ef028ea019746ee54abc107ee382466a22c083900a82ec3e3ef01bb778b41dc487c5c39625800bc2f6bf5962c96b395470b369eb384a3503bd0218654d245750263a0c31345e86dbe641f3140044116f3df958acde3c73bc8f2d111f3cfc7ac5cca7cf6b82289f2cd534a55103ec29049b27a2c954b6b0fed9f00bb46db37b44adab106bbc51acedc83cafc6d21244c87f9388ec338dbde24c9b69276d344da5ade3042253e902677211e48e5c9ca441b0d1e88899a9fa6bcaa5412170b6ddbf6ece3528846e79a2cf87d447125914bce5a000caa21f78091dfbc526606fccc56b29c154103d8500b5bbd8f324f096b444ddaa734f676e396a0d5914969f4a5e27902b19c9f5dce12009fb79ba3652906018ff54cadda3d565876f7475f0164480138742c9841c3e8e1f6b0f5b4a96b0867321ca586bc83b78955dd2bf520a4e7031efb4b92d59137f9b2502e634682e94ce815f7cf3f83c72cf1f0f676b5efaa9b175530fc07b7d14000b4fae9db0f364a0a6dd64c3deb0e6a959fb6ae0136737f7fc62cad5a9ea201319a6d108952f5830b231d6ba77c26134e367555bf24ecaecaa690a62443d24f99920e9d66305a43248f84ff19a3309feaba10edd90ce45eb7eaf8509da1c29d2bea110d727c245d0920a2b486592e14b4f8493f2f314e9dc8943e75cb5639700af6e0d3b2c967e4717ec531af8f345e341513c5eed611578a7dc95feeef095f0773c3a8aad83fdc4028d4f9f7f83e796b1c932ec6a28211fd9936b28d98cb0b28bdb6ef39cff19228e7cc3dff0520c6495f68d773f069bc0d2075c6e3966cd298684772e6bae82fc872827ec5027aaf9c1e4b995250e0c0cf35e670bdf4d02526a5cf0c5a65267c9c0096b25b243419c95bc28eb05d32257856ce0e8ac3327ad81d7dbffa5c5ca26f488a9e51685e33d7a5b6c18426dcce93c056eeca1b03383e1f73e4c318a7036e0cafdb9a8736c01d8516fbb2715240d430917b5e5416d077a769b42a570b0a8d4ad64b272d1fc7fb877e0a6907d1569c538f38e263a97a3599d02f60cd2b0edbd5c318c32cb5169ea97c4968bc8b3473498d16f859e1081a3817b0112f04b36fef0eefa46746fe71671e4a0acdcab2e6cd5131a7f8e436edecd7a50325e2b390fb2f8d99e255128e8e4ada979949cc2f8dd25981f77c2ea991afef2aeebf25e55e4cd7ef1ca73fc179e523c8ce3d0abc0d609e6b048ab633cb300defc38985be7a2eb47d3f1ab4a456e38bb5f08c147c4ad750f70f2d86686a869454e215a38ab8c58c348ceb0b6c7104f936abbcd54b404c8d5081e96365518d3c4c315ac88983d962315f8e221269dd2b4a9b2d729d1725198f0af7f78ea012816ba940f4d425cdd49b295057bbd6a448a460bb84e15d0e4f6499ede3368ca4415f49d62a4386049d1bf78139efff8d5935e07fdbba4d7499d361cfdfb6b14e0930a4da14555639e51f817853fd3b44627589d0c735014210660d2019760ad5ec1c7b29272df9aa87f36b98e81eb0818567558967e2cce52af577fd5433a44224abe98da4e4d6d6891c5474f6e6552992abfdb0405da044d9bcae8d6b2e4891d9927cb30877b57b62731dc43de41f4610c74767a982245e700ef447b3fd9e3a3b27ef8580a8b6106851239a44a62a46315939f2a9c38c04ee2657c1fb0eb53809dfd8d6f818c06942d736a6422bc1ac4ec7521581169fee8c20212674fec860ae6009eb1d431571e54d95347b36e47b0d152e795869be47a370d34b8ebb16fbfb4e723e57493db3fa5197c35547e882b5331c8dae3ffeb84a22ec21108f6c64d8352521fe88a0d20340242209df5ab0bb42bf23872fadabff3a15caf961454fa492643def2748921453827858c8fa33f2f25d51287e0655c5270d3ec622c91ee847305fd0c371db74d399f7dd2de74bb9455014d38e61cd58609c9294739b65220d9788a245a8e9030f34a7b17c41bf1adb2d406fa27eb6f6b0a1f28b5852d37cd9d92b652f918f34789d06c3d4b5b1c8abed07bcbdb34bf4a545bf00caadfbdbbcad3b3e158afe708731c9b38c375cd4630e8f318124d403436e6b0dfeb9ebada9ec19c7d7151935b524caa14f3ee46cf2883d436f3e4af89b3c1847f5c9e866de9b26135806784e8e1beb51f062bf5259dbf83eb5c874eb36d7b51a5813fef694de4aa99895796d98c4fedd7f71ae65db7314ba2c317e5eb55b97a057e4ea6976aa2709a2a912c62fcf5720f927fcf9efb1ed81ba71fa713a47fd06d9f8d3629ba4cef95677e0e752d74cd1b8a7266f80ec63dea31f4307a4e673607b5f8fdf9fbb3b398ec4a8e8addcb4e7a0ab2316791bde684becf2614e7ce40555a0ceb013ad41a353c7cdf4d7ed66a5401eb6b5d1ddb4576cbc4f888b4dc2173e9daeb6b1e3548aafa39dba084e7fba01514eaf7f449a35c0c898673b9f6c5d7f54239fa05407193fe1107d75a024d580a6e843d187fc024c35522fcd54cd71b374a22c801dbaf21653666016d72248060b90d2557a243b69289ffa35ffee034ed7a4718826fd8fea8ba3e8c766663581b3f8b5e5ee009f1d568203291d53a0141d7c5aacafe1a8b5b6af6c58666e4af6cf25ac3f218e1c9af4966d7b5c2c7fc12d41d7e58f3c474b52adb261fee20ff1595e732c29c2c01798f46b96b8a135f25a461077c60afe087b26ede8506b72a5fc34ff69b435bfd89d8e3053f6af501ca4c1c930ea62eb3685530394c981f5c284e39ad4996c0c8cb21d4e73eb6d71c85bb77cf8efefbfe43425934d94eede6031d99a207e9b7c046dc33a8819b503d3ba541259786809223568ebfd2dcd8e888cc12d314786f262b0b93275d879810cf0b45dab88592de1dbb744ad695f2b98b068173b4cc8f3b871eb46c3dc5b5c03eec3c9d68cb374a3553507b4b6fb4d66f6660181d3197585d7f9027008384a505151cfc4a17035dc45c8f51f6006562fec6a7a4c530e17aac066625cf4fbfaf55720dc0c6ae1106c05a74bdc854f570d49210ffb846518b956263633d495641c6f9e1aff45bdab012110e437698122f4b8f67edaba18335bb169f11df242fb83fb1b731d20d3205ef8051f584a792f94337192a9f2f9ee34fb6a9f4af2582f9848be1a07e0cbeeb14c3d6e5362acc8bdd6e04dd5a747e9de7a1d704faef0c0bfde9f4c4ea083c6d80b842766f59d8df2efc73b9ab1b0f15e186bd6dd5a5f174b494a566cbd35d588c21e5def2598909a3d08a9d0c80f37ef8b6f8f2c1513e271c3d4eaad1fee2b2567bf28f5c1aa19e4d00e5c25a290ac966d512c14b643a8d7a7199683e0dd2cec7af8de97b17cb9300881dd69ab70504dda10d4399dc9025d85e11c8d764d20be759ceeb160cc390260fabb2e43606b84b087bb47dbe1c2b424c9970967ea5f03b6440fa5d8f1dc1c0727cfca91dd3f3a884302823ae90da94c504705a751605095ef80fc21ceccd1eb47aafe029e0ffcad361c1af0fe3391f25e37e0824605ada435be2e2fb97eea82908f44138fb77208674fd1ac5f61ad589c0e65c6f35fb461bbe95ef75fd472ae55884bdf2a9d3301f1fe661a71b5f36edfa0ec0882c9a344d77d80975fcb83af10c74d01e42e16692a261407efc5b748b90c1370b1b0c7576fb4534cc8d3122a396fe61387c0d529fd77a63e6dc1f0a02d1aa1444eb927cb25e0fd28d6f3f728aedad5ff66812df18c5e43a1bdcbd25f33dba798b7e01f66299f12f4b5d79a7ad83fe7ad0b42579a1c4ad072c9b0f37a2d9a52876ace06207c2a4a6b7b8a371f90efdb3f468f5c2c664794236cc62dffbb0afe029ba223db5e81fbec2ff2958e15c1f676b0ed75cc24a6d12191e509a8d8d2282fa4f8592598e0f540ef82e11e359add63a6dd2f65cf28165166d43ecf1366eba0d6b3b1d95bd2197104cd291ca151c8f916f1866fb4641615a3aeeaa5481759eb5fa500a1447a35001260ebf8e34ca02f32c374d761f688fc829463cea0b12be72bfa1bc13549fdb6d8baca503d9e321d3e115192e91762379d01b2b84f7c7cce7e96fd4359faa96d00670195a542f7d2c2967f8a09668baef15132108971acff51e22ed5d7535bbba939929339321e52cd2e5ce82ca0e6456993593ad524552aa2963e0f2d318a8ca65c00854d4a6fc79bac47da251b8a941c13999170a3c0745fde06d4d8a3400a8029d7ec3c45efff4ff42a9eaaac8cf93527736191e78aab4873b5b5c096e7ad0c3aa25c296d1d7c8bdd6b841c5d9e08286f4857a6bcdcff7fa5b37029cf34df1104c00ec4bbeaa8646400b175afa7dcc2ed6838ecb3ecfbb166fccea7f6cea5c70c326aca7f3de3126b62b5a1beba9ca0ebdcf5537aec9190d5be517bb0858f0da74674906a61ebedc46871c20a140d0146d515a9d9f935ebf2e4f832ee2fbd3470b8204cf388630d6a786255c76f26089fefe89323865a4b7316596e0327aa19dcc77087196a1fa266301dea9406a15c27effcd28ec1f209348890c18cadd8a3a9e2f0b6b81df22e3c8fc22479e8e9a428e40068a57fd2f9ad0f24fe9f72004b56d020ce6a0415c1d26769c9d37c511697b42fa77c3c36d8d240b557a4c1b23b9f82633415b290cec1062b89870e4ee03c99dd2a74bcf93a0a48a8de0535b96c4090cd859695a579a87b7fe4bf89b59b3a9b1f7bb3e30794ce6741b9f27f03147933fac83a7d11984b1c01343241e98b6085fc4732062faf547ad9d913b660d8ee4d72570c310f39629a2d5f948fdd4fa369fb7e42c813959032fa168862fc268fd3bce972458c70d1d1c108cb257abe8106115e6f61daa8c8fb8369b9407ac41a42f365e6f91a551d21533663e1619692ac1d52fa272992bbf819a7180a6b68957dbc95e89232e2fc8f94483b2d7846f18b0cac77cc68e1fd4e240e886ffdf7729b7c8f5e35bf5ae348e476af629fc92f8823cd050094d2260f66de0859cac060845786a208d18ce614557173e8188f7ae8246be917687377d7df3b9a45c64e29659ad890894ff0a3f1dbba9b5775af888cdeb6574baeb02dd66e21c97125a6872c373e3de8359af6f6411f79badf60b3e27d43ae22262b409bc5453b9092f82d6a8d8ac4cbf741470ea9b6860585040481129abda281c64346e62b6977e8f00be954a3ce494e1534c0e6b2930f426306340d0a52d11a4314f64438e8e10557a398eb46a074d00859ce171be017dcb3f74abe30e3ecd89a15375ec9b844b26632c8ddd00999ce976238110d098d2d4f3cff69df69efc46d3f78ae0d14a6874134114acb497a74080a89323d30ec641c8a2679e9c3a0586203ae61473ebb854b5c5b4b628d080d1ddd7b5792810e70f969b98c5e357e9b71da236d51b035e9096c07f1b865e43df50756bbc6c9d1ef6eec07cb92e65e8d472f8343e3ef550608453105425a709e7d9ae112e24ad531e26a818a6e446beb20626979de43a354b68726ea4c377689dbf6be81ff345baf868bf006c7353587b7571f01bd1dfaa3dd85461c7d33401ea614d2024bd7237904c4ae13e1a7b2c7929c206c0261f109d4a31fb97c90255edcb9dc78e6dec13bc9707663bce6d1d98c8fe52ac973a1206369f845166277257fd4a7a02e606201b620dd1d56f231e93e4368349454fea19bcabc74bb97d280f895e12d278756f987558ff5bb20b23866ddd94350287aaa0c17e7b0f35a05453b472eccd3700ea85d84541d5502bb185a184be13bfbe729890773464fb6f947e11e1997f6d64f6bf85122b6d106a29f49141545c4e5870588682a3057d06cfd137958f3dbf842c35967b462ce247acc5202ef997a5e41cb8c2a8ab93c1c9a43b5a717b2a41b3452c2b2e25d20dec08fe6672c6536e8b121745dafe32ce5ac0589e789a8c2adeae00b6b88999f5f7946f9a82d2d33a69ee48fd763be008d0b7158dbf101c54e4236442ae401188dea96cedf776df46e4f6db297c8ffd57804dd8d6bcfc4647f55a38b2c78d1c0016f9472cbad430c0cf30dc45507b7e5f713b13a1ff07661bcc91d7b7f5a8b7e9ec5d7c0e59149c8779bae9948842d319b9bb946916b344183a4d39b27a10edabbecfa09384b784d546750b519c115acbaa1833edb82396352639cee96de2a02323582f6b0daaedafc3dfda86884e2932aaef0bdc18107e30a8c55d18367e79d379f6bc09ceb3c39625799682c2500176d1ff67df7f1ee7a8b51c2917f2af849ab98f681c1c0be3ab36166d613055b0f3c8a3cce849b92fe49cb9c4dd0c61f441771cac38915d3158de2a08f7f68cae86ca39bcecd868d797ea6a559ff61cc8c40022084a7cb61fb6d777f6780f4fb613a96d08ce402eb0db721c5eef3b83754e1f5e3c68103d76c27fcf5d8338e9d0f82bd62c9af73d65c93ee3232186787f99b2f9bd86542a56643acc4e93a1191393ddb5ef3e57e744c4068abad1429e535dc2ec7d25b844242feecb4341e2bcf12845a084c2c4961fc01dd57a388265597e4c4efcf454d0e41a60483671f5243b42cae0a28498ae2b1c8873c496f025016e25d37268ba415a2f8528d2eb5bb4ae3addaa2f041888fc307b603f098969dab95b9e70d0256b52f18a313e6ec40881d11e4d16285791ba522","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
