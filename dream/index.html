<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee3570f69913474670b7033d5f457c07bb06652038df1b65ba32330a93433fb2edb55d06257575dc1d33e92bbbd68917aeec47f677dbc07a8d78fcd6c7efd49acb82abea27c0692104435541ec15b1ab19ab732e75119e724c3185b41ca5ace74c382289fe34da1a3ccbf79a106c15e3b0a072508d25b43959d5a89679357867fd5de4cca6a810fb924fab2bda500af4904a22c471300fc4f9ca919cb962ab17865f23e2a3628d654d1e9361c4e254821ffe21453e4c47530d45887c20c354645c111c44b3457baa40dafc3f486f478baf062e672cc77146fe1218a19b1b171928cc385e825a56fa77ad9d25e8de65e6a7f77b4914148a72f56bacfae4f154815ea41944201c9820b068c47fc4a3cd9fc51db897ad56748149c73c37a9957e9ad8c5380db19c822744ac01dc9a35a6ffd39c1b0427fffd65016feb774b626f5c4fa44caa3183eb6c32ff28debefd3319f5d90e5e6a038ebfe5e463f117174a6d1fe39ff7044675db305f58c67a4ba68b5858c7c8c35298650308150722dc91098f3004529fe5d7e2cee8acb74b8054a2d9202e03f01c9795859f3274d4882c212e57a5c7a00db27a6f1c2f8c26cc8aff65dc801daf33cee972e9d4420a303dfe5b7fd78cb9ccf2779d8902fa1a5ff9c4cf64c4f80a47c1216c771c9ee5c3b868034bc183412fe12f6c6d9b1d6114420d71894fa65aef3044b77a717ac211cd69b54db8d92cfbd82b20595320bcf33b6468e63b7114495542df7289e4c5656123cd7d9cb252b886115f33adea9402a561f30eb3d51b9af5f34f09312eb746352d39a143f4587fb23a0873e3ea7cb047f270e3ddcbbf9652d42ec3d570ba0f105f7cea64870e52131c217fa775401d69d0edf4d15cb2711be08b8e1245c5a9a50592510609152b5d23311f22cf06f7e26fed3c31e24c3c832bfddd814e66a23495520073d8c1b89f61ae6f3ef6ad0617973592417f1cfdb5f2f43086198c3529b37d4f62b9ca2eff636895497ed1c535ce75aa0a4c7d8f6c02b2d28e4aa5a960fb84f1a658281bd372a4a1b675fdcfd69d1811ab29f85429c3c87434c8190488262f922ee3b92b823040412a2b5995230a9aac6c0138fcd88539ce8bd47f479069afe932aa9bf8dcfce81998a34134cfe568d2d7d147a67408e0f5c1331dfdd70280ece255520f9fcaaa3b4351a8b996970e09326bce03b8173c59e383d041e173d98e0e66580272d347261a9b3225c82fce1272b14dad3981f0198286ce518b87ec3e971729e585ad163d39cc18975f8e0bcdc79507f21d182558a82f65b72b84400403e4b0488f33ecdd30298f10415a36e18a254b493ada3e83d6d9f6b96f3a08a14201003dccde0711981aa5c2de51d8862564a5f596ea115682ac6e5dde227f47f833c416471969510a7ee826523adf173f9ed6e0af81e75d792a96a0155637db38e0597ec3647ac7f01b06df96e0a7a33c053e91f9f1bf61cb69a8e67c41d2fc32a0bfbca1c79e6ed3d8efb984575cff2cde3d98d30b32a588aea9727b3a8a48fbc37283c54bdbabb18da9dc0a4cb957f995931b9dab3e407d327018a9d9ec2f609e4a91e17225f6350376c47b80a03154646f45143edd783da04517aebcb7bc35bd71e50b11cdb40079ee89f4d6be374bf091ea5cf86a5750572fe0996c5f33c7f95ad601f9ec3ef069faf35839a34dc4e00fd3b1272217e1f6a2d1acdb23a01c1d7f3d05806029ce4ffa588add40f7fdb318bba745aacc2e36bfcee0ca76e1807b03462b3ab84900f045e8356efbd7dd88193ea70a4530ef2431b1cc46d172a909e89143713182c06cce4312b86e9ead26570ee7b8aefb130ae27208f30cb36f81125720b1173193176e9df74cfb3a642ac6270068cb59e7a9797da7a7a505aa7a184cb50b6fc23a0fe877d82a38cf0b88f1d2824322fd8fcd5c73066503a1705daba0d133c8dfe896dd4ec40241ea0ef1e82c143f9a9861b937b4b9cfaf758a4bf75805faa9780c5275407238feefd39a05837f9ac0a8306748f295385c3210d6e8fd8331cdd8a26152944cc75514cb9730dada68da5e86eb923ebec9d5f53bca2dcf829c48a803c6e1be0a51ead9103554208a5715a86f05cd81dbdbb8ef8c42cefffee37fb21bb2bba88abb6598076ce640117f5cf9b8697ec681334eab2fb29229ad9853c0d7e56db442a4446a284d686d9631b96113effec345ce235b9fe7f7717e95a8b9506e0c61be0067d5e88f7290c44da96b6ca52c6db7ca146c779e35aa65d6d44ee11d2212c861462ee781c97d56c954a118ebab1efa99104d2e66a11a453e162eb68393b9b3efc2ef5d61fa4db51a0ff1538ffa369e826592c3a7939daa0c3a6257f7bcbc217c600c9f9e539d6ca9606792a37de8a5b3a4114a1fc0db6a73160225d401b2eb8fd048512dd49648507fc8ac91f628c3343f38ca584cfa2e56b1884619ae6ca5f8f7161b0ba0b57970fdb6f8f9f5a65f7d5956e6186898a87044fc16e5a4a3f0886ceb137395b509d2e06b61fa9297dd6588c593b4f8e5a7c58a25d795473433b6eb3d9923ba0a49e76ffaf6793d734a3a3c9dc684f84aeff4b748e530973a7f72cd0fb181edcfa0ffc39b9560e32ad2ac253cca5afdb99108dd3ab4ee36f72d3c5a2fee4adde14887561e1103397bf6e9d0f178f2b359e1915def1443db1439af58bb2cc8005a839a051c55d97bbbc7c0275359945f21eca4dc7f04381cb517eeb247b8cd14121e351559c42128b29da0cf4b5b2f31456b5634ad9da2b9cd365050a691eb9327e709ae16e0fa560358956b1bc29d37c2575d2edb171f29b53e047c38d671b5e26d821478f95f49e5c187e374686bc6d70a61f49cbfa4940e31954422bb0f15d418804c43fed72b4c1a07d8e6778a727682390cd1163f9766727a696eeba34fc2c2a324734ddd0dc9029008e6b706427f4b6b2b796fd334654587a0d8ddfe6ab58227040bd7999c930015c86c3e8b11da7dc9b189b767cc8bc15ff3ce2df9faa3357060e2dbd39596e4c2cb78c610f97c3c646cde2571ae20823f0f8501cf488f915a09ac816b7e318c5a3ee7479340882cb095fc2d138fc424b2238688bd022f9ba27321461b2ea51508330bcd41bddf1a2b49fb9cfa3721a7cf25bc714f2a0c29e528bcc69800ffc7b9bd7489876179b31c0a70bacc5e95837fa6476f550d6f6616c6470d905a4594b2bf8ee63da68026901ce79a1b7562e28987ce91e77b70fca9ad1a54afad16e2ffa161a56f051141e343b6183cf892e715b7736fa806aa2dcadc53541b87f5d58fe0259deaf9709efea6d0da2e694a4aaace8e316389895d46e4d3c1bf71680af05716371be480fa9b0ea744c3e325d825bf0edb234097023e4823076ed3fd5d244910cd4f1e22b0f954a7da40290808b196e588465dec52ccfd10ad4f9e34786e313d5e2c194b510ab602adcedb4076845b18de74949e94da4e3d93b981b187c0b8aa14f03d77bbae124ab66d20b1e5ae24585490ed04fabcc000810f864685c1bf1c31abd84f2f7b21fe604b542b4a7d2b49620f837250c57a80cf0d5585717dc8753b7f2cecca35687630ac6885e76379d9095158df194aea08e8e1db732ef37ae8be00a2985fbee1433a6985e02eb46b512c0155e34b5cbeeb5a033c03dec055a0eb25a683550f92696e8537d188abff343e3a045141fe24e93fb733fc4c7e4da793056f46b12fdfbf6fff1965cf91c370b129eb3636f34870d7617938bacdf060135d0ee66ecce812d265d59d912862137ed6db753f54ca7f584db148c151346e28474dc664ef98b4fd9f355aad5ed1ae9876b7e11b4dbfce3a0dcb189b3862f83350e2ec163d53de28409d557dd2f6a4090982068ddece7702e5520684c50ccf383567524bb78977f83cc08e7a11f981f883af0ee29181b3e0eea091339c43a3833099659acf662527d6084e2db53321e54a9865046a4f06899b140831b9a7dcd8e4f2a16b53067e43212e1ce282cd6d50e8bc08e46ad3a1c198cac4bad1956e97fab296a983487f472b823b6c19c4af1cf3adc7b6c3e3d2c63378e381f93f78409c1740af3eb19ad1ed17771d896662304cff9e49383537dfb3fed6ebf76a89fa1d532d2a30b5e44db24e0772136e1f4b64ce1eaa3ae094cbd23ff1531c97a67a46f3b9eb01d63ceb9d754ba2bd4d8e1dc0458922fbcb667a58ca35838461e27e6bf8d3c704b54b147e6c6040b68856200b316a08a6428cfa2b86ca31a988c0fb86d2f1b16c67a51b870373b60e69a9eb0bc7d12d530776edcb84a42561bf58f0decbea7530ff9e58fb1c77366aa83fa694d3a3c720b381058646fe9df3a2d83ba5277aa942d546930358e6660a04db5a1a9638936874027d5617faebe75b5f0bb887ee75f44c2617cd9a7d2999eb2ab6452f6cd445d07cf001791f0447a89b0ed2a24f8f472aa793c12e4baa21cb7ba191540efe6d9a8c09b0cb7154bf541f922e3cf3db5591166defba5adf8640c10811b5c70d7578249115e7afb8bdca2c4d893f5257e882ca943c4b03ca6fb1e47469520d7bfbeae6c444808d9f14608c781f79d3cf81f5176793be1b02a0c9e086fb8df90e8e849b707aa7f9d40d40844e49077f1315f66ac8d72885dfaf5fd84b4df46301dbb9520832c1a1e52110bb4efe1446b87354dafee9316600b09ce19939c036343db65e78c2c7fe28590f65f432e49b2b3094398b0b86cc327b1af300582e1ea72f24f9466bb71fc58afecfeacdd8915f038ca1633ed853bff7e87c8fbb9e69963b2bc521f231a2e335bbe34339d6f169e7e324cebcaad33047a96e13fb99924b64ad4d832ec04ace1c4ba76b7a716f682e6aeee79eecdc8bf104f019c7af13f60fe03bb81f2540b5b37c789717eea47358984336d336882a3265198ed2a83665f20f7e404c4ac177252dfd27f18aea6129eb838b6c408d8835fbe4daf9b4feffaa7646d734d5a6e85285480272bce4b8ce7375217eab6b12e36590d64329a8f492910bfeb578f73980f1a1202df62f3f5dd25cbb9854fdd624b2d959c9c5beb786854e52bab18042b259a11bc6a3436b1207b3ef0fa4f43686689e916a6a9f0a613de5fe284e357f83d72304467a123233783e34c04efc020a71e2e29aa557a36835cfd6ed96f6e36526aeed286065a73a4c9de9f218fe5e41bf3742e9fdad9ea45f30928c0cba425ec366ad62ba812ead307da27991f2c96486b539729f4772fb95305c77951e95060d1f6e4b255e0f7ec6bb24dcf0393c6db4e8dfafefe423be220711020352df3c3c3ede27df01e8621dbf65052ee3582108a2d2265a1da4d2d46e6a1a92b98159860873914aa6981f599c892a9edf7f5d5a176a31b0695a9f33664528a8a9d0c34d49b535a13485ac3a1942a3edfe19e9f871ff0020cb703e80979963a4b20e23c6c873946eb99df265046b2c7e1714a36c30235037e72c7c7346073ba641414d0d83e26b03c818f78efd1cc320431b151689afc479aeba702c2fc01b30165dff5ec29be3a6e5d39d62cfca9c5f430830d5e73ca7c1db97053738bcf2a27cc17fa01ee2424f79e5351f0d8ede8fd12a6a2c6cdea5671855d19be97ae2b5ad92a2c62a03b455cbf89926be83dfb0a7962536aa365c7ad776ac957638d60e71da4c95967d5f955d453f9c397dc3ea5e33156699775582deb4d4c8d22377cd5acde302478d9424ab0e533bcf288c7c87665018c9b4cd1d03b8aaf1d57c2f679e6e7b77f1a18877342408751d7a72e0eb00913361f2956252f36ee3291ce08758288699a69a3459518b13afbcea09bbc0a35c5481d8e0aeb3a1dc90e80bd6704f40d15bb5fe13c39df58656e5e8e39193275cdb3936840786610495379b4621f31ad69af2a40743cc03c873ae14a6a7c19657438588b5f6c03a50120436f15c6f81124b025f9411385007edbc8a92096b5b105d9303e21619efe04a97410e64a768fedc27301407cee3fa47eaf02c9bcabfc96de3d56fd1f4bc381a134df7c7502d361a38405d89671f27de7c808c2371a6b49cda006be7eb26af97f8429cc381e8b26e76c25854374ed3822010af4b2cda5c773199d77b03367b429ae6add0c65f63dee18c609e69d73b9121766c0fd27d84fe252bedf363677a5fca30949d032b9b3a859aaadc619aba1eeddf099e26a479c94733d3e5ee40293ed95bed8fcaa93f634399f2663d08e070b4224444671bf9c7e7790a3a901e6fdc925e7974a693d6957c3d184ddfa5d7135979468039ebc8acf48e67341bfb720a19a49ee6a9453b8c5e603920d11e887e3fdd562aca09dc93965b9f9d03aa3cab20893ff513e952b00d311d55528b39ec3b20c9da0fef620984a08b7c531928792ea0280dfc663ad593eaae65936048181839beb18858e084b8734e4fcab42afbc31cb96d30e9e2840be428284e8cdbc1f956ef2bb4f21654efa8edd17dfdb744cdd9364e4fb68e252f4a6e04ab51eee6d01e4e04fd7bb33d433a6d1bc1c3f1e53baad3c8715501ca1e69a231afd809d7a14bc64d9a035f37dd40df03cfa98611f8af725c46b8ba5a9ed88a12879b5e8067ca642d50ce210060fbc80f1fa96a01cead8963df967636268d299d6f391b1e2f202dacd213c888b0de55a58741ad7e83b52a46645ca754e69e8233a6ee18eaf04c6b08c651b226f12cfd17d9956d0b314886bfd5858ed57558a97593bb151dcfb2448d0facc08110719661beff4e8d42e7be422e89cf2afefa1a6580ae3e766a8c7c9fcda32567b5a8f5c60ff5ac5af127470a1383b7a7ae2e376def9a35b7d9a10fbddd957e187975245bbff2064f0a56756338f3bc34a7536df0ae2a78a67fa3ed74aa4ffd8dc4a3289c1728de219594a4bf2b3be13379b3e719d6a248eade566f88521e122b5332a1f673ec5ee49638dbc226bb253a3af5350719feb97bb1923eed0446259ad1da9519b5cdafea99d8dd737f36120c563717affb04827bebb463853cab95ccf283c05a287314f3dfe4446f99365f3aa8c27b570b6f5f723d33802b24812752abf9ca15a24aac86fa17b10ffe879f77424a70adcaf641df40aefe9ed5b01f22d470228c7b0bb18bdcd3190d6b16e046caadedfcd08cacea05af09e33643369f99d707deaa67fe521a9e40b8693a2fce1d0ccac6299dca899e996250473a1b636858d6be6451af78c122db19fa3182bfaa8a64bf9a163c8bd83d80880e456d1cd3f7979b7e5c784f84db9d2f00eea69f25f1302099472b93e20fd95bf522da32d29b7c1d2a1d4a54be015a32c4fe2fd118aa9f5626a09646cedd6129600b9a420176f9b1e859c2925adcd9df2029203f991d885bb9b3b015b711a61309f228643d9e1ba168cb00877e45f3e59b761c1be5e1a960b49babdb722baa444104141c78bce3ad6a37d613c1f57652079e94e60a59717f12d7de92a5d1d1c1082edf42f4bcadc3ed8af871654df87af86924c4496f0e59b20b286618328d7713ad92bfd838a698430219824933dee210c401401d9efca2ab416f52d58af7cd24794c8812037dc55b67415866e744d71147ce5b01ba857a758786b4b0c04e32b8a9c1bafadfd5ee643d6700cab256558b614214a3620308444d14c82cf59efa27751d27b6f591b9dcd269b5e687ad8952057a7cf1dddcc5cfc94c37dcc4834a283db2ad2737125072db55cd2fbb3924fa59a930224f36ae8d28a81dff611d972acdca79fb7740a11175400887b92539bb50b5990fb81d926427643ce441d9325e8452790c57657b38b49d9a97b30aafeb6bbb7a0e60ed074432072ed57d0d0d73543703f95e7707dc3d5cbd00d9d69ffccb71ed34addf327d9173fa3514bfbe8a99ee96c17dd8f96f48fdbba4faaf722fa7d45b0eb46da5e5a2c5260b19d80cf64f0bc466e5cd1fa640be9259690eff071be83025b0732560c0ea5866ca497920ab5cee57e7f6e73072fbd2a68cfbc1d4b148aae58ef7ad1ba8387f7cda8102e930bc6cd79ec786fdbc2d28c7dbc6fb7b0ac2b46a6cb171a5dca075367c99f92e784d6535cd6bb26af513ce98fb671a70441e84222f7492ca8bb9c5ba59bf75cf9a0e728190850bae0d7ce66ed6b6ea8273621b41651b5412a1e6c22f075c117001fa296feb9977ff3ed49965646e2100929eece77859501f87f76f8e015f297083b97d989cdf64eb0439259585102332b6a4145555e8d34afdce6123ce77efae0c3e884704b5a7f209b0263bdbaee527081b6ae5cc50c3e1b46dc3653ba8b276b035e39e2de7d0030528d157da98fe101b71e3b285f1bd3bb8bf2748f0c77f70b7b27f5b9c08ab61de2c3eda86b3ef5e9a41289a850222f02245dc6d95a42f8c88f6eeb141dbec8f34406c026167fc276b5df5c92813baf91a28a404ce500d7dda3ac70fa6429bd33f714b51c75906999e23f47ef99fd1aaf8120f91b0c727d104a14250c97e5178a68793eceeac1a00ef5fd1e7c4e729dd66d2bf6c073cf66e3a13706d1f8cc108f6602130dd352f30b876413c51a9ef34a601ccebd420834be484f84cf2a03eb72188abbc103d983f7f27bfad701c1e87f46fd5ddad6c7671ffb7995ad6c983533b6b65812ca045a60e97067c2bea37bde23af83cc3c498c2a25c07b30f327e2d12eeb32e856bde494e6489aa318e94de6635491373439cd9167ae4193cfd75ac6133579c0682e8c76171eaf8ca6d2981fd244a30ec022d60be7a408251d2def78841bc93b7b55fc1a3fa345eb76697f4c90f893f267c1f1e875dcebac98cbdd9389322ce2664c89c8881ed1c23cf5f58b4632c16925e730450a5f9bb85f3a591ea1dbf21abaa447c29b9f806ff546178fd4c742fd40199807a45a933fb0b147a357d92fdb02815945b3649e305559d6ee98fa3703478c03cd920d36c1d587b7c3d051cd412f5fe2ee76769cd8167758e1b4d419b9e11eefc5521a599d0d9c22ad2ad05bcc6bc9535d2f278e1d87ad185eb05e36eb59b5404643b51f679ac9e542b61d09952c6fcf323c2e8c7682712994aa179c4ab4eb3ebffaddaf173351a70c6fa8b284f5b440d720bf0e48413fb39b8194253a1fd5b05ac2848d963b9b90844611cdf3bb4462071028abdfe268ab51cc4f25224d0610c7f447b49d61a7db34b483f91140abf749a28c328026fc6679567921cdb6db1b72f94351d4e15d51be555fa5e233dc3466811a0d4c375a4afb7aa1de0acfcdbc9c3085babfb4f98a28c650511a6fa9e8032ea83d6427de337588ce1a2cf630c5b5f807c5dc638f16b16589593905de44c85b3f5e4e1f22768fdb5bf5b759df74fa4f1630b9ad8fbca9cc03b1d57e1d247f3d6e311c47c0b8d382e14f978ad3d27c6a0edd580cbdd230586ba6c46eed91a1073cf9b853ba0854815ff04071c545b60fcd18a1fcd6c7cce2a809e06c2a77715aa322f0750396b924c196481b8a2710940384fd03ea03487a7f1dcc339002d0ff5c2c48d90701bcea5c0e303e430e6e9079a1d026b4d22e4977aff1edfcb7dfe4f8dcaa27211072d6eb9943dde8efd3ff87d0c6b48ffd5b21ac67fc39759212beeb1bbfc88a9cc3d16e3eb4e71851ba6a9a0933a672ca8aee3b57fa66fb442758ba18360fe381b86a68ca55c19442f21c992ee9b872fa60a12c4b95bcbef9501a86495da15ff4da4ff5bd501b36bcc4da2b2f483745b270b93fd19945a77f41e5eded6a1debe44d23a4121abadef9464b6f85b471b99a0226a1d3ce6ef3a9a53d42f5a28dc0f89d3aa553583295c58011ea9b022fb314f2a81ebc2a82f62292be3e7289eca62d0514d3c074bddd038de3b3d29f473de39aeda24cbbc241c2a3a193bf61a75d0715c70ca39f9e8dad4a68b42d5feae3bd3ab1fbd686f11cf4214d24880637439186d0103cdfb5febab104f59f19263b8bb3e6887bdeaf5297d93d71f102724fc08cdf1025cf0f1ca90fe58e055bc818bff3d01a9a6937a1e0ff35944ef77d9dcec3b20646f55c8f43072e21859ce6089adee3dc77d1a61a26197aaaa6aa723b18344e614461fc196ff9f4130e89885360b40c2b03b9a803c8ee5c088b628495ce0fbf5e72b70b36076bf72a924a57ab1e36b920a6e5eaeeb39ca8dccef4b3310ca1cb32e1cd43299ba1bf6d3209c61ae0e3d82be119d6f4e071044d186cd235332ddbe3d3d68971c305e73494876ba340d1899b5c18e61d242e5a85512a7563bb16b18fc0435da596e4cc34744b54018a257bd31263a8ce1bd39d088286436a5a0fe65c6d11706bb3c2804b8a12e1f16ba988a37627fe1af712a1c734c9cfa6eef8b609b0b47f2baf07bdcee453c865b994188c1a4ad5b49721066f18f9c235b4726b55fa220e02a2177cfb678491447e9a3f52755c761748f48d188a595a7b4763862381c3b424a5d7df4b4f20d62ef443b31fe60c0a21c1baa51eb2c97c74862859d8b48b5cdd6ba799c279e5939f749be499dd44f16be49778df19fa36b2509df5391aa00efff8c4a2586fdda0c282d76181f1f39c50dd9fcfc87adad85b9ab3ad6767dc4a3215ea56383870b4b5094c8ac96f12d1ef9a76d3659b79a7233cdb595d008a4f9f923f230f7d7a72272a921ebc1327671120552d5d22e0d27d964f3afed129770a8264505442a150811e90ed97423b5ef744437de8fbd864196f9b2a19c4c4ac47c9d998949f274115463024d76e3d03a1e0bd6d95486869621777b10bb46736a5a83b42a52a06a8552035c168ec7b2f55f902eff79578c426cfbbfb82d351d23d7a20dbbaf8a3d92bfc46b663990a6373bce37e4f81e4ed51cb683d8a9b1201fd1d132ebc63253483642edf54f775aa46519c187d136ce2122cbc51862c9a957d3a9ce9feee1797756043a4defc1565679dc0c6f467168d015fb70216b491dc6caaf9fde9fcca3faed67e15ce0a94134398f59a7c88b775629ab5a296db9e54b9510a1fb07a9329c17491bb880a7d5459d5183d39fea369df24b96897b3cbd87f832b851","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
