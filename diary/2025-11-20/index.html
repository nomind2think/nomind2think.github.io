<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42d51df160121800201524e5506bc6753fc731421b4a16db7765529044bd25c89b70c26518643312b5e775ef56c51dc2352ae987b41a43a42bba586f1553126fa38bd47276cd2bd31aff1afc341db10d93b6a4e1e48541a82e4f726c1afa2c756c01acbd302b1aaa4ccceb00a0731b33ea9a241e12e82d7e57746554997e30876a2bf8dc646e30e4b7a9956a80c89eb9e26eff77ef59a8f27c6d9880f9d66118a240d37d067cb6607581479ce3106506d5deba731750f6ef3d338f710a099ad0555e580d88d7a197bce751c80a2ca8218405de118a96b154e5d7daeb3185a4c070925542eb298ff162ff1253a5ce14745dd59f1c7d8af31c8237d25a773f1daba5c84f517269b20a9219c25835ffcd7ba6d2cfe495323b573016ed061679dff17778f5def4e3ba09c7f70933eccac680136820d4d3423dd0c5c6e96ed89af142d2f761ff06710b0447ed7f73abc4b40720e8d24e79ab1cf67dbea7ec93cd408010d7ca679c3e3827b17fc9fd59fe6d1238d208bd8ae63676d168cdd30ea11545855693fe337918f3043d3b4be040309e27465e4b6f1303292e263902bd0974e539d6274988a9a6847952c0b999e6cdf0003c4b8f3cf6f8cc0aea025e606dd61f48578b14d9e3fdaf99ba2f83dbcf6859675f0126b2a585513969f352177a8ad5f5e64489e58d5b30c31ac355c7650c8d1dfe6e3a6bea15f99a1fc49d0d9d7a6978ccc6fdf1acab175fe9faab6eaa5524c0758d248eaf244de232e80023b524ea4001700c5f1c5e19800f5671996a46f27cc638afd5d709941166bc87cf85ca0e488d7af8ecfd7dfd05fa84b6c824d660b4536dda33e8a4732ceef8ee911e015d28b4aeb47b107988b5cde4d5c66990f40658eca1501eacb35ae60c52fff6ddc775e9f509f9d166ae523dcb3736b3caa6632a09618881832a5453ac78392c6146ef90023cdbe06c2a21068b8725cf7d6d382c82057c2759f505eb36385da72f19d9cdfa86201aa6b3e4eaa9d184efd668d54b826ad989ec290aa0d1d3f0540ed7fa6c93cd3ed5e5b5652a4bb0e90c8e568bc6b8192b13c24256ddc5b7b03a674bdf94b6782cc08b83d8241f1a1645ad4f9a6de35d3bc574728571acabaa9b10b3aef7e0caa5e50d6768bf1ebcc47f3122636f946e5cdd04578bb5800b72b6ccc986bee3b782e648a30d13ffd9c1d20950957d361f23f181560d0e532399186c7a8b02bab69881ffda04c69ad158f94a5d6387c4876e0a308fe3124dd8f5dbc99945f932b1b000a9675e77fd9a7de408043b8be672198b227478934fddd2f10d891c54b6262a88193256344e7dd7482b20d20cd0b61b3a83c0b6392a7f553de30a6032cc5677ee3c62c1b58cd27974843bdb7c40923e9848f3fc52bba2d1d7dea229efc6d80a9ac2acf758f33d64a6f72711c3b5637d90f5109a97617982a4b921da56d6524844449ff3395d2b2a0ef41d08903b5498974c2aa1cd823399c9fc9ac89edcf7c227f7ac5ba068f06076087245fc49fbbbbd89a59fd20e3df67e17766ad347feccc6f8c26106b3c10e63b25f9e745549035a679651605b9560974cbba0ce33e5d4bf1bf3a6cbfee1f36fb187c9ef2a0154abf89baa4ba60ce37c7988cc7c89fa6673f82337e56581658cdb1bb94bdfb74ce8c2115479b75ef390b4be9d25bd0662c8b941ade005a6fe3188db7f60bd842c9797f4be171f6bc81697afb3503753dc127dcedd2a7c5d74373d801d70bf48202cdab4cda6367603ba9076d706a590ced89c6cc1113e2ed1d44313f7cf5b2cd756f0bc6c0c3716fe197852514e9f570b28b5215406db966e1a88063affb28162dec7174c33e4d0d9f33aaf685fd800007a5721ce828a68334100c1fcff57640657b0564e07ea9e7c720e37cb95e8f77bc366e1f875feae65efbc669142b4424e5866859642de9954e7eb62c50a3dea609fc922e4942b8a92ffa6099ad733fc82149aa949c86f0715f69adf70beeb96e2589a341cc177289c0985012167887437ba21fd0e4ac832afe63bb0bc519975294321fb46f74db42dcb5c604d630961a7d4adb3e3a59031737b2e4557b887ac1f8f5feaaa41394549d195549d413ee97020208434ef6cb32f9c9a3f0a944dc6d0448ac5d9c530cb2bd91c4a43c871baab770e4b827450bbf76125a516c82354726e79fee3eb9a4d850ae99ac41a0aa9eca43156c0888a82fcb231030e1b04a1b06ad4b5367afb7404a7cc4ca509f4e1639cfb68b551db0fa12e9cf34bb834c15e3108b42600fc59f7b3cb6895a445169fcc2d78c8a5d012707347b2b7da8bfd3c52b081d11a9aaa96aeffbe73006ede3df37eeb5d01e1cd25ccc011f56ad168cd67402ecc1c98e98202b77fb4a5fa24933d979ad7995a14aafd6f3375c8e1242bbc0abdffe6f36181298967f04acfaa666eea5c7df41ac3ed44d5909b49b02183a4ded9a708a0a5723fffef34d81d659a5de08db012e5c0ab210dc50bb9c51dc1d7113ef2563872e325343047057e5aa5e9870ab5156a121f2f96adaa31863079616a8daf8f17261c42d2410155a78f255e53cfccc4e53f225a233171310922289915def158c303a8ae61e489ab916f8ba1d81f85ab623b2f6492461f96057c531e6ed8852fc71014370ce7743a18e4112a5a9bae9f45c0dc2401725a6bb96b3f5ebb4c26d8b42f3d04b2c1c3ba123c7835191dd64ba49380e8a60c3d4cf453c610d650012188f5ddc2891185245b197396e861be31b7e91cdc0d3d28d8a03256631eb785e322cf7b99277b07683aef07facead411bed414cc7065c274af25a0a52c9eb49fe26ae71046c0497af090ec1fffb32fc2ae74db4b3ca5a1d679ae36560272df74e618b3cb2d2f4b45246316a3c668d85f402d200377da07a7851a09c0ee6e64bf3ccba675080fcfc5db094d1d492760311220b5fd101d90906b450fa961e1c06d9aa701ba97f7030d5df23b01e35aa029a77b1abf87b90f4b5bffa56b1e858fb8c410c0a4cadbbde80d1939afc4c8a3d268d79394e704cf96d074468c97f884cbebfbf17891205a672310ed03b3bec6287bad530303d4a48ecc95029ddf2a9eed35ee7d6131f34a59300cb86da12ad701eda0dd3daf070f39ed328d20b0e3174e9cb7d0ffaca1684fb07fa46c1e0f540b7f3dd4b2a46130d82a5353b1dfcc81cbe2c3acda151ac066c4152d4abf25e034903a15662c262da8415ac8ee92f8c8a6c535cbf916b47a9ed7a6f0097ce45065cd9eb7db3768cc85cef53e91641bc0f0b3200643d8fa40943831acf8400585603b188adcf7e8e42538977adf118918bfa79c2af7c4c82b3facd3bb3176e9a59604dd7605aa7cce5eea04252ae99cbcd88064b93e4f1b2c8171c2ec244ac7e677d2b26cc9681433b20c47951d14d5980fdad2c4538e94cbdec18c1fd91b3723ff23f42f553995ced1606e8b0e8e688642d1e4d989c11230549436c3547201cd1a13dbfb27d0ca57b43a1c5fbce78569208a64497b49616d953934b65edf6114b6a55f86114891a26168f79c2f8b4b12b008a62e465e2c756798003b8f737b86cf7ee2b58f37c28b48fc9e0abdb5f7c61508e9646b010b07074d5dd29f5d82af21f331d8937e549eaffead9985a83f480c44b52ba84dab2ea7e02fe6d4c990ab088efd46b650de0d440701b651245a8241e06dc1ad4f01fda1c762ba1d9cb8364a1cd8f687bf20483b43d73d4581f48399ffe3c9b2441d5ba3d16512737163e81e544c89e0f5f9d33476d2627376273c2d9e988d7801e1d523f094078463c12a121615e36abbb14955b1dcee3abf0b7732a0d02099d9e66907893a3fc26d5d3c1d060fa487855f5f27c7987888cb40340ba9426e418d4544c358ccdcbc95a8ee19a79bacf30cfe16e22b9bad3ab87c01f3f80eb901e161afb3dd2643bcfb31f732200660afa4edd4e2997a8d47dd92401e140a89edfbbb24611575f0d9ed0db336896573643b4faab1669aa6586b66353c2dc17651ea41ce62be37ccaedacbfb71a24323b359739d0c5825afb40e11f136d65b9a84c78040c22c32120434d64016e1c4feb6cee651445055af43ce571b580ee2c49c0453ec5c2a7ed78186d4224470db10008ea52c11f91299cf9224dc5cfeec28c4915b863937e2f070dc2e2c2fe4bb3391a4badfbe38c0c9f7c587d20aada850a4603cf53fb02cd61cb808f8f45971fdfa9659ab457d591ad7ffe685c84d5608a18cd3ad97691d22ff987f64ade52742b1484e69903df7ac315703bf42687b3732e7a2cf0566757c58ecb4c96b9374076d775ab0cd8fc9b5e984b394d1a8fe02533deaefc7366db5f4e3db0ca2e37bfdac51528558470478a4188dc992780405563182306300a9dfb6ff6c8e705b42a3cc9a7095264c5922a7e99cb37edd3d512aabb28d001412acc63804b3e761fbeebbd0fdebb4b05cee585772f7fd3c1de8c29c6e97519bd65eb243b80eed0e57eadb4acf9de9d264ed4c21c3b30be8eba0b3b5f3181801b1c73e73aaa4d42711411fcfffe81df686fcc48dafacbc31f50604bbd3cf363bdbd37d0c9531e6455619024a61d78be2cc987ea3fbd7f9acaf3b3cdfe4cf89411136924c48f81a8346e1c2ba6c32103cea15f118842a28b2a6d79d072278063a9b7ac3e41dcbb255c2becd70d8bba10130aef9a5058c93949fb257407daf15ac5fdc48779416ba3cf1d93ecefe3ab111b009fc103477bdbdcca87ad0ccef4bd7af520ec26ee14efd68dcb5cbe85f56fbdf9e85a47f85f19b9fb9fcd3a86cc221f41c25d74bf2f8462eb4a955f0267d7cc157b634d3c902423f0dc0ed240439af78cbd19ea43ba3d667d2f6980e5c255a9760d7aaa57ba84cc3e64b8e0819123b8f715f95f05a7730ce0009611991fa2e8773b97cd18382732bd51484023da8add1add4f814dd893f0d000c154461769dcb2afe64f3079988d4121b47df31e66ec3696abbbdebd9a8570be02b8f64e0f4fb137f0015802c16d83f95dcfafa688e370f43f6bb38684fa99b9f14dedc1c0d85b7afea0c43edafdf22e5538510a4e14d3494a7aaef24b567d1215c43bc9ba9f3721a71dae2590322d17206ffba27578cbeb5c511c2f12b08f6794e3fe9171328c7240953e92c40b1845d990c90de3fead175947e5dcf23e344b058b319cf5ed9b7b5b526690e0bc9e8c96127aa904798db3400de0d34a7d1a83282a074892bafab5249b328154ac81dae3b95df699563d4811e1303c67d814516fb69a2ffa37cc8ba956321c038cdb5452c3ba98d4b93268693f619a5c4c83ed76c285dc601c5a4d7514e5eb3707bd5fc3d7efdb6d0f07cd499468adc0cc2375dfe90b6da6ecf80cbfdeb13b086f284f14f715d9861368cefae8994eb529c0d8ebb40d4fa65201f78d669bc7c1223f4703491c0dfa547d68eb26955bf1d8fa10565bc32c15559a9a3e449f4166fbf6c94e013257fc2e5ffa75eba93e7fec6ddfd83205ec36d9a7f695086b8635641e00182b0f5030368ae11690ccfad9abcbf568b6143a4dbc5879fcb865bc61a573727bb0efa41a81009cb253ec009c225171c59e3c46e43d4fb546978d87fe72638f5e50e7e24f1e319d2944eeb7927b0496938b7869611dc5f2f56bbf9800f245c1c83ee9ec81076b98e2e406d9589220c1c8e8ae78a8b60f9b2b4b4a7a3733c5e77c8a8528319ad5a44b25df710ea1ad37dfdac66918be47854cbf72cf435015b75b575bbb7d9ba547d3c3a154654ab2bca7407a41bbddb42972a5a4828ea423534629203035dc75d9ec12315728bdce31fd18064303c50a40a82496d367d9b7acc84a769485e1f7083c08311b2d1a5b41ddab4935c505e676075c47ce33658c51471c58517b4d480e9f5db94039792d1ddea6e68bd30ec507963b55e5f8f48d8641c27d3b01fcb3226bcb02dba3ed17bc107d4140b55095e02bea3fca26bf885483ef264a60dd3705688f95d40542e6dbc394c99b078214f75deca2834d3a0fd3e393732c1f22887a4c10cb9cb303fc5fc814a4b7e322f65fdabba54b78426ca6af327c24fa9fc635f5e03d239c3b5c452fa1ab5ae1da2870a263648e43621630e13ce28552f0cfc983f4c92d26658274b2743a95b1809a2ebab35b39b00c6c5eb2c272c9e2ed700a9c0524227bd1734352942be2cf15f0e57363bc61225e9a4ceba2224b8f5c3475d3b6e4d0108532e1fa48312be42ab7c48a6cc5f87c7074e5b21761d0eb0359f5b16966a1e01a5d5bb6722e7256f88addb648a07994eac77c724e3f17aba8f6947500405ca1d007f292b379de45fed8c92b1e61c87fd5bab71c85505c5a228227e2675741dd812ae42fa3ec41de330e1409113f920f8082898a104009f25d89a93b8bd1ec439400845d8c5862b1fa0ec4db3cca076c5213af76a2035d03da5ea096f5aeeb7c55c50dddc2d2f089605452b4cf2e21b74e8b0b5550bd94f6a82910c3f276fde45749b15c7283464587cabc842a88a3930a0e4578c0fa6d52a0d6fc88db61cf15790a9b92d37ce94b5d89041d98f9011acfc38c6ed2bd05049244f8a787076a6ea6f79897e665a3b23a0d3faffc51648af89da66b2405a27bc65aab0417c4ca15acb0f8ec2324d6d6c1773276683ef7331f92e75e5c574a6d56ef8d18e91ff4e0c687f3d52bae94e2dc832003cd16e4532afe3a7f5af0261475966a9f65f7ced5c4c146d85f59a3d25bd7b0ffdfc3394cf3afd28b62f39ffeac6521159abd9697e091f3789013bd8443312bb677165733dd5247720cb18c348c85b40108941a15b9cc970c3a4b7aeb6d670ead1a4592c3d5efe41c32025439d61da7e41baf36c0eb995211d5ae141217725574c2ebc48f73f75a73212af4747a511bc99d17512c8b67e2c664020e0b6b1665b216bfced418f43cc6d8b3c7c188201cdfe4155beff44c953c51982dc0f4243f4590252f566dd85ad6c3e66c34c6f7ddbdeccb13ad0f558c0ed1aa0fb3a6d9ee35d0f748c23ccc2f208fdf2aa3aa2ab715742645bf9c3a066e6336b3de9b456581457c950f731d619a91385efeef3a2de54a057b15fb9b120ecb94d077df5cb7684c4c13b59c32d76a71be6bffaf127e742179f45ca463d428726b06e865ce311217f0480b8c92cfc9fed85878b82b542cb071e6cae2a8cf81de04cdac778d8b74e2ffd75907d84546d6138105a8e3b43f701bacc479deaa9119ff93e16b5b6ff935234702c1725307f9af01c632270f9658ec7ba8b9692f68f01729f447fdb2582f74f0196f95753a597e4c362434f0ceaa4b937e7ee1d85577e11da1ebefc6091c9214d13773ac5bcfeaa84c720705ec796610d1812322025eac69194ed9889f64d231f5a64ece44917debe3eee2cb93b975c3ea65fb77e8e28ba0cfac28a3d24cbe8a797fcff6d48b9a6e647d477a4318a7ed43683ddeecc9456905466ced771575287adce5013c0a7ef54b4976fc864e26685f9a232e56a903ab1d979f24e28530a3a7aa6250e2971114550a5db3c3285fbdb0f95518688ac5a3141b9cb7b576ac85274f8895d92c2c4d4f54143a26c13285e048bfd280f5db1c3d2a7b305f701e56438fedf8fe9f487ceda5c8bd1d982776473c9ab49934dbcc617e2609a71da30cf12b86f88b0dd1afe86d3b392164a7b59e8fb95c2210ca81c8575da3199732058645d7d878836c5dafc0d50b366a98213fbe2c047d254c722b3bfffb345db68de1652ca3303381e719277f646ef2b770891efd3020a7035fd92fe5ae7bd4d5af818553b30f2848d764be9e9726cb4a7002f0df2f7aa61cb994dfd90b0833c53cde35b402425180f11dc0dfd024cd81237f6ded119724664e64abf5a7b7f0009f347d5b221de93304f86fcad568d4303c5d318237d528f37cbb230e15e7e9e09e0c7139f765d6d8cc15498f5923d02e33c25c02607081de772ebd69d6609bd3058b9ca104d6aeffe686f03aa19ec63104d77670dcabefaf766892bfb5d92b864eb18f9527392c3e0cb20c62cdef3f157affcfb667c004c464d277f680b3e2a726e89b2fc1cf5825a7846f21d22f9eb2731742260b90513ef23d2597c13cbf98bd156cd6c3d5e8da306a24985b77a80dea876a3fabc6a106d78ca7fc40fe224c4ed8e842a516b860817151be1d4a59231a8d963a0f6f22e7aa40f9fc8f83764a0349ea3b5478a080d4ad430384e3838764f9cd5a8f87901ddfed1682b1c74197df6e3ca633ab5c159f09c01ec1e7d23a0cf2ee95d8e33b1af0f9dde01b85ddbf88513ed4a10ae3b8b62d69c642629f09757d71f7e92f35a3a1045c703d9741267efb34f1aa8045802518a61f112d95214e56fc620a5627f86f86e25ab9f3a486b8ac042881b8f7e9af6c6f17c771f20f669b495ccf76833af61bd588e3221dcf46365294be2deb3925f360754adbdf46811ab95588074efdf718916c011fc650b21884dd6f4281575ddd30afc1bcbc43b8f1ff2785f7efbf7f6181b124b0b4234736f4e324ebce4661e81b6a60c6bd06df52a617db8e355e5e51b9cedd7ae4983e71641b94c3e84a2a32def7d799d0309f234156698dbc2cfe5756e0ff91f3e3b9065dd5084fde8e6bd7fd369fff5339bc261c34b8eb28ee262399561df145d683eb13dc5574cfde8c1b8bf426e6264c3dec5ef95b0682452946b13abad80518ab2a99504f2ac82470c48bec7343e5d5f911d94e334f3787af016723588c196d7e0e597e885b3cb622c94985e1e183ef5cb384b3f393d8282d617d6e01dbd8fe6a04e5c072633c76b5a0cacfccff26c272375b9936df018833c6d99140b80e77554d3513b89df34f6be0d7f94a4b9e7242c7adb0123ec87b874d9e2263114746b1f5e556d507ba0bff6edb8593c480f7aa79b5a4e3018c1bba1377ab77e65950bed9c20c1094e79417fc2b0438d44b2e90669de5589ce7f2279c9bd68ffc5204416296190321d1d4c31f65c95b6fd90b3497e8a7385ba61bc49196941065d1de459c4b9108dbe75672c031b41baa340f4de428b5a0bfe90a4f25c028443b0521f0f9002703a24b96c10460b22fb46d9563bb655f2453da6e6b2897c0311e97719926df0e72358078bed38607afffe42d32acfa64a9c33bdc9f292acaf975e526cd995f78fff1d6b3ad3db87ad0f39109ad476354d0c1dd900e4052a37c9247f34e40962278ddad75fcad8bd612002a6175ff6ebf39ed107f22099fc1be597584314f8fe7087caacd627dd96a2d202da958fdea8482a9fa9fffd6fc4e7ebf826cf9a5393d6aa127c605dcbae10faff33a30366c8c8b60fc29bda5b308f4959ac87ee9d86ff859dc79989f2596127a85a6da6729e8412c824e83c3552dcae774a2930c8cf35ccad1645d6b3113ce1dccc0b8d8f2f0f6bed85245df72dadf6a47387394a163e8bb98f4565f1fce18d3baf8a4491769eaaef84a548354795edaed14dd63ae47c772b5d25364e35f9291a8296b58189e40cb1a279ec814b86fc8e8ff83ebf649d9b6e8220ecf0ccec8d49d51d3f2aff04dfd85fb7a4b03f44d356b1149352d910025ed89022df7447877dc355eb02185de76c4f4b9c2cad22d44f88bd329d12690fe00368f2886fdffb273257043e32ec23aae816be13e06c5f443e055ba2c760ed51e6b5480c7a8b61c6506dd7fba1daafdd0cd2af6fcd99152d278964d37657d65c179bbd4fcb1b8c31a364200a78a38a17be2b2596995005234e6b43944b445d1bbb1b7553306fbc5a35d684df66e2153dcb8935a03626ffb7d3ed96f29973a02f3401d79c7c57cb39643a8a9e821578649a3df0d42a8542bf6be91eb84eb406542fb68441e8b33038c792b0113616ecc47808a783a2ad7cef9812b8e322f80409a8f93088976e8c49dc93a8ff5aa4334d34eebed21d7b97e1c4f168416d92cac34713b4f91ce37ef3d8982387812ae07ff884198f240240edaabb817d8129ca6d59aa6a16d36fe616fb91d764ba587a4518e337dffd6c7c672de393faf0281014049433c43d453f8ae49fac31fb382b1c5e4ee1626d414c21536fd709a64deaaf4f252a1cbfeb66515ec8834c94866c9aac7f99aa4e76e6e13ad949ee023039127efdb0695b30a8db5c3d0b4e87a6115b7c8298173939f0f4f0037e3f546ebf2529516e42f40151314b33aa5a2f2b6a616e08c64b08d664f99b5a20d3bd73546f4ae22e93dd5df38b3fbfa91a6addbc57c1c0326c094c712b9e33c9f401ca710771975766ec8c001c8c9a42f84ff89a21a44384daffac5c685eca7dd9b15fbd8b759f7275a1771a52e07370ece85b11d3d060dd4aa02e3e628f249841dffe72ab90ef20a13795069161cf2ffe05c5c4da2d5a50018d4449da24404ddb58ff4fe507ca0c6da4e354fd6bca899a8eeeed2cc384de023cf59825b3d4066cb30111da91a489e2d9a04df733d81288ca6a878b47eacf8d2ecf96426b100489bb23faaf9aa27b6640315ea6f974e8e4a3507ed84ed35161fdf74f21f20e0d1c9a69b1cf64d184ccbdd7cee3fc4cd806d67d0952dcfb6c8165e6292ae4029b839ba7e9fbf78ebd3b7b611950c343a3c687982b8f6f77119b44cea655244a41b19772e4ac58273231405caa084b8b83e42fcddd7cd9dd1aaf73e797335155dd8a30a0bdacd33a6dbb0b3f74e485419c0e996204d9c77d1d24c82c2869d023557db3a78704bb06857835911d1a925fd3559e390fefc2492cfb96e00edc91de9447a22700627b6f995fcbc8c4f63519b424e04c86e122d444f861e140100849ed706c10f074a64573ae2efd48bcb23ed4dd35819654ec8bf2a4edd25dc98ef25cccbb31462cbb497dc88a2085a8a2fc0f7d938a32ef4b3deb78cbc43e178da1d5f19fa3e3247b1e0baacbef177b23f742c0d7f6bb56327f6aa6d360bf3a58cae23e307b1c4c526210d9292feded3f7500b13b0e6f7a57a08a5123f952156cc73c97c0e5e12b8a43b047917cbbcd8edd3dd5dd52a85811566ea8f58cb6ddcc79d8176099f4b88f8e2d5d474ba54fdd03a14b3de30f4b11069461bd3e6127c06a70dfa97f1f858b5218dfc2bf178a65bfbf58814a624f98287ad09f4deb4a73e4b71da1cd4173a6900899695c0928678ad8dff228bdd951fb5cc216549182bd989d609cba0c6b0450a415e22058eb0ba4f6217928ea325ac061fcff87f9ce83911d7b98b15eaf539c87d41a6476c526c75ff252027235e7019e2b194f43029aadf632c7bf2678142d7a10781b5ef0534e87e6de1348169621ea16982110f754fad538f7d4ba49568a4fa8eec6dc31655023fa17b8bf1511a9fd1aca258109410e2368eff57f50e33429a29522e3cfbdc44ca0afc3b49db2b6f3d749e0764888bfa2c4304ddb7b750617e568b1d6ae210060bf741067ea725680aff2200bb0862456a32711fc73b883e69275ef487935c01ce4d430212c175a15a19d6aee8357f02cfb61d92b66b6e15c191d4b92300d27f9cbcd13a152daed9420c0708ce6986ef940b52eb6279d10ab5c34576ef2972155e3994d7c821991c92727835f3ee5e4281d07e8c106de78be1e7cf8c164497ac3eef54aad62b0c0dd0e9065a227ff1f4e46b7b31725d93ac0a02dd458cb15c095f3c45a408aadb6c015013a6d399ccee560bb283ace509cf4811027b13e0cddfab1fc50a4799a76e51802a49c8edef2f9ef44ba04fd5ca24f1fcd211e3212ea6aae47e62453458851c4db7c90eca24a28cd6d53fa8aa4c9eb7cfa727b925e23776d5af2d15c25d5939d9364e9c134933e6757b32204b0346bed90f6fb217ac9d969280ac673e8360dc69450d0eabdebd40cb5a8f6bed8d2eaa4c5123816afc8d61d5edd45ae98a5d616eb8ecdc802f442c1346685503dc1fe344fc07fe83e806744b6bdf80bc951c337e962fdc854582d5c436699c0609897212e32323a432caa18e5b670430eb9d55a2f02278133b366f8537255acf2ec8b78fc7d052a68444ad5663a123b94fad67fd8c6c338f9e189824b0dce7fd05dbdaf2b68b45d71e8da1249abe78ebcf00936c0271537731e184f426c015d3662a297caf8ad55dc0d3c8cd3ab721fc970a23020101f1a0058ebeb44f7969b21786adabf444a737784ddb262c37906b956cb68871c2753e42bebad66838fab1c98ebdde1c8c1705e1ec6bf118eff24ee6dbe87cd8302929f8a0fd007c137c2719461a155885706d1967cc280a2ed5c7c43cbb5f638b97894a6a6daa6727685cc7adeafe2edc153993bddd803047b4f464aee30f1a085402b3a6e2d0b8367bf59bf519180ed8fdb81938d28a39a8be5fbef7a5072401816667881a91b50530785aeb69c9ac5864d77d7d9810f8a4f90d74a48cb06c7b52b599a51a64d82b30de118b772c168b8e6b85504b505df23040284662463fc8ef52783561b3c9581e386007f0b1bda0b12ce15356bd408b90fd2bebe70862b29ed40c640cf847754d8565532cc638ef82a3d6e774ed43d53d0cbca9baeb2602fc7424fe1583157852644f21959b1a0fe97afdbb05dc619cc3e74f40ca96ed446bc3709ea69f0ab728defcafe932e37ea07fee2ae705bf20d8ebbb82a41096a0cc3bce6dd49b8298fa2bcde9037552b0fed5916b0d60db299d84bc66f7cd0a4f2c66b6dfcf377d2096517ed645602a4db12dfc51b6fe53266deaa598fed52575b358f9d5c2d3b5eab264371d6ac7f24748de7c4e0482c3342021de8a29b212cfef98aaed8946a74805cd918f021fa9ead3a558eeebdfc803117e662eee6fec070c9eef52c92c43315ffe7a070592a29bd025df8be2096f29edfa4b8ce47f4f97fdc258c195cc4e642df6f7e2c3b397c6fb1497928db7bb209f47433e09dfd5a9b4ed0ce81b5a6171f23bcdcf13bd0b4824aa3f21e0c2da9a0422751a5b13c4401efb55ae8be41387227b8d6c8ba1550da010e7c3c2258d47b8204237d32093c61ff4fc6d45fe3b594e4daaf291997f1ee3a5bd33e691ab97668067f9a400a2b1623a077a1ae3db0888ce29e6acbf15d9e6eda7d8f5299526b6a74168edd343c26019673b380752514650c1edb7c45b970fe8ea71beed67eaffea37de73e88ba9c700669830ef8a5c307dd52f6800df03d3ff0c7483d2b64e6e9b52d8fa2a461fd11fa75165bfc161fe877fea82ec0a559322b72e4725a17f9f4bb5d7be3d4333f6c76916b5d0e140adce17edda180c98a98d04f4f585a52fef52ec534adfed83f4a906716bd1212a9457dd528684ab6eb310474455209c8ba600fe09147ed490aefaae7cd0ec75ee2005cedec2fe70b37435fb3a7c4977287da6cc31055e54153f5db4247b7bb212a1b172a6276e4cf0573b35de13f17e705fd3095ef9d92e6e77145d6823cf4c816d798be141dbcbd678cad9becab827070095d49e6c80384dc6e0d5a209f3495221c241534008856280857f1b9a34b2b6bb4486159d71d553dbdd1306aeb171c935686eb3cbfc08d91519334e4e9bedc07c82b54132824474edd01c030dbc74789af867a682a71f1fc596f5e628e89c3e2c1a3eba801e1fff5386ef17574f6131685050993bd79b627296d5ad9e681f24d4e29476679286cff36efabd40f834beaded01f938c59388891babfc716632ec008b10aa938d032b99a6208128bfa625b6e9fffc7e954c726dc54c2e8b74ea85b851b1802cdf080e8410b5ee320d7dc5cc64e8f58aaea9e57d89e1657e432ced096313fc0c02154a502026d74e0459403f85c1c0636d1b3ef4f137358281ffedba75af615a4a9e77c0b9133f215177ff79dee25539cf7b2301eecfe1479bf9ef83916d1de5ca9ff1d77c4c4c11ac1ccc1b22b505bd024f3bf99b6446bcfe85824f7fbd04ae7d068a8ef5ad05dab2d19c95b80710555bcf466f40e205909e689d5578b5ce81230a019b4579fae8be88dd5ef5729289ebd3f30c81c0d14817a2270c7fa69d90a4b520b6752b07ac7ae0f76eb184da19a6039db921fb35b11e6fcb686714a31945df032e5004e88e22a38680054b3153c2e26462627a94b3b03122b9d00716b24bb3309a3fd81e55f50d849cc50a5f40fd6f83b7d9203b77cfdd305618f9f1b21f8b72e8d7c83de075f9067039ca8d23cd6ec5cd2ed803d968dbd38aed3c1c0897dc9e315fef9a51530d0848b60f156fb37fec9b81af820b55e0e7dc60a329a21c8a90f17c8314ba76e3576e98e41590c0c165fd5d3fb9d95a29e417f3b75a7e6f090de2686806e30fbc99e2d52aef9a48eeaff315891056830af7503abf563b37b5098f65c922e2560ce671dbabc939bbc377cbfcbfaffc8ab17a63ff86c6c9b24a51100be07ac9930c22928caf4d14ece40ee85c5c6cb15274f2a1d859f4180a0e27ff9fc00c3d1f7e620362dc1d41a9642d673c9fd8db6017ecd0f9134eb924f271cc3dc173be04e4a346d4487d04ea2adddd85f762d5ecdd27fe1229d9fae96fbf17ea1e44a7d7a6d114e31cb2adb743c9b49d56f3987b9199332431e5440b2bcf8d2e22384af2a4370bc3526729d27524fd86116364dab7263424623c2b676a5c83bf7573c23172b73b63aa2501b2b9900c84ee07037a70f55d0afd29cb7af6c6011c3a6f5d363ae39abdad1280b997cbdd1de7fa891f5a28ddebf7f252093d208d36b9b58d67625ea3955894da614fa19ee36803befca52ffe993359a1759bac13de004e864087c2e241a28641b1708bb8f40d3c2d4bbc07d22a89b7c03f56944569eac151f1f70aa5ce0c141275dea5559950a8147d8a039ae547edcc9933e5922f1ada44211ebb12a3c732262bfded33cb54424623d44a87ae01e4d317af70d97d562df7ede46d247040fc24e0e5314e5e7c8e083181225f5bb3417b005c33a552ad82a65124ce1eb277859732b4457acc9f2606845f852f9b9b5c17b10493e8cfd4a0803ee49c0eb0cfa603838464cadee30769eaf77166d826b27eca1efa14255e241561630130890def7c48650037ea85fd3d37e5cf0d46f17172964c0395ae7f528547db878f22e846b566e406fac2ced4f064bdee2e75b225086af1d47b9e0de9b187b93fb0f38edcd13db15d5414295c6b234083cd4b665a1d3654eefce431836b56e7b024541ccef618c8a6ed30caf719939bca54c0ae9eb739601c0d4705f2d304b8d6e1ad1c6625313ee294128d259e21a707414bef76d2d8931f0ab6dab9ed2fa70074edb4b86c8d6c9847c7fb2ee812fc2855139493741acbeb3ec60bd93855502eebfedd379a52df46c0011959465318c401e4d130508c319186cbaffc29319c28e7317e4a30f4fd1a39438d26af7eb7857e2f61dbadf472725c54586da249800ece6c96735445a1fe67e72752b4ca859597b56fb36f22d45d7c36b47c4de76215468db40cfb186439945225a748ad1d551fba52b170498f72eecdb820fe47d53c54a44b21d68b6861c0845791844cb73f824355bef2f5b3f9f857def827a0290c9aa6ca47110821aa3b11ee0088cc47b8ff7c67107f84585e55131cd9bd2372df1553e036454c7eb00947a4c9fe86aa5924f1ddb45624f5341e5784aa749299adedf6afffee6e856953c5449630e4145c5c55d671b4731f255de208d34af41d4915ef4173d20a59b57e58e41610f8cf92114219f48a044a61845cd5f71cb320436e525d3ccaa722c146712f18923ff0a7b4537ea861e49e3b38e8786ce9570f632b8582ffe1ce9394667e80061dc46b63a2e0b66dc256d7a0141e7329394ea5434897ae80b1a1f72e7adbd19dc59745f296fbf7e0c019df5ab5fff428787214c742ff42aade95b63c426d4925933aea43bb5578838799927c2060410a9ea9302e74ae7030d65a5697f8dee255ad9c6d32b77a6d06d30476389929307ebec8eb2b8f0238181356a69486a080aff7d55ed3e73e114eef1416074a662cb33934ea9a425c2806766175b777931217180e5a409f635b57ed85f48c64197f8705d3d66c714370673defe34db8a75afa8905dae1727107f4bb824d6221167506f281aa8a7b237adfdd90814397e2890bef888e4b28c89e8ccfcc8f21c3c8ff741b31f0bcd522ae2404e98a47c488cbc168236112cd8b04ac27eb33c6f184636845a41295bc0066c60d50f40a60b6bbe167cf3eef2f4c3db75b856c12da1a912444e51da0b0ab9912cc1f0ff5963cac662b09197ab51091225186ac6cd23ba40426be1c3d1dba4fe38ca88cc1f3b61b281a0130fa4d7cc55f9aed0cb6f4c26faac2a06b6d3e3243705789b903a7540c5227d4338816fe604ee07750126287191c06dc95fe2931a8241d39e731d7ce09afdc117727c8b8f4d4ee379f3397572d790b702429725817e64329de4f3fd494bc2b990df4c8363b38cbdb6cc4fbfe76501b3a886c1a549e2de605d22c57ee4bda8829f3fa498abc56de527b338f4da0494a1f37be6672e4c363b8ff24576f95b3633a5d7c0f165f3dd161622f4378b2be43556d4e1e1e159420ee64d521680512ce862624b499217acfe85d264ed816e5ff98508821ac86a25498e169185de0282b3fca3d19f72414bfb06ad81ab0c3793c8a990e1d4a7534bfb2f146a1a7bcc37e3b18e90dd0573d2c0398465ad9cee1e80165d70bea362b24710bb02025c7e8ea08ca4a72b0a4b4d42ccf5da89d7a8988ca3fe4bea22c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
