<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc74be2fe968f2b4cdddf9cb03710ba4fe881022cdf048015cb1ddae09f348cdcdb4f90739598bb9b7dd776466955b0bb8a270390d7809375a4ad3e336c67c6ef42e3ee6f6edd9993678ca3501dbe80e54f632d5cf6bc98935fec744be6c2993316c88e3c0827ef2fb3237ff51d38cd304c158dda3a7a7eac2aa5137dd9d763c42afdfe262b69d4ac81394ecf0c03a96ebde5170bfdf0304ab5e8ad4c938c584619e609ab7f94dcc3fb872c392e242b9a15bb3226c3be3b8e2df1efaa425162b5fecdff2c4be89cf0f966b9cd06b897ea4fc3bee8039c94168fc035ea24dcc0aa0c443cc88ff0443d0690692ca3d10824fb6ce6e5e633d28f0d65641c48edfe9722b7a6d34285843e3afe492b0c570705d05bf237d30897607d4bf7a61cb8da937f18a227a48c4243f1ec5732ba1fd08d9ff0844d53a06b4eb15128e3ba52ed4cd5bb332ea80ee2ce503880a60bd15eeddedf785dd8d0143268d271e31e7c2b53dc85f02418f8c05c18f754f341573d6839a0dbed2387e55ef251abef6c5249c656419ad2352910c6d90ab3d97234e4943d1fae2c577f3a87693f82f90d6333caea2fdd561ebb3746c381a37ff7aedc11ec2733fda91667c2e5a53576d038e13d605fad57ec4ff718d6850ddbe332e736c305f37dd50ae022c8150db9f803aed29afedc98967b8f2df60c5a220a767d5fbc7ca37300efaf4cf20ef19364782e45533a39a8a4c09911bdbcd3c44d742133d1a4c519381cde49056f90d25c710dd01a0d3ca2423c411010cf51a6e0d35ef2729d8d41dd92414e47ef70167b2db2934c9dbcb2e9994b75482e523c20d069131a4ea8f360f7889c5eb14d78d78bd310b9c30baf23f71d64365b800149b28b52323773522f1f3c083c94f5d1f425958c26c1e19502e50a703195ed42dcb11ef1df65e8b8acc5094ba22c8a61b26b80f3c2d23c3751628e83a6283edbef88698ea7f8f003abe70f1b4725f258b4ec0fc5212945834a7f5e7b6f9ac8c1ebaf1fa7d295d3f8993937f85ce4ec07bc3744ee07c4df61f2f926c7527944cc4b44429f4de82dcdef6f4c3632c4eaf1eb71d7b46393f3768fc174137b1adfc90635922938ff7a73904741b0055bf0a104015ec6d21a6a505d73da5ace57a7d668198534ba237baf3174b9570111c84e6848442215377b699c40a600fc846806b8834c93e69e6c814b24a5383f8ee785960053cf156fd0a1bb8ca1f0f837f8da2f3f069b186a5740f9d5414abb806d40db9ae7b62b22208bc451560a806c9af39de07c2e42ab5e6624d9dc0467964e1e4a8f7a1d446f472958c1315d9c4c6ae6967908eb31c8a6ac9ea0bf5b71a9988666afd08593aab6ec379830bdf4643f5bc2cbcdcb6da72ccb0a21d9da5b74fde150713bb8331d13e5588f3dcfe57f2cc8a3dfbc18b6478541b3d82a810e3bd411537196ee539bd9baa46bc2159dd980b5b1c8d68e0c89ff1382ab65f435815116258a0602b01ab78ffa9f5af677d3a2d530f5ca4a7fe7cb0810760461a4f42b79f44366b8adb1c286abee32c44f8c273f9dce18889c95c0b9ce3ae92e0e6bff2bccfccbcd41d8da69282a531793dcf4ba81a4cf35b9d4a8278ca33105fdcbbfa0ef8e0222ebfad9eece8628de05054cf8ebe6e6708237d1816c432828e2256e9c51c9314719fbaf68b307c5528535af3f358c04c37ded7c3128cbcf1104e38b117a026c0dae771ac7a02b6d230c5e7fec58c6e39e07f6836f5df9372e0bba8be78d081a6fbe93991274cc12d8a2ecf03563cc5a261b26526aa1ab800b8a9b34d553f60b0af981e5db8757fd702977bad1b2e61210714fa084115eeb45359d5f188f25f47999d787aa3cada48f9bf94257ac34a3a0bd4b5b6ba081323ce8a03a4a563a4c147312f3dc5c5955226c5c8acc8e5b7bfc3d11f86d9ee719664ed6f7d124e85da6c35ace20761120706d56298308eda48cd3ddff7be3e434ac3b21c193931e1ffc8f87e7a2783a85cbe37c3f320d4a3a8d83c9de01e254811e2d1fb747b2b8461b57d14b24366d29b96d768680458c05911d0de3b71f1ca24a5a901ac444f0128371f578c1c203e8c406b99b45cb38093d4682e6846ea1a39f79b0b2d4a3f49248ed1cf915c1edb2a54306601c6e5b4d1e3e192243c68d9564aa48e79c06765cf4a9ff9fc7630742a9d4fa4cf3d24f1a9d07eb39bfd54d8109a41f3098135ece8767e622432e5ecee7f52f3e6c21466a3145c14a47a520cc71344492cdb4ddf23f75bbabedcea295c5e99bdd13cd52a377aa0215214f4659bd3113e210442cb2c27e01c70d80b5da77ce53af122efc04597f65682854d9e5fc86012534ad88539b8e2ce6fa339125c8b218179247b167b008bc72670fa51ad849c71450da926a943281c4ffefabd4070c6fc56fbb4265f419ff5e00042877c20a9c0cfff81a3f8c25b9ac4e4ae10f4de9b489f5987571212c98383c90d2282a847c00c4fd4d399ee6477a91b9bd880feef906b72d3d3afefac626e653b5dd66964582533595c957f5d3ff57476c62927494c1b4e88a309cd5fd6f0af142dfaf76f08a70b80f84ae2d227873f1e8f3c4575cc6cf1c389a42981dd61485671e39e43efd00e38b9add31ee4a16983cbc8adf0a892145e558370029b1aecc31fe10f15113f9f556c0236498f7aa96d09ef69a4cf5e0775210ed51cc61383dd1f59bd552d162632dc243e514b92862ee3e00c09f641824293eb3b7d76be4ecdab6d33e248e71be6445a658848c113baa8e33c62362c09aa2e6cad49dcb1a4e551af518b974726544a75211156405f238caa598779874227eda9d7b1ccc13b58f1dd5e65a6eee54c1049b395978307fef0dce87550905f0c763d48239244d01124b5749dd28eca3bfbbeb988787ad8ccbcd2bd66f5f9f2b2292f3cd6a09425e7b6afdb513a7a0042169b1289f2205042efb4e3e77b887d3473eef944fb77eacb8ffaa3f60ccf40d653474ecfbbc80474b926b2a6162be635412aab74dfdb5f48e92e9aaa801ca03adfdefe957900aaac1ab4b894b9548c7ed95df89e997a539841f4b8fd9640672bb77f8acbd115d8141f863d1f75c0c5b72813f2ca685afc4bb0680d6faff1e339bd51c6ad3c0e82e53966265bbf6a2ce3930e6f7f3657dd8931e4c101d3d02539147673b81e0a896dbb60630adafc0e1ec2901b9a896fcef4b5ab2e68354ac891965e57b351e0b6d1ba100f34c0c09e17def75f1eb1e71b062f01a221233a3d347e54353941d317711180ea5f4706273d932b4d35a83ebb63936453641e1dcd6fe37ce00755f8b351d203271d8fd796d69cdd070e48393205cc102466b7fd78d57e6d1597990e9ab6e4bf2f907daebc737fab4af89e85ccdd5da44622674d0d046304faac855cf2ddb5d48b7db24d8a3cfc780156ce58a5f4ac50e11984dbaa0545bc5f29132b8d1cffd3adb2287ccb9d8d56d9a2390965396a1ca0025dfe207146ede66a79bd4842b16f6e3b957d0e8e12106136a10697d0eb16dc7eb521609fad6f72cd9feddff3b773a92da1aeb2c2a59239b55c4d10d874d7554a6b73c2cb5764e004428f32b94cfdfc4653384b6be23d183ac65486335ebb2bb7154f57c5dc40a1e85710136a16c7b438dda632e4c8f29ca261b9e71c80abfc9773f2aadde7fa59b3e938fdbeb1b44cb044d518eb22309c6532b1edf18be52f7f43ed514fa8a13711dc3bad326b9093059bf9972b98a6a8d4fe35d073e8ccf9119288232c04869df014ef66562e73a2a3faa17ca1312e948d9fbcaa6a170d460ecc8b0b9fe92a5896719367601e01df54354dc575de13f5c5213456a13ea39577d9416cda12fda6770e09d21c90a819bddf6b1bb90dd3ea3846f0c30cfa9b13596ee849732b2f80dd8a9688523a091a5193702e2fff2046e3f435e6ea7811d9a52a1057f55f8dc83433f51b46ead5b03b6a3a362e5acdee4a6d58afdd8439f158e2b40657043020ca446ce902517fd68e7cde411677655d738b134f76b88441be71f6a5f1317812100a5dd614656338fa389718c14ff761899a4635e29260bd59feec51ade01d9519790404afb05f0e5acd5f8c0c7f1179fb6689d7b01ef42fa126f33ae5a502a3caebf18b351de8bab2e49cc089f15873450725af7d6608233dfadf89be245477bfcbf8ae160c9e5e64a78f2d9f0feb067c4fd4d424f011420f6ea250b3f17a7ee6e7b3c999aa59d3a36881c72a2cc4e2ee96b1d4502b77be1cb63af3d92c7fdad5e84bbaeddf6f7c7c1e3d963638b029e361e4b469491d8b55cca911278666cf663dd27417dafec9331a812595f67fec29cbb3b37f9eba0801cadeaf43756052895e44c82c97fb814de81a46d8dbdab82fe6628be39954dbdfe58ecd5eafd7423393c83ab2c994bdc190b6cf48aacdc3d1232735786177459e52211b5920db6acd21d4658dd703fde749b74640af4d2bd21669bc5dc6fcf2b239db7212ed8eca36b8064f7c614273fc13ac9136a014db3c1080a169354e6edb7d2513b40a6b93f6077c21a6296090dae5cbadaf09cdb90290960c67484a7f4f05b70cf7c4ca07c9d4322101dd588780191ae754c23a44feccd6e5cc7470117a394de3f269c2648bbca294341e9e8bc9b8f235dea385ad98425975a15b962e9249cff0d904847f27ef34d9b896e34ea2b6e0e3f9ed313a2874883d5b3d57241ba076b928f0099feee0702400e51d06e6a77e2f819531e07fd21a26de16243f3664cd9225d86edcff4e15a5e23d2cfdbc508c32cebf072c48c84f98efd62fcdf9752bf56155eaae4d2c3ed9f317a3004968748a3e4fb5ff65dc24c4441309745feb125506b4a66cd248671b01860059a0a5113a16e30edc0f364a7f52826cbb951a1f87249ef84935cedb00aded8c97777e0a5dac12bf261a4d0ed1f1a04f43374a1ae9058907a1376be0a32ee026819dd792b972a0fd761ec61302a6388cd871d78e306a1383453311771aea44225949ba99a78702668c842ea847a94cbe631484f8281b8a9f6ffa7dca922990ce34a8bea137a50e80a7e693e95e473c3630949d2c7ba1d6f593f4fe35a900db44f37ea1f6dfa122924542c1fc530c5eae6270760fe605a1a4fb05e2350c463d33d46570c92f4e3bec674aa79f1a553f64036d6a08f71726b96c394a2049fa21de9ba2e4960b2ac4370ec248e70b9b5958c7a7e191089c6f3dee226709efa5f8132aaa3602882fc3b0b7f1391151b80281ba6966aaf17ede630486de7c2016298486dfccc0a05fdcc9113671b73019621b8f457ccbdb6f02909599dbad42f22e86f5af0e7bf2379060292fca3ffe2a958dabd513c68301d20ddd0bfe37559e57eaf4b236318f09b6f98f4111d1b246abd003146e2d3d4ecebf93262baf02a13b2f43753267e00c2b42c4a333bde7bb4160a45749c0beda53acb999b5f00f75f11f9de4eeb5bfc27d8ced12106270a97ffaffb17bcc4a53f8d1bc5ac8db1fa4a4569810be011371414a5dc02b69c042bd4c9220f27a5ec2d177efdfe040c8c4c722943415832bbba420d43eb0da583f7e618a76839761676cac66a99a847f8310858de6e4b837b53112aed34947161d025caabe9585df6bf825b6c6c6b8db63b5a404dfd8d50034f50573f2024465b20138ca318cae5b2f531b5c22afc96bf0d2560a5236e6e5c4fca5cde03badda19f482f8e9b873f7c695fe74cdd049082c2ecf60d11a4524798050c5c05c18624b2993619dbb2db7dba2505bbc833bc96ad479b6e9f3e9821949bb702156084d58e008daabb8e2ea5b6d3acdc7cb114b63c6417df43cc6935b4292ce29ef2efc3a36e7c361c73070335669386e32f125ed1aefdcf0cc2ae1f036b75d55dc84a1c63d6e8ad889eebd5dae073ff81bf32d62ab24d2a989ed098b9e72a15f32e4a20d3f3f99b018f85d3d08679df19d1a46536f43cdd83cf5f932091d0b16998ce84ca01bdf04b079ce4d599beea9b226f08aafa2ae6919128bf24691824a283f6c30a911c9d6d33c4026d515f69d2a5bd0c357c45999c96c9122a44ee8118a2159803e798d1f571a9835c08d1d3f25282f85909c6b80f6f03a2e6a01dff2e25f7bdef51560b9ea424b003246044b0037a59e4085926d90b8e6f5c0ef98408f4cd73b274549da8bea9daeb9ecbbe69602ffefc6a5fed3d22c5940497fc28415ab67b60afb59baaf97fae1dd826fa48076314d6c6d55e8ed53c8cb41b4e5b0fb47e3d1f3fb5f5d4cba0e0a9d849466a843a86d68442d9f877e2fe39cc82cedf2e39b21c186ccc320b28b1941f0d416b16570f51c049e5e39aef968e566b61ea684e43bdcb3cc1731cd18d7edeb4b6a8385b8da10f1b2dbe325acf1cd87060989f45fda531775563d6888fbe78f3b14f3834a8e34ab61a227e749426eca51552cc1da9e3334fb5aa66e3b9cc5d30dcdbb15dcba6cfaec38318450547d35b3a2b0c0dedc2bf36be5d7c5c75eaf6be40635a2c76b3cda4e9ccf40a4c3cad049706027e14e310bcff321c44ecf60f04986cce109eecffe2a1417a7bbc46fc43ebec003c7bd0b234d8e4fbde39dc7ad6da3ccd65cf7593f3630d15c16c7bdbb633fda1a4987c3011a7ab8321edae4896d41d658ededf895fa9940aa8754e3063cfef34309eaa8de6965dee12a07076cd71e799b803a62a2d8a4467486f12cf387f67f446117e9522e39c636a8b09c6221bd8c61dc5afb7cf4bff60407dceb004b84899924dcbf7ad0b957aa4329dc4582e416994064bac78ffe9dc180b08c4313bd7f7262896a9b19baf09322fff6b7d13dd0f2d72f0931c97e6cf0ad421126d5ef9e04119f92d01ec6ad6a03df7df42771384aa404ef0ac44bb5980db82f31c8ac8d329c4228cd5be6baf1706e57b36be147fab1a1863b7520cefe9bb6c5e1ec18b6fdf0e42d4f96796b74605b183a7ec1341e98b90082410b894d79411f697614c7dfad013fbe31136f7a44eb5e243351f215e95c69e008764461d20292da0a82aa0428b0d028db8c74621ed5a29720ed705008d0212ef03ff15d72bf9a8bd819d9bf1f48d76fe76e92caaa9b42af8e9b09da6b010b331db7cc526059b79950c7cc277598361c32aa8b2d3921e38b5594c82b0354417642d487f8586d29ba83f682395e50d5668fff24e95a5153990fe290914893ff54924d6bc894e55f8567d8e935bba64d6d1d0c5cd9d01a2d643a2ea358753b920b14cbfbe3006646981a02db9173ca55a167eb9b8c4233564309fc9e48eca51b1bb9f004fc90689f185c4063d69f7473bf909866e5d8f359a566751842fe3805e2f6ca5a63129faa9c887c610dbe6e2f064702331bf0aafb05fc4d1b3afc1fa6f8d7d8990a3ab2019d5c23a550aa7cc3a2d42a8c8d92ffa8c08f580ce090d285eb345b81acc1221e870a9b2b042cf7015d6c891a7316de294e2f9032cecf9877033482fc31d22d484287c8dee64c5884983aed09eb5322f314c2ba123ff1d90394c45520e80bdbe9bd83d691cb9434775354e94c069cd874c9c6dcdbb56f2d0bb395456197ce108648333a64ccc7c124a47212c917a3cbcaeab6769cf16ea8e01240c76d44eb7f45d0aec09851e2a760913d69f9a87589f1b5652a575ce6bb5c984db74da29571e8f2967cb3a36d5fd9f64128fe85b74252d762f20b5a9749625df921b6d112e5d8d2e2c17f88e136dadc8d15f2719a27bb3699a80b3d916a8c905d3e8efb12fd3c61ad6ab1c167f38e9162882e517b5be26c6aab1ffde240af8d626864cf88bd3b5cfffa406be7b0658abfa140f28ab753cafacc1658f8bb664263d400ff223655bdef42a4b5907163ee1ba153320f0fc2a76028ca576090554bc3241cd25cee45faa8993347f03618304e57bea26e334bf676d967c9ddad4f598f839e521942d4d77ebd405723ed5d99cae3be2e62d85cb525d3a455852083f959e1587c1eb8cfec7f4cbb229fe55112287d7d0eb308aede01f6d844449d4a23c6920dbc869f1af3280d92bc89695132bcd67da18a48417539f37e13dc36d51792fb7806eb7a5be5000f513e9ec99bcf34525998c919624ce3eb99cf36f9ba16390977d026edd572708e488b8f0ba51e2130ff8210526e7753e73c7850a92c604b2fdeb2d8e21bffa43c8389777dbdfcdbe3a9b740515bc839a8a429223a4cbd2a55fcaad2716b3b10b3ccffb40096f27b3a1341d14214e0ea54e706f4797826c7f6d41be7b29661027939e8362173e05a1d862c225fdc03da4fe6d9c780fe98c99ee12915394bd8f14a4a7623f3b630fa7942874f4840cd08d4ae5bd9e2312a37b6e3346ab30cba457794b8eb9f8ad3e7c5c9537a9a99f0ae0a2019a0a160582da4068b57ea46addb9404444b26f1031f44620817c36fcf033126364e158d476dee05c1a86fc95d6fc50eab02c26c88014710125caf4183ef4473efd796a71689a6894a132691fbdafa02ad032dec912bf25c75ed98612cc28dbab3b243f76014d41d1bfdf3b71a979c65ee9c66eadab180ac322ff3b4d6f1ca4462c431a6042618c75eed3aa17d0e6229917ad167f75cf8aa61348ba71aa2ab20b8d43ee5f50d1e3ce75e2d31a789c8e548def5a36a81506f13a20c0f5a890a459538379fdacb47f18978be4b70576e73a46d0a3ed99258d9aae1702e0f9631f998a8c4c79c9f95faff05dfeb28891427ac21bf58dffe472f5e62d124bc58c22662f4fba6a597231c9bd9df73fd5fc4889f4b091c211251601643365844a2e29c0c6cfe631264ba06a665011cf01403b3add69b7e21b62f5305fe532f63435e2aa3d08be6c6fd71ce03e6e936ac5e0646568656f425220c7914d002baf99a04be0f5ff89b124fecc34c4c9bca727c43ece2d7460ff88ee96182ce9c959a5e774a9329681866f507030055133424c4d328bcbc51a1ac18d9fdfae6c544c07925d1783dd475bb0b8fc555ae06b4a5feaa82de98ab2ce3f97e9264ae4d3b352874775063dc4112668800a70f186d7e169af74fa0690e9786226c705e4f64c74f5a3a83f2341bbf9a3b9150095b58ffaac9bdddfefe774b1a153d08b469c6d9dfabaf93370471ee383847034f2b65a459d004e3c3dc0b22543b31b5c005ba3dce2a05ae2e616d10bff78c743087b178b1b119c721172ba264cadf22d0bd54a935d7b4fa3027d98dcdb242d4513b47f7cb00169f3cee49018c19ab5db54e7e755d6dbeb90527b123b39407c1a4573bcc8b71ad880282d10d74791a4e8d392e50d9baeb6747eb4c11a2e245d0d32b2877679c9f30015a3331cf90b706244793368aab621a610892fa959bbe51874b94f2130e5f6009f1cc5df8f692b2e59c6c8ed5c537ea1f3f8fe0765a823d8029fff2be12d12ed60de29464e7bd42f0f260aa624b107877be78b4c7431d9ed0506d81f1bb3da7801307d3c3baf493d532236510c970aa603a1bfaf894ebd05378cce33012f9da9566afcaceab4daf5b89af44de8094bbfb046872c83a9629d89d4672f0ff97a8bbcee9625cea569231651cba18118d62401db5798b2e2a0f454b103096313d94f0396314050b0b407d58370e2e068c1c8a439ccd39e96da50d74d7841eab36374ed2b8101431820d6366bc1260df5541dbd4c74767498cbfe0325365f46a04516e73c99f43d7b8f2f252dce585071106759890b734a3e56004386d5f9384d9e7deea0446c1e9dc1976629e846edf5e7b2f54d3876d29dadf7fe7fb52190f76f269bfb4c7fdafcec441e7aac8130146bf139eba56abbd6201c7742ec1ea5734e3df9ba3d8359e01eb485faa805fe882e96dc9eb4081bc0b409d707f72aeb74fffdf9724534e5d417391ddb7283403f08aef363bf59eac76cf48f695ac47a1af9b7057773d2ecbc4b361d51885060e24d01ba7d5895ebfe80855b34594c12e3936618816829b0a6884e45b3fc07a59b4fd449f23fcff3bfd9db78a8fc9cca7677ab8a52ce2a13aa42ab61e9dfedb97683175eb1d63bf104d5f44d92c62c94609f4479ce86c002991c474861107198ec318e3604f393f1e9a09121052e54eaa2f53beb94af058c186e4b4896f09e97ca3f9f6cf84b9edd459038d5d453ad1da5a9552a478acb1c19a87bc6315e70b93f976de5b58315ca896e25ec479ef1be9126d80b48162be092900fc784d99f1e742ebd4244543a87d9ae94aac2b9d66f9a5f6f17d0bc844e0494bc62d30b84f8e28a5946c7197263cf510c90fe90a98d8ab90cc6c3c576ee9f83b88e55912fe5ac052d4f983d18af7a5ad3cba32324ca0051f28403dded27c20a4ea8d2b2e78059eaf8d49c2638952f3eb29b1d53119c155b6560a9bb9b7711f7c281978b7a538ef022dbf3d9d1d3df8f81ae4bc3d5cad5cf5f0de693aaa2cd781a82b1d647c9185f7f7f77aee7b578bf84faa3c0ed93ce047237073f2c81cb4cc63287a2cbce0f78d9893f0b6558723e7cc5b48adf2cf4ce0b30aaab6a4f3ae4629fe6b8644bd70b32233f86a7b989cc219e4ac9ba8313bf08f903ce0e1d890e759ea3c0c14241f5dbc72a007ae8f8314237eeb439881465d3b8843e07110c9b2f36d789a8ef02a1e65e344d09c028338ffc71c207f1c87a6b61fa9d77ce915481e04713492b2a0edd1974a6cac42a98403d9e48f9d038508601a387248f1fbb6e9a322d2e63a3f681c806e006082d7545440a00b846a51734853c450ed09254b5278fa7f7120154f846a969bee6a3628bf06c0037c46c37a57b2f0f50173a4c46e3848dc78cdadd1e1fd837ea8b5b77845d7ea84b677fcf8b118286020bf992513b2aaf70be12c592fef2b385d106fe59dbeb1135bbd450bd1cab2bdef089e44557ef2ce4fc7e2d204e345ff0c72c877d7a2f187af581b18c0b709a149793ebe7e20b8f24e8d49828ba7856cb418b2a3e6d1ee887fa90fdfa106635a966e3af6e0ae49bc1b363c39b2716b69c5e8213ff2692bd5b071434df69e5aa24041c1cecadf912480ec9c1bf6ead2f0aea416baf7159b837e3c8b6b6b93e7aac21fe616d78575f6b51ef2a4e5de9d5aff88389464c10a9ae5a176c4ed3cc991dfcf68fa4820e21f6c1fdb86f94c13e56156738c0666cc2a4555a724d185223408757a456a32002068ea94c6243caf4d82b94cb4bf55eec1b21d2ab880df5582be2d45d52183f67788bfd990cf0fac9f2bb12126076dfe7f234857163c2fb1b3f1a95ad4dd78cd46f694340fe86fed53de18f9ce2770e59d55e77b9a39a7d2ca9deed0821163abcbb7fff64c95c5388cd8754a3aef2b684ebd555f111f14991ffd949463800955547f939b73dcb4dbe50864f769c3dc15621bd017646fc0e97c24dfbb1254ac4bb54bcde810ec6e845a973987ca950d56348c89e0e8e848fd83cfa1c0f83c3c5ecfed23847c5c734970ae837e8b99d7762ae897636b49fdfab4dffbc1e37f0b0a51c2e6d93e0ee1989fe036a2fa815fad5251eb5926c31c923a5644050ac70a59dd32ad76688a7737159413f8ac390b341bf08441368d0e92a066b955296f735e4e8f032e04610c29589c98d6a31c5b9bb52e2b59c246790b9f1af71b364cf7b23cd17543fead5a236a3787b4651904b2ff1970c2f2d1fde592f8c00632e86d190e470c3af99a8c9edd73a53de3378d315ce359e14a995a8d0bcd6331c1caeb365c5553b6c561075f19923694a85a58028ce739816fb3253ae053720dd99401489f67a34522ba221c863d3a1a8b33c782ad2d01a8af218a456cd28408b83d9b7d8ba4770ad139589df2005c863738af137499114ea91eddbaf920b5a37e9e140a7bbf436d238cf919745f4c3d72643eb78141d19ee57fbfc5b0870708b560300bfea71feb4ffaa3dd2c839f53245aaa9c72549bb0cf63aad17b93b39c573f086972cd9970461d97a0ba1307bc02e14fb042492efa358d67e7bff200f6e67ebbba359b6792cb479e4120c18e09277a2574923b8cf7212536deedf81d68c95d30124fdb26d309b16f36bd5bc3280aaa7070b5df3be0d96a08aa5dd4f5693738ede635ea65846f6c8b11d2766fea3327b61469bcfb0b8b5d2a0ada4d0c66cf500d2748bb319d9e9c96f6ac7bcc5978581d4f3c63e193f311c600b42a1e0de44505a21350b47ae3837913adcf7f09f4ff6bca903a4eefa629ebfa059b5f086dfdd86fa741ed50bcbe47ea540f8092413a52844aae42d190da34a139a896fa4b77e4d8445dfa3e6a517629b7a4378cb86692430ecf7099ef5c678a65fe8a2cfc373f2fa6fe06aa9be4dbd65805677a1fa4b53a326548ec0a28752d37b7e455c03e821aa8391515b0bbc811d45193ca2bc937fbe0d31bd1e1890b40bf4d3de9ea51da506911112c36fd24bcec877809022f1fbda9944da398e88f501eb0e9e1645eb048e18f1d9a905a4c49acf2376076f778b65bd9fa59c60e5039386307d6326d485d59abab626e205685a696334825908a6b14fc94a53b86c30f3a3a2c4ebf63a2650e37b4934cc4994072c15d6e4159e9a9aa9607f8d52572d5f5c03b2d6302a82d0db035a507d8bbca39b1e490f62f8267246f822d7805a8be6cd03ba06d1a317de7a49bc608d372fd06c93558799043884ffdd693189ad1e14d6174b8770f7904cc97b35c1ef22b9236ccaf44e8b2e518ae4f772e7533fb7c5fa9995f260892fe100859ddd27af50d0f0f023a371f0bff0b22995225d03d2ec1e49904ebd7200fa5915858bead25ab65e58d0f86a18d8d291188a2cd6c9f3083e711688a88f00c10ce83174779c5c74e0c9defc42018397256c72e99e8076da1f8d2a99d2072bdef1dc0e8fa1e92b179ea6325f654e0a76c98835a0be133b311f852fa2ee11512a8eb0c306ee9c9cf310acf42e848e04749f2df32769b1271ae8842ec5bb2cd2043d0b359927a56549ff4175e767acb49e05f85471600c01a17b8dc6519eb5478b3ccf532e9e00ba77c4263ef07ef79f0b615fd86d28fa278e2ac46159a18747efac0e549a74b7d7299e5f4f1d71470da15943aa804991d9c8169733d364c64a803439dbe30880d27d5c62c09929a79e89d8dcb8c275ffe997b7cba38cc8beb415e0a7515b483bee145fffaf56ae80bfd3b53086d40b39b1e4ef24fc9b22aeb369d2486f64be80f9448fc07dcea4475085b2d2afc05a41efb2543c7512a620b4a00f48cfcd9bbf8f644c750c4fe596c985357fdfa7518d89227e7b6ee8f280a5695125a2b7955cdd4acfd2d17c80c471606176ce913a058307a8a39a2a950db79af7aa4cef87ae6c304c7b888ac448541ad6154da31aef851f94714db9ef887db5b3ae8b14f59079b23b45fd6bf998c7d1dbd318ec2bd3bc2b5cc07fb3a46980f5eb1cef3bf6ec8f22b187d1b1dd3ba9906377999dbcb07eec89d55e480b9258b963c4a706cbe3752e333c38ad67c10ec854ae91401ffaa1ffc4d8f71339663395cde576665f5b3f043294884f71d7266cf8a8feb7762ef2603b1b3d1fe6af5e22fa1092170edf85b89596ad9098eca723a7664013699479361318f1533f942686dc4634ce268d3f93ea1d4ba46e38be3ecc0f433f8a6f5286f899e7a77acc11df837539876fade841f0058a450373fe90950eb69acbd6f984dff861c1baa1c0bbcb1f7101d3d92024f77a695f335bb88445a2a4b6331044f3c471dd89ad71025aa2854da4d2dd80334b6158ac311a5f82eb5ea98481926caa9407e4cc8d03e5d67263a060fc21c7bac9f5503507725ff656a1fe4346f349ea44e1d72d883212fc4007f8ff1f80be3f64ae1df1ed1e436e9ecd55f6a2207d112c1542c46d55a6f8871431c97adffc71ba7ec19bedccc630078eb3f56fa3f76c25e25bec8e8cebba88c03c7ceb751a21a221eb213a2472719adbc1c6adabd0592994c714798de186b83bc5f421afd67dfe8e7718392261f94165b5035ed34173b2b27411dd98ad53f2925442cbc677932089236148e8d211df62856e089d44a768353df5a15e899231cc1cbcb1097313350b14e5aa6deb5648ff9ea2d83b88ca5d7dacf4abefe47e1710afa2ad618d79eaedab21acadcf26653d5855f1314a3e411da12495319d4bab44d08560d66d2979d23e5006b89ee55d77702a7ec96609adba4884b9a01a693cb7f3a311fffbc708fce5b8a76e4d40d9f24596ae00a21daa0b8ecdf929d963e1a56161ef9b0b96d7f521a39bbff247d13d15408c0b524bf7094687d19d414561d9d573108f5318402f4e536d99b17ea88a2812cf17ffc810246c14c4dc0a18d66ef460ce0cdc1df29317f9db136c2d147f572b6e9e76f0c269b4c05689122d635882b009262d4f52091cece77cf147db2fac538e812417e62169124dce4ac5c7e84d49d2edac2a907aa70c0357fbe2195acca9dba199c327c1cd48beeaa86fd09954b265855a8c49c2bc8864a4003002592f33c2b278112a2510a5bae74278f9c4a44188c088493b47eca91849f15ed4a4a15c545276b35385d39186767a9a519b3ff47fa0368e28e6cd2d757dc12b5bf4a7e724f042715b0d1aa104c0e27fbeddcb0ecebc9dd79e85ceb03e9cbaaa7828f19a1ca91385a5c40ab2d8d17fbd7654971d3f3cb32e3402ed91d3a3996c5a6c8ea7ab1e0865ed762e58355dcc93945c439c86e673275e95c474fe51b273ebbfe4f157d7ab9ac11c4a968842748fbe601bdf6329511bda87715d86551be00e0887b0b603b7b33cf224d327e60b5e55d07be265aae8d8075c294b22b2280630bf823a12f190922edfe70ccd6e44c8b9833bc02b417ab738963513de56894c62f5e68534a59c7df0c4d743e8b8be9c57ebab95ff32cfe7762098fb62e43d0a83110caeb5dd4479bf95b2b10c3ef61d39056abd63b5af3dc97df161cc538022cc0388e0f3f019eb3e7d792c07d48fdf5f2b82f1c7dc5655139213e502ae308f212d7f9777b8ed6704cc19e939de98d05978ae26ffa579a721dcc6d811ea99921f34c46127c0ff09cfe890fc54859e12902d40735fd7348cdffa80067e8aab1fab1541ad079ccc61f270c01ce1ee090b93ea8473467759388ad14edb2647f4c08a18225764e67dae7e4f1e170ae1b7b298e9c195de44cb0325520b15e059b43fdbb7b303c2e8eae42c72765e80852d0dfbe5e66fdc55bfa1e9238a0ac115dde7932054a440ec1f596ee2a000d43325047ac2153cf698c0dcf4bf8dd65e3faaa1e1a29793c55c6f1945e1803929869505d28018cb5d051161b9f505c7232e51e020f27d62654d7d42b05fd65399d4c1a925325bdb8d14738533e7684aa8c466a1b078f386d82d018693dbee5cb0f154cdfeb095c0a7e3da858bed05bfa08387ffab29a9d4d5f8d99ff143a8c8f9fb6dcfa2f8bffceb9d885ff9c6c001114540eaf35a2bf8535bffb9134d2dfc12240f2ca26917cdfda5dad0e1fe66d5f8cc31a14352452e27f54da2f26e4ea10b22c8fd5ff473eae6caaf702d1ce5c98a0598f9350c563ebd6dc541fc1a0e07ef6d71d5bcca1889480e9c0142bf2294293d402e05dc844cb930ab458192926019e9fdbb45f21419279c22ff137f3b770fcc92a25621cd31f185acd83fe2826a49f1b4c698369d9c37a57d7c294e603600b0b0a884e8cddcdeae71f35115211802c549433c66d5fb60d479c0f3c2d1facda4dc8bb7e97bfc250eb295a73af97479d5dff18b02cb83cbd02103fd1489335e7ecad6c7b312713cfc15d460f87b4cbe9ff27ef051dfe2a7066f6607d84ea015ee25ca2170ad9cd031d1b203e3aba1c2499c13908f28a5d6f7a407158ea9a949940f258b09ba08bc20d4d7aac951e6709dc9c4db4a8c76e962bb16c5dcca557e72d1174fc3c57df9c459a3d374e7bf5987cb19b8a8f23b3623eed6e4d5e91d0a52e568469f552f17013277b89229578f5a4c6ae76bfbf5eeefaa205dfad157e871afd015596edbb156908efd17c0bf061376188cd5308f41a35036052a238d70d41ef7e4669f7eb98bd6aa2ed059d0185b854845ccd2f5fdf9debda0916e0e16af0cb252608ffe2f8f38b62e08e2672952a548fc2802e6ea8772f2e914943753ddcb1be34ac97459cd23323caaea907543db56d239250ae223c6fbb0d49025b6e66eb0498113304ed5c268df4b342ad997ccfc1c959f1ffb8dc1b5531daf327a4838e3523f7b2e874e67c5654290527235958cdf0b6c10a7a4a8e5602f18dea2bf65e4f3296ded644240c9dc922999536eabf271940c750be61f3f07a479be5f0c408e05083f4b7fe73f41d9278e1f0c437ae92507e4133ef791374ee50aa927d96c35bab80f57efbd275a0b59e7d873dd5742eb7a144a1894a3597a70de9d0a82b88e8a53e9a638680f7e5456d4eda362693c27fec153a382bf33071465b32ebd8d27e8df1fca273377ffbea41ee29e0b838579e7a04144dff02364b5b6c6f14de8e443abcc2bf7e5a49b4a1d5eecc0bfa73f2ab4a969e87595a5ecfa55b115d719e76bf5393033b893f84683d959a430cc8eb16dcf42119319c02f8024e3f92e28c37d3fa12fb9d015dc1b0436dc0595b003bfb09e6edfb9f6364419731ef8b485979f06bc05e3af6e5ba6afd2376d0302b98a4984787338c27c2fa539deac4303ced3cc689d458e231e183f6b9f0e233dced9bfcb81bba08ca9662688b46152a222e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
