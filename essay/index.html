<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1264c3f109c0f313fa8e73c2497e6b1e963f23f6cccc0c2be9a0f221915adef5f7c517f1baae4f4f53bcc69bd47b5b4881397eb488382ddac364c05879ca47be82c07ac029478a1c4680fe1e40ceab5bc142ca62d7764106ccc2eec77accfe3aaf491decfaaa69eb35da2a05575110dec86914a00ed9fe1a9b6ff9cd00bf39ab2b4fe20c51a523194be8c95297c773aff948463b2c4e90e0d8f096c870db6ce77d94d8f9025be1d294f1d2e1603ca21f2a8ff9492128ac98151994f145c78510073953476ef6588e20a423388fc6b0d850f72e208c0170d62865cc623768156645c7e80954d71507a933da8b006259fbfce9141f8e085c4b9901058a264fe0890dfec781b765a4c8195af2d6f8d316007cdbb1074b18770c0fb2765024ccf09f0c80a5eafd0f8e3f16f63538f3c939b4545e09c5ec3800531d34093f0112ba73105d6114d080f0d76b34958b1da7c0a1f60b40c68ba87c1f5019dfaad31e7248ed2667fb23197ca6ef33c89517cc86e54d2f76bc56e08b5d6293b0e3a8a2ab4f508be8265e73d271893d353402e48983393014f57182c24304aee1a2e15ec5903c01ee633985b97d92380802afb2e89b1d22c90fad66b95abe6e9ef428fbe293e1a9d3e925804d2c5ea1983e755c2ced43fe33273e221060ac68a21315656144528b6087dbdeaf708c03856a7423eba339e5e94859470ee04044b460ef6d8a0d92ba73ca52893817b4b689434caf9b451d3011e1951ac0b03a5a5007b3ccfb6294b207222ef0763426b11679b025de395a97cf9e05712db4c67249d92d1321d2ee8d25cc5955812ade790e6a2c496deff3ba6417129e46763a73ff32ab6eefae5a2b129bd813fcd33d29b36eaf40982aec4ab276719d75afc964ef24b7256e7e8af2025e885dbd85e1e8aaca5975d13e3af252a507f0ed55264859eaa186779ddbab086add2e3e3e8e2c5a5c2f66d031ad5b6d8d01836c427202acb8f1da49cdf71bf6bd9b3eb8e331fa854cb581f20165f1faa38b08184645fe71b1b4975dfd543766b17c63499f4d157bee52290aa94700837f0d333bcb442ff3734d3eb697965ea1a36716f0f74812634c6d5c509b1b0012ba0e9811e66f4de39fec35666d9837ab3ae11f95759e78918f0eebac47ee5ab11b2a9ef67d6d3f641e3dcc2673106ff7df3ebb5195a48061f1d2fbcc7f11d1284088ddc2d9f9309d94de182eed8453700bcc1ad6b792e053d46f97a3a94d949d4f49e99661f2ef7e6c6c639fe5a3ae9db96c1ddf4d7afe366de9160f5a21bbcf0cebb9e25c9ad3958fca8c54969459be32e56d077da97a43eea07f15823333b3d7309ce2af27d65e8ddda7f2fb18ca223910fcf1c393db6d067290859155d09f5ff7206d91da7562fe092afc2639aae75b4b1a9388b2a178427528ae085fb1465dfa7f1b313613243cb90bec19ebdc283be3036af482cfb73f1ecf09523d07f02335e279101c20e309824c461c94ac7b468ecbad1c16ba8ff7cc939fbad93124195e23cf3e294d4e21218f773db2a49d44a92575e05d9def180ee1310bf97415b94ef56feffc332e50e7e84496bbe12534a1d3fac81a4de300ae3b81dcdb6e6272c1037a4e55d944ceb111436842c6c1325cac1f61cb5c3d59020dab019aeba918ab57ad5d7bf2c899f179dcf1f963bf378921bcf429528413c0098b715ad8a9f5a89d831a657ea500f9903a2906a77934f69c1211374e8a8a2d7a808a8fa1b844bb1fec8be7a04e4651a9c5967e449456604121f19e0c2682d0e5e5b6038ecd601c0e22b14ba3111ec952b548e41e14c42a8f98c03b5cee419720f63f559d388d40a8f69502d79beddb82357a8e7493dc25209cdb7869303b3519fac2aea474a15f14ba0ef27d1296c0e085f95ee908b8d21fbdfdfb8ad01c827b5ce196ddb01ed3661bbcc6c9dfe506f775f960fc03f7f41fe3ec9b84d85da201565fe5eaa077376997a61069023e44df5a54d527d3d9d2d164ba6a230684dd3f6f101b45f29aea743ce9ab4f3c8313d22b0b75185e20b604f6b344912f864a61d7a8b5793569e01acf2b9c8ff9d51f588fe4f19d57140fde891d3d99a157b88bcd237d43458c4868e310aa6ee8d3dd7567f29bba055736b3a795363def3298a4121dad347c62e569592ecf9a073db09c93f9062d1251593aa77f0451b0ea9b799567fa86c3c8b103cbb1adcce65b69b94ac82f3f2d4055444ce3500d7fea07ede9955140b3f3c03134ef9335c9aace926ac0071ccc04783ea6935a3f3608f9171798b53696694c0e2f20a42b3ed8b9d8a28240c79a1d19763d87a2897ba95191c0b8ff2d9dab1741c80620c9b137e87bd740865430e80d2f8ce717cf84b83935927984e39b4c5ac40ce8c4dd99d61181f33b64eeaba3b7c304131c03d6983c7940123a5196bf547f79140ade36c97150ac2951ac1b25b0efcd5a814a042369a5aaa09eaa4d11ed836f3ff1ae228603cac3a5d42bb79d55c9c898834c576285452a7d714ac11279617163f5c03296917c67ebfcf93cfbeaca0224efea54dff57fb6a3f5f364f6f3c0683886b649d22601cdfdaf31e3c7bfa11aa45ee57bc50017c8a2abd95c09ec3e6e34960ab202f7e772622dc5936601933050e031934a104c3a7384390e96d702b6a406b9f8ccb310598c31e331d7d235a29066a9a55f848d83a6340f7f45efeb49fb45edb83d6ebe98f9b6ca5829e7cb6fd04548010f6fb0fae89146b8675c47536e8e08c4c3985d08b015c1a316070f29cf2f9ded191e3e170f7a45254b4740be549933e30a9e795d6a69cc66806b22e00c5bf2618cdab6317c47335f11a38855668627bae074652eecbae9fbfab107ade909cb4647870f3e270dc520f5ed37b00f1a79aef361123e55d37fe216dea1e3b9b23c3bc01443fcfe8b4c870473fa60b0c1e20a1b36f4ea12e6537223a49e35d214b12d7ac8a2fbc681057da275da70d5cf225e3c655ccc53606c53c18a2179b4f287924c4292377117b1333c5d4b936732f20ae28303b270c2877bcd33cfde62a7fc20c35a72a6c60dc1d61f972465d40cdb8512b507a4823b3ab948e4c6f4de600e65f8b26833ce9a89faa9fc7c2f50ddf933b9fee3addcc438768a43a8642f9916a3e8052c274e1f1d30f0c4b515dce34c7c341a0f79018a71e7ef650b6709023e430f16f020c9d60dc10110844fe55f7521953f895b6dae29e09ef13e5160c7df7a9ad046784a8cc2780514f0251f14ef57e1049c9af8701ed04422b568eab2064108c37d5957e6bb3b89f6bb1c05cf9bbf013824fdd219b9d81d80a332b9bc82767af8554f882f3847c6a27883337ba8c37b5b82b634629f59e5d1fd98a8473a01adeebefc7d42c28b921093129719cf095eb1f2ae326c9726ac9f4d706e9f06fb6b54f367bb27db4c0ef5fd2accb8beac6de5f39be69165657ee45bff2dc51d98b3f2c676b50aff3ff82100e3980f24f35cf77fcace5afe0068e6ebba71c8d39215cd9214e6cde0aff0f34f678fdbcd508bb52d7787cda624d865f36e6b7bb01e71b3c22b4fcbab2c6f95357c8be95c608e12e6790455c5ebeb8c8898153e497b9fd173d675cae3c2592c7edcb22b48126d327c02f123463027c5a3065a9f52f0150989e5f0e309ba962d4f1660c3f7e23c17a4f4737f9b2e30bff2834bdef9a12a0d3987c7f455a50cb2153ef05e1101524cd7919a2af53e095212a4d30f653dfbbd804f83d60b6622dcf40bc477e759a5a5c0499e224f476e79ec09936fd925cb8828a45f4d873c2db122443b05693cf0f44060dfcfb93f2f328766537b25b40c99acc059c931e72c55dc5a3c91efb5297aa22819fad5e6320c02ce75ad19afe07ec6cfe0b9244d33e33b3f83085794c5ef9e4f35ffe874ec53358fa84f3453ea67d501f66b966bf7c04b940381874934b16769aa003996ed77b41f2c16b4583fb76b0e9d32591dcde655ac9dd7b3a5d2806b815a9c87d56ce9a34325645c40ad729ebcd779dc1a41bb0c995224a7edb0153348673cb89652d09fc88b008a2eee7d365e63025bf155ce4ed7b9efe502c5480d0936a7adbb07db89af253039f0afa84e4b7a560207085d34308644fdf83c575524ec085999c6e4cf72133617710db7dbc35dbdeda7ecc8f4a2c85503a6f31d301a569149838bd540f3fc417600c68fccafaffea29e781f41f27d3a1ef4aa7aacb9bb4cbce566f73c7db352dfde1a7c39123602a3b16e702ee6d5f9d239fa1eded31237ef75e291c3f7c4b7b3c12e3e5f082f20385a063c052a6249a69fc8a8032f26314037c5d284a3639ba472cfb0901411c468955efc13ee57741e19372c3ca46215824221c9289d7e1e506e0a5b92a5f3ad782838eea4a0d9349733e00dcf77ceca0b19c12d2964207ba2e54174468a1ca9e5269b7e737eb8c33e0f7509bd9e564552c17b9fb9fb578d14b62a8a3e4d14497762c626ef9ca82ffb1b64bbdfab92a959137e8db71121f5d49aec35a319bec31190af885ba279c315ba68b9ac3fb0f1a3c8addff3b067732d36060293149860c02a0068337fcda259df5ae804438d2fe399912bbea021960ffa10f353e7d6a5130a77db5e46a224c6cf37554231f681bf2409aa346c20fed1d9eecb523d5d6a349cb77ba69e50fc43fc5bff0ac1825027cb3b58928f1d666cffa384b803904d7c437872565731bfe3f7d47e61df5f59b32c9eaeb7bca99ba0043f382590a54f6ad660aac2cf1fba54512a83e4f2c2a3bf632f4d0e59b81e65e39d55a8e18675ca9b61222e909c1908182e27dd9be6ceeb9243fae62f5f3215b335f47f35459495b3de653b4df66f6b29a602ee0cd91ac8fa3e5b0524b6f9697e5e809ade777fa64672f41df46e351bace4d5c71d90694a0bb8c7fd8f376d4ae38a698a4f98dc0b6d34179714d9b8fee28cf273edeccb6915d38a734063e3d8d1f714a2ece657311aa97d7ff274d483053b37bf9e5dec7b421e74946169d189ea5f64845d75570e474c69a0ec0fb41a02885687e10f5e768760c3149a9978db690379722416fb6303fd8e1f94a9beeeb3f5accf48d16e85ed0e0322b7b03f55d4e1c4e2c3240bb1c2f172b56ec4cc50a26e751696cbdf1126c2cd15a0539a688a6a8140299e268de236887c93e79937806083bf90ea7f8d92a32a50bb18535c320fb152fe7d99a647d0bca8b915d84419775f62fc98906c79d5e640ff2e3068bb37e26d98b5ad940b79e0f495f8b8484849891e99875caa0a7cc9b959f5db4e5ed5be071691dd9050337f2766cc821eb847ba9c785271ebe47dd391627d322f275d3eb28596bdc9b925f16aa317488977fce1af91f16db5f948a68020838bb72f6a4f2abf471b33728ee095059388cc78cfd7427856fb80c534210badd9259c52118d2ca8435d23050e20a8d94908b927af635f2dcc40134ff329bd1c2cf167f180b32541cc39c4950e1a7150b32b5fbb08d6d592530446a071c34e4e4b4589c5bed88d080d6ce86975836aa4fd4c42063e5e5222cc7772b4da359bf5c7541448abc5c55bf78f3f61ee7311b41118c33c069428c75ced7295b5d3828d765a6615948ccc493a280693ed28c31faa0328e4be11dd48016e6aadcd67540fb6b63b1828e3591cc5eedacfccefaf6fd9856116ae4ab93ef16c45b7ad74d392107077fc650016beef2f9dd0d18fa1461264e2c05b2df3de20d862bb759065e34da2e8c5025ae9d6548128f145b43bfa8c635c09ae9fc5972cd7937c009b76d0cd89c2792b4588227fd4d97353250ca0f75a6bfd0cc294acdd1b04f3d65757b0271629ed681df3c72615e9f4797157eead9a6b7fe28afa1525def83949b40ddfe3714c50c6d2039535034a83642042fb66116234a1dbb544fbeb94b4e751ebfa9bb880272d1be96e7439e541f1f9ae83ae82837fcb952e8bcdeecc8cfb22aa2b64ec558af1e4fa49fa652129e073ca1934cc1fc10c0906cd16654dc68e6e253ee372eaf183c02aeb63c548768d1ef5ff34fc9581a530f1d17acebd92c6c44a4d43ec2461e68728ef33431f826b3fc21ef7584503b3742d39ca552b6fe199466d59d1db9124ec711df9b7c1d06fb9f7deac0b4c018e7cdf579141ce3ea0c266ce3f2d92387b7057b620a981d7ecf57bbbf737c58ff704287b4c7eb8f77c0bb6be42af05167de322793f82530d66f4f3662ed47aca159ae678515998a84fb9d89efdd9149e8dca581535b2cf8a8ea69dfede444c5ec048830f9a6b8c2cf17ab7e9b7b8148b0bb426b9694d4dc6ba29a938ea90b66f23793eba8dd85f58b1f9097f1503402a7a9ce655ae7e9d9281b8dac7edc2c7b2b770cd1298fe2b6729d4b7e1d902cf80dffa9c97bfad03cc26b9d30e808a96552734932db9faf1c90d54fa4f79951a85cbd4a802df3908e93a77cbf4f99e0aafb3721af900ff39d523d5bce050ab878e48a430b61aa3a75a3dd94910c378cf299be748e1c3f69390e3ae1b0345deff5d08f3ef7e5e055348b15324822e803f70822dc83f34725ba983e4c820b2b75a3a5079140e9ae7b3155174a671cf8f8440e67294c790e43a49d2e7d8df454629446c1601a5cf4943856d5ef85939a7afee55501bf96a2f0137508deb048d8ed708a1ca9d072451ebb2e8e798697e76845e288e47e72bead665e3d1f1a5c04ad09f56f4273b1c41d59b9b842dbb65a81843af40d82d74b31df81c017cfaf5ca1b110d87d0f3fdd92b433aabea24e6fb0687bb567f110aa17e818ba4611d6ef520b54a8696066cf28f13ae081b34fdeeb9829cac6699b18fa0d9b63575c9767ff90a412acc7fdee5f22a210247311c4a86386da914e50fcc45581c441ac175852d3eba0574680329acd087ba428d054ec97bfdaa4f44a0f449c547bf516151fc45e081b1bffa842ab8b1f1231f82257caa2e1a65d03b9d42f3b9706efd4684e72322ecdc86625423aa1d439e14f6e3fd57cc0609b26ea150b5f4672b5c749fb668a61eee4a5f8da3e9b0c74eddd024b609ab870bdb7cdf20111eeed30cd36b7b25d9a2a3a9d54527de3ec1cfbc663e115094b7fbe5e521932fdf4e23f2cc5a19b119913291fc05ef67adb2c502d298b19d9e802a442b9c3b71b09f859a3247ae5ed2608a11c12ed337bfb10fc64d03cf14198ea6ef3cac8b8b656f00422f8513ef5ba8d8859e3b000b7c1ac27d09f0fea1b4bbd267b6b1cafafbaacbd1f5fdad0e7e437008756cd202375b74c3929d13f409abcc977de7d6c8ffad0d8fe3886b3ded528b85e4047ca80381b21160f858ffa9175b407a8522ba18407daed585071d2be3ecb28b358c8201d4f2a195b8b6dc2a6d06ba2a25d4da9bdebed22081a25b531ec0454aad118f4f3e357e06cee7cfdb102cf6fd384bd6f7aea2d467d705e74037c18baec2c48960615879d0a455306c2e68fc1fd0c9284b1a3431048b031c62fd16dcaa276f748d7b66966b836c390de5ddfa5ecc1f1e938541804687c54b3f11937418889fc28e5494cf4af42b6940831ecc85780e0859d47cff526215ee93871f0d0bf573190a6b0400880ebe7c827736ae9d6739583542e1b910b19eab8eca4194a2c00e9e7b268edd8bf70db9cc0604c9bea728b1a1fe10fa1068b8a9cd42fb0fdf2680b3af762b02d49f787b9fa114fd231bb62643d561837c51ca116c2761038de4058d6ee3ecac73b89ca0e35ea0bcb7d750447138736c6405717e613ad1ed7c7c847d309fc09b19870461ffdf1c83d453e6f58662affbd3742f2c83d42832c8f1661b2f5b4237650793aeac4d6b56649a2257fdc4af7debd8d51f44c6c9a3865d796cf9e8b811b4125bda835b5c46f7e257b340a8f4a2ad317a36a349d78d5161bac025eb643dfb73989266505c4f3f86a3ab29054099da89037efa99b9c61eb2ca02036edb14b4da446506af22acb03dc4c66c72a5de7cbffa0e4558d0d2de4240669e474b663ff97ec6d9e3a7a4b4995b1aafb4f0c660678ced4fcc39ee0c7d17061208c0f7152779b608979cf982d8c81c09cbdb090529256d6b27e4cb22a8a98009c742c4da3e3c69dd7fbd244169d2b92db8d26f0d7d17b8c2d24f7ed73582e26ae70a95235f024ee7ed5a913588351a2273ff9d2fb2bbe10ef79ea0bea8a05fcd799b8b4073cb616c99b5fccade6bc6d178623838add0da1ddacd1ba1a986020f153dfdf41757fe744d8a17cad9641c81008054e022dd431b36ab6514aa205c51968929d832307f85f0ec49a821ef7fb9d79e69e337b76b9aedeb8137b9de08c7fb2fcfb8b78d5b7229ab200cb5de38d5201c56703fb5db414f5d2e96ac1c53022e104d60f31bf6238fe95d40788db902f28d701beb9cd382d28a395e5568326539f9517f549a2da1833953c0f296c4c1e5d4eb3eeacfdfa8a42ebea15c647df7a141123ce043a378e9815582d26874e54a3564e4327ae10239ceb0075d1eba263cb9c8226331d1135f71ccf810cac9373dab703910caafd03d6210b567dd30d5b65a261c8a80a71351305c9feec256cbc831428f972491373c94baa758ad2a660acc745c18a156aaec9074eba86bafe285a30e47913bebbd89aaaf4556182430c6484a326822876943cd08b31af014f3c59965c17de8bd6a4f6ab2482ff4105570185ed2dc243c3d703baa5d67fa8b416054cd4578686f124785d656a6f487d328145e56abf35f9cc73b6220b865c3a40a50dd11aeec6daeb22eda1d4a5056af4051e07d48f754a3b613b7f4b4d8207eef74e59d3dde8439fede9ab154ca1a73da824cedf547f302b8de6ef1165f7ef71475bcb440691d4897b583c019c73d555fe23c3abba2d64c730eaa0898c72aa98d5fa5dd553f9252bb3f7368e94247ea0d562dfd546f5419bc3f6cda9d618079f5f91850917b90330ccacdfd8bd126020c118aee3102a28075d04d28f76469d7ddfa58e2eb7d75943768d282a0b17c4feb5821646eed3ba75a39885335e817d135de38bd96ef7d3dac166d36f563dbff16dd6fa329673e9170a5594af5a357d374319f82ef932c0ea176b0f80b7bc07a0ed538a95c2e9ebf14400a959e7bf658c5ecd4ff5b5ee177c161753b8533bee44609637d9b6241c26f922cb15df526a2e14693cd55a2bd89443b4d449a0db741e3c4098e5807de4cf82c47b7d14f233952170e2cc44a265c774bb210b257bd94c9b69e7b6296a789fde68feabbadc7b75b3a0a24b2d8c8993f469b48f83e541839f71a81aeda5b80154af54aa9b8554fc212eb77c9ecec257637c87d53eaa5768aec3adb47362917bbd40982294c56af3834617d4338f4eadd10601b04155a8edca1af3ec0c5147aece63bd2f847c8cfa015a4d95afd3b00569dcd0c823b1d8903f380d9a1e612f46b90d61959ee746a7d48a43174e314cb0ef987384e64db9cdd5c11a09f5391915d701eb81c9375b373c4eeb9813318dc367b9b6e99aac58bbd2f035e99bc6dc618184c37eda88e054f5d9f057fe78555cb9bf6ba3608edfa7593a964420b5315667fe9bf28fb5ccb8fed1728a0bee06adfee3a6cc4cd289d0c9620b26fe1b0d123bfa2ff6a21ef9ff8e01c343076752f520f73cf4a1b7c93ac7300d6907b8fec66e171e81a4cfb41a4fd4a797a3055e6ae392508a4a1c11603404bd250a059b202f4eea77c093a2f8732ff0485e3329b27d4140b50b34e6181d8a5243bdac84dc961dc0bda3bd875618a27f0f612f51f58efdbd79bc3c1d9683f3d331a635b66ddcfedc61090530d6f0056fd00b0caf6214b8c18d54c0e747c41b397657f8a5af48cfbcf52c55813ae353223c46617425a53db857720f9e90facaf38fc29656eb1bb7041a6a8e1700d9164c04ad7e9c8951dfe283919f6df897346fb30d57d55d3bbe2bd30c44c39e348da8b9dbabbda14a49506f3acdd135dcda1ac8c97b9a6b886fbf006bd473f3672aa603bebad20fc390b8c3b573cef490928a03c4355472182bdcc075ee8b5b5b78417eafd2232cdbbc147d3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
