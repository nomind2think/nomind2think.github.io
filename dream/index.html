<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efd6e229b2e3ed58162bcf7bf01d055f3a4190729f26a6e854b3054e4478cffe1eee74ff57c397a616b97dd3dc68be1ad1033130c66da76441eb2b046ff206ffec15a54af77aa713e6cf595c7ce2703d7139f42371c2bb3a10618f313af30e0760d187a90a3e4c1d45d241876035270e3df83f5c35a1542367f96c86c4f6e1bb6a130cc28fd59430a7d0d8a640d80671c98c8528ac633568d03a3421f61016739565ef385eab9cf1c5cdb0153b368849fc631dc7b2447d072ef1d0cac77f277d6963a3d8e2e6a6e23075ad7c747672f9aafbd289cf99b7176e718637fb1c1e8294b02ed7cbd28369bbaf7dcb75481490287bd0e2fdc859ad034a90d88b15938b79d5d2fa6c89237510524f60b184200405a5d10ca9828d920d967023dfab71d8c2368e048221ae53c32169b43e4801ab58b3ba3f321ded3b92325b3937e66ab9a166a75ba945621cab0ef8634767ca6be92c908ec07660fe3dbb7a6b5a9824ff897cf1c56d1cd444591c3d51185657b345075dd1af0ff3571f4126815c70c91830f56a71997242be4b6dd49dc3d16b072e1046c3c79cafeeb4ef4de3ee8167f7e42d93bef567d83b9854e910393da205b107cba612c18b5d43736065d78b97ecc9d8df1ca5e0bccf2962399a435ef588ac09921f0b1e3befb84161c803f7937f284e471deca262e97739b58c53fe4c1a17b24dd959dacc1994b0977a3ddaf10e91fe89a48944e203e739c1af41f7dd0b0ea120885c5cbd4a33bb90cf3db80a1f0797e8dae754fdca87a4bb6a5865d9fffb2e4fb1014e5c72eb396148a752c257c99e235cc2ec6312ee5228922c294aa4c05fa22f1db5eb8c7314ef273f02a20c37e4515c5a893c561fcca69b12c7bc318e93bc589fd27826fd4f7beb15d49f9e6bbb078b1f146ac1a3d2704d375dc6bc14cca11e0201adc766537b47bf1cc5e72fa7c8717aac15717b84abeefd75d5a9172b24d98551abfb14a41d0e212cd17ddabc6382d92f124746a572a56d13f12c0d9283462e9ca621b28b72eac27466a1a54ca4313a03b8e399898c4614a9acda11c42c6fedcf930ced7fb8f5f95421ed6dbb5e594d920b1cc65274085f7bab54c33794dc06694aec80e1123211f2dc62979e891f3c56348bcfcdc7d4ae4275115e08ceb3bee7eec815a62fc7284f14655d9b8207166d86b008aeb3c5f748f5f019c62fc40e6834614a21eeea6f6f6954a72dc7c82f47dff1e7b2bf2c3a6c12ba9b1fa9555be0814ebab8b245219bc3ed48127b04ccc7ef60ae9409b79eec1a2e9396aa4a14d9e765b5f76cce66dddcec013ca08f77cb2c5b9f371cf388105adb6f82a167f3300039249e276a9495e3ec74b49176fef3c134c35a9c74f760eb2f3587308fb660ab7984c31192e1ea11501b6d680e81b46da0a3eecc804ea8f2467805f5ce55e72c3b7a8d3c8151b841afa2e6d3d395f7804f749e9fbcf2b65602733bdf937360ce12df0da0b770ffe7f481953ee1335443a87909993825662f211527252fb4be1eb6eb751c48a109093d683fa4a19b27a2885d7450425e90e9aa8b8766935e2044457d82f3903f4f532e167e4e16f71db6960c7563b23b0b332c645876004085fd9beedede03356f95990bfb13c5f1594044921913338dd9dac97273a3014ceea36904beccdf0fff9b91b4ce573fe9e37226d9deee18a8d944d29e8821896d53592266297775931261e163cb09f7377e9c89c55052ce14b573787e781bb2d34aff057cc932ec3d78dab12a5d4a62585a2ab03b992fe63be6000fc04a3eefc3fc7c0e3df5cfc21299eea15bdb8c304c0777f7ecc60403a12e721f3d77da2c460b5ff375192134cb2995c09b8a990c305e02f16c433d3d8e9931345241f252fed19d6bcbc27fcfcf1f1c33bf133bce9dd975f285403e7c051cabd5d4dd8451098b23216e81bf6f245d692b011f662410dd9a585faa1c9539aee9da98ca0bdd4fae7c4c257013c35b36c1b203cd092eee039490ad972695f630059bb72a5c62b3faa67e999ebc21f668c809e5cce39c8389a9d3527694514fee3e2b31d46fde1e111951a08a59709183b57c0ca44f2ee4e6e36de909ce3792c88cdbed83df2e450e4d454680fcea8ee05bbe8c9be428d9458505a0bff39b70500d56960c98d2841c26a8798768c0538622fabe260d8533334989d7f49d1132c84a72d1b679c5aab997b8885fd70ab9e196638f3157f5d0190772fae860d62a377e7c1b34aaf3f416d81c28bbc7fe2b08d1a7eb71b5540ba701f7224bf11ac1ea05cfe69ea48abef9feb7742275217964dd70cd63d70d5e115364c336753f692d8b853ce0ee9e4eadbc9778db304e3ffea13f37903b967194a81b81fc5722e3a65900224414fd2f85faf7eed410d47c6716ba922ee35a93ce2066b98a176920ae90893ebe90c4fd699a3c66231aea09ee2480a2b34efadbacd976365a8cf57bdbf935fdba9869517d991fd1a000929b20538971c83b2d46be076de8664fe5a0ce37e014fd1ddc9aa45105fcef65baa429b3b25edeb61e5476cf5b005e8ac0a493ab7e0cc84cf744d5d7ab0ecb534e8399b776ef5514779d414c9c7cdad1076f95cb192f5e75ac903fba96b9910222e2fd137c9022c0abf442b40ba4aacd30aa86bd0af458905179247d9e79bb9e4aa204c20961fe45418fd01d84e81a30fe767e7a406e1de6dcff7550d5e6ea9c43a0505c0768594cbde639c79845f8df596cb8cfc8fa71defb28fea4194761986509b0e84f8489e001e33a4daa3b17e7c47e32e001902e4a2845255627bc00161376d9b0d3d8044eefc586f111dcad0cbe3557a749414fba64ced21dfbaf50b7bd04a4d801ed1d3fb3b10dc9a76e6f375c53dbd901c5157d34cce13a5b86412433b87727c171fa4ab54b5c0cad4d8a46e577344b00f86c18832edefdddd8d9cec14bddec314f05f470a544e8c92e533a2b6c543f7af98a2e5d0d70eaafe29aafce4eb91c3ad1e31c8b2dd413484a811fad416029329f741f2dc87669e2ca910ac2af322de52d6da1f4447514f339e539940626ff68a28a5c727d522da9b1edfbebaf37ae3777507220876677bf8da46f8e5285e4ee721c7cef9f47f8a22bd162057d5b1fad50968d9d29762f44562cc4d88b77c33c364c980262436ffc328e25c65cf701156c4c62c97ba10bed1ab837168f8dba5995c81bee39d0355f75c683f6931bd0d0dba673ea52b75925c252e5e8d9236f6551ba438b7d266816e5b4369d38154fa8a5590009ade412314a74cd9412e39f94ad216411b2342bd9335f77ae349545398d5ac82ed925cfd5aae55d92ca7d98d588dcbb5ff49b73034d354b807a09ded0eea5e650be78ab4f74895ad3d7ebf91245e98d8832a9327d3176911bec8fe4dd63003882ae3ae6d2373c547d7071ee5bb6448ea279df2307e05bb786a384837ffacca4fa82b77b84ace07e952c0bf6752c9b7ab2336ed54e7ea161142b83b2358fb0db5e027948a8080fb92f8ab94292ad498758f82360e5c247f0ea15171e983f5d4590298cf187de87bafa904163c69aeb00384cbddd47aebcbbedee1eff7f8bd6cc603914fcbf376354d49661a2718baf91478a59301970fdb65f63401794bb51df0ad8db8a44cb9ce015293ae219e4dcd8661297f4e8851a4090b46bb580b1e46c9e14adcca9767795b108bca6c9a256c94a537956ad6acdd0015b126655106b276fb478f460793d8c0b09279b0fbe23dc73fcb6df66bfa63f2e5ff3dc8b4a7625deec9e3a74a2889e4ac67b2a72f8531135bf8c495bd08bf000a740f01a81ac4f3ca6691f8592b34e131ac75d35635698ffc74e5bd01ca8b25a58cf5e6898edae0ca21426005cb8eface40b25271efdbb9d99b4c44b5d239b43689905a9c02e2de7d0c7511dde1851120be41b11cd99f9d079d97d9b199d5743464170138a5863418e194a576ec467bde4e3f71da62795424f61fad2795338d53eecf51eb3f9943d79377974dd747c02d7dabb6b4d52e668d03877106be5c0ebf809842c5df3ae7406f2ff4eb4f7fc10053c3617493b689495014473c83ec1c0ca0084ce6ca15087c3221ce3b9bc27a46be2935c9433f390222a0a2e0fb8362875a5c9ab413423a87b13ed7da07c9e62b1b26aec18de7b416c4d302f4ea594202fdf0c74d2d1e22059e1a2fd10eb744d6ad2ad9401e06b1ad643ef7d79e142cd0eddcf858656c9b26e952d73950fcda0d5e4d9b07df628d2703e54216bac332800b73c4801372e575754f5cc346926a06ca453b413fca4cb4b5fa690d8bea3602f51cc159cd5b1d1ac984591b3e9c1cc5ac14c36a66eb0ce9239da8a562b0b751613471a2756c27a9756205d1ea2cc0e0999ce6704d77c00e4e3ea6e5f14f5b7b960aa6eef2e349a1955966676738755519261de5b3b21d7db653dd8e7f9f8263830a78f155a281e55be2239b8ae20e2401f9425c905342a000de177746d5485cc52699ad29e5a466a58f548bcfb12ae53ba454ed6415b1e7831d04171d0317dd5080abbc10d6abcc7bcb577f807718ef7054b024b70987f8627b7931bd6440ba5ee8f28068a434b5365337befc11647492176a55a322c2c1005431dacf16d048b1f1eee9e7fa37ffadced6035d049bbed199e096e9fc63181f6c46b893335d6e88a8a7a37e260459b6f48ad3baf70d3a2d96e5a533bdf09627c20cc4070f583d3a569669a78f70f2c401941e842ab534aea472b899e341331bfb5fbbdf6deac97627c5870cb4a24aa37bb101f657e5246e23790100e0bb20dd20d17bddc2390346f6be14b1800958e4a9984709a0362cb375c08e920d5bf40c729c489c0f1366b5cbe430f29285502aa73a6afedbd7d083fa0b6373ea8137892d6b8882b9a457baa7906712d9dfcf3912962c198ff5018bfde96013670b5b10892a1a5c3bb1c4b7826e589a7b8fd935dd07f4db0a6ac09a57ec3b549eecc5b6494f59336dafff6422fa5eaeca3b2544c96d88a6839e579e7d1aa002058d1a78dfef3ffe52b2bab9ddca32bb6fabdbcf07fada4748b1689d172013798d1af0c83157869f3cdba46ebd7d5f2ff1404476d03957cbcf4cd180ea72429ab8043c9df977b75f896570071893c446c728f5910fb1de5b16f448fd5fa1b8e46d3db65f1a0a454b8a1f49f69dc060c6fd66250f0d58bb09b265eefbfea5b5d3d449b58846ea156c82d8065a5588061ad882f5ef21cae4085266ccaeab3b8e5de1c0837167f5c14cc5526809233711179b3db386f6fd104ca087ef7dd9ef51d684829de56254403346aaa60a1166cb4c5c000fdcf83c241b5d16124a95a96037d6496016fec099f1a74ce4156b640998b9638a819a036d8acdf485421203ec0cfa200f9ca2b25d4f7cccd25bf8f6b939b8cf08844e125d82f914d2bc1a7952c0e53594682c7dd29e072e95b1ff1c8a93a3f5e3279fe1fc4ceb73e4afd471c35713be9bdc35d222f5e5d6fdb88dd014fe11ff516ac5b3d2a38ca3857dbcf52b350bfbbf1db5b559091bcf4d9960385973b43e3445a297a77df1d443ec1ddaa2d36fb4361e765c5e3f028479966347d6a0f5069ea5a369c6aad08fe89ed994b7d9e60449d19124e1fa5f1b6905042aee9f27ee5b220b670696b3253447c3295b57b4da022b76f24befd77536772daa59c50dcd05cedeebb711c61f9feb659eae05afea7e6466db5f84f40cd49fbe10204820f4ae7b6de62899d199b268ef607c3f3b17fbedb23ff15a37aee4b7ab3f9d2ab892cccabce9a67ad5e08cb8d9df85b2ae618118ed19eb6770afda043a0a226aa12eb95f7a1bbb20e1682f5127f71ba200337ac6ea78e5b16b21ee8c88e1c94f50a85c1fe859f4a6cb987f533c3e4f78f826852c1285e3459cb868fd6493c133f7b6d733e53160b543b31fa7898c76c593618985f734ab8f6ce8892734755c884186e42eacf550d1e498f5e9711b96c68ca3fd1f0b3c25eef454f1f5abdf3e4995fcbb6b56d68772cba1d92457197c92f242311db94f0e5348b8425affe4fe3a6193a3d88d3338d67f5a343539b5c28abb0f6297fe0269a656df5bd042792d3d7488a81e6797cfd14dbb8762ec3b8d8e9605b7aabb08e9dbe5c5a9cf25151d00ffe4fc50bd958ae0151d2451b879d5e8cc2bb6dbe0433f71f079a5cf5b9f3da86e96e87d189361ab6658db308539a3b7b7df982eb43272b899069307a9b1ae4bc6bd85f443bddfcaf968639b3d4c430efba4d528afd8cb2ab4128f708dd7802f67c7712b2e4cb86cca58e6af4da28e916298fc7c1118b75c3a32fdbef6e9f185d3327c8315c6223f5398db0f252480d4042bd88c91b826a37fecf9e1cf578122e1a939256663511af750ed47172b97e21806fe24216fda3ef81737d20180585077345b08182f3e9c318dfcc25219020ba9975f6a891f69230b7de65b381402e2ded774f80d2b3475b9fcf23f6d9f75d8c66ff5953916367f474bd4864f4555d4c6c29e030fc1484c30423eafa6bbec7a62b6fc894453efe799869e8bb2c357d0212a36fa7a29805bff4973c4061d5a58bff29d72d3cfc8c758f7ff2c0c63a653eda53304a69443977039610f41fc59b3ba6662362dfe79c60e89e98bcca9d33d7046bd1d4fe1a460ea94b7ccd64c746556d1ccd4987117234e354570fbe272b2e3434fd1c2a52e5011a2564678b6dd9fe8394b3b7f08b219df31dcd6b6df0893728b6b59edd3caf734f39c763160cb081aafa9c1d9607a69f1c87aad900e1e22b5e02f52bc0a9623ef87e7141ba704e3c164311e53bc6d6e24f061906a0d712288e1dac8303b1aecc802731c294744ba06dd184cd303376a57e5a12ec883437cfc04d56e3b3cf72ac63054f53abd2564df796ee8cdc6a384bbde0a35bf733f2efa9bf0ca61f56a60c91bebd9ffcbe8f4a1da563ec79c89261c65cffc8a171e66a85ca1de5b895f5f49f7044ea69652a056575a2937bb067aa07a35f1eee6b1e32137ae27e328697585babb547add8405939c7f849fd392375327677979b5f4b62ef7fd5dd940b6af3c839829210e3e11c8514061b7272ce3479ccbf320111da53c48fcd99d334ce8dc47c33000a25383b95a885c4f062baf7efaf812eb6512752bb48ecef91fff63610a7712dacc6df5e3ce09e2ba3ad9cddc178bdd676ba8dcbc234d3779a2c5dda1006dc2d1d55cca5216dbba25451c587e077c219ebaa0382a51176b0430c0f8b4152b546ce1b18377cf527e351ccb62cde3e8ec1c0d371789f5b81a2a50479690232933e4c177c51a59d806d8f091277dac69408d92ed9c818c65b3a2e5e0f7601db5a918521ccab112cef92967dab53a4ff3bf5a29648a2cb8a36230153ad1f647eb2788d43cd747c1d58c0bf8f2795a1820f836ba89a643465feca8d52bac3d774c5858d29b880b309f938ed6ce3aa501ebeb520b9886abfdf5a69cf9f35b2e9394563468ce5ab265f335174c76fbc323672e2ed14ea5954728e1eb7f83fdc6e2799c557f02bc21cef8ceaa95312396e787536f7722c7399d43c6c7d99b81160c1c85d1b06cbf7ea46dfa0583b424664246dd46058eec17c204e5b71859c9653e2cd5e6fecc4c637e38c282c5f4a0e89f72d1a38f43768f42a8d56436eb79d200b21de15962351da6ea8f4d16bfd45a3ce00a0d86ca52c1f371be99c78edefaa6c127e6198c8b3db0e966c50dba8c72362afedc1dbccb83e070f0bb99ee08e4569ee68688dd532f448c3b6a523bfb93aad88c2d5acc418271fdbefbdb60f4664bd690975752f4a0d81184b09f9239a6fdee4a542d42ea09f1e4044620aa6a09dbf8728ef09f1b61c7db50b521ec7d73c6b6e93c95732f40ef081643f395875fde282bb7bfad1163c5374ef26af695155a8de95d3b5b8785836ca81fd9c20cdac85e523f367fc43ac37e53e74a70acaaab25bfbda6bf51f4bcbb4108aef6b5f8b7f6e877dc494373bea901ba286c6b8f0107096af44add1f80608fd671236db5ebe211775e5773465c64cfa593bb7dce8259e36338ad3179402fd3ee8f7e443cd7ed240c9bc8a03618f33accc258785523136b687c4303cd52a90a0d0650fa890daa20d13097a2398630103c7739ab7b53db98b1c6c3f2745fafba9e0c7dd22ca45d0d277d5cb1386d111ad1d02ebc2a8ddacdd606414b6104ac59763b3423f93bb5160e2461b5a266da90221291e419399282a6dd0767ae77588601a6dc39f4a04407e3ea04b6d63e203316dd72b86aeba919e4cd043a35e0185715dabd2d011551cbe08736ce9608f10b0b77b3b5d4bda40b2dacf296b8b354bc5437dac9af353819717798420df4a491dc8f2cf7dd813129dd94263838237f59ef7a6b8db26cc2734f4b3c68733d166b4aac99ae4afe340fec7bed2234089fab3be7315e58e482d3ea077485cb68b9a128a5727ae880a0cfb00ea681feb4792f4512f4b32c899ba2707391af90742fd69dd14ca1743abed475752947e9fbd45a91cb517a025d6de720b9aee4d99680cc08a92263dff2523951d30a05d801a8e05dfed33b7e7b9a3da1fa2529f0bd80b3a24eb8bcea762594fcd89ed2b737d6b41215b207fff5d2c7fffdbd5b10325f2ca918f62d8c986d1a0afa635d69b89bec5e161d850a1e8b65c79c0719ed15f75095128c8c27106e9d4360a2c76e1b24cb3c5a1f051c7c278c7ac7be5f6cac853a7e5f67418bbf0441a4a89f2fa563cba8f885767ba30558872fbd32f9e824091f8c3c55e438812c7aa09bb78a97394de0e7d8063ce2f62c772c9f64f59179fe9e460a86cb79a91e4592b140a596997bd140412dffb25b17d050914dd9721e81c026fa731e33cd4f3e27d9bd24aee0828eb04d60c970513429975147a2747f7abba62039919a765ec6890bbdfa2c13047d789b898492b34fb534e775e7d0052498ee14652efd83fe5bb553d3d2a952f7a4e775553b37918f9602360291e02766cf4d4bb9100faccc30f650599bdd8a1f9ff6e45b11bdecc5cc62f9b750358a08c8dd8805c6b7d4865a0e001dba24744055dc53511ac86fc6ac530b18a335e555a821226f0c1b7f2d0b241958e7432e5f41adad9e7dfba7a64a7f8c49ceda8d25a0dc8992c2cb829e2a38a2a3eda8d317ddf161e304169a1f9a40c253e3cd6d4483a478acc237542d9eebfd47d89a291973a7878ba6aa074da03c62ef06fe3b97a78d86ea8ca937a28f3775f15ed8eaa2b070f96c312679827e6da8c6523056d39fadc60e6f268f3156a87dd2068fcb525896c44980e6a30e39ead8815eb0863db36bb399ffbd30d38013d1b58607231fb018f371b242ab79c25cef1bdaeeb845cd0a3007ab588bb600978194fbf751a084f27c1c87dfc19a08b5c94073e954ece1344ef67a400cfa93b307335e6466046b0c0033d169f9b2a628204ef59d15afc095321e48fca4863311dbde15b4f583ba10904490528f93c42119847899d85a103ddb54d36aa2c3a2638902c40cc90cc88e29e81cfbcb28f9f03fe43b705f3531974561004f3d5e18f70a86c3a3fbc0ce4d352d6e658aeacd03f9519b29a70e604827af1ae39fb8d25f6491438af7a0f406fd506b9005e532697bd468f92b6ffcb0593977105544540094e815e8197d280c4b3acedb0e39edf09f29c0819a1085f9dcabbdf61f74a075e4144bd866c7cc7cd37954f444b6959e5a22db1a2531c883b2fd80c6b35f019a56053a8faf5e0b97c23fd8dddfbb90d58f1ee7e18fd38718df5f9af7cdfe35686d1340c47dbfe5741428fa9e557d1635be0bcb20b0f1151986b92f20244a42fe39dd8a4777b50cc704c1308480123a8277cf6c99be31416c4136f4efb549f079ca8c99b1cdb4a5d58489df881d8f9b58afc203488710018f6c26b73530bb6ef2cc9cb9fe329b008d61058e191b800b6085b4bfdeb922c7fffe3229036696523b7f51420eb33bffd5cc2cf8e8e7f2d424d90ca00a82d404afc74a7ec82b30cf216222fadecdb1568c6904ff3ef37c079ac8506a8a2414e0ed426a63dcbf75c23321b4beb83cb2676094cdb671d82723a0643ac3edcbe6966e727082951f27fb5e1320c640eebbd1a31440624197d30a043235e3b1a5e5d7281d9da19b989ae9f4def50d676cd62e30c33f38728e3e1e72f330d8f9aef04ac22cdcde90c10042012b637816017c0a7a2fa9236836e6fda3b930ab4b34fe297fbf13b1c309463605ab6be48a061fe6a157e7500fa3110ca48f9d30c92adbdb300b0a3b08bc9d208dff0ca8b58a9fb76948cd89ad1b1b5858e28dc75f72d42fcb1fb475f1e8b97d69daa1b9682de9338f56ff8d44fe2cc7ba1d2444a4a6051e4d04aa7f9f5f1b58875ec1a7a16388fb9f48346374d4aa411c5820270e7af228e0a5cb8f73a0f45ff3b7e82deef55250e5dbc4abf4801e5966f1e55eff3693830bdafac4e712f02f1a063f40d8ac785ebae769b24f40fbef398fc6aec9b3048486483c02ddfb98fc7c146fdf10d90ba4bbcf63945260fdee00d8ab58a79c57b1584df30a4e862356cb8fa7acc05ca347ff2aaf142d2e3da5b9658400066b2ebad47b39ec9d67890c1473181611007ae0464c42f2dad5916d6605befb564bbf284af5de54c067830fa5bb3db362084504dfc4c40ceedc0f1ee828d0c63b2fc7f4b416a89a48f93416f0f8cfeab9a2e847b5a5f3cabe149bbd06adf63a466ff79fd63dd9b177d1abf1998e1f11c1b0e33946e02b73d229b6758a740a7cd92828115f689cf01270228e26b554b066157f02a93876e7715ed20b01941ed75d3d115e17caace6444a993ddcff51f3eec7883b629e6738a15330ae1bd4fb9e3ea055b51eff0351526307832899fd862e9cfdede72b0915cf77bbabb9fd7129435f74fc1562c9c5dea7fc14a64894d96950332e735c376b617ef5bb0bc0da1fe9bfd4858334e6382b192259f7f7afda05b246a9df413b0e2e14d2db16c382c5f112c4947263f4d941b94bd7f247a9c5ab5a93f0991976c1da6de8909ae41","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
