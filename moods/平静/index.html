<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f24942650a00ac51f73996e70e291e1e8bb416b2185fa61b4add35ab43af1cf243d34dbd8a90315d306243bc28a4d86c686717dd3104ac6233d49d15d5533975b755a0ea64b3df797177b5c9564ed35de16b9b55714ce494451b1670b86717d14938fed0c6ef792a0d32326bc7becaf07962029cfa4d53b1a52fbbbf9cb4f2d2d482b7d5556508046ee3d90d958940119777a915ed78078d39f7cdd73e59084c28b358ac026126bf94f6e117ac82e4b41530c2774b2cf068f6ef72b12acb63c64ed1aca435810ec62b558137d345a5e26653037bb5752a13839a95039f5bea1380d2802401a023c17985593bd838ce9a89e72ce2311b022e1cec0d9e0d629a3a239ae77c2472a6d4441ca62c9f57e7f325c44141e1e75ed1dca34375166732fa09f94d179607bc7fd6d3095e684c3d4c08a57ae6e764a1e4e48810db83c7f9f967571ed849c2ae25d69f4160b55ea9b03e5d72607c89441ee0cf482ff8a9a77df9eee32466c33fe6095e31b1d1bd11019fc3d53f02f3f2fe117275b912ea58ed01ba1ffcf31c7bdcb335731f3383a5ff4cb66e44e9453cce6eb02a08de5915ca3a0bc22f2716d2ef0d19af9aa0a1ddf6bdf91cb53c949bd49b5a588d43b3d89807c19f286748e28ebde812e947888d006b2df7b819be25c8bbe1c4b623a07e731592a70e302f18ec044c43b3b7176d58512c3cf6ecf41a2db6dc0a30a4e1e6c690b0cfab155f5ae8dd424089cf4a572e01c8efbc3b611e607ba1a36a0cb5cd457a78f37b2d6a9c573c190f455b143670c06d71466cc22dc6dfab14f96808d7448e9459105e037ef959cf2cdd84c1892f633fe948329d9cb7e30a65cb423c6aa7a976e97731ef676a18ace9565f9d5812a59a0c2f48d54994a6b862a3ad99d2cf4fa506823dfc4faf77f83d416d5574e625f604df29e822f1d14a461650c81dc3c05ca778a2c299bc90783718109b294817a7c87b767711d76016a4db1d0e9a27845388a18e1f040aa18896aa9a26fefa9ed2ee2cf7e09567c9253c1d3826e2dd95e68b6f2f61a5a3f5d262f68ceb75c6ee86ad211a3a78a62ea65422fedc1fc8b7aa6c260445f471aede665b73f86467b97b75748997bd23f482d67add8d5852975041b9dee62bc76814e8bf9c9dcca75ce871595677fa2287280e5a68143defb8b3055212e48a9839462d786f5697868ceb0c1a1bc6802761651ecfd238cac517c7dd0f72a307d8af24e17a6a5d17cf705c786c70d2c18637e8b8611b3cac59fe01c44365188da437bcbd57f1529eadc692fd150ec1a7eac87ac79f23618680c52144f2b198b97378fe27ea2aad268c6a387c569157bf14e2e891c8318d0f7853a51fd203ef9d6301cfbc3d0c3dd12ec803f583e8b5546162bed2b8aab3d5f792b80f9b7259a883d7dc09b148b93c74d5018f187fcfee48feff81509760f309bb688f2d10a7247e4d2f304b4b13b72efb9a6fcd97e6c4c2d96a4102ea9332efc6711159a2ea4721c60169dc7a322912857cebd81f3e119618b811ad1cff24dc3b584df0d55c92745fa06ab6879a26d97f88672ba3e1d886f161f98e60688ab65e5632c0e7e8f413fbb9e0369006da544474d7589d1388736b6e1f7d25f772c240f6449bf2815accfdf5c203506e14e32066e2a4eb72beb5bbccacdd73213f8f977f3135092649dd0bfcdae6000095eee842ead30cbfbce8d6b7ab152b2afa5a81ae0076f04ea194df0a8f95499027f266ffa25dbe233fb0886ec8e0945e837b7a12a48bbee89e1ed5172677eafec93d1455d5786b07c6d5591841c7d082c82aa899f69d144ef025179de6800633a988f210ac4e538b6d96dc7d4063a3c1c0df75dbb9a7d8b3c4647781b843169ded9916a389cc3a99aaabafc05e1a9c473cdc9545ad75dec73b0b154aa4d51e846c5a677a75432379e6d4ef4755f8f42dfb2fd53e5d6b440a1b3fe51f9bbf1ce3f739448a469bc663f38a423f461ade4956ceb821dfcae7e89a0498914b82c2218cd4a065a6775ba76a8a89b43afb62e48b778d88b43391fb842c3dbbd3f3c357791c47e74a25188646a257076d2c8e901dfbc35bcc2ae10f3cb9ed7d07d3b3e12b555edcbd038508ce2974deabb1e8d1a101e140d53603cb077219454f78b2d6568caa912e580b49b5111fc5c231d59287744dfe0f7c96e4356840395998cb04d25a3b0976be3785d87e20b10635c2bf0a0b83b9a6e7380644737dc10f5b944a21dfe3b815871ecd9b879d515bdb38536588e75c7d14a530c3997bc8e1b4c39243f74fcaf601dd20256a30950ddac16a54fe707dc987b141b5cfb6074a1ac7ffe2e7070414b1a11d4f7669427eedb387fba9c3b8ddd2ca7bff3d5e6b10849abcb27c8c6d298a7261ec7ab121d13c94d57ba1ef1c9c62d9a49d6cedd702fac75a53c9be856cd13e74e65259c7410e9d4413cfd52d97fe8b87da26f41c5518dbc360eb5b9b3b4f1f8a961f53ad4af16f0fa39f710f22af4d3b2d9e585f4cf6cf2a99866b71ac5b1a4b5f96bb1830acd0e0c59ee19cdef3b8ef60dc50e85f896a65aed4dad3b8fb63b297b1da3ab9ad70e84f44c6032b539f08e127d14aad1aca14d9d970cffec72e4592e7bbef6847334eb8c60b1dacf5ada772d348dbeb832531c020e4a5a33b1486be605ffe4b9de88dc4bb133e9a2cc16b17e108b3a38ad61d338ae88ac657239df98a2ccce235cdca4f780c4bfdc621822da185436a88dd4abbc9bcdda786939e9b79540ed2192d4309fe591c3db4073b8e52e4a0cf2984552a28b3250b4324bac32368faeb35af6ab658850841580826f0509bb454b051ccc508facd14cc61600b18adbc2ed311636fca98be7ab5d5b83702c7b866a88467e00a38dbe42f63a06f4ff9d9e1b0ee95e2fd5e3cf71cc353cb245b04a358f4597bbebfd0040135f8aac87370b0ec970a37f2de4387d6393c8de9414b9ecad6747e983c0cf0a69e6c0610684c24a2d1c1b34dd5cfb56802b5338bb6450020946b4b2a36ee72511c61015be12c80a36b0dee59d83979ed6ba0789a3eb448669b6af09db92e74b5f2280ead9b0da1f63eda6209d28a6b48749c83405886d26cec5b82ff7acaf574cc151ea9700adf76352366ecd66d644e158c071143eb3555bfd3029b4a174ed404aaf37d0053f88bd04c07440192eca4a413e492754bbd896ce8163739a5f141efd39a42d41f72c2966a92380c11427334e59dcfb898c88769084698f628ec781a04d8b55ab6d9b1127b6e07fe9241f148ec9d5c6eeeeadffc89d5eb0ae8affc754483641b6477d97bb75f454d500703d37cae6566031ed314f8291eb4f8dcc0f11555d1ca2dbb364354c234c26b6392b2de6538ace6bb62f670e7908a0fec8581a36e917591f9bf67c7366fea9a41f5ce98177115e3b5d87185f9cc4cdc3e46986e24e08ab78faa53f0f0653a9d72f627325e94fe0bfabc356dab3841073f0db4ceaffe5a0e3f15a5a750f40732f9a310debf8ddaa9c19c13624ab25df7ac597a71b0f19e61be8019a6abe2a12b57649dd00d510be55aa631645b8a7dd1f3dc2a9ebda80c77dc66b996c0a9f8e7af31d19073f5c50b66de62a310164ecfb4e815576bf42bc929706f4fae04a3482a279cfef22652b3d4eb278378d575dfd8557f01fbf44ab9fbd87c3fbbd2ff18f97006177b71007fb3495874bfb4be27bed79c9d96e80c07745533738e987445eab977d3911cbe5ac3eea8be6f95e3991ed3b03b08aa6deadcd7a06659286f34629de357707f166931df02ff538ee768535483ad743a7981a56b6530909f396f8d1d02a1d05194974fe0cc92b7f476546b4aa6b836c1a7df2299f4c012eb0238cb9b802005b393b05643c555831129b37d6bbe70a62e16579cf226af046e4b39cb8b381890e26d003308af81c3d2b6dd7ce6808ce8bf1f3280f1d763a9c11f0cb1d34f67afce1228844c34117fc7fe28e3c21672511ae29a0aeb606c2155f3bf328c81850aa94bb99b15fb57dbd1af853713bc9a63cece68af8c47e1fd7b82da797cde4f1bfadcb3d85cc8d02efe5c91bffc53bd105125f6161142eaa7da1ce1845f0d5ba82481f34fb977995bdf73e701603fcb9c15df4d361ace749ba56ad1b40c53980a71489687f753cf46ff33475ddfcf0fb12cbaeb8d3351c2e17bcda432eaf327c0928a63f5a4483ecfef7510260c0e48da116a48418dd8db0872d1293d120227cd456ad7cdfb823c5635fd39bc801fe501b4374fdae999a23fa79395d857c69acdbf877a49a466b54476824f64f208c67b4b3d24d64ea831119a5018a01cb4ea32b3912e34ed7a7b4951ae015833245fccf0cff9ff37f874ebc1c1c83d71b58f1b477773dd883e3c42572ed11855f043d926470e8dfaf8f99ed0107fb9fa55043bd37d2c99bb19ffdca25af891ac96530868407b7e8518b4c88b0adba3ccda30d17b188de343ee32c54e5848307af30290c5a9bfa681ad309e7e67f4d70416a739831d2b071077689e4b44907fbe3c4d19f8dd12a4a97826a802805170c97bc3725a22dd2f3c1e0ad35a0d608bb5015ad27ea0265fefee864f999f097a118daccab9e28ba2a65f28f527f4cd75224507128852853b9a75a3cfc1b0e3792363aa141710ad8505a950870331ce3e08f2a763bef5e9b672844b827071ae00771d3070ad385426aaf764c72d9e4d927d62145b6298d39b71c0f8b3c88d6762cbd594f5c5ee51ae3fe010e48164aefb9f71dc92bd3f9768728c2c4e4aacaa2d7f6b64614b8967bfadc04f08ee3456f7385a405b5438b7cbd6cf610a1944abdf45a7e6ceae5d34391c3363ecae7ea800275f3f57ee394767f7745e87abf09032a1741876333be3cabe71052d1247c0826360004b5a1f801810b096ebc931beef15a77f74623147c2f5914b153b6691e7a2e8df3a862fc16cc236d8d7cb99a2809ea9b37786a1a6429fb91d28c4f0ece864d102b53967aefd12c528163492bb16a06fde45d52b618746ce429714cf923bef9d92dff88183f5217510bddc20a085dee02c03dc39aed9bd84d406b8e1aaffa9a62cb636b905a5fd54162c49b666447898439860e6331d308e522d62624bc2c34284a514629007f8c0d5d722eed9c58c726c18be43e1535cde03a8d6b6cfbcb33cc1857498c5d064a5eb21d2ddf5d1d75642d2ba5e18b875cb7da8e1e3e13e7809aee9f51ae4d9ab0f4995439baaf3f04d54d0e7149ca781e1a272edfa594e63ae56cae0aff23daeea20bcde14ae8da4a48a0ed14aaebf60e509004e9b7fcd7ffbb6bd5372e303dae06fe4c889b48c4e55bfa1c08f89f166d7988a1d95f249b9b4cdf8ee9f206e99f37e9f7d37a59d5ee3431cfbde0ae6d94c1b17f7d2968e2f1214243d52003b8216c2788984a497a02d01b426e32aa56be30756398caa2a6e55a4e1d35a3c69259b873184b91cd59de96a2a47432842d5054974eb67101b7aeca7e99d7a204d491dbc53a86a6ea99f3723038d10827a8a631830a6ce21bbd2d224731326848cbac641708ace1e007236631d46bab229005801f61650fcdb01a44abb8018d7b5683458f1658463a593d5a8afc3b8b07b8b096eb8062721bf5c98bd0ac83430697458896ec5a7b7c7ddf7517cdb865579022b83206694d62538346aef70c6d5d1c2fe4fc635463a1be128430b914fd2a1bbcb6c8db150d67277a2c3f5d363aaad4a45d28ce2b25c1d5cc1857cbba41ff005beeb1e6c411a7294d27a65a18fc9bde89f2e4fc4d723d10b6174b5e1b9559819474068a87f3e8ec733b078562ef320c5a31616645caf16fc9823f800bc4e919659529159e12a446846c25994a8a1a70fe51685fa4b90647280281e2760e41a10e974cf2fd9f0a50149ff9e2d78b0ee5db53f3fb76f7d57d7c929163226afccd4d54a68de073e8e94b5fb75ff7506c8eaf45608bf34eb094feeec210320122a2bb7e4857dc134050f644b4e03c9e294236a726421a6310a99910c04404d5e5340aeeeb381ebfc7e2f0d7e40c3db993d425bb2b2733b19685db880404d69e0bfdf74ad0bb7a84f800f2d1d901d9b715b6fab28e71d8f93998fd62e0b8a4411fee23c3a357fc877f0e275d7144e53cbcb361fe3ccd753416d0412ef40789c6c0beb68161bd8411567da94e27c992dad8a927fc028fa49ab65c1834122d97d9cb5a6d25736669a8a2e641a27af0ef6ab81b25b6bd04bd87a28107e76fc8b1232c0abdd98a80f3a8ff9516a958b6c632ca91652bde34659d40bd7481be71b65f6032da76ee0645d5b26b78752ebdc2170f0d0196fe769f6aab51113ce62a62e66503be35fb79fe0aa9261b6987bfb43d326445529a9a59287a789d72878d55972a5181e50485aa98a18d858e5a44b13db6948b4f767faae3cb42b51256095137391a548c93693b11093db704ba1675b6e03a350eee69028427dadf2823425ffee5a946bce6ab113d685350682f8defdcb7d365c149e2c75133e8f8e3437486e067cc48f8ba031bf74833944b7dd4890683ea2dce2180096c5000ec9684c4e4e2967cefcbd17d536e69bc9f388523d8b665d300e5f8338062a36850454dd7da7259659151da06dfd10f4b2dc09aee1a3f58fd0ba7d5696bcea9f06a1a0df5b4808a6e17c9ab582e03e71b3b4fe68810b6abbfdb7ef62397e14250c606e896755760c6312236d63cc97244d82f1ce2c7fe9741ba1bf965a068d3c7961f399aa6c9f7f811cea3982d7a09aa2910de25f1a38d100c91e68597284b496ae7b8d8262b497b007ee582cb0ad64d3ebb12a32f8fa042a5bc115a103ee321c15a4f79b8d3866ab643422190d779d57f7981bf81ae71cd60d171e3dec59631b78a89294e46712cd88c1efe03267f2a9541b34f23b48243416a4cdc6bd9e00268eac24ed2e991ed968d84c12c0316d1ff60fa19323fa04d1a631ca8224f41d8fff52f4bc8a02da37dacc82630b988396010b127b18e91c7c37062759616a6ebcf807c599b296e58488ccead411c265113fd9e27d047eef5b3559788f90384321953ddace17835f5af8b075bcd5ba94643cbb7448788635a68324c9d6f8da2cec25803d95916838302c940209397dea9eebd743ccd689ffc626622784b1b5c8a9e8152c394e64b413b96d28947375738e22f0358f58cc97ebaeaf3c4bdba631b52a217ea98abeae88b19d88bdcf57205440baec0a9c9c745a960393f9210e22552f0c82fd4f0411169fce330b311b2f98089f0ebb397d5b54243cc5d12e7a6bfa7c994b79e9a4b8c220c6bb5b0495158d3a11dfff513bc809ad24b4b1dad170ddf4424452baca8252f75a1adddc9cf4b8a4602c2affd3e026ee6a9e0e337e53f8f5868b42d0e4064246508cebafa0dc62eac0efb2548d3454134a2b7402fad81b3bc09f4d4eaa0939942deba65b7487ed956dc52c3e0e31165da3fa99e473f24f08cb00f7401e60ae4751ca4a2ea29cf5ec151c7f647dbf51c56228f569b5230f2b093b2b4e21c394e039cb71a296ecbb5b698f4e5939f1e8d17db102d2ee1affe17782d88f210728fb157fe89a719ed35ff0d7472041575db6412b9fa0404003f0e8a8fe0a3554643f14bad15932793bd65c8bb860ce974c8eb47e6423060974f8071a556ca416c221900952a0755fe3da8da5ceb1cca759adab2317f8af95d94926941aa46feec1e2e7f67dd404bed427bd900c7b87c60b7a830b0528d1b729b4db52a88fb058d3433bac69854f1790f79ad6e46f8e6791e6616c7ec36442e3fec1dba6c37243bfb0aee4b214cdc7589e0f9fb35d57a5fe65ad25c87338d38ba5b69b5f2a9587d7816a58ff51f5da97f28d0ee8a0d6898465b9b0aa39908b84bfbfaa042768217a33ae22a82f84644dc4a0f869da3515cbdc0b4df3b464bcff0c573b35a480b7e695349e5ad3b09e0aa9f4d9e7655b3322e35aaa5831be0577e4e8cfe93faaadcd724b01d05d34973faad78310b87a00143559d7a4beee8e0b4c41a8845696849f88eb46e52727b59c1a3cafd97d6683df5c28303c40e18cbee0340af4015ae12412d5df1d29f9574c56fb01eed8bff126c00019eccac3b0a90d4ca26e7a5f9f42fe4c2c3744c08c3e5732e7f3c7380e7ddaa13795f22e6646e59016e0c3b52e4dbbe9bc4afca0d8cf39e2d298442d85ee2dd2db7e1a1522c3d8aaa372fb6af10cd97ff83dd319706a12b9c8f3f292b401850485bb6c26d5d9d1ee8688da690380632fbb0a2cbe0a695130b9532beb51620c90e456774772c175270c0463cab59ba2ad88bca0df04abb0d3f49f5a8a32bbd9a9ef72233223616968dc547e7f2b7fe972b5fcba66febf1610e2916a1f86ae1456cd3dea6dce4329b64bef1399f56dff4c6e5cbc94d2ad5ceb88f39d152998d673444893da25836eecf742f1827d66d921847de42425add3024c95fb26e526a24ab5c1092ea350d03d0702752f10243d333a3b5b44280704c7eaa52e870aa6c0e4dc3a79007ec8f44f12169bbf5618e7b7ccec58229df135595a50358d4a5c9621d5add52ed526b83f384a7194a68f1e9c748a1fd285692acb29d2abf041b15c33669312841395520229edd429b5461aa90a5bb629c5e8720a0ed51974c3f579d7bece69bb1a278d2bfc903e6a24fbc04d8c00e88d5cdc0e845148d66b5e8e3223eef41b28907108c83a818d4b77a179d066e7607574dbb53fb9fd82eb4344fea61a9d573da81e5912991e9be3e4fdf46a504de662c94f3c2d81d2055e14c229c0f700dfd8cc66c93d0fbe2135186381fb65dca4181512c2f65fb3a7e6fc070079e2c8c7fcc531665d0091152d7267b1cfa60d87d56777c53ae5e3f7c107cff17578f9c10b68420d3cd31d34da40855be8b3e0c7ce0d3fb417c10fe62a9930d7e7530f1a4721d83067989775c88fc76b50bd51223cc5b0eaf22a03a39be5017a8ea38e2a4fba6654e03dfbcbda88bbd82309c28660a47401c013933472da40464e0b796b21ea4cf8e850429338738a6cd18ec53f056d2668f0bbaf73afd473867f44d8830105ae37bde2bb8b9322025f91da2aa75cc63afbc5a60aa50312f0e13e7d66ce3783567ab0097dd4624943b72912069f7fcc6fd6efa67abfa1250050abfc493a0cf384de86597b8f6bc8ed6d5266220ee73402ce7688489d350941bda736fe442450410e7fd440e2df196b6515bad33b07eafa1f0d5ccd5f742b4763bf944c566033f5a7f36b2b41b1fe6a3be394047f2dc4082720977ad3a92b33da487eb07e34f8defeedbb35cf89896884b67c4ca5674ad3c3910027292ab0b20d58e22daee6dbd05efa7ef6b336bb5ce154851467896f67fc25e4d3a38f0c124091f0bb77a78287bc5a0285bccc6cb659dd4b5b9ee815f6b17143cf8bacd52b2a0550b40b52262f3fc43d256126bdcc8cfa9302f34b7de476e9838d3e438b6a27eff0c237b501146efb9a495356494a4952ed21a4bb0bcb58bde70bba515a95e582bebcef2ae14c596ff9248375c2c6042428be2e7beecd900ffa1138c7acc9572c994e75d6f8479fb7c8b5cc2e739753acb4530648b52d85220f3c1828d459ade053b2acb4d3f83d95ecf893522e47cf98e8ce98b7be3c4701d65ed894dd98a3afd48eece34c23c3cd95a034d3e522558cf9d79588b3011c8213b02c4839ebeaab8ea0a094ce70ecf4db2803982af3f673ca8b600a16167660efbcc9699a677481da9b0262e05c6a7eedb69cfc90d652909560d9cbfdc16bf2d9eb84513676631d84bc2e87b8d809675d4fa6e138452ad3f2fbb8cd4ff597f7a15875f1d392478f958fb8f45e23f47da7c3884f7caf76bbd72c51025094b83a8df4a764feeef49a44ac8b9d8d1ef6d03a9a9b720f147579eab381b42810476c3a2bcf65a9ceae47410f9364044d31288664c0df1cc1e1741e49b7613357e03893ac50dd1c6646b5e05a6d3998ecd0de1782cdcf48073f7a89879112ec8bc0685f42aff4606003d93873e4b3ba624b49977eb0e5d1ffff7fef56f3932bf0ceb124e1e803495864eb6e811c3b58f7971745e3ab5502084de48b0089f14be661b0ea3ed3f494c0363ec9db85bdc0ebbc8ebff53a91a04e5cdea799e929dc5b42acf202ad3132b84106ba5a0b5cff0da3d094d245138e8ea085bd73e1c64b43d5742fe60356d8b68941a6d3071e7fd934d1a7deb1319cb3941de3434c5e1c6b850a2195c154ce1ece411623d0b4670ea9ad744fd17b8c5710256af3ad74859e65476a5de14feb3cc0283f8b9b3700acda6e9d0e6a4964813f4e7070951f96ee57e1b8109ce0c9d524160aad53a04a174a10c264e2c89338429e939d6be295a15750ecb2976926d8d82350a205d3096921a8aa256b1cf2242004f080471c77ce14e5dca644efe636357ca8c9077bc2e2ba7210cd9f15baf2d78c693c3d711eb082329c95971c9377661af229af3ee113e3bd00f4dab93b9ae2b02ce5e85911d3c4aa198b802777bfaee02197d882c2f7b6d9f4eb91f835322491b18a2867e3c4b89af9ee72f56e1c3792d24aebf3ce540ec07cb8626f62f8e2cbee84478aeaa6e9e9f33a60902f3fceb1bba4e45b74aaa88669302f99309d5849bc5d574765bedf40fe540be3cfaf1a6dbf9197d64a89a1b705cbab1050896619c2ac9dd037963ebde2ddcb4e01947061963827b54678fb96b89d863281edcfe708aefd6a81f1809f71cd9b2e09e316ba0268a504349255b0f16b92f8a3d3b220f673312efb7e4f6a11df2d58b9038f0bdea75cf909d18b6ae9e844266293422f005f98934d54462c07fb380fb6ce3db7c3361124257d09887e43ab029247b352452f347ed7e95ec3c0a5802a4a359ca0d5a875cd72e502adf316bff253a999976e7bd45dc3a7c461742875b4d0f6699710091aef00130208ae6394a8ecfb1d0f3f9a643e1a180ed7e923459ea252f251a9928e319f7137c625a3b793a8c9b869765c06626930332ec44703fcdef43590ab94e92724a856ab62cae0ef8ef7901e272f1242e46e6eb80a0ebd28c3be76370a09808decda9fa7ebb9fbcba686d8c62d6aa1588ccee59461dd64b37878aa806abc56d529a48186f702649bf2654b766e2e88baeb70112f064fce2d1dda21f39159729dea6dbfef6b9278ee5dba6cd7fb245620f4470fea62add8edcc57692134ea869c1c21657bb2212d76f9e7a62465f83e61604c5cd88631bff3703a677cfd763b9e61c2d05f9ac778e48f546dbf50eff9e5606cc8f7ef038d145ecf51bb1513da4c5a7b0c35fd6efe57012224e8dad9d228ae653342d94940d4f25ac0f0201db0d60d7bf0bf2ad8618dcb6f3abb987760b4152cfa4b937688f789aa66b83af2197159154acadb127f5b7a8f847b444109b1d5882dd6d68a28464df354f5e474fc6481a441c050d0fb45068496aa16031cf3dd5e0b3f6fbf605b92e163b59ecd44a0920b1e0ad831be844de097d1f3eb9c395c3d445a3fe2f5b2a729599e97a977ca47b1ff71a76d1f3dbf5f24bd8ab3edf7ec8da393f4459fd820da0a7238c1f7d27f448efaada99703b3bb2a6427e22cffbd73bb73bf191cc25682fcc82e03ea68892a1ff328181c7a47037cbc1013fb2eaa32f600ffd390a0040fb0d4636c8a460e5378ea86fefef9d052f5ef4f7ef9358a925d5010636d8a29c221cbcc97a42d01fcff0e8f401cf1e0d84aa17153a5e5d1010278f96acd3a8020d2c93360be454317a89335f93c74661d47e4cb29da5d2548c4081ef5f0e25a5ef5811546ec4687b542ffde370b795de234d36a43c79a9d9671a3fe2733e2973c25d792c7f15e33a7d57f1f7a685190b605af9be5a938363761cd40fee263dabc4d2c7befd16a2148c9fbf938018ba02d35ecd2446689749487537afd71e703d93b9780c7eff2a0164eabce7dc9296db89594ce6873dd35d3fb7fd2ac8bc0c33378786d81390271acadef3ede15841c6c7f69ea51eb7bd4e09a4fbca6bce967344707c6b41ea3d2115afc58d8ff3f966d3442ac12afb126747d9499b5920ed2c337c6e39963e31f2fe599bfab687f2c9228fd69431638ee4bd8edf8712e05a3fffd646535e7ecdab29788cbb7f7df617d1b01329a51e51a3523f27ce86d0de4c4f69d0c732e38d7ce932ebc680fb17d98ee8908c187aecd8c05a56e3f3ea5c4165bbaa49cd3732a4637e9fab27a435d24beb93dace9046a7dca31f968a641c3fa9a4f2297b96d96f3a017011fe49ae847d64012c218af2341cd5b0442310ad81c93023d7bd38845fbdaa142a006b18822aea1e10a245af1a17f00fa5a40535384258a266854306a15b31148c1b13152c8d0169cd1164a888269231531382629aa7fff3af7f4119a1d34a9bcc1b5b2068e03536b4b535146d513ce189153c565438b79cf70e21fe80b0e15a12f16b9a7f4edf2578e3a67b67097f8213bfbedca0e422cd766a6046e162ad56bc4ff316cdbe2a84bb09d8f1d0889d6a57990262cbbc4253c37a672b4307722be9b263d10f03a3b20f7630472d25c798a19ce75b6fa690c911e5f016e99749f5f1b79d292c2026f5867ac873ad58aec20293e2c409891f2c0c0b9046d808d9db6d6077ba2a9b05da912209a567fd32501ae6228d0c954383350cdb56d5b69acf137bb2f78c42f8d18eff26f2c995ae7b4cd2871acc837632fc5faa1dd4260068e7626ba4fcca547166374aebbc464e45c48c67ca85ca6403ec838b055709c6ea863eb1d87292171b957c644c0ec31abae20e10483b3699f04afc463568b14158b4c1842205df8bb3e77ebcba61d1afa73fec101b8cb50dd89925102a4d9d03a98a8ef027186507983ba46685ac2fdd3ec6da62dced2511962f842b469b09e62bc423746088938f0bd7e91ff04513a91bcaa4060df5507da58400e183c43e61daa597daa53e6b6b7c15f6168f35294cff1df3579a7931b964b90ee11b72b6003d7f3437a89ef4f085e9d5c6ed5582224db6eaae6217797aab67aa802516a670d2200089a173e14c4cd0f6559ae3ee6089d8c1a323058ed7d4d6b004ac03beb4d96cb09562346f4cde947a3dfb2c85aeec422fb62162b000afddf64a0b4f5b945638fdad7f6fb5a446c4c6eb78db31ebef344b9faf9d34dcde8b740097ab2427cebc6ffe61a4c78222b76077353ecb05da0d38de96630b27b94f3256e3a195a67b59f90d95db3c70fc0175458bb0e393777150ac790ed1dc49429771a0a7f05ce3974d1d0e1391d09180f1e83cd56572cc08b4a1318d09ddf760a6a0e23f29d4bcd2ebb94898a8707eb82e1b074e0a0d784b01e66c202c98a6b26f0a6e053493847c47a702c74f1d3c5a53f1fa3e7750ae77cc70e4e81f14b611ae898686b8149a6dfe70032de1679442f224295821f08b8c72bc22689fb2b4331381f329aa45f43c8efe537596a6a6148099448db9975ef67b6146fd11c38b81a5a98d5d960bb73647426af85d919b77c66feb2dead0bc4b42c2efee1c02c570ce82bbb58516cda2a21fa2c943ceb13c91da502c052519f6ce6f4f73b63d438cbe475d4174a06a83fbbdba2ea377097420758369f79c1c7bc1495982fd0a4203d40dc50af6fa8b31cfbbd66ab67732d532ab89b96516df0aebb7f1c79dc942f46e23169c609a0e31b933b013ce40739e793bc6cee31a74b36d3ae59f8582fc9b8c867e071965d1d20bff0506abff7dcc6ca8f0a9c73f702d142b0cb6bd149082ccbbaf8ec5b6d232f488bf1b36d95c9f969068872301f1cf1b7979ef7303a68fe44834694f5c5dcfbd4f92076616514076bc279d1d35269a772b586aac44b174b0933ec63a80509ef99ef22a15207d4bf28a08a98ea6b621ce0decf5716ffc0e0e0022e173f6e5ac8eaee975a1b488ec0bfec51804ab53f200158ed01c2c6a408a7794f0be308139069f804df7bf5850e78acbdf6660839a51b6e9391e1a3a8487f1488ee83d412a01aeef1d27dd402cbb6d4b6f2a4c08b1c31a7cd6e02699b8b7f6169cc407230abd88197a2d49ef2960d1f174e009fffa9f7af32c3600bcc9140630ecb87cb7a5a4f9de584c2f5fda35f9589c2b1f21fc3f9c6147a4120e2bfbbefe4bdeaf416126756303bee6e0531e29d7634147bfef1ec14970d238a5f873864884cd7e4882cfff96c180a996111cfa5e0dbbe91528a144ae3893dc9593b3e6a861cd5e6f135bd0d445cc5de57f5db389318f5248406d344dadbf36fb1a731170df4f2d8f45801964bb49241247734e1048f4e0a9cd53de578a426f88aeca06b36e2a59a9edc6dc347d0528d639923a4d95ff4ebf3948ae951b02ea1a01d461524cf80c902d696ad2ba172a9febc78d8e50c27c0df24ce38b9bde710142d549baa91c0d0d037f049682ff2d0e0825b8f0fdecfba9b6e527e65d28e41ee877a1a8a84f36a8565780a08337b85cf5e51096cfbbd51c504aec462d073ce06b8d648d7193595ed60f7d9590e1d62f77e8c5d15ba7f59786f2f6b9cf5cf37507f8f38d021cbd2583320b274f48cb53052be71d678c2fab59161745c7139d89c4dcfcb39d340060f7f8d80ab3a9dc02553755a121c34218bd2f4e6ae17667c44d8d38fa5b4488ee74f6c06044602b6ccf7f1dbf59ee3e8252471baec624951f296aebd23af982ca4e3b07e96d2bf0586c0c63d1def7ca7a218162e27792d05b6f1399d2f7fc7e0dcb4953519dc3ffcc12d044bebb3d398dd6daa00aa77691f98abe25ce9d5202fb32b57122cf81ee0acc2de9dfb6573d009cde3e8936e31f162822a78b2fa64ccd2b31d2d6b0433e2b4bf762beb743de43497a6cce4033886e2fac2bcd8a06071c5e25a83495042c3697d35c1794fe8048a61c0d286e15c18742c3f5e7336d18e02f530e89b3a1c1c80e760aa440a9e5047468759e46473955ae5645f007affe080dc822b055cc46d70b421c4e6560626c5818c6eb8e36ec16f5fa790064d7fc1e1340dcae91518da1eabad8d6512dd10bb3425a6d02d73779244e2ab0d15c2ca703690f92962ce4b92ca43440e45dde3dfcf6e4942841c2035ecce089574b8677763230a83a946c2594dd77975330b63ca23bf5a8d13440faadaabe56b3b0bb1f3a619682b48ddc37cc2decd00eae0fab33d66d05a13671262f9f63a7a585f9b591fa2d7c7c144b7c65f5644f32cce902bc6481786f1bc12bc59e50ee7584f38f2c4ed1cf8d48d315a5b35a47231e69d32280079c2068541aaf8d6492bde76005dfc221cc48da70907262e589db07b281c32ebbbe6c4664ebf50f5071f8707d04deeb84905b32f5846132f0ae1dc9fd3b676793d734d288f2ffb84c4f53d109a0614a10a2462a1263264e27da13a83ec2e8b7aad9a4d8aa8e290eff96b64a2370f76e5242a50c0cc2471c72c73f2b38fd0da90c6779dcedf3a345d7f02915ea636a418e98b092939faf33e11263f71a3f6b4fc3d4c8b36c8091d1fc72c557609b6981d188e04659bafc14a0a0e222943b18977b92159bb771e059c3422c145a22a88ca13fbc6f87b28d4d18674520aa8a5812b3883e96e82ef0ba582c16075b468e6ceef2cddf4b82ad96b8ccdeb99d76e2af0f05bba69d8cbd6bb7a5368c0ceeba83e397b3e8e381d0a1da160423babdca1b67ce3e87730c7e3cd313b7c96f6537946dd29bec79518f7f8ca53f649310ee44ae0c83501e15a9c1a7991b2c23ae06e8e323fb487d9e88f76273eb3549802e7bf8da4f9175508185273bffc2378d4e1556ed3abb145eb45a1d4b6b36679ff3e78576bea006bba4956c3d6c9968a9fc4bf2ccbce07247b3d3df5c2b1ff0bef1b012dc8f286cd4ceb860a077be0666b6f131d58dfef57ba2949c41750f430b03a555a405c518bede0b4466208e83a60b2bec9fe127bd453acb239cc2c15a0e23dd937e6a37e8d12cf6a90d04d824cd44745664b32f08745bcc3bc39de9ad1d82dadba2ccff0f3829cb0bc5eedc8f60b9863655f97ca9d94d38ce2043898a5d9e3ce2cea10f8271b38839a562f655066bc2449157030dcd0b42a6a8997842df6a20c8fa2a3a87db6291161c91fe9c347c96d8a7524c834bc08bb8115721457b60efc021339b45e46fd6ed9db745aa73631b2b9182d25c53e2eb82d452c5f7c1771c9ee11319a648328a3459968e9513b489a9066fe4b16dfb68d265e7611c2e7af72fe0f5e1de507291f71d2654d02de567725dff6c12878284bc5f237a072675d9d77548cf420d646dc6199eefef98a87de34061894c4942320da17f706a6bf7854b38d73bcbebbc2b12a467124f2ccd195537b7f808e27659c164ec367ec262023bf8e271514d7468946ff0c67e07b6087647103c3451ae34d71a219521b2d6c32fbcef5ffb8a45bcb5766f02adbe0e7961e34ea70b76a5c779c4e56ee0964efc29465aada5400cd1c01535dab70539ce08e4494d8dc90e9e9c9a9a14cd9adcc79a8345c83f7561768f3dbed61b9027bd180f5c2a3ffa96aa5bb101ca25c312af50abdaf9d43c00b77c948cd23c13de5aa88320709669d621178279ccadd9a7a04ed0553390f47d30ca7196035a4ccdcdac541df0ea1ec42d252ea49f7996a8010a8ba5c349d1c2970cdc9c01621cc00eeca17db1a86aa7e7ae001c1aba5c5bb1c76a3414fa521b277eb4d0f2a5615c8a4f679495ef6ca573e6c0f3dae6135bd5efdae3b04e7288e3cccb64edea82b14cdeabec9b892feb11358ab3c525ed1fa470dc613bb5ae7f4b14a816430102e5da81829bc9f3e73faa3d8ab831e4afb54780f1a03a4be8df0d17fbd3d15d97263abd4542b9d9f68f8b0b1c8ac907dfb1a83e1dc8d268deed87faf793fa8bca8853a93519043d09e764a5ed21d763c799b24a291f30afb343f45d7d576f5b77534263b28d44a1fde799d25e56504221aba0f3f3a25cb4ada8a7ff9aea0e99abe2a7e689a85399fc0dbf8c74344488b00d9fdb780c59b2455ce6318e8e14be28e408b0b97142ab3c0d2cb2cfe816fec5a40c3babfcff8618ff04b66ee09b6f0df1cd39bbd28a268843384f4833099553473bdaa14ac90ba70004e656a77cfd7a39f7404cf5f94e997284bc4b614dc888d649b28427613635865b3a8113fa7aefe1e01a4f9f90c48177d01c64b62e9fffcb0fd13b64b6fef45be38f0493bfcbfc52ed7ef81f9b33f1704765f2fb9bae52f0ce8b2b68146de807bdb1c059e1e9c5538968b8c57900fb07274b41d5f1822b65c35426118856b9dd877bb63f55b67a7751e4ab2239faff02137a3302eb86258db7f762328fe79684dfe21794e374d9fb644d8a56d0b31817c84f739344f68154decda16da14d19cc0d4b302a75b0d8b72ba1004fc2c3bcabb0b572e16d24f0704d94d356adc996fbfd4e675b46b8c2d3af6730b3d1bc5a3a0f5988928d7ed7314dad2172af8d41feee51f97d7901ba331196cecca3bb56d9fc0b424cfdcee7605fdda49a948a760195f04b4e210a919ae363361132324065b8cf236517f228dc122b58e74d91b5d877290dad49482021654f8717e488f3cc7a7bb3d4bc2ca5f6783b425653997b93be85104095800bd43ac4e6913376803fd3a4d8ef32995418a43abe4435ae344e9892d6b5210e718f242bd3e07df649d0d34f3308f86562c560c91a493f4dd5a2bc5e423f5d5e4f8cae42b747cb73134c0ccab81b0061e7b1d4e86ffc96c550e1beefc0f2b58d7da36793f89af423cd48b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
