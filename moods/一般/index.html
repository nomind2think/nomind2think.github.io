<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1bc1ec890279af74a3bc33ea03709a14024f78c9e63b4c00874405f16c800161c3c007bb6fe757bbef2fdb86231c8ac4bb746dc89cffa8831ad3f57bb7e6ee15b10afb1e522d3e83fd0bb9b6f3b00bd302f3d3e4d8cc7b9a17c9f73fde95c0f9d9283e38584057ef543cc65df71abdf7add57ec7dabdac7e4be3b6bd9c7b90dc84908d0691b9c5210823f693870c25f1328aa6af577835b0d10c03c30388ff4c0782b5ed49b73055edeca797d8b98fadb44a1e96d099607362d92d01cf4bb243f9d8bc487231fb84c4782e261306f74a908251b512a79a6f88530bb87c7e41590de73846a2f95320e76a0bec50fdf93fcaedb6c02b445a0d92bdca94b611330e5a622b04d8c4a936fba758e6d9195d92f8c8c978e5fe0d183b1c317a8750f59bc96270695550cf678a4c9ffeda638d3535fd6402fa8b1b4d7a75394c73d5b88a24f81003f567e63e54133a75f4b7eaf37c0b8fe315bbbdb8c506d124497a6b5517b9ec9118b5eb85e039f62319011247e33cc5fff4e3d12e6e49aa8ed3ef780e530cf58011a3d0c9675dd85ff768619c9339db2876de92dd748c16fce6703751dff6bdfc824396823a419b4d288284cd32b89c34ff8ad9b4230322c6a68514295654f1285985b99ac87c65dfdbd1d2e9d002d897a52f66da72a3486f41514aee38b70e316180f5a0b5c9a96b49e73be81eabffff7dfc76d0df3a967c02d91901bb491e688d76893e2eb807703cc50f225e3fb04d221c0df40326b3c1b67b6b4dfda4872d1cdb233f5daa054437d7b4aa0e358ade679c65929c1706df74aa92b3e86357d5c9552df6123d83a7ccf0a864e69d9b87ba2e9ef5ca55b6686973714b3ae49a3446a984dbffcce7d3ee566fb253fdc92d5e9ab41ffaf1fc250d85cdf4fae5bfa900c4843fe58cb525801332a4e46ec69ae6eecdedbd8d00f758d014077404889d09d6906f5d72f648fdd650e235802f1bd6d2707b62c6e4d9fc4c01f53ca34ec6c3455a8d8fd8484e4e48d285fbd5407273e30906d89c618aefa133ad94eb1086b6989043aab99286a40069baf81a1d3e32d25bf30442691385e7ff48489867e4fd11a2c4ff08691e6c4fd0a5aad9dfd014c5bc7c72d4c4141b906b0bc0368f707589722127ea39a0f7188cd8e107d8aaee63c1661e6b4d648d79e7d70dcbfc9b6c8b272dd6fd95bb5150482926cfff2bc58608ce494234ad94523010e510de3c0a9fd67d40538dd3ae04b3880c8439223aa822986aaaef5337b5d4ece67e87080a1be6a7c04c33a85d39471fe423c770022551c4be2a91fc6fa58fd5b30006d4c62e178be351a5f6523fec24067dbfddb6f61396ddc97bcc8e610a505c5cb609141469441cee11b6392addc483ccc57bf841a6dda48a4e0eac03afd781f43ce3a24ad1b0a015f596ac09d4c3b82c994d807d3373312b7f1ed4811eb81e16336bea4cbaf9ca6e2cf542cc134bc5b8722643862d00ad9cf89e550f098b131913cb4b034848af13b2d1465fcfd4011f45b9f1a3703f4d89b847a150b2eb74bad86771098925f5588667aa3dac078cc96fbdebba9580f653dada7b5309b06aa64f274f07872c32d8d9900879d9e75bbf536cc645be5bd4554465c482041ce12f59ccdbcb7b622cc66c24e701047f973dcb6e7642c8eb1b29adeb9bc79c06f262d4d816f2dfbb3c90aa0e67d666f7c6ae17c2ba5ebfd7c88812521e6f304f35a39f77467ad0f59369ec52a33b57c8340857de8ef20c4a4f69a7ad094e818b428698fd0679834d83a3e8c88be58aae3d70324106ceba01d9287a4435fe6f5cc02adf1c08a4812c2f41a7d22518e97392897ed01c135423538a5e952a510d8b6417d4de2244c3ee994ad491a886a290b937503601f37501e2d103f83306becf60f6650d742a3d1a4e615118e79bd9a41fd60698ed0727e381c12020d698572433c1f1ef0f90ee8af9b682ca6bc4bfe8241cbd678e4364927291c93d19780e88eb8ce5660c4dfbfad12708892152e614a4187c348f4f5d828bff9b47eb51798b5b747117da8a9b7443c7ede8af9222fa8f2edc9775c9eb01d0b348a3c13c6f766b14ebed7034fec9f7ec993946cb7ee67af054323720c128282f46f5331c652f0e2879962c6eb8b07f31ad7f5bb5237e6123ae2bf93daf76d01b7d82119a6bd87490abd5b2b8770d78e2dd4f6caefb16656d30be2a87b2941749d7fb81fa5fcae91b56ff994ad1ece3126ac9183c1ec544dcb2f06ea6115218f7777506546747f2b8c84acdfcd639e170bb92d546a66fc8db718102f41156068f7a815c3fff746dea4c62bdfc452c43b0051a831f68dc3c6dd71f08343d8b53d92238e529289b9a5b25fbb631fd89537ca1749740f3c4894b59e3a15387dc29e5e610f81d044ac67c99913d968d3a494ce456d1ded91ec757dbe1972ab243de9ef6e344f7dd66bd1b399ff844c781cd67992f3b8c9318bcb975d9e8bf62e44b0898565c8c14e56e9da009ba77974130abcf2f0b3ffd6e461cfeee5f5f3bfd1e4544d59d2ef85397a143f2f755a777d083b202e4df38e3198a223657bbd686b875bbee613fcf8d08f986631fa3ffd35b80935c499f4c3d14c31dbae5e9fd8527e94baa0de4778fb099ae07bc38292537e374f600427a91861a70bc7a39a1bc0eaa5eccd1e3b431bfbbceff647cc917b2da77129187759f5b7bd5c11dbcfa6d4104ec017f8e8f025cc92a96d12b63dc03d1fad76d65c8ab9532eb0842da5878acf16db3894f92453c68b576ec35d34b8f793498b26d8b2ba9fe8ff094392ad122fb41605ba6f05c0bad709b6497159f89039e65324216a8dd650ad4f40dc8061050d41752d42063d4d0c65b0e3ac7104f4bb3a11c536593430cf40a6130922c3cb39b19534ad8d4645b816b569b9bab1acf4c15928308c74b37c24919de8bc1ba1e4a6d9d87660973770739b62de256295341c3c07d6435aa49ae8bef84014f2fc2942056b38c0c583e6c63394794a36bd9ef043f9530c8686aa681e9bec927cba1cd9b41c543363af0327edf75a8f397487b86d8142c8d6bedddaae72570e06475a5d10ae3f81bb2c6185f7677b6710770a392bc6494c1ac43f2ce5046761b77c3bfbd228613b1ec3eff33d0cb4532f6dcd332c31cd6f09d19d9ae7b58648e3fcf50e6cc9a2b5b3c6c83a47c54f3401a988e18ba8e435f76f279e7aaf0892f55a4f9e1512ba4b8cd7cf71523feb1000d450a529259aeab30ce8b71b7112ad3121db9c6705457ee6660154805d092beceb5a300ebe9b5613a55901561089a09f44743485c7ce5729abdbc4b87ebe00e1a1f2e54b9d8dce6d65c3af870d445fbf255503888c7818ef238354f283f5b77029924262f275e9de66bbe7423c7bbcf240983076f0023b37b73290e0f757d977e973298b63bcbe5ae272d57c431873020533b22dd03775a61624de291e86cdf5fa48ac2ddf305ada9d8bce3b67ab9cf603af4d6c4ac28f06964dba34d2aa075badcc1d9fd9920feee944a508d681a662f8818232db2141f9814e29af3553b9b594315e78576aa6eb1700b93fcb5ef690b0d29b36393f40500cfbd70d2d7317b7825b41b40b04e6e2c164862a7e490403d0af6d2aa40e07179918be09b908874e49fb3566cd8c78bde1e9cdb131002b369c1ba3265a1db80fcb2722d31a5fa712eff2d888f72049ed88f5041c75c8b83abd616f94d398c05d06f95f5eea63fcec98f3406c357e1f57e1d8ff6c30ca38fe230f1eccbb529ecac7ae6924095b2cac20feadcd11a6085f3356fbb1a00f78465fbbad2012f1c4988c1d9f97cf64048939b7f8e1c6e3e374e464c6c9d3dea5cb47dcf6aba89558af9706f49551dda6c78d53934735e69264964a6470c47603ac6342c50e6b5c2babacc931a87bbacfe1502d7ea946f697273f53771ac0de01a6f8b54353da541c7570ee55c659b4df87239ce00cca20872960fa6d89511839dc8b5222aac437b3c5d29857e8f20166d2e6d0adb8c72e21cbb99e99142e757c1f09e9d071b675fd49845e80f9e397d871c67bc28612fd5f8a6e0dbdb133ac5805ab44f6e825dfd5b5edabd64498b7aee308b3b392568429b154e4ab2962168732ed284367bfbedb12ca22400bd9577155a3e3367001aad4060ed8c07741ae42a5bdb039fa6a7361538b1f36217f07ac1e86fcc4394f4a2a1e5bc792a787f74364d1c24c7729a123b378a189ef509c56476feaf9b4c1e300b8bf9bb19138c0cf38ab3ba61ca8309f91706f650cfb48eb6960a53a56fde29ceea750707b4360252de07f1737b86e2b939b17629bd42e116998397c89fdd7c8071ec103b0bdd2d7d7a6a57d77f6bbd5a7c3fea15f91511099543de764ecba54ac24770f588582ca4d80009179350d483342203f65f26e41d93c14e594674d3e84008b78d12a50930e96e2d9c99600b2f748b93c26bbcdcd88bf4f6437afc0f794df9268159b977e71b5a41cfbc78a83dfec71d85b93f152b5d6b1efc08fe47cc263872104f9c2ae926065635c249dc332aa176a18351c2a96defad6a7aee69492489ac85ff586f2b68c9f3443c9850c037280e26ea4dff74423aa355e1e6449c1527cda259dcbe17f08dc35cccd93fee2ffd91b95b06a8a5d82aab5da70301b1ba85db8714f107af05365311803af7f00de074b4b1b7c0903803bd3db6a50fd8629e384659060bfb87de414eccb168ea2a25ace92980fe593332d4b55e3f63a7ca0a9c8304ebd127805dc6340eea1161980f9893dc4b76a0dd871187a2bc4d9afb5a2b0c1e3f63e99526bf78a9f6c0770ae5f63d612ee0cba66e9650e984a0369f338655f82e8b258ec683d85ce8d8b61e4d88cf159b551ea43e28a95bcac694a2c08a19a935cc7d0a3763e832493513432d7fc21a2697080b11e75a9054992cd0a3c3a8daf5db145b249c86877c38441a9802ce20f985ced779aae7b23db607e4072a16feb822346075610346acee936e6f221eb628e72e4738d88e50c4ad48c0f54ef99ff700015332229bfaac14c99af35a575f2ad08b1eb4d1f87ced350969047bef767d00e684a1fed9c2d41995a6cef3863180cf0dc2fec97dd2cc409f496ffce1a51ff8545892793f7160dbdfe88c3b09a1c11254617c15d5a0d0816268309ba9405eec3a825430e391d31f664abedbbe02ab673d656bb701b3a3f2984467cffedeb96d552a57fa66ad4e2e2e09197708eb209b1d3f086c7bd2ef85e9c2f0d485f14b3a89ed0ee66fbaa12f8cbb5c1127738e6938f89f17b94b629982d4f6fd5352611c58f170221a7557b0abf97765ea2ccb16bea2b2bda68c8cb929976ed8771117f365fb9bb5c4fb6bfecc4a0316712941ef2e8e3ae5f6a39c08fa0e47e903f8f98f3a599667df905d243442cfc3ae9da1801d858fd8a3ccf7b09445ec1fa74a7a81c6a6ae5d17d8d47ad7c7c5648fa109fd64150ac1416370cb423c18ea18c8a1268a1b904c052f9fed83baa5d8e8b21de30fc3115b78563576ddaaf8291e36033eb367f17f44656c4d08ce7e1cdad2cbd74cbc54aafdc1e6e1fa6998a711516a94900731b3123db43b7d92c2afe42f3f7532f8987d3bfbfa17b8b3a5216a9e4fbc0fa05063c155d3970aaacf6a9ef4604d1e231fa89931b07587797261fd73fe0a783fafe9b2935495e6898bc2f458d1f6a6d9e7b7337701111052014846d9fa499aca80b12b77c94de3bf19cdc616beeb40338dbc0ad17fc143e53807b807da42af22fc9146b93f8c1062a30b2bfcfdbefc047a19a39d11030e7f4c74ce4ecefc517ae5ca3f42b301ffa17c17a54de8a87e8385e51b5d656f101866ce2c630b29881e3d63eede92d5bda6322296d2d75d92eb45ef54f99f508ef54bf1c171842d8f9ab3072af6beda27296791e39d575e3a32b40bca282e63592ec80ec2abdc31e66c43dbb4a56e5250b6dba918364c300f344c43faefd81d8c1ae32b820a40ab90db36c8eb3396b9ebcf212349b0590ce13c09a1b20645505783312b9ddaffacbe6b783bbca1f95c5063dfc9386f910fd3256e2c32da25d10155a98359abb09253018149632f07c2ef508fad3a70002d516639bebdacd295d0464a227225f2023234c98e6277dc1e746418dd42763216b48f16377e0049e9170ae9e0e89fd53cdc3e8552c8fb941a33b0d858e64654e7fc5bee3faa3f55dead459a624bc832df331886a4fed847874e39eb2c07d9b34e97faad0667b6bd7227108e847dad67bab2ab178219859c2fb4de7360b8e94780b5ba9a493da04838444526776c2e72388d97e55cce2c4d544343b7b7c38517bb4030d75ac3087d7a8b9ecc4a4666e8d0bcc47c6a5f67a012e0558685cc26db47e699807b4aac9dcefae835c33602a9deed10c5f44cf09bf58ca916a3749bb2ea7dc42a0db7778fc80159d3fcdc0c659737c90a62d40a386ff2180b589ae60fb361c1ef672cb8abc5f032e0f8b23f63b817bab54ba4e8c16c769a4f6cbb6bf220da2662a10a4504a112d00d634b2563ee52a9584341870e2bd24d1e56c5c632de1bb8cfecbcaa6ab47b5cc9269ad84f9bd970b5a664a20382ce9556747075bdbf6326e634fbda647cc5d481bdbd057159a2cc78d0c4b19ccf4484c06ec3c32d422584be82a7a15b753ad27cc403c36e0be973536e0c078f175fef8106da6d7a945b4370873a13f2c3725203db6d8217dcbc09b4e7427384deed2afb7ce2b4d5a1b103644b07149dcfcf8f66d74e92fe06b0ac769dceefb5aae55db74b80807f1aedb8e5fcb1e2ab8800a23e2422e54d81c63180dca5aac40f8f8e6a0c2cb8efec287dee5ef59fe98eef38d4f697b7a08e856784bfe9f02b49276708e63c478e7bfa7b65f79c720a430db01e523f90558e4951258148ca14c4ac8c0defe9f3efa60678c459973a704ecff4df4708410c16a83c6d27eaec128ddc2edd06bb3c9ab6c8639621dcc7a6020f9f2ee17d6a0d34769e6e0fbd59802a76083b7c246b91e084f86451bbd2316f270e5f9085aaa9ac651f57333e3168570780955ef220548ef6aec3ca79c1241e2e7e32c07b7068b85d4a73971a5b9022aa9545f17d49640d35321350add1c6771da500c864f751c982dd1f803280d2d1486b661ac4e69f8dd52bac85ea222b51ba28cec7f704dc915a4e0c5babf3f981e603118e66aa0140719162e52f4441e2744997bdb29dd1985486d388d89d57a26509b2dcba30c88686b568aa102914984cc8274fee34bd612d8d919ee327640a4104acfd0301e089ff2dde2073a586c49d14745a69eecf4a751b912997753f4c425664225d794f62bbdce213c5b2c229beb9a3a1d75242eed40a65655a5b3cd2a932feddd9965fb205c787329f49d8afc7e4a749a5db2567f1d1e15371a3c433e70478d15bc091a34f0731db1e864e7d7160de3a83caba83510a739954c0fe34ec74b57055d3013cce0ed78f7c2afdd506be0e2afe42e1211850e409ea344d76b9f5ffc679f14163d6ecd90e483ff88b3a0fe8e352986bf266ac699f03fe391e76885ca6719f98b66c339aa4cc4987dd9256dfc381c00755bdbf37fa73544df49512a32d408a8522bd195bac309ab6016374e56ff86dba66d871ae9a50b510ec4382751c7f5d4fc41c002035f9f9c6d5abf1c482891e58d7555d58f1c2cb1e25847c13cc018d0958df5c8c3b4a4a21566a81a814f0f0a28dd7281a5ff9834ed7f657c11721fa373db8efbf84e3a5c74bb5b84342f13b21b9a33433f491d6c80929801ddd3250b6be208c19f93db3700c1f6e14dd8867cd5cb93d9ad3c2a67613593dc6da5d470cb4b541ca29a20fb67c5a22a9bf74f2548d396ecf9e0581084136e7df1f91fe5fe1002df0ce983c9df24b5db267558769324ec280fec437665344549249f473b47ae4a9cb9ed9a22160002309ce097c7cdc24b935b3315a8126509141972f2cd003a56f4cfd025b64b234587ec03ef206b8d2c0189b71fe4f0fc31e759b53df39815bf2034a72fa4fd0e672115c3ecc007109c3b86993dea265e13493dc91d4238a84ce59cfb27e5903257d42e38f916aef5222a26721b6a683f31ae974975f59a2e16ccc0b4aaa06953be0ed8287a77ee3229d34683d3dce274a914f9a478e6a7c0652a0bd735c174dcf346927a1bb5b11abf73508d1b265b567298bf4a2f0b65a36c5361191d0abe8d7fb469f3e270bf434f7666c9279d7f532f50bd005476fb42df1e49af9543b290f4f90ad4a7f43b064030316877ed3c925ff4a287fbd72b33220feba79afa9114762c7e21aaac4687d07976114b1736e061b0fd33d4d2215f12f4f13fbdedd06c9b50f8fb081cd04a516a29df67cad93a42f7eeb59e6970d9bdb6c156ea98007de29051965061fe58b9f8067b76b5e37d504c76c486548cb66d96a5c24e55c171a8bb5183d2c85e71aa3c21629250e11886bebbafd877b6a34545ce970433bc8ab84570ff31f315625974ad4deba827249d1cf01f92b62ce72c72e9a6bae6720ed9cda64916d7ef621287f74a842f40590e65fe7b3f933c262cf412e847bb2ca91eaf78e7fd63168876636c8fbdc255cee5acf5127896101fcd7a871aaaefdc46c842060ac10b29dab10830a7b9d9b99690d187ae59ce067e7e2a7ee377e1e4fd4234b484432cbd700beef82eb30ab13de6c1ba70dd86914618d1f484871a043806278f917d1dfc7465ddde4857ec854988d0ad7781ffe7414aad25c4fae8d5aaabd2381cb028491b349ab76139e66a50e0de9ebcd17c68604ed2b6153adc5ff4ae5ad42106b286982472fd70f438ffa859d7746e6ebd094e885cb136698454604a13a07cad5209a9751527dced1f0609209039e4ef6236f4613bf15f0aa73c790a0c3e8eed523a134838f6148e223bde80155ba027c4e53995e909df464b2bea1c3ce8ab93cbce03a668c0b035fab62dfbfc0a80efd9e9f245fad1d671ac1205303e4d05d836816facc148285b946b6019229662ced9e4c05e4fbe6eeed3d657c750893251c15ffb25e68a0b96d2a03b9271154179d03217d7de7147f32c922cd6556d58f9e49add074ec839419a1ecdf5b2a20010212919a4cb3fea1a00de0cb63dd3bab8cac3cead9fb79c33cab8e6eee8c5d403f635926d581512fca4d8ef88b6376a39a4e647399178aa4008b33ad81ff57c641685ba9e9b19e3171b2db71ce14765af7347646fa66e8369121f374b58e68f18d222dbc872e4e01e3c61bd2eb6ec94ed2e71f85b90a79af13996798ab12ba7f5f63e3152ee88eab9de204509bc31d1ae608eb124f000964191dfe90d63ee5ccc9a5b5af78f3847d3eeb22f69c496a78bb40464b9c9cb0966be8447fdc48492c185917cab67f0103d8f3601e832cd617c9f5aaf280cd3a040cc85188293e56cd464801120214b2d3299f8d85a28d2ebc020f5765de8b4526a799d5c62bf75c7a669f68aa5847b2ad6a77bce4d340398806d2091978da925d4abdbe1ad4cf5a1c0be237f42e34b31673f84caedc49f400484ccc93a5fb9685722936589ad057b4bc9c58ddf6df35e52c059dd6f56df726117a042161f356adf0d09b7b26f771bb5359e4374c9183713988b8cb5a38ff77dbfe727444234eb25740defcbe72cbe57761cf75c11cebff63dd0de30485fc5ec28a203646905625bf9bdda8b8ab211b2f6ac249896c49fa25aefe7e502d7afb42c485a42d545de5562ccbc408ad5269f6115966c7003237c2dbd30397c11613599349edd2327608583ec1570ef4ec9d2e76b4c7c9f93448bbc85887f7f90a00831b130a8a5d17498c7e07cd17d2b21fdbe51fa0f3177127674a9076cb9af054b6e283bd587e34a073632a1bd100083a77f2d7707b615e6e497281b8d13b525376abeed249abbf84f18cc50b36124d60ac4d7f9eb63274fae87a80a4dfaebf5488d47cb02185b4480f6b5011798c081c6db8016c15805034376ed4d7580e9e46543734ebad60d7de1794a33210f7d9072f95dd13a9ce8a7f199ead9bc77bd7f4e70d673680bf60be71ee8c3868481262e5f60c46c62827d39134c385c624a8e708abcc166d5f60222bc5d17bd16b54207f7e914a17f9044e20ac6a52e690dc07626d2b60946a275b28a82069f974dd26eea97e2056d0bb56ef21c9c32c24953b43dadf1116823fd205f13000ad23cc6d6998212aad370dfd1e6114944173fbef542b15caef66c283488e171b8f2b118587b52ccebec14dc812e5d2c1f78634bbf93d4b7ab330a9982154ed2cc07fac760a35ade7b5e7b7a42179ed3adaa99828b70d5dd3d8e9ef76f425776c8c9666a5289f042a1bacfbf479dcbc14be948c3741e2cb4aa39482f7f9becc4e7eee7536fa6ba01ce029033f51cf8a460658958d25a4808c0911c174029698334ab69289eb06974aa6c780f9a0c37a7b8da3322b0c14e50ce3974b0dc63a583c87ccdeb7e9660c01906a38e263444e51528bb29c1a4f487170a1d7c87ffa88218aa0c39e7586432cb40083e22a561bd444fb693814fc8ba18f38bf43fe6a767a785c9e4a2dbf19545d2cb14c8436d91828af89bc6ee61c80c68789ae4bb1b339fa167b2caa964173fda1d9b5c3c6c75c7f9378251b030d9e1221f4a82b6e43389d768c9fa2fd20368910d9262dc0c334a0ebb44710a7b2add8d2830566572a9b9bfe84d429540335a562b90d339c6e8c76ac4ff12dae2f2d61fb0754e16ed12d39f6c5aae1fc7e537c736f4a772650ce23cfaf0264494ce1bb80f3f6b5ae112b2fbd3a985804faa7e8bec39d462e78811606679baebcf26cf87235ae23e252d9603e638edd531950badc6b39c762ef9bf7642d668b51be548492b0d16b3454e8673151054dd7d1a94f594917fb8d02e115658b21df6fdb1c5f48dee26c42455fb1d71e9fb8dbd983dda24bfdbf681868026479aa747655464fc0d4165a0db370608bb9e98152182a485b45bc310b00635f0444e466f6e6971d32f959474e1623163e4dccdaaba459332fe580b5cdf9148e17a3fc37b5c140cf689cbd5bb53e7f3c3cee7333523dd2e548b2cdf9c78309ad27d155be03ae2ce01177b90bcdf962895cc012cdef69747cc0f5c67e8c4db4956ac52faf82cc638fd81c528bef2a01836daff81d9a9ef2b3417b8c5b2194226c5656c25b08d5f08f28e6c56bbba286170bb0eba998a0de1d2a807ccb8befe55bb7d1d395d6d8b257c9f0fc05850d8b0680f0199a7d826e8ecdff822362abfca44875932e5fec1ad0d31d22837ef743da7cff7ed6a7b45743b49f365e03c6fc64eb62b127dcba0504bf074e7ea5899bcbd03947fe043aa1aa0b2a4d55a70d84e62d4531fbbaa5d62ad96ba0f3d872a1edd0a3247e185a70907b307df7e5eb0b34b394d6ece9b45a3fd9c9e5e02577cbc3a9f3e69fe917dfd1bcd1293c3c70ab1e55b85ddaf1cfb840be05d177d8726fbbc1b7d6de6da832d0d3ad7c506d85af62d2ff93861e330b9951f2caf89fc76427cd64d35329cf7978ee5a4725b89601bdfef34f41ca8014caae980a60e6ab55d15235b85b7a386fffcae9946cdf57bb77c64c227b0af1a9414febab87b11b8c8496de573bb470d03fc0f657e3ca267fc12f6328e79aae4ebde8247363ca4caaeb29f22c4bca9b8f1e32860878cbaae53ad6bd92e3a0cf30f43188df386ee3e93205d59249c1fcfc11f0bdc2a743da7b477c7d305c6dee9fd9dbc9bbfd6a073dd5bc0d8aa9d87a40af8048469e962a50882a2211b0c346fac555f404e93d1f88c6332f62815e0f4cd11b1499fffaf7e742cf4e54c6497463bd9828a0d23197c450e40f06b65a2d92b656b7b9f30f3fed3f9d8e663707726a82c82ec16fe080d4bbd1dc603203386f29a76ecae67e78c371426467db9f4f0fa99b8b80256554e83e5af3c8af471d18f2aed0206b1b9eede7e626332d2af1c4451d34a46ceaf4df685d803beff731c7e987c6be813fdaf14c864e59906fbbe13e5b46e406d655f748ddbecbfad81de34752d4554b808c0bc8e2e5e714a905928c3b5459c0bebb39eb5ad4aec4501b8ad6c69340d1c66722c35aeedc59e337aa7a567ac8679c233188eeb6b716311c9c95919730a083165484f542e41a5c4a3ceee074358a2a33217b42bc5f1ee857f913bc819c7efa06a01085531d212bec2375f3f136398c10e37ec7fd6048d160a3f72e6d73f58f8c5b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
