<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29bd8f6d4160efebf5f11ad3b28cbdc8718830a7f057867e1acd4cce7a9805c212fa3cd4d99292b2dfc0c15a1a8750ec293adf4ddeb22eb8be698b00f91ba79fb74b8ed6040111a78b74b647c526d605def05eda28d04be2d4b81b9a0938d019b16fc7e40d212006decb32220388249379199aaf71b5c06bf825094e6feb55b61d5a279161de8f099ec915191fd20e592c6c1138f2260be5956960f0bf15ba8659ec86602e1d271e2b64eb2048452c682cc22c36435cf1d6100785a513c5fd4ac15a53b632e860ccd7074cc345eb74bdadc43a9c298d85e7b7b68add4d4aecf831ed9a5b2cb5d84037061e083aaaea0ad4b33d33ee600fde6648b4c03f2eeda525cfe513fac338040e5c5ede7b157c8396cf010b9e93c7427288cc4070f3e8a42003897781d61faedeca8e9d4aa5870b0a2b2522661123fba119fccb8591e0dd55817581b02f657b84e34cefd24339ce4c4e2bc640277f75f8f83b30b00f9d94ae64651d29e0de9fedcd18b320f2e2b3134332223d387e9d7b8ceb105d660d04b3c63708d9020f8e697db50ebc11592f411f97482b94b1e7a69ab89ecd0edff798273d051fe03c6715b34444a7249f959cdf192ac10065d377895abcf8e3c23aca366c56a88596d617d1ae8e154104250ba11fc747b887116dc145b432a9121c4f999d057ad54f8a29d953cd813d1509ca1102ac258241344e17731aac41b18eb6b3a8da7a9f7efac829aeb3b921b30657d21422c20d86ecd8893eccfe2fb43862eaa57277844eece78e69dbdbcc972227d1ccd36b22116488b6cca7f5a04499053c3fd34631034adecb81b634a2a594e7a18327f17c5e37d803704195fcc87bff9175408c17a657f6986fbb1dbcd76ecdbdc192376bf93e1f81551ebacb8a911a3d8a21f1294a438d01c717d34e924b26b4c114ca5759fbc090c24061612cecc8e2310ebde796c0bb31c29bdb5c4bf3faccd3cd0dc36d024265494ec186dad2e1c2df985f8ae872063247eb8900385c427edb652ca74a0f960b796521e4e0bd99bc04a447f7f519a4d717c21c197e9d0daa59907157386b4ad8627b1d6c5b0c782c58a4342e6069b9958724fdc20a86896eeada558e866ebd6051fec08967849b5ee60866a8d392809caf96d962bb4609e6e5e3b8156c2e59f0aabd39e59ef7f9fb017e9da4e81761fba33c582c20d926295ca3ee7511eee81e95effa384e6eb144aa188b0ade9450398e1230e08f74899de10098277a9fd08b4ea4f1351c4aa6034d34d8cfb8329a367639a15ed79a0fa34c449cbfff6e21cf07121a5bcadbdaa1813b867feae0c227961780c62326cab25248f603233aa5fca624658583bca0525fbd2f8e36e40747921148b86f6cb761e176f0156d12806ecc9ae0f84737572a3f611ba4de52fad7ac907451ea80fc5881f5ad9e651479ac428715452e40f1b7506e2f93c42623a6c69944442c84261d496531eff32f881bd08ec15d75538a0f82afdbd4ed277fb29b61af8ee270ee36fadf0da2cba40f5348002392fc6e7ea08f9ca81fe12ad8cd8c932ef64e4c95d1cb9b870023582d03d3e6b64acad50ccced70451cd18df07747fff767d51124cafa2a167b9956310f441bc0b3d4d0442297229b450a0342287dd0a7541f65448dce5a1a668114ae18f4d678e0ceb7b6be586e85122cde890676958a4fe43f85253ef9a7dff09e724e310fa77d6dd920e6823c4da9b554c4b8cf4b9047c059c2946b859785aeee741c2d4200d1b03cb0e059bc7983d6d2823b9410e448d427c7230e450350fb069e8090ab62e1c2c30bba7d8f1b328faf83b269fccf679c9c8ba0692580a655045ba3d798ad4a061c22cb45226e43703409f4e3ecaf963101a4baf720f46079d463e3e48a386e946db91194f888b736b7cb8f03a3710be057a0af4be789def9ebe2b774fc99c1f778f5302720acc9fcc1b72f61c24c5888011d2683c6a7ca7f5b3ee332d0e29968b6cd92e0a90e002505fc4ed78c452931e18cf4d9a586ec9cc6e4e5698b09ca058c50bde24967bf59b6442622c68abbd60800cb270136b91b9f45ff5586fe667cd3a9eee192136469824b00cea8bd8c500ac1d4e8cdcc4d2482186aded4ee69a02871bc93212ed6317a59b411b8361516e7377dc10187924ad25b62877f2b51b5b208c48e2b695bcd72e1a81065fc7dfbbb9eae9219531272304fc59f35735bb53675258a1e0318c949a87f041000dfe7f6dd30e52d296714c6ef396df7862487b414fc51a0711d2f1c460bdb56a707b86224a2362a21dd462df16919d0b8535f025e7f63e58511c1bb2095139a3188b4a4668044444340b8f36d50bf6f0b0c0399acf476fc56995a7f2654c47d6a3f5c2f3767db5a1a4f384336e4936455bc012a6412c5e52a6e75aced341f6c750df6f00098cc9b77e059ac9b3b55c9509b10a96ed90411f0c892f0d452e4e27701f69e5c8189bae50a53eceb5ad545d3c509074fb0ef69a6b665f977eece60fe01fbf42d8b0bc108b5d98653175953959ed162984d6e85d9437bbb6b2f42000ed5f0c3b9da492d10048381fb8dd92a432ecf3016ecb2112d454b99fd01dc7f2a4709cd847f4c3660b3a85e2bc826764d12dfd12f352821cf7d03cdd4bec4b63fc0bc704b7f8d6207dfc2c1074a722254bdee30f86ab11453078c492faa650f7b56f4cbd1631d5f5b978ccced057673018717786b6d7620955d444ffe5fd6a95f46c67cd4f90e52e7961df724f94ce6e889caa0567e0ef580b2210fb5c5d2d8884896e60ef7809107ae302436bd98ce1ba13a057d09635e2f4e554f6a7b3161e023df7c91d370b46b1cd588d6baab31af8f0b8694e546ae098582b87610efd78846a6434482b4033ac8894bf2ff79041a7ca90d5c9cef0c370137d8f6db520ddde076b5f46f6fa160fa99e3a83a6c2a4f7964fcb0e2eb1a5facfd5258a266d8641d5045d1b844491459a70aa62afa054801659820e4d7abc9c2e69d1e4f86d5edb9f58d14dbd2e6db4cf69a6b7af8081790f53bcc750ae5d84251130c4a931bc1631ba4791873a0065b0df29873c6ab4663952c0852060a1c21fb366dca0581887c34dc204ccd306ca324fc0d46b63f8c4f9bc229e7225e2af3b8c5b3ef9ed06279f5c1a7d1cac5737edee83a1708ce735aba819209503e61253393b226f2446f6b4f027c9f0980bfaf55b49066fe860d6a7edb328940c45da8bc8ec3b917951c53af9ecedabed493633cc282310433c247056128a2d5701b4798a381a9091f02c8637c1f16cda4065f57581bbde0e897f2800d10009e3ff92c0e55e4ff95de3ad277e6d2e3058ad91390d183f13e6b32ba82a1c7ae7478c41768cd71357f128f5df05a1558f50a49fc9f5469cfd04e4f9f69fc04ec0d1d5ad0ffb4f16e5ce10b008a8ce8da70b7d776bafb2ca7c0e2f1837cc61518fad0b1ad06ed921a839828da6a7e746f138124f47f511a33e50b55a2994667178fbb4b4bf4fc9d854fce24950821141b64c81746065f2f2b50d5cc56ddc6e276194272a9227108f8c7d9fae6493355f2ee9555f80074571a4ac7ad6e7d5a057df96d0d79b524ad3a681e666182efab66e5c2cad3a3e4337196017a586aab0eaf8799fbea8e98bbf5e4a283f2f71979e74e84ecd50f1ef6b518ddad1e52412f14721065e1f7a47fe8135b5e8fa5821068e3a89d28a6ccf53cf592e9514007e03921e23a5634beac95d5fd9aae5d2dbdb00d94ae0e871616d7115db50a71ddc68d92ec47eb00c30463977bca03907b94f20db7bfb6da9be88bfb16654f4d9798c69ae5f76d417d349993c7fc49f5ce1eb4607986475a1dbc27de76a61680b41a86a554dae80b3edc37fedeff6c35ad1794af055859ca1f3802fd8bcc824fe66f8216d88f304d3c44ecbcb6413aa48751e6fc1bbc577c75f638326f751bc45e20b254e25c817a8d3879608e07c25cddf46ddc23962957a6cb061a975c7826071dac28810fdfc22c4de9069dc50a562a38a2eada4c74e44aee0705c752d3e6fd5486db76268f4447776952092cec7d46e723bce9d54ca96b393d10b5992d45e618f80b7e2d2d0da34dad3a086960339c72699103b31a718e51da6951643f8c867be914fc53911d9fd2ff8400ac24dc5f01cdd96160ec2783923425a0b2d0a24da99d7defced62e1d90d86b1396dc450d75b0d7e4076b1491a510589fee56c0f776100e2c185e666701b03914788d174b21d6db70301134e304bdf26e829389120f98a249ca14d335e4451532e6541ebd2f1bf44386c750cdf955622c882a9fa65e5bac6a1a671995c18b2853126337a4e637e7fd8e30f87ee612071a709e0172bd6a11050e182042675696743834c33119b75252ef4b1d92605e0a1e4d990cc685d26fd9a196d7407b44090578ac7560f41c1c15b45c5994ec2614f9b3516d7dd446c12dd418847bf611e2c1168f2980bd0bd4b626a356181368a570fe0b4a8c019055d4f303f4f5fb247a6456d3387bd08a0a3e8e5c26938a1c6ecfe90099f0472da47e73516e37a5d8977637215f66ef56d4a64c2568c8aa0a05b2cfab87625cbfa18d87ac2e24a8cffdf3b18aa1136c79862b499e6b5765a70be3a62e1d43346fbd5a23ecd107befe096242a751170f149750aa638a0304026e436e1fb5884c46539ea3656091b9ca8f0abd881c72e20044330e8124c789373fc4a5fba36e42b2c6f512ffa456a7ae2a988659e6198fe98da7706e85e8f02a9149877264f5f3986449642efc3fccda7d00aad4faf7b4d48f12cef8c0e26662015ff7af2adba7093d090d27d2176c23e23a0ff7d3de0ebbc45ec79f476448ab1875528185bc6fe18415e7a34d40de96509449563d92ac3bd4b9d05d4326252810f039701e577fcc3c9e28af7a5ace65e797a3a3c74bc71f2de7ce75810d46abd3e3b8177cca92b761094a3472d84cb55daf4dfc9247f1ba97b96cd79713c03201825ec87fcd6d2748b5576ab2f0a11378578a97a2b0ef0a2a3dbe0726ed9119d1c9a974178595e9d8288762805efead8320bb22bd80a507fa597b78257fc1560f09f2ca658af1ca18092989baa8e532fc9fc3b2cf198c4aac588f70fb5f93df177b79f2e44a8bfd5e6bbcdef3422781cafda97e80fa38a029564b5fa5d3dce10f14e64b237faed2b57a45273faf532b5c4f93f9c10a626424bb6d540676a7de7c8c614605d6854cf869a99d5e85f66a7cbf3a981f1aa2af4c4ba3d73a461118b8a522d7f87f243bd22353c19f521fd5fc6480fb04c9b6885c419c0dfc902fcbbb8b45927182c8e1cb3985c6eda442940b69262bbdd0f89cff14dde917ffc36cf08488bbb9dee37e593d99d1a262d8a05c2716de3b71273c2fda6bbfeec69eca017a232abe589d105f54fd2566561d487fa2509625fef1fc4be4075aa28021715201a4738657fc8ef2d67b4c50d6c292eb6122fc55bd4b45c7a9a7d8660ed6a9d4563838113015736fd3e62796fe2d3c386abadb5075c5a65fdd42247bf8e1f935d0825ee69f521693757b7b9bac80a100d51b3dfe44db70abac793166d7b2ed629a6a114837d517376ce10d535a3d36a83dc14f40ec2427ab87d4e07dcb92a481d1720488f77322f5fda61630a5cf60af6759aa784755ad58ee7cb56727d377ae811ff2ee45305579bf0ddc1602fe6fd6082d964afe01c1fe57d409ebbace569ace4fbcef024c950669069be9273b041987f774a242c1b98cdd7f75b0cc05c847a8c8acd683572977c0c0b11e1dc0147ee0d5a470fda022359b06150a87667a6aac92194a9407efc9a4810b51511881e243f82e49677a415a57d4adb1dbb49c35c3af1a9d51dc73f76e0e3ec9dde345032aba6b4898917b82a9ab22863472288eb616625d9c6fa150021911fa38f18977f749a08c7cfc4ebec682775566bef9c0424b15f372f302aa8bc4007ace9c4a5e632fcfcb8c708dc7ff7a7722afeafe1d3680bcfc0667ba4e03b6684c853a1f6c36ab51a10e5f093dcb443b79b81bfbe1adf742f404017333775d6ac635fbfcd346ae4ef0a6f504c566b2c0348807c537822dc4e1379cc04fdebe2880e8a16dd38af9101e39ed2216a14d6ccfbf17cec83e590739398b731f8bb5abd15e98f029a970c7a95081c5837113402ef443d5d9b301559be78b719e1a395f36e3a8f2c6f173696e6d751ba2a465f159c81b794d9094d522073d241a8836d382eb46f423b57fdd4b4764b3197fb39831fc3f0f51cc24a9a25890d1ec162dafa94f3dc55ba20775cd23c3092ab3bb51d52f26ebc0a7f82cca67e4b2d7ad0b9c8c1be6d26d8715b88fcaaf10b4f1af2b11bfafbfe9387fe1dfada9623353704e8302a20751ab7365a6abec6067416b84218d29bfbce52b9c7bb56b30345cf8e81e283305c7662eedfb1c97dda73baf06a77dbc5fe88618632a746f66a863a14651acbcf9946a71ae77383dc598f52cc2b7da1aad380068ca3d874c2dc7952dcffb97fd1d0ecdfc1db85d74bf003fd0bd5e6532ea775d6dc7aeef963d0a5861fe31bbe61df8cc11ed90020b6897d2aa7fc269e2d01cf83a5b700f3c7da2eba2bc3eb8592f21483a02bae0ab5611b84f4043f696c2fc5421bda0389d269bad9d5c02d208b426f73c067099de8222a70260d896d1e39065ddb3b224b9ae079ecbf812ffaa3dd0bb6a34c105738e7e1822331ddf540c553e734b85a8aa30fa49814a124d6bbf358b05faa3ba0b97c5c3ee539a2ab1b5257884910b0c6e56480d98710f01ccc04518e71c3158353c2beb311d97148f70d79c3fa02a97ccb60592453019ceb71f2273a88538cd928d6fa7d2e48a84e2703524e1bf14231d8a7e7788b690082c91d64479cea47c397a370a3673a14338ad82a226fdc9d21eb0dca893808f4aea919a2d5fb5e078ae94a33247978803be3a160a0a4f3aa3669d697db3fbfe6c8f66de7d739ec2a6cfa4c27c71daa32b15611f4581987cead5436b70794dc18131a35c688d2007981bfbb02f639b6320bf81938ecfe20b454b46ddd24a37e5b968bd42349344a3c7c51b62a9e915e716392f1ea9097ef1fb5fd5c2f68cbf51c82353ff19fac0c6d2f40bd2e617cec7979ff62a926e8a9dc6ce74c5eab26cf0a7c117ba629e21211f76d57e6a170b92cf022ce5747bdf30a7134e17db535f5cc57e72e4adafd69d53f6d8e653871dfe8dd700cf397c1eb216c265946df778fa4b16d4a0ff3483810cc2621fad30329ef00b89748bb19c3e59047e9edc289a3dd5272ecb1543f84e3faee0321192146356e205eef63c6d90ffc0c0d2d154521bd62af1b2991a1b0595cc8629d0e84a1a55dadf35d27e13e88018e93e2c9c66b0f63f6f09f9916daec19ebaf0d234f8a40deef9c9e97dd5433aa4fd2155152c4319b5d95781c53e72a1557ca69c59ab2a392243502b2925825321f19de3714aa1d9b90ddc06d49bdd04b52db11fa1d03f7778490414a0d9438f6d9fb9b9001eaa6d74baf34729542a9a3c7d331886a186bf052f9dee2ecfad8c54e96167df4e82ad3eb4d2060cc3af162c496e914c1945006588c082f7c0ba43958fc98e498d712c872f37aaeb1f888624ca1738ea916f6d3a288accad561951f61e42155fa4d3b576e2829c65975be2114edf33ff3220cf8e4a69d148bf32d0de6d7607586364dede1c1cc28ceb7c2069ba1c1a6256d93912a12bb33234e955e128dff166e657f003d5ab461e7d4cee3a43f59df9b6b3825fa5a67cfabc849ec821f911602d85f86fd081b4b789fe38ac1777f5893ae43668c2351e8b397e49c72a7eb37cd1e6544b22a2ee9dc1cb6c04dbc564b29b9fec76b1dd12948b066faac0f1de90ec09e85769fa1d3407bc98079a4ffd23538ffbc300b7b65b09fd2eba2addb74c18079ab13ff38632c26f6817d46f74f703ca3c219bb96c41f1432f9afa2e7e6d2aa8352b144cc23fd57a61cacb6e0d380d0cc8fa9cb90e742d0e1288996509f07817617d3a6609919a74da0ce8ec1b7d6d259a5eea87c2e4b5890434eacfb66f9aed4ea87872ea952f32b074a0198e45bed3d36a2a26949f69c1a8f6dbb0fff4f8ca0c1a790e1696b430365c2f4b5c8e35e997b7219df7cb01685bd4d2480b26a3231fa23da28b2abae3b1141782eb61ffe7b91355d8e74245d5716f66fa4ebb135aa28ada67ec26c6742302cb0893b38017f1ed6ea4f3aef74fca017d2bc65e99ff31198f23d4a8eb0016b1b54a45908474b3158ff5bd1e0dfc24df1dca04ac8698271e2b8a91a3e418c6c8cefa96aaec817a0a702c91b3b974df613319b03dbbdd38f8f7253a0e30f8060e537ba27f8bc814ab6380e24ececf26696b34ec25fe419a1d465ec025f90a51aaef4c31a5bc0dc6d5bc914ec159d5360604bde9bc61739fa213d58cb2e387f6db7c3ee4eaec69787d356e77b08f6229a4b75f15248dac26a3b7d1820e5985c134fe5e8b4462409c718ff94ea3fbe461ee77294a942afe6ce84ab8db26f2b90639534338875bc2c8b0938fa58618d844dca8ef1a55bde49fbe18757fbdfad10c2d87fdf15ffb80248749093671c7070daf61cee1ba50888ec00a1795dc11d9f40385b7a08d04144508740af43f177f0fa1ae49887cee114ce8bfbfdc65c74dc90ddcfbeaacf2c9b30a3540a12343b182c9e3ac95a9ca87487363dea14d06bdf9fd73edd9b401ece0239d006caed60200c804e74346e3c20f1f8d1493d183fe08156ec8c2c4357ca153903ffef4e0f4633e7b200475949b5ce5103aab341f73a8ca87ce8c7b57cea5cc87c505253fc6074702d92ddd751c8830683bb0a56b5ba462363eae03439c7704608408cb987417883fa2581eb44fc4fec2960d00f6f62868ee28688cf9b32d32baa76df468cd0d0be49b6ef4445b39c25038339919fdd9e9a6c4a3c4ec8f13a72932d31dd31763881b056cd7b05605d53b2942841da1ece1ba79fddf0fa9bf929c616a6997825d6ac95a262ec6a86418d3a12a2cc719db9fac83c9d107c879495c3d96004fdf6cc1d332d6ecb0cab6e620c5429639772f81090c8cf7a3eaa71eccdec72ad1eaff28115c3cf62b45a7aa2a4e9a04f6d3cbd945b45228a9397b2be1ab91136f21b94675440d05b36bb2c96fad54316d6224737e3a346fc7e3755537dbf3c5cfe35efdc7b4a740db6c8a599f6285f3075587868c94589674c5a6e8d90ac0f38970def161109ff49d2983721f2d2a4f7a4ceb033cddf5ddf17d84fb4e30409afdb86d50c2fae7dba0bf7c7fd942b1b0a45f64f3e1fb17819f8857a53968dd0b456b434715fe42782da10ec7e9f12db7ea7d66510261acd15481f6f8ae39432b851c43ede16be99fcbeee5bc46ae094af3dfc161995c9acd71bf1f3392b4d7dbd664b4f23f7efc74916e3f81aaae09e9513e3a68b68e0bfc22ff9620035abb706ef01cfb88ca23e59e06168409e8f091cba3bc15dbcacc4bc9d930fa66cd30dc875363e1e6d3da07f7bb1d7bf1cc88ee17c87d74c312e93883e0110a358039fee3978891a302330cca188dddc85a1184349cdedf774eeb4f70a642145c9c1e5ec0c498ce5644f768a8976e94b3c6e78560e01473236032dfd18a6eb10b3430fbf76162274e66c992ae2ef13b2dbcb23bf0a6cf380aad693aa7d212512b7273e782c91ca507453283d5c75eae31723847b9448bc790e2e512a4d296ce4a185d16903a9595eab2e712dbe9eb140f09d664b5dd560dcf81f3f406355a66a56101457e87c5ae8da90fbb535d50f18b41d025cf9170f33b59322a83bcbbb7bccb946d9b9f4378b36cceb64592b05a0ba6367a3d3042efb92f8c60853c6c54093a8ccef9c83caa6f32d6ad37dc0795085b3ee56eee0130fd2f795410628ac62fc3e6cbed2a4eec15719794c6efcb2d6a389d1906bb81e85784ee7844c987382ca0a14d05165c5545a7eff2fbe3a863281061b1130076f61e8feef9fca86b82358d4727fabe62cddd405fe51db37bbc61a994d9a72523c972bce354cc42e9180e02a27159ebcd27b66d759a3fbbb51a7753ff47f690b041ea832d73f231e2e420be9203a96b2d959ec15962c4601ff27fa46e763e7fe961d2cf37336469f1b4a79ade6dbc987e0b8f9a002f22b116e9147c6e8a612ea650fcb80d23eafcc00668b30f3ea3ea2fb30b9b487f4ce6bf42a29589a29b7b75c7393de26ee68a2ca45b3ce483d104961c2b336af42509f50778804b36f57b3c0ccfd0eda1a7138897e8d40243f73bc371d8d3a298c6f70da88aaae64495f535e285e953e4e8382665359b72c00d8c02e7103fcc88fd06d4319b7f70fa4455ca77466b25686b85979c1baac8b996c9fde26242c24dd8deb0b8c4e7caa3f9814000c181430e94536f77235a4e5bd34a45cf923e35896922513d43e47aef76a615a27835b16c6676618aca74e84f05c4ae8605f621eb0ad4c03902a521d748f121e460a0262538f25fd296a697eee9c497f55d9bcebd1c5de4e790af17302882e7db4d57460fe553d9db4d05ac8b32b89def349be406b1a37eadbe2b3dba958e3269a2ed3f2aa5d427c5a13cee6ad783b2db77ac6bf0c22935bcdba5d7ad6e459ebe8d3d1a5de928bff241c1b6ee278b970de06bb550632439e383b8faf4bde7fe2b24985fdc815739a0693864a26cc287c22a32544781ff974b937601ed1c1da3209883382e6989b5ba0375cc1d4576a201b87bcbf3d452b47985a256282bef113d0eba7d348c0d99161e3e7445e888cfa43ee5d92d525e1e9f1c030fbb1ad0d21729e3fa57989ba2e7c969dc3139e230a219d4c23158939985fea564a8d38f78550d7383b3600148285717895b20d6a2bf8cc8e73c525ae199364a386c16dc7110a23e867825a18d063f96c704b15e078a0a8be70104ee6544dba6d0dd2a028399aa836125522997cabecdcaaafe0dc81cf8f02a7616bc1e25077e3e38700553cba89093ca3ce0c24c07539c3f26aefde682e485d0b03bdc92db8aac5e7a182e915c06d644954ded06de03d97dbc8c78b928367dd4cfaa385cea05687217ddfcf1565c1c2962ebfe8ac3f82f9cefbcf139ac546ca687104e471ec7c32adf97d9766ca6e7731b7561af0d9ef4992556e9d72d4b5310f72cc04594c4f7f1f864d46e828ab9dbf433828f595b49fa68a98921b4d9de69c6bd4635efe8c43a42a2e8603cfff8f32c3313cc9ba0440cd5a3d373aeafef27a8bfde78acc56ecfd514d3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
