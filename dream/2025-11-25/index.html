<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c8a5c002404f789f25919e383e07f201e88a99ebbb14ff544247dfb0b237c28c5201f2aafc53803190043621041860370262268e099d9b20a1cd7f47f064bb9e9d0aee8c3a07b6b7444a714d9e726cd0cbc2fde45b97bb7eae6a1c9f3cb9e1acf973456d4a84fedc80fbb4e00219ace7c20cbf78713683b8d69217be4cda1f38e599deaee5c1385c14123410be1625748efd4f261ff56f74848d0ad217ff2cea05f8dfcdf6917b7bee279d1c93e7069e68f0ae0d57dec4c2d46ef02cf094ac4ee2146833ebcc1bfe619d12ef15c9a762e558c4ab0db71216a52eb4fc6ad706f1c3c90d48dec9eedd7599ba1d56becabb4942b7a5d77ebfd701bb5d6bf51215100a1d2368f410ba89f32bc633ec8eabe8926f85238a144b4e3d0457ccf19a3b71948b95f6b304be95d9de52695a0f0f921e6334a08f0fed06f356847b1581f8ec1ff3482aac8a650235eb1ff8617eca781570d01a8f13376432d3ab22e5d522d457ac98d71fa37f0ac8d5084857809f35d1235d03d22751ff665ef160b8a50ba3757dd715e4ceb4e267b4ceb222c28589868d13325c38c3b8d2452197a04f3047f8c0c66bbfd2ae2a9788c98475b82484c4d18f6ba4c5fc71b2288d06dae99f47f08382a5dc1feb8b29b125870f83281a07ef61ff64ae0a092aa9ae551f0090e324ea6d434c2e69e54b7f4df6326c0c637ad3d4ea4a46a8effca6435cc5ed85b70ebf791afc6a9dba0df35849c6d1d1b97d12a5b9cfb7c4218723848611e4a1437247adcbdcd8b0c6dde798b00c21a812910674d283b8da06b6d6aa83681b7ef0354fa4c22a021dede4f9f570051ef3d84dd27b73a71b0e1ea49092cf0b1655d12e3595a788a0519584cf0b9246d04134cbc923de1ef21c5d6e68428b3f00866526b52ecb0071fca955696a24c3d9e26b808cce966e3c0bf8e00b51f0bf254364b132a83434f2059f142631bc1a09a4b27574bbb78b03a2910a9c9d0ec89bb74d2c0c4920e450bc81731b339bb7dadf8521b5ce55efeec04de181b17319270c3efc2c722ec231ee47c073397ed5240daec7c63589978a8d391ed74fd7620e79dec10ac7bdf44c320ebc9f68a079c5e511957e98117a5c42f781a373c9a1449dd73a865e9fdd108efd2339872b9794928cf77c499309e3e02865deaee9834079eb5da79d54852fcc7b4841fe2ecb58bfb257621938684f7acdeb63fa764f9e62b41cc0652021e10b21eae2b28f1b14d66ad075d7fa0e6a147720cd61b493715ef3ba277a9f49dd83e8bebbab219fefa75019b6cab212147025aecaa558ed17c33e81e0600a93e8db08e5f0fdfa9f793806e6cf46393e9962618598ef293bea262b7ae8f53482a1bbadcf84db8e1ad0e27843e316158774fddbc032efddc882bd76c94593528003184f9e1c36d74a761ad54bd258110ba7aa2cefb50841dc61bcad13ede4be614a5fac6780f1b1153bc81c9ad55b18a7875f1b4a23c36b7f3f6c50a01af4f90e5608925a1f881a079c24d2b9ccb3b5cb29c0d1b7f439ce10656737162f46f1ba278bda29bc8af54aac6a248b40f8009475f46ec1797f405caeb8b6bdb5e68ddef3d5ebc406841556bd28bcc1c27bd6c28289f30e5d1c3e555b022f11d51e4f839704e7750c0e607df0063f3ee523a5fec03f78a49b78a08f18a1a5583dd3f3b7031455530e5a629c8debcb76fd1189f02cd962aadbd7fef03413f2f571c1954a7cbee444af2a4f52894bec0cb0a32f92714241c123601d0c25a920ff4d7188622a95e443cab9d09e4ae753021bde6d4ef7918fe0dac4ca0a4b6e0ca41c27101d82ba812801d57c64b8ecdb086fce86e94db325359fdb52130c78f90263a1d79965f9899b2e20b61cfe3d94a36153bd68636c4e0b8f53b9a23a8ddf21a9eda213ce4fce985e05b6efd193f27b753fe39f36f18fbf7495ba98c0367712cb6a78174a23c0b2b95ac88fc3c4dc8b35fcd4b4b25d156da937facc598613f6ee071270c72f3662926da402fa59f36630e8fc3953865f09968f38df3a3eb59f7a52e03182e8ef17062e6196662bfc624334a9cb027623483b6c434eb88fe5e3f61401093ef8c3bf2978ef7ee50901195f62f60b42abf81c2f67e560d029ab12da8c30c8288d8c743a6c1fc50b789453ce61d6530fd452352bcf90c817dc71af72c3f8d97a8ffd2cf4e74456284ff84e16338181762508690cadda3457cc7b747df5ce3583c475bc8932a3d7a7751a51c0a52c7f3ccc5117c847ebad3d5bfcd64dedc8064f06e8ef72f34079e2ad0df6e67552c7866d1edd7a34166469cfaebe6e7c6bf4cd10d16ca917f45a3ad42a627044dbd24659f3fb84cd09b18fb420ea97f9077f9b4738210e6dbe8d7408153db492d5ba8ac106dd2d588952425eb2e6fb4b6dcccdb2c645fdad0b08e13debfbb79f1cfd5d17578f7ab84d021657f0b630f0803d070956a6ec0018a9e0aaf41e7dec3d8b80175f0a2921c44e1496e5b91372b04ae74718dcc83fe972f9748491c2d403d402febb6e5a60f77d89adb3533a585cbe7aa6805e6f86ad7cb56fbd8fb8ccde8fe6a1007fc089ea73fc02a710936b204f5d28e6b3773c7e468f97fe84adb2c7515df28eaafae4e315cb50f6f363e275d04c4e91c92b0d45915d29b631f8c7fb09a54cb237304d179bb5f3a86e830ae0e9c98e7a288054b049db2d912723643e2ab2f98650c1c26e7ade8a8b40d2d25fb618f9f3d99f5384a69905d1628741291f1b0a87e1d4fd6d80598d9282437919a9780d8a78404d5906d864af1d000d75056c1516c56c0620bb44a85d1df6b672f39d19920fc0d26d800d0ce3aff333426ea852d4cd0e936ef16beec19b74dd76acf5457bcefd1ad504b71830fd771451ef51bcaceee10e9515141a6d081a6ce75e28cb7e23a3bc50f839b8fb317368762bc905f350092c16834f2de027d25676164b095bec34c5c691b1223a56a92d6ee6a6fcdc5056ee4872925d4c302e321c649a31cb5c0cd53f1d4bf734c098e0384754ab0834216235f769c3c22badc29b732cee1d60510116f38cd48e3a8a942934e6f55c1a9dd9280fa3e863dac8f43254585f82851478fa0bff9bbcf2265fdc862d894b2a61f303c380639493917e7a9a3077faa4e2f6f47cf27ec8e337d184855b4b144f4fc02f6f0063ad1b2ecb2b1dbf7011c513958bd3bdd259a7e7a0bbe4b59cde39932672733a4d4643343ace50e990b1c6165f286f8bd6489de2b2c2dc3390b0f27a07ef7c571125d23ccb69c2ac3fdb47227ebe29e9f5bfd3b67042c8eeb55f649b1da1e1c8403dc6e1833ab639e29839cffc80d9cae9d87e4d4ee15c3baa4aa0ac58a2274abe8612b758289a70e6d7e3255dd032275fd9679634fc39ccd9a71a8642f4420268911a3098c6b2184e13c80b444724fec41a4ea41eeb8e6d0dbdd1e25db87531489a6820128ec916154367e6e2664bccf6e48c1854db3e7aba844d0a1288ef8ab86e0afc4235c58cbf97c12dfdc011eb789636f12f99c26250578e1d7f154e120b2c6fec97f405f4865c6d5c029b44c387d80b966f54bfb45b61a9165c1ad903660bce9279372aa20b7f1e57aa48b308feca0fa29673789e12bdc89a661f5034b2141eeac2b26873a8c5efa97d33562b1088df00b29e2608d6add4032f728e3dd4a3f06156b8b4744d72394d9bab2c3c388ab70e22ce6e38b0edd0bc52c8b723f9c2840467fbe7ae5da893ecfaeb5e937db31ca78cf11346e342046ab56e7114ed00681aa170d8c0a6a711eac86547aae7a70f78d59926175afcb25612e9e39a4ec9ded4321bfe55c1b0637bb1b4189dc1878f1cbcc091cdb720c56edf767da2fbf9376645d2351ec28ff229fe100fa7bfb864554402001fb247917c29264c9f380cb1b5523938e97886e33a3c560c3d7ee0f443fff7ba1ac5181df9c31e037ed6441bb19d1e4779d2f0c8d52127df0d6635138a3d08d97e6fa9cd93aa82e8dad051eeb4cb17ff9855be547485cf3c4b5b4592881462ed637a96182616b59afacfe1baff21f67abff3d4b0ed480a608e18127aab44abd4d233f7beaec86fc6849a283a83d7b5860d10729db92bcc234c04c8cd02bfa9b2a0ef73cfa33a4bc4dd3d34b876c5a639813aa9ad0b69ba9e299a4cb148836dc43cbc8360b02380b3e133f89c209a230bf53f8328a3cb2b5471f44cb93cb3342d4a69987ba2465619529e5a1201e169ac2165329dfe89eec96aa2d859909afe25d40fd4a6f57f3b02215edb05bdedf844002620e2f3e9b33cdac36d2e41fa6ec8cfd9ad312b179c0d288bfae373be5ff2425e32a0ab4c9fcea8923e448ad1b96c949e82e762a7ae55da9cd0df91a090f7e93ef788b9fee302b52993f1e4c676ae42953cae6169debb4396191aa0e3ad2e37eba781836eef4c0402b35c639e0c8b81bb57147a287bb3bf322ee0cb8e221e686360346a44c6032da4643ac89ee08560426f1afbb4546bb651108fcfa5a59327cda3e5d7d2b6c3e0af59cacb71b7aab515eebbbdd56f6f4cfc848d2c133fb5bf949e0706715de45a693834a31cce098637ea9637ad13e20bfbd3b4a67676a695b10e8aaf3003c28f1087190cad74c18bcf41d51386a85f26f9fcd551ac61a979cbbefd42106438f76b3bf1846282af71f30d1634168070660f2a4d5bfbcd365ba1c1f0cfd20937b2e9ae5f4ff2f14beaca0932ad9fe17863a268722f3f8668a4c60b60dfc3f0f7d23171be9beb0ebf84682c72ff5b1e6bdacf17e7b88cdb71228b93fa0e65f856b64d02584a87f1a294918f7e13675cdb6ce203dda18ea0ec2fabfcd43d66bb1ff71ecc8c04ecf9154d08752b1b9eb9fc5228941efb4d587f1ccb7588c9e29a7db496aa3db0f2aac30d0ee6f55c4751c9ca70448634abb80d1e2ca55f7f6f86bf0910f4608f7568303d713a73ab5c70f7828b31c3793930fa4df902145bfde0f0cd4e7f4e97c4405ff363d68b8f3ca28daaa562b35b40bf901162282e259f7dd76425dab57814e1347746f21578ae6fdc0bc56e0e218591103329f48a71ec5fd7548d67a25d5521b7d05cb2683460b8f8dd47c2ef0dacce84812a6c1145535de7c9b89c52d1c922bab8ebfb357fc10b49c1841889679b84ec0bd8dd4f2d1feecb685e67ed363b253ff816247f152defc4b0cb19a9cdaf835c4c4308d605cd56c9da98247596c7c9320696853e25699fc1e3f265f98a7dc093b4aa110277e9cf1894b14f73b271846664a432ed5e436a789394343670d3bd04de403987d862105d5304c2761760e9018507d8f10535ce57b38d7954cd8e578dd828b61bb875b5fb27964ad003fdd022f999a51cf4060959137423a62d0ade260a5a66e98f6aa05935d142852cf97128c5ef037a3e411fbd79f5843ca6eb6dbb127c0eff93f418dcd04b12bfa524f3e1b367ac510e9acf6c6d58991ff21a4f240c9c5cdb96769752d41156d1dee805c79c6a0c945cd881b24f3e733870f632dc163c439993e6c6cda357710803a345c2e2d6654b30aec44fabf2c1bb753e749342a08977a5d54df8c1c7f41733af7da209024a278cf3704d37c72a047fa7d8a53cc721919016284d9b3ce03c296a391cebfacbfa604aac8f92aabda0b0cf59f69f201b5b96757c4b31b48953bdd11c9dc9a02d1d09fcb356e83fcc099ef035fef3fc447d417c28a04900344d646cd594bf0d57bcb9436b87d6c946d4e27a641eb94c4c728edcf75c2f7ec0915f756aa629c5df72017d90f9b282d076fb2e02caf2037cbd1aca6bcb713966746a6a56a15b514f825dc9556f60a8033525828979e860cc9717cb52cc71489821034b76c395b54d3c59e98485eb6d0191fc78de2c5d95adda6e23fd6424a87fadd6976df9c4d51833936ab4ec5821aa7b3f8a5bd620b9fdfe3d6699e505621424ff832e01a745fbd323f671d11d3b04d84a408ebb64ac2291b3f618e429a879e184b918e6a80ffadbcb48944fff4dfed3af2893b55d3576a696dbd4e315f124d2e23c0be088d2d922b1d4988639ddf48057959dab976d785f40bb2c5ea4d69cac9bad0810721928d2382363f9d25363b590834cae72fd8b22641fb813b5bb2bff12fe28e853d069569d67239ea4952aa58d9b70791fe1841f598895351e7938a47181dfe2271b77c7a3a0d69d2df00e3b21a8e27899d1609fffa8696d3b02632c73f12be82eaa5c3cc6e1dabdf95c02a1b002f52dd1be481fcfa0773a58e8464c79ecb672fc85d6d1731c1e8bdfec2f4af0e7a1f799bc1af6d22f668fd14479624babbf9cdfe7ac92036648df3ce1914f3d01812c87325bad57aaecc8e477bb2de7ea7e255394d8ba8dd676746057238ad4ae652da6c35672ed2d39e8ca49284d1b5cf3d30df2e7430d2aac7eebaa6ac10a528af6560d258c23ea36e5bbd8c8905d29b961252e8c4d917a00345f07cb54867e1cd8d9233e1ed90e21797176777b59ca2693675b7170edd9cdd45458176421c68f615fea504905529af6525588a456dbfb76411672f0881f3efd7518cba887662ca0ebb3a24a7f0c893d18187424263d8654700722479ba9465ea97e8e7988f5e929e373eb2d7a70dbf64a8f47067554c0e2fb25fd54db54e7e9442283c8f9589451974b9f655fe94b72457b704f1740b342eb531dcb8bb90de7b54fae203c3985eb4dbbed1bba79343306184086c79a01b1055ae55864788541f114ceb2e841b9684a6540b71d110f89a913021dad94753befeda19b4623ed8aaeff13385611f7f4142275443132a32428b3f9fbe2d57fcd7506168429af42c210ec2ba3bf289f239d0ba8a01289350e3db1d2fc8ba6634ca64f06be6933365950ca78de3ebf79472c69d96c2ad28fa541cafcb21442b69560b7abfa475642ba8cc056ec59d8ca8794558be664e5072c03fa682af9b3f7a144419d1eeae6923992855d0f6c9efd6256dae5c25f60f6a04177b15d5e3406fb4cedcb0e6f174cb95d58ba7d583ef35afb0fda2582a9de0a37e3f186e5db9f45687ed51ba97bf786b50327f240e93c7b93d15a87f51d41c3cee0847f98fd6f6522e2dbe6b4d64ec727fedf7517333022a3501a2f975716c7c963fdcf2a713820edf936fd524352b18c6c294ae3769013fc759163277bbadddb7bf787dbd9792a488a8e8bf75441a007862695cc066d9a3ec2ee854e31e7eb1617097bd033a946ffd989f54e863b27e6bd3bb9eb513a5e63de610e3140bfcac91f2900efba7edbe5b60742dfc64d71d1bfa02c5f9a680a06e4c64a276f0594d77c0252d73f107005b44d2c7529f2e4006dde845960237a9ad8b6b766c93869a16856434410a4ccee3aca0afb762b1fb237854a4c3baa0e8388399c007bc7233c7b4903f5633d3ee4e795bc033e350f0fab55f58150ad39141971c043adeb1d807f0d94f85a1223a9a9ac306f6c1a2fa838dd9cffe390958d2eb658f83a371b26cd7482bc8301db451bd4d971a823cc68c856cba5ed7fcc730daa08683745fa31ece59a0a4907b2ca43ca1cff4d983ff073d7430c3672fc93b773c585c1cab808600e09e87ee18db21e30999ad9ee63f00a732b43003678aae2df53f01364d0d807198409c3aab3262200485f84a62e7ed6025660ba9a7873f0efb48978b4c18f9fa0e336d4502ac779c7bf191c1b428b1dc646d8bb83faf7289c416d857347daff8dd37a7e8ec93248b5995cf246c35eb2dba9a39133bbfcc37511d7194b6b233a8ac6fde22982f393f4b2a454d49ebd22c7a9e75160d0c5cb2759b44a2647c09bae29d05a5cb8169f8d40feba9e7b4f27d2a395464ced5b23ae2a1e296a5650984a969e5c4e530f5300f400c8c08ceb80f6e5e123efefcf644d7649bf839c1a1ef78b5b4553a3d2cd3661c1eabdfcc8503d36ea3cf444482aead82a8a5d74fd13a3417b3e12b883c1015050cb4ff19aaf2cef36081ca792960c8b04143ff4b19c3cb2a2e2b1810a1f12332090c34a9d16bb4778ed9d65de88e67286254a2cf929271bea5c34f400d82d8d557c2be5acae9115ea25b87dda6fe6154a12d9a2b0d94692e18cd42b10f96aaafce9c72b394b20bd30ecdd01d578385e00556db1a66a8e387db87ef3c88109389afa84e117b27ac3be633f5f901a6705363a435063ea6f8b63c10b7d85d901ff289a337191a04a271c5d8cb1174516379d8590b4eda19839d21814c64032c6730e417b77486e3b42c23dec225df611c0187c3bef1e32886c30eeecb39c78c3e9cdd6f25bde38afe6d2da600be324755d3da40520a0b16f53bdbce5a010f335202d9c0afaac9fe558a297efa9666879e5d9f0eaa55eef5a287d802b22162690cf3a29d7fb509946a363d80d5770ce478ce0d31b56d10b0badaab7ca65ed81e87b195af743119966aa89dbcca76c6641bcfea9fc1bfe347d426b1d6ccb33881f0f4b0f78fc75b3ec3ce893821b8e0ccc9fe8d505672e14930aa4931c67245e2aae9c05a95a23342508da70abfa802f9c045bc91c6563225bf763985022468ba028920dd9cb933a0a52e5427db9196bb8a1ac49c16dcb8415ce9d2e616e5c028b2a60fda7abab7e7235acbc11c7f860577a5ec0f70c9ee7101cd4f8f8487e195397a4be0726ea42a75946afb819a55f0fcfe833bb2125a5b24b8c2326bdbb4c9a11ff3d6f293705dce639dcd2105083b4e9a7d18ddc564114453b88e52a8b1d0a37c69bda724e1f97ffaa92b18f2c6f6aee75fdf313ccdc88eb1a7a1de3277b3dafadb570d2eca0b2b96886f498d1bcc55214443a17aa83d6146070aa1d8587126142e292e727605e63d7b4d4472ce78b8d7178d7f3adeb1fbc50cf69f16b8dbeb23eda96c410a6bd59863e142eae92c8683f10bd448ad3e8de608060a9444ee802611f5158bb3fbb34f2738ab2c52c9da1789b257b814fe55a7bface290da5f87620d335b660fccc085691a1e1bb70c59c13ee68691bb4f083ab45fdff5f86b65fa1c883a30979997f4870c981efceacca5825e1d4f1cf12975f8d7db7b1d0eab1951b1e4964783d8fce897895320a8709175681e51b7b4cce187c2d77c528c69fc17ed16bfee796818ef3070a3f80794be87859f8a26abbe0fbe2c03e0bb7dd59abc2bfdbd8a34272f39f1df6b6ba057113d281bcbb8c5805b055dd0c5ba8da82b4e45671efb14d39dc09729d177d9a346589785dae39d64aa994e0605d743fa83795e769d3737576c6e87281519d560e3fe50e00ad89957d70de4acbde91c8b7b199314debb37456c1950399a14184922ff780b3392f4ccc6119bab423c619bff56ebc840774e07eef567bda7c40d97c2fbba35ca212c7e7a07ca118dfba8d6a371bd69fdbad4728da238a792a92aa42ad45a66fc0294370984980801b6a73c0d3cc9b182a079d90d019110aac84768838b8910604521d918c25abf85027e5f5c0344d14b4c6b38b4aea25802c120ac99316ac7b2388db8bc3a244aff39f194da106b83de23764a0ad948edbdf5da3417cc8d797f6ce0d5baef431b676be2f716cc8372fe0a534cb84a9d1f950183dd324f1c217c73e63d40184681a764b0aa05ebdfe56f48ee15c43ac4f8ee391e72822a3faa448adc1c83e1fa4894b40e40b134337b0bfbda576a75b381f36fa8621f6b30e9c16cae470de05cd986f2cb502b4f506ca18f9abcd5c09d0de6e759c331d1cabdbac491117e1a97f665a216ebf4a2917823ce5d506da5ad273494d77b84f54942f6bcc0294d313d1c18b9aefa18c7169ef271aa51fce9dbaab3503c828a4f609ea5df41ce446ab077c56e99093450b987ff717653bc735c268b945cb1f44e2db37f0f3ef55766a479e5c8dcd241ca142f420c282d410fa7422d688cba970ba767f3cf4644ae3f3917730615fc0efd00b245bd42f01f70c69ff7814cb0a55a3e37630a9bb3a996889e1e393952fd8f94786803e994e61fb4f963bfbaedbff0f9e52c3efae9e2f3d7adfb125e89f754d007cee393332d1f145068c3aad4c898e058f73d04108db5f742bdba4e4133822c67d1300a5c1a9b6377fcc32c3b5265bd62221e2ad02e6690eae3bb4f04e94aa6089dc636ac25aff3736ecd9e3739550347b6cb49223fef2615a9b2d34115ac3e5863246585b9ae993e0c652b7569beb1d68d8859da286dc017a7921aa8b347d3410bfe246538455642fa36dae9c803035347a09dee4e5792d4da36f723d93a1eb7b74b8b6133102ce2e7e8a8edd5481427de907b89b9a74c006a569064d81893e2256e15afcf6112519b9ed0f5fba98c30c1032526d4e2694647e8df08b2f1caa3e7e53467bdbeb0dfd0e862a966565d548a0e56b969d9d766cc826ad3033bd497c8b9bc17586f9098a6f2788db2908c4d70aefd871bad62f469df7e2c0a116fb5d3b4acce2ef830d663734b3324798a83988688c278b32636562d24a2a0e7935756ae786d7a14696437eaae62a18b1b3f2c027f87e56797777d4c4cc3444cc9581184cb09e7b54121c5759fb7289d336509dbb2b3f504af183cf239a4b3849d0985691beedcf4e5a7d3374e8cabdfcd4b7424103f39b6c5884b8b3962844c2a15e011d0cd426d5fb9bf9b9a97a21517cb695e3347edd290abe1a60639142d6a9f0e13f57718e20b41a3e44d5f4880065bff62205837ed15c8cfb2abe2e46e22e50a21a3a2c7d04ff8ab625f65faffc3a3d98ef36892bf730afcef601dc18a4942a1ae5e820071596a5edd672494b4e0304ad4d23e7519da3913e75be3fd4c37c7f21509161c3fa465c3fd854f90a1d3dce01cdb36806634287fb75620a298ab3c45994d10714f7f834dca66a81ab458cbbe8ef9da652de9bee3fa1a47e90aaa60bca91682c5b91d68c6afb1cecd3f0d2a1e5d478f049bd14e4c629e1944d857e4aeb4a32b22ae53040617ed28ee6ef46ae9b96b7865883f407fee797f200a5ebd083ac9bf0d0eb81703d9e8d923465d454c2a90063937585b5c1d0a7d7e80e01853c949c56a6bf1ff1e3432859c7873be1a8616cc9dd2b895eb0a255b6b727e10947429e9d3cd687cee82d018fa5c33c16d337388f79f40d9421669f25afac775da0b6f912e4d12d3ccf63bf6ca4971a8bd5f2800d590cfdb26665364da001e0e1533b0ef95ad66bdf28a3360556d60b6067b14a736a9a3b9bfecbdf5dfa4ee4475d596f7b2e5d751e3f440b0eb983d50fd19e4480a14ca345ef7d25d2783318eb88d521d20150723bee151242905e92a5d89f674bed7f6f744aea6c90276eed5f189d67ed7c0ff46f9f2e7b3083924f9a127489813b6cac022ccb6955abc753ac927eda37fc8134d0f2eb58386658762a9e158af729bc8471a5a4a8bd431f88303f9e8a7649fed19b61ae3cebc5ebfd27e261c3b18232381a8ac3f0118baabb53ec293acc9580b07fb986cbb18397d9d3c02ecd34dd3d074717b3968040caa5e160c65da4e8becfb4634902108647a0d62cac08ce9d368c2ef2c62407119bb8fb9c2c09234750582f6ffbb5f17d3e43d2c5752831f7cae10e1b51967eb7bf9cc9db8b95d7a22949004c350a43ded5d581c9daac7cc14b2ca640c2fb80f3d80d295ebe170c542168a1e3ec8e6b1756dc32fd35a921bb0426a228998c368cbc7394ee716ebc794358acfac3ed86867b862bdcd474c129ec01e6b27f19e80a873edfaec42bf8f5964ac85e0263b3a9a4e9d67cd0e2cb92ffd84690ab2f6e3c599e69c7952788ec54bcc1161a8463f9ec626a68ff32ea028ac5011a76f2cb7aab669683ecd408323c31f995f371eafa8f5de35b5b8f9b85e45b4c781aa90e797f3e94dcdfe54707126a88cd984f13e7829c5d389d9bac9521592b053f128a24cf7d47220939a38c0c409fa4c6a508004c2f392f1e974158ffc7faa3e7843c7bae8674bc369a280ccf7d9048c4ac6bcd4c317eee07e1dae4b7f769d7d7f840ef5e3833e5ee05286ab802b56411506de17f84c38967dc5c07987232f250b4693ca48d9954d27324c5ac269131691af866bc00b5b48d89825ae336349428027a17e1698b3b67a2f7538c6f3a28f68b7bac82ba748f08a58ef269356ff4cb66584ac8e84c24be00f50d981d8699fa2a7dda3a239cfedef3e6e60021fd83ad9e8223c5007d86ec5cff9fa64679c8f75ab2e6b7fe7de2cc6da1f24fc7e031b0b523989acf2b7a58700bb3196b0efe6594ccbb4ec4d3926287c817849d72a52caa7cfc53ca467b009bbafa9cc770e835833164d4a38beafe1a6a3cd2f3cf030cb50216fe229c89a8a759717fa1ed675769fd4f391f5ba951163ada86bee3a542267d03570062df6fac81d0687673bd48d382e173cf951c5dc3549315e4d8c412aa088d4dcda920c2e8863a192941753d8bbaa04e50e69fad8e94a16870abc5f3c899a33ea3ce12708425735dd46cc154cf8795dd41c539c3c66f70a5a1eb422c34f8a7c73624a5b1ad91b7bde3ab9ad4ba2de5fcdc0c73a7e741b42a93feb37f2c2678765b4586d3e84bef9a39eb0369637bb1165769f3b19cc37c4d6f68b7ddf23606eb4c71c72984633da4a23d71929bd3a284ad7908e9240c1114bc3ec1699d891a9c5c515ad200f2df47b48d74f6cf288519c9ae1d97d3dfa795816fbdbe195ec0de3112905400660d4f3df9278d7de2a1bc6bbbde43ac5cb841fcf9afa457b2759f982ae15951ed37dfcf69c1c06cbba79c4404ce5bc86d04efdf771568c5b9ee5790decb9f2d01b6a4fb40c4474edd041855c4f1295fd01f2d089c0bf800e15aee1849ad2accf18e9362dd86bcd36f9003db2e632d697fd3cb8ea112610e4f81a46d3514f0e0e876d26f264a7e8be06e6fee2e5f2e15b297768f1553954050ad2df2cbcb788dd7248d30f03d02eab5c1309928642cafa61c9d1599d6334654a4b976b400b00b47a71ed0ff7c1e9e2ee04908bc3137f3606417368414601f5f20b48e4e782497ab051c0eb3d59bcd9160f566390cae40c5129b374c55626bf2cd55e4e68cd596dcd18bae00c399da0f1405b76909f226479100c62b967b4a90b49ecf3085a77099ee1de7c44955c934125f72afb9862bbcb751d56d4f1c66f159b61bbe7c5d33f8717b17646ae0db992018d210c704d2663b8f11becc22e30c316cc8f09d0f729a2ec22d92735a0e433edf80832bdaf7fa941d1fd13f905e4eca33bc539fba2260db7b568bedd444b07fc7d22396b0c3097d6e4bb25f56f02f5267b563a1ee51ebfa84bc3f2b1b4226c5b67953ad97033e224860982ae6b2fe995134077d9f6cf4cec46853877cfdec5d21acd24e9092a674408d99cbf8a6367ecff4b9be038ee652c63b48331f430e047c0bc7f4a25b87be07f848e0acfbab56bd9afa2f2a0baf34185caf0483c3e0974129da37948d0fb8e3c273b046a289f9d173bf4825e17b742f5a95ce0b1ff5662ed68e9bf3797657ac2cd1e0e71e16ce0a7c57395342a2362270b39242bf430c9c3967afc92290c2aad74490f542d18e8b53bbe185772507006ec995baf950c216e3c6932fde746b4aee3300a348763bed0d5c948ee4bd1066cd24655c11860b838ff85b38a29134e312943c5c2d6a01a3162dcb79e79b8bbde45514d63e559ac21aa84b042c9c992ece5d6b3793e4b2386c9d768f06e01d39efaede7e2effdc2ee12e1e613dc20fec9125f8c6db8af9b7bf4c8019b32dda1621c6a8ae41fbdbd710434be88f6a5143dd39818aeab7bf911755ef1103cfa8dcc928842157a9f09c338f413b600931dd264cf7b748cb128705fcecb7838754f0af4fe6656d08c67c514bb8b7a6102d11d5ae88ebcd5149b426f324625fe2e07ac0d2674b98b57782b5dfc4b21419d807c34d1021f1ae2cb7c2784c58a01d823a393da75c90293f2bbb169168c196065f2f21912cbf6b0154ab38064690998a8c01294e58e2e7da053956f1e4ba52e8673bf3b937e71fbf3a24d7f712db0c272eb1d51e25d3744cd57bd7f2cf17261564833183cc7e56ebed908431e8741ceece8fe02644c07f0b44caae06a294b25fdc2e2a24024a97f97d194e5443d27b491b98824aad3d51c533d176ee6586f2ca4831de342018e514fdbc9bc79d7266224a797dddc4768c20b16e170619b8ffe4a8ef443f370915f7f4ad6c635d5fcaf07bb473a6bf3b9e5604060aa69bb458a9f116dcbc50c0ac3ad207d90e97e0c33c89d067fba65be7885ed4a4617c9f1b7998520ffddcc7626e3690bcd5c880701956604601a7545a8051a034acfda37a07eba3a6fd66d13942c88773989fa014329d42f6fc6f92d019be6a6c169c5f7fc4400686d38f19fcbdd640dafdee3b23284c232199bb455c1fcd7f30d66c0ab50535603a52af67ee688ce9d0549129e8cd2381a3b85208d0ee0a86403a1ce5d8029994e6cd5aa4755d08eace3f2ab563914692f7f7c24db9fedb5dd76e968f4f1aa7171b73faebfd3b015f9baf208544866b4a77b6d14efb01658907e6496b82a9aa79a609206af82f16d954e3ee8768e268547e785d44b156f78bf99f1c662707cf6ebc31ea9a92e258bbb117436d5c68b2fa0c0fc77e512983ce7af6040d520bf92d36e6da5892f0df4b49177e7d044241c8980530e9ddcc9161fdaf8471f5bf8883e3d3d8bf9c225b171e3a4390550d2d7d11a7490342b605d5ced67d3b5dff6a39f77debc616a3da3e6b75a700c4eaaee8b8affde9f6331e4d3a5eff736fa685a82157c6d491b179ea83ab2ec6a2ce25badb81fea558aafe5730a9d91a95bc8ea49688be7876161dd1fa59bcdc898467188d952c8fdf21e657972e2588975ffcf19fa2d37f2eed0cc58174085962920a3eadd48d9118537b2a2321ebc3e3873209f76054de8beb46b76e43f931624ab6cb52eba3970a5920ee6a4480c378e3979b07ccfba576df8d7e2cde19b93d2ae6ba59a616ba10a1de9bead8d595cd0fb0befdcc98a573d9173c04f689275dfb8a68496cb98c25ce534492dba75bf0bf84336e96f4d3a8fbd8e904b3fe28253a62a6e5fc3fa1f997b7683c5427617b43d51747b44fa0d8044e7721a204e4d26d51774e3d2ad8c00ef5dde2730b6b71d35132d26d8868214f82a37c2e974374ca9abf1a56a116557e6f99b21e9f848ee2dde45780736220994c0613cc2de940e192aa75b1dca2f0ab14616276190a3b0b642aa6dc80f0d1eb2f31d93705da1dc313579190576ae2d7e9736db0171a55b9bf0b914962b4638c83c1ac61aaf6963bf4152cdcb60f87245ab1e4fb0cbe0618d902b62b801238194a0bffd21848a0b8c80c73431a080c90445ea220c5149fb83232e302d9e2186a0c460f1b5ecc8bf41d676cc156653b99a072d7a584c12f705de95cf26d7150653394012adeb39151a80c6faff4ad62ce86af4177e4b48942f5476ef001559575ed364dec970c5551560e5c9503c6e9539c0fc0ffb1d32185a1658c77b31881c55379c3de684e39042a2ae0e0d4962b285c0f4d2cb71c0748fc81a938ca7f0493f6d4196198b4c2b7cb77024ad6fb6ed6b72126f04716401e7f0876603c72822e0eec5236f8ca287a5d2f9091cbe5edc4753d8c62642435169a87a9f5a2683432de5a0d813dc69bc2ceacce1aa8fb9d292d59391f0cf29cb95d19b20fb458240b7b909a56c5305ad41723d7f595f80e47d54546b47732fbd645790ab473b1eea51f4ff1e7bcc722cb73bac9ad1e1b1856bcb770f96798f10e270e255597aa1c04abdca9a51c315b95cf551ab2cd2c33d66d67a15bc20dbf64ac4733bc6eb2469d5e8a89028cc8d651dbafe08f99c9be44a8417979d6e5ef21d3cace979872904a752c9fcbf728318dbc75d13d1cee490b6348f4562637e9240215aa79a444a6714fa3384427fb24d3a643597ea16ffdf9a587689dca75692b853f8d3c0b9cbe38e3cc7c39847afaf396499202c867abc34a42238c1cd26af175d359e49ac7771d47f55c6693d300f03877d73d88cb7ca1b1e9ef299f37359d290d86b39f2bcfda10141876779220361d7ecae8a1c0a52637c0cd3c7a8b78701799b2a3ff0f0d80c7e82ade03e728d75e9400dcf63be6e004564a943084f5cb6324ae709f851f7d8f974211131ba87e9defab851b13e7103ac7caa759dc3b766030dcdc45b6f10362682fdb8059b52abe69edbb558ea55ed316c80b2e890bdcc0383a302c6f5cb05dc33b6f5bd8fed96a0168c876a9df8ec449f47786847f228bfc413a77a325bd0eaaebcd0d2f12c57ea653dcf5e6008354d7183ac84de5f609f049663f2de410b7a43153def6fcd3b6447f4e6ed53049dd8529721ac5fa4de402f3e05bd269556ea0a9d9b2d582356e20da4f241ee6998bc7f2fe6326380699d932a160dead219c79eb2299bf5301b4fbda99f75b05349f93f9d9a39f47bf1e06ae228e266eff321210d50cce04046181afb389c83b7393f585a19627e7efe36bb3c505094eecf2a56d1ec9783d63c16674d8605ff23f2ee3e32004d7b130bd874ccb69ab960ad13e0689c83f3670a85a8713fa99a6b85c59043e7626c0cc5fa61f38cc0e633955838e676d5ad3989d15282c1244a4fb77ff064e6c578f08558786e6876dfe912043832e5137b80ca7a74d7cbe0ceacee75063ceec9f40533576af5fe3874a3237167321fa2e861bf375cb1dba1c52a7745a2be83eeedaa5e4a4a8b055797ada2743ba8d35929f9756bbd50408698463d0b8ee7e07473e045d1af5b81a8da565a62a2a3f2125f1116f7cbe42f7e010c3b7d9043e81f48afd61c28597d549611d7390419f6ebf90c1932adf82978f45e65a4085db681647f832d3cab93f20871885c58be54fadef12e558ab2720cbdca9217c32d65ad94866f39b47577f2d805a6537a2dfe00649d0d2602f92a255b3c08593d25c5a27c5a8373c5f9b59d5a68c40037a51eee8ef6c9449f7ad64fe6ace357887e69aa823f18b0f99cb1c46f1a3b8ed698d57d95c6dac73bf809a90ed609f509d7978f78ad5ed4eb9a86749489c539b132142520dfe2d4d464880346113094705f2c8bf34a40d9b0fa7c8a553b2c996fe7061569bcb86bc2d92ca7aa356ef9b6ed41f166b6e5529fce85bd5daca74d852d1ce422d35b2d077c11f2069b7e6d3911637fd3520b97d6b2cd709ecb5d77dfc264ddda886678d8b513234b9bf3f1d0f275f73cca75a658d5320954b828efa719bec06abe0548d4d3509ae2df4c5bba4fa0ee7b36abb15ba0a93ff695005a91504afea8a89179bac38994a7a2d301674044d110a1bab3d43975654bf78aa3dd4a9eae97f6f331bbf0f02b460f0f1db4d4a585d055342a469b88db8461ee07b07234db2bf773a94a12aed52782e828da2d43e99f05f2274bc00624b34b2d0c795de2d4b902fd32dde893d1ef40f04d25784eaae73915de09d9ccf7bb487c7a44fa46f1f5ef55cf6c4522efa280a08377730e686364d37386fc3f2e493fd9be160d153920370d5b36c9fe5175bbfcc8a4b16f1954fb78855af3fded6fa3ad8dc45c93637867e34ea1a2d4196127ae568d2d98128d2b5819c87a69b6209400a9129ea9acc550fcb7fb458d36be2650e6c973d4406380c9542d376baaf049b8102019da5d4f93b6a80e58442c9aa92a4ae031ff9f67b7134b62eb9c0103a9a63542a81ef1b1ef601b61703c2b336b2e6bc7cf11c4c78a235e244e20f9b29cb6cf640c97dd49e6b6b344328018da2917cced57fcc2e78cdf69eedd79c8ee8a2c9554d1867d45d71d8b0709f698654cd013280b2d98dc98e42f7af4e307510f7bb493bda009d02c6299d17a9a825e5b1f24eea4ca33af576a3bb246bf4d12cd51e23b097f8d661b97a2b1e0d54deb817e3023ee9a0ece82794a23383fb653ca0e07a99e852c3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
