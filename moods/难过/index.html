<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15710064549065871cc3f8022361c304c5e9677a4683b7521b6e1d6fff0483e55069d9d3ef757271b28a1327e2c94bc83c24a3eaebef05a7dd6c23f4436ba2fa87cb5b82ce257fdebac42023c699aa07039619f7d7f76759c363687143b35b99bb50c21b23066cfbd9dd98fab61128e1e993d83431030862bbf9934ba93ae95bf4c6ea76c5d39c381864d4a4dfcf48afe900b615434c4fe3c34fed6b9c8d38152bac0fba9f6bd44671e70362add67c912efde070c117af37f118cd2311bbb72a9e088088f11153c7dc5ca347192a33dbe2dbdc59217d0b0092873a14198d560083267ba588554fa72aae54ae6d6518f4dcb6fb07e299079ffc0fc212beae83a5bb082d52f2e71b218f5db4112db8d7fa8762a4045baa77842551859b78ee92d04b1facf550e391c03dabc394063821a55fb6f0606521415365a6d9cbf8850323b93d9b8caaee65aefd850823a36a81b64c14abbb2226b3a2f7923fa71abcba909addc4f9b62de9cf98e82d1acc7c3d94cd0bbb91e3213addac8f996a2d8e17f34c0c407f3323587da1f821e501135ab49d1ab0ca759db6a294218378e775be8026250fe964da3d35ac54f4e99647a89a06903f8194baf144fa11e74c898892ab3f7b58a59397c2d37562ef3d91586a9e76bd5f05c18b1a7597e0992dd1ec0288fea4081ffc631617c2c977094b029862d87b224394d2cffb19c133bccb68adf47c7babdf8abe4ed74ec9dbbbeb801243ca75023d0f90a372e6a76136044ba7dbffd6e8fed50e90498012f7f1485912fcecf9c98aa87fc79c70a3f299f94fb5473cff446b683e7dd23d9896a1a4b7b3fab1109b0cdbe9c321bd253996bb52c24effec3a7209c01c3f54d275d8b3a183684c4e79f62264c253d468aed630c1a23fba9f38a78ddbeab7fc3d66a4ddc4c8f189c9e28d0167cf86ab0c520bd681ccf00594dc2e1c011ec2e3a4e0947ba72dcb98f4cdba6c71b797732f19928b545c2e3ea86a081963a3768b0c613eaa8967c8cd47174e3d75cb653e7ae906ae32d7b967408420a34ed17c43eb09bf23aa87d5c18da1ac0ed98267dc21146c78ca85389984a7085fa7a9e2e1b907320b0dffce37b123b1500c7b6c1d684e6c75e563bd12b51bfd92cf3fa98313e30e4365b2a87d5c766a3a3d81333ff663fcfa5642515d09c8a59e67998b3c14a7a95f7e6154388e12b83991f176ff1867b01aa328594f79d7d28213fc4c2ad69ff2864fda989313647aaa83654c828c44f78c230ae86fe1e5ac6679556670344e08dac4829943ab76d0d3b0dbd1e0fb3f44fe7333d8a573d11d14a62a634b24315efc5615b7f2dc2e93953a0d25d4af6a4355d552c287b8ff08acfa9f814cd0bc89be797cc7ad03dd046413063e587c8718aaf33bb0ab98cda0a56fc680a3fc7196407c171bc6f3f5457f0b0530c367e3410c45f39de2cac4984c94d2783912ccb404f0ef2050a5bc6af1a7e63760196de0fa40adafeab0aa6e110db4ff9955fdf8e170442be8e0564936ce49a0f9139c2f92123a04a379218b16367450e7490671e9af1bab2acb3ac36b6b7d93e0fad05fde185f7df2fed7e842a89cb2049c9361c394e96b9573bbe2f29e16ee503f2c1ddd2dad1df1de752834a6c6d9e77b355e069c5b7030bbe317894db0cc531a2d796a88f70045f692e2c26b8eb48c5b104eba6864de42d448026eee449a681664d7a08e4aeb42a29f109178145d8d284e43fd4bdb0bad5a80e5df68b717a354ce452f5f0085dcc366a47b5dc1e2d604b2f3bb791e926a83fbe36ebc64c1dd42c32e3aefb8e5223e2add0a4052ffb47cb7d3a659c7833d76761faa3b50096e35ed2b621503b7afc6ba84edf27030195d51bcd21c8f83e1d43298bdc52e61e7ae2b23b77d846d8d2d452d3b7ea46449a3c72f3362a83ee020de96434432b6cdc2bba4ae447004d017eac9231ec009662b885c06b182bd20a7a30f46ca5845e907652a7330f61f90b95c244726d3259fd4da8409991fe3d8d593a2361073daa0350dc0738ebc52e24225c4f8b0376120e2a3bd2439d37ba2a579b23b6928aa861b78ff143ba8c64fc96032d0efdbe48768686daa689fccadb818cee60e655621bbb1fd421bd7b6bd2e4fe3929ae846d4b8a0088d7d92c8fafb807825f5c3d491b6e9dc0391b74adaa737c5c3e8fb02b68c3c4d4db44d6b4fb9e6ef03e82610023a0e5eb15a36437796bb946991d30fa740bae3be62df4ade14d6884276fc3ef42e457fe1d663959114bacbfd3afead2c68f2c3998a57c82a84c889fe882154957421a41d7e32bb5952a5d189fad28a833e8d016a8d520b3b7ad501a3ab14af54597f9a3a09509ac486880312f50b4e07772b2a25edbadf88bed4a5619f59622afb3e36817caf0ce3f713940736d7b60c8159e6593091001719f474cf25474d4bffa4a31489f8911431b37781752ac4e817c38d6d74efa3db8de27b4658e7a615d7b98810ed08e764726bd85fa12e09fe98f03a95ba7990cb41c927e596a8373c2da898030a939d7e82b35fb2d633f4e138e02c822727e373b6f906a9f0c1f8c1dc36b697e25dff33fd7f9067e65ea6c1cbffe2e9e29d36d37a22aa53c1184e2969dc710007e513bfb989c4912c4aa313a6c5d12808560be15a1df5da8fa275b9254a037b1aa58c808f3cd2af9ec7f5753504c822cd1e5bef7ffbda8d280cfefbba54b5cbb55dd43c89b4ae69632988652ca607285ad90a47ad34871418c8b574da2394fe64fdbc0e418cd467c20a382a41d5dbcf0bc9c88cffa07a814b7e760a332ea1c96b889259c4d94b1409780330e1452cac3ee8e257f87f0f6a42ddf5cfa7d9c9a814bc894ce2488d39667bf142f5819d0acd34a8d6fc6a0681bf8ae70e1ff8c5f4893aae1af8a940714ce2ebcc5850cb34247f506bbcbed74a7f1ac7923e104ef2a3ada264b18306622c09586829c9017b5d07fa71238835b38d15806be12c12882a652dd94484422806f0f89bb6bb707b392078d6c6456dfa60b434a582b7928991c11278a78463a778f79ffc1cfbb3e1066b7667bd16fa9716bf64c81569711563a61c791d0e3aad27b27f9af826dc6dd1990ec3dd7b23d3bd41bd6ed64204ba0dfb9d934811021ea93f4ed617645c73c62d529d403d77bf845b08e3e59ccfea7183885d0ac2552a79c94a7982126b91be467580b494ee5d538263b55a22b927f788c707a4a03dc57601f4b13fa36a21b8e291806b143950e78360da7e86cb22fdd725ecf16f585a90c149d4a1bdeddd9a528ed12d677216e6a8b046777340bd424d60ee88a7ec07f77e61f122b331e9d4db1ea37573a17bc34098baa09300bca0c5cec81bb38a934ea5ced0cd8d693ded3d9212ae567aaef43f45e9383a22dcf8871ae6556502a7f42b320d34999827a9c65727dbc1b8d7dd412493090b9c8d94a1c5da1d249db0c5dcc0bf1dfaa5d659c4bb9ad8a6d08b85073063e1040225b8fcb6ee5a7fbf4b7ec509cd889cd007fe39f2e94583902429b296afe741044f91746299caca81b1c209d071e7d579d6c78405417ee2f1d0b95d1ccf39c210fb266c4d7c0aebf28cf22292d829959ec8d562a66c6e0b8ed224cae5f757d2ed09945e57c6681c1e6dbe980b639134d54c4abe99004929960ab2a006db901bc801bf7cc8b84c387985939506e9d0891f7469001b64d68091bccce5c9fc33944ad047b725498871cb872e2d2281aab560f8c0182c614cc6eaaefd2e26ca5000e884cc385988854386751a5632a88ad28f8696480574608c2d9f35787e2fb8dec54b8595857a410d874c62b02f911a772b63cd8b13c820efea6d30aae47221c6b9fce2aa2a2ebd0cb85f083c2cc9d66cb6cd892f865b70c076f4052b3db2562d33061ec4a1aadecb6c5be2ccc1151f788b552e5637b4ec641cf7189c79a70a64fa4afc1d2698923b20a2e5430c6d1e63aa0cc7053ef7d0070b4543f7b7e691820ec114bdc02c5e38a958ba60aeaa270a10db7d22223029a6df18697be4f8a022ca5669f415780cc7519857823ac45d80acf9477349f5d6f7f2a61a544dc21190d727c9abe5f55ea00faf34d45d272f36bcefcace0433ca8db53cb1c91c9a2566776af0e5b29580b3e065ee284098fc7d2b27fc5a9c5b9385f17d9f9b386c222b7d60622f1753fc56d636c29ecf5935dd4beb86a23911047da5d7c792f25dc5517e98a1f888c636404bcff9cbd0994ae871657e8816501e7a9d53b99043dabdb6114ea449ac0c2c82156dfc62bde949a7ca4e520a749c124146fbd35df63ed15d2d9452cfa17f7564596a2ec653d7ac2bf782d1584edfaa1f10e9777579065886fa71838def0035f094f704012910a4048d06daf2551f76632eb032bde8a687b5cdaa93f9abc4d5a9085754bc9dfcc0807fcc9d5a301845a8894506a4b4074a9d8eb53f7fde64e87dc90d59b7c895222ad069ce7cba64f169b2f65f01fde4be4270aad0c0cedfef1887759093eca40f1dd1b014949060df4263de56a2ad8fe66cdbae64c977e04d0aef8e30bc37cf46ad9fff6c2e4cabea2d206d24c27b79a296d073f27af084ff4b9fb8d2ff5c82ec36c9c41669d00f24b0e5bf72cb03e4cc55486c1df2992c8590dbb1d5bf988bb2164173f8f29ec08cabad2d27d0f5659b01eef253e583c6a922cebbdc0e52668fcbba17851e1386a1f21d5825233d1518f305c516ad5ebda2f0393dfb82ffc96e172aa5acd131d250f06cd376745bd7fe49e2c82c9f9840e404948a359e62715f62cae196f6249f7c8eace41a9679c2fa3c06da5ebdc106b002b9aedf1aaa4a075c18f371665548358e7aa577680a725b1190ba656757c23f66af0f2c565aec250852a9ed0f9503444a249b573ad63ff182b8a507293720064e1f81dfc170e743a910cd5e96960d85e02b193538155ed84e09c67d630ebe111c6aa194c29a00a805f53e79296efc2e1e28fed3c50ab4c3602d1a31d6b3466e1ef452f63b35d431be1e1b782054bdb1ba20513c8b5316b311f7e6d00a530275e27f72599da4075df8c85deb586da062b51ecc1a2e191ef59dec42154a82d3427353aa7f38dba303d4b63ef07252a620237f8313d2539dee8df30e0cca3a2ef36903b98072221178b659451e53dd8e928ab37b9c5b82bab0ce2c3d392ff0286b994403e5a4405e8fa1cd5b8beac28af5d6d0f2451fab0caef51e61a698f953791f6c0e05c5b7a8c9ac6723d05b101a1b8e5e6e36a983d622df021d0930b323f4dfe0c8dc81aed504f51ec948c9c9ccb07473c750fa5a2c44a580143b7b737430eb84f8a65fe3084a0fc20c809c2b6e40d5554a222fbc70ac0e962ba4d41b4ab47c8671b03949c038de3cb3e125ebe9333785e1e1276c036383270c96551be549f2816df7f17d83b96a98ad7eb1c9e0c066e03984886e8fa795be32baa4c204996682b75ee526dc1cf2f0e299a9662f01e7e024d895771b38550644ac8ffb91e9b1648fafdeaa4632341d3ebc846669d06c6baa6a4ff3e95550080bf4834f368e8a60b4fb4c96207bcf1285d08c5a897e77e09155bf705c58b02f45fe8f5653fd943f3679d2ebad3665233c2d2cbb0f03d8400a08b5ede701876d4a8efe557aae9aa4707d6cb8bfebf367df55f5397720f54a0c45275604fa442623b01d116c1cab5748ac37c6804f16b1a79d8f1e40b64a72c9b645b039d091558a532e2941cc4b3ff079a2e247bfdb99cd35b15398d2bad33180ada9fb520149ce21a003bbdc654b36c6910f8de23fb5560e8a837b6d80acc844a1016c2a4e9f630a9665e6a0d5d0e27e0b786b3f24fd2f9ff0b5016fa271bebb91aa45f2a62515c6c99c18ae5cf9f8320f3c432c6a80ecfa26b396cfd7a5100315f4c92282091f016d4a85017e89bfb9bda0e0faa500c77edca40115d90fd90d49e42a33af15c2533bb353eb3ce4ae351044ab765833175d10c1c2b1f92cecfd9dccd4dff77f924d973046ff93002d10548406f6f61239266a7a008417d6c0cfa7f83df4e13f836f80e3b8ba0dd0544259490582ec24e43704a81520660171fae5be477211ecff1dbb3e19f0fce70ecfe6dd4d46248a224a936ed0b9920f54054f5a34c723c4d20672a3169cd73e7bde9d68f937c395fbb66955610102fc3672b92470fe2e31d7dbe1cb97733fca43af633d4e5367b578dc9ec1c1ad0859aaabbaa1615ab29ce65f9326d8e18b7881d0cd0fd680187b866387fdfd9605e67d1b5f2c7ac71d605e4e93ee1f917414c3b78fac7597607b039aa2d96058dfab4d82593def4de0fbe70c16c9ae01dab48d16c7b95893e75c152271c68c957feba33270be9616a60ccccd13541117be3f73405e624c8e2aedba3c444a338774fc9b55e3834cb182ede184fea297bdd407c917bfc14dbb3d7bdf152aaff5b814a50cda464859791aa6a2e5746f60b6e42ea1b07eeea5c1327514cce832acbeae784570e28a5a70dd17272f138e49d2e8a16c1d15583aabe128b4aff0d01925af839bfde72a2b32b6ef1b7b819c02b723aa0387f71baef1d13811be9e22894a95c55337a0f52df32913d53ad84218f8896db6130add38ba9c1051d6e5af92350a6110aaa3670d927ce4fe27252a72895dc97f33e4bb606f310dbe9eb8c266a371d5c70cd5bc28ed16367747018abcdbf2ae6121772cc489f146980a1fb3a66dad1a5fb365d264e9b80b7f23db05fbc3ce3bdafa5a4e4e8809e80354ef10c5249d13726a933f2add839678e911ddeb34099ca60e6e4acfdd58ea41c60b76fa98cefd7a88a8fdcac992bee7624cb39aa383807ae5348f845db806c0705569c382f60347aed1a072af585cbe0aba8042e9b3bfacc717221c6620b3346bae3091d85d6a600eed28a2dcec172870bb35793ae70cde45940436250ae01c8a56f768446c78387804a314df2e64c35134cf7c813c95a402b1bc3e8560cdbccf26c67dc33438898b8248be229942ce625af3557ec1f1c6c9d8e0da2f16768a4ef0c8e1e6e90e11dcdf7250d49b75dd218443ddf89ec6db03000284ce87c44fa74c6f95df0407334c9f1b6ff36017e289047ee57765c1f2a39ea98209d2787bcc1b26e22710ed79afb0d1dbd500774f66355ba7590e82cef5681c9f4dab1373f327dcb3c10fda443e5b531fa9ffaaf4d861c647a84867657130bd2b9ba247620aeb3553f974e2548feac2232cd1bd83edec5e0a53c1b10e4de31f769370753df3ec4c083c0d40bb2e3232f0bf73110f76f007c453bc71046e2935e0406d1612881006adf1e9b16b3ec409c0524e9fe61436f6c00e45fe6f9fe61f110b4c8d3d2cbcbb71c6b25d75988a5afb6aca7eeb8e9ae223a9bdb3526f4c725b290fcd88115dc458147a882e85c99674380cf8a6b0055e9c96b4d4811bf1db56b56b9c5e95372aeeb7c4d4ef75543b09ca7d76eb0b2f4821ff1ef8756b0564727be5d31bff9b74017251d9cbf1f6cef438294279855cc04ccc822932f97d1da8b25542f904201498acbd651a227d96eee8a70847845c1bb8b5c7c6e7e4266a68e8d0a73c09b11e42cf97739c47d70eb14c8b9b5d4c4141087faac374a6f6de72f513a50b4f646acd1e1347b59cbc2bbece62ba2e5041bd9e2fd1f08902d68f6b204eb112f6c33f39f08c96c7174514df12b3e34cced7c57dcfbb5eaf5edbe50c010ca7482673e6c1250e36dd422a5eb640217ee869afce02f6e307e8990f1aee981898247dce9ae1d5e93f45d77144b68bd34a9eb41530cf9470f3ade253979bb2a0a61ec74984b9ba34df3d1018dc3d836cf5e4f48e29d3d095626a060c39e8eaeb91f73476107ebcb981d642d04043415b89f7a748fd62b83f15fc9862a3bafe9c2aabce5dce55c1bcf4bbb5eb5760c6747fd725cf3a5e28eb995a890732ec9e247b36c19db9cdc072660e2b2ee29d3b16f33f70209bfcfe9c795af119230f36c85df8a7cb27c0712cca136e5d66236cd11a76a805feb52055ab6e1180a789ede0ac1f8660cd41756f9f9d4cd441b067bd7dec0a20fcc7fa186cdd48f75d2584f3e3202aa96d8240a96d47230ef425abfd693a16b8dfac6670de1df3f65414fa038beaa43ebeffacd56e970e85bf373123294b14c4dd382f46bb1f3d9c9ee0ea9731783eec810f19156cc36cec667425e46f1af9fc3a6bace11230feb9bcf3b6b3bcbb5fe43d63e02b918c9a57ca3161618f755549b237d97796ad126070114b4ffcc1dad4ee45283936d8bd03e8b21e2310f92b86f74eb28e48be76d7dfcc78eee8f4cdfe6981590843245dc212e91c47e406fa1df8786afbd61352b6d269b0e509a7476b7d6fb7d41a1b4cfd7f3cd469840f4ca06b12977be9720ac28e4fd5a2b3b07255c1bb654ed243cd111974426f0b562d331416e479eebfbe8a14d5e26f74814648f62aa45a98a5b22638892e4ba656116212aa61bfea2153a77124b747aa915fa24b04450483b7b45d9df580aa778ab22d091867c82c1b8ebe4465c54620fb6a6d12c439ae625e056e9e1c3eb7c5001cd3b9c37dfeaf365cec87c3e12c677e15c58f52e1eaf139c5debb7f6d653bb5e2d8b82aeb644dc2d285a969cb90cf490e5a637738424a4303d76c4483746f52fdf778944c44221ac35c05b23d2318e119e1a8302784d9d8c41a4f9ee9eb06e6185f6c529f9f59ae93267629703ba3860f6020e3b9ef177839c7394a818a4c96f00307eb69fad46246c98685930a1655774872e0a11ac7c46d7055f9e088eb535e5446f3a221421804ab03f6a1465e21926c719cf568e742464264795f7d0f23d466e036682f66e8a50da9c3ebb38f30fe759b6c8dfe723ac8da2b61f95265c480beb7465cb62ff6d6bdfd3e2f0454a5856b55385f0a78447dc91bd208f29512c4d9d1b14e6d54660a2c060604b8842c8a4a5959383865409651cd772dd266c6966d5f5c1521c4611f5708f712c82b877c500f53113ebbe0c700539ff8d0689e94c067048259f1bdca92b25f4830398f127fcdc002493605c7050de7ea64012146fec81479a5bd99a5ce319a32c02a55e53f572eeedb098d3136b21a30b0832cd63afe2b28e093b21eb72e8ff8ec1a016446bd3dc84e994be265d34aceba5798abf0b6a35ea4481f8a4c1b1353918be623760c8fa25a29a0cf5c1e4d676e7d4b6ac79de3bf6797bf335ca05fb978cad9bf05c83935df7419864fc7e1e9a00ec62014bbdd46ec4b2f2168a1a5b6b373e4b090b80a31e9e0da0d69e77e66fc8d58554cb9ff365b9df88b8e86aa19ff2594d69fd31b34975444c6eb8c59d93519c9d54a10e7438fad80966c6a9a8fa558229a80f695a332d1b52cf2724806fb9d09d950bef8441d88c03fb45de97e0744f741af58df13d3e0805200c94f57aae7613fb593928e2a1c4577ce76a9d871d812f9028553f38338527f0dcbd43acc826179735d4611b32c34ca1a6814c00fbd251cc0ab4248b10bee20827bc1a2e07659d6141f613877aaf45c3b66c409c27902321ad5ffa45d3c4387085663eff29dd716102136ed36e4351821127f3a17d339b7037507cbb374148b5194c000eb8bf97b4bf03da76045eda584b13c1926786f4a375e5a2256036aceb8442020a4ecea6314b5bf082938912b9aab475b7cf8c38179a47e075d5c3a0f075725ca7df22ca97474093a8799f54422bf8a376eaec7713419aeaa66e186e6ae77409037a2a4ace94240f2313add0a69bf2bf4570bc8290342ba7ddd462e56109d98b9c9ffda9677cd34a4995a16f618835bd27e39af35e9c5965daebc978adbc987059af37c80e3603821fbf5f1571b5d19f843e163c123ad1877b67e051b2c75de91bc628b0c6c1b1d2e822eed7a8951fdf0c061b5dfece76899ea5d3998c9f991424a499102dbddecf34e380bdd2b503ede484543489521b4bcc0ace726cf1575b28aab35e11796321da9321c7f43224d52e2d3b908d0a4aa6a2330fdc2d971e636de4b6c041e55d2442b1e06c3eccf20f647054b16e8a99c37909348c6e7ce78e0abb23edc15a55d94f1fb9c80d961bf4fa91103ad37c405c1275dec5f9f90923155e0bc08d9ec10cde5f4c2ebcc2f991e71626670fede70fae63a286dca6a0548dc629f1ab54cdfc1fc34869db9091afa51c13d914655dde33c23dcc92ec9a469b3c62f4f35caa591267f148526733c3c85b9a68baca68512a8d2d037b56b210b91a73e94b4ed999f18b2bcdd7c4e190cb24a4534ecf77e5407516d284b63f46893e8abbf9e4d1fce3d80d19554947fc2d81319bbb893c19d72086dc53689e9ce737b62779e45d0c295ffe2025939c9d375a9cb567aceb3a4269a02c7f4e1f5d54454b73a4b3b50b9d84c6e3ebdf4a04c24345dc3d968b5408f8cb69f04270a10fccb9b829c09cb23fb560595ebf3a793131735202be25d57fcd9bec50862c66a62f1f029728485598e009311f43089e1fcb0ba3c5e3f0baf0af0658a21e39feb6cdba3d7fd9f36a09b207f5e7c120d3f21a8e44e5619c0b5f59830658b5b2be23b46eda350d0a7530a4508af56c370c2320857cf45aa12ceb4bbf4e9b8efc48c1bb1d34b581aa11fb2b5f7dc9a2c4505af5ea7b056bcfa9e90196e06a6be1464eafea3216ee4d381eb8d0e604007b0b43ebb26056c25134766c855a3cbd20e1660cb4ae32629e6d4c4255a6db6bfc20b23a1a4d4fececa8701c9d65a2cc57b9e41a65af3379e51ca3efa69950b690a97d3c426a1399c416e8b82f5da0fb566f67f488ff53b8511981fa736cfd6d6b75ab336b324a5f2e3ce9325ef28f062ee102ce3aae4138db54faeccae27cb5347619481c1f033a6f65d45e4a3329968b5962c2edcab8d95c3fcc39591f4cf159e161d198b4d24ec3ef3e319b8c166c6da814f335e35afa53b405ed4f48663602e884d671474f547c0a5ffd92155885c5e7ff228ad920b805e96ab7ff8747aabaaa82f7641db1da1f06cc86d2b4a87873cfd01545ae309e2b1bcefa5d465636f623178ef1cfa99e11ec56598914426dd84f5621de29ab33fe24671eabd86042c8e95078735b68f92c9ab061bb6a978c6fdf39b8be04e09f46b5ddeadb56c74d50b0b44367a6f3547ec0ab0e0f878b67cedc855358a0b1621218e73157b16fd185fdf62251125e276edcbbfd6a6ae30403f2f50ce101bb5ab74ea85ea23dedfba76c4bad37f282419642a825bde62089e065bd4f89728d4996ce0b226e846c1696d5fee5468a18f5507970276bcd263672663b6cc85b0e1ba0469f17e72684be2932b0387b7d60ffabf2321a7dcc14a1cc337376bd42938865412add98c2ee92132cc43195e0974a6c45e97071606a6e835d6154fcc10b7587b5ff3e8f5f4996a52590453f5f99893811eba788b9eb9b649cb7c3fb100fb5d59fbfea51df32f6065132fa2d1cda3e8df735941663943fdbc51ffd9446779657ef91ce42e46cb5353a5590f6d5143413f5c11513e5984dbf7fcdea6eda8c51512c153b4eb8b1f1927289782bf2605caa5c489f957918c35be8fbf864e6d158cb13af9afc9e13ae56a3149bde1c7088dbaf86601ca144cb934e95347123a90801cfbea5d08ae17e658ea6d50b5a364b86d78955a259a2afa3fa4ee583685b10ec056da0df711740534bf33122edac3b8f19aba7451ba036980a03d4a8225af9b9f2e18a8dee1e5feb40777dea7a8802679f5be76b9e04dbe39331d850096a876af33ea9c71caef1c83cc8249721c687450ba88870c0162bd9fc05f9207d61815a252c3d370d1d4086df565650f8222e6f42f00b7b96c04dd98518b77b6fabbf2ab3659dcab3a7756248526af9772f154b6cad55b93ee4671a528fdea42e3fe98f52c8ba8dca2fc43f11f1182eb9569c34b1196e25d36e9203b44cc8212dc02edba66aea2d7e38fa5830191cc70a7830c3a84dd1fce5465cece3ae225361d5592583da6af12a644ae43de26cf5d46c4fb8bf5cc753e0e52ba5573cf96620cb4dcc484b284480df92dd15ea16d9004c0c1ebcb7f514681f2b3327643afdf0037052951cb0bf873f4c046be9892f77b934692d4582ed8332cb1f81370c4721d757b22b31cdae78072559a9141bcda8f302fa52c4422a39027f2113ee6948b5314d6b7107b454a687d81aa792692c03aecd8eb1532bdf394b7854a18fceef9e7311e427dcbfb0a28ba961c6c5b25ec12ff5bd2e25a7c64b92165406c59d59f347bc4bb5a771b53e3b8b396525c5f725b71a7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
