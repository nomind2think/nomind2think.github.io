<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd1cfeddecdcb7d1d26b1225a318ac292936c9acb0ee83c8c41783d90d1e8c718b111c5b3de45387c5e108ad0e644497a44f59f964684024af1c5d2c19d7db929749a91ec9c1e09eafb16a8ab1d0f78b1f924341dbb1d10ad0ef9398fbe0b252c55a3c8bec7b5a3c2f3b0a536bc36d82d9137d12026a9b797b7b04311fb3bc910059100e4b850f3f361838697d20005004b66273816dbe8e64cd1cd5bf9669e4a6f207f7e0a7900928dfdc25c7fe92ca61807c246da26b3c72d6cb40b9bf09df0c6ddc9d9e329b4b09585435f7af6d83bdb04f641ede115b717473e5f5bbac555635608b6b8be0f6512c6c1ba93aab6222255040a93cae7019c54faab1284f577e3f074efea3520ea49748324a5da7141eea5610ee247da20951023184f52c16422b911364860684ec373b804c6f84295cadc87f77a951365c594b8482231cd27264ffe50fb19d6ca31609cd3f54507a3cb1a12cd621ddf2bf8a61a2446f8ff1b064bfd69c959c6a2072e50c1936d5606cea5e3de6db71990e43c6013a3f1a704b2dbbcf2a0acff79e6a6c7dab998109b12dde3d4a8627fed766871f3e30d5038599f8e6aedc405cd8d0aa5273616c221b435dc65c1d9a067f9cbdcf3cb0dafc6c837fbf55e1b53bf27b511afde55c5db2298a835a037f8a331a48baa7a0b8858f3bb72887c39fe0d637daf3abab4f154d928247b6c8ed818c331bac0400c38f57cbc9afab235097f3bc032f33e4a1f961bec43413292d53d4234a22f52ce56b1517ffdced1883d28e87bee2a9b127085500668476bb7f577b1301ea65d837f9ad92e4077efcf8c67f580ae58f0ce7a4457529cc3d613d1dca86979688a6e40bb9f571eadb36f0ca78d8dd98e78be6eaf94e2b9b2f1e0dc6d6340a606fa370a7f813d2609f54c2df274a3348fc501164e6cf0cb440a53a3292d623b192a35754ef8b6cfaa00e435e7a752eef156caf3867c9c565c722ae211df2abd9dffd95e589a531856190cfe0448ef5e1cf7fa3c60adc09c9383181d21c1d75cdd1f733ff0afab7cb7f83940c9e5e8a3f418803861a7eb0f1ef5cf593e098887eed314a613d2d4dbf1bafa4b47f13535575b46b67df971ea66782314afb203bc33581f751ea9c70c79ee554bc4721350b0aae9849a385973013dbb65f1232e83e5cfc9a5187f0a57440df087bbc66cca67d2dc4040c03a2023e15cbe59892c8c0464e35eef51827c1a1fcabf83430b38ff4bd6b8f65b8d9b411fc887d5f6dafdaa62e34c0e4ea7cf2d169db4c4c41f431433ca0859bae75c6619e3a431e6eef52aa9265957ac4cb48e70848f61ff2c40664c6397f94d71a5fa4cda80648796c0fdfb3e23e0d3ac292b2721366ed2d96aff2598fcaa52dec35a4b7160629a341e8daeaf413081e95c6746fd844308c85e358a40c4dfd92c3d97966df09ba83de64def8ce606449b84ca484a0dc716b40e9bebf1a99da87fb9e53cd21c2564bcb57a6c8c9ff0ffca6ac13a2ee3760a583c928af69084342cd4f231315c5d012911f9a0407fa97ae16397dae9e315429fe942011e4cccb5a7d3c543649da106607c9dd5f44177449e5c162c8344ecffd8b330e762a28ae77a0f407bc08ae698de199b9967b58c251f4de0fd68b154ba70598f27de22cffa82506e383d00bf00d80fe04f01b55c708e5aed463aaa90d4382a5f4da0f06c153deecd6c37ba9d9c8d761667210b15a0be740fd39fc107859d5216ae4436eb3ad607b34bf2741721bf35274e08c20538c7bafe3cf15a5f297c591428bf4e82ae39c89c3305387eb6611953b79ad9fb973c4b8ad2cb8d8cae2d442b32d5009a5da485c9721503862c546366a132a99664646e5ea322a1f5885295461063fc1831302824aa032fee01d649c64bca335f219e59ad62d2480a62416f3076d816d4bfdde836342d154ef9670bc176457ba0b70657cf4aeaf5e5a9e5e57404839e7de242fcb5cb4260b0e2171bd0a9584621e764d2246e30b2445d7b3084e1d7e0417fd1d803edb339773f60f5e279bb3655e494acf95be506a1824effb6241e15937644e96aa060f3ff4e1e9278ff5f81a6676f142bac14ac869d4d54934101c2e0abd24135193f95f8b5e9c494f7066b6a0ba23a2da746f27387175cf3dda3f671d5f41e7e4ea9557c0bb6d8b95e6d1a0a92d72ad6732f8a5b539d2f85f699466a387ed77baf1dcbe77bbc010752a912105fb7a67e4c5b4d26078c95ad9aa468427ed694b477108aa18d69d3f605d9c5baf0bdb4ef2836a9f7f2e32da6367b9d3832d271dee3ea2fe44d4b941d5659a990f6ee8bedc4c0c4803a2e461b628f6ce88e743520ccfc3db52b3dd527d017893b6c2160b51a4416aff22dfb68feedbe468bd5a105dabb1be0234ab822e9a3ac32c1f7a81cc806b743ff578433d2c84d112f31694020d1ace6640fd19511331030aff1d737ae0d387c5d0b4f51e54cca0e4b5747805bfff81c70e591583bf988d7e0dd2568de7d29d42a2056c050b96082da0a2eec3e55cd6e5a2df8a5d2e4d857f3f816636e25b177ea430d414226a1a0fe906a3711b9e7ad1111967985ea75e3e1c6710afbde016928dba1eccfdbd3c5f8ad7a07e76547306db7421dc7465eeae636e7f9a90d862cc2e16251c806bd177caa5ef0836d4216b0c1d81f6e72d869ac88848e0450054129d403a5fa86175756b198d486f4b213af00ac09099d3d3f05bfeee0650e077addcd08bf0848d03b64c69665a477b9897125c10115ff34168b15f80d958f2c2fa22cc73177047b3a4cd2695c9bc91ab5c03342bb75aefd62222ab3eccc5e89197cb8bf5f7e0163af4c235210ea77eee956678db1575eed6ea5d8f8b782757f03546b6c1f8585dee7db4f0658f31d93c98858eaeff9453ba393042dd6530e43db2249477c1f952030670bfbfdb5df88983df5afba64fd26cb6a9a5201288f9734963203eafc02b3aee608b036de0ed68fef8d2308c1efcf85ab164fc6e18949f5ea127a8d4b9fb5558c0b6e8bead27422f1d1bc16ffebcca7d27a3c785528fe903625d545eae46a1c6cbe8d7aad302248c9fa98c5265dfebb91072f89587507555f615c6b9efd073fd07004ae6c25420a6840853f7a4a2720c5aeec8a6fd970e35481cc66e7a33a91f871ec9587ba19d9aa25a164406134be3fdf85bcdca83e040ab46682bcb9cf6b0b4f3f9e3d412f09c8072ea36e174f2c166f57157ce8c9c5cc9cbe28e6411e56b8714cfadc7f243da5b5be9647881cdd8370cbba79d289e569010a7f7976fde8a73042664492193fd022e807d0723f007eff447f3bd6c4a8c55bf8f38b26db6ba63bb56a3926d9e4843bbe1e5a6de73c91d875a523e485f372a0193b2114991720b3aed62dbedab5d64204c31b3957bee48a3bc3d2e66e18ca3537952f7210c97090ee0b421f365c10531257a7edc9e3ef0b3e8cc6e0ead320efc8f99e3c8b7c67be5d494fc60b1291eb67ed9f4bb8bbeaa6a0cb81f38afb672145ad8fdd1203d56f2de4b564f34e4cf8743e9db18ba3af0121a3d37a0a9dacc67bba29b7cf46a8f579459584ccb4597f0a5b453a40ce1b9ce92612f8fabfa1ace9386b6cac75428f2541640f49e8c8c3ed3c81adc08aaea14606380de6037f74fef711cd20bb3525012c506501d45edac33c990eb1c0f9cac5a2115f30425601da86d28be3ddf86df37b249a432262d967ae216da60ee21bc024fb4f20015534150fbc8c610956e010af468acce437ef23a66078be0881bcb26e0f81011f4e323678512cfa59e75a8a1290f4a9918da9c616de2c0fab75046dd664214020625cd257e4280e8a07f8869222e794fcab26f5aad75c58bf6d54c81d9aaec08ddad250029aeac2f13cfb106b68cacae86d4d77fd742ba96a7ec3261d8b5f2801f07478530f52539837dc29d05ee514b073a8befb554281cd0988dd7958fc06f32a2714ec7b2f0e196a4e36007dddc97ee068ad1d0a7556b0b810d82a01c12791b61bcf91c890cef390505aced272c69d85a04bd1efdad782945d255f43fcc1912b82aafe4ca7079e9000c8928b2a690e0aac451dfc1c2332a84b42eb7974a847b162001dd171fdf8c0926909ed48c38a353f6933c5ff18479fa614a87f5b8bec8065fa14ff54bb32049d65fea62791bc21ac03c0f4433f0fbfcdc9e6cf37c4868570c8a8e6cae6d42723804ca72d52b868c55a2a5279c929f1f2e00d3d1e5bf47c425d2959e9e528db5d76c04492eeb2571d764d46f560060197cb87bebef251101009ceae71738cd68658f2637ef18bb221711191e048a1138dbb0cb89b0ec1b14b3176cc87bd13310cac015e327a4a529c9bfd11bc30b98ecd870ea75ca911d0a3d5eeff41ce591853e150805f815c24995009b192bdb6fced9de136f2f710e702ce6bc625139c2b444f4a6ed72ddfc8721cbbd4adbbe4ad51bdca98151b8cd32cc3891f2250f8ccf032d4bc83dcf2d73524869c6cbdfec03f1b1666c22f673400c13458c5b87f3c98a66975fc92696d22b64a91850aaf260d15b0558a08f0f17352d43d0bdbf7e5b8586296a409a6ae0a778cb51dd246e3d5baf5fdb23c3b30a71031bd6a72772765727c9994403b54a1a8335904e77b0059aacdb6b50285f20824ddaadd5bf291c556d67e612f8830b37a30ba3ca0a3f2caf92ec3f769b506580d4f84c930936c7d437d3ac48900e994dc8e65bd45958e16a67efb23cd2a9de8ce6a3f17018c276a038a6efb5c9d889e545e7e9650dc8c6b4e1c38d5367169583967f7d3d3ca1f9cbd795fba46d28919d4e8c6221b05b6c901cc179c016a1cd23b290ab33f0d607b5f114b134a7f678e59743861bee373c32e85f52624b0546b8f4d02349ac85376ad984623918f8657354a1de926d76bbbffab494ae318345cf3c130f828242b1d883fc3c002110758ca7f908a843392e8665094979a475a210e8e1ef688c691d0a89e3ed1f8ac17e2c330d2908f0e16b0f936080ca40ed630b6bcf4253bdf760c45c5a560366634eea46abb3794c16ff0184b82d3eea9251a85217a8dd3a440e16049bb1f5e616074c7c9b0b94ef26feb200976fb784de0cee6891847aeab9aabb9da1b5803119259704f6d54561ca46f22d185298b031a73dd75fead6de6ed0aafedb668cc561514809a1bd200e99392bfd132414bea323b5c43bc3cd7f0b5a16717f4e0bce9c50b9a4caa5dd4f2ea941f7aa0951cb6212fd7f5d0791c2c963f9092fc40c7240ea2ac55877ab31b7e1c9c1b99b8d4074848cc3837d8f945988050972f758ba17c71dd12b7e4b6a3250ce53fa5bc815fedf0008799759f1296bb1d59cf99aef1c481731414399371b45223ce3f917aebcfbf34997afd8995376125086833c4ede13a601beae603ffc539f4195d6912f378c267cd371922c435b91927c723d7f051ea4d4f253ab7eaf666e8a461500eb59d1ffdc846b13439d947e0ffdd46059c90fe4ad3f582d237c910b313c696b8552291e24e95be6aa3751ec0951f9d27e2ac46a2f6fbee2a64d0dc930b198f4eb9c39adea0ba1175be6d65f9d6097b47b54de68b5c00f792165174668f9c5014d0a6588bb3a3c2e0e816fc0fc6cea2f5bd836806d46acb7b6e908bdb5f9d2be8d334561bc60d38fed498211ab57f39681f48a6be35d04b384056540a3dfe1f7068e0a4be3e82e864876151f2e94d21f9e9f8371e211f8b8e0d3eae13f6cf06d92c3379564ccd1047d8d2a6e6a06caeb70d28c7ecc64d1448ea6bfccd745d28f0f001a78bfa3b31c2e968bd6b24c07cf7f059577df174f3d6c8bdced0b8f48132eee59f030e01eb6339217deeb2b2f16d1aa35b57f209b6b1c8a11f60175e78f9c5fdaed70253f4580dec0ae897b4b6a6b32b1e65aa0508f284e668320b4027a982d7ed0cf4a657a32c35a3985e9e7597beed9eb979864bb1cc21b2871c41545168a442f5c61b7b032ba4353dd4645f07c170728843f440aec01efec09a19d3e8345ec5c148509dc591443993cf90e01c220ed24eba56cabc25ebeb2ab628f0f710823ee2674bed1201d46bf28648905ae7723aeace60dfe19a6a131c6382dfbe83e14ac84c31a414b31bda3add7e7832ba2137ce4db61fc30317a62fd2cd788366b648cb740e0a7cf144c06a6c68777913823e956d89f19624e9456d28f80a5ada1a74db7f65e06e534896aba7184ca58ddab9e1ecb3ee0cb44f9cca4384c2de59c1a3256b2f79d41d43837f71ef032d37b004e3906b8e66e6508ae82419b38cf95314c4df28abeb4c7b51ab6890b5b146566a27a66beb7788f6b77521a2e8a7b6f837c3f8849b18513fa305c70b297a3b7160aeb8d72d06ca6eff7c5448af464b89ea63ef59a34ccf45cef56211d8041463dd906d2a8e1be59479b39ed2a717f55de0f7c4132d5ade10dfdf9035d8950e508372fa63f4c97b0d704503b18471a8cfbaa1e57572290f6d6a1fa46c0faabb8c38e0c1af35c8657b4eecf2ee4ff675fce23f9ee91bb1c82996388f77ad2bbced566dac0d0809840e77b46d1879cae4fa6c623437ae92f3b82f50c4a9ec7c2b799e3e417f8e6801ccff39fe6c55cbc41764d2cb7cfdb5a0216bb9187d3db1c2a5edd596bdbbca8d514d3b89ffe63bf4efce4ad95838bedc60454f89ae34b4a05ed2f58375878af43d28057c16dbc9d84d48c7a0bf007e4dbaf148428672dda45ff2e5b1072de6a6cf63e62b27ced249f5066f2d480bf0ae93cd18989f6c22e1993f5ad520b8aec82d03b5094a99d4baf6faf327f4a1a6aa6c4385cb754d37f22523f9c05643a0042a45cc5e8a202e0e2040ac4d7bda0f72dc2518c2c583149157b7dfa92a327e231296e53a1553e505675e4bf6c37fc6785f16011a1ab670c0dbf744e0a86e7b8d8552d78a13ec0b6cabacae37c9e498b7ecb12b304d37d07036814c493f5bdb9274a7814ea3cbb682b4ad30297760592840139cb07ab60966bdf84be379ac14e14bcaf8eabb8ff8886020c821fb166fc37be7211b714875c2f74a028029284b7994d7d618568528cf9dc8012d45f80f73e0ca97ae2a4f10cc9f3826a96dd53cb99d1f88a5ac020f401230f74aaf528acb298b3c62df48b86a731bc8a9676db92326578d64d8780f04c83b8d0a9146b194c2a3f43e8249bcf4b5abe721ed2a5aa9978ce7b0458ca3d3ca161493869ae7447d0b6804f47e48bc43ea5421eed3a1119d4dbd7ae3a5fc737d909c1d9b6ad16d8ebc31867b60ecc4e3b28fff56183075babded81c49826ce09a4f4432be20164c88e6e6e59b5a10210380984f9f71bde216feb99aa9d4d2d7b2fda882fbb67daa2b5c0a368b636e3fd7c09c5f794e6ea8e6a6f9d708ca221bc1d4c8e7778d827f06b9011d42fb964bd4451cc11169697f3a9c5cbc434193b788ac81b83de1ee72507846e670565c0f7e48583a70d2f5c8e0f089569b4a21e32ded3598a9e1fdc946852b2091e590325f3945029d07cada732fb1ecfd94f79bf489afa1455811013a79db5b439a92de40eb0b02cf7d9c1099ae80b63349c6e86f76bb22f9cb3dd152ebc88e142ff266b3312696878d9869fdc716337a1d52859baa1eda4232f290a0cc9a44bdc7d795c40e713108df9e5bb069e049f621ce577d46f28d1750613ceebbb9641f56c222b991ae82a59c1be28d8401e25103fa8f9521c10744f9325c4e8627ca557ceee5aa788ab6f4c2930e6db4941fe21c50fd41d5bbfca8d550be6077aeed5914ff118bd9d84a6b92f73ae55e97efb80ad8502c94535ab00217753ee8ca067f8e0227104d9ee304fdeff579e312cb049803084b9ed8728abdce7343806ec15580c5a1792c378e8d278bb49650ab66e12de1e5534e15a0176f76f61e17675b0f8b4d4fd54092aa14b85fe12c9ea9f6da0583edaefc1eaa5795b89f38b6acc5e157ba2165ec80c372fe05a628d4ac4c4cfbec998495367b69ac377a17aa678eb2a33f4070bad3fb2ee55175f077ab59d484a1a9668fc2e41b9ba81dc2f3d123a7c34f88fcd9cd140a288dd1bbd7b981ed09c9068daf036440ea47ec78575d55c624ff31de6004b1d3e2a2518042bd436b84bf047fc068604dceca4edc9017bc7b5fde480543660c0f89c41319ccf8e1efcf0e6b23c095c5382f20a0ddf0a9ef0456e6561d19b8d41cb33073e58b13d00ed9013423dc24ee462bdd22e04a4a4eaab84275bb0de115bb8c0d21ff7a9332e4d444a1f348bf474382735f45ba321fcd70baeb41a88079874c43ba15f30a5df833c48f586b831ed5a38d12ccd4f8e2f8dded2b9aa128ddb18294d9742e5c6b1bfd1958804bbb5dc1f364d1d8689fac64cc47788ce32dbd0bd40e0ae783bd754c9f25b64109432c45e33936b5350ee6c31cabbd4b6e282d13efee3889405b6c28da2e30f637bdf69184b1807ddcc9403ce79769af2c09b117710ffe4d71eb61ea54167f0119a2ac21ca3d885a9c78ada859e0e664e5cfd9ef3a30728920e438fdabc763804bb6b61a5218080cda68160c558fe54c1f849f6bda1f328ba9008d46170a2faf1acabf62cb4cf60d4bd5b11e1ab9b3f573083eba98444e336fe48a0ec63665e1b7f0340bede594a402f23a56c8f02b34f561907bca43efbaf633fd12fed548b04152362e9dff84f9df4bdfb641bbe619b4480b6ea50414e4d65d240c89f4dd0479c58b45227c9dd77ca0080f8b7983b54d956ada77009100e9e7e2e4c62b309cf49820a9a0e8d05909e95ff02440fd69231378155bdbb2734e28c3fd7ee37830d4e6a441c7b427375876a373f1581a1818b6e7db5dcacde1f1c978b58fb3f1c6543fc3664ec93440698b07ed8702c12dcdff53ef2e412fa2f7fdd29f65084e7b957692659fd39a4b3ce923ef07ef709b1bd8fd5be8ae9ba192726245e01d4d68475caec31e0bd723f39f16c25c058508d30d9c0d2e4c2c65e810a9c0962bd14e0cc4ad085f66ac0910f58991e0f1805e78fc89fd24cbea652cf9b7c9fbbd0d40794ada12070d2d88df601e252fe9b57e68dfd041f0d75fc2cc485db88aab38da5e0097128453c540ba86ae0a7ce898692a160325cd3915a8776db810319d5d91365bc8856d3ec53f00c372a85e63d9829347e3e506f48811a3f08022b1fcf281a8063a9fc8d3a99ab46e820c9ec283093cfe853f4272ab52ecdaf7a636d98b7c5a5ad8f60d82bdfb72d2b5a6e216f7b4c6d1b6be19d4f49e8fa525ff45e27bcd3c202f6848f8e381c7423ba6a124ed28d650ab0c5ff984ec10da5b81ea55541b51bf8a17c2182f0c34f490ec74f67f501166bf0d087035136cc29d9aa524c6cd7144dadab6232232e21a2d686ac5b26df33479922fe76629fcff055249d9a30ace204487899a2ceefb84b71640ce266911b1b5d67d26c3793284a4e7b3dcfb4e8b85c0a307a8b2428b49dcc1fb3e5cdd748a9b4c497774e4de108edce98edb7943afe2aa7938ce60247326461b34e185011ef684bb04c0574211f18622bb709aa952fbd49f430c2f9268601a4f3bf4117bfab32416bccd7d1b4ff32c146d802abc72edbc1d9eabcee810e4d35374a6e89f74b082c5167794164216f7a430551d06dfb8e81bf460dc3926dfcb60429fa4df21b66f5b9ee9878e131d347306864dac4fd8ec51555b15afe661bd981b4dcdec9e3ea7882be50522d64a316e971f074f2a5536ed1eed216cdd5b16f26e96c5e1c03709f5f593477267dfbbb46ee269f76a108e1b05d433a09db572d1e5699522d8a90d25fb45d2e5c16f467118e0c9d4ef6afe8d247e6a4bebc18a5f59c81404fc48e31541b5a042a4a6ac5634c0495f9ce2bbd06fc235342c9dbf9610767fccc572960a8e0a3c657fd077730fc37f7fe3f7b54662bec3fcb5235972f44668121f37dd220858cbfa6de7739027ccce334fb7e1bd4c61799e0bccb300fc894a9f4bc8a3afe81a3fe663c5ab3e66f42f6f632fd87f470cc587e807e8e5702239a1f0aa375b11259b8ca5675a29503e8083a3f66dbdf2fc37711190aab385ed3876da3275e99be0a46720e5e764ae0a4d616ccd9f710adfe006c0401ac714eee6e68813eff8d78562ce296813c4b27df42eae903bd62e04e8c67b6cdcbf9d5af7942e5df9cd992f636a3db21257a98478116fecd1c87ba6660d685892664d23daf2f8bac8acbae9f7bec20ad04b8fe0a409c84c948d617b3efa94d4bd40fcd421acef151748bc718c5bfb2616b95a602f2c2bdbb2a6dbc7a070c767a3f6f08c0d38428d57885342906e6a7c8d0b0aca7063b6d482699dbe473b35ef91172f43bc3e48fdde74a68d52df5d804e195f944fe1e6bc303be89ecbbe5b33c9765f4ece5470943ad45a077c097b92836d897205320e4e066026a575b850906ec37c8222d27a6e588ca57d91bc91866fa6548b8c10686b1102e52b9da80750ad5d2310c5bc82c0abc283a51c8a59b337e4d660a7b4f8ec8f1cd937e23531ed3490d8865826d7c4bf13d8014e52934ddfb60395080fb2efa38ca102ff7d2c98144aa5a713e9552c97a7a49e4d0dd2e2f851abf6cd6453649172b78b02947d22f12f832cba78ec99ce6dd744ad4a7dade0ea528d34ce4084f1ec66bf62bb2046ed3ffb69877bf0428c042f8f99feb162b1409bc1637706f573a6a0094eb9f1b9d2f16c46b89c2901de9ba45cf673c1985ddeed26ffbcd519e8c38c270a90cd8c143554b504b17e8a28e4b3228f1b7a95f27692020d66a35453df69936d909ff1c2d828b0c9a622a8dbfd20e5cb585c4054ee32e2dc128e48a98c260d935b1791d8d8cf9fdfdc45521ae00fc1769c5e96a18470f9afc207fa25854cd5ce4f6c24deefd7b598bbae72fa0cbb4401cdac774ed7bd3a21e5f2bdf596ffb63dd6fa01e2dbd2b07ab1417cbdd1d6a691776ff28635b212d09f6a500e239e390c0f5fa48d1479e378db7758db2ac828c6dc0cc77ff362074380668ba817a61fabc515fb440fd60de396c7411fb8120cff6a94220168afa2b755c3001656b2825e6c1327c3209bf95a3b358d4ab8bb653cfe898bac248c401738281063177f7a5fc99da92162da18fa71d249d0358a615a04486990f360b46732f5681aa0be666bb5d887da3d399463733bb318d850ae6864be90df9a9158baf59aa21f2bbeff72b8e8b3789bdef17a02241d232b90ab9ff42075977b8628bd416d65f371afd7cafb71d388fd7fe1daabe1c288313a3b2465d47e1d7a9d4e8157adf93569aff87d5048d995c43d9f8d6a1ca6e7b46aabdf7dde54ee1ac417a7f6faa74c4f1e7a0ea949a709218de30a17930e172127a4448811402824f78fb486e9c7f0980f8ab9c550c1fc11833e41daf4d21fe885c77f2b6e83da90dcf44bd916791abe9ad3f24084727e5306def745ee5c7d2f0cd68c675a58f03d168a3132fa3ba3d12bc2847edf14adeabf7b4341f480d68bd7fce9c2efd3be66086afea547800973202660a763da0cfb9471df6445d3aeb7cc5fd724d8eb2e09f51697fe36212b191fe74317c1247360f25d0d66f2ccfb3f83b1079e6bd186aa83d452228d39a675067d65df6d96fc7e656e824565e65ca1ad1cca4ab482f8ceb054d288d223e6adfc7cb42534eeed2d2f06bc27fcff4e651b805ed6c07a5dff7e572180d2bd73fa481948695fd71d7fa1564bf6ca4910d2e756461dbfacd54516fd3c5948e762371e47966a3129d83fcac6f8b74fb41b263186c0a415e6e2e26fcd83296416da5cc4560a39275bec9b7e784fcb21c24a32b4209b146a224dfdc1eb3e4e2cfeab14dfcfd8dd3df38484a79cc9acda6126d1badd6f7c4638dec5c7d8b7c56f437bdf398d06d87b999f9d399e5e932fcf88fb722251bbb4edd24feedb2917a667335a5656a5a4e3b90dd6eacb6731c8c971c62cf6aa4447e21e71163062bb7689bf2555c36ae125e2113dd40b4fc96c7c377c8b426368877bff5c09a64c09ef857d18573c8d2f3e73c35c45f2ee659d316db451eb2b657ba2cc0f9cf2187a752620fbeb083b1ce2de93c67eee003cd5690f85b6fe100cb3611bd118b80111baa54b1e42b27bb0a0f2dde8ae9bb9e0ac43fce0f01dcd93173bc3fb6e4da38de92369d3981dc121f7c3b0dca20a5c81f1b8e05f8bda1f6eb821c0a3cea2990e7850e7cade739b0c14158470a319e3e2ccbb35826be66115453197c7e2910c927056976d0ce1b38fe44e00165e843b066607bb90213daa2bedf058e41123546d1010f9cd01cb4e235d57e2f9aa46ee36c15194302ee70f89b7368b3aab107a4b6efef07af90bf247ac08ff0da3df810281773ffb5f6e080066394c636c1fdb4353a11f74967f8bb417f2a8065ad2af75e0b23cfd10a778ed5ec40f3f61d72bb55ce75a2e01346d48bdcfe97869f3578de3653a044960548d7c5acc5cda6d1b8c7e3470f27a723c087e47ee5e23073c6ffdb3c498dab381d95e3dd24a18a29bc9d1f36e5fdf1921cca0bef61d3d7e38eac796bb95c84d571c56ad31a9c9e685f808ac1ec8d8d44650a58f19bcb61046d7069aab045fe0e9c08255ae2d5db196c88dd9858dc7542517f56d968c963d2287f116191c987fcda300745a48202d525384c118aa60cbc32509414bd8bb369ec7d5c6c5d6c400fd9300bba410a85f40eeefafc52ce4e44bae4e946f1dbb580c0ed0e4a3442748063dbd64a6af3b50a8e0dd26949b7769eec6f51a357846ab52fe5184074d498f85fc3506dc4228beda96b58d2871f750f65f11ebe67c0dc581baeace8a13f875176efafcf2852499e568e6c428179ab1b348073825bf9db0e06a2231096c9ffb7a7b868bfff771b3812993d62e835b1eeffddf170a514d05cb422da8538fd4515157ef2466a789ac4dba9b1ee5e76fbe27d67af1b5d8b4c2952e9d37e6da84ea7deb4776155428c911ddc41090b9f3818f8f1a6188c29b34561d86087ac67508f975524d5d09e30f76f666018fd19f1c277a0075c8a57fc87de12d4dbf008f8f1217cf4875b1bf90b509903e9a536875063152cf5d38433e1e36438749ff4bc18bf99957f77b1febf78abf8ac5f8f58df2cb56b3aedec1cd3732fa93b25f1fadddfed5effd8fd777ce7f3a00cd72b2af1168840e4b1988e3397012703854d9ab466a1149588d87256013e71c1af12e9fceba8511522a25b40a046d9a616a9b1c5b8e6181024d3fb442db6e75800caa47db375ac79af56b078bc0cfdb50956a93203c64203879306163b646d0f9339d76a12e206f14260e8d6b9ec4a7c81072b9331b100868301ba499dea9f55c1c8ea7ad7e4458039fea2c053df7760732eb7052e77299aec79b9f81e8578e3988901b229297cf523461ccdbb3a08abd1fbd9d06275d409d5adbc5d7e31b51436eea7604a09f1c9877c5e8583df4c331e85988044585fa9f563dcc1fbc0ce3c1e6c55bd43991bf0dda011eb57bbd636597aeef661d360323757497a9eb5c7c3ae2772a68d0790a5247302bd115909e43be6d2ab9d67fa62d98479ce36e1fea9fb9c62e80f5825c0c81a7a499a46cda7875302a8cdfffb8240c671805a1b6932417c628c0d8a2b6762c3345954a14b480aa0a7611ce04be463fe5b8e1c6d07f40fe68334d17a922180f0abddfc48d41bc28c150f44afed7c7c4e20f358900926de230df7c215bd8fc019da2b66f28f527aecad5679db058dc6cce01079f03e2b80676d0eed362d33ab3adde71e03210099379597fd1323e4621c7877b55bb0df17482027bd7073225c1f00cb3ebf329ee60dcfb6e1a4fd5fd0c3601f17c52611348c20b8a74078dee997153b12f865de576a4a22b819ff1196a58a3d5dccb3f6312199ca69eedbaa0730f86ab08ae7f684134a5d1eb0909242158c83ebecd9d812e5fdd3b5936d80de023ac31e9aa630eba3fad5b990052bae39d0a511e607ab3b963ff34b6ddc3d4f22239fa55ab24797da40fc74ae87fea96b44b848c22c9d752c9de97a0206185d3ec187bc923f07cf67c4e78272e022fad89824637cb8b84bb2c5b1a6fdd93771a853b110c1861622a443bcf7bbbc4ad6730f8716ac8e96a08e741469219b8a1051e265a092428d51607c15741b82b352821cd98f459140e69fded18c44124d80689bcf1cef4eb9cd5a709e52ec386b68d9c3afa1dbe80a4d02261bd767be212c829e30c76a980eff5ee389b6c75bf24acada509f4153c34adf40e1d2b5101bd048b79c6dd0ad97f71c4a8945c01681fdfb562971eeea553f67d3e249b9db636ae73f55048e13a6e04053b40516b1a88a3a634f56c4acf1872f474794a10d4c3e9a9de3c6254fbf6acf5d6b76af351ca5a08f032e3a9dd52c76cd4dd5c5d89d88519082241cb85a20505a8dd3019d075e0c3fff86afcbfa2af021540a6177c0ceb16b3f1ec6d577f1bc72a84484118055f7c8d358159445601789341ef13deccf5b042ce6abe4cd44c989065ea94f63648a185f8ba7e4bb51ddd82a82bfbc93691173a067b2938e0c5b20b7c5af8ec239bc3892b829b2696ff9c957c5942793c40152f3d22ea2343a5139522608e4f00a67af4cd0f9effc553612316693b3d3db6b0bb3e4d1b9a9e7b049f7858f61809b1287f8f77e6c26f0a6b3cbbe15dbadef4ac2c16685eef35b82d45e0905dc842a01f214a884bc98140f6e587c7d776f4797e67f62d36ec6b534825897e8d4d0c4630533ee7135895da74c95364e77ef85ec702e57143134f671a44fe62a1862c61c8fcb26dfe7a65abce78f7be64e7951ba407e4b1be17253d3ffdea7372a20a817e9ddbf2b4ec50d3645e4c638fc1ebfdc1f29a918ccdae687bf9e336479c8557aa92a6a600c5997f0da6b123f785e6891f7cf545ebffd31703f751b10c202d12262202fb915bf99b646b2674d0603dfefe49deab485e927a252b5824209725621c980bf44e8e13f13f0ec00396b9eda615854122c5f7cedf6a5ad15b6c0810dcb3b338a479288f0c188e1294445d12ff368556ce39bdb5ca9c21936b68cbd76b54c1636e39db95bc54b35b1a4bb050969129b1460abb6ad765e2608cc4d295bcb66d86aff47c6c5e577693313f5a8776a04226357a0630433a609764c5f0bd91c9849e497d6bead750fd70766549330415a1b62dddc52677c3762390a5a5cb1084d4b598d1a7fe5a1481421eb6487896cdebe8050966badb64b6a7df0f00635e549825d51a430ab19351b4ea0f2681244421445c4ebad7bf474d62a1cd55e56783c36579871eeb633aeebc4917c65bc00c94eece8e6b564fd40d54918318c51b715f406cc2f89398d7341cebe07e950408fc66efc410a1481b1d15233bf76755ae36c2dc40d685eea9edad45227da2bcb1f04b9206dbf6c86467d9bdf2888deac20dae8e203b2e0cf8b7f02a420cd39cf026897cda2dd087e8b2605acdd1f95305dcdb6094f981df457eb31687c5506ae37186b56a70f0232ad4cc978ba19943dee2f5d20de59a0e8d173d208d0f8fef914939edfe62e0bb9c7f306c9e34001ea5f3d477785ee246eebd90ac3881d29e62fad771456a7e8cd5630071f608e503046d1ce3e1cbc7aec92ad150d71d6702c4bd730949a629daa7b57dc56496661bafb3316acd9e21f157c26e1604e334f24a11a90cbc924eb4828fe15de6271e9d1529911d5e87e0e06ab3246caf4c52a29175732b6ec053c058aa8095d0a10042859b9571b15b565a0f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
