<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"295c40308d9656e16b0d32bf5f0bf674e3f8a1fc2b7726472440f7ab4f40ae6f3bba9bdec33bbb1519c256dfb38bac73e7b3962189b2aeadfa4b7d219ade2a47cd17709de45a65f22dc1dde5db292ff082c62e9f11c6c2925e3d6b16139c52b7e9fe3a912aa80cdb82e020b03e3d5a3b8ea3c26ec46c71f918464331b4d656e279a52212f53f48199aaad7e90f180faf0b45cf8ce9d4dee5a858d77f7d681f3c70f3385542a1a202707a3392ed0318108adb2c3953595865d8fb8507bbab60f104a4faa8502f8e4223864083c81f66bda0d538084638d8e518095353c41e4a1e942ae83b20e9db593eab1b53c6f23d867680465d86450b65eb82f892ca0edd9039c62d433b7ec5fa7a12fcd8414919886c96171fb11d866b12897c62166fa02c5a26a89f609ce6e9d72799cf0543280ffa1197ea9065e10e2cdb5f4fe8de10facbba3e270496179f03c45f77991fb679f618de842676a74931f4c063341da1cacc9f3438a56973d0d7da6249eb50a14aba610f6fe0af756b944f706432c680a2fcff85159910ee6e1596fd7e5a6584c217df76b9a57ecc7eeefd54e53f0fd8035055fb4544daaab24296e99006197f881d217298cda9502f6b580fa441a0a466bc47b866ec7d2cff36dd031761ed68f2ed7ad43b7648721779b0f6459f99035a38b95991dd2af12cef9ab8cff2735d6b4e028755ce81ed510780c3ac897951b24ab3f8791d84d0074cfeb0c60a31f912e5b05004b638c3c7e6e0a08581dc534ffb3453d9663114a88d319dce0f3589fe1c78e0dcc6fc9e027191e68fde82d21e22f879c42b104101e3580a1cbe69f82b67dbbd3be01ea603b98327b0e53a8c6fa179e2718610b007990fd712caedacbac0791204fa334c7005b459623ff0a66d3d4e4eadb3a02fd2d130993fe9303df390fd2840980a3dccf96b7c5efc461d9c28b2857d2e45cf553c9c34ce5656ea2bb1c1e138302634fbd5692da746a7beb3c499a237cd9b80c15301e20007a488f5ac6ea7d2b4a7f17b5f16d0a99831232d51054296cf3db3531e32427dde71bf6ec042e690a474825a6dd7f253c4081159ae082d2a1e1ab22738ffdb91e805e71d6c13c94a8a75eb297f44bf3b8d734b2bb9bba555f6a902f8d861bda6374f3b569cf7005c46d45733b8d7041b67862d475c4d0689dcedebab0260f39b737138f9bf430d470720b4e83acb4f5c6e5517b5db066e71f95420e3903986a6754adc953501f3f7de633f866931c395a47d90757e7aed0df3b9a37f91fbf6240852f2b4d335eca065959b6322f68910c7ad83b4cd10d295516cafc021a2cff338ab0b9fe680649411a640c085b602f5af6ece44e801bb9e06129f5f18dac5fe968913e2c43c6e3b5c78e8d6746ff9a82aca9ccc65d451cf45299005492758130e6c320a300ce00929d271c0858ae1acc1eae0386b7b233e1c9f2f1dcc21bcb29c6ffdfd1f87f25da79fe579478a8f5adc6daf8db04c1badfdd39847b00a46bbb99d9dc869a5a03624365d6dcfa56fe0a83b409827b1aa353cdec798e3ce2be7179de8970e2f8612c3c4907335c87b532579ed7af21fc15911d064f9b25c7110fb5ab9742ea85c46715eea6d5772642e28ff72fa11ba340c59696dd7d9babe37de0ce4fcebb0745f5c914dc5261554b8431a81d3632dfe4292fc215a6976edefab8c356de100739b32540cc6becff230c63ce54eb293ce140426832c0e91e6639377bcb15678e88f7e8f6bef20d93952fd7922eb3c158a3210e7d246e4b6dfdbb64ce84a990a354567c31b984ce4b9d7580173910b991a63f79c582c2e3703d9057e0e06dfb60d2445bcfc7ffec596758e242c787de7ffeb239020c2a750ae24f8a88e1e08eadd3ceee576929a2d0150c36d25de08529559e72001437ead9a145df8d2e15a12f109134aef3d92874a0248768c8aaf2d1e4a338a5efae7056240c93a4e334a26ab163504dc93cd085e0f732657e41d4a99f3c8a1ab24b6819ef8f5d137bfb981286828247a80efac0be1983710340b066ca23ce9b6c8306ae7220f6000a5f0e4745b9ce1cd1ada1a2a4b913b536d517a28285bdbc8d29b20f7be359a640a6ae3761959139aa5fe06e75a3cefdc21c89644197e1c7536cd8d978158bd07cace3ef88cf88540b864a6f9772bd3ed584c972938cb5414b9ff3b2c17aedbfc1ce3106d120cb60878aa2c39e0df43c06b3aebb1f4718390df3c979cfb863d5e130e3d645ac2dc3214883b6d60cdb0a935c931647d16e9373a771caff62e370c477bb2f7b7d53e3f50e086b75b96ed7027b9be549c7086279e5a0de87a0f8cd33e4d31dc564b90af4b930069f3ead33c48b2d345a3388431137244b4b0a4f18f55b4e39cd23edea0b75a539a74c76e549b962e4bca77bac06dd3434ef15373ff1740164d09e4d906d6dd90b1bb7c0bbddf9fc5d6d6d17f388827639b460799e49d02cb8af2db4ca7451490c884e9404f61eb1ae4b1b7a69dfba9001e9e9cf71b5c9b71ce10cd448665675da191f52801a934e9bc45b8f75d99c69a955dc203ea1fcb93283990deb49bdc3e120ca942cac59c0f17733f2b9c63bcf610f87d29bc3d2afc9691f1024730daf81f759734732d8d3606beb7e69798906447a28292fc3ca76e73ff76f139883cc1327639c75317877f0becc5e3fbe689cb3f79e94b59e002d39e022a501cae438b013c09bdb978afb562fe4fc16a3b032f7bd3eb15d0f0830f80c64eb3380e57bddd4729f05ba73862ea7fa477b30e0defc119930fb98881e6338ca5f1edb81451f232e6d3fd362e36099641d1eaab6eb023ae736a04529484c33b1e7125ba6024fedc96748043cdf9e7ace970ec5c22f73701d8f6e35d7cb72809260050d31c8c9d34c0f2300078cef0553dd90ce03006c7ef2bed4c422c6fe2a056ead13b0641232891f98a0a87ef34d91e72bd5e8f9675ac59ddf47e514809727a85ea5ea212c27601c4ff9e59a5b4567a0cb016e3fb160ad02fa5ebe362770ef3b8ebb13fb2c132fd30ef87b513740ba025e301768ee75347841b12f0f085d279666b53032aa716526733ad1e77ece5b2f1c197e9ef95e5491d6c417dfa75bebe2529b962a206d955ddcf8b2979da8f347a25b9eaf7e77a8c71c1d35c36e0a06cb4374b15c95986b47f809011e8ff61193743b7e99451bedc7308a977c3668c9cd0f458b80537c6fe285340ac94b9323b0017dc98bc2aaf7d10a8dd61d1a0c356a4952da9ada532ead1d3bff9e21bd01891668fbfe3ef4f43c66ede0112843b3e0b1fde8b5e7f4396d02714ce3528f34443c3f21744b8f725aee15340a2db2215102f0f6a9078173272136f7bdbd00f743d485efca5e4a760b47a1273b0bbbab61c33a5d5941fcd8eaddd1b16d559e0d8b6ca06beebce78e9706a357333dba9b4af72aebde1445080b40aa9f7f4860b68f5e2be399b72eae7e13c919f57b5e3e911d46df9c397f5148db151b114d7c704e2b87647c9622f519edb6ba40b159cab13f390ef5f83a9699acd7cdafd8c40c9347e9a1718d4fe070d1a7267435b7258071d953622c0ff4b555598ccb5b9b40b38bc9c1f57af7fab432b5aac5c98770a5f42137fcc09ad4a6b9058df881259903be81055c3ebc5703c0fe65458afc45102cc24dbb019576acc6cd571cda4f97669c52c3c7162ff26122177cabb614293aaa95da38ce185607bc4049fdb22473b5db9e5b71e78b6f2fe8acfae8ead0de25a8cb3f7e7d5ad72cae81fdb21b8d24056f3c42da6cd3e829fe1a2d1f2a0f7ca3703949448b408b0d4f60a877ef35473722473cfe1d129d313b8f4ba55b90709c5f0cab0d631a98047f9259c41a3cd8bdf9f462fa951a1fcb39d5ad9d6107b43ffad484cf65b772ed085937de0f39fd80e4e491ae4b6dad9b4eaab3e6bd8fe0febb680c9f7e61482f43a9886c54a41bf217a42c89da8befc22eebd51d33dcadf8819447578d06d433fa17b407a8a8496767554a1d17db8a4efe51f0f2eec6da1de925136fb1a30a8cbce8c555a09c438a0a07e2c934c3ea8ef619b4aec2706363786ddbd54eae60dad35bab7730f4b9c10819292137b4f94613fdbd1511a60868df717de02326ebe3013ee63c09e8ebd1d7eb8c2836ef84abc1f9a6c59b95fc79b9f242f79ef5e36d0fdf51591b3d7f5e4fb6c913380d6761d31c6c53e5a3d2ab4dec6887551b86c04aba334bee62ff720e3697e6c0e44877b65734d9138222c5c0b3b173a710dc329219c548c4faa86bcfac5c811935536dfa460ac5497e4df523b0a0ad157fad98adfe05fe352d1ae902f2d362378958b70ef0f5b534c7af8f8065f341971f5a8bad34fbf0de7d2d9996c3cdf71c10569181528c5fe5bab1485e7c2f8e7a1e4eaece7a25685e65531f1d86099ce0130338cf60c097d02db6f154870f11aeed1908b1dd5d0748c8fadb19025d9a5f728fe8c03f8e0745cde975bde33e113f75efb2d9ae78d6c0df98278be77ab3eac82095b5707cc698df88e3ce1c987610c20808f70f80d8fefb75f6c8e403393f9c650b68128bf0856ac09e78d306a469c9c006975a026beea55a9d258cbdeaec963ec5d43ca99182893aa1d01c9f34a60e0f09a314b90d0b7e08c73a714db3d79318fd323be0e67425524b33f30264151a375eb85994505a8848364c6939bcf88983cc60e4f13a73e4309a9bde21c450f3e555cf38c3d5c55eac01e91a96d4bdd5f6306e9fc76c80be40e115eef7b1cde16a15405b396227b443e513861681d53b4bad84a5055ef0d69b3a133eaad8f0436b16fd0446e6b8ad1628a6e31d57592f154459fc55c40f830b3cd1f61520b7295d266595828a6110681f1790f6480da3d1d4063e8461e0daecd67f0b4a7b93f092c279e36c50158f0528b443ef35e1f6782aba751285a64bd0f6cf360479a7672e5f32db836de957375d62f028ca02bf27e05c053a15092ca228f14b5e8c637335a02b07b66a1f8d818168720f59053c55a3d3506b1fc7d93a5baa778673433533d164b5e86a28f2ff94b09f70915eca27c5e4cf68527fdac9de7c144e0079f08a6b491cc54ee9013b78241e8b8e4788f819eb561a026104c693e1d74c199497d4459c5a70779209d27b62969d1393b6113a358bcf45ac17d75611c6d1f4d6bd4ecff91d9810b56784272bb9a30edf8dcad75598661caa8168dce86b641b8ed6a16d2dbaf9d8123e6c792ebe5b8301e365ea48d3073dfb1163ef800bbdc1b27a7af482dda16dee4018cc491d930680e4705bb42fa67cefb4b9b647ec2bf44bb3ec325707353ecb392af84b768706a6e06c5b016a36574c184087397f299edcfc025b5d9099e231361a38d39f66aaa23fd56d5b8c01fdfe0a3458986abf9a93c81fea5b65e25a5b67e50645da51b1cc774e420e63a7c7dacb6b4fe247194b8864cd271f062dc0c84a278afe429ebb2bcc995745c237e09139520303a8a56bb99a1568168bbe7fb4ce4634bc112ba797958cf743d9b4bd7094b66625765699cb1dbe82fbee20ca7ce68d7bc1181f1ac671108bef10385ea78785eeb9472bc34d70dc306a37b1f6d0aa07cddcc3feb113fc2ab0d82d871f15ba2b027a82ddd46a9496cfa9c4f23a813b8f1fc3d219df01273f848cb166116a252d72c4ac740bff15ae27eae0b59d04c050316d098d5a928f6c5176d648709819d309559e9743cef8bedd68eb79652463c5b7a8fcba46bee37b03d4a69d10cd7e7cd73fac6238b8f92497f9fdf76d9f77270e2c2bb9fce8ad64096b8c57ba447024204b41141dbf57cef2e73e554fe0ecd04ca97a4819ab4fada28b8f6709c8fcf7ce9689626ba25c40bf7081e13d728b22aa20e9818d368e19324627db6cb3a5e71cdca2b5a7a46857dda128ecd08512ea9ba7850b0dacd646e40d4267f4cd2326c0873b64eafbce0d1865dd4fb4ab409528eb532d4f916d4b9ea131dc4386b0858bb438a59fae980a5348359fcf2da40dbbda3475801f47163932a5b6cdfa8d06e552bc262995a9ebbbab02330170b440ca050a006c83bcf7c8638d126c1ae61c6dc099805185870c8d03daa7dd4e11923d1d1aa1646392715481235a87e52c9466c9ca0a34e3fd289b3870f01476df108857cb34a2d519f5473c1bec1d73b57e293911b7f543a570f81a9e846d564ffb37015d2b655cd87b91aa1cfb698b21e6fa5601100fd90411b84634721abb83e97e70ae9a2b748b8f0b23cf654872548617d24580c7a5292a6faff1694cc18f3c61d17b868407437e9020cf34d120ed15279ee7abae27fc006d09b36b8bcd8c825ffb53fba89567f9221538cb81332873728bab93fad4039dcae9310c1ea7225a216d9ead0d30cc49c2b3098bef519528178f6e4547aa5de8ee1b6d3759a2de74fc5571bf6385fc2737333fe0056b91a4952582d1300300fd4ab913e306e6dca64e29622a7d3e375be576a8b3ea4983283359c92e20a0c17314a4d622ca77c968286f18e8f66f1432cc70906c1f492a4533066cc1f95d475ceeb456d4a618250489c0307cc9ed38d721fb1dcbcfe9396d0da9788c1e4df7720611ae3025638ae18c5312702bc7a6434d31493bdeab53f5e39fee6c869726736a112621fa167f6e48ae801a5e1d472d28797f5d19a4056ef7831262c85d0d4a595f228fe4a6bbad2a8e192d530f3423a3b4da73cf6d139a61cf90d7a27eab3a330b3fd7ea28322e7bf281a4b1c686a360625022b2077086da27027f6e8b35b6c202fc8b2b28466681d77c734cab758836b9d4e188189d6339f09081af02cf7d5fe18eaef63bb147ed104e7660f796f95285d38780297563fec9db732d64cc2d0e776d65357a91fdfc31c2c2f0fb4685b61ea3016c41ee3896bd378af9064c9500a7fe1da554d3b2037d475bbfb3974309ecf0f533fba8887683f8a8406366e1f48e1e4f0b191fe10f033ac33abe0a0ca2b4c10f3caaba0b06a8d49937c5804f1e9c44ce916a2769367a8814242be573c221fa512200f6d5f674db0a273d3671f52ca03e4b2d5260f02294210fd10dffa154bb887c3db02fb184c7ae42cf92370c66a98a6694d706f56ab4ba9003506aa9678300ddcda195b54c8007223a0fc35498dfc99499b45e49fbd213734ce38f3db42fb8d0f0c450fbb5247a2967c890970dfd8715cf9e131e2c3588eda4bd422e1d499de89085ffc181369ac656d39df10d436ded722efe8bab326ac7ade8daa8f73b338d4192749af692319d9c1962695a28d88e61137602c6b632921e8b0af05195d9d42d263f6adb6b19d384bcfc25ba6cf03a99b3d35c875d0645be67c1b490604761646a3f0c27414b91dc2e24145b7aa00df19f47eeb8ecf5e3ee17f21a974748d85351e9b3e858d10615e65f4899503abb1d9dedc19145483199b7eab98717c2e3ac35324f6b7a5de09853676f9f5533c7eee8d82267a5c4a72711ce0094fda94c2755a15bb3a27061b755f1fff4cd81cf87d96035ef6082b3b863ec31bfb3ddd11c4f6eceef0c4ffc578cf8445b5dde95ccae110b7c0731ffd494e08fba198e42787531c4737f6bfbea05895023bce5edbbd8822dac282cc48f7a34b57ddd9b3e1d045520e9e42526066f96a9f39c6244396aa55089d08694bcbad86bd9a5de24655044a690c50de121511b8ec6f1127d588570d567dcfeebd4338773d2baef3c5c6d30634c3cbb1fd37a16c5fc2e6e99fa09e31645d22d5053975530cace9a5fc1da42bc97d5c4216b5cff29bcbdaf0653643d800098a912a8f36d56fe95ac851f3ba2dfd74769ffba941640c9e58aae555f28ac0db753ea4a3b39fec8966058ac947e6c9b4cda68a58607db7f5e5b1f2291340aaa074ddcc305cff9a7ee7d10a282168459121da7309f3f8f937c93eed0ca656d52c0ce7d3b0f006e30567a3898d9ac1687805bce2b02bdd2d6cc0e888e4df6fd6ffb07837e951afe0a549bf4960be6ecce76f07dada055ef41678a560badf8e964db8e84454e1234c7636c07bafd7dc43f922294916f537f15bbc9c0f535d01f8b0d1443515a585f8e9cc3b270ed43daf17d76dc3e3f7ebacb5214617ef2e4ddf3a14aa94915f7391117a7d7b0ac48627c7c800f3d457b278ab69f216de3a1a11466456439ee5df2a8e4a0bd7230ef3540a3f7eb77b315be8c6150939c0d9b43c043210cecec372674b6e6e222708e2e66a3fe717f190217a43d204180e3b2a8420f6985e173af0a69026a2d84011ee7011ba6fd15449078bbe6aa6074df9b30d447325af09585853c91760bf5c79ab290d3d68b25c8873d5b1895a9fc1adc31151ad38cb8d9711d176aa9a6c375b9a97e06c026a8c9d68276d781b4aaa50d2d44d61570092daed875f995061f620b6ce7804de7a2728a6234197c9c6addf8baada8e4f92570da932628b152566ae41c9e55ebe87210f707a6d5848fcead735fd14b8c710e624e6a9f3c4c744cc91904f893f4c7612befba3394c83968603185033f1c493d8fa2a8b14e6a665569d2ed657c5c6db68afcc65d466f3c44897c2d2a1096da9810603107f29d7e41f8be0ac20921066c07d5169c468e825436404f820fff5244704122dca1e902e2bc0513b68853bc2ee285006980e219446954e8153ed53a4dd89edfff05923b3728c7b669242e61366c22bc3ebb49d310cb3cbb429b4e53c3fecdab82bb565ae46ec2f9988fbc6796fa7d94763efe46982ca6175b01c9951723d02d49f2832b8f171ef4744236c31a2fc1427a02c3ec6c0df0a80bea40f9af17eceaa8557e1dda12141a1bbd4b0fdc986cae23e9cb8f9db77407da2e1fb1d2d17133e7a7f98c03ae0501b2480e9c3218eb40cf9d2bb7d10ffadf88e7c7262cca9f6e8668d34e2aeaa898fd9b8d1828d89e28885284fffbac624ca3a8bd07b16d9693b6b420030dd84ba747b5a3fcd42f31676b113af4b657396567479538e254d97734764161be1d4fcff5dbdc8d48fd74e442695a93c5db35434e5651ed79b01f560ad334298054d5177d5fbeb0664bc052e1a4e81f41a0f6dd54dc56d2029bb60dd0cca4e2be281665b6f5d2c39e71f95c812a25c2838fdac29e36eec216e58a245cf7da18f9706570c4b3ecd7fe72c8721a2cb12f45a68f4c74931cfea5995cc172cc67778f645a9af6a54a034281795285875595fbdf81e5fa5435dfeade49747ccc70113890b7f6aa17074582f85b37d680bb1a2a39747dc0b8f2774d5ae3ac7e1a5016c848228cb6dd19e2ab7479107f24dd93b1d80854f3fc1c0190fc916c085dd97945c89a79a0d4c7988193d76402409266e636cfe59024030a455919eed413077606a426ceb75831ad04413407627413c85503e41c2509b03ff716a52ae52457fa53e482cfce38692fb86368b082d54353790470d0ce6c03f27d710dea016bda2da52df2922af7df63c0d9d0c8952cc190e820028050c1c6486324b49a93a73638d95b1114db85eb4842e2f6841b7f89697da008cc6b26eb92af07a7ffdab0c6fcd18aa00b7f8d0de3f7dad4f8450aa285257423b0fe7ef4b5c0de140ea58e4fc3aba40ff7a445a00211a2a8582ebab129909eb26a1036e33085b158c2ddd21d45ba6a967892e6b10ccd2017375860d9cbac6ec8088a2769201c3d2f3922328e7d55a9ddd575bbbdc590527afa4d727d3cdd6411d1176edaa6ccfe58527fbd5090727137c402de625fc1d6883c35eee8e4cafd060deb315a778c073411309ece8f366db15a30f57aaaf13d2f35baad1d6a820698739cd1782a88dba51e2251e3f6e76f473c133a73ad420aa089872778c179bb441af53f41cb2b95004474172d3430649098c6585b44cad8799795c5709fe0eac124cc145a91bbb16fecebdd42fd6592fdbd238599b2d45ade387239fee5132d894b7cc5cde0916d3e36144e1214bd1ddfb6c3848b1104de4a24ff1a9435d629a90ddef04e2d05565bca99f96d780fd67d261f3d942aa42488a19b3359c1c01ce411227e80dcbaa6f133152b108fc1f39216f618eb59074adf2ae5caf64e42fa98305ebb4be831e8b25ba44711e07a4b6fc2dd51718d867570c8fb4578097af793dc8817aff0529136225ad4cc9905588d67b10dfe0cd2bdfb6b059df712d1ab562602a7a84e27267aebab0a87f4bad26bbceebd267e93badef75c49ce2c3bc399d72ad68c6d22e4053a6f0128f5e3de52804ac2d4be4b0bc508eeee6e8855c1c287308f103a25904b486e41979e6fd87bf434de3235258a7b1edcb40d4522073ce6afb9601a01e1c4a231c9e993ece111b9b71ef3b142840ec6a05d2d78539b68c40f569f683a57bc65b52dee85b9f3054ab57aa861ee416ec8b996805eade2c8fff043d5b9746556f748d7e5b988e6cbf1918126e425c31d34b8205d60448cab4fcb31cee7661b218a33f220445fa0bdc7a35881dfcc69120ebedb4cde9f10607e29287f4e8fbac6002c32d6f2fd3e46d6fb87834a55a0c043f1b0911d7e569fed17458600c8c320dc568e194419adaa4a34be0c498fb3cf77d0118d362b2a9fa86b3b67079920dd709f5d23fc038f9d3a8d8bad9ee94523863c891962c5739dd06014e496a3ded905680d827ee72d4f9860340d6a4a4c64158577f41768cb93547a700a0e1ea6d3e0cf2e52054eb33d4286804136e04be8967ea84c5c87dac8b8d995f2c327ddbda4c3386e706546291dfc20b72e8b207606c2590982f98893faf6b032cfb1c795c86907e3beb7e2599c57187ff8d5ead243bb3c3fd3a3594d370b5ac3c4132bca60b8ec6ae2312ac564c25dec865ece27a465c5ecd66b34e76102df149104e7464835029a5132abbcaaa8ee4f6d2762befe9b94a3557749e6012f6e6d72765cb9cabdea13a54418c4c3cba8ca6030b7d65090e1d409c2e94e914322c80a80f4596ada128f09e67c3e1297c1e998204848ccfac1c7ad1af071c032ada0595fa65027b2eb899f9a931c09059d81a42a605c77a4898ad2108e0a4097a74442586608454519b71a55371cb70502d7f41f3212ce2e92c0b4c3c805400a5f0f01670ff7babcf93ebbf8f5b20e903f07b282f3781535b8fefa78274b4d773a16d0e34e9f72f7e5c57f47d8e54904fad288d6789b3515555ff74b4db3a0e1677725ed63b0184790fc5b68072fc506f0962d9add28d65118f3b115ba3360f79a614b68843a231a32efbb1e471dedf07feb6588be8da4ff63c4cd7fc015c9b3ac401f5a2a1b1c83fd302bbf16a357d9aa681374149d224f6d344dbeb3185573eb430e358406b8795e0170056fef4ce53cdfbe6ee6087f94dd7f3865c4bdaf7b0d118169bbbb90677398a4566f8738ee084294791e4bf870ae6323ee1f757f56237de16880742d400286cfe6df9195476fad6719c98bcfe844edad79ae691219572e83f5f0795031085f655b0b934c773056316d21e67791a098b8c63e4491524f35a83c6b99ec4056cf3367f03d4921749f3e84ab6efd5bd18b870da5b79e52aafe6d1a93d05d7c77adb5ae548f512f06767646fcb7523a194b732d785de4a574d58fd2c17466c4ded8751ca8b2d73e9688d6990d3522a79420c4bfe9f4b8d1600782e9eea9bbadb3cc35341fe19b73cdac20bad007b63fef3bfa41a63b149a91ecd889fa18aaf79b15e7579a8f8ca0a417be6b8cc747cf0f630533dc79e8d1d3241fe2d13d25aca71ff7dbe13843862edf495275b0d77b7d9bc004086dc42aa2c85ab5a29a6fffa43c2b78f49cc488adb9fd221f3052f55127ac8080237e78935a66adc1200b84432d60a597d50aa3207ec2bb21334e5b858441cc120481b475f9d4cbb6539ca8684b24369e9407485a4940f421ceb7c81f320838b4dd3edcc29462d8b09c9029d8d649cdfdbb3e845e707247c49245b98adf8e448355b28934eeecd57cf1389b57fb157ce0b7f074ce814aff5d8c5d34f524998af6f1ba58dd35e65eff80458cf04ef4ff17516ffae83e2fcfbd7de6faf1fdc1fb3a743c7c2eb132ab00d6c41f4899119bbd206bc7f1ccd23ceb9b454cbf9247a26293445aa9920545c08e028a998409d9475005ccbd2448d0775c4e4de8ff465c80c64af72bf4f9c13037232a5ad3d8f13cc21f7c8ad5b735c60ff35fb5e65b14ccc63d085d93073c157b03c1425cf271d6b3dacda6dd5d1d8e4a9f2f1a435938f744f3883187949addd20708f64fb570549eb4864e1dc55d83a09e6bec142dabe1bf1703d9ea61812d615cf11f081a2e607a9d067bd2a3a4dbade4c612e00221961b9f4b210f1330c7398964056980d37bb758fac6af0c409808216075beee42754a8d441062f1b1ae9a63b8e7af18d814f1990552d4d0486af9c56b67a7ee9e1d3e25edbd5a09872d75f812aaa9c81f4319f801d34dba1ea0f1007896b4944195ef77ff44bf96b0f194a9f268a87e7e11728f5540191e1b0190b204fb36763ff875b35a7c581ee0a6a5fc736cdd3941b38d218c12487a7b65ff67c2a2093a7636230e685dc8a39ce7dcb98289e5f2f5562f8f7215d8bb26b5805868106e4cf9666e667632e22ae33b6a5500adc215261a9908b1cad54a962587f7332cf37d27e4cce5fad7a6445edd7748ec041cf22cbaeb06fbab515f8dec94e3a8f9d853cba04bbbf716b3dfcb1c8ddf0f83daa80e1058825bd08791780320e3e36db9cb15677852a5a29762c4877459752b4a8c6988356ab2ff5bc0ca9f949cad5a567c8eb1cc3efd04564c525a45e3f7480036dcdff2b03738ae788dd9a86abb4b6b85a17cb2ca657d895e0abd9f2590b9f5eb59c13c4734effa448ce6dc31314050f9af5fa6064477153b0b3023ce7ac62579d8d901364cddd2729181405ebf2ed7148b1416151e35cfb94f16f1c0837d331da8831517635ced83fdbdba6e985e39a90a2067efc3f85a0fe45afd44298931dc60786b0f8becbb53d377de8eb5a5baeddb79acdf303af40e5c705d78cd78462f5407a6d5f4150e16f3af1b394751d432f983f5920364110df14b44fbc87c40520965c87d709027a66658b353029926ba210fc813cb9de3cc76486d7ada4e3c25f42c58023760252b9d498764490766e776d41f975171a27c83cde4f0b9b2ee4b906181533d1f74bbcd4961d8f09e5eb0386a43536f769ae2e334148d0a0dc4383060ea088d03ffdb2058ca1db643b45c8d36d86fee59fc683b53cd0d69ac9f0c58d0609898cd3e825765750dbb0a5f53ca15067476c59db06c4e1dbb206ee0bb84bfaf1be4bde5e759bb8cd286c8fb08ba2d34c558fe49ee7f8bfb1b0c0952943dbc078fae85b4a70a3534ca77fb266a0ec1ac8cde54603b4ee51517329da971f16ac1247e0a06f3f80af6b235dca03e162d31ba28b116c2a7415d185a2de41575bb76c7fa3d13a4ce57c79970b0ceaa36c5075c8cc42b0aaf92d560019a22e2d5c6ac8066090218026699782a602dd81b0e4a5c2737df8aa187d3415597fd2bbe4c77aee2261f2e80d2d14d28fc1c062cfa85f3aeec087c8a52dbbef4a7be24cde85d2260b2084564a43fbcfd1b9cc6a90deb1e2ebc08b2531ec39d549ad352b88179a13a3d40711b8ca131e5d5da4c1c83a0ee71263c6841f992024d69cbcd2de757140fc5bdd4b33deacc88d433f07448f0d72450a4d70d93678b4cdc687fb24e0a46fd9329d5752c6378c9bed49410a82c8d3344b8f45c267057622d0b4beea9c7f37ee3fda8457970b986d6040a9b3df44b2b61b24a5614bae1a4d9b3f4725f1a4eca160a7a5cf84ac92140cef333aeefd7d272b93f3473df2b88bc3ffc5482175461472ca8d12ab5971706cd741fea6f655ff88a6bc9450a093904c4fb087c24daddfe3df4a522acc84935e1ba7e46f12dc1044cd6d31c3cd7359a1ce85040ca86d61f30e1579568bf86440e3fe494f63cbcb604358e3500dd7753d957a0f9718153575fa6db48e1069cd07deab7f07ea61c745b5a0b7645c6c07c41f5958ab83623854c1a0caf06a10e83353031503947248850b179829cbc22d3342b1231fe1921688cec508d19565a80d55b00b51228a157225012614d719706a878ce82a961a7a7ab90f6e8716ae9d728bf5631a2a3602d70cbaead142d3fb9a84077afb2598341752330c7c2df29406f6154b3ac7ce091722f2aad31a0746a6119bbb8f39948dcfe3842e5922997e48d4b08297a573d9411845e3a2af6ec9e10d9d48ae3287aac700d16b3e827cf2c02dad714821f430671051e18a7c42364e12266a5dfe665ff1331ddc51a4c1ce7b35296344d01d61d0bb689ff2047380add0b246c3545e771ee26294ee3e92ac3e481129c9e105e683d1f73dcf0e876ea222d53193adc2bfe4c3559816d6194075923b9b6d9358fdc4f74102455bc5465f0d9aafcb041af11350fbae9eaf6086ff519202c856d7570892e1fa7c41b479b2964b63e533345f7a2462ef094c803659ed03ef9f6ae925f78b88478861668fef621c608dd01032e720a7f876d030f2ff3a3e416eaab3f2a94157caad7efd730950dbce8f16c7b32686f5a907a692a1540727e1461cdaca49bbf224717d154b878edfd835edaad9b31ee78cf9fbd9b0d36c28d867b8f9312aba9e041b9248a66bceb139b440fe85f14815776c0308a9e449c40acb52d15fb9db01198987abe7f7418b09c843f1bd6220129b0f044f13b7e30d73712c8fe467456fc3f50900995ca4e4d832d959460fb1194ad723c086654fd5a829124bea478714406d23aaa0a9bc32395aa75b90ba0bd1cf4579aa39036b8ca84c6b7f5bc0d43ae3ac3cd11b369d5cc6ddd9a219dd27d7a4af98a022420601bec930a05262fd0a8f8e9d691baaafea5912924d14b4fd6813268a89b518b5c82c93470bb5349318cf5f17ddbd9c62d43d0d833f4bf23babc0c22e98bfc7e7162b7c8ea9f1064aae2d35840bfaddc174e464da1bc098553a3faa85d52cc2bb40f8337601fc24d0921931b7052b9e2a1e8ecdbe0828410449757a03ab61a6c46698dcaba5c025d8b35b55c76db355286162725aeda4266193817827e6b6858a68f1cb9691d57835ea4ffd35c424e08d0779f8fa0d4053db40275820d88415a4ba42f1295e931858474ba528ac4514533038a60ae1eddda95524a5ba1f33268bd2973ee386c2b1e5f4c0f58fa0cf18949d9cb37f02c6c9309abdb86a899cdb4a5e590273303d191a6ec8cf5730f60cbea494e54057e5c88a15f1557d2da0a153a431d606bf434a03712d440914854decd53ef4b1fe3a448fb7c13046a76e8988140f042d9dfd62d48ed117db71340aa7e5a564d9d05ee1eb5fb3b3f28bd0c9014829794677369d0626a85df3886af38e19c7126938490c2158081bbef1f296882bc8ca7376b7f19eda0bf774e7c03a7327108972a61d0abe7a86fe4e2421d7a7e89cc45af26b41d3082f344f65ddb1b9eb820739ca22ab07614b858e29538a404cbe4808ddd80d43a2b98f80245e6b99ba67e0b87863833cc4728954e05c5830d75325680bbeb2456d6cd688d8684b1dd07d78e43348e55bdfc6e598dfce9345067a8f4c00ba2c555803a9b2b3443c71ecde45bd470660c418d1d6b2015bd7baee56c60822eed99272d0b07d3285ed3d22b9da84eaf7265bf1a6e39d7e0a54de02cf4458fc51d00ff99900bd8df850fa412dfc5eaa612ea15bac46db347073f09d42068ae251c1796ab63466119dc85373007948e89deff2040caa7d212c8c1bc2e427850c21ce8b0615ceca08907d74fc75f3439d51c1b1f38478e35f9e9a01ee3f5b47db1df7f6dd84064a4d08b7f3efdc44b7197300b99e20b14371dc179c5c2cafced22f15f3805e7aff85afd39579b6634580aca114dd1566031bbe995e99dae760f8a6d13c03979a1b245d626f36a90c9ceb68c8c94e11ac8a925557358cd0197f773e42cbd1016e7fea7cf1b5e50c9420d04cc939243e811e64baf660f66dba1a9426fdb3dc372159c227d22ca9628a293f9726372a52e9a1ae139ac997ba519333e49ca6138a534ad4b13ada98fa0863d591918cd2a8be27827dc229e7ea90fa6a76b5874fe37831b2befdfafe3e92cf8059e9b43d9dac0ce0e6a3033d6a1acd2f425da11504807c6eb7fbd21fab1a85d014b06a2b66c080a79aca11119a5db6f1455aa97054ccdab51760271f9746935ef6d5e1421603f371073ad09a59c292b2700721e4ce9d46780c1ceb80eca58d8fd9cf464e446cd9024d823caef1f460bd39662aa749720586f7ea483b4731a378bf0e3157c35f5a0dacc03bd98d209b621129a9301418c4f3ae3300de2bc06c131338d63732708af40456fd6dc8f90d85dd372b6d71981040b944bef9d8a5697e3e996ce3711d0f769469a26ee06f1d026b3fda3c9105455a928af2aedddc1ec7610b1a01d897879bb50a184c3b2bb9c4a58da2ff016796ffb8843a729bdfaf5aff0b0287b6ef327a5ab629554b9a9cf97aec78b2588c35b0f21e4cc760b00a266bf4d6f23f708e2f63407dbb5a2d7c761bf56abb51a054207666a16c4a3066926337ee74fe7b3c90ff9b56ec3b49d5fd5861f9859df554a87b8e69788b74a055422464ec3ca1fa8a90356e748e8fa0fed443bd7498ba675cf0ce5184a7128be1c1f790b2cad64ce72b1d9e5233722a2d42c8571c3f962b97a1d9136b83724fc8b1840ad1ecef07656c8437dcae1781ff76a4f4fe7e061908c5b5c62abec7f7f96688f16829b880daed0fa1d42a35f57734a7a6ca4fc27a1818d4e83504b67104b7ed479f3c46ebf216942523c200662c29251f9d035609a2e80e69372f27345870b32a9fd606aa9b8de7dc18e109a03068b19037954ed946de8acff39c1326881dc9e7acb0c740df8f1821b7620aa060c8249077437f2d1c6e10251f7a3b342f24b867c2f11bf65da1a9c9b4391b66f101f8397e57e806ec2af6236ae2e11cdd2cdb031619dabdc3b6a26053321594edc05793d31d4a90b6a6fdf69c22c2306347dbbdc9bb8aedb4d8ca3f25213142a4e09c576aa319773476c6548c25f6c0a7d7e806525dc4687a095a6940a7bb66a4540570359a2ad2a529ed32c7d0471d5c889ad1952e67f47494e7ff12c74d5a8882167b1e89e1621e36b0c3bc889e0ce6ff5a5fbf3d6185e719e6741214f7284498da548278cb5d19d7b025d4182bf59190198db66c4961581ea015dc51e0a43823358c3df526936aa441c3a3fef8c503193c3457de1697c427c9e358569fe04a2540dfde9ca4f42e129fa440f4dd2f854c7a5a842012af860e5aea40172bbcf97ab5283c8b2313724fdb56d43ede009249c66c38afddb11a37c0318b0093ff8f8f82fb7b3c148356c40890bf8b1d6fb4f167ce1163fd294068026cf58bf78a24a41b2f802aad8b39823abd79bbb7f75c13ac72b4124b48a3fbbe9795957a4122b940919077b0ef44fe818dac29e8f425c7b7e0f546b476cb9e5054bd6fdc7204ce510a41bb6296685aad302c747afb82228bd4b0b15ef82879f22503aef8e726e087ad8b22fb90aacba816b90e08304a5f70a5291832d75e6d10ff3696247d11e3f5404e6726daf930ba915f75c91c53310597b3a9d51cd266fb8ba46b69e2221511bd9138d27c1c7e6ee9d7395beec9bf6eabfff41ca6e4f6a5e1ab8fd8a391df2c145a39eae3e3a32dc6ae59b7818649f7083152265022674c19197405b338ace1fff618aae0ab9f6da3f1ce92a0fc6f59605fb904cc991335cee051807c0db86f149c4f954d66c76f89d5d36c5cca6df926768cda7eb1ceccdcd0c6a5f4f32b7cb4357d906647bd1d125bff926a767b757a79ed061dafdfaf296c58de57c3a98f2e40783052176327902e08e303d24d7af92a4fc875466ae9","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
