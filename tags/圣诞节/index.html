<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20b8383a1eb258a868d9e3e6d5ac7b518702a45b99942251d5c78e1850cf0b6bf436bd318ce53b400ff7d8fc7a7c1e989fa9f54d937ea4c3f622395d87af6bb0b729a56d4448e6e6248eadd9f4e1f4170e0bbdd28959a9c1232a3999c5376189516dc7848c8ea06d82e9cf4c27042eb3dd0ffcbf45c191f0539573b9a40747e0b60e02020779db33b604a3336a5a869e0eb5379b01e3d60a869e62f6b0a32ddedff88f2058268fed758e82b4e4d544240cdc4ea0fb078f4b40c70ce63d73c937bb2c94de6261da70dbd5322cb275effc55dcf6f0ab9e694a5b7161cdf2a2b1498c3ae897a64021e5789861a76e9d9abdfe282c743f661c93c5fe92576ca30ee13afe42f01755a03d112121fdb8c00e870ac9a06af404f9d5ad694589ff1740a152502da0716de32eeafe5490f8f0eb186b40f306ce1556ce68fc3f409c079ef69a37426218340fdabfa63b5f3de7059abff781160225012954dcf7573f099cabc3d048c5d105870ea30dc64ed8a1f50b2092854c4f379d7a53607c4389c9fd023e4ec2570281248e30f0682beb41f5ec19e2e30bb24f208acd1d722e3481589a15f1ae7402f75961460016112192563734313b35f7675e76bc05ce3a3385db5ac54a123d5522a230e924ebab3dacdef6f982745288ec880e449ac0e435fc8187ae9f55f78a830ddf7920d0c2895e4536b6da241b292c69c0c072335f0a0a8191f27c41e060f0d71d77f318d4df1202b3966812e09d59aab1d40d07aad81eea2d8d09240222171c10f31bb0ab2c022f04f00fd902d72c00b3d58b8bd788bf657633d349a331c40e245ffca3ce157ab842b9ece28d11344b583464e5ee23be35e6625e4040457b544d6ea5e0764a6a8ab81c8f66760952c79357748691203096ac44108e9fafe91c7db8ae3a19afb6f1756f697cdd5185612925cb109872bd095e42d9fab2f5db27406beb9c2e7ff51e60b8648af59a3f3f7eaebc221b737e3a7b654cf5664a76251a8330f29ca2a5175b25235a090f584e37b3cbf2060a4f354edec2fd779445e9123a34766e081593d3b9ebf4966c33f5e1b59483de32f1b7fa07997b9b317fe0a534ebb8d69ebff7ba81e9f28151dcac850a5da018732f80e673457589c69f34d3001ba38cee57999272de2cbe4032dcfb85204f6d7d75f2f769cddc36df5a58fe8158547536aff3de4f75136a93657ead764996392b47c0d0d67b7155b64122fc1e88327e48d03b2795489672e1ee80a38371c13b2192b23829388a465c35907bb0086585c938d9adf82fd538309317a9954393a5af9d35ce606562c93cd43f32f1a22716b32fe63f6208014151ea808b88feb77897432afc731d93088bc9e2be449bd86b86a9bf7c1dd415d1570b55dbecf22463fc48c8efb48f21a4dd11700a83663fd9246e6a26648cd1b3b4774ab582bcae2a383361a1d9a2b1314f9676e675a0266f884641b8e68a61523cf1efb071263cd54f09e1a58959b83f8455f249e6a24f3e13dacead273c2a15bb1ad2df098e6763573152978d96b9f0873f6165a3157a1908753a9ce5254fbce3ec2080a11fdebc274844e5f30ec7dfb0480a35e291d8f2be0b8a5a9f0e4c153cd5d3690d0681c4d5e7838d6677ca6ce4a2cef6e4188728edc278213e5e567dae1d9c8148bbb8678ff22e3666cb6d3351a5e19a33abddec4bf9a3cc9885e543f43a2c01b7376b07cb62e254201b539c2877370e412b238a0af5aa018c4d69c5992361f1f2362ef1b81102bd6ef75e508d2cfe4ae3968b5e7c454675de401b37160e64333e74bfe851b8cd46835a16333b8f82469607a1392673acba1ecbf7745b42f574bc3b2939beb00a9d3288cc0f0d644580bfcc220dcca0cd1159229ce6830b9e8b388cf3c67c227c773b74b41b5ea0c305b794fc8dfa603d66dd75c7ccdad44abfad728b2fc2447d7b4e21f1de26c4e86a5d7a042bf92805d72fd993c8a7be16eff0ab9abcc36f8cc197bc8d6b8c71e872872e3b1b19f2d39af16e68ffbceb34e3bececdc3611898a134201dab679586b8a0de2ef2ce82b6d4bdab23bfc9b409b177863f2f0f374005da842b3e9bd692e53f2f1a540bad5f9b7a2513afc8540a57c480759852692330a11d18cc9f373606b6099aab79ab3f477116e397de6b463c74174fad1acbe01fd12cb189e598d57eead742e520b67bb0dd59db29a8ed27d11214029767ed4f852dcd2f2fead2733f1eeb9373876103f4ae205688ef66019726824d66394dc5082b9ab1385a7f02b1750e59677851785892aca51c33de35ce391ddd72566762118bd1a2e0752f3c9a7429382e872311c94917108f49afd3b73d259586a96c96def3713908a1e1e2611fe102a086a308804f67035d535c27c70ce74afc8b0bd5822263890b991863fbbcd2ff74c1bfc16699172340a961ae66aa13f850982d07a5cfa7d89332b484b1b3ab4e1f06469b540cfe6a4389224a05fc0273e396dbeb008717647f0356813dc2110898bfe1bd0d89da85f93102c272d553535e8ae006a5d53e25eca749b38a54aebf18e2bd8de9e7cde2a46b30c4839ceacc0fc1ee8f16ddae70d848999d21b5f8af046e55c0ea9ca09a4703bf20b5080ff18c8fa3fe49c04d598096536710420771dc2772405015713d658f3c238518d9c386eefeef513f716955bc7297560354ae6e6873a9b5c7c60908a8390e490e49c7faf3ab6d3c57cabc83bd1cd0d38b40a969aeff7777fb915ec3fbe030b1f2bd1b0d6bfaf6f41070930c90eb11382b0560b1796995f8e803924eddef1c68d839fe8f56dd25ff1892bc3d944c1b1ac8e9a018603685e2c098e36e34241474d3c4c6b500020266f1270e5a4461f6ccfd1034c8e1880f8c35f05db432cc24d48c181cd3ec8cac80c89041e731202e7ef32a2cbb52cd0fb8e03c41921d36f9df14350c869132efd82d0db6ac7c1628c5074b786ebb622e7732c34c65721f8ac1283956744f76e6f3227a9a90b08e8fae6a55cc0b8c6e399a5aebd2105605393269cf8a242377bae341997dfc1272f9149f56e20c34b228ebfe7c16d5ae212faddb26e8ca9368a58039a9d07129f3894d0e5fa605d8b8393cadaa59ed7f34ea5ec7ed6f2651551f60ac835f5d5ba868d4b5d950bbf75f21de5c24b1df3c2ed05d5c50759c6667a2b2372380857982d0e07908108dea7699fd76a77aa51cf7b409ed187158be06b859d7caca09bca15ca0d2e12944f2845e3ab735c66f5ac9cf67a2d01e558d7098efc66d242fce2a2b86b69826d22e3eba06132c818b3c957f64220a4d64d1fd00b3d6cbfd04773f9827afaee8a42e893f10c57152db89d58a6e05b037370aa6593ff615cd60086016a1ab01e199cc6e4177f122e90baa97af64c47de10036cdf0deb0f63171034da234625455bbc5ecd40ec3f2132e8456441b38f4ae7a1bdcefe3d10f6dc0811830a07a35de1328c057d71609ee437a3995072e2cea329844fe150ce5ecac30a0ad665ffda852356006773cd94a2e8c2be03906b25b2aaaf7b62d29a4fb8cf2266131a6f8335452841e212a1c96401d6ab6d00a91c7af5970293f103fbaa091a0923e00d463ce41b2c6927b37191a51e1f12a7fa05d10a2ed09d90f16384cf3c845d6dfa64e70d9e40b1fa0ce64cf2ae5613a6c73ca5552f46f246a459b30bb84603673ef3630b79609f75574bfb0bbedf89fc827a0d81eb02fa0306ef05d0fcf5e5f30b8427cfa6b884b6fe5ef1a54eed12d9e362648c45c74507b3959814c591d5f9fbd1a9893d49e6a606f25a8dd91c261c25c5ae958c1d396cbf65b149b71fd053b2a180c9bda7d5211f89ff990605d9cc936db299371476fa9e4622cebd624c9ed3175f822a2c4a9e5a1be8265f175e4218fbec719a22161aa51637b5182c11053dde2e28641e35704ad82268e58c587d9d47d2d2f4dc96d0a1042a84e9b597c897bd8c11166105a5c36ae38f6df77ba360e2a687d75fb78ae1c31f8c3fc648babeb067298cb95673a6fc5955e204008294658a4da2875e60102faaf3151536a48052801e3d99b256576cd03d9fbe64d58c4a4984917a5e8e8e009d28e4f1b05ddb858c471aedc2c3ee97d019bc765059bb231c5de0cf74ff4a56e1048c2ae9d531c0be97b9e7a1de03e0acc423c61e98b38087094871c347a430d08bfa525c133b97d10685871954ed58316fc550310a2136899f69e7f5ecf510134f23a22980737873088d1d0d5f40ca2b903d11299e49a3888d88c7ad7546572199c9933b74c56b4145a18044f62b46735c7845cd0092201b46c2ef0f8d93196fa70d985ccd6441ea723a1e00f23833792526d2b616a6ffd7a9645a95708740059f44251ea6e573f1a3384a853cb7ec37d5a1b6dff0bcdaa62722750997d5ebba206e759b1b64af15fa5f2e7bf4d2782a410cd23b64c4aa94adf44589229d7e0ae4657d0f448e2069d87af9bd63f65db53c8810110bd61f2c52ef6b88448a3acdb6b27bcea034fc595844a2e3ec7477f02ec5bdb336fc72ab7d8edcd6e1c1834df1adcba2ce00429f819b99a27c3378d4a28b21e481c92cbe8a84c663213ac08cedb001883709865102b36c311bf3630c78121fc6d915d25e593a1af70cdd2106943754e08283c037fe4506f1df8d0a12904edb0236370da2892ebad589d5849e025c99dbcc2f4e3b70679d59de4c3cd565112462e9c9c4ea75cb50d4b3616abf723c3788f9dc98db9d9e499f7ed74917a907597928bc01ca192a7eb4b020a4085424d2a00799c6662996a5db5bc3cfe7d9f095343fbb1ad1efde7397293fd93207c50222eed52743f35eed54e15e258d9e0666418d75b2ada4ed72bf61d21e888d9427b1d187623e9099ffbafb3fd2167f14a7047a83f491ee154d73642fccdca709ad58f62e116885cb932de906efa9b8ce0074c7c8e5fd8f12380abeb53b7aaf3f83c8e3810231d2480b5cf16b3cc09443226803e03731dd7807071f9970358f587e8709a30ddb56bd0516fd83573f871201954f5c1fc3be9117b70b2429b58430a2a3135af2c965ac6a27fb374602032bd10788e2ec3d8f8c996d349f02fc431e2d2cbf0f7766c0a7678d6676120b0c0d1d93d389d346bd66943370b167122ec782557a30b86a149c5e8a21e1c24f2ea14a5c857580321f4d6db23f46303c6cec95256fd44136fb23422aac838b49293af36bb35ef49722b04a4b58787a44ed71269a1991c023c6b4146648170f5119d10fb554f2b8fcc06cc30ac406b63a7441522be171668da5e51861dd9ab4dcd84ae180d59ecc56d6b38271b146c68d87eb71a9f721803aaff1f2a9cd16b438aa291fc2a106a61bbc4a4b64d89444a182e1d558e63f871add0323c345a901c551f8bc070cd03467c8fb5a12fb20245261293bce3e0108ce3739c70e829774fde929d745e12be66ebded1c845c5ecf0109c221a2aa818fc2318ee047144bb2ada4567144a59ecbe84d62f20722cc6d49755549f7c9904921da77073bb1fb690cff177a4f64b4b8f070b7e33f78f24009509eebfa6ec1e011ae8c9da239f5b2d6a07eb6fe8fc20e8c00aa7301b6b8df1ec639e44e460276aa28b2cb3b07cc259ec37b6e8cda0c8681dc5c90858f71a9474501ee81463521c49508cdc930d6d3689fa1af3417d736c9499507fe844a7b2ed8d10492c16c3bd444257ff8bad452774921752e1940d998f62604b25f02a4dda01fd0a9d6757c290c2f6889e953ee33db9886c1969d93deeb59a0afc0bccc8c16af7e14fc5870e5d77fb025c3c1473fa10447b9320248f396b471e1b7ded556f8a3cf704e0079f493ebff847f75b6a5664afe275984e9acd28f9bf584566e07c61ca610d7397b4e3fd3d690603e41fca33deed5fa11b0c81b6ec739b2a9eb2d0ad661ea73c7b60a19a9cd3c11234b05efb4d3b84d12558dffc160c7b91c493eab2ffa491fe13f4e2228a6d67130e2675cf22948a487a2998405170895cff3191e71b414ef56b251140bd74b213b69525338dd1eaa473868c8896486ac22da9972f7e8989c0a97668975f035aed1e0b979c49225eeda4819391fdaf1e08be107245b3a8c85763b63ddf300d4910ade0df6d0bd189fda662e9805d7cdd2a2a5946061ec3aaebb776d20d3ccea90d41794bae3f12f06f23477872ce2b60dc9ae298f430ed793bce29dcc321a16b15848c3aa3ffc06ce3cf67380af3fb57b939e49418307e99e2033b249ad7502f029f1418935c43f4d594cf0ea55f494b1d675b6d523592a10789d93dac530cba38adf1491e08a6c9defc7c942ebf4a2221901bfb65d7faaedbcfc41dae4699a9288e03a63c58f89bd3c8feb2faa6e80fb27d1796fd108933f891d97b51212a0d7775481cec68ea53c92faa92796c04fc05981dcad3783146e82edc313263dfe51dbf0c4c308d6ac51117c3ca6f248fff33f37bd2c1028b29f4e8fea94f215679d57bf069e74214720b133998db13b0c0ba8045598f3bcef0f7acdefddde66316d02d1d1ad836fa4e51769406a757b679772817ad91454ee2b2edd5de66dbbd56dad37256a69d8cb0a40389780c8b118ed19b2e08417f5374abbeb6de296cb860a722be8729351934a24083c9971eed428ade4ba1f304fe3753b538ff701750f7e078256deb7ff4ab347200bedfaee4c55603d4413b4c201f5d213389e0bde43ec256de2a36ece4b5259f22cc44c2db5a2e6cc10a8a383745b5e8e4d57fdf8dcfd092edd1e2b2d30b2b778945a883253fe9bc6e58986931507a756dacb80c3fa0f34f53b056b87ac91f6185af5bca1e9efd8964ae89efebc5871c21b375142bbb5dafb92da457aa8ca17d42e11f9469f82d76a40acd73af52f110754979f0533e40aed607464302384f9f377aa3e426687c94b6d1a9ae86063b9284606d1d9b75bec420a5b3c96256a1a475196fe0b998e7dc191efd82ed295be56993a1312da58ba45238aee2f8a0162d537b87fe9a03e21fd7dccc48613deba6cc8f6459f2e2a62c06f5a171a1e4f814fa4e9ca070f2c26bc1fdef299aa68b296e7f9220ebb6b8c1d6299fb864570e45a9788244928f02abbc6a8dfe41b207df010a58319f2ceb94fab112ad1a2deaaa3179c3e202c7a5464b840c749a47b9c71f5830885355783ed2fc9bc9fd4e4879034128892433ca55242a899fcf7c9974568ed3b47a2e40c1bb0477fde1d4f029193f992b23a82e21d30f3ca37a5a2b6be272d770facb857a5cb36778f27ad7eaf3e46c0b5c64c404675ce51145abdfdc83a1513c8d40c0d21ff8e4d3dfd7f6481193aab2a3015f600172f22d023da2eb40ba42cad20c0db22601c5474393f2637360900f6a5746c929f8bad57bc4acf4936bebb222ba280abb13dc80eaf71cd9de9cc2ac0c9dcf056943e571d3ef9b45a0dd73785ade347f6047c82357c864e4b126eaa942be13d3c7f39098ced5b5b056e8080f722656ba9030a4c9ec3436fb41a602fd88683d10a626a36e1fba69ae3e44747b6d47b25b54747c9ae92b42c5150e85abf029c7dccdfb703571af8e93108237eae9849196f89c57eaec122565fb6a476b676641aabbb53eba116d62a12187393878066fb97eef6db5204812f30f7015e9549fe8f10034e4ca10107435531159f25d432005417cb6eaa7feebab596004177b2cfc72d328186abf359fd260e211633c1595c392bf537461b4756aaff087a3fe4952f7cef9736ca871fde9858f9457af143de1d2dbfc00dc54f0cfce5ccee4de0465b03361dba00d42e2ee61391356aa06001d8dfa4b060d679fd30e46338e5045ace7d0ec6aa634316e37073f2c884969da5e75e0e7a51e277b44323e0484f84a6ceb1b786ba4070fb9d6a0c11f5ca842c4cbf6fd998b21083d39efc4fdb783b806739dd6375a1b6a09b69b1b0543a8d43642aa902bc7b6528534d19c0b2615174892f1669b2198098ea61fb7571899b25ff8b2bbf6f12ae7fd31819e0ac3001d3a9dc4ca78f4db3e038e58f46d977561cf6c5091299232541fabf355db021f6646fb880f761806151900361934856acb368ad1c8f39e78883a4839b20c2582ba37e82434371bdcd23a5e201faf8b0ade3b093056111ea6c4187894c31dc4c189bfe9a1cc51e14573aa81fe4c8cb4c58bc34eba14b92af302b4faca3ab5be1d6e2d4caf78edc53321aeca27830b6909d1b7df202be934ce9a73682bbd98bb5c6b6630f88335df65d52770378cdf5a4769c960abb5853c502599174e11c7b8c83d1998b893bc3ab2ddbc06c9d0c51714bba40f67643ddce8e6e900a29aab05597d78974ed44a0d22c5c3af6718b2252149bae38e2e17d215000ee8cbd48cff496839eeb639415d7e650763ec44c23d73e9d1eb8b65c07e3aa63e5e259eb3899ad8b4d87009a104f4419e362c92d175a72695c0afb55287149c8792c9e85eb0d7cb7c2345bf17f3db8a9bec23f81f91d0f5dcefe035f48d3ef0e71da59b568ebb01962ea59aee6bdc751ffc505564a129a95fd1b852ecd55f75de22512818f121fead8ebb61bcfcb8b5949c1425f4e4ad737e6a6f48eec26075b2b4a0d2af1cc9f018535088fe11b64bba84b9be57a4c008273686f7cb43a841e7f83ebfc355ef2c44f677b4e457eda4189ef881c359c57bfbb41d04151e4385fe8ed1e345e2c2b876239829d10b6e3d4ed9ab6faf46204e20cd0bd06117bf6ea6752457bad5cdb381e49b8904f7628c7b5a2093916718ad1d1a3539d97ddde34d8592d80cc089befaa1389236aaa818b7b353839bebb7292361095fa327956869056f6a0fc1c19d4013f54e143354f907d747717c6aa2049c6ede203e3a68ad87514b89e84d02be136275d5a254e49daf756b7f36b44571fb69999ea48df247fe382df0f32f0e9028cb7320d2caf5553fb943726e24f184afbfd96b8bcecb974b041b5ba216c20145d57ad3ae144b776bc8eccf1fa4221c247a2dc805b60c4f070184e555dc9ae781fb92717a6bd460d34f0bd6b3d0f550d7c916ac9843c749777bac3cef3200d7fbb3811723581f402ef8828473c086c10679253f2d029bc5579d2bae33146653a427e4be8858f1eeb02374c600345542a4784b2f52d3f3cd7b641312cb1d24286120a05aeddc29907c9fa07c51035a7f0a888ca2ab15649f1f8d2a4d132ceade4a47f2badbeffdf04074b6a83b6970a425e2bfeabfe891c2079b8229472e0ae232306740e17a73a727cdc6bf296569baf5a94f778a1f4a977b505c9aaed9395edc65dc97ff0a8a8d86dd65e26ab92f488d9788c601866a7753a72f947cf5ed0f5c58144d6fc16f64efab6724d13c9df075fe8bb4a2d47f8c814c079a7e022d4e05797194cf0bf2360c2f8cd8f54dd2d94b5e9f18c8490c6a117db7f2b0608eaee6373137183e21b7fc6de85554e41f72fc181d87b1ff96563a6064669d9fcef1f4ce56e15353b6fce89650eb8978201496e507674f8129b4aa3dd2a5590823cb378007db1237230a7c394f1f970b856178bd76515813014a5b572b27e8f69dc0f33e7f14466ebc9c7b4b79ac03b0ffc8de26336687ea5e58b2a1edda0f3e535795311dd9afb9f2352be981876cf6e2deed4b25c0562deaca7365ef8e2345ed2f88c6ba2a020788b88b66867da4541262b33241b9e21a08f5735a06910b84e12bcaf71839b4fe0bed5d282d0d90ae006f98c22829aca3c8a0ca415977c95ef29aba146b399f374b3a57d50000ddebf9dc64c0ea3ccafb02f915c6168ba4540248207373a4a5e35598836a9ed3ee568127782909817e1f84bd12c20fdd8bcc23d733831f7ce4fb01ed71a145c62955f9cbfa757279423341a7278923cbfa8c7ee1659369f7e68846fbade973014e29063f6ced8ff001567aa9e43a8ea10e2cbb8a77c3fc2fdcc607b921a30aacd0ca982534ff02ad0fd757c188606b7e47d4b44123fa49272361bf890ab53ed37db2eee60907b97d5019ba6052a69c86a116426245ad8adaa7f2a73ddbab3266da9ced9f4b56404c93b637801f65b63357ccc9586bc72eb76ddb1677746026de8573348e9e5d40bfbcffea92f48cdc5719d14209d7608ae40f3e24d9792a16e2d9b02aff84b93b456e263f9fb7b7fb551d445f783794c44bc0a8be5ed0f7eb10b52b16e05230d4ff8c1e070d8cece75105b6698ae0ec93479cc374ed5eecd912bae1edd1dba70953c1c5a5c2b6d4e9af2fe062cffb763f4b3a7765b139484d939dba27f1980881744ca568e7ddb130af3d4c8b27032c395ad0706035e954d2a421debfc5860ba2e8a9a4d1ee9c1749f5be95fda942d38c9a0f88077eb05c028524dc9d64cc552bd15183dcf72297c667e0e46f5e287f03d109ada9e8cd481b4de472136086d24d220afda56829dd25cb6466f19eddcbc0e058bbadfa5d1970e5c02deb1f1b80a8f139cf3766480687e274423f0b9ff290a119063c01bac05d072d8cb90eaa5f60318b9b9af8cd8fe0a73ed07d549274b153786999b4e9b7d8e4dfd3345737ca8af73163f6f3785e0f9f9a0633a44aafaabd3a07388bc0bc66264e9cf0fedecfbad4cd77dc9a4a205fa2e9052127ef572e16eab95ca1516564be293979bfd2b9bedb81db8b90a56ea4e77be966a49aa20f3e1a65bb86ac65e5d65ccc1e87404a353d785ea282d213ab2b8997998ae6f08fbe211f608627c243ecda2a15cfdbb5587f717aba31127d166e962ec5d4061c397f5711bbc5855b8bc0135e244a7ea6b49e1654eeffe9c5c64e9f84b4e9c8f51f3651cec312f19a05ab05b8d40812c12c3aa6fa7868727905b155a0174a25cb782fc2870f48ac5b39535a89c6acfd5346a20dc1af8492c8457fa12f126ea72903460ee5d94abd7df8fe033dd7968762ae251151cf95fbc1bfaa55332ca6071c2d0ece40642b9c8fe8abecfa4a137c7650a0dbb5d8c64d51bc67c82c679b2f3f90be57b1e5e690f6dddb8dc0535bb7947a451345f3f3f82fc7abcdf30c1edff5569fc0d4b90f1c28cd66573b39aca2a37da1723e47773901b3b0c164f75901dd1e20308d92c1ebe3862d03429e8763c39919bff81ae1f52bc2843e38069dd5fb98fb065d6e2a990e1733f11efdb4f1e0306bd4efc323471785bb3b74443e3fd6ee377f42e79c7de69aacfe0848fdb7347b302abcb1b2204b8aabdd1e22a9c11ee895f8fed03ad508de82d3edaf5d11f53e59354a36ae3aa71f94eb68729b5fe786d5e0ea0f613269b9d32aa2a199a75f1b2b9e5f667fa34e2cf0d836f3f1e1eab461cb0c057da5be41a5fb57e3c5666a0240092adf778a84e2fc7bb827290c46c06f3a31ced8a1e478a5d27e939c85c1f37f233c50f3bb5874804454cc93db424f314b3814e1172b58f797852332c5ae54b4dcdd89e1956804f2942c94cf434c2d34b87249d2991d00fa3cf1a24ce64210fada8145bd9adcbb7c7cc2c32642da89c509fc9bf9fc587e713905339c1eb333c23057d9d18e5978fde36150d120437cdb591565065f70c44e871a523a6a186b4d4b08a47fc4dcb5811a106eec177018b5326d9e8804ac16dd2beca3b0a79f1fdbbac88a293d2692d9eb5cf3fa54c14b2063583452f1e70881c21643035fa9a5f29806e721b723661517f05f74586b01c4e61f7b2be35bd8f2e811b12b3da0ad9d43fe840f1d611d9c166b1b3ed28d9be2e984be5942bd66c1fcad1c45788e9bc916945597914ccb824bf873b1f3a62e866d23186142956eb72c00f119527aec7196a46deed64d341c080bfeb2feee024772a36cb446efa01389f2ee991a88d611cc98977f6cf43e79acc204d30ae2ed45b723d48cef34612cd2a5c72d423da479ac130c69901a56159af0b40cfaceccaac5a047f79d2509bd71ef016649f7d9a244802b206c6022084c286dd7a8b27b49517b3ffdfb00bed791c1fb1494fdc24cc56c60a83d820e99e80164aa7dd8e524a975cc5955492b18bb92444146b08f9f3794dd70f62f313ccf19e06a38898eaf68a45a207220549252e02de9b9ff54bba12beb7aa21a3c67b1c9a34c486445b72a1813c855ecbeec23c0b04a5358626423cf405f76e221c0c0aa0e3020ada3dcdee4c57a1ab07e9bfb236577263fa713b82052695868f651545c5d7fe6e6a2448c1a7021e1632fd1b253bf2789bbff356b95b7b64cd8a6f035dffc2d6563a7d07a9b3848ae0caea5a041a2a0546c93db82ea211532466d040fea47c1a62676488f3fe4ffd0845bbd2d9ee27b699c2e6490fd9d7f91dc99f3f3ebe9ea2996d880c8d85b670231d12b38a07555e00533ce873f3f2a32222094f37b3a67eb233737bf56da35b9bc5eba1aa2c438675d4bf180a44881a2bcf2165b1e915a383cc163be87ee1d74b1470d4e824e5df90a04d1842c189e42db8751dd6d6a39cbba183bcf281a2071ab3e26dcd5ca8f577d77d68517d86853eeaa7da8bd508a86f17e8c7dd700c856c672857737f6e3415aee0073cb154b74e0278a0f0a37e6c3db5a599d559021de87f8c28c87dae2815a621aafacb2f51370cd2578a8ba883383cf9c7d2a551dd8bfb6ae87b7c16f7c48a8c86bd7222c58fc05d2779358a5df28bf9c9e20a2ff4a103a1fef536cb714c5cb44b315cd88ccee90877c1ea962918d3df4bca2728a252cd274f78094355e5c71cdef71adc84f3abfd2a3d88e73499e327f35d2aa0566838e070dbd6059ab7c6d58a7708b58e6501e89169cc6211fa96b9225667f07079ae2f98190db52588221d2129d2a281917af5ffffcd80232fe780baed05c2c155321c8575935d808883054f1dfe5c5a78773132c0a5ddc6d9a6496c0a341414ca998ec8fd2921ff45d249f4798ae8efe47177ffd851f5c8cfb1d5132468733e648b3006474d845b1b165b7cd087cb824d9869d686a38d68611e50b9e558892f38bc769101d8ffa9f495cf6af87abe77b61f9da36928f991782e71839a9616261f87f3ab6917852e92806429272d0a77084423feed7b487514856d6f7671c21f0852b80dda1d8a88786feb6fd3dc3809725e92e585d61853b17da142c6b1b34e7e7aa3b99e70e7031cee088d16dbddb976278e6616a3b3416cd42bca0e754fcb73fd908c85dc44a3681417f010c03c483f914f5e94f3e92ba490334a9cc8152cbe3f245ebdbaa141c02d041f0d48a211593ddadcb60df8525dd6890ca12c46fb2cc0f612aa4cf760892b96f2b35422523fee285b2e54a7c636dfb15882890fd10ab7cbb73c06ec491e62f60dc3edbfbc2026ea4040bdc696dc33be4b1e2468c389bd7aaa934b0320489f3d009f35aba59ee88ce3dccb6fac4c5d2813ff7c2c80f9249389763a15cacb9c427ec76f9be4f180dee82459d0a509e054a41ce4f0cc642ccf8107eec08827df2d3b791a6ceb4bad43802aee67decc1335fdf9390da70cb8087a18da23e949430b84d9d247c37a6db7fb1d9c34a87f1145de5c9b783696f4c7e2da3f83b3131514222d610b5db760802b3185db2f5154c80cc97aa3e47536678cd081c6990d963288ca27bdb6f9e38222c312ca7543b45a6fb6daf6aac16d9840aa7fea84fa5d087c13f890aacb0db1cc6f14db59c73d9c79165e6303d82fa11932681066b434f90bdd955ba688f32f1eb28f2b759b52719ea47fa405f174ac559d4b4df3466adc5d2251dd26f5dddd9ecffa9dd84f067f3a83c089efb56541f6d0bf114a4a84ced3cedcc878768662b21a07630c70cfaae4d6457b13085651977c7718ba6fd9a049b1032b6e39dc55c769c21aeef402aaa1267d19aabadefc844a7c7633108a4d37188fcc9b64c0ed5b52ecced7b421d46e21b840cb28595f6f166829582bb293bb24b682c89003b6d4900184bb5521de58095ac6518cd49447c8936ee754908b32f9696c9aae4408aa51647ee0ad5e47cbf62a82c50a3fb6b85ea09beeaab63c6c9bf1a7904528274411351ec85c5c2f5dc164109dfec5cfe149f49f452c5c03875c63fe41732e354c98d29c34e2d1d1b07e55a4b799705e65aa5d485a6992f5d0250bbec7e60344ea0d8516df48adcd65b050690574b0cf98225130af910311dec437960fbef5a7b3892b0198eab0b9bd3ca7de4c1fee3449c3b7d4f229f488c6a0e6758de81d908c671bf41aab104b185a71e5aba657d37303025085a59fe8316c7d03a235e887b7d90b7c15cb30447b8f471f1cfa089303fa5402caccc0818e6e552bca0994a3054d4df2f1a411d183eb151e987323329b09539ff03c97256f8b4108b9a0567de542d4cebae516fb26e594f8bdde89f065421dbba8afceb555a0607943912bf6bbcf0bf34bea424438594fc69edaa8117616e3d1fcb874ce3faa6d6eb77aed45fff70ce4a95494a3ac1ece33efa1c9550827d6896cb5e03c3fd14038f7688f877d990e5c603738ae19165cf664c153969675272de328fd5d0ea485f068e62a2772a52923172ef98d406d429b8a4e1ea550e9bd293f0d76bf90e0b1bf18410ced1984d79b56c0b2ef710bb94d89c26c81310f25aa569493295a15393ba67eb6e98b5af13090d4be2f1f154f23ac2b273a6c93b28c610cb05b41f94f9ba2182ec1c623ef4e340ee4595e41dde55859cd82d65a68f458836042ec6d3d58b3ce8b56e40ba9a6274f53b71ac35f8fd22f8ba01fffb5735258c3e7ffff5ae281bd96e6ef09d97896408cd382472809747959a809e21caffb0a8d7f02b674e905940b8f09f85b024d9f1402528eeae6594ccd5f9b53b3c8b88e68c923c9c7fb5f5bd596e0117ed0147d4047c7aebd4648e79bea58c6626ea376bcb141e66f00d271bace6214b30bb0ea35d0ac898b6710ed242c5eb9053fe83e56ffbd5c705ea30bc1a5853a762ba40264ec4227fb6755c4d8c37bde08befa4014f317f3d09607a7d478a370812fe","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
