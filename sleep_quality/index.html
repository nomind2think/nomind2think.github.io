<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"340b7529759619e5088445740f2aaf146f7024c044aa09bd71c7887c041a2992caeb71a81829e31713f9473b739445b2e0ec4a904bc8288fc59bcc675d4ccefab1da81d91d63b7f021995bdecb1c61fa7a22126ced48cf1519e44c0958e59e7dbdf6ac488f222e2eb03f2465d0d5d209a46cd65ef825ed19679c2b88bf233fe895107cf3f1ac3673fea2cce711e67faca5d538dbed7879cb07a88041cdb7418d3c81a8aa0a338bec56e1f497b3c06bb88866fc505cdfe6ce2073a0e48ac432abd7bdde4b21c8966d556cddabbec4920697f6742f614a19a61aa09c768b9bc56d4da0452353a104f5f54bd7c53429f3774c48c3e480f96b06fc1f0ce89c5bc069e034222ffb5475a72b820fea6eae10be314c0559d0ec477f9e8c99ff6dd31c22801051b73045a3cd1663a59b8c820c5f2d8a910dc5a9bae6df1c14da335e407d40b68d2779f9814c2d022817b034c77bb429f76940c1cc5a5f139c31a2b97b40e05dd9b3e3b70aef95a31d04ea313e783e9be9556f60412981790f6ba94dd8b89ae75d53e2ee1beb09203d1f49ad3e8e14dc552c4dbc82cb43f79ae63f0e848ef1756e2c68e7794a5e0eae81d8567d1dc65bbbbc417b33f5802692ed239444d51ffd9214e6a710734b1b23b82b04cef7c73240e60db82d60915de16403f8eb951f5c70ca2c14a46632323f3e62630e982c14c82cfd2c75ab3f1982edc00ac2efa70a1bf612e02d083fc317435b8502068bb027ad8c99e10caea9bc72ae6cae955ee12b5ff0d85ce3939e4cc98696894606af23d47c6325c3e26391bba83b878c60230c80a1c22dcfb12090e836a3872f821ed569727bf62ae4dba8e23a98e50d760887acc55acdbfda22ffb9af7ed99e0df15a5b4a9676759369d8e2cd94124d5376f61131bb772f4dcb541f95f81da01b16efc3665277c8756a7858272341804b626c152fa393ac0ea963af3bfd43b1c32e65a62127d24f395e002eb37a3951b691fbf2f9f5ab0cd27826426e1df607ec15ef4be9c33650350d66b6504c07eef6b32cfbc2b02f32e8fd3741cc6362d4419f68626ec39a95f5a44b79685d320138c2f218372415e20eb4358c9bf807d9b4d413b79f6aecfed52a870d7c1d808c4724e289ee3c1ce68360dc60fe51b581f7b49577f12bd728319b9281c16b3bc6c310c8175d54af83341c968cb07106e593d69fda023246731559bc9850014529148a4c2d62e90204063244b783ff1f1b229f469333b405718badeb7c464671f7cc0a919d6b83f4917390943e401b8613e01e54a76c403fbfb5b01ebbc4d4308672afb3741a9e0987e10ac05f8d493f911b7fc8a36abe2f11b4c742601db97b4ee1291bd58d3076122a298f34a40ae8c74c58b015f83b4711eda211382cea5b46cd8735f78e4f12961da04706ba4b30d50668714a8449970fb5cdf6afd9738cc8039ca9e2116634a4506875340910b9296620cbca5d3c5c3da29e8afe99c6eedfb004fbdb5e70f6b7b90613a5b49619b5e981a003a6d78579e95fc22b846d9cfffda8d8bd24f7f6cf6c9fe4240fe1d357abad859d649e5bfb612fa9b69ad67d4ef917b71123bb3a66cbfc711f1b14b7e5c5498b93c6733d027746ca3af9b2ee04c21e40f6fe67b18163561b8a4ec7fbb2c9031c878f55392143db4a7e5e8ef8d5f5d8497868b2096d36c97a67dcdede13a69456e9c45b5373f9c2d043d14f81fc00a53776d511bdb28933d5c0cebf5182b8d1bd1f5b9a39af8218a9d943d177d0a26461d74ff133a0db33b0407bab6c2c5cf079c5ad9b4b63701d31e4fbf41775a031aa060971f597cab3edcda061aa73c64a09ce4fa2ddf1ec680e5449ca54e611a8b75d26d8d20f286a142819841925e7c307a41e8a884d590d76d3b2f56a85d324323608e1eb21448b753ee3b745044473f098c1f80d5fdc8d67b25177d610f54f2ad5be338dee86a1a484b0596c7af667123848443421e61387bc78b8e32ce3f9efcc4e4bae6fcd9ee3001df5c8d54e35645d6ecfce56a3f9591e33405421cc128d7bbcde0ea4088270fb24afa4ca6e30dd10f8d7e0cbc7e3b762a750c065e2a3337bce1a4d7b382f13b6f4128c0def5df276154a8806d8c960b3536f0244ae961ae41440ddeeddbb9081abe826d93554f85efd1b509fe1bc58b9f33ad42f1b52b23daa7a282d15283fe368ecc655648dfa69098736cfa50801f42ddab03a119ef395a80960cddb9f60d6a07d58a744859c0dc42fbc8a0526587b764178b45bec8a3690a6f57d064b57f3fb7d2435787cae3ae77cadcc474330516b8779b0126201412f390c60e91db1d7e1df3c6eb01be98e0795cbae147c6a4c9fd326056e1fa5d1624e809cdedd3eee985baff255d2968153a919bbe51a32535977f5bb18d60364bf960abb158cf2d32844ac95e4f17e43970b8b653ba53340ecb106251c20885d92bf43a79434ebdb0970e3207c2d794881927895e96cc8ffd3b7ed40a970fd8d70260d49a48fe1dd4e495bc98f31dcd5b297d4ffd7d9843895e085436e17a6a70bef223dcbb9f6763306e7c51ec3136abf8ed6d230745a706baee89cadb3b7580e97044500fda303420c0ed3c711e51eec916fe1db41b5ca6227c252dcf959aaac6bc520458c966393c1c639d2cf5a5e6d54bc93ab43bc05d8782b1e8bfc0c52b04058ffa13cf99396ce2e87416f43fa5583e9fcd741f2d03d22c4382793a2f2cf4f198e0061c89f6fdc9d46a3008b581332871eb798d2667a4c1563e6971e327e4151cbf77bcd0e319124bd4b6dd9ffd434f10a2aeb0432954fe9f6d57a3859c7a80a69dc4d73b05b0a6018bf99d1463931e3b2d0e576dc3d3bf088d425e8fb975f1c51c682e5e3f91fd319a7440bd50b58a258cc5efdb19f2a1755211102c1213c04500c819e703bc96b3808c2f2be8bdb5f3db21c18fd1cbc9bc96631dfcbfecfaf0af926e8009d911da186e8ab482d2547d7f829c09b8e394c87ec7858514eecb015591721866a7070b79a5ca93760eb0937d0b5a653deea872bac9654c0415dd793ba791a237d88f411d098e94e305af5aa5980895975e4c57c117c11539ce6b6615a21b1f0e5009a2ed59e8be2f41306c110433ef7fd2e7cf97bac05eba538df55db48b14a20944526f2b338c19e2be8cee8ed1a30f9fd72d431ae0fe92283b64e5b9da6d43949ffa5b2972247abbc2669a87dac9f512654a3e200a9d3858970ec12ff13fea44a3e26973dab0394b49423c10afa8ced6a691b4954578e386235c9ba787ab29c4100a6dfeb2ecccebe45fa0a348949fd97e6064b4c6f4a486d67507c60ca9143d29024751e04c9933ff770497f27002a8887282aa1805c55336a64405fdeeecc6ea9f7214a790930486fe9af0d08c4b1777a05a54a93b7d538e66f26a455e0e8ec58c1ff87ee2864d2c28ae3b38521b102fe464af9787146c1b4f37b50ee6a0fb7b4ba1c882887157ab6b1d0dc82d3d9ab1ee3c09b68bf9e0ec92b8a23bd1fe1492390b7903f812d8698fa349840da21af0c0b9ace0504e3a4ebd52efbff9c9b7e40976e463b1afd8482cde310e452e0d022c1e637f3a299d69b17a862af0968a1a40b364f505439e8a178625787bb58774f119f8c9a824e924c7e0e73bbb58383a0958ea7dbe50c49c5aa53e9624a17cc1a65a9c87bfc7a0b49e67aca80d276b1ab7d2aa8eaf834b5ca577a8a3e4c3f6f669bd0610b25ed471a9012a6e6260824ded437e4bae2702e55a27bebb6dadd217c67d87bb9fd68322783f68fc68b41e35865c0780d88f457daa77083533aef35a799607a7d57e17a20d789a4bae73e37b100c6e03bd3e53f6e6953fb2e4113e1eaff575f3237c519e2f4c1aeddfad67d2017da5edf43444c759f0edc0584c4dbe3337626d7a054af78e9e561fcc5a9236013c112ab7e223ee88f0db88da198144da203a289c2ba14603b0bcdfef11d3b8b5727bb80c42e93fe848123a00080093b1b0457e34e39a83a481f8928435b341df1b24c73c982bfaf4d4773806b320143d7564af5dbaaab77de861a017b210a9601a0f3cfe6199e14537fe6c6b5734c9f10feac4beb1e9f8155cd4d6357536fc06c3065efd274cdc1dbe103dc2901d4a9ddbf697e7e3e9d0517e633d627b615634e242335f7998579c81d21e29af8ac81e4906c1d0f14b27d48233e4e8e1648528eba88947d82ab78afc79e3a0601d70adc017da5e2624fc3c12d961579ab88f9eedc616f38340dc64a1667ae5a11ce9e8b47b363e3e4e5edb28963939e869b40a1bdc667d0ff2033d8d55c31da91cfc44a4b0a4d9f745cf0cfbdbc86508642cdafb2656bb6f7c4b7eb03f5c05e26ddcb0b23b1552491d5801813d1f3aaa9f3f3101d9d9d574c79214dd56b2b728d95769c7081a62b1ca52fdc3a8417f186e3b5f0bfda4b3c08751aad08f61e5b40c044cd1568ccb192c298fc4ced9541c412ab673392586fdaadc4f7fd1da44a08ad76e3f72beb022d031b82a05b589c6a6527477844889709a50f2c65682905f007bd50c1180a4f1d67fe00eb55a89067fb245c08b004af2084f54c3b8eece5fbffddabacdae4b7e10d55244d19f6797bb03163039a07fc093c2665d8c510777d751b522529f1697389482fbc5b4deba7071b6dd08cdc9218a273b7fea4f0dc25745c3f724f7a178d4dee407441a92727aa284e1b0ec4301d1d3527500091bdbea14b4be6ea301e46b843eb5f794ed47f5f146e23830a315ac42125f6345388cc39ad23101831fdef0a3c25d8d394e17db51a2281d112caee7def9d257ba89ed05fe439e5aef852ea5d2b025b35c92cffbc35997b94dc3d1d718089bac8efb7dc1cba95a72eb80a7152ce815d9dea44c2409d9ad92403d17661804ab5abfa68781a477c9eb87ef43b8ad70c50c7d3b3cf5342732bab81aa0e5088c98e2b6d0b9653ae1ced0fc3fe309f55b73574b823295c697db7b24d027c27f4cd1707c52bce089383de4d91234a988144776c4e93680566f08811c06ab241d090db5fe1b2f8a4f47e02027fe0466f5ae5473fbadc1ef1fd4d521e49458be6cc65b0acc5f8e8384111d6b4e0153a53271ae7609dd8332885ab328539bb9c077cc3915dc519e2f5347a2cecdf040bcc3d2c7a3a8ef27201c77106de97a31f65e4cf3a01289025cddc7bcfd920c4d804331a6289d38cb76097b605ee4103c809c567aca3d523e264517ca392c19c81ef5033a8004faf0773f269b83b4cdd61c3e9805cdaca408a83105b873d7da8dc2677dbe0903a8754c0812afa950ba52e24d55777fe93f95fb6a02f2b0d31c7103f654d0c8e12b9b8ef466f5ee6ccef9b977ac36bd7426f3daec1fb3d9ea969cf1e8f2df67e527ce313b307ca0af6bad29f39e8827d955b6169dce8febc91a60e74d7c6ad898c66dba2de5edaaddd3713688599db107d94aac9a09c61dc55694a18c88c4ee15a604a1a0968c860e381fd7e0c8a7215ae013be836e1464457ec854f846c32682a3cf9b2d00b91adf72c7147aac3443e330841e49aa8920d465d6a5fc4cef197d7acd2fcd01bf3d51795ab4391ed1b726f62306142c6e956c65f571a5e33b19fb293c933f710c9ae59334b6a59ba3ac9f9351a6392d7896caaa8f7eabfe6a42a697dc9c333c78062a70e4d7cee0f58cfc1c48a98793bdcd52e7d212f79bdf486fed45d2052e4c7db02df87570305b070a42cab071a56ac67184a4b2472dd4ca0a9855c513ef1719165e481958c69992782fa03c5319b81ebba38ffffebdd21549a5f0dea27b5d5d0edcaa879a925faf00af1633d8b1c427b567716f0d7ce19d4dd3da8a88bdda469f84f864534ef7e3309faf23ca7147823a9fd115dff63644c8f4f64b9ab777efdeca624100eb35fd0a1ba2d48a1f379eec9be93e4331772e2e38290e2e0ef5a455c4fe8d9864969454647f237d540833d327fc3a4e59056a99a01846eb8b8316cbd6e755f35d85521e022fa328e44dfae7b2f0119e3d82942c1702b9f8fe161695ba3c56dc0a4de060058a2514b218d9adf004c88805a6b570944895b6aeea8f7409a245c3d4c29b9ed11647e1bbcde2c41e0e82b1ca7a3d1a2baafa92278dde92417b6b0c0f435d0a62f3b71afb28badb86a7749f46b7ee5302ae19215190f9a5f2e4e94f6f278a62722127ba109a64e9ea1a1b819947c16ad7e46162b8e13063aa3fefd1a69456a85d035a09eb39046e75aca5303854a6c12d1bdd2c132caa9b999b9a9b206515af4c5b92c2eb084571500e6feba62bf79ed0185f570f0f6187b3f2e660281635a04a1ab7cdb780d9a780f3a9abc00e48fc04a4573d524dbb5bd4c54df7b5d0bd5f25d6f083acf22ac29e009a244d06fb4e0d5bfd12f71ff7aaadb97f019f066a0403e8a29b46f3e655194b5eb5410f8a664a275791f576775e16e48220f83aef807fb37120e2dcf785aef9632a5d6e5b3639ba6fa0677e2111ca3d6995a4cf8213c22f2d8a8c958ecc911a92752810327642b6fbbacab2c470607163d182ca92a735634491e77676cc59c80aea3cc4b85e6b7389ca74f273644deb177d72b8630bb02f8f76d2a5e747fee38a6557990b66a2debba25323fd357e210f06ab057f0c6a74d7b8ad13edd48b6b005bee640e9f18bbe2b9812826fe0714945e1b587aeb18384d318b688219b63b89d85d1f38f6d438866e074d5f09c47a9922bd46eb25fabfcd5eff0af642962898593fe6a3e446740d3f4652f2ec03b8f9cabe9b0372ec9ea03a4ae93149ce5b86b2ff8f2a2144a7f89abf62ed98b11fe99cb4791cacc83201aedc1455ec970f7012a7a714ee27cfe472e28b478cbff7489141315ff452158c545849deedfa849a4bb6b0d5ab4b580873ac4482cea8dbea5bcc6c843413ed936a1c5dd797956f941c4c213b77d72574c5a0a1cb75313e2e35ef8656e151bc9f43f5099739f9321e1ad23d9b76d50bd90eec281b845067e8e90537455b9f270ac6372a4e446a82ed3175b5d2f23fc658bffdae0fa28ed9b715e166ada19dec365c9461c12474ca8ae5e8a4d53425b9861688e6ab9e4181a47c9c46a8a69dcadb5900e67b772e2d9e45e7b9378fe8afdc32ee543d02b843c8323693c8198ebb803435928cbf4282400964b73d31ff7325839a30b5df59f360bbf38776d16be692aeb91edc4f5da1a771292bf569b3e9aa384d55210a55feb1576f347ad4332eabe21f531da77d17fa7a30013abd46ab7fb6b030ec1aa742025ca57fea4a055a09f28c80165868d8c5291299f17ff117a0c5102d67411d242a8018dfc8b088b20b523726d21891c20c17413ddf48d64b853477d110d79715291554d48c9cc42a9b8fb529f8087cd832b77f4dbb314c79c7039bd3b7d6abcf42efbc68af6c7acf39ee54e18e89ca26d5c8a4f47ccdfd7ec4aa015272f5fd9c25e3988daa4dacc86144de7430de9eb584c8aed30c5126129225a62591be46679d1fd7ea9edadf490cd645052185d989244a68a61298c4df0e69cf65244b116bc9ce3659453502348382d12ba99c9f376b574aa4d44e7a87e0f4b05597802bd16997698bd85c80031d8da5f7a4a49ed5dd24c424d133ef8b20e1c2431efbde998bc6671859525e28105de2ae93c0654f79a4b0973ad26808b79f6f7c283ef5930e85119c3a68f678619ae5dac326ce78a659524999c3bae2316a8f8eab187df5e3f8ea697733179ea94ffac73da5c5e3c8324a7a5e248f7a6478d23c2a9b799f9bc5c9ae99cb7a13ce8a8ef839daa0f985be40f9ad25bfed5f06ceafa22950a245346233d29ba976e93a4089f4e1352aea6f8170c1663b9854203b1de35009377a04fc53c2f6f6312b4956178f592aea14c468dc55b781f121b63ebb7f91d7c69d78e40367c4c42b7d848516da6f7272a2ee1e72303a8366a44890b365a3e87210eaf7a535197c59e8b69b21c1700908a0261eb57053c8a8d3a3b58d9409cda484d297e1188d07aafc3fa904ef51d1e02f779125857a8e33aaec0111c7708fa100b14b763c63985abbf2e9325c6a730b0cb7e359ee0fef54a5df1ac250bbf82910eccbdd3b4b7c34a91ef9c4218f90977e32eda6031c7bcdbc820c23b127b2433fba5e6e83111e933dc1514caec41cfc0c030303777e150bf7ba8044ddf1116ee95044bf5411bb772edae9e1ec2a68f7218151caaf3502d1a16973cac79eee5230911b9bb64e273664236238b693d7b7d59553c927706d6208b67fcafafe9ea97d41b37098a1d5384c657771fa9184d663839160f264f2d4ba2583a82cf75255576f70963176676750cc78760c6ed8d597ba2fc6215893981774b104543f92ed306dfc491fdadb348858045dd3af267f34353da062650eaf6a75cf0a53c28a0bee3b561ca2ab5b30707e0b9c9f31720a31c77111587e51d3f6caf55762e645c34e46f173e98e3d8d265546a3073d15144fba2721754857c0cd8f7111118a21cf3b91328c0ba864a96ceb4f0aebfd0728450394777a7101e2bbcd2852d6330792782960d73c309f687f4393611afb8a42e04d02da8414b1937c2f947a658f834eaacbe9e3d1c1beef97cc458c3af535b7bf2f2e0406f5ec32f1bac670bd0ccb7599f1c2b628d67816af380a98ed1db0908ed8f81051b38da1318ae574e053f306efdfdf2296ae2b3747c1d4d0da110a0a612ab3c78001ad34437f2b42822a5c97ac23ea1a98308c8d4e68361045f8a99aff2423cd8acf56834d82e059f31540018587e53eaa9c9bc771f6d6a39f9390661e9a2d999245acccf129f1c501a26eacb0bcbb8dc91c5f1af284f65c002897cc74de9534abde35ecc79f9dbfad7b26d6063f2f849f703d6d517793c113da557204de57be560d2c6c8a9f7f88c8e34d6c5dabc4ec3cc12115953f90cbd44256598919d031f0c25b1f1dd0e7b016eda5713781ba733691f1e1f2a0d66267adb869688843fe417141c4c049bc2d3bbdc5adc2ffcbf04ad37676528b8023e7786ef08636c08ae316847ab4a4800c22749471a0e16b027a33efbebe96f584ff17796a6f60641805aa95699e6c62da80ebb2027a281d3c33046a6dc70492154be715090b33041317ef6c18f5ed3be0881cfb5505374e98b0056dbb58a5c1d64fbadf288052c468cd9ec449dc200350337ae19383d5548f8df7b2140fa36120b5923ead233b02161427d236c64bea9f1f546d75920dc38cdce3840261c326b3f3ecafe66842df9f0c7fbe7638fa6a5a84694de98da212453086197bcc2c38b603bf81ba8e6181bf655cdb851244aa5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
