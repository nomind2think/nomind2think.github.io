<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"854addc000e4dc86073883d8727a30c54190475cacff46bf2e955abb7b8cd16b490f85b375d090bb0f2ed427056255637c7e1e284fd8f9c366e18100b66849f738ddf53f0d20ba0745a5ca5d7b9b4507965b73e18a477458716eb49110dd0adf14dbaf703a81d1e49069254acde854d2a807bc8301e41f2614a3fce8ace72c939f317150046839c675e149379cc7494aaeb49cf8e2ef24e1bd0a6bd8e7ae41e60664ff4db88524fcffadf3c3abad367e70c5a2e31e972d54e7dc5434217d3aea2fbe1f83677fdc69e3daa11b1bc50e1533744ea8f5ebf1bf95f0161b5700401cc868ba8d25eb86c7dfcf5d3d6d7da9c79eda3ca197cd1346863efa8405e2f8170eee5e1abe70028dbf445861675cf7817d1b11bda955d359b8e040920baf83cca01dd35648760fff448a77d2639fbf8ade30e64ff03d2f332d01a6794b20f4b9b25b506de2efaaa921188adb2826722085c752fb8de3a130330f321eae79bfac844404819fdadf28a4f4bc33a0062f65dc8abf3d1df1770e2753092c6bc81ab0766f55fcf86ea603a6b954b160c5d7583e102dfcbcd102d20eef9a0e2e958851a61da7e8ff5be6f928bd5d88954041c9d70a346cea93f84722349c07a176c7a422938116159933d712f06cb46e1ff1068f0721034f083943ee70249d4a14012eab97257b00552cda0352c1327cfad0c1f383ad608ac2367c41ba41db1a316e08ce27a063836188f99f84ea37bdeecd052113d5b40a716dc0fb7135bdb0783d82df98f6fc4a61b85eb64b5d33c015d9ca242a7f1916df24e198995d078bbe033019e15a96703d12552a426b33e1acdd8da2059efb8ae646023200e9eeb0a09a15c0560345fd5a827ee495733998ef76162f6ab0d2ce2941cb50f29cb5307b7dbf0ed83338e32c5b4fd4b657bd799c5d1a0467fc2835aeeba3a3017e7c7b67896578338e17c7518c4f5e6c0a0082d7263b88cacd4c3dfd1cd51b47be15f4be32ab94da40a5057555762b6fb4fe5dcd05dcb557307f6ae6af7f22241f0dc63eef9f49e72d9207676218a541f062208acedaa43cda125df75f7c33413f5ee41c0c8907a31745bc29395720a13ed6723bbcf8a5af6bda7f6d8ce41bf531a8e6146e084e9d1a949b0a105ea705700260552d8d4af4dbab58154256b91635101768a5f817948dd01d47c258e862f9835163549a5b8a5f1b8de6dfaf993f47dfb317b964a77847989120bc81b622d57a1685665bef10387fe5a1e0e911e97ff5668f07cc9bcc48911d35a174883453b8143fb72b49c8b02b5947b78268ef5a41f51fbb604b031972412348fe0b5e1f2cc5e32d49bf5bbe19b957ff0e32b0fcb4f168bca354e4c0b8a4e7ff24ac391383310a1ffff4973b005b5bafd4dc4d732f9abbbe6dcc2a962cc08b4c048a8d4d793cd68e6098887faa2e3aab4417df590750c7b5afe66f0418af72e9baa26f189e2eef24136ccc4f0cb7ae6846c55604892e04aca1daddc51d2ddd8bc0c5e4319fb38848075f6941365f0e006c58273f645defa7c5bf9d95c4e1bd821cdbf0c9d0b84f83057f128352891c7319e39f5fc43220f52c5deb03c40e0b4ce4e589d6d8b3dff1444617cd863c4aa32d2709085c30ac3a432121980db765634d34f7f01be9e40c98126a91974e0e3c59118c3f01ef5880d68ef9a4b88ae6dfdc1ab4b2d66aa343eb114ac47eba11560c2f718ae7e6bce78ba65281689fb12954b160164f5e5427274592a63f1a0c0d761ddad14b0e0e72b6f492349600da6f88f6ecf1e3055ea549f784807f7bf6fa9524630785193e863c6d7e31c5f1ad3dab1a13d6d9b2052e539eaf23edaf0173488ba97c3f145e3832bd85ca07b9a03e11f164d4e3113b8d33a782837a073f5b0ec579629fbf70e2cee211ce5db1c423f5381a00eb25dc45323896e631b0b755c75e291e729feb85a71e0a28f6df5f98f502c1c5ea7cfd217a01d589c9fe05a5dcf0ee87614b49cb9a10b93131f51c2da53f2336199b1e9f64cf1e790d5697aa75e2c4e412fd66625703fbcea44bfa19805603349a99d5af2e93131911c69b93367e8a7cb333ad9b434460546772e88c1db747e5b1ee219d23f56e3341323ca2ff89ffde02e7aebd3c3312976d6fe91bf8fe66e014a998802a7d1e3fe9032217a6e6086d7021cb7c86195e78b9a6168003bbd0034bc757018f454b536ba4eea384e2d657580091444f6333c6322f7ed0d6f5bffccddb3b679907d1da5c2da412f86178704095cdd4d025fc5cb696e2cf36f59c398809c593eaf8577fa4c71f00c9b18747eb0912e643c61f0f38686ae50c8e17dfdb9e36a33e7766c69d1723423031dc5910ea2653e766b61f6ef7d0c3846e56f158d4045955af395c5876f0715517065c22cd6acaa1fa9fd17744bb4ea989f2b07cf3b6af6951a87e044937700953a2c8d27d62ef2ae3838f63675c0d616dc8f558d28d14265b9d808e9173f19497b37b7b3e4b4bc99569377bd9dbbb293e67367101262b24c72035abbfec5fad12565c41eb80d492474cb4f346d3552355d3f51cb23b7ed4572868990553931ede930eb5c6ed4f5ed03696fffca52e4ae32bc87dd409f13361ad6fdc2e58db5154eb1001453ed249b7c00613c88a57e57fde5a10eda6d8dc4904543f286df2ef19f1ca548f1bd4fb2ea9762c6a770c4aef94824b1c92d0ced97d20392d6897c8f19a22991e16a9f94185aadd556a31cf7cd2c2a3b2fa82e4b9c3cd9148ad162e791db02d608b20fb85b880456cda8a7c76a0d2165825e47910228e7c6e618daedde7c2c7e303dbe9562fe333f0c09f45ab3d636dc26bbeb0891838a003e4528a811e03645988f25b2a69b2f7e01aea7f7a1142ced410deceff89b7ff53411f24f0ded234e6c1d3eaccf9c27fd34d45a943db295243d31a66ba176f9fc5dbbf253a3e69fdccf7de6e5dd76bd26e55f9313fcc746936561b10aac93e7b06183fa322da2065e2edae77f5f587398816532bde31e0d60412109d0cb1e8da9efed3d03caeddbc85c4f87484f363be19fb56811ff946ac41d0b0c1e772fbb71ac8c4818790e9ffddea51740d56dcade2fe337adbc6194a568fbe9dbc2d9633ce1132cbf3906f9c34cfec65ef1bc3a696b38865bd4d471e57ce1479050116a913173230a54f7cf578f56f34eef98dcb45aa39cd17c11f7b411a7c1fc98ab15d4977c325becfad084bd920f944ed44c007835784c53e720ce124d6b4bccdfba61249686252c1e7ac7acb331695007bf3c0d63288fc128221b564704cfd64a925140b1482065c9269b20974c2a383065b16785e0f8cff5affc94c5334ba0160e3e02244847bf673371399b7b85bc7d22c72bf7091db25b8dc29ec790f82e725d7e04675b547d053ce8c98e73a2a828e5019580cd516228e1a2c75292945ee2d8e0ecc012c68acbf544eb403f469a088b721e8eff47ca093aa1f2918ccf20d9681b9493846ce73b89d8a039070c085d6c7e83a70023f91d36ba688fb1576af92a865994aa606182dc427768cb7e18c605a0cd6e7d7ed53f48f43a763659a3efee93a6f0aee9288b0595457223444b16e30d6ed94b3b7b405a534afa1a8a8d675eccc6800fe82c37f86f5dd60e17659c31328fc224ee989712fff9c028920df2ffe2b465c1008ff1c95be46573ebe61733dbe71de4a6e21ddcbf50c5bb39ffd1becfd44b6d8494c2c2dd0ef163c2699d1e793a30a0d92f5429c467e560eb2fbd6c775eee1a875d8f64e3a7d296b646e0dff6682d875f9c1f1ac1c4fb6a734e77ddcf53605b0d4dbce392fe81d86a3a35fe0685c64bbdcf780da820b95f015c4074a2c35b3e2d58a46641c15c4e3d45f3ede4d25fca71b78db2e64bd0c7d319b83351021d5707d948658c2dca59069ab2c0d6c0c2c3fcff3fac7c0ea6cf40097b463819315bc04634cc3d2d8a5ac1dd39c10d576b8eaee623bdc68cb77528eff4717c596134439933cef639bd5965dbd4afe223d9b242673aebe668f69daeb1637897ee33ac0726514795f37a5e31ce8f90bb2c3b31349b5c50ff990a692e6683dfc32a21e43807bcdf54a75e1798b46946bad44158a5dc84ece3d18cfce7459cded5558d4c45fd1f462cb814ee27a6c9263b8a29ad3c159eef431270771ad1211e0d0e64e8e173ca704631ded1a4f8a0186ddeecf6766b09d62cabf75e361d49796a2bbbe56e172939674aa6faf5af2f06333ec1e2ae8f1c35c57c51aeb38a7b88b311aa991d20aed2ce39f102c68a57bf670eb71b2c80b9871c77a1f8b910ad82a4426f30a6ff407255b762860e85120e7a566030ce3c54a380a87be8d55ef0a76aa3e62fa2d1cec6bc2ed3a6fc2d03c05728bf6d182c548d2f48f3a95516d7b6d491aca9397cfc5ad7b71f3b2ea8217558d36067a897c0bf7d7d9440d494c9fb82afa16094b53a07b0c061b7d29f9a0610f327047f6bfd8f48e265a0e73165692b901e4dfc3eb89dd0f5a30c49f529b15b12cb7b6ed699ad64e208e91e0edef060e9c6466aba792ce50c8710e2373a14ee6ca2cb9267e974ae2f568fc59979cb884bb1c4de225f3b9033e43dd06f4047eeb788636b35f7e172b1d3ba60ac5a9bd33c6099bfa95fccea36bd87ec3994de520d7e78427d1574d9c26d21ed22ee103ec62f030a23abd2b4ae9963386f909512227a6fcf53eec606c108d664c533a5cee8a1f75663d0d389d93392baa2a5b61e6cee8bf709cd2a58b7db36b9d085c517e1b4cbee8a74eb56a3c624f8374559f22f21084284d285e91d8a94f6c7ba400af64c5084a6a728a9e9d5efa7124a58d7e86c34cb62065838f5a982581ffddd48ce8e3550666a2b1015bfd14cde3ffff1485fb10d6adc1bcb42ff3d8a73461e166e1a896e887a1f1f6b11bde8cc8be93b5931909626e1715ea6ddf10ec0d19e6332b536b7c51cd231e97a8838196b858062b80f6be44c5b0c5ff77be42120f28865142feed66b2eaf508799065f01822c9fbacf6d55d6881fa274d49bea768f006d387986fc1fb3f4aadbdd33cc11cf4f2eef10483629a8f1a5ab216b7a4cde6d7a9176b0e44530233cfb979724e19a799276a2d4233d90beb074df3e865ee6571c2495a2d928bfa6ef7f8e79c542be59c91602240ef3d6bd8a03cbbcea9bec72a71568ed87081dedc4f165a1448ddab6d3dbb89fee03eddcd0e7c713b333e9eb8575b972f26d7fe3505f3e7dde931c34c79b1d9edd2d801fed52fe871065eae969736afdbf48cdf35c7ede31b5989aaa7c5a5f6fdc5549eceec138469a719998c418ba259b97157d6be35c3c98306f3135e7c078ab7e6b92dd4bca69ee78a99e3ae51e22ce029b7104458b42245f65ba75620c1799bbff60125250f1d9ad2dce13070b3a3c405d74b090aac6ea9094bf860f848e57a96b7bdd6a3ce9f7788db468c8a8e85c2d0c9a82bc4b63a79c96230a6b3a3d0a6f6dbc8b65968d3525d294183a0d2c18b6e61a06781a0aaec2503d1b7476e5311351604ff8522e2c1a9c37ddce673407a529575584a65aff0221eff14a55869ecf456b48984ecebb9524bf1878ef152d1c67bb58294f65bd7f6663531f0d70883d245de5ebb1805c62b82a4f49b4e11be52fe97a4abf1db541cb7e4fac8351d2a0c4d3d3362e6b784788262b940c4211096ac6492acf96c7a6ae2f6a90f3fa3a6dada3ade245b321735189f57779a4b5e2a5065128f4dd847211643b17c6234442568afce2a525b162ceba62ece76843ee6aee1154dfc47d5dc6b434eef959cdc8630f29df106aa0fe42079ee8058e5019c819bae4eb2e968602c0f53cab6bb90d17513b222fd412ceb8826c7dd0dabc7c09195f866fab3db7bdfc96ff1a073af4d4da585d84d4712cab0a534b49044677a5aa667a38c848cb2ecff2a7b2aaf5fa3ecf374ab35e592fa39982e07dd66829127a76a35939905bdcee3349ff5bf1a37a2f43534f786861ea00aff21e7d3c2e86d596a474b661abf8d3f6eaaf3fb2c0f33738d39606e5ffd5e4d5e21dac26b562c7a681afcae56dd4f8891c1c4d6b6a1d2488cb1ea831a30b5d83be7c47b70049a06aeeed7ca7549cee96edf4c5daf633326eada9355ffaa9523d307095a2f6b218761a43d2c421900fd91caebb181956a4993179267150f13032cdab98a7c9d96f7f3c25908164ac95c30025a920061f8b8c0d99b6ca2ddb40c29f52dcae0ce80b079b3c01a1cbd8502323742bf3c2aaf6f623aa592c64f9f7e6597cb84a4a79161ce3ed8593efec44dba591e8d45cb85726dc3dd5e1290ed5e6f12b1e081f1cd6392cb7fa34840745e7b87a3beb484471418bf7e9f3b507c3b2c0890519d30d1d68ee90b582fd814ee2f616ba1588ed637fac701c5d55da68059df9a829a645d2c16c8fb862b7ecb9d89870b6266bf4872b737697b70bed20c8955cb5c26aeae7d6d2adaedba8870aa60477cd63fd23a434119ebce4428c4ded7aad477511cdae6eb10123a550507714ff4d89685b468d9222a2fa0aa96d7d2571e18687098819f51270e19fa7ad35ed2ecaeacef99983bfa34aaab61a8f1e0865b8ac4618d30628bcb8330e664914198ac5db552e7fd90afc5d171c7f6857d67e99ddda2c9821bb3e9b093c1c03ae37ea2fa4cae288ca0fd2ece41dd997838611e7446332201483beb151b42e371dabda15effabc6ea374856f388d0f58216f15199abdbf95fef20669138891f390d8dc499f61746c6efc9e0b233fed51e8a65c7f620e36842ff5031cc242a5e1a8800fad3db04f8ca9943380f846f33d37e937df79e0a867502ecb7d6206aace714c48543d8193ac8dc49bf48fa29f609e43aa91cba771379008194e54a047bb71c50e0a8b8fc7e2653fcf3d930353c551bd3a5ba3bb51650440b9fc43e0f9708b53626312a6236e1636c3a2bb900691cde9fa71d4af94e488e8b716c4ababefb68a62dc4b8fe921eedf64a608b279ec607a3f283ec86daf3a6b6102265260a256ea60da877cca7ce166e76920bae028a1bb4439fd3ede5f3ec50f16e06ced611330dec1fcec3625d61a290bfe76955ada73c4ec007945e4dd2b1d654ef434d0b0d9a901fdb93ec47aa9b01d0e0ae732aa03169e92ca3fcb7452305c99875f97d16bebb17652c70a28e3bdd6ca03ba50a4975af9bb74a574411ec5e9414e8524a8a58670027d47de4e704e270a4a47167abb05b9c01dc75d2f82c7413c2cebfd1f861209b8c1ada62c78966cc27bb1353bbaca206ccb9fd853a14f0041d3ba4676f3f7d6a4a5d17187343a55e63bd5a56ebb59ba845482fe14a94234a2d60673038451839c0add9536be6aaceae8a2f72762d49e9d5334b2846a1620ba0862cf6fd112469cc474b95596beedc9e5303decb1ad826d8573bc4a25bf1ae13f2863a1bf42f7fc2ebe7ee1e65feea96d9ec96e7d0c04c55fe680a97a1190611b5da519c290d7d15f202d52f491db43b82a9700d06916fb65cc9ffe058adfceb260846a04d5a4911920665d63d502312bcd89564efaae80c088f8c31289e08002c94fc7852d1e02a3aa115334a22b5dd6fb9cca739eef6f73f35f15ab7f4d5f542dc1b5b40e6232ecd2ae2b8e53be07784f335cec72ddcf84f7ed134694c6f29f972598eaf258b68c8e1a5cf4695ea715ca578af270d4c5fd20e44c6c1c0fc61b6394e1ae5ebeff320de6bc69dc7106e004b5e543cebb40f62cff6136a5125743b4330cebd8e201471316285e367e765637506b0e62e262f564ba6d852e99f46c63ba7b56745d040f1a691c0fe40658e4223038e59b5767db87bdfdeb220fdbae364326f7a48dc07907627c4b8e0eb8c234f567662aba800895c1d2b4d5ecacee9282a76e4575613455b9ddacf895edd5955c40ddcb751493e514b326978cf4b5817be0ad100e5e8b58967df75c4e049780fa85de7d29a26eb28b42815d6cdaed18509f82176e52d3e20e728f940783663a8d039d85465fc37b57a5279fadef59e6306490d07c4a85455d1c5257aab1be39f85cd4c1bbd993427978efd7a09536b7af02ebb4ceeab3754c4bd7a4be8074362ec7e5da850eeb9cbf3f293bcc67d73378704c0a08925672e6202d5ad10302256f9a8efa6a81c2b58eb15b654eabae493b4c4742617da6bc35cab7aa5a978da471ef0f1134fe87b98fc7530a02a98bb7a1b1f722ebb01aae386049446369e9a04ef7f59f1deae28d30a2405959a9718f8e233aea70f9b1e6d97b0019eee58edc6bd00f36dcf76231d1f56d95b2b74c5aa69dea217916bf1570afd8cd741cec36d5574447ecc95fafae6f1ea0f93838e8cea6701ed11676fd9d8883281d09175d9f351f1753d114efa8acc5705848080a2939db45bdd019e979bc0ad314ec377b5440c2c7d0d7fae8440e92a1e26f0cb927ad967a2345190bb92cd0deb5c227e5e0945f2f6404625594207aaeabc71670156cc659840451414bad7fe8eb8b7dab345595868713158c58259ae24052f82c00d760598b4c16c2bf1177fa54edcab8ffb6349a8b877515e1c5bcf596dca1bbd55b57e7168ccbf66fb17f4ea1917ab2444f5cc7615425a66c3d9a9454627b588ea48f4e81887e04f583ef538618f5b6aa5822cf35f722a07601a218fc5d15584de9e167b136d65f1ea840fb6afbc9d33f2d4b81b03ba9481773b7fee3b9fdb36fc28f96b98cac005e9183b750aca4aa7165ead23c8530ef4f598948485fbb4f7d772b36b5d4630138c2ee5943906bce13d90c7e8fef4f724cf8b231e1386ce9c0802fedcc5c774dff85d03a93831447d9d82864c525d4f91e89b920505ad81e0f0106f15830a67cf54e53f85e6a3dcdb0882803a502d78b0c7bcc25d008d15d611706f8d1431a219e9b580106677855b82bf32cda2255e2da36732cf2c8d7065969b7f91a9a37964b9b7e2b4ef6373575240c515e3a247d769749b8c293c24e1ef5eef5049138874540208765a5f39943d9bc2cbc549ffca3b298cb089904e76b05713e45302fb0a59b9c4160360cf1c62d1a3a723470d70925e4871cd1529a6ce5f4d19f26cf8d932eab2600225f190fd6ee657924d59336ac4d478ab151b956882122d7f90191f0f971bc8bd206577a5031a03ae4e5c187aeb823556cfbb8197ab5b8f5852c5b2bf53ba53d76a82d80bbf578ece2051f4016f47390f92760666d4d0fc2da67ac87795dc674102598b9bfc5673f459f775780596383201ff06f9cd1ea8ea95793ae016f44e5a6d814408583cac5e60bd82a685ba8ae895b7304c50208ddbd0c0aab3223b4bcff9d0a9954fc406fe40a8a3659fc9887eb8cbde03b550efd2ef930ea012632b3bc6b072db995e7f63c37d3898b8a50660cd65f553b7b31e08dd3673c1f2e1bddee81b6bd2bfd716803ea6f5ddabfaccbfe6856bdcb799ac78fbe93f4840d66df1264cceb8fb7956b0760a8dd2a88348f8c5fa484e66db6b0177f4765c411450969942f09160f9080293fd7a88d2a6f20fd01e896dd2987ab6268e412fb599b43c31d7131256c469d48a6c9e471f7488327f7b34a38e98d7956f3bce154299d538dbc965b4d6d5031a74e4513b9781f8be148c272ec1e22c6e4a72327009caaea45de25d4958d29eb2c9e3bb77c4bfd56ef0318bc6a7416ae90edfc55d6e60020d3eb14bfa927faff0e696456e04ac2a5c6adaeb39ca1d094a9b9e0fd7fe674f12128c88d1ecf4a21bbe9bc745dade9e59791f7a9c211d008da2f719d6d9b65d3991d15d5fdd110fc960aea075a31770546e51993a3468322b8e03fbc73b2515e688470928e8cf103ae2bf1c881b827a945765c7d49ee90fb0ecc88fd572bdce38fe7dd7fb3e14dc13f509b76081715816e3a694a8a0c9020e748668121034436ac780d3ba33a8237e143ad5e1ac247b021d858f644129a9f140cb03f4aa835d4ff98dac3334195f0ec41702064f41dfdd43fa3befdad579ebee76f21176d8ca4d3cf945b6d6a65c776736da82be9b84b581b25d9fd7dae79507198dc5902a5d6d0054567d3c507af6af2b9cfac96fe80283f3bc38c05a015f142b922240f656b3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
