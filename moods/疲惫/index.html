<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36ebabe1717c8c55ebf4c9ad9792e01574dd4b12305087aed582c345ba02509d1c48b44ed4b8f164006def065c4083955cb8d5c3c1c35f4c8c374fb17b540028765b605bb9a1e3eb8bc4433bf388dd5ee18c443e97f4e029ea1ac4aefb1d72d87383a9dca94d8fe0f8bc3d8b16dabc3ac1c243136c29d037ea57753ad353745052216f1d408e1c7758f40186dd19a2b1fe863a8be8c43e7a0d3c9ed1c111187cad78b07c06da4922fbad7ba2c3a8f4dbaafb7c5e08d66e83075ec4759bd3e371cbc7b021ab1c2436daa279a282187b7d1c1eacd484aabb58e0117b0690a882dc05fc0b8be2fc01e559a06edc1199160b27ad845d36d0f1876c204ca547421f5589d0c27b5e6824ed71f136623f5405cf2d1bc5bcb2ce51e524681ab5913c881aa4a02de1769d50d7153ea387aa4f3f517242c68f28f6b7f6213c41ad65e42a9279f933bcb4fa932ae9cea0d85b477538a97c27f15dd40e53a0090be3c80df16d26ca8d50a8fcdfd1f72b0871c4d650c7bc4126a4befbaa7b3ff047ca51532013022e36603406cdf24237b09829028851a3e2a984eceea326f7021fab1a15d1eecf4c80fe54e56a22998cad8f9e77e16743d4abe112fa4c60a6aae5adb638fabedba68a0b3868f8515fea3cf2448a23f7809f56f26df3cd0b4c43be2245ed256ed7b011c02ef56e75b2edaa813bbf4bae7719c1e2a849164ef6137911b732e6eb498079df500cfa7fcd1b9821433b6338bd489fb7e82dc280436f65b8c6bc87d71442cee9b9f2d18040def31c2b055e60fb9212ce6a05130de6773a5b06845efdfc5c6bdfafc4ccf61a1f0f828c4518866d2de289f141dc4e60d532ad781d5165e03ba78c464f2669a41205e22987954b15beb7697387f7f0475b22e88245741b85c4843f0f5cc4ee33a668cdb307117345a22b7f87ea426677c1a8b808970be5e2a4826e845ca8bc1ac8cdb70c92f7b57463582546cc2e7402bccde4e556248e18eb91c7b147fabeda30ce6124e2793b40b60e992d40d2f1650cc8857bf4f32f72a0e69cc3e3d82b3db978a93db9bb96d88caa4ce9270c3723573302acc06d3026ee3d743b3f1c5df417cf6a4d8d137d4b9d86e76a101c579487d077a86a81895e424e640114672610fb575b51fed3c61d20882e8c893069bbf303744c9febf596ab38e0d398503543665011d761750f63d64ad4e05c3da2e9d1e8e23aa0d723eadfca2a50a7fdfb3099dc2b3e3658d697de8359ce355b6d1029c865dd10d52c981e881fda83189a69f28b219ff8561f9389f73f4a5f4ce7c247a9416c0bc8712998ec06acf896aeb831a6f8f4861b2d36c43ba16f05e6d646a32049c51a36fcceb9c7ade1c8f801368b2b0e83fb0a9fbb7f9374bc767688700c484b711f4b4337a7fd1c8d8e8646d9c31e618242f077119833caec37689de225c583cc86eb1cc07b8790e62bb87402d942f9638472fad139e8a731f666b867462ce8c260c4b75085f19a8e84ee7f07ca200200adcd539bad1ed6a5f34dcd89eb575834b060091df62ce292b11df4c4fc77fe162aedb4ee9933bf659e28bc446cbb25b1edeedab07347d5691d181e50aa5d9d4d6914b69279926ffc963191c4ae5b3ef9a8b042291be0d682b2fff3cc5458d874460598597abf8cb74c408313785836211095bda8df1e113d5939cfc61aa10b2f1a5d3462b76490c032a435c4a81ea78e4ffde82eb22297d0fc16355cd03b97652f7881516af49c553d9b7c2547cf937171573dc4b855dfc83d1e636ae42f98dba02d9b3d1d7c8ad85e57759081e5a9693854768030d4c2435796c5ceeeb5c1b18f62465f3357f76b9459fa62384fe42480d30cc54e098adcd390a131c9e4e665bfb67b1cdc837aeaf8d4cd7db6af106c7f4157a7b27b6a9022db9df7c82652bd5afe9f6291249f319b49b519c934619d63f069db77954bc091aeda90d0d0587250d8c2be0b03a7ffa61e4c808ffbd3b12b99023f3a8f966d41380402a8c5c13cdb532c6fca50cd7ab867e9dea558f702c4ab08b9dfa010c337fd9cb1d92a5d354ad045ee79a726a79549851e6eecbc92445069a7a0909b909d4cc821fbb269aa7bb063a4bbd400e23c1d243f4b7e2bc50cb235dae65ca4e50ac16b2c9b48b2896c233fb3567f284adabe533478b6f86d2b73e032b72cd88f434c3b3dfa0d2a9ea0bd7ae8cbcd6f43cecc2300b68bc93b6b7e5c2e2741e1d7432ba64f289ce5e55c010a79cb5d60e02fbd464097c84ee6a393f2ce2ee17bf61a3c2516c337309b977c1c8d82c729dc3c123aba128d24b1a08914f050d9ddfa8efaf83c5035a9f0fb44a4f91d7b3fb578f1356f5b2275bc55bdd55e6ba65aa48a16531dc377a146ba0d24e0ef44cef6a717cfc2746df0b39018dbf6913b1fecb83b5ee1ab1bd7e19d03993d48ae1432c11dc66099f61b0b350a8edec256d64c076bd91a54d77121c21a115b01bb3461524bc903e813bf88cd66cb87a0ccec25f3d9b027e2d5d40a05d12605ad44254df80757efd86727f7c4156b1ed5b7b81c123069a4a034cab02fa8731bee35d5d1fedb51435970bd327b4952429722c79453636aa5f1fae6a7546466aa3c367d68eb17066aac9310dcd56ee049d87367e29eb138e2c9466da460bc9e7b57c88b16936e36a3011d3d0f232ad66998f79c64f157fc995a5ffd44a8afb727fb8148ca7e08b894408ebd51de90dc4d50646417334daa5c3bce6246a9ef302033f1bd0ad4759474bb8024b3a9f63cee97526a26892f7337f057788971eb8e60ca1638f6f5350148226d30de3975b021cdde3f8f56630bd39ed54ace280a6abe98407af264efee8931bedd73f49533f40c6d3fc7c9f10ccf315385fcf8515a1384e6e9a7ca912a4767fc63fba5b755a54f89f647b44ee7316032b5be65be8ac78aa02ba8fdb159ed48a40dad5d4fa267284c3f824f81035f4e2b192645ed7e41ef42adf0e44f1d8856b769d0ef81a8f5e57176614d36701a72e15ff3d6361884a8dd89112bd2e6e96024a3c979b0835332aed698dea34a6dd0bf531b519c159e20e3978aecc847064dae8acd48407a7bb839cc97d551db809d4a82183ab50d6ee97c4f9f0c52fd59cb7c427341bb09e7b843d7f33b0cd28ebe0355dcb0e98bf36960a3b1395edec1690848d21b69cce8f8af45a9ad1ce2de49a30dda0f83cd88779f2949763085b8bff37faea8399b32e0e9575e16c7a7154b62ee1b8fd20bd681b6313dfb5cf16d42ce13cfb4e16d62198cab07ee702655bc9f07f7863bed3c215def9c4628f8be8f8c0fc7485d14e2284828fd235abba46b0bfda36ad55ce1418ecda6c667ba7c3de76f034155bd1e5e3e3d2dbf1f8ea4afb2feaebd68c63b61337d90417e34c7cf1ce0a67dfacaf8d9c4ff4c9cbd17b1b8933356e7a5789dce7ffd140d45e7eb145d7b78d3f8cfc898412818143586b785b341fd6f17e846f21214e8040ce421b5ebba079885cc966953e9cb161b147d4d95005c87f2ea1c722bf4e37c0a94273760c113a0580191f72747be1066dff16a6652fef454e2b28757287474d993557d8f1045541af3751b8991be03341ebda836f1a8af0ec78465041420a3fad409d0df3961266e57f2a153892ff81ed05fc4e1d28a49b2498f64abfd22c7087e418803117a618c645e9a1e66a65c1a44a7f32112e444bb9c4aee04c722bedb033af2a6ada2dc28c7b5fd70f3847fc4eb958f4258d53f064befe7d87df92277b9cdb005a7bf288b7c94336e7d8fb51159b7e00b546a31a286cb3d816384ec6faf64d09fc447c47f0a09cb2cd7486517bbdcaaa5df965cb8bcc895cca9b126557c5324e8232e9f0c987c79d850d33fd4ea5c77bbeb0fd0509172baf26efacb2e85e2ce83e4a5a4e539abd4b1c0e1924c4abe969362e9681c1f33860457b8b895167feca1a721783d7bccde92274500acea43106478783705576dbcb36fa1e666dd71f8b7d816b3ce211180dda1866727fae9573039c92fe273c811e9f3f7ef1e523a76c8b5d32015ef26d4b603835ce683e3be1a048d7e94f26b9847e25ca64fd306e4c9e7c4c843c5df7c04b1cf1280398b4369137584eaf93a7e77b928d933ba8502ad2e973e2928c393abf180c9c9e9869a62dfeacfcbf4fb9742c90bbeb3e373b137a8c9a19546ac0eee5b8465122ebb8e0545f91459b7b01034a8acf56b636b0f5980cc8471b1c4192d00e9a680cb2297065a660a4c665f574226ef6c8ce56a98672ffdda994daa8e19fe82895721da0c554500fb7f1d9fb412664dea38736e5fb8e251a938b04f7c649f44a3c0474aea1e28a589c17bbfd30b9590f6883b44ba9cdfc8f8a765365cf587132dfd9bf85a6157566f43002e91b91dcf8a17dd2cda523230c114ef7b5874975a7f4b3b7ec0d6237ed2fa40cfab284fd34425d5357bd50f035b2b8585a5c1b0bba1a452d3235462197e98a1ba1821503e57d9a2b97975d3edbce6dd05897574da96176b7b3b8e8c4c65da3361e188dc1e2367ac2cddb0750a43db0355e228509519efc54e608820db10585368e3640d7e7db4409ff7239c946fc008109eca64cc6910a0af55da865cb95de95daee47a6776b93a03da78b1b41eb7c8c87b05e16a913b0c71e40f8b5d4e5f74b949bc9094af6cba45ac5ea4a811ba227636fcfb4deff7e24f7d13fb10adc82e20105701453e7952aa222a7f5913cb1894cc1fd7d1149d8f5ae53a6f9626828bdfa2c6a29b581cf9bc7e3ac2620cde957200fe8d66a121a21a75fdd3b9daca2f38cfd3f241432f0d7087d01f896cd80cfddb1415dbb01d93ecee0bc4944f0c32af7ddf4a32277f16c67654db02ac0235dda0016502777e69232ecd1b3a04365c7262942b8899e7a7a3cd583caaf931f2fc6b3bebacd1bbf65b7da384967944f8b171b1b55059d8efb15c9e81a7a239903e95a799780148fec5e04d9206e7c0dbd31eca66847748a16af94c3833ecb2bed6a0c83613d4f091ce6a356532cd849d7d888c762e54160cba69b4d129300f32453029a69f37151c9a818633ec32dd65f3161a53ab8cc5beb5915c99ecdfe64c94ce665655f068799625b7809ffda157621a94b395ab175f311a0b577e45ee48f97e0c94df9d36716b31a7a3db3963c66bc30d863ba00c3fef5cfbf486fe522fadba07b97116d954e58bbaeeb7fb50051118ec9fdc5a5a88b5323be761dc5ca7cf99711ce59cd4fec5d5b6f63b363da092098722a6dcf4d6811a72393d94e0602a50d7747911b4b176a01ab8ce086168259d45584c8a3940a10aa6d5474f349d5bb5e090c284a27d2353222b51f4e18e92c7f4d5eec805cdbf8ea4412d0cf6da9432c2b010c1d0cdf9bc277b72f5246bc0c25148e841ccb33c0c7fd9fc6bf02296684da2393f8e6c8038bcdd479cfd8302514145961747872812690877ba9bf4d36f03aeec895f75433abaaa24e74b530a85ff21c6bc76bdba962b3d2f1cdf5e1db13c4ecbd37cc9b684c582a6a2b649c0cca67904a5e69110e805f0eedf6767844b909181d7fab7411387601a6d50de5df341da8309f83e43d131b87fffd633f8123747887efa48a59ee187d910cf8077659c8c0b0a68c298f74a4e56bab363f06ef1fcd8d8fa2a8252d67c9ca8a9f3c72ac8ee5d3d0c2b841d521aef7ff775a2a9ac20eeef2a182b726da0e24a3025714ea40370ef05e15ecfa9d2a3dc49192bd8d16962a324b582c52fc99db35282b85333d3baf26b547b9e0681d02f3bf6b5c80162603c369ad23395ebd71b057474dd516cc7d81c7853e12d21407b99b9364e122e637cc3b829af16945841ff22bbcd825966c77567c369597242632ae292dcc802558ee879125af1fbd066b02171c683d0bd676bdf13a0e1048ade040dc83b241d96dd5eef7d6bb35a4595fb7738830c390133003be181f672e9da2e44f17a91744315e7f20fbe04f4d7ca29f45d25194925c4fee7c1a7739b16d9184744e3e22169067501ebedeeddedb881d4f549d0aff5fa8b5139d956fc52875e5fe5bc2ac96af9f0eb533e2838405d5e397d4dd45ece1c4cefe818f0994070e8f55e6b76ba1c318941888f4e339f3014c34867a4fe7f75097132491c06bb7476ac54952ac404029e5d113e37964022329b1fe9faf2117911c65d97cb1af761d5b00616c4eb3b7c1ad9776192d1cfcfdacb69ed1c99c23dbc30ad65584705dc66005b040d25d0c51a90afa41d3b107d9e5e7fd06565a7a25017a5b05d32f2c80d872d8d36647bb0c2865266097d9b9c25bd4d8bbf56232d21740713bd597c98e08550b958708cfd925e08ed28f18be72c4310fd7fceed3879772568dc3e4a117d233c5b5b94bc9bb1c04c3c93dd5d8b07461ff61c2791b63077e35b821d0b8690b9eaf08c21bc8b401ba3bd8c0d906a1b25819c2f19fa0555b7d52c84a393a09152bc2fb004cb3e4b826ce5cc53e358c76f946867b7dd61fcc6eec6dd7ae7924b4b4763044bce209976da1765413dc0ca9387fce61dbe1158e23d4e84367e6c166cfce36cb7c0c2be9c807b925029f8095aebcc788c9555a8b35ec5796890f1bab0994febd163c24b7ae5d172074fd816fbfadf67b9e3508cd86e93fecfb256b67dc1c8f9fb9ef8c5ea4139c2be496fe1b49f8ec94de3e184bfad3fc2130183590c2334f41d1cba880e9102b3bc1a3b8dc5e0d37e3646dd3885d85a7b9090a9badae25740dfc72acd90d8935c72887390bfb8cdead34782654b6f7ba41784bdddaf65a9c6f5b50872f8344d1af95224123ee3265ccf2d219f0570acd00042d3dc29d7b1a7d876e2b7e0f6ad18ebbe3f2e00286988b036d409b0bbc7cf3f981774a8744b919ec2175af852db76acceed629ecfc1e23bd36899d39e792e4a0b9687640926e93c04b492c210647deaeab2e5dd271da3ac0807826083c891ec7dabf6060a15f9c2765a3a2564f6b2c51480b5f5367c26bb314b7079f11c1193206296efecad24743e120f511ed13389f507dafe2292f8a0558e58f3ee5247e6f3096a9ad046c2aa0bde63068b9935cd7896cec26e5d9a8d3fad8486e4ed5a808f6194e7637b91ab99ab86d01df62747b2d008e1983ef70a118fa24570ab3b9adff4320cdc24bbcc64c646a88eaaf300d1111dfdb1f7b559f7e3c44668fc0718c671ffb049f3ce191279902250d6f812fdde92fa8d11e0625d3ab660b67d0d897de527570ecf526803b4fbf74f7b6bab25a9906c50bb87024c92a1b2634cdb6f8decf3d4c0f75af823f8d95d7e16fb355cb61b2939b4be371cf9d97abd0f451c8de00019513a5b92f6dc146b41952dd339bde06b3863fa31fed549177999aac2ebcac30acd9164f46c5b242dc8e74da0240a942098e7f6f91d1bf75f45dc207903309ddf48fb30e6a95c333632f27dff71cae128278fd68c3efe869a7893d6ed6628127f7ea6de5713de270819aec7f8344ccc41435fbe3556fc22025f190f4e8465eb0128adb272372f3320ca32bd4073c6969fb352ef097cf21985a400c03191a09ba4c6f1ef05ddc04ab84c89ed7d989b17e1c9d975311dced6bf937d796f91d3e4fdba6aa40366e1a66f107088da5ca93b7d33c65c721533ecbe8ce56e2375101c5897af3d736ee9cfc0dc88c7da06e5b3cf84cd04948ba8533a34513ca04b05c07b0951cf13176b2424d6d7ebcfcf2ac14f0f3d11686e604c9e19595e834bd24d58ea4b12ae86f665a8d0cbbb87e6f66eef4575e17d0f3671c5b909ce104e87108c455698f28bdd773ef0b417a63d01e3135a4b65561d38ba69fe9b7a19a94219aa1d8302cf61526ea3c1f971e28858e05fb4e322e134cb5e3bb1523dbd99890b7cd6dbe249767dea98cbec1a21d235be3512ac98ffc29dd709fa00fb1da3b09fc3de6c7d09a199281c04bd7557b6dd4523ffd132aa76690f17acb2094db9b01df9d39f77aa4f5b84e9339e5fbfde200e5deef7c58c5517c53f8a10925ae373c9a0d75f3383b00e737a39871d304e9c4adb9fe1388e827ec34406506e30d669bd786ffecf017b95ca92f3441858f8b967e17a974890c3bf8bdce71a8c6fdca68cefbe665d7da136bc407890f35b7f83ca6bbc53e9c753e66231c00204b8f1599b1b0a112bd0655100b1796d6e5da2205cfea943c535c01995f852fb19aca1f750add83d67f627ea51a896c14bbabeb7c706f85016a5502207ac5454cb56061176554ed5ea1e3587fedc6f6b93601fba613dfe74b5b9862f20552d3532ed5722e0f7d621aefa819e7efc8a520714dcbf1b09068f1f8dc0b7c849fdf591cdfed1c24b7aaef94d8f6db52a8a99cc773cb8b073ae61bd2b42a247ce83770909420e356bea5498670fbd569843b93b73c10353f4ff6abfad312e72f1f4bdd1672854611828f9d6eda5f9619de31a8eda253226492fe9059168a19e72716da02f552898d6bc7dee6654372a5e837d0101b22307f5b44f9b122bded7d18c90207c2485f789ed3a760ff42688929668f9d8b787e159db5247b7413fab628ba35d88e4dce0f238302e2a3def789ae87621172c7b5c33409c59d31e35704185b40edcf7cda6b4dcb7c0fc964e90ba6ed792d58f4ec57fee5c58a70770407789b74dc46bf2566942ee4a247d9eecb859cbe636ce457a2bdd1102ae0e12ef4a75b34a2208c3723b4f91e93f941a463e54c0d8695c3a93068120a14827895d9b4741968b9a428d34eaddbcb68c3f89831d06f597c7345f19b29b0bfab6fac53e6138f49f69409ab3b460b8e43856f8206451c42f4b95f711cf5dd6677969e01793d9e62667b0ea2fa7edb35c9e75c40d2808acab99e5f8cc612df79aa95f60ac426104e466ed3de74ff79629337fc82454794e5aa6e0e13f4a87ae60798f8d2350df9ef4620d0819b0a2fd22599a9af37d856fb9fc93d81c87811a32a886128657d41655a490ab441917b147ce5ae17a8e5f84365429cbcce44c3b56f4dc7f92bc013cb6c6a9dc4d75351329494d87ddabb299d05141b6b641f9fc55ef6c2a1cf1d7cb15afde466c6614ba0ba0932056b0c0a6c6ce25024cba867d115d06d93520776c5614ae25da043b5af34d9e40845dfc88e9c2cb6e6712fe0ff59d438ed28968e7476f17d5bb1144406fe3bb2b1286daca586b79fd5329088e676b1459889d4c882a7f68f977ae2b55fadc281da16430a5edec689ec5b13e1080124212657f4cb27528ae6a92d416aeb69d56843822a698ac700ecc452141b24e23e92640763700abfa45799b2009e4717d5f691862f2795021888a2608bb8e34be0b2d93fcc5399bdd301957834db5cf669105892d5ae7874eccef0d5ed1686c9f4d480267f50d10876e84d71dbd3c1ab88540f3aa9e02f245e802d241ad41e9db3fe03215213ea37b09ac5840270b7eba1e56685b1f69357b9d47c3cdea248fabf05f932a8922d64cbb3e0f9cf17c53146cf52b29184f1f49ae99a8f1a42dec78aa63c43bcbbfd4efec4fad8cb81fe277c2a5293485c0ec72251870844cad3a9d7a8bb92c65dd26a10f74f0eec020e88f30199cca136bad183b8fd73837fe8debe6366d625d34a1b0169c1338439d1d9a6738105295c83341d9e428982522a526bce038483940bbb9937191db4dc6e1e8e01065446ba97c3a623c2b414281f5eaa3de5f8699264339679933da455dba03580082673e0a95be646ad20da68544ce3696056abe95844645235c508a5900446086e75b8e861ca26599dd96a33e8dc53f44857c01bb47b3c726c6c390fc7b579bf2968be0a2d3aa61c49c7b3add1e9d8327cf8521f4312102337cb0119408237314fc1134e2072b08793603dd0100e56ae314f195b6b131cfaa74c894887eaee91fbd13343b71cfe976f1d72034df6b1ddf928ce6fcc3d8eede6c8a5bbf0688afc42795b251b17afbba51ea24202d65447a5a7d6c2faa44ee79dfb65886efa9bf6f0dd37a1b7f1c9aa264620813bed43d0cfe0b4bf97763c5b157e0751e96eb4f24b5548903e71354120087a95b98cde609d8087dc0bb0b7361c83d724189556b7e9b926d9e745e6d266b7cef82e51fb6be91fa84094a68e3e44cd4ed50d16f33954603ed5937d736ed59e06cb266e675c011ad353d15d215ab34bfa0e8696327e33f030c90fe339572a514785a9a06bfd338f281aa3029966cfda0f79824bc5aaeaaeb1e8b8d4a64189ba3b88cea7a9594645a824b6486d617153e72a3110f226a628bcdc48bbe117157918fc6e1a1f5615ad28dfea0aec70c2243d17b7de06e8a423fb3b5cf603bee6e63a0979c1a54a8664d7a6e009ac05832be57962c339f07f6d22f0f95c4518d3c73beb15698c9f1fe0bebf8c3708b54962e686a73df4e73d8304519ed3f0d4079aeb3f4c8bf0c0a7fdbb50e1715518e235955db74b414d96d9fb155f95e3724bb308acff4d0e8c0be15c5753b5598ba9258a067eddd440194b8e5d454b8a2679b1d6b64a44160421d12890e75650101403b857cdbece814477c5b3d10f843eaf6927ce1b86ac146472fe8a5ae97a9597dc9e3818b9ae7065f51b86633755c45abd13c44d34e3ff11ea4f451a53c6596b9770528449bb2a24e6be252450cbc7e45e2d1713771af0aa8a0543b18a290aefa38c99963ea13d904a46a358d1a8a83e08c684a6ad6b2fd9c987e6578d72820e09264d3fc7d93fafa611edfad19740b4362c546d36bc463d635f104c128063648c7cfbe16bd28367d21de063f0433dca6c3ac87e50a362f588e7987e504cdd919c7a5d871a1377231992ecfa1b68c2b3959ee4bcb66dcc1cead2db2bba1dd4943177cbc5972c722b1653f1ca0afa42a6b47aa9aa05ff4ed21a2208083f2185a7718a0667d0dee361d1d71f474d1bd249c44b46d2d3cd9ecfaf12e100329484845b353526034c2f6474803df277bc8cdac42201975360a10a81d3d75eb9775ebec9b0434ff61805fdd8f7975c96b84e88f1dee333228e1e5369b26860cbfeb83be4c2b6012f6fe768af5753cdabd845828a5a3e8093b7d551a4881877c2680bfbc184c67b9a112a5b31b34f7a1f3328b5235057ae66328753dbae353c25cf519017a72aca15566252ecd5885a03ecb556d8f40ea61a7e73a33ec964e639b309fb3fcf264d68c6c63b79f560fe20d50197122df8841dc07f219c00fba2917942542db8e756b50f25375727e4d6226839b520c90dedd50d88ec75e69f59319c63e6d0e5161e27940f285d4836b1469f820ad85e2de5932a74eec71e9f76b1caafeea257e4551c57dc20ec162bf9bc112e9d2398baedb3b517fb1d255f63c12c08c4cdf0e4446a199867534c35b5004506ba832420acbd86b1faa2774f58c93fdb2e8f55bb2794972468850996371a1e98e91d17b2cbde76c1046aa742fbe572db78471ba2704210cb12933ed5265ec6e3a5fa51f4b10c3ac5db738df47619300ba0a47d27f164b9c4f0ecf570fece3349670e7f41fefbf24132a159816a7ac75f86ee0fe67c05546b4ac17009110503ef16fa8f9f63381df65c131ea488ef7143cc1a6730065b6a785b8e8e438af698651244006fc62fe864997480cb9c73f6a8d45591573da9ccdb58652aaeb795587aaf2222b1f5cd044890ac706c11a5ab47edf5a28a8cd333db4b86b076f12bbdb4a72fe20b8c473a1c1e88d14cfaa11b268cc7672fe06fdfa8c1b4353a95d61f0b5cc9a929c0c722fab27dae82f790646c8d48470386bdc1399aa68759d62283bb5f7c6a033f4d659822547d45d4c3506e14ed591fe19119059d9c9f430c08a8ab69ac2dc6d97b1d0a3d676a8db1d9a465241b5fac487598374cebd465058ddbac7d5823ccbcd5d3377336d1500f1c7d6ae5bc48a7d319f6242b8d0e909c96ca0c5232dffe3cb9168ac4e2ca0edbf1bd69b4273ce7f4f34635d604255b1ef7a5d6340fbdbc656884e02d4442ec04e794fe4ca8e734b579fd713543957dbb5724e22ff01adf5f93c48e22bf45485de89e7a173c7b6e5793f6312e8ad088fa469b500456c01c8acdef78ea14b67c5354fa32697f25a90d8a8bb9af331459d34fd0d2e4cc2d5b82be485a15375a1e8ddda2eb295d74dabebea502ef9f309556c5892c4ad2ef9b5bc49ca28ab746e7c41e06f191d8098e1367a0122a337731b34f8ba466957cfd3f35d6a57982efed0116f8e44fdb123c424f5ff145f731a03f8158f4645f8005269927eff5690f80e2d115e9270948b31b5345adf1c50860a8751b0478c14a582dd18b3ee68a4ee0e3a1bbcf558a3ac632155f39ef91fa9b36953261251a4558f644d4a960120b8811698c8d36619000df653a2aacb62326679077b517c3f05cd799743c0c926a80d4b49cec69729a764e7bd5e286b90e6dddedb2563fbdcc9b6fe5a46f000827abe5c7703dbb51285c1765661689fa0096725d8bfa6eae7da3335453eb2d429fea2d26ff0f572de32d22030a3ce5c6e0aa74a0da8b4d17c4cfcfec94d47d47a4233e6512989ca630243d224b1efd525835b54cae4a7a8fb5eb027837ce9504c6d41a503da835b7163e0d07956b0d7fe58d41ea655328644e25f6c55162d4a140554b6694c9bdb6f813e865c4d9733e3e674b88fade541300a5f1bab2feb18da96698f77dc7c27d48e89e480b20778bf143177f1b475d9c27dc66bed008d077e1e06f316bba9e9eec959708b286bde8a2e9e5bfcb3c039d04c3cf6cd8c3ec79639647074f4e16fccec67e788e7066fc051b54d81ac322fbec56963406a4dfcc5d9586f04f29b53d29637d827f06cda672f98984c15994d7fb5584f4d1372ee1d4892f5f9df840224a946c55414febe052f2650c647796af39b854b11cbf03f1737e321b2ae187fe9c6a387d2af028fb29db9012223fe4303150b25cb6c3ff6410657a640630750c6587b321d340e95fa3429b0033599951b769677a860a0b5c0c2c17d13f1948909f24d9a3ba8c3aebb92357c220fd467ed10c97ea77126d3afb8d7af5712cc5affc02e348087bd53716e7ed2522162425e5020b0373b0bc340f9dac01cd07b7c156b057e581e34e6486cca2bbcff39d7248148f7b33d93121fb68ffaf656e53d5cf3403e94edff9551496a802dd16866ba584fc6407001399bbf75d33637e4c69e2350c5272cb7e21b5f4937ebeeaef99e107b508d480ec9550301de8f64f335ab93e6838b7bb525a6692a995a350f11f46c319f9f826b0a88676891eb4a7353177de0817930e790924cf8d3687c0561e4710a2f092c3e6b2601dba0c36c9e23689ece10ad1d00a223654b9edb17ce6f55167888fa6bc3cc8e92f138ae9f7b6ab35e02e2e0f073fcef89af3f418327dd1dfcf7380a296d74c25ae26a3e309ad99366dbe266e648f353092fdb0dc39e7136103aefa3f361cae02386f443385d561fec22e9c6fe4a25a31a2f918fffe41ed6d92d7cadf0d3f27f3b8e93dd05c328fd32b4b7156b44bda0d603883ce8534d9145965bbbc06ffcadfcd45221fd4579f804362898601b7b10b713b74f50c62a0b6540477f7022780cd32db3fcb8d0b4a1207d186f5312ff7300771430d37951f073795ff29664f6a7f51404c29acc68b450c21395b03f966e9b0a8fcbd771040041ad76bc6bd7f7074f80e7e4116f204feb0d7b6819a9510472bd0151100f2f9525f3cd40b6047baa3cd3b6ece46bb7fda791f879e45b7faef4393f4843af08d97eaba5c30a8f79733ef0b51b1ae65d27f9cf36c3366d22edbb9e0678f1edc216f4359f2aac7bac0970d24644dd7b816e00c662abd6813665a52587200f39bb3bee07b801c704d508cf279b8223fb1ef4cea3fcda0a050584f66e03d60b847378c63fd846f01f4b0588c11418679db5cef5a0022a543f6632ca07d6431d392616559d1e59a60ec8f2457ccf6b6a05419e67baf9626e4c56bce4c3fc96646629f8f8c279749679608540b3bb979486db843a066b72b3024026c725e7f357337df7f16a4cdc331da2651afd4316a63a488d78b1ddec2fdb54589188dd087bc59fc79fc4a6fa557b0a9fc33d3686e4be4350f189596bdcc85c1c299287346fe8bedfab19029e134a99eb525adbc7d03efe2548366c249882296fd088e28276c14a7d9cd4cd217db9aea926d5c47a235cc1a942f949525afeea286ce2d5126be8f3629f32cf00057aee758e1a9b383c6fbfd070950a9749149487e604a63dc8d373338bdec24689df950f107b33ae0f9a5759308d3a023463b090a98749fcc4e24003e7104ac62951a940eceed88c11d56a5256b6414c2c5d8b7c05e811a532c966790247aab11cd3268ae0c12dd6419c8cc0f8ca79dcd22552da5825a427f24306fc697e9492c0635b77f66c53aeba0712b7597f3bf6d321e86c6ae12bedc361d8d41b663b76373fdc85ae0939828a6b2b904f8c22ef09398eb2c9c06ee54c9a8f09aa6bd07a1b1a533d8dcd2928f43be3d0941714101b0039fd359a5b41edbe657f5ac41a3425f5452ff7d8934a533fa772a31d08b58ed832735c326b82d3ecd9830f77d51d72a556d1c3b8f17d59f29d4c7d560a4096a77f4bf1a7cc52813364d61227a24b8f7242d05be4ecb1a5ff7c74048a557a414988a2c579b8696312dec89ee291d79d13b5901830b42bc2550b3eb2c3d8edc788d58ff257735c03fb51e32eedad88ae91c43a1fa88d2f41529e61684edd673c387f81cd91fda8220cc599fe248355ede48f586e2a1e1af39068058aab2e7c30d7a7b5bb4ad88785e0813631c6b968d4de89becf43e228c8865aa58568e3fdb760c2e30f30cd8c036e7d3f59ad416c5f1bed3521479313ae587ee883e5926a76fc90866bfef408a967d6c042a185a7755c4bee709c6d7fb82ea1a2e5d05d6a306a24fb2c077da443758cdfbb6226a8182d4883cb402c511fb9b8873a5f3cda04a73b91df60baf36258da58575454af8e9f42f28f73b2c34cacf9443937cc6d8d981288f2ab0baccff3ed71babb9dd6c9992bb951caa6a16050195b041a08f162860d9f47022146fb35c60e0db9f8bf1c665068231f086dee96f17311ccde5e35aabb4060d94910030f661139cb225f9c6e65dd2afbcd1476f97a95b3764508678b837e162f8d3e895f97c5661ac2cd17705d4e666e5ec5a1ae49d990513430a290e61513877310f51c768841cf20e5567eae4da0e340f321b31c1c30d7a02ce402fe5848228098bbc61581a3de48228857cb9d3e61634ed415e86d427605f3e596bd137089e5f6877d4e5f4b49a9c5dc9412203c73761470fe3d871ada7e9b23560abf3fa21f3d8b3c64939617fd5e610bd14bec6a465f9bcc45f571e84d217a6005201da1a9c61e476d0a9a4fd3693a3db095090362c87b6efb7e093490b79da925b1456e8503277995699b491f2a7d8c3003adccd1e825caecc733236a54e0d10b6f691549aa7f8cbe14ad48cbbaff6d0bcaaee216139b627748f9e68cf28c0e2aac639f74059a6bafba0195a3982fc78402ebeefca86b9a754b029d23ff5600aade39c69395f95e3af8e46af38f79a49df63014012fdc3fd3e5643edeb382988672ae36a604f813faac50752ed5415d5bcbbd6300ca149f0c913ad56ea0cf4ff185935bf69178761ba3b332e7af0de3f62608e478d7c2b6f60237f0ef0129db3c2ccdf2ac254b7f469cc993e3e31166d9237963d32d01fa7e177a2ac8c7050c2dcc471138ec9231e08dc306faef8fc3dc5ce5e11bd3ecb6a9db4d2bf3fda91e8c7cdcb060c2e132135f7e8e025d6a9d14de9c5c0307fb55cd6ffa0222928cc9faf313c0fc63395a8c002f66bd0f9968ca29e3610c8557d72e876f559d462f936835303a13ceeaf915ab53133d292492f9f1820dfdfeae746fc33d3b53c77cd35550f2020ecdee118106ba73cbda0231be74171b9babcf089ff6f678bac2b78dd614e93323c0213122bfd59e497be8c759313fa1b94ecba35e3f490c7cd412991ac83f0a560cec318daa017bfa4fcfa569ca4f045478aa0def1cb3b20908bd5c052f3a02a4e5cff6220f8fb0cb12a8f3f08fc62d80a94f70603d5df76b6f9ac68f6e325685a6fd4535dc6815d1001cca20fa2e5e03ba2b672f7aa6ecf35739648cce5de2f333fead3eb5f6004bbf6e2d6e53b0b2ce8848bff58053f4513acaf54569c2f2e7a384f9333c445d7a973bb93e063082ee2f678cadcd907f2acfaa3ae0c47c290966f6c9eadc08921312130e2d21d6d1f9d362f84d8f6a64a6056e22a97b1e1613386dd75440b93b8e4fe7f110e4a965bc17c67fe95f6c2c6ca1708387ab626abb43a9245751e0e2064da742be3622449086bf842224b02746d9bf6b9e19cd28c810d9f582f7a1745998175ef94f1ee1eadfb4b67ee25d5be8b6f0f5d80816c9bad20a50aec209483e6438abbf2af99398fc19ae6347ac7b50e48670eaf1c83ef2b0ca30bca86e2ebc6e59fd43b6b584d002f346e982b51c20d7e05cde041c3ad682c1f2e07504c357cc8ab60d8c281c0b2c51f18b17c1bce3e8acffba0e824c29d055e8a138d52b28431a84b266c0f28aeca319084e3a6d9d5deb72cbde8b51e98b26760d8ff488da221d624b3db70d9efb13dcc25e918b619a800c25b72ab7094327badce544592ab10bc9cd36eae5876b8167870903ed3d5b11315ea1eb8e61b3c42b644cad6ddb9015862676350e80e32499f25cea26ae215d343b142b9f050ccf2dbec62dfe68c86f8656857609e3be4865fba55f80ac5949ff7395497ebafbe1217a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
