<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"105f8b0dbd237923d755d6ed1912ba621a64f9c08c669919c2efb4b03f00aac0dc41d54953f3be8750768b2e9c331256f9797beeff1749b535eb4d979109cfd72d6a5e3a067bbf5eb13c51705112cbd210132d2dc79190553b7900b61fa05ac1555367159cc153a97fd8f498ab15bdb1975788a06763d5802506880e1db660243127b4b629e9eee95d3c4b2085eb45dbaa64d5a8f297b3314cac4bf1e4f297afde9fcf03931e1c07b947684428db4865fc4f37bd2417bc057b1bbd62a80f229650de1a7373a4ea2a89eede1569d22b421b85834f4cb2bdcc26bc77ab93e7f3a59402e2e179c34f37e3da6f401e71a62ab42e337a30ea3afc342b3bb70637697b5a1196b99695ee9237826132c36798212dd5c6d310def7f9c4a8ade4591d7d1f9972756834a8fb1bffc156d1f0e7ce4981d10eea9c9cd5114f75b517c7d74347e69b0f70c96f6515e5087a6b8788104f5adc9255b1fa298b67f998024c8a982940042a626c852b25b25edb801a0385326cb4d053abf8144ac169f19f0affddd5f89d59c2d16f716efddcd1398f22ca62bf55155d7625747f7e260c0d1478e0ab8e79a8b996d4b88a1814c2d5937e960a5746e2579cc04ff514c79a16af16259c68c076ac18ddc6ed6a5a4ea8bcba17c8c8600a89cd4cb095890def0d3e53bd0ac670ddc976a22b7871ac6b6b126c152b7a8211704b041302d27cb0ca2e5d01542e8ccaf2a7f782b42be8d662b4b16f983ced808dfc8ff913b2dddb19109a274b133182ceac7b45aed4452a8ada1fa86e5da38913c4a9f12528349b43adfcc5a146b0ea37d00bc1e37564133b6c0e438fb8b0e6974cb3102af66402c90d342900abe19467471ed45e3f90b2c18511b888a7a05b90b69f68434cabd13925025a147a5043ff5d32ebb0ff44df561ab776d3dd20a0139536047b7ae79d6668521b062d0a9635f8c501f9cd3ebb5091d71e3282a97b54cc11dea436a2cc5460f2f2e5917178195a15b923a898e72845dce177422debe9a4ca83fa064a903de6ac7117eee36fb987658874f3a19adfe78e60ea0e6b0fa2ffe017f0c68dc74155091b4a7c5eff84e341acbc86ee10b7e3909b873e85fc2a388f0cfcb921697a697ccd24d3b579d8fef30042e58c7136c2314e31cd9245a870662caa196950d71d7071b813763921b6bea78b15460e4c97982a9fdcea425f597e6c424ef9adf35928f8971a22433e431927aad5c9e3b59c8dc88c5dffb414a42c51166d7909266b91e33f5b6a8c6fe23bd73eff891b9bcf3b10099ddb75f0ed0cf0b4ea6d7313042d4b3d6387f2f948c79a53241a080cc3b6dcd0c735411c606d160060d12351b2cc88f753dc4a08869dc897b03798cb905c41e1c05c949a3885f2345ab4771398236f6792a4026a4ff8f99c2411e580e443de3c32b17a4b79fcb8f53341ecee9bd6b28a7f054f6e6c7e0f7642719a857e3fa7df0db64ceb8849f0d2b765cb26b9635081731e20e41802915968def4f7a4323552e4e45a8f5c6010e41aac6f7c98b9704340be78062189bd1b34f0a825c110e4587cd7aa9e4e94ec695ccd1c347a7aac921a618389853a41b9406eb1d3da132102c10102d492554684319deb29337220748667a0901bd686d434c1022f2bf8d92bd36ff2c8428fbc3a38787cd6068d4ff7fdbdd34e6227092f108cacdcf781b5d936a33ba7e5c87ef82d60f234e2c01042863b25d923a8873f70e797e8d9bdc0cfc918762d78409256c36f4ad60f1aef74dd2fb16f88690cb894640a89a5d55dd0177a76438428fda67821702ff077d558d5ef55f7490f754a3a09c1374a03ecbf7727d1a6c55e93c77f47f63f29ea0c7f11f256cebd15d09c483d8f2b77980676051aef7f0ac08369aec84798cdcd1094b185eb6955b70a32efea28225b97537d22857c735d299150c75d9203e69b5b18a0b08f0b9b45fb597ee6c06c4d526d0013733f2afb849dfb81406ffc0ebadd28b2ca66c22c8463dcaa711d95c1fd11ae98bf8b9accc0c19ec9088b8f5deed6102f5545db15260b11ddeb683059bc826b636393d27e27a13484fc91a935f471bcda5538ed2a14469ed302cdf89599a9e267d6266c998e6017b0208bbcb9a00641f6de0b82e6e9a08284ac08db1e00d5ef7cae437aaf1087dea6e6d24c296a5862d61f59c78fc1ca8701c4d268de93ae59b7682abe745bc3e82617d128ed67baad00c570b84611d59ee1d7baa8be3330ea179017d8e105b5190f0c6fe89997738cbb603249243e892b2d1516cbcc83b6c144edb2511d542b5826d49b44801b8f41f5f9f7611c8402fc6bacab2edbad45128d69b3f0ebfe1870233fcf62fbff39030a24ad0b42442bf0b5bfbbabd31b860d7cc69f55a2609779de179297a604e86f104ab03c9354809ab7175f1a9f2e0030df5b7599be9c9ef8ea8851ef4b463f705bad480fc8653bb4e4f3bfb087b43f24a9d94f5c6845e847c1f857cd729c364660d08f1410a8b6bfdbcb54014b65cec04fbc356bf34f65e09f4f12f27804ac60b5cefd8bd31bce3cad2107b6ee6fa198c1f0aa5831f94c22ae8d17a34dbb8ace24adac714e0074a6ba9d105e1d7bcc56ea6197c91b6bfd5e2940a35c37e527d29d27e55fd182aa4aef03d5ff26cd514dc932cac75760998a61425553a8603f1fc0e09a21b8531ded32b0004d18e5f680bf95df6a3b1e5eb48aaf24e61c9a9f0624201d8362b22cdcef3dd42a03ba1cb697fdcfdcea0ee326d67a5b987af2ba7f87dc696bafad81c72cbffdb35dfb020b2f10a66a2e32c5d65e11acfc1175d02a3d4a2f1f1590ef2e20e60fbfdb4982d109bd2228ab391a897a5557abd894d37c5e91d56de68b14aa430d9651198369d02e599b7c182bd2908a226f3f11b1d214c25b08f393d7d1e45a5053f3a74910219f316f0d5031c7cf5be3a47d2155f51ad1a440b4bf32b1b73eb43aa9208524dc56b798767c22b7528363fcf40447ee6b540af7b4b6870bf05a2cf798b0466dde5c999da04d6d8d36f57497731c230cd403938c4c7119dc332bec2918548c679b8e4ae3e34e608672e7df14dd4d309600519cc9ab97746b2030afc42d245e66caaaa94df7436ce80b1aa18fbe14632ebce43f9c323d2fb8438fa894c3767775515e01bfd742b5b271ca483f1dd57d42d4539e79ad446052c47644168f1f8c20e88062ecb9147ccca7863e0374d5eb3e4e475d98457bca0508f14d2aebd90fa722c7a70a02d63db97747a60f8a74b39f6334134f29591791748b72c9e0272e176d6ea663178cd7f25e46c6627c8ffbdd2da9999837453f4df2e51985ac79658be645d9df99786a16cbfe85c7be8aad694710dc43eb43b3f824eb7195a2b53c767a2da7e9f7caa26ae576f4f4ee61a1e3ff3d2ee7d678df946b6ad10376f75474632b00612c136119aa4f5a95fb37596fb7f39b026c9ce515995a82fd0b62e902a56311760052a09b6eb79c10c2c573c3d5203d50356e651b71a9ed3f2a155c97888c95af547cb0542f88a0144ab5a4c0cb8f77074891d07bfb3ad402c9247e05e117ce499c5c981b0747f71d2511f2190af4aa1eec0d67a3f4560a5213e6304512c815a59dc6838e8b5425fe63d370b5a8d847ff5c96788ee32b878eda908c621330103733b8ec557ba436bdaf018ce6698cf182e0e80a7b07a1f8e168f27eb61ec0a602a6d05471a8473e53fcecbe00a4ebd74aa4379f5af0481b0ca4857eb34aeb50cf8b22138834bfd3c182f1463663d8c3cbf61438479a970bd879b7ec57cb0c9ea12d279d96104aab4a0e505a10f7232c89693f861b277ca6af281c301ae5c4b65fffd7f4eeae8d079a4279bcd5b3ece213b411c5ab978c66bda26a26c03689378c3be582dee4316baa2601ea9273a8ddfe3a1f0b9d2c1017c14803ac2ddb1d95cf3f141a12f535c4a6fc50929d69842a4b4a42def767bf40643d1f031cd0d812e1995700c224372835ce99d3e35af9cd3b3e0a1ab6ba8de63c1c57feba36e39754a75c4a1527fa6f77e29fc53814f5ab5d68a7ac7f7dfc2eb53548700230b066ec93171d7b31f018cc769c4abc43f2b598880c661c4b625bd66344a4abec0ef380dc7e49166d63cabb7073d4d5ca68f99c6fc787c53f9741d57c9ae9128d59189983925dc5cf30a1e0da6cb8d7993bb52af065b4bae75e87aaaf0d0aede80bca60c76107896f420f11f2d6d79622d75268e048e62d101b584365a52fd58546f0df910477e31cfab7443d4d66e06fc8ab7791878516a1ad4a553217362476a7dc948365e9b53d05ed2cdc4e80ffd2eab1c6211925de5d757e5cd2a6213f46766439c1b52ca5163bc5156a42a8e0818cba515c932c9bbd9ecd4bb5f7accd6fe6b36dd7f501c97ac42af1af2fc083b05dd4a4e1da73c2962621a24ef10fae0d52c443d4bad197668d75b581de5f81e32bd27c4c871a0f7e80046b7abd317fc483f1fcc1365f261a027146902f330e98e56642c5504dab99b5764bbd77ba323c05c81f184de0d8e6db15dd10533573e3372de6eb27d4ddfc89ff61813d7835726d0cebfbd8420ea1b3ecbd794fc97ddad606c9e87022f5728033837f498855a573f665013ce8da3db27736850f3be319b743741ca23eb5f33b1a371efe2d7e8a75eaaf529850785781743694b9ebbf2262817df553569bfc256636946ad7584b4546bcd7accabe65d6c7781d823c7883673bb91dfdbf7056e546eaf55d7a1b59bb4b1099e722513bde2f07f64b7baffd50b949b529bcf4c3cc351b255e8f4de78b74e09641c1adea78178e2c1e9dbf85ca7e726e43aa2b44b69ab893439438d22ff4f1d9bc72f35fb8e66bb188311e427f58f88ed5f7fefb5223da2ad10ccf4766e9d3c415451f1e4bf417a33ea1129b19b8d679852d6ce03dd1e3191911a0f6f76b7ea61d4f73b5f5aaafb37b6e9814c586fa571ef0cd601a646c28f9a5a06f13725708ab07383ecf986cf1b49f66bd78114fd413324348cf39b7e3fe2ee36c184155720047fe05a1660524f5badbea77e774cdaa20cc126f23bcf77140cf84f1a906fd4a26d418391ea9c95a343d24f868573854d916193be8a4f44d2e5950538cbbd91aa63a6b1651db95a5408f43db861c35e57205249d7b29990d0db016e7a423d290fbc11bc298552ca86f5e9ec0b728a470718692ab678c49a4550615b20ff75b3c158af5c384baee97016ea72c42d3f447c08af15cbd2ddd75b31496730236da535a0fe6c7fff0bb1fe26dd7f3ae89ce92159cd954391cbebe9a495058bba53d62f7fcebf5fc653a18b0d9f796c03062176336b109784bad093c1ca509a103fb3ad1c7f2aa18f9de0f036e8185388e406c145eb791ddc3b4fe7f46d8a1ddebd59e7631eef52f5a00d2460651034d7a3318cfc6013ff1186e11c8836b77326a66ac18b4493747293f79f45ff7c4621d51b0951e70f416ef90e3826716539545ed7fb44d2ef92a7f6244a8efd85f0235e0383672b881fdec05e7ce1159cd0878bfe829281f9bf49bdc1c2df6b8155785e374b17313cc4fc14fdb04e4abcb1ab5b555b7f5996f48b396b56bcb757134b603f0ee9505d1237ce3454e859916eb905c723ec360147b1fa6584bf0a8c06d91f7c76aa5a110bc54d4c3728b0a479a6cd513ce8771527761d075b8ab03d4e0b330521dae2f98132a43c37628d6076f322b82ef889bf4013c8a04e746a8600a9b5243e591db26045e06548229e8dccdfeb22ef2231de3e802afd65d1095fed76f7de2734f97d7f588ec5065b8aa4e1fbfbd3b40373205b869bb399d40153df46f910629fe792e6bf036af879ca3fd9f7dfc7aea374e1a7d716d6809b68405a4f3d7ff28cd48fff65626f42460dc4c1ad943fa3b797ce53e3d436ff94f4705bbc0405977742052810cf5d147e46a2ca7bfeac46494080911e887d37245281b788051b446df6a77c785278986614dc304617d4fe33c7f0fbf8e8b7dea6e7a95b79c3b45128da14718f4079d4c18cbe604a0f798c5cc60d505a5373cc3c9ea4d5b1d20f48d5a8b1384a28cf4e2b1c5edc07783aa8c207a5f89eaf22cb33d69aaafd846be0b9e6267219f287a0c0a8d8655501487e04876237d28305f5d15992ed12c496901ad532cefd7d28b4ef4a2a1aa5718fdf52f34d67241b25d7b7a7569d87abec4fd3e46faddabe529f05ff8eed2a951d4788f3c28166676f52af305cd6ade72775ff893e1b41bd175ed6d6431528bec7e12303e880e482cb2e95ed7c09eb3d14b2c788caef6ed3dc21d044c222a7d03f4ddb21071dcfef1275e5c062107aa026a44d62351524285495eb527a92618135cb2b995ebad7745eb11465021505b22c182349e7c6cecd0e5b02de4af744d2494d357981d687327960b2411067dd35536edf0bc17957e4ef6f603c641ba11b1fc79f54506258028b0b6f0000462e28575bf2de145ef2bf09e568d8c76cbcc9e21f28b5a5fdc19a382bd8fbbd9f7f7b899fc79dc5a935c5f787b58f02a1b719daf0ea22335712681f53d800498e34cc7b13921b880ce8bf9314ebd97a10c1a8d4656fc199df7374ede396f0a7144dba9588bbf2f7e4b288c8122ae4825aab2e0ec758b273b435059a7dff3ccdbc0c8d8fe55662a0cb7b56e3b6ff3eef4eb2dc56a8938fea360ae7dfcc69866bd784646815cda72ba0f7f881cbd99916626db3e06b2df4446e4eec2eed9270d733f0a9079b29d4501c238806154187029370f5a1f317b5f3900b920a5a3a7109f6108b6d642a42ac900aa1654739a4760c13cf2c425619790679f5fb135f2e52889c04155d6d65997fc682c255d14c58d13956bdc13600c35bfd2b53bf35b26c37482c2db224fc2604ad2f1f3fe5204118a5ff88926a0044d2e7469dce6f85c71a937fafca77f2783436d0bc0b7cd895b6028ff596ed515ca9bb35dcfad87808aa29c83373e04136fdac202c8ff6344aea7a61741af108faaa1b605fe23ce6346e2cd70ce0f1f6ac5f0651f35549e2c89ba97d7ae628d530ce3db6500c46ce5a33c5d2ef8da1b5db54f283a78e493f8dddfb274d1c7d7a3893c8a5a205adf555209d5da4ce2e6754d2e78b379a665a95e0be23a4192096ba1c82ae69e4b784c1abb93e585c9ccbfe03329688434b451c39c893824a01d81f941648e64f7cb802c640cc771b6924d79f7fba3ab81da6562f58db36add1ac13ceca791b71c2eb0bd4d3b54c11563198cc1703d93d328780c073980d2f98cc3a330617698f334f8762a05632f2f82ee44551d6908efed97eb644449edc828bb302f3e7921fe27a83e0992b4606586664f6148777ea97c795052ff8dd54f74660eed0767dc1d054f39f61db5eda5301ef2deceea0bc2093109454bf212f51f928d5be6c617690eefb5bf6e16d5445aea5a996d434a71c2bcf75feef59f7fbbbf991ad092f4f37269710117bbc51726fb05933465f930fb94a0e6521b3b350e96f7e5d3188c00a7bf8d6c21786111dc99aaf88c6122f890a6187668d208549ddaeeb8cbf5bc080cec74c09a2fbb1a6fa8720dbd34241b921dfc13b67b4a10b0fcbcb59bfe6afbad5f957f1dbe637687dcad7591d11239ed194e8d095dc0516994dfe73a56d1ee11822609df5228abaae5826a98b4843bf075410f7e8e08a8600dccf5ebeaa9b3cd140c18d6621a24f2b15a4d8f61ad3cf77134f9c98abfabce7bab4329f54df4a5740dc60d7ff8051e5e987fae85213c2aab130acf641a0498413b730d4f4b41201234e94eb9553cfa42fd2106ac7ab05e1f6eddbe866b5cfbbbc70e0e8c0d952e5b5007bbd6a5bc4ea7ebea1666f98e181bdff64e2ce656493daef1a0cf76ad92399e560aa296c1948dd6c9d435685fb60862201ec458fc56f2741045ccae6c958a0e0cc9cd9b96e9013bd09e53d9a77f33621652bbba8e01e658811bad657e3c53edfa30b1b328eb81219f487c94c7ffda9aa5527d0d910739784f7bf292ca22a2d2a8ba28811f6890ee1d271ce7a160887eae123e571600f8c8264837780f229d0d89f4d86fcbcea7321468b3c6385b0b7b4b90455f3c7bbc004d7956311fffb5eaeeec3f801254bc08227297ef48adb56918f552254a6dccae9ac65fc2d048932903fe90bc6bcf5841939fdff57eef528bc6b49c96b64953506b8b098235d87425e5994562ad1e6c35a47ec1d48068e45d733454bba2b977fbf51dfea8a3233fe5af9e23dd63a2ce604b152a3302179d1d83530abfc60043fc2e5bf1c8cc952164bd272d1ed3ac0335dbb58112ad12508d76b33eca50d91f25d67b6ba57d171f5ba052c4ec87e717fdd89d83b65dd522249c03555de64cfc8f752e14f1386e416447b2b439479d538dbfddbc899b442f7559045da5e24d63f1054f8b7dc3fa6bce5b8180801dca98319cba8741ee2aafc51bcea456af732d3b0855233f2213e3e015e070b0a915e48ef0f59d7f7b47c3aa6ae9a1ac4c8b234ebf2264768b775e573797fd39d38d7e7cf4af2de3e4d121916d807c8856712c505d19435adc281f62d6367348fdf1bcd4aa3c2f5807321bccd280ac608ac5433a16467fa9a56db777e67802f7f6c1e2a0cdfcb20872d6eac2b102de356fa534d73b61d65e2bef3f0f978dbf4b8704fab717dfbb4bcd3054d0e73fb195e245610d21efb5daabe122a5727e2ec243a922c46c36c394f9019c86a7fb9a8aec0ef7eecccacfc72a2a2f930b484b976f7285270fadba4d75ee4e4fa7acd8b5e7110c3943cbd473adb235a7a263e381881e45680588ac7025463f09276a9dd018e9267e212833a11d19e8d2de1835c4c6924a712fa8e66ecf82ea71daf8ef5a954fda7a62d8842d0fe3407ca18ea384db03d64314793be235ec2fc164638a1c052a6ab6784034b054aa6f23ba1f1ebd5c490d34b0a45c3b01711fda56a73d771d5ad0c5616af0709cb81793a91b3a6f7628d43e1ae6c61a627a8812d31f94ec1fa41163bdfc1f0c03c26ea10100d5793e05fbe8c23ad49bb8fa5aa8f37d4963e2aa9db16653a54423ad49d59252aa04e23e8f0679006d81cbaead182c247ddaa3e69b21357662b4f02a44aa56c8ee4d56f7694c959a33ca9fe4b47fec62b27155ead9aefde782b3b4613d5d85c9a01eb71ccc2ee7bbe5e74fe681f9d96b212da7f8cf9f17ee489f1a76318caa153e6b776714d383a4ab73c13e17b71080a45ce7becb2b045616a07798f3ebbdcbcbeedf6ec368f5959396d9c5b9050498f98a09390727925846b4c988f3d367b699406b2e5cd4a885c1319088adf967c70469458ade1d1473bf75c33c24d4e44e824a5940878390d5ef5d1616dfe05ac8804585dc418236b4f0df5ac7abbbc9bd5bcbea4b8100402ed795e259c74dd69b59d91648b5f7662c69f41fc1e1e371d73e93cf5fe6806e329f34f5f9ee671d25c5359095268d1b9901fb01358a2a4356cb411cf1907a714d7c0b619e29fea50568530af7863d932bf2e87c44b950dc602e2747f4f1e4eea3365fc035f4053ca8caaeb002ede1372a3ba722994578dd09d499c0fd268d92b6faf460e09b866d5cd645594dd366c670503c3dd7d57ad55f48305591baa4e8475d101a30b20a1002b610e49c33d34124fe3ea623189a1f9d8f7bb7a215c1883fc3163cb938f1b54cfde7d5ad272c94ea28ad3f60145eb9fff961a19642af4c68c283e04253b3eca62ac69a42d2491f373129531e14c7d5a00f5914aaddf38bffbc593d445d66030f7c2326dfcce8b71cdcef7cb9625109dae3ef4c340e864a7b9e71b91d872dae721258842e3ec7f658e5bb7fdeab9122246616ea73811c7cbf350390ad36d51baf96158c87e2df7da9caa3ef6ef917ce95079af2641b93e87d7fea1807ab751d54bf9e2f979beb11385c92901940d80fae966fb047bf208ea4de1e39196e2c46b6eca3482e3b27f5b659f144f8b4e64fcff6aca4d835b9fab699c91e1ba618adb9ee36de1767c7f92d145b5fc64e4f377038cf060b3df69985ba4acc649298978b982cc70da254552d6fcdb9d88ea69aa9c3996b7e33cf05c7de1a271b5887d0b4f2df18d031c48e59a42cef6e7a4ee8d7dd27f9b59f12f97ac108678bc2c96476cc55c929054837d145414fc85a2d267eeccd6a7186157e96ac4f3b8b6c3f78939d1112aff0b7da7271422ec4960c60568cffaa0642965d2815a97e2a09832ed33e66dba136eb916249b33d317f75e1451f25fed69c16a2f82cf6e2599fc372f0dc16dd33cf35bda25b29241e354093e493993e915283a98a594ead92e1ef8473699b57faa232677507b6cfac48c08a649b26dc5c26080faa56be0d8d9751faa58fd224dafa4c3cd1de39cf74c3200c924f11698fe7da0089dcad36687ebf7c40cc05cd85aa6ee53a4bb4c512d107dc20154fd70de20e73c70a3ce6db7c315ed744ca2b21d5321aaacd54d12a929c6ab36c35a37e9c844e264319140a094c6e36147bb0d511ae0b0e3f3538eabb4200e5628f9e99a868a4b534b917aadbd9dd14008524e93b5c402587b219940a3057e977766677186f36bc4c8f40214cf26bf19560f7c894482c07fec76765e5356644f2da1e5ad335f4a818d2e8ecdca95420ce31b8a31df5cbb24ee813730d47fbac111c40e6950be2eba390a7fdb755e6600ffd5386270bf97449127a3c0a53f037d292f0eccdd4e390d362dae536635986dae3d96848f2786acb0c32fd930506badb311fefbe8896cbde71a0e65619d5b9705a35111d59c8035153114cec1b4d27d2bebe95f2897c037df2baed2f38a13f7afb1095c3a6b584f9c69063af6f61d759afcfad0c37cdba7943bb0d18edcf08e64d43b699a9f1df26eddc7a315d4e1d53722207a67276f0fa7188d72cafd294c2513100d80ce7852c6f2f5a1329c1eab2d66ef2b3b0654dc5ceb49554b4ae4723dd385c9533c5658c1a5a47be59c1a21b1479f25de281993f0a1320a3b08cf72072323f59cd755a34f5a34280c8c52c8030691f73929ea47cf0a9729ed3570f7e38e829c02986be001533961c57d8880b70e62381dafa609ed446a8e86af77200a63634a07877bb8d3ab6762fa417d1a84d6a394df120ed741f0ab10c28a4a2735979889ce4875a1ea16f11238203e51dc528d1a6a7b40f335fea08ad34b9a23a070794e8beb8a5e95f777dea0de1e380290efd57b6b5f8c7215dbb405890cc003078b69bed88b094f95dd3e60f8ea6a7fc79cce4723e9bf4e9af245a75282d54789b1e950d8ce74f68e9e96750ce8ca993cc601312b39042a992c6aa8c387b0dd181662658724d94e3846c911e63aa00114851d0403a0cc2694299c6da9e27e7891db363dd054b13a044a117d0c6d60bdd7870b5939c49ac8bd1a445b4926bee34b96c91c8ee469b590c71122e1148ad81d244ea7236f518b2302a2e55fb541fa0a52f3ef716e93878856617aa5da24f49754822ab597c38d26798c24f81e1497c7f5cafd61694253cff8a09dd291cfbc75c022b6b113bc92b8e3aec49a2267d8b18aa6f645c0a2d07e92ef16b2dff97d6bc217506b29e2446cae4478d89afbfea3a8fd8c758b05f8d9bda4d3fe7c500c2e474de405e50af46c047e76ccb9b415288a9bf65ed0e016bfb7906efbf3ccb97ea3c20fa6da47303825f6103138b8962dbd8110581ba1bc843724679fa746714a08d829b6d48ba6227e7c603bf0f2badfb9e8e7f1cdb8da496d462a18a115fec7b433c7324955c9109e52cf550c95cac02c948ac8b7216bf4ba8198b0d22c2bad2e659015952628aa334037b5288235f04ded8e3e668dca936adaaad260778cb7bc994c73741fb75d37f1bf078cbd18efc1f6ffb561949523fdffea20f9f6b4496619d438cdd6938890189c9298be9460ea83c8110725564cd84abaca28485c02b50f182aa8974e8e6c96b2577679e568642dcec66fd4b596bd5c2214bf3203783f373a439f6a8f698f8b47f5af03be446b4c326adec19cbdc3df10e6711b92147a5ef8a17ae09d49e1bcae5ada3d07a326eeafafc26c2576200009a9e7f28b7aed18442a462d8cb59bad6d8e13a2433605a930a108bd191f38f3089fdd8d96ac2a10255fd444dca1f14a48680b19a7d5fb9e1b4c50d501fcd3d25c5cf624693d2e85a417c128737f7e9cc5182f2385835467c3c7dbc12d5d8e7ec0bce26f64fd21ce83aa0d3acbfd932da7e0b664f11c1d7a7f7dbf455a16ab6601def14597d5de6f916f5da193cd12e25c1de251acb2a181bbeed798a0082197005ea3742be4239f1640f205bfcbb979ee486b15b44f4eb7c23938b6edde35b007fb81a4301a24db2fbd52a55e5048dab92e65aedf078e42437af3a557c27e5cadbdf5167cffb4a7c1082d9527267517e1e618c08c4d1d4f361a3674fa6272b5fae5d617fa6a71ffd04722d667f69e20f7ac7ddc1c2a9d101bb87691334154e66b162fd14f8c98fb15558a3c1e241cf7c6168e26666554950a51bb2b7814d6286f8fa0c498cf66144971e805d979813aca8a1dd35a203fd544ec9245efa132abebf467d2f538a4be451ced780009716360cabaf2c832f8542f2bb1d2f4dc4a422b19fc2e517b34a1d3fc6162308c43c5e49a975a03ff6ab31301bd80bcc868e7f04767b5954f733a637655e4e0d19fedabf989c198fee94c60b16a56361e63e5bfd8a408bac42602dc5621beb44433aa75b57a0fa7792dfac19b254a7a6444a7fb652b78f415f75da7f3dc9b08e20780b9f6510ff183c37a2969f761274f896417cbd2efb97ff94e995f9e78e3f1fa2a3becc68710e21322cb7581d60e8e7afd5597532f9ae442278c14a54e6fb5714bdf700f89347796ce0419828c6a8262008aec6d65c6e2662d548db76d06a96d67bdb67da5d2be6f44fca8629f739728d05f4c4ce35d9e14aa2f8d3720f3ca33c1883b31349037ab632f84fe7a51bc315bdc478e8fea57aa8dc7bd1f019de24435b1ba506f56c6be097c2f345758a41e521564381983cac7762bbaffc7a69fa7de2826a08c027365b6d8f848af3010a3daa53747c37164526d148cf9885f3a5033ed73eaa706bc6117206bcf65b1eb52297b601947ce58304130842ba6a25751e19eb71af40be312cbdc929ba13c787d7a62e8b6fc82e5f3d70206ef50443366649b4140ab231f24d226d429899341c73ef096641a7d1ca80587b87684763ae51b145cd1d4725c26c50d8793414dd6a9928fa302833b11e149d99b6a2566160d3816ebe5900ca1f999b268f37ee168224060673f3ebbc72bcb20579adc6a512d2d7571e916b25ebac4a2533ec0ea501804d5298f3ddd3b967d5065eacae5cacd6659b0a6882f15aaa21121bd76d4f208298a88bc76051d2493cf4767b2724d50b3e88eec518b86adfe58ca5e163dec76892767ce10d455e2724f8bae1f62ff252b3febdcf0c1eb99e7236a594d40257eb4c6f371ff20cf75418a80ff8de5a2aafdbe32039274110ee2d3551797b8bba8f5b934d9b06ab782d5a4acba38a276031d12bb2c5ddf2494d037c70bc871ecf8ae509718d1e928c2f0d473766b448f661ceeef3b7342d0b13a7ca0db3f00b3caceadc54d4ccc1010a7fd852fd3387ffa768d66aaea5c82d0e17e65b7f41b2516a815d5d83713f0f46fa05675b6627303c6956a4ed89f84eb9dac89453e0e385a67eafe41305d9823f7be3cdc1e04c2212a9a5d6e320bc49e2744a453c7cb7a08926176264f51d0a0ee721652f08bfc9a0dacb4dfb4393154cc19cd2cf6304b47a0f7356314993b50c7d5be78ec8bbfa1f10e93a9e0a458d23b6e0ae942fc59998d7181a15ed790af7c538fe9d41c836eaa8ebae7cc450033877e32cf600e3a48309a82e34e527e69545f63afe8609727c328deacda954e24be23528bea6cf9c554de924422dc71159b3c0bec01059ced0f6e16c3b5cc00e81b79a91b4223dcc963b641d991fc2b345ed79137783c583afdcc749c66edaa05c64afce256f73e711b0919c2d72a030d6734aed324f1877c3a1c4adcda85c3d7377842ac6baf88b37943b883fc0dadb02d065a026dd5ad4f42dfcaba9ab2f37c0575adcf7b76e851ffef16dbbaba41db13a05a62b6b8a1604102b8f709952b3b8d7c7d5f545905f598aa22ef826bbd45cc7321b17550e587bc847ca3a4065bd29329f471086b882e5ffd1a95164b0a800fd84286b9f317f4797090cd6ecfdb8d71537c63826803640edb0ef9a5c4240d6ef776b038a44679806782f2f5587eac460452215d04370ad66c6c7754dc02eb9407fa051c8fd37afe7c3521b4dbe62f8a6e9e3ea4ae0ce81d2dbb15d28f0d0e748a588f3c0130489802d5dd6b86c302d31d07d0b56c1ad75804ac0a3c7a524d8e33ca15669fb3fc873e9ef420ba28eef612ad53df402e6308ba5862f956bfdfafc7c5746982aa093c6e5f30bef175e12ea1eafd19f6a8d1167509f27d8f5373470b6004a89e17a8da8b0d18b590f5f19e5b9793eb9ca5007e5ad3676d2762e079079810122e48cc4305373f6e8af0558b81b454056524e00dc154ce1b589a4142e853afc149da191c9cf3c915b61b79eab776bc402f7029baf3dc5d1c263198f6751b9bd073351c00578a44aafa9e79846e02bd7f8c48d312f690b68a689946720106d31da98d33251e12d6b810db7e2ca2081fdab0eeaad73f9b023e507cb785e5db69ffcfa3076efaf2a4576e0220510e6d74cb91919d900211736d14e5b79ff3a8cd845421f710623ba6f9e24bfa0987810b9e04f04208e063ab86d2b7f9d709ea63313fb1079595f40552e1be69747110c0b70689c5c33fd72384286e289570ae9f09e0dc95471a783404eddb1a7b548dee023e897d5b20d1e36cbcc9ff75d63041d5a182e36f87199ee57086bb293d42a3d7c0c285d066449271febbb5bc8bf9f6ed5f479ebebdae755cd6788560e5f97ce5727ddee5afd0380bceae4b4e7fb701c335479bcdb382527d93a321f79f38b6a788d11129dabfae6cbf81703f0a41c7474adcc029307ea38ecc7ffdf2327746e9a6641b966fbd4a16e9221ae4652d9f0c5bbe82680cbc9df6e7025a58c4e38c9eb7d7a9b460c71fabe24932c9d881d84fe72f2fe804c95489e98ef36dfb55d8943efeeeb08b2714d635f2b3863b3492b97e4a7e57a280bb9f21daa4b768d1ade03010fcf397529f2b3ff8ffd7c046c1f14ba4f094df8b037f531e301c207e71c41be0a95cf8bea9fa999ec27b3ae7d3e3041e7d7986bd8fd77689aebc0d25280d7cdd3415854fc58879558a71c871b31770a9b7102fc56533ad5f1b7c3f1dc95a75afbfb2ad7e21b1d92fd4a2cbf10b453701b0dfe8ec4b58a17d40573e4739ac82db08957ff5313169fa3e43635e1b8e8472326c45534e78841aacc068a716a5a8f05ba5f141558bb9569a6e62d7eaaebec4cc5bfff9aebf05918d7ea54d1e811aa84a74496b47fde6bca4750e8efc00b1526ad9741f17677b79b329cc80242fb1cace12591e02fab861d6105019ccbb470cea956d7f9003170937eb42c93a59f32f5e256ea56ab31f53539ad3f4ddf7022cd850435c1c61c629bec93d16223ca6fa1d14048114f0b814551bcdbd5260a0276265eb4c12658f8a1337508347282dfb1528ab610efd27b66db9ef3888932679d928319d8624b80d75f6a9d6cebca3ef5251a0f781da0b128b05b2565370d81218ad0e7aecf25be8e72e24ae276b9a9ee8ab0d95a74bc7a19533f5b369de60c32c048a2c8bc08655dfd09eddccb4b02e065c5ed133b90f25cba2a67e5b3db564179187dee2e474f4517a52049d7863a9399d5d61248c305bfadc05461eac3824b3ca6db12b83924468b4345c70c03c805034f45ed1138067f020b8880882861700606417ed2404d955ddb07d46f8fd10843ec7f340d4836473f0acc849b920f98a0834ebff3b12453d3a1323546589423c569edd228e7979d1cbb3a3516bbdd953c1db9f18be7a3113f9c1201db38964aab655d0243e0625f88831e8cb23a0513adebf3c5bbcce4584937c099ad0d47650f55b77cec2fa891e22ae0b3a86c4c9d394be4d7ee5ea9b5507ceba209f573eb623f94034a651722f452ed4006a2f517201efd3c93cfb52266cb26a507556e224574dcd458c3d363ae069f9b552275439d2e032491d094571ca9df628b99711f7acb74706e2a7a03e461f7f6132afbb7544d212fea10f1f1afff60065a63bd933ef022c884dce63a8a2718a85ac10e3dff1e8aaa07192c140c93b57cc6998daad16d66266b8033911b2069b18e4bc5503154ec851e4ea6481c1b83118f320e51e917b628bb96a095561c1f066b905b5d066eafdc86b979375e455e1ce5a3fe1310e12b336bddcf55b1e06768fb39a349719d00d16ba2fbbfb5ac9c88fe87c124b196158471a676d3bbc7ffcb7e7ae01b1597848ce364c237505c3fadf03d5408de0af0096d4eda78439aac820c4d7be70e8aaaa61ca98be91e9f4730feff78dfc9d230d4be94eeec9b0545e46495e302c54f347a93725a6a386cde35945157cd48a4eced89443572a3f30503105052306952cd37a5f2ab1bdba5abe8fa2bfda0e152291292f6498cef486f0d83ee88a6e0af2616d13b506d3e437f5bcd6117a9a4d1c105e183db69d59454f0f6af2dbe10a8f3113a007969b677bcb3d98385f48c999a443034032c6e6432d0a2e038cae057e0c12013c148b8d026340ead2ad838513884b8c8f0546218cd6253c3b51f9149662709d97c901670deab212efd21a293f7e3c16487490b03843d85987c52b75f51a822f4246f16ee4c417cc9d14fe0dd018e7f468af75ae1ab82cef382955031f749a5ff8d1a0fba68b65b2ff2e3ea845ad6fbeee117b4f7824bd275f7fb5181d61d9f51d4ac7432677aab6f34c52b1be1908a2df0e1e571ae5fb18c74148d8607d60e7db230bcad3573197b0d35d334c1809943d25ef49ff142bf01017729902b6dccb3023e8dc89c2c1c41708d38ed53e15c6fa0b1683a0ea74951d6563565f34edf2e593815c3f8f38d0b26e3c37a1392d8186560ee370a04eb871fd97eb86d7a51cdd0174eb8a33b2425ce50ee4e39fed2d3252a4aef9bb808d8ea2f0995176ab22e37dd2927704f1fc0613409174ae862c198a0e3130ca05f0c9a97dc3ae0530beedc1e939ed3ecb2a512cb8331f406eba9fc248b5422911ffd6bc7efd7631cc7068295a760f3b7677fd99e32dcec8a04fdc9dbb2cd176d0f5b4655042b63412c73244aa114e877cdd64f726155026b0fd6cbc541bbb38c682b68ed76317d811426780a030d4bed49b5069dab39d60e721e70f3c7b8d446904f328119a9406385098e7889ad7ce81cb2ece9f2a6099ed13e3a5e35c958c5e33b5271afa35875501828761b6ea5971d9693f447ea927b2fb20fa0b4ab2004328832b6c1245e66d4ff78426c29e4a10d246961c80221be20fd06b8c8b63610229be42d48378d3b059e581aa885920f73d61f3e44b0805755e4eadf160cdee6932d6facfa04f4d07432f5efeb48e69de7142b611c35bbe13e5d266f06acbf10e052fc70f231d9b5c4b412713b56730f263748f86b362e3defe8966a531a655711dc12fb80411040821f7672efdbaee2b80a98a49e51cd90e17a81d575c350ca419c7493805e7c74043c307c6e7c7b7ed7db2f6dcb85829b5e51a1514d90f75edbb40384b3d51ef7eaf1264b1375872b8d4a454657b53465d790b1d97c1d43ea28b61782273b91859a6e15e70adc6d6c0dc0420f135ffb9d76570fdbaad8dc19a80e04ce0cf89d6b36ac4327137838fb94aabd4e96302dabd71a475c771e8c20bc19129d67fb121d2bb711ad09b0141688c5578785f8d7f00c90b7cdb4a176ae52b5079fec19cc0e7ae843f92ff54d7d5aa1bec110275d42ff5fb59c7eddc1b7af70ed52542b7e67e827f91902a6c9bbb35e88e5f88a1bd892fdcdcc863f55866b01ae71d4a58485de76c6eb25d1e0fa11e0c1580f30107f91578becd3b5229971cb2ff67713723336ef76efc59d7b1f2a1e904c59766264d2b7d8add1f85c7f6746e29a99a509d94f469b96ebaaf99c36baef6790e0","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
