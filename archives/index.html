<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d415fe546571f71d7a5e5f9e1b1664d914701ce13f113905fb711a160c96de5964ebbf313e11d971e201cb25cdc157964d703525cf069006f07c9aee2d428cde10363a052b57d46a1dad2abbf5d906ffe5c772fe75eaa393361c96aef5f686594a3211d67d68a6fe1a6a3f69ad4b5434ab2b49b06e9efc0633812026cfad7ada968a67866785bc74ddf35a8a66b790bdd5704f76d42b8a5312363ccd4bee09d07d555e23a429c9f8b7bc06b3de588b1ceddc5705742475603a9ef27d293a06598a4a813afb8b5430edf12da47a9047e24e8f5d4bab9619543d4478d1117b4039ee78cee20e80e974d2d4c3c38d8b17687451e33119ba0ca366c5f3c411598964498754cc76fe47f8eb6dcd0b27811cb17dde43f0f2e0ebf94b8d76486ca8f93acfa7f2cc49454d0c3e3e50e851b0f6fba313c3344cffa9eb36d618204afc8dfb509e1eb68bd840a20908c6bf1242dcee81d38e014e4cbaf158ac769d59115125f21f57ec6f27dc5bc0fee0c4c18f79676cdcc17d1c1ba3530f87f880e60ce1744e77d428bc05cfaf78b346cc5b1e04adbb3170df65c68604586992b6ca98b6ef998b9af46ca66962ba91256624a267a496996161cda1029484a88626ef70ff6342ffdb6154d06c226117d9fc431b76b2d6eba259348622ae9fd3a5013d70d4e723d3b2475701fd9ff4e56544a72b774ea5785578884078bc95351cd83bba0daf5516a556695682917ae3d5e00d66b77b199913603fb18eded06344f8e7a198fc1bbf233ecd60b2cdd7c57884384b0cfb0fad59c049edad431cb1d8ed1db8ad58d77cdf658d28c65db2fdc4d024fd6fd87820aa2d5afc959ea3d3c5ce5056a870df19ee9923246b84d237c90bb6e89a73e480951ec2cafde3ed99f4b4756d058051a271c88ca2a9e3fd721fbd8926507113329631678c4735ed33b7463811885eaf83b9143aa06fc7dab5a514399a6a1db7d1c7c37d927e51d2553bd7612ac7db7bbaac30b18946161e7dc91f2a3a81839e0bd172f7a8545d388186f11a1cface736cb8b1ba6169b8947620a287c5fe31a1d74af5007befd9e3bc7c05ab18c69312e57c44e519aa68750d3fdde1efafea559f7a4eb976326dde49c836ee6916ea520989c75870eda418bac2074a4c3e1b029a38722693910a488977f29bad493157c0a9f69b4841a137dae4d41f85418d2926cf44c0c12c46e2bde9d27f81b71cf09b20aad0180e45da7b5d875165463d4f3ff295b48bc2cf58c82a16d94302dfd98baa16a908df16ac2853ad80b5ad4084c857078d8e93df0233d11a364249f2d628310ddb7483113f507e10b70cbc1a4607aa87897157511d7061c5b0c0218636e0546be7650c49699be625a541463aafcb9ed22cc63085675bc82ff496412c9f6558efdc81a99828956332cb7a1a71e51a93ecaec23c040726804c8458e4b7381ee3c0c5960342bc40d8efbeb1ff93ad6faece62c23b14c720f84cc5524a6f3d52ec59c98127dd50cb520ba9aa34c494df6e2117142d7f6f9af789cd6ba4a2169abab307e43305a9264591ec8a5bf48e10706f628af44ca8dfdfa7809bf90798969e9124c1440ae85fdb0770dbeb35402b4528706b85a90ae8bffef01e31cf248f1229c5f36d1906174d648c243fdfbab22057ff9c26c7b2532c8d4679ce38903043524a05b42e96805ec77c04e0fdf684563a6fe98ccad143fb1ed819f205087a51b9174e67d4a74b72460230161e0e658d9e40c03cdfd7ffe764710ecdca8aed45cb515554b4a7814ac648e3d64e6221dde73cc686abf2322cf68c298e5ff9064acf3ed9e2b52b0f206fa68bda2d525cff19f822a01a32bd16a3ebe9cfeffe0c6ec5f1b6bfa06c10bdd6f00e7a50b443671fbac090f57927fc61d6b1aa467b4e5486e4280f9b4f4d6b705a21a99a208d9360d29ef4a80621a6f02141ccf415f376d639944fe9f689f7b2dfd81d71df0aef5edf7dfc7a25b9111122fbee0ab31571c810e45837221da2106acf8ff4a2b02a0b3129b098c264842098916c45b480007f73b5fefc120628d8933309ad14bb33771a3f6c5569bbb8bb26ea24212139961878794dc7b21fd23c6705817588b99fac88fe0146426d20ea453288fb1e75f7c16032c8668fd4ef6b3d043f8dca807cea8cec3571d70d727eefd7253fa4a9b16e5133efae193a446f6c5c247107fbc8d5f3e9ae13987bf9c03e1b999f1a8313b3f43640474f0848f084f062b7d0238c03d6b61d3431e817597a6085aaedca91d443876728a3138be3f56aed577f47831a3695df26c4829b24acbe6c869b8bbbc1fac29ef9d964a39a9b512acb3ff4f07fa732401b7299d9ff82d93692d0c85cce453989f0d24b6fb4dc148898507e532910cf955344e91c69e73aef210401d2ec912800f8769738897c623986467da89b3d62a74729d2b1755298596900fd3869340c2adf2efa624c21b2f9c4fa36a9f79bc439ef2ddd5954c74d3a17b66feb23521eddb1dbacdfa6f785293285feafb0c17c7cce8a1a80c2a023f41e2ecf14804a08bf568607c4c715f86b975dc5cd956da5f764144feb4aa7c056c7f218105b4abc1879adbe7e8d8ce74682bf259d7a60c506be7b8d1e8e0f24272a1b28b4e67e875fe4b9dcb9ebb172ed37bdc2779e8d080781a3704b067810a2b90cf889520857250d96b866300495bc61e2746e2befc84085dede0b7cb2322937f3a5641c26823ccc03742daa2741ee497c9bf977730fea7d9eb29a0f5673f6b424427011d2ddd86ea08b4a884e41b32c82e3c0676f6d63d4386d75ee2819eb03567778f558593e5d9d0d93bb68979d85258726d453d2580df18238708a964861e212709f64fa3220d11e4eba579945f0fb2925966420f8dac9202110529646606a7562e32ab4eb981f7b4e6eeadceb1e9432d021ba525ba604bc6f4c3e5310aeab9d4b888bf843685ab8527330f547776a962fc8f6710afb3213399fd1544b222ba868c5c6f058be63adae63e9135607efeef1ccde404629637af52d762f3878684955ffee3d33a78c3dac3896ac801d0376e04165cc1abf5cd6453a5178b9208deeae81e3dfa97ecca7a41e6a96660533ea25eba35fc412f90401ccac71af04152079f704d518f127151ee7c84a0fc5c145dfe7a63ccf88b78309b7475cce40741773a5355addaab5a258fe411347a1bb60c8ec757e72d88f4e46a311886fb4e239c8d7c7a53c9e79ae176d0855fe17e12899d8ef439597495d94d3c20ece6df184a17395156abd3bf3add050c9f85170b37253829b37c34f8bad1c5ac07b64b8cd1f99b73b8bc6c67bb4198fd52e7ce02a20ca018047eaadd15c1680a2d78c58b0e8cb6e544208467ada3e8cc3a634efc4527b70dc31b75dc8294e514a55d07d07ef799a447c3a26d7c97c2d035da0b2da655e9568e1601f6376dadbe390876e9fdfdeda2280aa3a22588996fdf4e86fdd91db7bd5720584ee52c6c819347ee0a4b7ae20a0c6ebcdf2076fe7e795da9b244efba7f340efdb969097585e0d1f6fb83388ee87f61f5e3a20bb374ba55350ca4e300ac54da63dcdb4aa0cdd6d595b5b63b81936fd02f97dde3a66e56074960dfb8589d1cfa6095ce39358170257698600234a52821eb8380b12da3e8d44f6eb4552717a1603ddc353f6f18487724bde2b56364924785ece52990ed1fc353d326937fe2b91b2448c374731eb6fbabc49bbd06591c472fe563619072ade1d7fb758c9ca22694af3766d6c694b6c099c60462d85114b58b16b8ce8bfa620d7c8eb02f40a34989f49d13856bd7b73d13e19b47c83384987aa7f3a23553218e0a5b4b714d6e2f40fc8439d00a54ada903f40608674658d6803b9544d5df2d0d34790d78b40136a456c46547d2efc6c5d41ac573244d9805c65d54e0ba5f71b0de81ace9e97ce9cff4d14be7bc27027d422d9ee539c873835aff0225aa4366619367c0a59217d504ec8d2b53a77d8564c78fcba3039bcce4e0ed2cef32ad18e924f4b31610b68bdedeb7bd6d4404a57ee0016fbcd6beecf11a37ae6a3dbfa6ffe9c04b09d9396b316b90c29664e42fdb5de586c9c120aeb052e6abadbf9569df690c7b3ef138bba513c0eda9f6d9c6b3905b39641737c377dd7d9e5d1e2d1e9175919aaeb57a17e516287985a823f6889584945117610f728f0b49f68b44ec63589f536a5d36c8c25fbebc92ab6f54640c06c505b082623b287e785fe81c257e7f0e6f78e860c4fd14de059d6ab9103cc99d0835b90521c1faeebc5f666eee0e7b4e7d9ce5cdff6a84fd1d7071dd18b4c3ba164c3900d35625a5ad4c8a2e87389ecaaeb55a0dcb464ac90435f49cafdb6448251b1e818c92cee3f7ff07be9fc8040b9c9a43761db9a5fb91c28ce894a09ff0e7d88182aac76d096b40245b6b8e51c3ac1dc4ff54d314ecdbfd9097cfce7f4a6cc714673f31f68449add8457338d8da9f4a2fd7421336f12a1aeb9ffa70b6c5e307924ff398c2a4ea346699a2dac51e2637d8df6331f3db3480bed24cff870df70ff0784a9536f094ca73abf6593463f13183cba605d8655c6d3a2e9e6d5d5d61462e715c073941e7ce10516f6eba85b31181a4e9563ff21cff19bab727cca5c89571317d6c4dc7367a05806ec54b473cb209cda7964c3ce7fbc00c2983c329daae015c82da2dc07b31c0265a5939e3bc890201153e94e18c5a26c43237ffe2a7b30cc622967563f862eb14a237e25215554ed15ee73acd63fb9c82c857ff5566a9ab134c6d081be9b3d056a8ba5bd629ab05febe34ddd8076937964e517ebf798bafca8d15fcd550285cf9cfbd680061ec69a6a29cdaceeffb0385fb4ea70af20f7c49dd12dc622f97724e42aefd596c6947ff837528f8db3435ac10405559d91978a378dfa8e7a7196cd4fedd36928aa74581a36e83da15e5d26d8f029b63406f4fef0cec5cb0b736b7c063cdf5cea351e8d75851e78c644657b5ebb689a052df789c011e17926e31f96e0fe7a13cac94bfe0ad88790a6df10210fa43d1f227eeece3a24c0adf071dfb4dcf61c1b2b7fcf70e39509b9b4d0d65a9f97679a6e401cdbef81e0d4056444b0f2ebd63fc5a0db107a66cb81af53188f4dab3eaabbd9564a49113820aeca906fabb9776062eb82e77ed26feb3460771c280fe64fa18515487f3524a25d0508903ff4339fb1e1c6c492a96b8ad118400e35e9475a4b582b5e6329341f2fa88e77d1b5d861f4b0f194a7cb764b1958232d337e91397f241c090754d101523997b5d6ccdf5c46199bc32b9fccfb8f63cff89d6071e33144d609f49c445b117d54770ee38701bd80876c34d69c722c3aff56cb66196ea3f21c76dfe59fd94df478a00f027852edbf856f40d89f213faaafd3db8acd7b6f253acb1d3eebdafb0cc5f4643123b1abfa8c5b864fa2134cf51a8b7ced6541fa18b5f993fd0fa88343d26a5cac28fa62930f97e88b27d889605f6e3c0b3d39b4aa626d9fe4dc0e6df889d1d7899b4abcdc45cd30aaf1473b21236ddc4429f93118a2fc3b8cba2f573abc968d03eae41a2a8bb7494fe6d1e65eb6e1a04609f06fb8b6cad6197faf434aa7c12c7d49166c8bd375d6840b810c29e07a9e5de101eb085d7ab283d95904e72550452a55f2e647f00540373ec8fe3e88dd28a16a467769b94e9a352afb9cc76d6069a665933f999d79be90f536b4bd5cd9fc46c753a222dad8a3907cda39137b4d7819244799cd51ed3b58651ed75b3d48a59ea0a51840b99f287ca7af23ca29499c0bee699d76884e633c3c88be8f949d8940d02b1e6ac509567f9e7c68c54986e75fb8959612719522b261e5bd41a0d8a3e0a7693136c91f8f10e517b4fa4ad977c05f052b03dcafb7625474993d545da1301925a830254abf72ce8b3ed395f10671d595ed9f267601aedb8a1a6e7453ef1dbbee855c9da815da4a20a2ac8a814cc946a97624e4452d3befad7a7a3a15fc9a405b25ea6bb718fc3ba8541bffdfec6e628c607345ff23b672978edab12026960713346b6618e62b9bf6ca51b0944c15030d5469a588eb810ccddfeb9245d2b1163268b161721fa26c5aebcccc516fd20451ed4423569715015bdd816009bf1d907e781734b29842861ed869e6d4758ee4f988e1410baf5f535c34faa7caa7ec0d57ec45730385da1aafd05e9312c6d0fabf3cf19915ea4714ea2339a32596493b4b602fd9cd17c4335b18b0059cbffb1323329e0b07eba0272b724a582d13347bfc0153774281b4926617ad2365a4a36d33bb026934c1b87e5b96249114b2b29278abe84ccbf4a4b2f8c9aee2ac2760bb3beaf600075d9bd919808ba1ab46ce195966a95500b90e730264538f0aeb37fdffd9903a33289ee3b0cd63657bad1d5f3cf38379548f8caf54b3fe2b0881ba71ba41785c9ae0216fae3875e2859f124cbda35b356c637a581f22fc6b062bed1c3184117241f38ee216692ac78ea37f9366fe3fef172aebfe6466f1d96c6525a9b11d2537df74c630fae687a9109ef53f8cdf4571001fd1ba626530c78e7118da4de038f9628a0b00e49803fb7c3bf7e719d8810d78914981d048f0808ca74817fc5b2cd250b667a694f6f3729100b207ee78fa25174b8ccd12582112141942d066a205f432c1946a4d0bde69476299bdab95e88b2fbaa6cf98cd93de417cd52011ad87630cc039238ddb827af584dbc11ec81468f20f86ca3d9f5eac42793fde2a83ce37d33f064e177092335c6f0b1742ca912b677578b7ea0a0aed694d7577ff26cbba3097d446038ccc5f6401cba7af2c794c0628c95f015bc1a2ee31175668e7e388bc1ba67125f695d6b6194c3827ffb64b6faea7f0fe9be68f950dd7b1622734b170517db224f82a1b0dcef95f712b5477339267db4132ef47f2a38c839c48b07543d22ca47678ddefefaae317c0174a83936d294088090a2d4491f689f5d3806c3cf4d14dba24ed1048e9d6a798122ce5f646d8eb41bdef8905285cfda10ca7a053c6fa249474a0430ccfed8ff7f65995fee575879d8adafa51889a8aa61d55258c348c6c8c8ba7f35073824b3e3b33839aaa341d8278ff3984ef4c5b9428abe2452382e180d03b4f81db5abffac2a106b0ddcdc45eb4b66bd2d20c1d7d3b44003dfbc44393d858651de1194812870f7b136b21b21a62108c20c6c431b2b9cacc13550af235356c848f2032b35d980447ee83dce2e227a1672de1d4e909a6632b9efe74891daea9c50bc663346664c589565927b1726b61ea0b03d3c6bc00e5b8e7e81c66a145aeb4c6af7b60b6c429cc7c12478a82ea1baa1f6328c98ae49cb6891bc86f7069e9d519bc1a748954cd9ae4a692a8476fa974c05c7338c314f886dac5b8a14d0b8b1b3d1bdc437d82f38fbfc05af19704aa98b3b0c365967e177c6d8180fbbd8ef84d519e48e035e12f8c3b54638af97b17fab23a8271045a803a8dc5d545850d2491b409932607c9fe4a7b8de97704370602eaaf027cbcce4ad190f731040f8e9bad055af583e0b98c9c80919d0265eab23af599f68aef2951dd4a66b7549a365105e0c46621e290790c105c072abb608cc4c84f651bbad7782af1320a1538bcecdcf17aa57f05b54e5e5cd6c79b58f9769ad0c43b75c86333a4ec59aab40424c8f61aae0ee5eff6e5ef8ff3b9359c4dee60007c4ae7d5a1edfbb00ae82469c817202569875612fc223c8ca8bf99bb4913b5357f3cf74504550b8a2e30618894575e216aec7997fcd2977922d2f50c4eebb40468b583130eeeff5a7f0e67ec79469fdf6bea0f58349fba96039597e1e848b9c3ce20c67cb202a78d929ab5fecf187fb60033d07da5c4594c5cd4ba065cd4b46667bc2e6814682dbeb0904e0e551888cda3645fe7bfaabf174bc9f897c5d60ba22b868ab043b0925bd462fa2fad72ec4023e0251085cb77029d46b06124e0e68e1e948a069b863284866a07fe9f6314eb0e8d29d2dc6def3ac3b3287461b09129a230fe874b91a13a6f4074dfae3878a38ecd2bfc0e38440d474bf17d0b702b904efc46275475fa68a01106268a5506d61e0c49f0f3a4f470dfe4c875298a4cada9af3307e1de3687afb0e53057db1e4391bffdb2fa138b33d63f02e7efb50764aa497295fb72799159c6ffd0412492ae51b0f6c3fc95b462e0ffbe86625ed08d2b01b9fa4b81915787fb9abaca9e28964ffa55fd49b660ffafa239e1a6e6943671a8d1fcf9227a6dd0edd0bb2c3b8e0496c13fac7dd2e9ce9de88c99a39815b9a02f9b509f807f64de3b53f728cfa6ff4e2f8e75193933dde3e5dd2259290f1fd25cd19cf1677d32bf1304981cacb0b8b6b3f15e6bb5b14d8d631c85694a3eeae9d7c047f1a7aa26aa5ca99816822b4dfcef218b5196a5b36018f8ffb5e77db324156f9daff657c9c64b36397edd22fff211e035b91b5b374334e2ec30c04f738ef5b3354263ae5f501a133634181f20ca8ab0b78cbc9b5da8c5ed758dbd1fd825b7f680be0b732eb5038caf6e0bde41fe082f38c91a9b29c5b0f408efd64f391ced95873ba2b49cf7be46ccfd0ab8625aee2601b817ccebc3919695a1585412bc40e553be6c7fce8a804e69e82ab7b6f1b3bc1fe470ef4285690b9266b8fa31b4293d32b09b6869311ef775da460b911d29787e19f68bef26bbcd8c35d29dc005332136efae97a9021701cf8fa2d3e620fd063a8b675f77a133068e536a013357e4d62037cfd12330e1ef62589cdc60035f601014579834bc7d1224100f5f12ec152e6552acbfd0422fc6c18ad718784de64177a899de73234f634df286b4b760a44de4e423624b54c8037aa539c4c420b6b934102152e87dfed70883744c41a0a5637dd49877a07c86cc1ea2fdd10fc0a633784b7ff0f1591405e76011bddae38da20f8335935d5bf742ca949a94b66c6ac14414206b2dc830ddcf77bcd14effe2c68078b98bd9ba08a8cae952c4338abcac90e736f35af9dcd36474195b0fa090d68e295471a29ddc5ada35207a9843d473a779f6be6c206595ff8f83d41a9a1305629f4d8df8152d44d3152cf4ae63a4c4a866906ba87d026f90fe02862bac3cf6f3984c8993579e9bef205663e20fd211d9edd0eed9e0f3e923e93643ce1da5c9804a2de3942861a0cae8fa4b78571006467ddd2829de8354ec76841e446f5bf97d300a4f5d2cc53d28660fa67972d371ded9eefef238254dd895d8485ce83920fe222defc96e3157baa413ecad921b637217092d2f2d8ed78b8a9c7f24ea6b4b7e048fe681eebbc3cb55299e5a6f061cc09c996904e784b64ca51b9f6662dd26075a8fda26d3352c2657692da090f7b5a101c35249145d2f8319e4b4bb28432687646a6b38540ae33ec64f00d4a5c5862fe42f88a0ba541972a0058ccd912dca4a886fc400fefa21e3498a80533196d3b2a74f02a76f9bfe9ef48d42e5b2b378b36c4ef2c321da331dbb8151ab90d5dddcf21a3936193cfbeaa97c4c628c3973ff44bc5f8ec4779177ca86e33e4edffd623ceec52f6ccfd026cdf6530e139b1c1a4204ee5564d7965d8f4ab838a444c0ed4ccfc389b2c7585217d31be783fdc541e221fcf8ad5ab5740c698d0656fffd2f3ce847a124deeeb091ac09d736c0c870404edd4dbfdafe5944447ca0f4c637d4f2d0dcb0e1ab839ba02f7f130c9614d5e0f1a1f3289511c1fd13b1fdd4f3aae307b54724c341b4b9861cc053056e0a916fc44b64f0da339b9b8f8e3fe0a6a5156374384a1192d325a2c075fbc693f6adb57e528ab13ee431ed735f7dabab281bd7c3d3da106bd45cdd72131dd0bec78531e1c6823c6fc539d2afdc9f6dcb1a60d07525f9ac25e7c30f68cca523901a684ee6c29de3495dc13cd99bf4bf09ec467fe1b5061b7dcea64008a98f0d287f22022119e5a624776fe20eb4513bacf31bc26f6c1bd2707313cc9e22b1c7e1720b5e47cc9f827171401e52b6f312f220ebdfffd9e9805479aaa97731fcd3d76d6ab2b68b639b197c7c154b3a65a86444235bd199f4b4e242393eb0794507bbeb7cdc904f2affd6ed49e76e25bb3889cca1e3fcb53fbe19dd97e4bed65ef62c8db1fbc26b35993ce1d76ba9c7d5b1a1dcb1f4dee12575f95b1bd3316557cae46192d1262fc95b8c6ffb34fe61292acfebcc4444c0e02a02789b4df29a212a37591673d7806d39dd2b61661806354374857a8cd3192b668e9cf5d0d4f2f4a6aa72ad82e0da3283fcd66f733f8fe9630f9cecf334c0edca25de76810421c760d2bf9eaad60f8bbfdeeb2146c6007b541efe6801921a8608c2e152bdc0eb06f2ab5a0d49dc7e8eacb526bab9dd422f4931be27092c50fec86a625b91c9d81c4c8f382c0a738f3c82b2ba850490af51cbac962569c09f91fbdd5e6ef87d71fc4ffce5b2218e89b63b49ee9b6f32052b03085d80583abb5de3299340a70482c7c0ef0b5ebd90d61c8513b9608e0b9ba9c8eaa0c44c8b8c05791b700db4a1c0904b53cf4ca206ec60563baa786a6b82a4c96a4ddd95bd67dc7c260012181186f7337978df51347ae7625d9a9efc68d2628897acb2e6e274abe7999034678e85d0f90de0ebb605d1e0317214ce94cd8e16fba36018c0a16d37dd215e8b3096c2fd505c311a27176370274a29ed5a2a1e99e2563245309be9e1c649abaf559f8b3802dc468bc531f0eb5d9e59b73c98fdeb400cf2923c6f2a5b616904868496ba3015ed5911221cb164a2b90aac967bebc4b38134eaf010cb8c18874daae34584ecf3cd35ae145a1c38b79a520913f5009e057e78eed2ac22353be338ac66550c882c4ecacd55996ed71ecedc0efc8be32772615ba9ffb7c304b1f13198970c05d8f15467f33798a49f66f55e81f80b170701afacca088b095f45ec773a46d41533f503c5745038aca32f6ab32f9514b696a5cb55b4f2b26f48a225f33548315e001a340ccf39b9a08c94e840170a80a223a0011976540d32bb9bee35981bdf41c81b52aa20935874fdcc2be534625ce8ff344c074f63082e7629aa216e0bdd9d8134d3b5691e3099278e11840d9af5251e17dd2c1226b2a6116f82bbd4fa5ba23bafe013a1f54e5ef9ecde9977b73ba95c5d39f3cf304e5f7a073355549f58a86a02179c1f3f462d373fe75073c3784c9570f20740af0b00905837fce2ef7d920f05d86d7e70ad61394587a4496faf0686aaa4c04dc805fa1a68a90ab4eed9eb48bde4a9b3157d7a10521cdaf8712e6d7ca5d162f41b627020496160f625c04f40a37c6660def93714b25ff954932cb95f2be83c09f38b9fe8682e026fbed069c637144e8f49aa97e596c1781a1aeac833c980b14f5b6d9cea237c664fd2c3c0c69501677ddbcbe18459cd342e8748f2d3c8447cba03c384576fe70e3abd0ec52231243afc348a396366e017623074f41cc60d31c75f3af21bdf5215023a732dc46fe9b8e533a929aa6991c2492e668a86970b03ae95a17daad4306fe432bf4463f2e71154f015adfb493ee213209114135af028b2e3671cc64c7e716a0a397c2210121933498c7b06cf143b58c5dabc2254753a239298eb178428786fe77bd8a9198e8e1c890860c3502de9f2740c9ecacb93bf93e731efc2267217f13f6e7182b17bc5078e97829fa838ea3728000c3f50d9ed6794e80c82aaa3c57528d1132db0aad28e0071acfe0927cb725000a66fa268a7e840903e0abb22de7c1b9e78655166828c385bf0eaaa06c8dda5da8bc64d23bf648cd9cc8cd0832340bdf5ea81cb876acce6c342b5410caf4c61439119a65f35629713d792487caeb9ec7bb76b545c0e08969f40e1b2dde23672b96f3d7ab6f09171660493918793495faab1e59be76d88767c85c1150dc075f1aac4fe57cc66b9e31352d274c7265119dd764fd08d6db652ee512efd0b05abe16b28f66330d424c7a5639344af7d2922a1858552a73ed4c93581805d916af00374c510b4f32565b2a3aed76e6fa87812586df2a87cacf1195072c33ea796bcfb37fa089b2330fb578940407e40f7e48e6adaa7387d1d7b8d8bfad2609f0976ad95c62e69046b433eddf16c427de3d41df0d0130c089c9d60840076b015dbe08dc9f23c66db015c126fc3c4c4f6098e192409f45721bfb5fe8cbef2f401ec8328857c87ce945b10f2877bd90bf8def3ab44f16b6e498f50323e1b7cdad9095c2f607a89070d3022151007e6b8b5faf2f532721c75d660c9e7906c12201965f54f01188f814c15d593ecb32f16c90bcd8b178e179d83108d695d22a652ce1bf5ad48d94893b2a0632b8114f7900765b860a1b13cafe0a4eb50d1a812394327e3ac2b4dc29638541eb65dff5a2650ab5d217b00b17a7b28cff2463924e0c6387d53d219689072ecd4054d687535b61e744dad4655e18726fed710f9f1914bfac058eb8bbe8282d587772ad89a59ec5348bc8e91a9eed26d9032aa7afab11548e01a9ed225e49dfce56190e84d76e4422b16c5bd479ec2b68a82599917f0c01891ea2baf2bcbfead400018a7e77f7704b12501833bed9acdb08fcc8812c40c901da805c059cfcb888b1f49bdeb681b45233770906120fb4232044409930eea9d8d1d10122d1a43e6ba1898c84f1ad9c515a8045a0547f0b9a7629102afee5f1545a82d59698befeb2d4cfefcab8fc6f6cf0cdfe3b1f7833964e2918dd59b693d64fd90ac6f1a8498c26dabca29ef3b866e0e59d2bb0f89df4248bb2292e904642a4a493a9c210864d9fe71c06abdecb37589a5b4936fa6179a1950f7444722f87a13f1447157ac7fef232ae10963b77d2ee1f02a6d5115f2e5a093747ac4e153e4e958e71ab9bd0f8010c2b1e8240a1de22ee2a005c5e14867b42cb0da8aef2dd7d5623d9a4738a4ecf40b016b4431cc6c5130c88af97d4843c4203db7e2130bec6a024d79f079ed4c2f544ae74d3076904159165b0033616c1add5a2844c42a121f8d3e5df976ef1dd2741f097ba583bddebb951b05d68e3921b351decc5e5a005aa6d43045141d9b52f5f8400ed8f12c7dd41d4c2437bf6823d746852e18507cb4638ab0b2690d15d2fa3b990484d18ea08a749c6f4c551f3b5899e2e2c64a56227a1fa206155914e6790745fbe564d1cf594025ab9b1de136d837a9478fa3a47d1f3eea2b7f815b8cec5ea44e03a95edc7c4b804872660501d8c3d0779946e0a6137bb1324f7271eca1011fe9a152dd546a4a3d1dead36c406517508957e6276bd4d380f58e6e3a6ef255e3de7d68d31b43e6fc5db57227849a3f2e5716af3438ca0d19e3d3863600d8d2bc75326c8ee5ee7e3e815a049abca178255bf76f7c48cc5a683722e6ce63d1f21f954cfc4eb267a02cf2ff931f04a148ef1f988f4c6f6cd7dcede99cdc2f8a427a5e093a4cadbdbbd78529f263b5df54d97eecb30bfaccd75b39a7c36d5039fe1b722992fa08cd45d91eb899278c024b3baa7a0c733a060b6c59d1735b43fbc7ae1af5f5afae4fc18e18ae935adf786ef469ba40ce113c48b18f55acbd3dd4c467abc2c5a5ea8809dfabf71be347f7a45241f5e37e3c4617e17608affa74b45bff69ac26c8d4b32561f901f59fcf7e3fd38a0c812e5542cc371509135711e7c5818b2e8329de3785a0175c3c0cee82cb9ddffb749658b05730e45fd6b2c1b03783ef3d2ce7c3424e7d36e0f2b148a55cdaee42c39b6cd76b5139c5af1b1d27c7d818db17d840855f1b4a4975ddbf65152c95a19e6411086f0109805f2a26bf46e4412dd5b425aaecf782d4d9129ad0e01446daa70f639f60c921f29019783413108f019dc567d1eb88c6c885b21a502f1ab0b8f9870c5fff2eb74873569e2cfdca47e05a8ff26e14d00e06c5bda469956c38da77ae3dd360198b707cbf7a5de38d6b3239cc9a86ca84f5274b126b68fe47bd65499fbf1131b9ecba17aa559e508471f4a7e0b0928b95046cf0cd1f425e3cc6dbef602561ab1359a38bfd4f180c78a4ad737ee2e1605a9335d7ab8e1591d7ec3efd28d2f22da78c4354a2818b588c070835337903952900260bc95634acb1038ab8a939b2dbe869f5084864eb1e3bf2cd092f42c452bcf978ccefb42f40f2ad470788ebdb7235e90c4533d98fb59aed149d4a652b2562dfc91ee8ea9a89adc756828f1ecd7a8d68619eaf3be7ca4ec8431ea0f22a431fb57bf1a9c3f654cf322a724104f42cf41c303666a5becb0131f936c1409643ce50e6ce1feb46b390a481a5e03083569589f5ec94f5c31bef3b942e6af9b114e977297fc9703282150043c63db6d5c3671668b131a0b97993ba87bb2cca3dcf24196e3678f8f313ecfb300c1bffb0f79535a6fa4dd34b651d2b02bfc16bd355b94addeae6fe1708c1710a2ce7ef8ac0c6460c8bbdd434f1e50c9199e5b569657e8b9a44cf289c4badc3c15e7b0cd0d206d611dda4796251eef388905c8ebb8c6f209747ec9b45fbb046aecb126ea8ed8a9b861fcddbf1995800bdaacd7f6fd1771ed4ad3b6ca68c4a269ea796cbb8ec291aaa74d4ef4eab97c371e6f3f1cb15388682253eb197342ac7a0da7e4dd821cc62b2668f7bf43efe2914fc6234dab198a06b052726f3d0e9703789825f3c5eb5dd8148b05dd7a890be08739bb040b3d48120dd72ba0399585a29777cd0388d4a199aaace0fedd1ade7b2ea827bdd371521c67127bca88c870f15d54db4008262dbcec2a1142628cc8ca46d7865a86a7878162b479e39eadf18abd5a377708088eb11a4a58c67878f05d3bd8ab73715d4cc0eb04f4cd24b976985dec095edf853fa7687d69a016db22f6e773c8a1c8d6bce5492411b6055ebdd550f022635ffdaf58aed358546a199d65ef9642e9f68c89b7f09ee8886c0577b8702a599ecd78d8644181c11f173771f0cdb9e326e0fed939e6269d9fa88d56c4da2d3cdb7cdaba1f5b9e8bd19650a8d1884a3bd70efce9993c9f044c992ed2b35d1e6ae7a79e770a02f37e923a70fb28ed2c6f4303e86039a57b8295fa42029b624a8fad855fb33c591c1cd9a320a61bfea758c843e85004f0b8918d0da3ad2b1d356656746aff8caa5502d461606be4906e18dd3b6dbe2a18c7adbb8fdedaef3e95eb9f8ef4768ad4a08ad1acb9aaab76fcd5f6ff3385533583ff1ba0b723bb421a9d5995a620436c2bfa185b0e770cb44a34e0d0c013f4c93e60b9fc3f5cff1513ab315edba26fd5bdbee94fbd2c5a2d2122fcb66a52299b04505a6944227c1192d39284dcbd65d5e904935c3d515846775ab751b1d4f732a4c477d7dbea7a2c9ef67515ce4279acb61c745f0d469cf425d2a132141d23b2304e627da0a741d066752ca5b32215cc3e481aefb324e8649d48fe0979b5920ccfcdab4153cd9574e0466ba35d988c00f15aa54bcf44fe125117cf2372cc0c9ec7be5e6c5b03d7ff023d5661875c1627caaec57c894b053e7b37d11c02f6bc28a99ed60195110e7a717208612f6fa5e8327e1b5eeb217636838397ef3f3e88b26cca82da7a06d8745887232069b7a32102b5e774cf84a951d970711f5ed711d6a7009a30ab0af09b368a77cea11ee7da07eb1201417b4c7525a5e6fe1d7d90de7ab936909b646999c9e949d6861e2994d034f999389db1528bdc0c30bfb8914b6d0eff471ba2ef137dd2bf229d08c657c6281a2d25f9a71541714751baced06bd19ccdf1265b4718f6f286316d01af66abdcbe0c91269a1ccf88447ff01e9cfd06f2b04ced2a49a9d911b0db68d65f42fbf06466b7e33c8638267dd6f023ad0ed2f025410a7d8ac909718ea5d25f8f3408924b9983612875f15841372354f09519ce5feb0c934587cc7fc995fd93d87e675bba57b531f9427da83de32f65162573bc6674528b8fea0e09777518e149c211d15c94d40376f32c0a32cd25f10d216745e3afba143ad9638e7e956b44e846ed07048246e38cd55ab5af211ed096c9c6fe55d9524ff28ce0c4561800d83adbc08b2557e5f8f133885c94ab4492dcd30fa679d2f4411930614da02f2b02297da18cb0e01577a8dc8e8508bac6bcee779a6f52091a54713c1e3109b8bbe85f71f459c129460e3806b96244241438848022f7b65b0474e105ba61803403500eb046ffb7292db1a53cb6ca443d98ccc9e1b76d8c94deebf342828193afe2faffbf0d57d90f5c1558c1e7da23265089edd65dd9f0f0e8a90e011c4fd70aea96a62ca028e57f8cdfc8d0e4838ab78d47f87c8e8f4a1612d2c869cafb3ad0a5adb37003accd131c687ed47057900c49e063f03912bb090924223a61392f65c505358a602ab5c2e65e564f507d866fa9e346ae1f55a2b03d42461ac6ee6286fd4c813f915da9bfc518bf516e67d9c20a1181cbd7e8bb7dcac450c31fcfde3db78b83984f4c2281e9c977150cd03c9ec051e61dee667580cb0bb7029bdd16cb7a07b886f310717da7553fda4e55b46c5e1ccd007431f73d476ae399bcbf403b4ac7d5ff271efc8a90febefa650091e126df21378917e1690c53fb1a63a53a30f949de9d9336eda050a2952b0bccb00e00a1d48a037c4b0d3b47d47554e89f7a33c38b6808b3d324161d79b83437533696e761734557956ac8d4e436f27ae74435a3bd4e0d60f93333d6d29d50f9922ff2b4407de332ba8cf7731fc2ff2c2d4ff83ab7f5c084479f8e65ff5570919945801b82a30d4d8f26e0fef841ed756e8ac5b776889a843b5e1cb5b1bce9f6410b29f469b5fea6f551f208407f1f914c372a35c7da51c5b557e6f70c4e435a5cd61d74af43ef41d7362015a0b6e4abbcc874653bdd2049e548f006bad308085e8cf083577072508e724846f7f7907565838fcc147f1ea68766c8c634c3d7f0f5ca6ceee6f78aaa15c4604ae1015cfca9c9b0a8e20ca8d63dd6f882aa4894c862cfe3a5a2011d5cb3f7fd6fa47eba01b76ca02a93a20d4c91a02d3076a0739f61f93453a37169b2b2e897876c79d5161bba8b58c889fd805e3ad16cde708507494a3443a09c1c653e85e60b639e5dc3a773cad190cc3e12d9735a90eb5a61314eac5000955f5854d1b41862af257e37701bc5a628cf926178a1b1b4fdee07e889c0d32f51977b81abe2145e56ca161389130413f580f18f5a7f7c69cc82a50562a29ff7fc1830bb358cfe575a2a5332ed40a1a7faa70239049e3acdc28740a9cd781e151e60747b14a4fcb073c1567cb470a9905ec21d6033e40efab042663472d23840dd59aff475734f9c7560862122bb210610b83c56b4a6710c30a4cd1378c3d34877518082ea0803c30f376e5efa7c8e16215a9e622a0701dc6c95df4dbfaedd90944b87da5d44d251690e08fea5a38ba8e03bf07d8606acf066dea72dc05b1103ddc49345edfa26a864528f74413f6c3e730c221306b8566697466f7dc5a018c0b81c684e3f80b0ed91ed2f3e426cb739a18bf363a9c129dbcc39d49f205a536c04f869b50ef1e37680955462af633d2c5729a3b486368239812b9eadbc7042f6bdce1eee8a46d298df8b570b00bd70044b210aa580ef152e552c89814fcc41dfcba882ed2121b118eb7f726879b441500de579b06faa971fbfe70dda516465319fc0e035572cd5ea359539312a254a3e3e0ee6e3484aff7cb9c6860bf719a2d77db7ede7c829e9b15d0a06eb103ded252b0a411bc50a68fe7537317171973bb7670b37b1e7234efdaceb1b79a59e7db081298a90fb7d3572fb6f0948ca8a36d83c44b1620eda95669289667cc9ef432bd32ad10c520ef7af4fb42b8b3585422d60d14d2a33edee49c4ee6acccf3f07a56ca3b24e0b704945b520c2b0eeecce9796b19037d13300ae1da50fffa217a6f8e136c8b732a5b7351831ddab56f6e6e1f9af2a2eabf657868635fc34da5f4249ba1a5993010dfa9c1b255a00b82e16713b01d12e161fc7b757380e1fcc2f1dee99b869607dbd252cf546b02505a15f94c371e3c87033f70cc326c6d1d1bf8ebef2c0325cd8244153278aff7916f69f369f62045bbfcb7e85939640898bbf6effc9e81f47581432cf0c3c07020747eb42f79902e4b998254c9de0b558484fb6895dc75bc260bf46373b4e18c945ee0806cdb080cf1b9381d9875e0aa2636d5882d5b041b6a26e50d8d6ba93bbf4fe3c3ea524a1bf525cc318984d7288b7f4b559e8f58d634228a9a02528e1734054af52ad2a697c2d654727431831084d16179436eed6a431426088c672803af762cc5fc61b0e3abb8cca0aac33fbbd4b3918f19b9ed0bbd20cdf85581170ad7b5798c622a94587f1b0bf58809bd0e1cc11796bc5ccd9427eedbce373c8be002ad39227f65b7877f99c50753aae704c7ea5fb288cbc02425cf747baafb826848741e2fd66fa2f1b747b49981b607f8f280e3a098efd5cecfcbb028a8a05c24fa8744fc814d198a6a77875f9cfcea85ab07116e4063e76f60e6974b2cfd123f83efdf38048e460dbe4e195c223b999d11c7c4c89487ecb3287166133b73f02847ab5aaa9dd74a84158e509b4040278aabf06155c9e11832516495241113b97b7cf8a5d4a00a34c4d37b20b208f5b8f880ffdf75c1a61991a6fdccc5f9c1eaf84d7e7c3f25efca10620d013a2af365e649aea256f1c3ab09068e3389f6a324a4d43ea2a1e914b6557a6068343c32fbc6c92933c521e907f58938512a8caac52a683267e0a21613a88b01bca9a54f1f88c7b8a0cf6d4a837f50bd629c9b23e2f6e9361ec729a5626d527b734a4f2c31307faf8b9e30a3cec69ba855f49de3a47e88419d0f1e0d093558f1fefeaba02832c4cf44652a76387e0a1fb3a36524975f66538ffbaae49e20c1587f1971bb4a3355e7d35c879ce5ea27832b4b66361636b5edf767cd50d61e40b6e979d40a5fbc26c12bc4036dcb62dcd563dc63811b5473bfddbe264b3b64b5bd9315b680d46cefbcc5535a8c4468c15fe8c80fff3ccd5f98e041011ace5c342ffc147df014e4156c7b75d78046a513b8387d24ed8b5b4d1febb964237a3c0023e016368c45c63437e7de1a1a05d1bbf464f47f6eb394dae9074078209781bae31f2bb7711360aac06d7c87044c2e488e7de73c76f68488b59ac220fc0746e4f30eb82cf81ebdda472a4b7addcd029f15cef648f21034064a6cfa030dd3c32b949eb6b988e2eb9af1def26911dd0d1700e176b5b22f3abafc60cca6cfbce7826fc86e8155dbf23ddb3a3cae10fca23141658a577371ba5fc2d9771df1f672da2edc72e69a4203a3e85fc879ef97ce485248d17ddc6aec50e47ac03176bfced30744d83adb4b629101d4c9f5ded854ee70d7af883bbd159d4157f2bee9d50d82726d64ea97a49000a1add17c3ff59cad1f27f9d6e58f85ac4682ddb331af7c58f204b4a687326c020f115e5c9a50b3b6766cda732bcd5a4d7f78754c7c63529ff99a2d8c47c0e730ff2572c137ff5f33c1f93e1c467629e959a2b717ce32b4a430da037c2c96ae597514caa3af3a0adb44c38e747272bbbb268bc0aa1a1ea991b137d9319feffd232fca84ab724c66e4f2a5eed5cad00edc3f58c077f670033fc9e6d0ca65b9c3bc3b455947b61cf19d3388195821f4f25a4ac7b508a718015276ae3ec4b535e1247fcff77e1a5117b08e168db011fa98e8b3282a2f6d1dca84398b45da13102922fb559de89b0116c250d7db00a31e0301d3b293df7900c621d768bd780513360f85213a15c7b6e7c1550dace330670f81bcb743c92a66a0e04d014e721b164e1a7e4451121bbbd9faa93dcece36819ee1bdb28fd7b96d412fb27ca55c2f4f4edd3467e7f0b3de5c2a3b08e62f7f4b801c433c287f6e0c868b91f8b80358bca845219c08e38497b9d7356b477552856379a04de75339ca7868ea0feb19d6b75ce3c841b4d96962b0365ca29676486b85a05cf50fec22bf7f9bd78b5335f0dacc1848894ae01f5e92fd02c798510a1d94aae589b43d483c4bd354703320789ff8a73a91d324ab7cf0afec17789fbfc370b2967c9cf50c0874a439af3ab411b52f0d6d2de39bbbfab98bccd41ec5fcf112059bd0da2b0a531296ad2f912707820edd84025a31b6659b897506c48a3e0abd6fafad85e4b802bfa47f6e56689779874c1e5e8bbab0028c18bf3e4d7c092fb1ef0c1bfc8be763634a112264e7cd2f34feb89870d1af9c6594b0338645b0bab109ccaffbd6114dbb78875dd931a7dd76bd5ef10ddee948c8b49d870c13f6be25c8db205825dcd8cbe55c9838f8e41b4ff3958e3149618a409e8819c9cc04437cf370b567d60a59e439c2b436f55b3943062cef781f1f8783d05df2a2a318ed5f83e109f3c3169b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
