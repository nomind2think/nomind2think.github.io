<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4bc92ca864cec75e6442650b856d570cd784e55f157e51cce8721543dfcfd9709d4a148b212febeb982b7db8a6b313e0a1051abf1590bcf24161e5c1ff5fcb08d9ca56f1afd3c4ebc6653a7bc6a8f1385214b42bfdbafbdc37efd7e9e56b9c642bb59994bbd306d80f75dd420fdf527ed6d6729097a5a6160b29bcd8fa82c6608ae6596f483efd13f11a65e2e6ccf88d65c49dee0e519d58827d191c641f12b62cbb75521b9775e15f43f6bff36177d6d5e8dc089eb387147f8a1d1107d717cdcfd3e6f9ad2081a0012c6db708c33499cd6471a9f3c373f403393a890fc827d6c9c865d77ed6d34551abedf8130e19f36d8a4342869fa5c26d8a610fd2b360b344e3bb21b1de1f0dcf2f8f11ed800dffb76d78b4066525c753752b59e79a233178c51daf28e18c6fda6aaac7bd0e8c727c8ada9dc66499915987f88708367e146d390f7ba01a720c08362dc7b855bfe5d920fc1e7c3de89368f70ed1b3b90642aebe76fc3abbe5edbce0496d6423cfc4f82e28353a3085babf75d2fb864687879e082058923b343312fef60c4f0a71cc4c8c22274b4178033286c48c20ff0801470dbabafc9dc19c48289bf8a6f383f181b256b6d5f88dd21fdbfaecd10ae47cec981429d07d2b5f40f9e42deaa7e6122cc96e824ee37b8887f5b0222e95358cb3eb16f8414935f05305ccce2dd6b1a45344606c9d7dbf6f4139bc13df1dd6294fcf0d68c45c61ea1bd3b008297331905f997ab06ba8cc031a3dc0d1082ff67bad7282556905ff62f3aae3b358b7a13ad4474aa34219a1f3fc8f44fc76cd976a687d95d3e36a0784191417a370d0e28fe9d9ec15ab3a27b08c4bcb668d74e01a7bc4a054acfa964d9647afdff16c58dd021c1c8b7092186aca6b31ccda97f5fc409f68fa65e011bdf53c0b1e55f8ef738456a111af3e5e38afbeb404a86cbfd9543eac6bea9f8c5aff9c889acc34fb52306019763854cdad0d84a4c82b7c6ea8277fd73153334629322eb14a367ef8dffb0335af979b2800a684df2b77de8b7c452cbe1405aa18fcc608f9adcfc854deda93a70615a4a64914e0d2ded958860dcc00d0d45677a02e51ee081efc52025382e1e1b56e7ceb4012c55a542ab33e405e4e821b05e38e9dc4c9d6ede7a8b2ec38cb714aaa686dc0faed700a0fe8c68da24fd66d75b14df064b520b5b349d8cc3ab357fe86da76b50c66946b3b9c061161ea17e8e27355421f84ec7ccab8d607b9e5f7d685db051255fe099dc14fbc20b6fad0d5cd6d57017726f3b4dcdda055bf6bf3797f433cd6756a34a449b23b605064314de57835fb7622c68d5b1ddefffb4f5f2f5887e9347478baf09bb8212136769db12cd71282ef71d3e7d53e29a378b5d33eef8045fdb871629c65d38ee1dba39737592db968074780f90aff8aacc23e7794f4de5b5bcee0d9fa5a7aef6c0200429ce859790f41a35c83cc7e203ff905be39ad142394f6bd4492615e84c7f838826bc44e50fcb749b8fd6a28f116f615102f719f79ca8c38997a1a2445c1f8b9d12b54a574c4011ab9029e2b0ce195f2ea655b13cac8e1a806eb1fe2addbc3de7394f5393c5c820f5af4158dcc82f0b48ba2fb06a4e88357651753ab3ab3c7201c1f5915f50dd065664bf76943fd35c9bf1d06b0e9bb283c62ec572d278bf271559b6693ba3bc2dc08663e4d616a3909dd118a76f210c92f3b7d8e17f35f5cfa4f9fa56bf82930a5fa876065a8b35593a756e419752059d88daf2f1c5860034138b771ee9950a6c6841ffa922cf1cad763604d741b6fa0074d95be238e6f329366b428186010a2951ced2b09a03d66125df5258d8a7d63510bf37d75a4eff13286de422f14f867ff53c2b18f12ba81bd483a90a49acedac8a6c97d59d28ee0bb4494ccf2848f9485ddfcfb2a992036d7d4ee3b58a8c404ff2ed4a97f3a0345e5f3a65ee33b7c026443fa6a05bf200fad712ef3cfb93436766ef9a036665b425e677458c55477604cdd4dd7cba3ef69b404d76e64637e9efcdcd1ad35a2bc12297423c88d867206ffa051cd02a9a2b197671f2eacee545579e7823b394d84f21b88db784704454ee80696bc8eee0f482b794c061bd0a9f0e32e9166f0fe0230594ae7368e95ae5e328d274513abc609164ed495f7eba97f6bce4b1c7898c36b202fa3a2474e51b9bc34ff029fef4011bb1628d36889de5d2f7caf9d0cb48c8cdc854efa9c62a24d2801bdb9356701312af3b3db07f4167b0ffd3752d4e09fad4ce35a4015e691af2c5b513bd45364840a33f3a857a7da9a1ade1a9838d9bb10006f671d3939cee190352fa113e2b2a47bfa787db387db1218d72d04862baaaaa56e4e131379fc682de6b0c59d6c6b9908a6cfb8ffc3bc346a1ec013c4cbebb0887135ac6631638d976614d7ca6de4aa17973d76db92a74a7b953a0ab855e8d38651470f9e5904038aab25323f51d592010f5677c58be2f47e02613a860817209d753a97013cbd19ff86652501b67c3e54eacc7387c7572567e19b92ed7c096483e05eb58ffaaf2fc9a9425c2f5b3ae694071d2dfc7ad461cf4ea0e90a9c04f24d451a46bc5cb02fbd45ee9851954c360d3548b38e3cee550bc71f0a82141944f56f5573d0ddb3692b7c2e25bff423d7065845ba99d6ab8587dacddb80f62dc601a6c30a98bf76ab9822e05971ed182230da0965f390e48f65956b1e776e9b4285520097e5fb18b1bf709397a254a18cc11659d22e4245ee9440228b243693ea35565295d2ef7282e1bd0aba13a3bc5c9f662c73dc74c6a47794c2d65f745db63131c573ba5100bf1bd6115907ab565b6d4cb3ed0f23d3234b9a75f85fe05194a88383fc967610470b6e5b9d70d98decb008fafac779f9f3d335ffe4843220647b916ceb2edd169c46a5f1c3a9883afbae41b453235be76b1c0cebc0a3dc842593d52dbf8cf6537fad5225f7e179ee9c8b248cefa44bdf3a98437edf6346a606de0594cdac043546062651dc9332e8cefefd8e969d812fcb07e8b523caad11ef0d5594559aef91552f3f6273dfcca03ccaaa5b0fe5ceebb170f6e91e1ebf7ce955244519e808c9f30b6c0aee3f061cf3234b5734bf0cec371abd69db23fb11aead303b04440781932beae9f5a8d81d18501c65487c69780ac4ce7e210e29dfa62df58d839268dd119b7e429bd92d3306dbc6f26514ba626681e5e3281cef4e71025069ef59b8e735ea2858d096a48f9bbdaa848e247708dc31013d5438c44910ba9728eb46124cc49db0ab5c37ce77b217d63194cd3e48eb635e0b2e6c1ea36d13c14a5a630287798f84b3bb487aaf5e5ced256fae0a13f959219fa3abff2cc00e4a9f88229fa2648da2b905dbe46464de542da49c2997fd9eb023593a0ee345f246366b7af58ddf7d7b1745034dab59adcc24c495db9480fc92b328e323428290c86b990aa418d5e1f4cef640d09d0d1599783e12b91af18f982c7dcb19d4579ccd4a0e762ed07c0fcba970203a5870ae73129d8f36a54dce6f876f1d7751e66f2012d6f9bcab5c9ac2b2b159cc643765acb8a25703435b729ae4a6d970ab81b297e7da4193cc93ab47cf3a6b4dc0385a75444e5450be28e1c59aedd3be1457430e8f69e1d8043a82091d037819c8e1d0200411dec8893c37eebd2358580b5b26d0602128e10aa6c708fb722cb1695df6091509456636b4c9b843ab7a9867f5fdfc532c73b8eab34f648a8a217fe69e17eb48e89b562aa0934bb2e813e04bc1129ad17bb3022d164843911fd18213f2fa6977e49994107f288dac82cb73719fcc3e4ed7fe1a6d30eb589fe95594048b36742a8b25d3db374dd37452c7fb185acc32438ae243fec0c1647462cd73dcc3083c7ff7ba6a2214569e1f1470ef069df95eaeee89c560c356b321e780ff535e22512d58c5d8f8864c1a1e184407c0aa6d10ef1af03beb334c88809094a740e1a9688ba753a070b81c971b8fb69016dddd2ed5fa896b0e8ff96cb9017b408edb4f99fb4a09f5ba45d6713b68656e3d254333d82b2abb8649d6c204fef07dbb739bb7fd7c2212d1eaece679b3648cea3cb8e696780f00ea0f0e938d7a5248d918d8ceb662b003328a437920796b2746d1590f650c18cc9532f075e8af60069f363d9f783cbb95ca2a261cbf138116796174d1aa27e777ecee4244c3593029d6d9b310998531b59de09c50b198f20929953e9e86a04e3e4c9aa9920642619a65a5bac1bc78b42b9a67d52f13bf014244cfdefbdba98d91a65dd058667fb4b09f3baf0fdf9c576d2808f24dc317fe3c60578533468c5576b190fb6df249169cff3e40611eff1ae1ec26c422259beed8fe6f05b2945ae7c43b726cfe1e99575ad7cf00fa6efc272c0dc33ff11b9cea0557b8ee8942456b363701378f8097be55e601aafb3937e7b0e7d45f8fc2d0f4ea94c13403c6866208fee12bbc4b7810b9247e1d9e3c08922a2b6111b65bac9feafecf4454e14c06ebbd4deb4cbc6749ba1862c5bdbcc3c4ae0cca6d328b3189533858be039d1c614a28597e6ec328c07b9dbdea83a7e62173abd20f4e0cc08bb969a67d760fef43ee0cede10ffd4eddeb0579482c9fdd8f5902f31fdc6363692209b892972835d3d77ec9922d989207032a9f3156eeba3469eafedeb369b75b7a3e2aa07af15395a031d6ddefc4b0c2c20f41be515fb031925f13f1ff394eaa907e8753455c37da72f3e7daf1ab3a1dd47f9cdc806e30d8989ad099cf866927c93e4d87c1cdf1decda9a5c018d9c8d535f4b180a6e863661cd5c5918da636e477409a7eba793b512bf385ce19c3bc8fc6223ad0cab11cda09e01b6f75a7b93a613aa8ea6850e3611cb13e86e9d05be3316c15777e542538bc5ffb4d0d911af012d214e7f7feda66f2957f38aed7e4a3571bd9c648443311dffe7c2727649927115968de44c3ce825e25bd7413c1c5e13329cfe65560ab8add58f959c90d48738fe9d890487cbe649487dd7be1098cd9cd2eaf6c4ee497db5830baa45d737bdc3496bf8524112c868fe46dfdf4a779fd8ad47c76ae32dd022460eb9b90600126c8bc462d5a30b9d71a0306b896f6716e02478037b1e7c24e1c1709f49fd55704d49d2d60b054e1121c54e021ee5d8fca0daf55e3819718fde4f7dce3b5626f758668ddeb4687d4fed070c93e298d4ed774b2dc4349c81b7fb41d35485514ba5eabe84bb2a4965cb78ef4d4a513ba0f73614318b942ad2b0f322b0911503ee263d7230c6ea276b07e5c0fc3ab5faa0eb8780192c830d4a074f21aa2950244a94246e314a083ec8ba5332c53bc02dbf908e8c82509edf026e9134d48a24a3ec3e0d45cbba1ea53bb94884a6f882433087f4fb8f595f3467dfb5dac80c67fe1bf31bb0b000289ed10c1b13934ff91cf93bd154ff460b14728f73d2a6d0ce3973780260338cd5410d29d40e7941054e9cfb8b991dbe16ce8f40b523e52bc4ee9a544cb029fe526770616cf7d7ffa4351858b467333b35216cc1dc9cc6a0b6ac02984cb5f8df54b1bc5d42657481d6f8d8e6454147a48df786aab5c804db774c6f61a221c5da6074d6ffa608b50b848757aa1a618108b09f40ddae86315cf5a04b32cde29e44e1b70cfd235c2bf61327fd33996429f61f200927989d6d69004e008b4280336a2172f03da9ac34cd87bc614e547ee0f5641e0efb652853c54bfe16d49f231f9045d342f992c1ad2a24ab6c34e0c2d6163870d1a326b52bcb1f77bf4ba4ac701f59053a573b9138deca4c06a24ce7633dfb983b85d4c7ae3f200a380375e0f0b09f49ff59a64283319e1746f92edb4dff7567ada0405f3fd323828d659b4877927305c2a26c8d4f1adfd62b7bdac0d12c1be692255c93fd63de771b1687b947aec685e719c38d22fd1f544a39c68d60c915ad90b95632ce224848c95a5a89ffc20ce5b7d38e4661cc12cbf2550d57dbc07194cb661ede3534d4b8a8ccea15ba2cefdb01f1708de4a891df693e3a3cb10f999b32da00b837923a014e5336e2980d555e1359180ff548f595cf5d8e27f56235f2afec190284c969a98f11c4966642bca1e6d898cfe872d5b0932022daeceefdf597f97915f62dc38beeca3dfae6d7523ac91d18592c850308637736c2b7213daf1b0e1e4d82ecc042e6be59dce572b01d683862a2cf136408f963bb47d382f81c84853502631b131de38352f75d4f808bb7e605dc7fbe6078f9dde87e366ce562fecca2281d044fd9026d42045921666c65683f43d7728c0e35eb46f3efacdd22a539688cad5b3b0e486ff5fc30af4a78f5f42c2d377d60e3d6a33956f14c5456c7a7baf09eef4affb5624aa9b6d0d72cc35c6198fdb330b0d1a4ef4e5307c3d8a22f68937265944130d710b4fff4982ccdc7d42e0c0333350f66f391436c4757c2533f3b2fce7072eea385476879c76fe85e0ee39165c98c0858f78156cf4ab296cd701ddff0cef505a96b1b10858e30f7ce38ec715a79c87495b20b2cc1d29a1f53524869724d271313e5a01d7b8a99ade7648baf4a4662b5cd3657823aed8dd33f2f8f7af69c1f949a09253c888998b42d904d11fbf4b975f25faa11be2b3ff4ba28d796589a0158a9b292ee1ad287fc5f893b06fa73ab01eb8cea2b24c739ee60111a9472a038dfe63edde99ba7c073226b3d719e98821491ce6767bc013e3d6c3e49a17c57ada80cee8c7d673a1652ad0c76879d3244309f4b903f39b8559b0f5039bdf07db1d2eaba9b28928edad00d8f10f93a532536be4245b9487026e98444e4bcea1d279a3e882be4308001e9db9d23cc3084bcbd594aeafc6a4a210297c7886449cddd07cd46250d66a8d70485cb542a484a5b5324548472786c8faae7fb5351bb932622530ba9dd2b9816cbe601739adcaa2806301fd781ef144114594643fd29f9d224037892514300cc16ff767bc4a04f8f03418adcbc933690050e0a42152fe1276ef9f532c9c1c6767af5413bea085fd12731edc0808f3bf48fffdb5826d9fcdb7a8eaa2a49afdda0b265e875f64aef0d4747eaf5ce45a3f3bf2941cdac8ba7a14a2a338e2dfb86a5b0e7b829cf0d1696730d413905ca49ebc132a48d72a75ae28aa78f22d0afb5fd76191ae1d802ed791b55d18a8e906598251adaf16b0579ca56ffddb35222913bf1942757053eba5eea28dbf7e36c1386f4278fcde80b58e1d9b145cd7ce43c49a3a7f7e2508e91a40c5090a92fb22a4358887c34fac220b7fc2abde40e36466095eec50f77c92a7129a42571f853422095f99709f32ec4c76ec02dd23ed32519d5140696f99e63b777cc84b20bbe3d0c901eb527a650b769b2f85798e93000469bba9f4f00a91b246811d7db19c390f27255a433808445e29636c602db5604278a28188ebaf9bccd13f31f40a345eb0438dbc453e7728ef44378cd9f36c1359e130d1d336cb93fa16afb95f28fe0cd7254e1dded88f76d72ebbc1e59983f5b7ba353873e7c15ec6e2ff3226679a0f977f6a2dd89863b0cda21384ad0170c1ac7d72bfccfd483c5bb24164c047b2e1cbba896b2949d686c2c2fc3634d56dbfd616d09d42566ae340b040ad261a02d08245df564afca19654abfa6a9c6cf5f3d3b694d7b6c96523beb442b971fa2d85feef695d4353908ab250a5e1b564792503437f468a6eb592832baba79b718ceaa92b81b2d70b8e500805b2357dc05105f7ceb3e3c3bbec8a4bf823a4a826d613c6e551400fca0ffa74e87fa2081620f482c93b2c00558de00d8a56b6c25ad5c270cc46051c44cb0376d8d70f43dc48d0675111d69e2237aa5c00ab0b8f0f52e004728c389c251b420176001c143e30155d889c0e466063c0b46c364f19fc5b02d26e6fe17f171363d239fe1679fe941172b0418872d893c88be82ec682ea671ec2cbe2112ea54f3de803f8a63604e5ba95fd292588b5c608f2c72a6f667942dab3be666445ca15b780e352240547f7614943c9e7daec4ffe5afa24612d2bc07b9dd95d3292861778cb63625b35fd5bf05b9023f02b465b7c7c8e8558790d640dc553180255ac6c9009817d42bb6578618130fff1826dbb9514c3f3a8b9f956d47bb8f8cec17d9322b89e857c4d6c0bfa78cf3a59168e1021d7c3361ee2ab5bddc9d4f86b468d84081579e887c67e52dd0a02774655d11997c2b2914a1f74fb1d1a54fed667e6ca64945ec6e14ee18bddb9c226d302596c848530855fb058a4c1e47f8163935d12d40724a92849c505dbaf8ab940ab86539c20894fe4759c4e34f7409ad58586e913ce72d98d49b59278c21959bbb73d1dccdf84353e1b91691743c033597c3dacac4d2e00f672616f95b1a9a03c47b927d158fe1ee0926baabfdf3233d1bfd48b28b415c81aedbb999719c2997deeb7b6ab43bc2c15496b19c525f9e76eaaa4ac95f2ede664ced70ae96fbbd22c32f79879d8fe32dc60223a7c1f24118b258579019b9297ed855b7f9ff114d7d8b6b20c8648bbc2bc173d092611eb7126393d48bab7c887d63ac65491bdfc409a06c534ca03645d8f0fc916de852f2e88bb0c69c9429a92050eca30d63193ab4af373ab2a4446b725fca4af452e057eeb2c8c88b18b269fe59a4b32f00dd522adb91f8e02a9520b0d385b716f98d669886aef28f24bf3d4ad239dc73e60ec5cd8d7fe7f8b4fecec711d4bcc14fe2880a8d33f4790951d32670ae1457b132c6f83876c41273d8777ddff6f97588f6775ffb44b4034dcf795a2fd9501cae4764fa4399a4d2f6ccc0757719131c61688ce084f23914a74bd0a505749f2e4707780a1dd0e7622ba2df1ed306902be30e8a2102a274ac0018824a623029cba9dff3982988f45025c5531939756f9b0649d20860cc38534955a8bdcd68cf08f07976560ca4a34cb7c9bdb9de34d95f717f78a87b20665993155b463971cea0a6e271f8d6c5a431a36b968ab552b47b9b07ceb56c6cb2e1c9122aeb0842daf6bd4ef833d87644dc4d460b841ee33ecfe914b46d599c79921f0051cb8b0cbdea6a7d7f4d7debfaf26d2b9cab86b1a88ebcf6d462d7bc2a10c9caa0284e9b158ba0d5deefab2a5b7d43b3a8520a72d59533606e4d6136decbc17dba44988d21cdbca2ff296035d3f65ba7668c64e512097199c23f21960b4ff463d5d6b635b609fd8dc28fc89bcde585ab589ad78928366bad952e059d49931239e84397aeaacd8f78dbe9d4a7b33924724009779de9c5dd0c559dcb7dc6d052005fdcfa7007db33c81d03846f72a1f1815d9e6141dac4da94a901e4a9b79b560182bb194d0e643810021cc8f778bef9f7f6df34447920cb6158d5d93c803f46d999b17790319f77eba0d42e59dcfb09f5211bc8622a80160b8e58ffedb803c3ee10a21f71bc91478af3c0dc4b8736d5664bfc7c0163253c5ca70d99b542f5145068801205523f0a8cb36fbaad0bf9eb1f052edf7c77318f29aa8f026da193d50ded77cf3d4b13a6a330a1e9963f912a02cdf5a4189c081a7253b3707fa1c44b43136848b1e750a36d17d8124acbe22c7a5662e0e14d83f5754d676a47e4aefcbd26dae56ecb3c623342e6787122e00e6b8609c8c8a05f250e4953b8886b8e8709a6a72bf21ed1cd6dec7da3e6ff64c74cc5927c28bc8b00705b0ab55b7b00dd7ee161588c907daf2fe9d056a93a23d5c3560e90af03711b66aaea6fec27106d99ceb002cc128e33a959c5afcd1df66a10448e5c7598aa3d4c1401ecf816f9ca857494a7bcb179276ab858617764280fd558464496f339e68ecbbae0d5c05430ce1ab861d0a78fd4faea58b33e7634d6b2a6275ef855852cbbc6f775c4774471caadd75a5a768d85469f9590f47fbaac77e326bdcfffc80ec2cf04e2b82a82d3fadd4278de24c764bb69beb0617f741cfba283e772be8d11e8b7fa2ff3449006be95ce8b86fe0fc5ad62ff38d1357478f680b31826cee20fb736c62af6248f199ef183a0f44d548160eb96ce3e83c23ec2cd23b23e513d6c5eb6345acc946916065bfd05076938b32ee0cde6e68809cacb4c1070ec6f1c9e2ed134785a39c77e554434f9022caa9e317f2dd8768f65d186661426200d542bbe59aaf6d83496ab9b95b1d8599a4d5d1202d5bb50f29a386af88b73e257b6bb4cee9fcbe1046ef09658706823a4d61d4953a1fa476bef2f5772b63683ea8bc86d8a6cac5ac85910a229e03a9db3117c477722491c17e494c87aabd68075ed88c0e98016a5271e83e62440141687023fe78736813abc1d9bafb0cbdd803c059b4008986525c5e72b252439d89eecf20b147f704d0bbc79823edd1c368fc2815dc50ff88984d24dfeb1debb93d634fded881b1397d2d06abc10b3730142960d6b2f11116d13375f856fab5a9406cc2cb5ee03ef0f25780d4939d804c63d472f9aaed3470ffe3cc84585019002b5a2a71d827f9fbcee5a0e93947da71182c19c153f5cc066a3e1c7d8f1588ae55dbdfe97547ff7d2555d68630865f601b49765a4453d489a6010e6ff9e4bc51f22b5c84c4f3772b928e79d999236d9dc649dee321c051776d230a2f8763610b70d83cd21e279b44c082d0342dedf44196ca39918ba6d3e9ed14dbc415d46b5a606957eff1c08db997de6658b42c37804e49a4df82cb19740d6e9ee9bb6d81c5d2ce52180978c8a0e1a81cc19d374b071bf40b6118fde1b4678f1513f7333c5d67412d846ca3cea5019f81855ab96f95a98","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
