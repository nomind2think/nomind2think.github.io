<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea1b9d44f730cb26d82952c1e50f64e9e41dc3b439bd455401d0db33e35b2741ec4d62dbb0313bdee04be8e50ad8e9db3f7fae2c6428d1de091054f851bd65beb3101d6cfdeb448066f0654283639ed0c9dc8990370e9abcee96e837c9b15fb118d09f21e125f8e748890157ada03a564d6b89ab2613cca608fcae7883f3addfa826a93d0c4b5701d15da5597c87130134ccf3d3d72820122376d8309b4f7604214ca2690e233f42b0e24617f3b6307f978c2354f5c08495d7f29d0b918231837212f33057b405f93f3cc4613fdf7bb9401ba258f48dc48e2613d24c5cdacece8c7d7d1059fd4f7799ceb78c2a458084ae56237c69acae753e82092cdbfd087cb719b106907d1b256bb41b7f25c98440770b9b76ab11599e7b510a24a82cae07370c27846d1404f454db6f69ba5e985640badd1c59b8100e5945013703d260d107b7b8f30fbf3ef4c8899a38e760e5b0191f28f4c843cb2476333ae8b0d2e15618726f6160eacc47a5190fbc92e5867cf83b586207b07be669c24679884949e6d91dbf1e36c39cf8d2c69c0b1dd3554f89dafc39d8b41a0cf9967c1f2a0785dd382974a73f6774f19c62d9fe391d1c1b567623f01e3748c35fd3615965fc8abe8c68459a09e1f2810ee6dc27ff2c5ca79c9611dd199909b3f822c84bf97ad2641a5cea04d4fa848bb2768528c04d77c4444598e35847a719540b4b22e4489832bbb7c3bb73af5528e33511922870b9819ccfc1ad5b3d9e1f8944c7db6f9b81adee4a52487d13ebd88a11ca0a02e1a5be8583cc49c3c2ff8ec1b4f0bec2fa892bc7eec4d34e631e1acf9722d0b2344253f12c257bb79029a3633fc5425011c61c8dcd2de907604018ad1272690234954be921fd1be4567462a0c5dc4fdb4655f0ff19d01eb807a640a31acbe459d03efc3396485f988bb1d66abd5d0e4b17d07a0040d18e4136d4c83c3f6d0ac903b22314a42cb8138171140f9f97c185686956e88aab1db5f50b8e0675595481be581cb956192835ebb42f5617437cf1a81b512ea38d73ffdc723ac15e258c4e9f1aec878092566186b17be45b49a273b6efb6ef8f496c1a091ddd7b6100c24af8fe968831371813e5b32509c771f340ea34246d1e70e0e36ea83e9229e11549c258b02454f0bf978b2eaace254ff4902bde5e95b23e11371b2e904c152458531d53f9647d6d95f029018283f4481171f14d9da3a1c9a5e9bd93cd9a30594309cb6a302fd777aae794a82dc9b2c68bd165f3e7b0d36a75e0aa776b1198854f6aca18798eaeabbd777cd505c6cd91b62b775c0ca4face727f74aac615fc9bcce6db24e0041c4589825c965084b2f2f1960f31c6000fc40ba72930449b8d3f261cf9807c95d00c8ecea488e3b95a827cc219043c8b954970a5b4c3d161d111815bf1e39544a903bf877354e05b849bb7e7970483d2154b41b2fb91ac8e2ddbb5d513076d729e6f50d19bee5866ca525c5ad7fdb5c14e40f280e4227a9c1a85638500d06f390f26c6468d0fade3d8abf44abb2949099ec915004f42e6da69fae3ee867c4bc010c9d88f1f13ef1f01d26f22d010cc1332652c3c2c67c6161221ae0010060a4aa55e95ff76da84c593ccc686bfbecd58a48f00390836902cfea000d8ff749d4e609b868b5b77d29468dedec6c6ae64842efabb674c7861c822213d56f9c0a24f6ef75727205263206039aa7168d09b42c6ecface5aa991f067a1033e790ebc3a359c3c93c0c9eac0fa455037d7f145228d42d175b1e7f91f0eee72cd8681d814d6892b0de41b97b23c87eeb15348f2ce8fa65a69013ca5b473b31ea2dfe3c811916ec6380142aca7816a8daf7e4a3dff0c5c1e4426b7989bc0583e404527e353e55c645a8f1600b756dd16381f1c8106e2649c3a3a12df436e9894063c7e60083289b160de53351e4fbb9adb0b95d766cce81ffd9b09dce5d3a76a04ce237ffdac3aff79f8cb58b242656f1a402f70cf0e2d2f77dbc171c87aba49627258ad7c1e8b937b57b0622237b5c45accc588bd29f412c1111d56a511626cb16b75dc2f2af152673e8aa717af706c06e0ea4c9001e7a9ea23f677eaa00571df4e48a0b30e692961b3232fe28e4367c43883b67a14ac2ec27057af3c71d3a24bf2296675e4d570112214f2b575c0417f4dbf944ea72aea378546a348338aedc140d01699af2bcf3ae028c1c27cb61fefc039991f8a6b1a70f3e7ed8fd971be4aa549779f76a00d63e6eb153f73f051188036c9792b4ee964b1a1f2542836abedc83b62644687abcd1e17f9227308ff13e549f3ff9f67eae383880003cd58135ed63c2c6a604775bcdc448d86343d735c8f5d03060d8e415d29f707b5efc96bc7587f797c9d5c40f60171dbcd0c6e51f597d0347d63cc2fc96c7bafecf139f887f3d49970ee949333d407130af17a2a85aeef09e86c7f9c3e0a766840ebd58a3f139d0f107ebec78a53508334a128d0f5b44616ff1ba34380cd351b17c1a60a8407286a74bd36701dfd401fb23098d26018c00b761a78b020feb91cb3b1bfa077aba237695833187487b5d261f449e4d8357c080505c7164f10eeaafd85f8d0ffd1f42f30749c563e8935dcff38f5f3add2970b2e643da32b60541a05198ce1bd0937da198d3d1ef00f5f64c99cb90701b33e0f5e7e723db4d2590d4632c8378a403eb505cbbbdc8633303edcb8f5cc72df817600d7eb44a9edff440abe926dc9d3a0abda81c3dbfe58fa5cb3aae525fe85542b8de5e58bf363e08196110aed0c5bc4605dd243694fed291fb05a1479e64603db9ede887cd8d3ddf6a18dfedf0bb39f778735f70a3348fd30126bcb3d55bcdb173121047fc0dcc584bb82d1a876edbcc201bbdf51fca6b84208e7930bef575131fcf4fe82150f28beaf988d5137a341a3de62c86fd4c82c31691b1b6996a6f1ca298ef41c6b57aa7282516746c3273a6d796a07aae2551eaad17405cdfdd2bbc12452a8fda53044a6e2531843e0756a9a0e94239305f13b4deb76a67c82a8bb5988d2a8b936f5d524acd5e46216a4947ab98dcae857785fbdc654a8334e5b8ef4c7b9d2c166c49d0f5395034f0b61b005db67a1c7a706b5c0d46dff29b9b48ef301a5eef1ddc1441076953a0c4c0c3c616a1909982c2df45bf894576f5d7fe955a679f6ef639d5a9eea98ee4a9b5fffff42ded2f6ec5aef8fed161445ae4dee712b70a65e5de583a2761f7adec69e411eab0381ff8c8aa91a1ea0ffe540f8a4f6f8239ad0edb8c1d4cbbeb6dc71325de6803a36d6e3e7622f5aac9ce3503234c8cb0c36562a7bef70efaa4e24c2fab9476b059c363059eb7e1d7897d36e24c60ca8958f88ca870044846ac6398c2c0488819a66562b4ed028f58153f3cdd3036af15cc17e41c27f9acd7a3830542abeacec311615830e80a305f37b16e35ac1062f65aeac7b3908854b1cbc0f9463512770462e59dadebecfe9f6d4bf4f41b60185879dfa5fa6896092f5dec54711854908cbe39d3aa2390fa36c8c0f8822917f829d5b9c1a51afdffecf2a1e8ab7bf0a5e9b7190b395033b7f1d7cc13f4a935dac350c75de22428c2c863e673253b5009f93eabe65195c662f2d67fe70ba13b03f89d2ed0f677d1127c2cfc834ca489362c0585aad4936c812b98b6c84bcf9557951ad3cca5b0057766ac2cdfdd397f8ecdbbefedc7f20f50196a336e636ae8aa25644332bdf9cde393275df287284610f0fd246db273ea62a6c0d01c705e7b048c6c7dabe85e082679806d6ef39fee6f904887cf358f37cf8ba6ce8d1d15024158696f84dead79f72a88f82e6e1f8cd18f3bb54d933ba0be34f03eff5ffe1a32ecb4385661e36672f0faeaef0cfdf5a7b7feef7736f8b8b03fa205f12af90241226db9d0d33c0ce2e5c74815505e481d00fa4bb049cb4e8dd6365a21daed43c5230ab7881bdd11ec9bf66a9434f12e0e2edfd17bd1e37bc438bed4ac8a8b408f7baeca38f3a4ede76290c731641db632138671bfc5ad9e967f3e7a25f4995a5a3dedd9397483ff2cd0565b682f4c49dc6117f2765021ca155c90b0efbfecba1d2d8d6328e4e8b4a6703610dbc8a50c3d309a577a73c42322f58350ac33eac7e889491e8a242c9bd7af9a436f86a597c14279b596458c62d8d01087a78be0381f4d0b2934fb175bfd845331cad8a460db6572dcd5f8e3b3a504af025f9357584ad4962e01c074657dda4d561a73f5098baceba6e55f73ee8977af4ead0f8531a4e6b08a0293e2613e74acb6e9b5f8e8613103f1faca0a4f0c68c6196c22d4c10d8db4a308e56fd88fdd9f78f7b345065e4acffc1a5d2f4be5f771395d5a36e2371ad40b3f850d95db0ae8d9aa24cfa50a9826608167711d87181590e81b119f6d66b2f8a652e12b6218b3edbc035618c11b804c3ee4a73baf84795ccfa1cb550ec67e077d3d86d6b7ffd97851e5ae4d904e7a19d20a9f4111843ba5cef54aac4eccbea435025d84ccbe21ce446633f378d9765c2faa6da01633942f4b9db79b69f5d05d1ec6b2c9068a18ccdc17bf65664cd32d34ba053896bc3ff3c16fcf6710205283a65fa1d5c65930b36ad77f8f72534b4a62e8dae354ef79d02c4ba7bf098b287eb6a57b0083866e60efa59462b4af3bedcac4b9c63e4271d92b75eb3e811d0edd641643321d7ef8a419e84dc001b81f1acfbc15a38f7c822d6c0ece5dc46840eb03d65da73a3667d817df4e7a1433265b57902b4d4f045f03a90e3556f7f767ef813360d09b5d90865d942a587be281e2c3db7da8dafea5e068d256526162b807f3365a2cbb2cf6cca007037c3db7a40822444ae5e090ef4751db82e52a984ef813f80a41f04e065c6900c99c2ef2d5af7c5c088bc81553a0628449caea11ea87a820086577cf9e0af68a8b06b262da6844d22004ae2b9901caf2d5101767839e465516b36291a7b7f431d0b4419fb8538eb1e4c90c7defd228bb89bac0bf5486c49525b25e68f6b45e4eb3d563df6f5eb32c240476109ab81a62c9f46b0d2d258d809001f658024c5d1339c7934a886d881bea804ea6e0d8a22af8f04b15337590ccf275bf52e4c5d6f4bded951787bef9239cfb7ccc1c888d3603d0e4a6731a6a2cbb62503bd8ced2a2601af2ad34bacd9a323e5477a7cb8c802794e019836fbc1f4dd1c68fb3d5f9ef202e76aed31b92bcecf800a7dcdaec396fe8e3015f3e5faa8c4463bb91b72915877983743b78fe477a8eba90ea1921731021366821398069db54a0b773491d4ec8b06a36faec33c60487bef4dbe252945b189a568028dcd2bf76bfa32ce50f43ae761e1d4a88de621def4c7895a283aa25cb204803ac67c577b8f45b30057d9589da8d3d7f1ecbbf26d6572ff235b560088db026d58d173ffe0120d6af64fa5c51400101f244adb89183da6f383fd3d3422d8f9ae748c786f9e2e41773ba1b271b7c75e4c78ec161608d40bd51eff3ab1662be270182c10ffae8ea9cd7a7499967d83c18e00f26c2847b312ae12b647a8883f3369815d752a11d3f64071d49f773a7ba04472bea33ef9c16af55c85e65417260ae95a87b214d323765768cadcf1e4f68dcd430ebe6a154ad36048aee1fb8564b8b544ae9ab1927426ca9113717020ab67fee021c4b7a0647e96ce1ac8d31eee698652ee74b003a4d19113b90f2f6b445f99113a76761b338a653b8ae7001e535c8562e38b59874c9219b9099a11ac383ac53b359003cb041bef7c0850d6b36e12cb95bb1edfbc1798685b4d012c7ec3ed634fb1754ca66ed9f54d1184977b797c5094fe78adb8e2c564000e9a712fdf602f3dd25215e6dd5e7fb176cb31004275884bb3e3001a13f2f9eae45a445ee1ddf02d2045f3f8669d520e853ecda9a4be2d94541e598636ef2d9cf3d365b66c340fe312b3e311fe8f5f53f9195c79c6f8861a035c681b8fd1ebc11577e121b99f29ffc7939f26a78a53b0a7a3c7b7b1cb59004dc5d5bb3887a7ce50d7c6f47ab0f46d6790a43a141db8b13d35840ec82e19a9fadf06e2a5fd3c2139d2ea7e513100cbbc91ce5b2a1001e1382558188ebd14d00cc179e45fe400633a10d0515b0c395c2e40e5aca0dd023b07dad624086433d34c41be8e82cdb4cdbcd88d077f688512c0b3d0725e411eb1426d98004b0a8c4ba8c101790ac2505b6be458e85c84c33d59e87dda305a90d959e2d810b43f06383c19b93d37d63555bd815ff3c466443b890f70343fa0d48018be2bb9eb15132b510fd96810f245acb56cec45ddf5d3927c423c31971d818ed035dc856b700b53613b084a8984f7a62212100b66be5640cc8f04915570de09b1dd37714ec662568ed31259348f699d2164f1c5952b4cf27234dbf54a73ec918b7618d747c66603d7243bd50c3f6c7e94ff34b64f080ee5db25ff126383b60880026311f868ef1e25b329b81d46bc71362611386b8eeb796abdcd424012d9225d8fbdc9de55d20cc4c62b9c94ee82dcd14243749c98dba630da31e093720b045d744cf8d20e3e24a1fca8a07f6dbf85286b1a97c82cfb4ca4ca3ced2fe355e75c97d76a3c86a9fde87babcaaa1dde3a49a646a8f7e083c09895a12bab816e0be7a1d6e87cc4aa78ffbd149a3d0be83680fc444153c1209099deaf7f961e2d72c871e7c904c31a1257ffb31b270374cb3b654b96597d656d7a0794ee4911fad3d4ede6f96da83015e33d3e7fbc01a345032f2104fe8a44c64c35741c4cb470d9a65d384bf532e41f37d9ff705ef0f44b20d36ba56b388110b82fb710e1fdd7f63b60e6086758437004864f6b6ee2bbda0f444fb21eb547ee8bfe9386536dc3e849c0acf48f68640e8c20ddbb5acd53bc5202d7a7194eae0675689403b42aca7d1e8d40274126ffb419444fe3bdd1ffb110363a16112ce4eaec62d446d42af11274ad00d602ce9ded0328ff21e761f679623f8df60d04b2c4cae0b5749d3a474aea74cbb997be80f7fe33c17241daaf765bf0a3a59644585b69e9db456a515204e4ef476629c4539bae51998d2e88aaea88c29f6f8440a2c5f975b7179ce6dc020bb2f629044b0b27429f262a8c390e614dc81992ce16de0ecd684ce861d3b2f25e926fdeb12c75a7d0de9cbb3d2632aed0342f1de8d19133bc43752e34f97f90ed99acbf29eaf74bddda6de70482cfc8f829e8db65086c958dfbe85334fc9c639903a25fccdf2c0fcc3c77eafa1b91f4c8776ee0592958b31286ce64a932a081763d46defc5a432a8115305a1f437f1c0b4c8c6bc2042a28f5051ef128cb937c732589599f3cdc7a5f9ccbac1ff3b084c15ca0536445366d59ef6e2d7ce5df6546e631509a3f311276e0570da9f4189e508a2a191ceb55ff0b22b43d20c1eb0173229e8bd19146159fb5e7a91008c4c5914134c1e51bb9a5ca84c11fff12ffe746cb680f4913a1a0b3e2eb18c30130508b775cb5e208aa323190d2d50460ffe4930addd23392baa895fd7591cc60cf6a405f1aea0182807632b889ff8d1398fd2a2085e6fc9d1684ade566c9ccde6e987957382fd86aa55b8d96f69c45a7a1791600205d4f072dcc4c63ab0838b68715c980a1ccc06a36b233910772d38348b00c9cd1badf535f1cfd48be3dfad4c7d02d685efc57ce4ad08f6af7d2bcd41877d271fec5c647529f42b5e23185947b9ccca6ab4ad4a265538454b14ba0325d21464c47524edd0a721dd6a865dc322e499dfaf80792002cf5153c32cca1a5c2f24aa47aeff90cc43f97ad6bb48fbca27086c0ba61cea430e49489e53cda87d3270c4dc0e7be25c73faa7e1665ac64ee0ef3c80ccd2683d644543d69255661bea539547776f67344131fbca7c10da4714eb2211444f6a4b70d724ba52cc7daf62b012394f9edc6c9d54f030e64da70c72faf65b4a869639169d2f19cb834404215e32d8cb0d0d4dad64f667b83584cdb52c2f89b88ea0eb02cbd67264607a22596817ba09abf0348f86c61ebb30c35da735b154dfc8e52c67b9f2a802abde92ff2809b92aad6212dbb393195ac7f428a652f64acf1ef7ce607d25ae3640448c75503a81c38a567740e8a1432c6e98f5247015eada0b607832cc2177c9411d6d35ead515b3ebafc694deebedce41fc2d3f8b39cd8b4db0caf30eaf72050413f9fc24b3886e88dee4e76700bb8bf28496d0240a675da7d7156e0bed16611a155c4bd19f07f1671574d76d8bd6620ac8cd8b83c5b7ed34fb04c12c5c1846c3fb761ab38395d39d7bb3fb7220ae4eb3d1082d81e325de768eb4f4565461a2b0ca73b6717478ee388ecba1aca14117ed6ee896d21c5142e814c101c14fa028ee6a2a2e2a3c356837d1b79d5792f5e2192340490841d88da71af38775a59a51a7578867a3aa80f25200fc051eaa90aa89cccadca7a6195bad403ad6d8b0910729c8dd079efb5018d046d39584dbf4b00421d4c47695d8b18ee982791de4e2c41e20524c0fa21c6ffacb6f5ba5072b523fef789387127393fb3a1dffb1fc41c4bab03c1484de3e50d5c09e56f1e1d013482fd1a85c768ad7760e9920d9ac9a905f0c40bd7be225d3e9553d43feaf6b2b437c64e0188527381c323190b15f0d3ecdcf493e78f25a867d94edf5ea68e2ea8a72660cdf4c4e20599e363b982246a5edfb7b23bd74802adda8643a7c28c508274499725c7c77273722664440241182f8748d6e129c577f27658ec8987246b362203b1fe4291ba8c3a4631cadd5550762c701118a90bad3dc376cf239065592d896b6ba17333c6d3c603d2536d4d5763ea367732c5bd0842d3de1bdef044faebbe86b581313595563699b901772be7c7de376dc1eb0ff9c75d4216e427adaf597950af044c491bd7050cb2b66c4f51e40fbb26cfc3f6cbb56aacd5245f5a7344d9cf4e2fec3aab58556c9a119591047771cfb4c941e4b238fd4d7f696bbc7e952bd8dbd0b30f272c4e5367a9f4a1d50cd20cf03be86b10de93468c3d1102071e04afc8650a0cbf3a2dcfee51ae48e8c487e56a591396f502b838b2fa8dbc6ae0789ef79bd74b5af22db51fb6e6b0933340a63bdb9a6d5d8a0063880ed6e505e29ddcb30b3e991cb0ccb22df0daace84b7f69c04a300f3380eeb0f91d7d7d057c1fe03afec28c888b457693310ecdf0b351a60282e7b38b287f1553da2b36b49a48da31127c0db856fae693aa3d34933e59868d94e95534c4d514c044885b467b06bab953ac5dbabb511e6d77485eae2e01975bdf47cab4c57f0bb9c0288d147366ac65272c0bb13fd79d879108ffe19ded25bda53e5dd41dda0c221fdba5e40313197275318c3114d3ac3bedf623bb8b2074e4827467ed194bd135bddfc538e5cef15e48084c953dc42c7c5edd5ce605594cf56904879a2c8fce6e95f831980d9ac75479af426ef58c6d4ac31eddb33fd9ccb05705f52e96d33c9d84746507467420d060e05c86d40d144ee4c6c9f1d2539ece627cb43c17c2253923bd51a72ec8247494b5e535c82a7ed1b113f114399f5afc479a3ad4197f177b77c115bbf4daa40da1158faa4b18b2f1d9855c4bfe36a46745cbcc185ba017ab9214f4c7c8659aff3cf66a760f2eca7de3a0c3e957580d13fbb987fadfee77360e00f21ea17b927fb8c4c16f95ef476ce5ae4c7faccaf56e171ff588c5d2dd470bd1fdff3aaceca50240ecaa1e61297a32cd5c0d369220a5515a2cd24c751fa43b11620adb969b4a756abc145d08fad4e66adc51e0324e999a18da968d8093a1d29879870eadfd26f0facbb58737182cee41a04d971fb44c584fa01dd20c80caefc15762bc70e7d941935b358d33dde483f5fe916e9d8b984b0f084cbf02598be2d4c4485d83d519f5c3f86f0aaf2eefda66afc80c6a960d940b4644fa5157bb24da2e5f1f2c32075be4f205528bdecc3b26009ad19ddd808a953ffad4d11a7138dcc04e43794d42d4c9eba2ac850a475988b02c514e80a395e4780cef10597c9e0f3d30936e3c167b9398e87bd794f8f8982252ab969dcfd212a95181ddfa5013000c6dbed91ab91b520910b66e54a98b3175dc767092a9a3ba62532347771deea27ba1f3a251de64541fd4834f452c236ef4b9075ca6578245dc45d74a15dd229e00c7752263e785a58c993575dea0d6e211f9f6c6afcee20bc0dc8a757c4ceb51419fb484ba18bc3741c03e829b61c5024686c5e3ac8b15e1e4ff4dfdd1481c23d77f70b9a94442c95dc031707abc5a8bb9444dce1338df6eb4ddb35303de4dc4eb9d7f94f1a7ea5dd62c00861170a519053b29be69f5047ff12cb1029e76374c03b133370dd2215bea6f09784e52de21e8159f977175722bbfaf1eb859c632e30d37c5298815dea5ea2f32484f465270ee174e0a525d2f1937db6bbc20ade0f12838b9339a81375ae9e9a1754cd1a9d526b51b9264a16a40a9aeac9eb0f364eeb5c1c828421bf3bf8244e208b457ac2f52d781b521403a0fa0e8135d959b2cd8baa86a3432b008ea5de05e9ea392e5c623c01548935256a10fa792469d32bc7a1795b481277cc1c6b816a86c7bcc2376c29937f39e57de123249f59f1c7dac07fe60d17474037f63d729dc575a3b564773c6edc66ad5c9c462aae7de916669af19485074e538844c704cc117e4c77a9a70d8626e061c109294237617bf80c347c5c71a09b5fbefcf0affb29d540a85278dc10d30dbe160fda2a9a7b51a36f6fb82a936ba57fafadedda7b94cecc49613f45e4245c3faa9f08c852da09d5e16055122fbc3c8024104cb04f8cf5c6e4439595e2eb2db6daac0326126788983122a1d8cdb034cbe5010a6e4d6a61f4abf1469473756586fe1dbe755f205967ca7ff82332662ee8e43063bb85b1338bd71c3c2ac727361bc8c61f0c3041fe88b2842f8ff4e98c3b503b31b8bcceb902daa464076d736e4cb516bfe072ad08d58bbff2b32287bbd945d41b76f9e126879b42153a1681325e8c93ce5a19201e80132494e906f31a651b5c5a62130dbf68d2dc1831a63ed11378c496755b15eb0bfc30e045f524da1b86579aa71d6f6c6f553ace8cbd7024b75b061a45564a6a376b0d9e672998e9ee78e3ef513e4fd4e4a951fb0e08cb3fbd7556437bd8e6e9f56fc5d745c218495057cbb35e1b8d56f49c57d3fd2768f99a137bfb68d97d0f855e6a4ba7cc0bdf38414c1a10bb4dd1f1da9d4bfe227a04de45205520be2487af509c2c79002c23804d0e4f2e367d9","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
