<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d51c46648bf696e95a16bbc2284d186b03d0878c7e74b1df14755f32501f192bc8d09e1ba5de00007507c761ac0e726f5444d8daccce89239f2e8f86a9e3a36c12d8a49f1ab07c213865c2a90a05fa16fadd58eaff7cc074cc88b13e5b2fbad14176cf46c68bfd2690e28a320900c4ae315ebb09d3c026885264a9de3075299f6b9120efbb1a3f4f00a4819a08f31703d464c2c26c1d25d8a5803bd956a1e863ddb037905a2e924353cdea85cd9f3cccee78561cf9e956586405665f3c86655eba8a6cd668fdbc03712bfb0b53ae2c2a081f1059bd72dd2a4788491806c008d615fd61523959509cb0f940f2092033c2014b552dbd77e4f8f298a75e46dc0e97c1c7d7323033f89cd075ad9f61b4507ccc6c441722fd71d1b5bedb9c7abd13047bc2e142aa042c366e1d25ec5c725003223e242cbfb546fe41313c96f678304c3b3f4385a15a816d255e7f9cd4e6f3ba673e0da66e52a99d8bb7fcad63f662e45a47e691eb710844081cf8b9ed480144cce25f3b4f302017c98b6d1d072b87c4b51c03637a733890c810d163a9702b47d68993199d84c8709b35419e10cdbfad6a8a9d049ecd61af7735ac1bc0baa7e82b3e70b93b0ef46235c8968572071aa6b32762fc9743c8971b1946e31ee09b318f23c4c3734bc85a4b2e2008efc87d2928693e1189a131f6d0e5b2795047c5cfe05e7316ea18cb4ab161b041cdf9142fc1e0f0e4422b3a4b94f93c1e97bb6ded870544f6c24594c98e0a8f89ed22457ea5e707c97a0f5f89432bbb3ca65a02cc856106887d2823abedb350081af2959f3b8335bdf2188c7f06fcac9386bdd88483bd44397764bcc3bb5f8f2686aca1df9d08277b75fb2cb44c4e853fdd40c9874b38794a82d58dba5179236013f6dc92549c243e375ac45410ba0fa4b812def9d750e29de4e86295125ec54026675525005113697dd74bc49ad878ed04c48dfb11fbe405c58b406a2d725ab7a1f29e60aa4669d989fa738272a60d102c57c066597d2f17368259518669e38dea544397350435839341add7fd2d4ec6f9bc63f7c0047232394b2c28fbd7e08c172b060fafd2b9f8ffb9b4e857acf9159ff39f9f594e7b175e387e261b9f6ba0bec0d6139bc81f9a0244a6c1873c30ac43049b683471ffdc56dc23f61d87c6a42cddd59cce948cb9442fd66ee55925243f77b620da59225058485c1eeb336dfc5f0340a4d4a5f8c0ed68cea45b0785a063262b8b57c2944a74e609858d1620f38c43227f7b53392f34695b87ce21414944ecd2004d582adcabeeab3d1f11e0fb2d0cec059a9428e2055870c085a1752a5d1b94c9ec43e0f7147e60fc6dd9dd0784bbb1e5b8bc22425a468bfe38404ec8ca5704d93880afb10353142301109abfa2bb14b281d9787431b466994a1e10d6816a5811406b6e6a99762f3eee26fe8f8abaae7fa42d0ecd32a00584eca1977bd3bd735aac2d2af829542e1e28731cc75df4eba5c98f323a9632afc9f29eff73cc9d0ea4d19a718b67642da907382ede090f768ecf0b329570d3f10fe1eb6859df3f896e92686d9f2a0455ae01c187dafc8b22c966fd6f83399eb7920f02f0526c65a423ec751e258d0a9dafc610deeb700b6361ea993068af5d6b74e4ee573f9973345ed15c97fc0bf959c78a28d0f92a1404f3fe068a617fb0ad78389e48a63a36bff4e75de8c90a38e6a2b07abeea507b9f28743b5f327303a3aa1fc77c5e87f3c981fdc46ed0b7bd4df9feb36ab1d68f43990071df31562d1090fe5ca90f546a17ce7a568d2c9834666ec983563955aa691f0db38644d701109b49cb7bad7723a6715a961c17de56bb1b34f3a5497f1ea52eeba36986c1228679d53f8e8b52bc16477407bcdec44bdd6df42b2c18a4cffb1bf00d368a71c1cd36a0272a976dbf6605e2209008e7b696ecb1216dca6bbadbde54e4db8eb0c1de0079f4f1720a84f8e509f9c994e994f0acc87eba100d050d6bfce77de2f6f40ad723cdab3a12807d99acf513e1678201d81c6871d2c03749775e5b6e2955fcab21e1dbde7abe83207f203b6e7983690058c051e424eb7dba55a16b681a04a36269c0b68d9304178d80ab685aaa2978aa10e44188f9bd23198687c430e6771cb20b8bd12ce002c231a33ddc4d208dc2d49ca8588249da2e9af413f9125dde0b45a8f1cef8cc1dd77a4d81f96cd9f0f2cdb79203412dea53bafa5b135486a41e982ab5cc053871517df6d9a57b76becd74ef7c578e3fb1a78608077880adee55f60b3e5afb3bb9f42ca81791d4b1a540759a13eaf0269a1ce3ec9b6beab8bb6572a442f97dbcc6ad71c1a34195c7fdf5be3d5d3e9b995e7aa045280d26705052336281877412eee36e7f04dba5477babac4edda0c87d3979e9636900626bf676a65131c01cb63b2e8169e02b985cee323651e4bf691e8588aef16cb33fa8b6469d865c1a373baecb4f6814fb23ce61a538d1f2640659409685faf161150f7cca9d805c13f983ed9a3bc000adcfad2aaf33eb90d6ae393fb90872a1e2a13376f809be05f5033fadbcc6aba0c75eca5d7041f2fda55010b55e4421168613abb8ee768fbecfdd0da6175ccfc03e6a307b39defeb5b9eacc27e65cddbd58da4f41e7cc02352aa2a4d3ad7c08e09e54464748502d7fa32f360e5a0e8ea1a5cba5cc33519b594c59f829ff1dab46df5e52fc42933b6d74d82422e48a5bbb5efb18814cfe2fd89837280246742217b0c28bb9840d29e62e775911bf7ef05ac6f0559714842bbe8e8697f3b7cb93dbb238c98c0685bfee0a1fbcb969502eb9956818e043fb1f79f9765f0a5f9a52876ac5867541facfdf9f3072517d389cbea3121da1860435a907113ef92cf24e3e573b53002e80d41ea728456f6de9823c0c2bb7a5068e9d56d5c12324004c050105c45d1aaa2099d12fd0ba8de246f612683c64d4bc9da31d70359a0d6bdb0943afa10ea67265221fb8fd64776651f96fdb4bcaa7f78af9bd9b6c31ab0cea59c4222781bfaecde6658f2e7700839d347689884fb9207d8ee8d4009ec12317c2e0eedb93d912da19059211c51327e947a0c664edf41779fdf49d0edb0c227fcd7ae3f69d3d53eed8cec136ef1def573a99a0f266b451811142af394daa71efb79497be609805cf227c8d7b4aecc0ef86ff72928da6d53423761dc15b888a42698182a605bd05cba51466aa8076260db11880ab0287a369473f88f6b41183ad5f6196b0c5a36c2aa410ed4ac71c60a9420099947b6a671489a3dfe09f2812c1ede76c704885dcf3a869cc103cb9934894774c2ce73906b79d0a106e4613a411e7fd7ae1531ac00563cfb71b56ba810ffd55d4a121db0083d1aaa819eb5918a3be9ab18c709208a76824884d3ea52573bd6051f4e7315b5408bad9e8ebf64d963cdaa600fe1921949a852c24455463041a37493b33d7098efb17cff4fcd4ae414212514ba0d5f83c6e51346d4c9f76c436191feb37f45593848ed9cb566112597b0bedb7534bd862f6911fd8506e314c5bc683e1751c56841c623af401b4faf12c59da73f49a1d1e914bf9b6323380232ab80bf3839b4d6975121635bd43dfafa15f918c87ded09f00ef0a4f48715bd992268a6b38a67c205194f8b07cf7597c2aed85a0c09f6184e192a3d2b7cc3061d85878abff1ce09323b53030efba732960224163d0bed006e4df703b2d36de8e0c75ad91a68793a18efe5178648aaee3eae7e4229a1f261f169d221734675fcc9c680fb93039a41e925431720daed1232c9eb7b2609b4217ef05c4a1cb7e8311daa76e0d4a38304666bc7c2d2fcf1df7e682cea5aee7bb4380f1cdef275b8c1ea330542627ff12b3f2374c26e0fd94908de492ad69c8463950b40dfd3c2e3324565690b8fdd349b0c6abc978c198086a0eef6beb4c8f0c338e890e2e23ab4b3b8932f6441449920fde56ec12f0ced12c944f3c06fd0527a7adf028141b3460f79551b49e7eb2c456506ac02c8f9d455583127c86a8eb067553de5d074f04aa6257fb2b5fec87e1c93947c14b41a08ae08db30281c43fdd207ae0bb70562e2f2c65bac54023cf3556e61dd94f1735cf8b5742182ecceb1f2f374a3c5a43b84ea5c4ea586195388d43c9f7760b907984d37d8db8563a17b7bd9eef7df1112bec942004ca59f662e4221eba8563956579e3db6911d6384b5c3af58532a8ece4404834912eb1fc23f1c7f0020d672814881b15310e94766866f9e12f78a6126b46df34d724b8fadc1bb1dcd46439f35f58d2871cdc1359cec45712ff966910274e7d0d92da5606187f667342277107e6630e2f6c8654cf7197d55d1458e58c609686f29874d3e5600fe49ce046a6bc39e067eb8d92c9d511bd4391784dd7c0006f6b89957f412e02b4cedb684c78e4ba4bc34d77a5962a28ae7b793527e13f6b46e53fa38a2dd66448ac27a49c2d6023bf89068968fc892dda1bf55d3a5396d2f9f72133743779f670d1eba854712223f175ab88aca84b6d6197d9d9074dba95ee41df056a5ef6f7fc314054c18480c3a2c18ea9c727ff9aebc86347c902e91ea6834ce15406ed200ff294800641312e66bb3ba939aa87c012b9f4a190e53676d0f055ad9daf53f307bcd19e3b0f500e5317f5094590507ff2129b04f5475e035904e5165b88955f67c1a8616440bda959e3e0af874ca0bcba1648ce2fe37ff7417eb3ebb2445c14e2141ed9c9197f708aaab7f3d02f11b2cfa7e5b2ea881f7cc4d045abbb1c3d0d3fd9bfc61be182eb26ac70b67a07fd4d315c21f44058c759b586afc907722a04623d9e59a5b067b837bf2f29c7788f59aaaaba990f3cba01c3291a9d4edaf55bc1e494fc8100ec45a49a6f9717a4feb9b1e36a4d0aca75d0d39a1465ce5c75ce1029a14606efda2ea1be38f5f7698b56f7b0c9ba738ee66e98c485ebb5f891b280748669ae0ab4037661c4fd9ff2769f9ee1dbaed031b780dede464453ee9287fb515a1bdef6489b8c8ed10eae8cd9f49e5a017fa8a4275713947f3c3996af5205225059d97e79fd2d975c72b623c4847423f2a4854586f2bd2daa4b7c5fe59b551205ca259abe1b709fdcd6939190f370845d20a6f1a2eaf6e1d6e6a254a00dcdae8df6d78beef2bb285a7c23af652aaca688265d72b998ef8e1a99125958b16d9a50e8f6214a3d5c934073553c291c1dc7b0e8857164799918135d7d17dc896ee1e1a47df7908b6bb1c0fc7a2de0182fc6296f6866fb539dd90cc1284213c37f719a1c97702b805a751bc2007daf43b5e20a1d77e940f5dcf454cc3c5b859931f0fb9785b3fcfe8df82cf2f250c65ff8b3831c2d1a765dbbfead094f97c6199b1740ea59b6014f6dc8d7e1dbc0aab8f67d3e6cc75e05f1eb9729bf122883d896c9bd65155c4e4d91a94cc5a3ba2d0418e037a536399efa387e96839f0054b523f1f8cf224e6075a36b15fa9ea9159766f7a319666b330427fe8975afaad21eeff608e04ec42ddd14a0113cb114ed4a66ba2c28ca26fa3e8de6ea509a19265da656dd95238b6ed5548a4a74a811f1708e22eab922c7bcf726c2a34ea56e2b2d558a716258c9cb4a3129f95818f032894def3707e14124842f74983763dd3ea4377f9a4e1e15d255104165d8c0b0747b34616b305b612a4ccbbff69b933fc73a217a987972da5096c7a67cd31b855cf2e29e66311ae08fefc6fa077b347199a8e734674b3100fff0877804de03c80b284a02bc434483031c13e463fdd49689077f5d8cd3fee716df7071195b863acb311c45b9f9dce70ebcd5b188d2d2839cdaaa6e88730053fb45a1bab2634b676c72a473ecb5d122f710fbec153c03c41896e15422883839a38499abb4b6befd9909ed308528fcad1caa791765df2956511914c1181a506053553e05141a69d366f41de0782256a7086e6900c8856f32a4dcc1fe327e50006ed102c6650431ae82e04a5bedd45005f42d1e2a218e0952a7084a669c006e67c5745de3da8fdb484e8623055b7b447e505c7543a6eec1c015ede7f7c17845f961668093a36f3f5201cd5ed7fc56630dc6261852ab3c9b076dfe716bb1f8d02d0f08e9d10c29429749b38179ed091a2791aabcd49d53b8064dee16cf95bf1fcf1052877a6b84899c7d99f6634a0d1e23b97f0a545304d5cc66e44dc81bc4d0450dad590ab58d1a068e6a42e10ca186dc5bae87b5ef38f9654eebcd4a4cf356036513be74400947d84ff0a4c8c3e6ed17ab8264da9f39b6aada6ebb8876b698af72457d39782a87904428f98507c58f82a5b213d20116e5a43b4159059d9b9989e551b61f1e7e0898eca29f12e6a1121cf78058fae19502836bdb82cf65f98896972a83c1708c4a28494a8ee05379c2377f9f8ce02be23ee6604ed92967e59eb7cfa99aac5a2d533398d4ed99fdbf8d6424ad147bd535af6e515029346beea55943d30ec8dff920ac253e06cdf6661807b72180efb3f477f23daee9dc35b9801cf6d7933f4c7f16249cc2acac8979c3ebf348cb5709acd87e8e4fc1dd3f85cd18a764eb7cca0c20542595b08f1ab04f062535a4b228ad479d26c71f84a0a4233d994d7c25a3fc5427b7076e497cd0d9bcedc2d11a75d66ff92d114b0d6a99ec32db606c7da6a809f588b7abc0cbb1aec757306889f6fae61d7ec6c5c44d3584525904704301883da8acb78a6113b94f2b0fd5f500918d7fe8b63bca9300336a6fdde1ec56ff861792894b744c50f93672fcde0c2a3e23245c9542d394b531dd25a01784e55254418aa5854e1321a23b0a41f22b317f3c31e95cd652758740ed1d14e9d81a9dfa22e862185d661b03e3b2cd1e990aefdf14a7c7ab6f7adfb6a111e56e206a2a4acf2c6a54346d224c647fe41f9bcdb26472ef1d31eb7079c072b409574aa2f94d157c2604b337e7ce9b3c7d742e81e98fc31a765b0d807bbd57d65e2116d2a28c99cacdb9ef94dba4469ed7b83d7b64d05dd1df1488dea690d446493ee6726a230090d27fde1a37c904da8d6cced29916a78a3f277cd3dab89f709a213523cfe5850e88ca2ac63866f0941f22eb2d06415740ea6308f71af48cda84a46eb99d013c5018f9b9b4be493807efb356848ae4d4319c71b4ac03c51e0e83b6f89ae9a430492a984df08bc2bbd9162f06d8c48e4ae6c0ec78cf3ce0393477ed4c03111530756ff5aa86acd0d97a04498c764ad86939c470bbe65f8352b1c9b5e23cb5b1eae2de18631afaa3cc663d8062dc7883dc1c5f7480e9dd2869fc2d5f003842e4716d60faa995e62ce99dfa08afcd13b2cdc8d3dbe40d1900b7ac6d90bb3e308f5a444c7814d205e717679ed1e660666b4b0aca456f42830c611937095cb1c730e43d4518ee82c46f74c6816c67c3d4a3c7388187ff64e04dc9e89db884de31eebc73a8593320535b7029ccb100d90532f0aa3f626603ba4794417c15c0e9a21cb275119ace0bea255077a1678b12b2b0279873b1220f595d263d851601b28bec38919eda3cf95403aa83838d374ba8dc3e4c263a821d290af31461fefdadb932aa51cdba9b5a829c7e2a95bbdb7dcc07adbd7836302a59195af52c75a4e74bef4c3c583f13bc95aeb80fdcf5434b95f4e0ad8dff96de78c22c975b48a3dc6dcf3dfbc61468ad9d23745125fa9c62938a25e9dc7503a51f82b160411a29cc771df79cf9db95c7fd2408457d0f5897f0c8404307eef4437bb308a99cdc74688fc4329ea8956e37d86591c4a406f3d9dd6261bed736cfbf40288d172ce6d61ffd61cf1ec2fa4b4928252a37f527de25586542a6101ff9d0c1a5f89b10b55e65062c439602f5c61938097379a285073c0b14d86279f253e8b432613d33f542b8dd519df7d38e975d0a746d05c63cae9919b803ce7b97a7724281e3af66b87167e1b402d8acf79c5634c65b75058eb8526eec183926fbfea9334db9aaa5796d28d248c60415eb1fc0ebd4749133ea3f8aaf258412e13b36e596affe938d84f463b896ed60e1a5090c7922175c5e4be379b24f77d68a605ae69eb62a03b34e380ef8debdb02ab64cfd3ef7b19469618c2870be2a378468d6851ba50b50d0dcd2bebb962af58271d72a226501c7ba5c8c853bde22320d0ba3a877e3ae970111db2fe4065d078360ebc41024a2c1010164761ce4fa28f57ce76605c911942253874dc403257f665411439c2f64c50d34edf4e5aec9ca0b3a07a0fe2f9bd62ae30a729a40de20b0ccb8fa41fe3ba3ed4e89795ed47bd0e7de40585c5b5836a3a20109e610af14754ea425cb00b7df6d901b6b4f1aaabe66b20302a2008beb98b66525ce488144fe8e73773dbea12bafb450c1faecc8235bb25331e7593cf8501627bc3b311fe8e59b43f7d2d7493538ceae7d8e7e0723e8f389e54267405cb1748e03e3bdc53d1cae85f721cf99361c0765668ccc42dd7a77fdd04785b9299dc78679db9aefda64f87a63e2bb4df5b777cdad9eca2988d2c300f1dcad4ad053ab8329bd5e534286e3c742c040c5afbc4caff99d4a23d66ca75c95096e5c1bdf67969e47228607243eb9fa221e2df3fe09997929c969c57adfc3a2f553d20082cba4b46fb4c1234a9d5590faeade964b9a72af8be62abb6c01bfd6ba2f4eeb6e1b9af2828cc68aed627fdcf81a5ad8f4430e3458b307307914a0f1948e6a5ae7221604b6f74643ad78571517c37567a2fcd0fe9771d7b76250c6825440cdecc80f4bcd8f4c7b660c9d775dce63f62aa1b3aabc574138a7341a53e9807eeda0811dc66a9caa7238029e96af79c6a024be412048cbc7fe89726d3a0129287a72547c48033f4c829b1ea6c880c651d745b866edda371b39a7ddb8eb615b5acc1051c30baa1d9d977a6ce2330616273c0ee846a84bc54bc3cd035a094bc073168ccf18a25e4f58f628b8fdf218ceddb54296443901484b49f779d54045190040934ad440c616d28d4d1878f7a1e7893c1eac74fa765fc045382de2edab0ceb2290d6e8fb6944aebf60766da5ac935a6945549cf26fcf019f3da406df18554cd0d4df93b9ef243c4597ac84a4a151047d7d6bc63c4965d6a9d7b89add909c2ab3b369dbe187252eb67823392f505edbe081a2bdaf59ac380f0898b36deb82a07d599cda5bf91e6f9a2e1d62691cbdc5de066ff5fdcb91ecd82cc6b6196bac7a86b29c0294d25ff5cd8d43d6d49fdbfddcd855e83182e0010eeff5bdca0c3b81b5afa4945e8103a9749e8f2e9feceead97ed4127f9baf56f9bb734d1ccc3e677e7a320f79df1ac92ad7d58d60cec727bfcce241ff492c36419b3a8cd87f7213c7cb494134faedfe47b10e5082f36451f258ac63504e303d5014d206f3427772dbc1297facf0fbb6bdf5501e79c1cf48e832078756eb18587fa1e8f54674a4e392bfade01715afc299a328b3f223aee6adc936aeedc69aaa7dd4fc9b59d2c8ffdff4bd91462e587dd13625273360419219a083f28542daaa3d1b90f29276dc9634e96af92a86bc90ef3bf452d7995afc2d257917ce77adcbe628f02a95e7cb227957628b18d345b9ff2fdaa3153f3133694902371b68917074d8f00cb0403010175e808a6f8ed864d9789588e22493faaf85003b813dad5d2650afdc038e18464e7b73f9aaf0081a9c0a2b2c991892026bd54f81d24c373c3d8645ee4af0d5829c77472ebe07e33f0343fa4b1ef19522f07071415aa8a6279cc3e16af2932a93cfcc616c41fe10792c46adc586bcc0aef72e4a3d94da2dd79727538fa2af5c4ae0091cd1b72d29db9573aab20c4491be582afecc7e392cd8ca134a7cc8cfede2a5f46a3d091851ffa1f79ce0008fb381bf424bb7ee98cf6ea7ac3547c84f7e95bb9df156885c5ec75872da69e6c23e956228d8501bca887b8373dd5c482ca3828235b9770f4643265a2333c9f5cfa787a05ef6fdd74f9f7ac718c054b94dd0581d9a341eff2e2dd7da832cd9ae0bd79999c2b4dd89618bc1d5de7daa24d4905213914af41c11b54b42e1b999426406749df52cd074073808680170b3d440f181e6ea1988d527d90bf54a7f05eba610c4c2678d6c9f765dc85b4203280126c0d0180d680afed695e7c450cf322ae977b0bb4b549788530f52cb69f7480393ad218610f25fe949a14208923041ab40703e8130c88d6c28e579db6188aa33a57feb8ba0a967d790a9ffe68ec76ed637ec7f4d3eb3652968f0ae4200dc8acfe8f1dd9211731e340f848b0c93b14d060c5261cc2cf078f4a47bfcde5efd7fda1dfe681a3bcf84a604a1e76c8f4c26afb6562fcfa8a59ec39c04559d79a25b118c50ee3753805b2a3a6e0d0978bc9a811b82c43cc02af05bf46d2a4a8e86ab4a623e78e1fdf0d5d7242bd867c3bb4a696b265fbbfc24af52470c3d015d27a86a03f0ad3ac82b349e41376528d3a5fd07a50a5a1603da733231c9bcf19d6ab48363f9908bfac87659b88a879cacf8b143fd03307cc1f476bc42017b4ae49742a53d48eeb025a74dbd8c71b32d18a22ec2c33c96bf8c6027668e5041e9a67b3af629f5037b1026d415cce174013f9595caa1291f262667847d48eb5804026cc3661318c1e4ce7f12daf0ee4cdacd8331a295b66172c1c1674124dcdb410382c81a1330eec9fb442eaa8bf64de1db09d382c7af402720853103336c5236417f4b32720e77d44268acecf06c847879a3445425ba6640b28682f46eb77f99fb0c8a04eaac41a88dba2592b202fd7217c366108b63025946d60754bc5ecb47791d077a01a006f054b5fa68e86c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
