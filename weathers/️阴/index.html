<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87bc8137821f8fce702a8f181f86449ec9186aa339c1def33871884e90d8901b1c34f371e467fb6259d03922409b36a78385b8eaaa50ff6b0094282da14849fa99d5fa707301e021848b4848b9f5faf85a9e19da3511709998681cfb6ee0c12fc5a721fcd41f53ebc1f3139bbbcdf3e85440bc021e33d2eea5b1ff0467930eb3455aa06ca35288496d3261e55b598b67e30401edd46a87ac8f09a995186e0b1b22513578a276086d0c9bec33a4a50f9e98e140b50f4bf19c0df982b8a427017b486a431e3067c649b1a2a2861c019e9be4b43ba449efabb7bcb7fb8a3648e94881769a15cea74b416ec71138794f6f11550496278c2dca1f45127eced57aee582c06a682f434a99fdd2af333481194ffe2ff7d60e0a3a7fa0c86d91b533e4527a8b8b49eb7b30ca95640b0d8fc6e7afdbfa46b65dc661142b21a62494cc6ff79cd6a541441dff726ee48fbdee919958982a128f1ca15a8aa04af91bae6f97ab8262647b170c72d6b8129dae68184c46dccb0d8a36daa92e957781824cc3079ff4a4c198bb15700d422798549812d8e587f2aaedbc5aa50233798e73960d202e2e008ca7ec2f467b489c238fe800b26b525fec11fb0b2b2c311c9197e40839fa4c73791b68db18d8cee3ee9d0dcceeaf145d76d746b4c73d3e29424ab199424517a1abbd9fab7de5461dd6ca1d3e49cc847b4c28dfb6491895bd32310126e71130659e3f6d7f4ba1fd233e24260840feb87992cc7ce4f2666bffc73227f3c8e8f8d88b061c7008031c8f73a48e8fd0b9fb641c6b8c3b2361b3b5cba4be5bcccff13deba945afc1fb9223410fd656a4203591e34df0e993681e441934cc036c5375d92588cd02d1faa60fd1d7221e9020fbdf80d0051fc44f3d4a630238e7e561af6b07d2c4652441edb0facfa04f626cfac59ae0c46342a6d5a1daf4475cfbe6011a7ca09de76a5042d375ed3c2a54833b25d5ad2b5f46d332f018ee145dc16c67c5891a73547b4d426fd54b3a756d5e26607f0861b466554a9edad52d82a1ab33c01b9c089a88ad394769bdd61143f010c0cd13cf6be7ae871708c14e24fb7215790bacf1ec50d95becb685cfedca80a831be3704611ecfe271da9da9d9b2ec10386a017c8f2a292700e3b9ab058e55e1c939b6fa2388a859aae12324bc60c65bd4726facd703c4fbc5c9e6e85b0ae923c441ea24a6984d9ddf4207adb906f9cb948bbc3aa6e15842ffe40264a59f23274b1a95809666f585c6fcfda8557829f6a0f238b049fa187fb1942d9bd6150e6a2fa73ee1652f8b2b2ea5c389b7d733650e68e646cafbcc2bdd6555b77404cc96c2ecd97b9557a0a85da3c56d636d447146a5693d9edaa57292b1d83962062ac14639a169b9a678dae6d07a7ef7e03c3ac306408a9285d4bb9e4fa13aafac7a94eef1b929869b6a1e6bc09e9ff46857ae19c2f0149e79adc3feec77f209045cbcdb7dad1e2f03291845436c8a70f5ec7fa7f1b382be830dad823d201e89e78c37321d3d23f08251b230bd221eb10122d719a2200e08c176ebf8c4979393d7c0a32b423153a9ac7cb12b3b5edb85a6c6dfa3641349927248472978a38e568f497fe49aa418e0851a7b1fad9f201b14eb423e74d331c073c5c716af514e4c279700e400141b58a2a8cdce800e7b9be8b5e3cde5818e69a0dcf575224d54e22169820529356c1396b78dcc04da59fbca8f52048c151b93d304864db50e6e08da5d635d07f243871f4b80720f85b4a154834c062e6ce09c835c548252a4b45755215bdfcc8c7ab90bd3c00db1e8b60b43a1a33659813d2c64c6fe119b9430e2dafbb621a68567daecc5f23fddacb5dea536713a741b22b6f75e8982820136062606902091619b525b34c728af21131ad24f1ea63c2efcce91adf79a1e6a933985e16aab12faf528fa3dc9da730115ca58fcf5ac4ab005fad7a76d2421f948a9b3ed8dcfbcc36434f06f72253e4de3ea44c3d7d51ca99d01aa9239b5f89bd7c1d894923c3aad287026e2b7cba65eafcfa8d2e50d2ebe4c21eb406daa34c243f3f16cbb4b63411b4390ecfa4dd38ac42182ad2a4a060b052d505f60d9c309633460a49fd3f0ceb3e774e191bb146601f8136ae5ee52f70b945f8ac29ec823191aecbc70cb5c108f1f32c6de7641f9dc456160023c655f6cb4370c2afc993395f992290e0f7c90b0b7c61466bcf6c178a7a33e921e4f1cdb6f86e8b7850abb7cef9902a3e697d23970f49e27e967bdf0c15253f1eb4a07c07b326006b398fa4ea9409fc1e1849d448e786a56da7a696737381343bf8ce4ac699616fb51f8544a056dc176923479c93b44820604ee117d22276a7707c7f84d03ece93a5cd5f82a34f623461d4657cf757c0a5657d16eb683a50dd280c0d252b68b4d27d258b2a12c7ee1f8d64a6cb792d5c2053474bebe6282474b22777ed80de3d0d4fc50d145f19fd2e0159ad0f2b6af354cd1d7e66cb6acd0d79f0976300f1477ead3f90cb704a5392c9300607a19429235bdcf5a5a8b3dd8c3e5f9ee79e2e601304fbb1f494c9ce6e10e3db4ba73ed44ab440e6ee42ece11baccbcbd9da0adb2ee005cdc2aaab46d15faa7309b8ab1d5afa11fc415ab99818224d0ee42598542a5eba9d43d550fd1439af2b6a198df27f14d73d41ee9c9eeaabace320db006d005558109c78f376f1ec42cca3b088d1513da41c27ec8f31555583eb91ede6c0dceb77e5ed1a26b1394fb1cf3c830c3fa2ae0f39c30164ce2811427ba4a9b716e5f780edeadc9dfc777fc482421c081ca7603e1c451c16bb6c454d38cad963e89305d29b0d2ec9d1388b61a4d88f29ec5d9a7ae7911df16ce2e175151a8c4df575d5ca9695c7affa6d2e23fd70fec5e6553812313076ef3387657961c3cc7b0417d437f773a5b536f93b50e499972bc8505dcd294221454d259923ae991ebdb9c3457cb14ccf8baf2c739d55eb0b9be88c4f469b38fb1bb994b13d1bd60f494b247cedc3f3ce3c55e2b697100568619bdae2476b000807a743ebb1279f7681b40778820c6fa35c8e3d484a5b1057d9733a8277a70d9add0c77a2f11b4d730dfb328540577fc08243d437cc31f6551c667677283d79185d7190de20a9c25c625603473ebf8e1b2294882519eaf8c02cf335bbc1f67c567ed157d63db79080b48915ac0dd97d56a500c293b2ce37ee12c570de111be3ef7e312553247242353a3bb333c1ca9295dd361b9e9e40f5d8075fde305eb4d50f692a6e3519e0ed88964b2944bbbcc7a857919903b9192236fec90bc3dfd4f93e5131cd9549d8c00a6cb03dfcce28f4499672fc3f54a4d598dc8c13643cdb48c8897eae62e4683b73a0d0f521741fba5b1857f936931484f9ba98bf50efb1d7a3ad5a77230cbfaf2bf3244739a83b859a48c071d239ee23bb7552fd857902f964afeba9c6e6e911dd35ebade579e5dcf0a4d783813425659e01aa362125bc4dbbe5f588d8494aff8a6fbf32d67e629ac8da7675ddb60913ba38083a38d93383cea2bee299504f54048997d7c86779bcac8d6fccaaf799833ca830029f4a4f187b1b2bfa7fbfa4305e66fc23f0ccff38f4ad4d31a8dee7f44e873d04a5b97a4985c07b487fd3ecfb64347864f6f8c2412158f0eebeeff20acf1434eb9abfb1b5b59088e80a67c90579b42084d68c65f424a0ad3f0efe5f3da8d61b49241ecd2f144b7486a61e1616bb07ad49198650324160876725ece9d178c10202f6839353ce6d6843a841a43e1b289b999a1bb240009fa179172091640a762543076234ae52f3e83c67e917b0f9eefc83abbae5540175e578afd295b20c7fabcd063be8cefba4fdf683550ff877ce3a9b4e398a84d51a18d6b8389a63b82be48308c2e68d77329f82dd79ccbf1826430e973f113cf63125cea7909faa335b01458a8507932019583d6aae9c909bb13e3e68c9347fef0d60812c60d0d9343a006ff4d238abd877da442024d1674c56239549c308ce1debbd562b251285feefd6a462c6863a5da0e6e03d0dc5d66afe5cc1d85bce2829aa7373b55e245f387685995970614f4faef473cd322791039fe52c3604406b252717ebf557b83fda3b286476c0a705558bc7bf71bf0c8b85aa4048fa880c66d9ab7f6d59a97f74202ef560e5c7b686ab10e50797b9682a7658940a1350e0ec436d5aa1dbabe40a9c1e1cab03ac5be34147daac3d0bbaf97f64ca3611bfb3e9ddbf8132a3ab4e9611ffe6d728fd15eff238414c7750b47b9a359d237b87b9a50b334d328b6a47f821fd44b4df4b020ae2a520b87373b239ea046c1cfeda77f7481057e31fe8864d24b9147dfefb2e9267be4cb673b09241b79cb52468b34e6c4dc19c7c6af789317cc3c20089e984083de96cedcfd84ad3022b362c336529c5d5f0171904b71e630e93313c112f3bce8fcd5cd41bbe6d492e6f2866e6cab503663578024643787b881ac3f24f095776de3bc69660d2aef8d08dfcc6e2fcdfe87c9f5a5162061686357ed6aa53ae7941d79e744ec75977083bdbae614788f05855242fac589685b032651e6119c8d85ff80a7694347b0bc3e29d54ba7945f2e09b442631d7e6d01d74d9db01f602780d4f39a8c0ef6c522283d9b78fc206b86f72553ebe2381ec9f1226facd3e0d1d0cda75369f379bb037917c49f0f599a5bb41ae7b12ad802282d658cdf18a73060e1990018dfa0b561566ca4b8a7767fc8b837dd862217d41768a2e7cafa71a273dbef8a88f9ce5f18566e53415d5cbb09b58aedb7a1e6d5ac2481fc7d8f7a7c714edaa73dc6621af81773a152668a1d482509dcd8fe1a3da2024941297d43a92ef571bf1fcd7c4c03ae0e2afb6aa69afef1ecb4bd3f5b07626c7985e27356ae0546bf948b98781b7e90bf2e0cb7fe0544aa7090efa5f3a36c0f7a4afc063fa7e9ac4c1e52ce5e08bfb5f7fec7e1cd174f280d9babf3e02a1d83100ac0bb4d8ca9427cd6655d4d0446c797fc2c649dc3d03db6d7da93fc1588ef6b6ea476de903ba95d236b2c245422d06dcc890a06e569e410ebb4917350febb8259cc5414a7bdd708789ba79ffcc3212de06ee68a2f3d8ad2dfc42dfc4cf65ca5eb807d05044f5915841cab8562a63c26dbd22ab30186d34706934b6f18ba34b58cbe889ed8ba5febb8ccf912f436f486b55ab85df0f6c39bc25cffd623e54cb2304155cc2f6f6a4743fa84d1a1d75607ef92be792424e745474a265fc24989c6101cc541c90679a93ffa875ac40b385ee98bfa8b2c53a3e63b8b102ab900f5181082ac8fbab22d26895b04cf4177c8f7505d088edc6d9884c548ec8551f96752236d77397d477fa429cfd468876f420a0e572986e6eafa1c303e83567adbb3fdd4aa670683b39093230ebfe6387d78202393a40a396478b5dcd1df455d34f6061ab80c51f318d8c90b12fa887a87c766b7ad1a80d8e37ee0af71217c73538a5193443dfbe930e753e065d5c3302af048ba8958e27c8cb7a1733ac01f54bf4966a3bb6c63cf7ad0c6ec1ec831bdf470bdce3cdc648e60ec85108d0b630f0481722b805468276c7bd12635205b20188654ef6c3d4c74de87b7e9546eb6e34ac6e280dd365040013fad28abc4f8c643f49f99c2796bd511ccc0c7fbecad98c2222da9a5dd326fdbdda030b9f2996866b398d851242ac37f1620d92b4399a2019a3d424f0870b7f412734bbd33a0231cea91471a445b33de2fcacea2f82374e24812e4c415d75d6d8148b82952e3aff1f6c6e1a689719e748471a66b52a94361ea4d290357b59c52dd48904716a07a3bf028177ff70dead582af6500c5b3e5981f4611a7013428519b052a7d1e988ffb5e36918bf61a82644c51559edb2214c638c1f8ebe4bfd323784f73563d70aff3f7a6e55b852b218944ba050cf3e0ef1e2945e7fcdc9269064aff364e5000fb5d1e93d68720d8dd4857b934b3bb91322ce1379067d3b9ab49ab490b62cc31f488f08e486093b2da93a3e5a49599bc842ca7e90c7e3492256384728668dd208a9575f3e2951142e188bd9e34c0e1ead402717dfd2bfd43a0f7c263396781aa84fc898fd94ac9683303f2a3dc2a87af2fd51684eb3425a47957f5fbea99c7786bc0003f613f8d1ef123f6d78581fe730701b1d20c113ffcf1a94e348f60ecf53e9283f2e61cf01b910da85e6badb7ea8d8b61f5d33a2fe2ee37cd4223109e0b00678068c282059e9c0a93767e5a56b1d0a941277b69fe277e1032b739cabcdef7bda323fc95e7a94805cfad0a8e9b037e88e314ce5e373bda54d8b5cdffa4c21eea1eada5e9a39d1633cc8ba5794d7e22f9f8997dafc11f96530fdea19b8aa7d9c7edeae47e3d55fa72b417d5e4ea2c117ebd3d6ca68950f0f6bb20147679cc43f61bfb36c6020989bc200a876e08c82e65d175e9e20c2db01a7ac2d2f22a6949c0ff80a0165695f0ac821a1e033c68975a3468b30384adc69f01e5496edd3a109bc99d221b930e361bab6147dbb8362aff8b90b940c6326a5c10c9105d372eb74363a1627f8addb2dead3b8c9577b5ebb28b7276e190a3bed106f88e048b81c992e1011d5a984d54057e7f06abd48e9c91963796bd882751e5fd8b38cebeda1ef05e625c4599e68c872be3b4e6820f1237e00d54032bd7c6d4ac02b6a15857138ea78a43146beef72ceb67aeac207ffa4f3e9a8c2fa9d457fd77a674c65640d651723c55deeb75e1558663243b31436f499d29680116e67a220ab7ec093eb9f6886da620bb0d354870a4ae13b2802f8dcf9e2cac3ce6ff18e647bfe7cbcf5dd110d2ba3cb3683a41d6024a9c85e1cc80ae6f40a79ddaa23f2d929a0c5ca9acc1245b98bebdb9cddf2af53794239defb1a0c0ea854f81dc524a1ec492c16d97fb122856f3e88c196ee80b02756071f5e38a63546418c02c23191a4a69706216f6e35acaad66edc429c87225cc6a94e3d5ef233b1d535cc9481a1820e35c07c35c2cfc5569c5aa1c1bce7478957b79b996955f58e653874a866199e6fef28c5f7498777e94ca909b8561bdec3a0335a218df6fefe34e1826f6576c72044ee5c65af810b049fd6b8703d8668c7b4bad3227ce0029b06be0b3be2831d7f9e958cb5de56720651d1ce42912a9c09c64f4d7780eceff38fa675202fc1302a09adefc5ae6106cd1a9fc903c15c9bc22f12ce6901a2af761095b0406d8b299b3277db40c9f9ae526e36f9c009bf0751352b03a35009275b9f21305af222d0136d8b2673b73f33ff82d6ce82250b11c58b4ec7bc38ec1a0d51ea1b0e29a6383b905913cd92feb92e8287e52bb17a0b062a1dbea7f6c39ff9887d15b9171bbfe25d8f2baacea74314a264782caebce02334a656f8dd5f61c15dfab346dd8ea4872f623bce0e04dd7b4aeddae6984bad0616f4aa31a5027ad1c521c81e2591825d577dbd2f044200792c6bdb7645f57f93ac937990ba851e6eb6165a4aedcf0f319ac90fe4a3db18c4a7e98560f00636e484adf122fa7d2e8a1e045889d9d91550e285fdb74b61e109a4cc6d6d637314eaf9694d758cdf2b746b2313c0a0103bfc32e443d926b8dbd64b6ce90bdb82f2fdcb82a8e22720703c6e9ea3b6c183564610d68a0e2d73d9da3d3fb35305eb53f5cb2a274387458aa145fccc00a14ed71205f4648a9548b8106d82ac73a709c00fefee7f391dc9aab5c097902cffcb7261eed0981c0f8f0e3b2995ce1ecfe0c68f221fe9a874994e61739d6c24aeb1a796a709077cecdd71df3729d6dbe24678f458f9886c5c34b897f1cdb5c5b52c568351bcfbb7c7ea4e06ee05f8ea614f05de6dccdd670e2bd11da02453fc5b964e2c02a2f91f60c50f0155d6e4dbc2307db7a60b14c49e6b8c647bc1d3934a81de5a8296004ffc2c07abe0b2774df33ad271f4de9c85ba827d4d579db20421bf56d88b568e68101e9fa9bbd9c535427eab107efdc44d679da545dd33483ed53cd05abb0b2e07e995d1ac62b755774f138de7b88a971361f07ce88e8a68477a9d282c702261728ae63f01873e5e8b8e82cc28baf0368e10205eafcb7976fbe8c2d17b4c3eb0db0174733cf0ef14f3428e567f5ef71b7236466f526f5fc4407fe0581ce2caad93ad089afe86c793cf6e39a021becc8da6edf69a65af1c4004f27d545be0af47736910b3e53ed4b1b0980c718ebdef2582a7b613779a9d81c9b8dca971875dd4c99fcdfa591d3069838c2b5d15eaa98cf0e4d068c0d9bba6581139fc8b58f5da2037c87ded054512c4b2914e3a340c41e1f4112de4606582d5b4d16dafc492e4a3fc83dc3ee02a86dde41830bf049de90e15bf1e056a7fad23102242930896be29ca60d930e06498bc6495dcd5e6f129f9ca3097e660699bea86816b80b027c03b7ace7f5c70bec188d22c1e6b8539ab7a0480e70a05d6efc7214f5cc0802da262bc3921f31576b9d0c868bc02206221cf85209dfb230efe2568f319fb83e8a70c0e34d14eb66897a15a09c165985634dd25d3fd79afed767cd822e9206cacf68b3232d4f2b1bb84525b3f147a6f1837e3710bd7c34c90a061d1c89cd0364d0066838227d7690b7fab86655a2f81e293f872f461c9437e167df8800b353aecf0befa0911919194b8414c9c4c8986b720e5b9fb59cf9890b5b00710e8df0779c0cf6847e2f48d8f9338a13fa5ff008888e364dcd54b2286b1d4d496563855ebf51764ec7b01819e745016287f4666365f3480fb981982afc86a1c8bc10b0841fcc435d7d5556f80c3a13749799fe20cf220c9c3afa35104ba2b0da0bd87300d289e1439e6c4f1da7aa9460d11dbad92cb4633f0c5f9ddd52a8798f1359abcbb4be7f40070d751f2429a3b47b885600e4aee2185cddc3e2fbd4a91bd800a4153b823518b6415e99f135a5eceaca4a1b5b5d4182f92018e3f212db30232110aeb83c2d88c02a28f5c7cb2a8614d14a005ba3636feff339a37dbef1933dfafb7786c3bb3ec9dc99cff133157eda75a5d0601946ce7ee709cb56926bce8c94794ab09e3398b97d6c6a35e6f5f9ec0247c4c4f2a9ad7e8ee083bdc3523a094025c96ac01f0cccd2e608f12836018fc18c73e9478d44e24684d3163a6befe3ba4eca80d3e35bff131b66bbd78afdbe2327baf92c8a9176bfa9032b6eb1d5dba091f9fd8e48cfc3c31272dbb238810704589d0a2c1466d0f7763942311ec40fda5fe021a4667a54b248f7c7059f8fe71eaac1618ffcf8f35a5dbb03cdbabd36522438757bf84828c38116b15aaa051fcd4b1a9dde0b70949aad8f7ee0754412c5ea7091091979a6babcab0309ed23d3c42da5da80dbcc60463dfb2d734b978537483287b32699d723b9f56dbf79f8255bc2f850d428db7c3b997b4c36bdb90b422abb750f3e756344bfbc2d65053436d27a17d1aa6f4a4cfd4c00bd1ddbd2cc433e7b27054839657a74a6ece78ba773683a6af8fec19b1809378a8cda39dc506109d16f41e4dea30b3e86213c5664e571733aeb887fd6cbd45932a73486c61a944d92f35ad618f3a886e6aa3735badf6c17996854263daca0d5cd399716e7160d0986153f8f8be90d3c14e7e09897c2ef1a6e94fa437555c7d8dc38b8f17b29057263dabc358a39436246995167946d6224aea30d85fba5d72a25902132c88b61da70a777961e4e6a45a7560d6fa04d036748a1167ee042c5e9bac5e1066ae5a0b497ce412ead80b0572c70c807de1537b324b142115aef0f8d18da3791c730ed9ed2b65ae0e5fb55d87e6c31d0a179d90c3adf2c35f26b7c91558adcac5e148af692fbcff6564555236973b6d840131a5539fcc0624ca36411641a5d7e9d2a4d39e6a693f142ed473063713211a70d46e81a3a96a3d4715ca3255fb74c947cdba66e46242d4c94a45cf5998dc573886f53a110c88a72ad6db36e2823218eda4688939a9c019c34a3c9795cced251ff3d4276897d307d561800a49a80222a7eb28bc0409495434977e240aafb5d37285bcb9bc976f0301dfd6c9bfb9f7cbeb1db449353e37ef16d28c9c4919bf03cb24d469486ad7ded3f83564365df81dbff991fb12cabee86ed2fd85518945a34f735aca0a0f0aa28de216829eb7700e29c67cab35e823c4129b132598336be96567b7c76c3168a433cca6feb244c25e2f41bb288b6aff7d792f6e69976815495e1ffe24b7178772bf8302f1303c8483b9671b1dea749c568186c69713d9f7c697f5cde544f238c7bf74af931990f3398f5dd6a3c8883aa2628d3b5ce63d9b6c6a0c76216ed386c887b0abf815dc558ee9f962a49a3264ef2c799f4d0f960efe5345d77a59a5648e06924440e822122a0adf8a178c401825ad626ea6433c14df31679f39c4b9e4917e0a94c7d2771c3fc55aa6f1cbf3ca97c313dcf2391dad00c9a9bedf834cc8bc242eb7449ad48dc24a48debb704abb874d645fae94eedda35d0212ef50294280efbe6d538c017d18ff2d95587223d79710c4d3fc843bd24eeb3e7e282598110b09581920e78d075d6b5ded6c3befed49cd928a4f48e8940a30fcbfaadec0efecf0368d74d9d80f24fbba2c54038db33c504b0c334b9a4eaf7f60f3f0fa3e75e9c6c3fdc111869642727acb42870bf19a019fdcf8fa025c31da272d6c287639cb5b74142fd77ef3cddfa3bac4b31a8f5202981af4a3df30430e043660a6a20c84cdfc92fd4bea477f440c54055fbb811b3568d4d930db74d7022eea39c65ba611ce86ded50a34f14f3af98a7b390dc64a4b24ba3e4f3de97d1bcdaf15edf38e148b3cbc393774b3dfc8687f4a3c92d017583d6aa09ffe4480ae36a53bacd54b2bdaa636befcd4e7c74010ec1f97186fa675d67a721117f6d1959a9a8a02132f235bde4a381f87b7d65897d9473935dbc47f619771c97fe269845c700f0ac23a9a114380fffd348a045c434a96d4e77a1da45fb292f3c532a2c9b1c1209508633b0be25e023e09b3c0d37e214873060bcd8403bce797e13ddbe1dd6eb6dcec93539562dfcd1fb6258be506e216f466414adb412aa2fb28a0deacb44f0cf616983f04ef4a9d1d1ccecae9cb12e85bf40532d0ff5f4e7919ad906052e4532e10a335c1c193a24b0a862ddba1bc67ce46a381c69abd445ea7e901020726ed0850c3e1899653af4a7ae39c534ceb22672f471197c7225ab74bc2a2d9854b345e85b85706ebfb592e71ea566ac79e1fcf9d6f9f4055da2abb18fd12f0ee4ba237fe6e854e39ac95b4cf78812aa24a273549a2388ba7f51c7ef8fcf61a7a1c6b173fc2e2b41a4211b99d203e62f920aec16e10dfda05bb0c9512280960784d2a0ef071beb56279b2276237d16bf7b411a6511e6e09c8d9eb597545d300d55db23c0f623940948c966438050136cf3ebd547455e5c58c6ae798ac98b33baffe7823502079ea09360d369f4a84c5d8c90dc365aa0774585d002f5c0a32e8fe4c249b907889d4d1e8fedebb0558fd7ab371c7e5df1ec8c2650865ce9fab647e9b2748bd1cfb3b682f9024f1efb9e1180cbc664b914f5fe842358ae046b0ff1debae0d528b107041aea17281429d9e2662dd52ad268e78cf1b5760a5e1a94a201b5f9272b3b94b1942495b982aaa8a019c53286794a0c27fe26d556af8dad5093a900a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
