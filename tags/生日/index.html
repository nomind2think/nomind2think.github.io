<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fdd87c0a2b6551ba1e857d4ddd4eb925135af691647994182bbe6e3661602ba4962833c6359da1f7c5ac007fcad5ddd0ada1029e2a84b1b5a5d615d66f03bf2bda36f2978e54cb5253e3cb1d814b5d8c3b3df3382547a2aecdd882ca23328d1502da65f9230fda0efe5fe9fdf0e79cdd14bd9846f06e37d2f75b95d2d06ec0da2c9dc76e539de05d2f2adace4a478b45f5bffba7612c5d4304986e2d298a710986e99b22eb2926cdd942f33945fe21b109fceb43ab6d034279c8564a57d42c2f0f46f6a99ef55887653809c70ef9054a7c34301053bc1cda11d835191757f441c0a019fdb6768f9ef75825deffa0f695fa3dd2d4d0a11c107014233353c82ce2e2652abdd18c3732772a81ccb8ad869cd17b93ae82d31688497239971892fbc9d6b449a8bc763821e55ee34f53ebec8db0c555e4e387496978e5813d779e9e869030bcf0d323963532cf7c3d1c16c0bd2984695adbb8b0e4097a53f0d37c82f041d19de581691eb3615f9c7177607c6f201a405ad66806ff32942b941ff167c51c5566356cb3938a3a97c4aeef0fcfe6fcb8125e857a68552d6876d72627c6b17e53e46a47c8ef217c19037097ae74e43ae65dfeae86a5540f95956d0754dc145134d4b8c84618bbb1aaddf2b2fa611f4f19f672b628c2ffc216e902f2fde49ac23492241a55dc8f6e4c59a6640a109c8964c0b03f1140fe1904a5a0ad13af5d23a2d6e01a11b636635af4cea18e711425760a712e05212ddeebe8dc8f2b95a7432adde8c53034071743ff10cb56546c2f5c9f992bf627ff2f9ae0a2b236430a33b0ca66022a86b875545ae70cdcfed51b4aa5515eab70ed5c98af75562b85950f62240ae741eaea543cbc90ecaae57bfa0d1a0ef62c39cdb87a061eab6a55bceea6b08535467771060c77d1ae87ecdbe4f23bbddcb6c818980ff374eec20af5789fb6fe5d3b936b6fcc9e62f73da47646a73c60111962c65c998267af6ad0f04d7e6fe4c0ffc09a522ff09e4a7f1cb33e7bff170d937b63a8b4b3472f2ea74657e42ce7c19e9223abab5fea6616acc28df2ee8bb53c258d088c42b0ced6fee22c9716197b5dbf2ca84f648939dafe60a7adee03510dbafd3160fa1f161b277a6bba5f82bb21aaf80e779e68ab9a43a328af79ea25a3f16169646af1a1052dba9f48813eebcce4f154232d60d88d07dd08ff62f3575048659437517500dc87a41a5e40c9737559e72938f6767784309da7686eedcd3b104e953537396da2116b61a5abf90a32d280951396a2f696325f9e2d8cbb18ab58a9671e7d25fa1ae02c98082506281473190a9954a4f8bcffb40b12e8634d6f1d73f2c081afbb97479f717c6af0111f4c02d5dcedaec7d63f5e653fc86c9db5b7d4d3d8f30dca779767ac995924e055c01f9e8e95e61096e36e870c67dcfd8759f3a6a04dd6e28bcf6aca4debedf5b798e5c869fdfa1e681f19ec716d72462981de42ec4520eba3da4b4626e9704ac9cd3cb92716dba349d5a3178762cc98f0cca878efff42602539d469d0309ecaf9133d403203186517596f82e48df531fa0ae9e6aec9e534da002017ff0d69ed80c6dfa05a68c38dc2e31412dfbb7a2079885bdc9dbe5fb3464977971f400c4a4307478f4a02bb9772fa684ba84295e099a56ff9d1901ccbba1fabedd12256e57764d3fcbe8b4eb37ee481ef2e7e2feb6740ec791a691e9a3b8f33ef6e228126407387630562167b2680dff9f25b4f567ff9c153595c70607d81350498f10b56e0e45517f80aa3f4f7553f073754c8c8d1b2eb7e5cb1b3d6b06ed6bcea787097516922239f1e5ce8bcfe0fb2eb36e640d352c829f4a4d027f2c108e854064d096bdb2aeff49bd897f25b9676cf58f0fc6da4b2cbb5f0c56e7f8691c144c3a562c3fc52cb341812105a0960300104ab78d2820b17a06bac64aa5f10a91289ef930fae7e6604f06ddcf929c68ae28082075dfb6948cb0b6feae9978bb2aa9c5f862a2fa3f3335c9f54908ec5e0a0df39c15eb99b28ff365a7cac1a2d21abec57ccd1cb00473d6ee627b7ce5bdbdd12b287e0cf08fc8662cb6f68a405114c5d6843a48a9b7554cc43281082940bfabff6feb8069987addad551ca9d974bd5425651e525bb525dfca130d3f4f63fcff8832a7bdc20dda7097e605ae0bc9a915068411d724829dbb49a37400acd8070f401e510891ee67384178d11def21bc2f7c31933dc5d5b973eca1e36414838b77e2b38030b3ecd1c3cf25ab853502c59e8af8388a37136df0aa52fabb02dc1247a0db73f3ff0b7f57f76995d2ecf55c82ad03883e79a45104dbabe7f9ce50d629ee543b93a3c8a652258967fa89925d7755a195270a241d8f9133cae53f92ba39742829cb5f25c2aa72d627f008e34c77da25a6053908e22e3d745406d2c7028dc2e27b9a748e12bcc7ee35bdb46e77631fb6cde8333a494e565439613e524927dbf7c36ab11f174ec23beb0311d02846c8676e3393ed7c2d07782949fec1859b363606569cb619f4de931728de2ae813aa3d8a5b7cf0633bc389145dfce2ef53b9250f2143078337213682834ba5f87e694e5d57cecf6dc5d723905b68b78ed04fa0a44bc3e8b05fedb988b32c463e4a183f54a2bbbd815621d4876428ffae6435788ff0a2eec6d556d85c0372b88f7f477f5805a90bbadca5a68070526ca6c7c5fe05c188021715ebbcf86bd3363a3787cbd4a20551debcd13bfbcdf2ffcf14fc885fd1217f8f668f43fc3505945217d7ca96482768755b39964163d2d76fc2401890b8a082d32a1d6f50cb08d2a65f98da055d68c70896ea9e60f10db2532d9954ef2d3e5aef955bcfc1509694f6d97ff28fe058992666320dac5260d4be98548c61b14f1f14f18d6a8853dd3c7231265e99f9e82ff3b776054afa22cf8e151eeead1664b231b7453e5e19ee1e807160f9dd48feded1d47bcf001dc38cb3dec4157fe8c8107cb4f375525457c9296ca6f3d6296b044fb319c35fbac1f476f0f1a157478f31bb2eab2f7fb5d86d73868534c04e277dfb955884cd469a6ee162becb1a5d38b46a89f3fc1a6c00257eb29e7749232ff5698ad852f6d75de18358ac5024882232b1df117419829cdce225b4e3f1779ba87e256c500de468a6efea29838dc1dc8e9a98952fc95eddd30d6bee33997b37505b8e18a7ac35f87972ead29b741268431c68082d0ea4a239341f38d2530c7c8afd4a42d7442435c3bf589e8153ee450741098c043551bbcc689711c5631d6cd8a90e807719d732f167c3462c71bc75012a05ced17343d13eadbfbaeb99a7c04cb65522e4f033895b775c877a14b88cecab7f21bdcd2ca891e0c012584960f503e4af262b4f3837ae969bdce7bd08d2aff948e3bcb6ba4d30981d328304e642f662a81567253a8019383bf47aae97fe0943f4fa1d2d6d9b68681e3d1f5cbc1d9fde83630c2d2bdc7f76fcf11e0c385c654d979bf8d30f6ea9257bee2a5187fa750acd48b44feafc00a855fa2b294b5032af35d92581c1b7a4ba9a4d06e817e3ced73724076b5f02c5db7fed59cd1c5d15aea279629b0fd68c7586cd1050a8d6adbe44a17624a8bcacf234f35f7d21ad65a924e69ffc8496595219e8e9322b610e59f6352471786787edf20055979c365ee685667d056a0a9952187f4f2f072447e31bcf82bc43c1b02979efafa2922cb595dbf3629854838e4237c6ea1e78eff290da63ed11d9dbaaf123d029ef94971e2c80590a66d358a880b1ab6aca1ed820a9041fd2b766da8605f965cf5a854ee533760c88692f02e0dd26df753226b1d81d2d42f5532ae94f492b5fe4ee8a4e5c868edb02d70ac44b9cf47dc2a0e3f9cb025ba3a906a793b739c21c977dd44516adddb0f3589834a668b6643037890572cfebc6dbb5e6e68dd1129736de59d8ebed8e3b86781c4fab61ed47144e03dcc67e61be5f52be6f3aed036d5c8684f1d6d482d13e06da22cb24b1638ae91da8d96300bbf1e1fbc2e4e61ef95b775c7a0b9ac3ce901cb3064b69ba21127a019e28729f0bceebeb00bdaa6b01476fa65e181c2eebf8a18fc02547fac568f62048ebe3aa3e967b17e6b3716916835d919bd5f64a53a95b8302ed802ef586f75261f67d2579222dd45e9c72d61621f54ace769d067c8b895d7df4c5802f684fde581a74ee5ea56c16fa0161f5212458e075eb95ed53287f90500310c92ed16f7a7628953a2a30e04a9c8437ef7359a68100040e6665fb26b8f7982b7b6e2272d48ae261f3c6fb3701934f8c09346f5a97bb69284dff40f6f11bce7c9c54fcc51372e5261bbccfc1715fdb26332a5b94531a4a242e0c7efe670083f2f6b8218b684c4e3aa45e543e29bab72ccde2a5d2b4a25b6e94f2908fff126a56bed19a6e9db629884acf0bdf4d859766a5270a62f1d3ac297717b36daf8eb45f5e81e501a9c16e098f9e5107b621b14d8057408f10c6be32459e37494a7e1601d6e17540b0db1559644ab89cd40c118ca0cb772bcaf73058120f328de6f3fa26b5537d39d44e8cdf6444e0f2bcd8d59635d62081c0667ce7c097cd45ed7ef68e6baf6083781098f1f7cf0a3eba9176b23bddea7866f2f608092b585266f093e1bbe037e5639c67b05d7d2eabc1e685a899b34ae6bdcb09e12e4c6e99f17e0848a6cb80b001cae92fd61b6e198e7a311a18799683a61a5e627f2641562221fa345b1af58cf92b98bff72c85e90c77224d40f55f5bd186c289ae205984d75e978ea49c4b7e84f07114eb75f98660e5285b76347ddbd7277eec152f779738b97e43ef4ef5f9403afb1f3596b291bca8570e0b198261934b6716ff9fca8836402da86ef25ffebb001c3eea1bcd317399190654b3a275da7f1489ab7dccde5417b291a236d8d46c7f20210bfd5006d8ab1cef47e14894a3c03a012a4a9e393ca5c203a4db6942627ddae179605181a31024a60f80a2f297323826629dae65c828fd2db7a5472a14e1f8bab15b2361cb76610af5ba41f993d7c304f620daa7b859a679580023f0d7b1cfdf4a03db8b3ab50a7f1c9e29008d2b70113a8222afb8ec639c6cc53c8aba44f27b371935db54643c6c134d1ce9d9ce7171c9e6f969f195592ae67f0c8923700ba58b7c6645714cbe2b71a32b5ab56b33d953c392c8fb6be531ed3c97d6cf363c8dfaab8eab53abfed75f57c2277a5835ad9fb6e4b13096efc197246187cdb8b9adaf1e703b4f477eb7d22b15683e110cb1df86e045f2fc91f0a1ca491d8be9235635958e49bba2d4e8095b4d3f9fd6d83c0eeb615bddf382d1c0dc9653a9b08dc0343da94eb4dcec70043904cf70a486eab685de31cbbc5fb70e3b81709e65bd3ff35b368160dc4b05c09d226359c1fab79e16278a3fb5fa902fe669f0da4e66834859f62377cd7224a3a22b912de6319f3773e5ca63e4ba54be87cdce081abb59631b9cbcff40a982af7c322862b9fe6dff220c1e60bf689204d33e3782b6e3aa1db830ae713f704f407746bedcba312db93d5ff5ef216e54bf847c53e905fc072b33a10cbfb75982a0f8d35b19256341e80e87982b926e2e34ea37f9b4acb4259370fd07bfa10724d8eca4c381d9a42c209876eeba6279cb7cf7e8ab3f80e798a0ff897e44db4d082124af460231ca8b046e4b737b5934515dd171f48fde4b1cd1a5978991cb770f0764e1d36cb71c8e789cf2e5cdc052cc7b7fdeee17655b8c7dc8f5ba5d6d96c95d9e34bf1fc6f247c453a15de7b76562bdcd6f4dde8e50672660a61e82a07837d5f81a298de8b24f39358337a05ed676893b4673b69becf02ef27c622ca2459116359aafb1c1e6ad49195bbf5d2f3913699b94b5adf6193fac30d76f218a04051b7555e045d240d9a8698d6c92ac9b05dc7a209312201d85abd24fc5328920f75e4160968c4a9005fac1e603495a304bea393e5fa33423aae68a9b2f03d0fbb8a3ef96a3fdb15976b9b3f537c90ca12a3af616a2f81b23afc027b7d4d6cff10810ece0625d03ddf72dca79d5aeaa4f1fd0ee7e0225ae3403bf0ed4e10a3aaabc67cf94b99174cde1a3b070bd0057067121bb9688de5cb45e75a96fddc738d5402d9c056cc5e408076a8bb73590b884f15d7f7dd4bcddbc77f0a90c120918485939534fdc7d287a042dd842a32fbbc9f6cde5c9dd022b269d3b258ebd6e6fd582233f1f88fa398c1b358b852c806d7dfc7033ed41f0b0a11b3612d77abe534a7bd76acbd93c371c6f86599a6bf8394700c26a904aeb89678fdb6d70945ea8f0d64c09178812b37d9414b8e62b45cdb3f532169d8112d367042ec1eeabe1f71a89e6a5e54d91eeb661251a2e68c1d826e30267ac0411d2c38061a92386c1cf9bb32bcc0b611a1169b79081e38c1be91eacdb6fa00b14a53277450003440332525a8edc9cddbf346afeca9f194b98fdee7d38f7761c345b85c20ac517e81196732d69c0240064ce46dfd738d5d209ccb196ff1308c7bf4d27e294f6873a6f711c870303a90d340febd4699b6b418387527455a5d2a4f7f1b4ec3f50b43640142953fd97f7fead1843a625743da8e4ac46fb53c9347b2bd15f8a938cbe37c893b5afa278ce1740b30fd3114c21d41a77fe3b35e1ec896753fb762803432b4341b93447f3e1dc7e9f43e61a333223442251bc3c2eb13c1dff16232b57c2f47a743b9e334c59255aa925ae7ba3b8d899493b2608053d8b2592bdec38a8f31b8df3ace34c88c5bfd4b4117b676093b4b09b9c27960354b02343b2a243089b48f7d191835434e69fca1cf7083db6fdcafa7cfec652562f6e147ccbfb474e02d6e6b1419ac45805087365f30fdc0e61cf67ede5f28c647adb20fdba436bab49f6bd378b756ad299f04ef7217aa7a10631d2585dc7fd82a1a7d28b3a919e86a783d5f9083ded76b120085698c2d36b373fbef1a13f97a9156bcfcac4e6ae90bf98fc87866191923db737bd6d33ba318b6d4b6521c659a6bd85e28f3b93124dc99ee0a7a147deca32e85e2149ae3a05a2161fd377d9573b7263b7604d3a8b2ef8da9fea0d29157d2cbad76a82fa1de7836f06c68220187f46e08b4a18454df4751d9639ab0761cd26eeaadf0736415fd1c9496f4cc92feb2fcad104ff611b15a9ec739d596df9e77b1e9397d1aea22ba8cb6616d1dbac7d4a09be86b845920a9599cc32fa3cacd6f5db51bbb4866b497d0737f2a901e58669dcd557e39f3423eb5051c0feded062bd884d3c698d7a5f10f3720c8c16725885481549956a471417f8d75c6033508d4cef369bdffc036e2cc3d6575e03cf7ec2fd71a03365ad4ca42b422a9964226fb2781554a81a6ec3a0335931428cdaea6d3b0b70b187e34a147bfec431acfe2ef3005d316aa61d84a7303921d7d030988b0266dc4d8662adf5f9fc601d58c6cf4a7c01ec8ea29eb1ac6f2280bbe893f97f0cce4441ec9269e86a5df2d0a68ca4c2aa35a03f3e950762e9ac9e4d7524b29f4245128a428b27abe09912df6e9b567beba050db7333d74590d69a52a2853a16421826701d621e104c4f4c53cff0c093736363884e2476f0fae655e8ef8be95f83f46c30a53a0e4b13a82754092267d714b17648bce9e205a3a4f6ef101921551b819f1b36d330b2ec292efcb27ef0a768a28bb0748fec3a559fbb7bd6fbfa8792704300d260b92741a757f378ee6cd8ff63783a4cb628c6901993cb139055b15208578bcd4109ea32693d86d348e971247252ca4431ef8e746898b8ddea3781e54a109a36428c054844060e1cf3014057f98ca0e286f364807ca312257293163379e9e395b176e82e9d995fe8dbcac9919146d471ac7a8f34d255b532e49523c72fe3594c87b99b12aa8dee95757057ace0aab6fdfb6f986145b55ef406b595c2ad201add3b2a57d135aeb00c4546dc62a57c0b04b3ae04cb66fe96bd65ce2550508391aaa3232cc9f3edf1ef777d0795dc93f0e2e4a2882a2f84bd2cabb1a1bb427e4013c87073ebbabc4d03cc19758ddfc9ca1cc1b4a713e176d4ea8f51abc8b9599aa80a39e4fbe9e27629e42a0ebf3fab262e748b93d4ab330b2e295fe270d2feff92cee45fbf5a0c404e5b7b581c5bcdb50f8eaa66768dbf4e12e16194a17f7284f068e7d70da7f4e1b59070b8ce2ec10da66bd16909f0404f81fbdded3a6ec90204e16e098105a10ba99204875dec0234b159ed1c16c2813362713d44691781403ded9b80a793b5f5a6e8a75007f231f30db01cf12140d9f00151ed0c28fdfed004c5335df2008c9fbe06d82534f802c8a2b22c98f6557425867c4922812dca918a6f67c8e96066c6508653de8ea32cacd638bd4fdeed0c427f66cac472e1bbed109f898a560cfc0bb9494d035b52eecca1def34d8152c0cc22b91ea4af611f50aab7d0d23f9e1edcba1032ce0abfb855a120a5f41e0c9ab58adf395715d43f3640da7b4feaf8752b311ab63842e770542f4e57897cd4dc774e0e571dd26be8895b9b95a72bb154d0334d263f8cfc835adc8e4e064eadafe2d4174820aaceeea5f08ad5ac07b1f6383800596bb0dd5c90c5826a8f379d55c0432e50822a6cc76f4f0afdceee29b51b85c90fcd52cb65aa392e73b4d8f877c0b984740310c658ac3001d45b6c997f8637bfaffa3b6215e476d678997364455e35aa2fbba22bd9099b2cd5d3edf4b5cdd6a3ffa9e7d114c6513d5d76fd4c298102dd947b918f276160f7d00be75836983dd105e578b588ea3b0da9f6ea1c08c6b44797b565620ccf53db411e52475c666a3e855162e477b078c564b0d774fcf9c1d5a0b8baf1a21396ba2b55196f56ba5943eb26012e51325407f1e78e3ed0dd07ca4681407405d2f4aff35f542aa4e9daea7e9cd50f259d7d496c43a4e625539d9cb621b9dfb42dd465440a42effe52cd65c2a8e26788769b531393e1c5dcb204e1677c174bf7da25f7b2d8c48ca5cd5572e556c368bca036488c65c99d984e2101b5aa56fc9601c5c1cae88640aa55e95412188f39c8aab204a1d6682a7eda5174931e12740e3d93371e59c5cc9c91c2812fbb0c1f1b48e7928bb38b4cf61757aade342ae4dc27408f4885aba1249e09b46ed14dbe8c8f1190247024fc7405b0e7da20247bf3adf2e97ada636d40a9b21841e6edcdbb469f7976af40e96200dfcf9c3029796d221b4faae52b1fa2fbd8aec7f0ed85041d31927e9e3ceee3b0df683e9bc4ffd1d624815995fc2e24b25330152b13e21dd36207df7e0d763bec409b10bbf1259a037e1b102b3aa71ca230461cd4139dc2880d9eb7d9c69f5d4e9b222fbff34469692430c9bbd5a4e2c41c5897975dc13361a18d164736d102179489d317eba489fa82b4829418b8488aa00254f93722a10cd40a8e41d0678824aedc3769f5b476a95dc5c003e85e2d249895b3c59c519cc1335a1d11262f7eb04ca15446d235ee07ea623f9b369bcf72c65138cd7ee27df5f2ae863e2bf7927e9ad5f58596622d5db4febd8c289bfebcd2cf5fc198acbb3c80d135242ed34492026b075a62d25d80b5845a76faf391995e4d1cab9813b621cf16cdb5bc3fbfda251fad83e249e9c55e09707ac3a322c749d88eb683fb06735754438480a45e9cd6cb6f330d0d492bc8dd79135880eef0f8370673c7e219ac6425c4494771b385a77285adb8a2b3f275923591b83823b85149630b757fbffa549f4b8d45eac3961654cd35216c72b49a3e5f10fdef34cf5ec898655f0328b637b5bfa58ac6a4fa172c990a00a441848149a0c47cc3575166b0ada6fa88d597501de6048eaf9b7508d23653e6f7ed142b933837395d802fe80afbdf5566e304255823227be19eae7c8f47a3bac5e9b1b974882732a9b060b35641786367e2a08562b8038da00b7029af94097b6371fecb6710bf9823c6c1b22da932deea2246eefe5e347a42867c8d1744f1e63a510afef70863e7e15afd794ccedc47bf2ee69fa4c98cc5cc3d0da7fe3979b90bccf8a617232c5189372c2e5c95ed75613ab047d3965b4104716a7340034de5f6ba195963256a791e271c2252f508b528f15082abb70f8fd5c308aea94e8c86cb547533b159331b104bc87b23119961c28cb5787bf597b6676ec883bdeb9f12f515f219e6e3359d326db705cfffb48a765d2e36cb31a125b98f9e6a1a7fd9aa6d33f163493a1b868a54cb23ad8901cf5b01d1f913a5109f94a2624cafcf4d4d0c4d44acc1c8adefec99852ec5b23e7f6af339d405e09d7456d9ebdf8b80dd6768a6fbdfbf09cee1124f8b70e44084816e4c0af0c60687be11e5bdb66d60076e21d436338cf6654eb2fe82c2bab11b56cd5bf2f668a3c6b36471e85f1c66a3686dfa9d725bd66a67148d7cf2fab3d5ec80d12f717c5bf0aed16d8c576d6369d8215b4892b706b5b7afc4d0d1ab68354f98b29328c382b023aaeac4bccb8025ba9de91b5a3ddf888986de7352ee5c577fdb5bc3bc437cb5b8f81bde0c47ac8f5eceb4983f57075c0444e7a13aed95931862758ac53257ca81559c2bceb599906a0198d9aff5b6b665e5b49872c8ca255c8c4ff554134f8cf798a5407584a82be616b4d1e59a81053b1368290ed52179f133b3f147d8814f39468db8d65afaae38134f29037b9dc5b6ac7ea21e7a804d53592eca471324be40f9ce722b4212c7701acd1badcd8364350eb6fb026eb5e6ac743a38f01ea3ba8fcd664f3950060ba219f3a4199f553aa3d12efebda89d06499e23e89fb63f2849f389487bd606b4b415f86e5f1dd8fde00848b2f8dd4d8ff8de407f832fc22a82bcfe33ca1816ac522533ca5d246290a5f7c2804dd80e618163e7ed1b5980532ccb37360f123db1dd7612b8f479cf3b7deb8671dc6ae60b00fa7826f0488a1aa5ddf4004dfc89ac7d87ae9a1efca3c9c3b048b0f08fea3cda71066f39175dfdcfa41528d90b23655aa969170dbfea6f470fa09a97b9d314e5c2d7c978d368bbd8fbd34ea8cee720b84b7061de9764a545f644220cb21431c3601d0f1438f14c597a517f0e549a9611434a94a885f2e49436153fdc5a2d73dbe7a248f05179b72d1b178b9fcc27a177b8b99eaef248eaea2eed72718b5d1c6d0eb4a7762660e68f6ebf7107d5405aa3ce770f05d0a2081a63f45d7426ca58a6ca699d64d355bd1d6d5e6909d0ecc6f4ba21d7266a29e0e7c1312288046937335c561bcbb7ed1d984360bbc0c48997bf1d2d6ec990e4456a14552e2d6575cbd099939f626c900c2fc58d63c6da5e579ab1348c22ddb1559e0a6f4ca94d229f765864bf76ad8f0770f52185b9baba38e0e146e496d0a3d28365dba74d4662c5de1f25416c4ae29f768107a404bcdd6db417d046c13525a8db253c498bdc341ce4924192a3bc13297b654ebf4fa3c3f56bb75740bd7568d7e59b7877ab2240950e795c2aa0543fbb72497ea1b6cda50bba894738bbf201a513fcf836a8086fb72de0d418aca0326337024affadee5f689865fb30cb372f6188c170a7bdb41ec4a492d7114865273a8fabd23cd00574cd0aa0231adf30bcff5b7db100b169c1f1a8159c23cf6991a497d6cf977b08f8c4e0b4f0bbc5344806e283479aaeb2e4beeb93128cbe661ecf6805155797ec8dd371b476614f015d975c3f2b46de85c2dd20f103239f36bcf3fae97a4c1e4dc2b0d71934487ec9af92c5565b6aa32ef76207777c8892c6be7f33d3bc9c838687109993affe4d1430637a03959cbef481f2a49625b46c697ccdcc36238182d32ecdeaa87d598ea4c139f618d934b182fb52762c2959a34f38d10a4aa8f261e69f95e97f8e29b1b6607b63d9180f146bf16fb5fa1d8d8cd53b445f8f6fe49a40aa532ef333f67c3d75e4826b8efde61f123c1f898c1c55a912417218c85a7b178115c8ed795bd4744aaf4685cb6578d1eed8fa3853ce379f7d8f00979dbb532af0fb8872d9931ebfa3e9d2edda24983e3d9619aea4d155edf596bd9014955a40b45e22018834425fe59dbd44456cc2518d12b071810fc90cd6abca8376f6d3f70521319e16dcd03adb311da0a4147abaae0d650a1a0d06c3b567415f16b04cfaf2ba67cfe23663666c97ed4bad82ae4290ef8b75e4a5ed144a424d9dd254884f962c864c931e2ca14fc8326198de69ebac97b2f672ccf3afd2031874662dcde320af176bdf4836a88e45b13f0ef26b92d369bb0838859d40d9b3e16956b314f5d46a8df360bb8c0db86ae7f0a0b456f39a73e7474b937e49eb8a2c7c9bc977f142cae9d2fd11ebea0adbdc624b2b87aa4b06e0e9a2f0b016ca3445a942e773babdbbdb3aad8cb39d121f55ee85dffeeb584ba35abcdeb0b1811cfc35545c246efe69ad5fb394d9727a7ae110fa53bccfe37c9028ea9ff19ceb4ab401da068d5e7e470d707726cf62fbad7a4b51a6d4d82041f67d805adfd9f33d2a6769cfc0f1ade2d05cb482994f8e6b2773409bf0a3ddf9342a7927029a24f92277b260f4fe2753755754deeb2288d6de04bab4253822304e1ffb00424a0f81b547af44e8ca7e5734ebcbd93ec878f038629b58a3273753c98171a5f36c44e99efd3626f71e59b03612e10668a2c33b4c29bb8b25f92fd552971c32d053042d0238301648225fcd2aaa20fadf58f1ed0cd36e040f77f5a147c2959edadd4f18ed410bfde015887c489642049498f0013a667bdc43039dbbb03040576ff9fa6e2b89cdf8f18827b1e80c68ea1d95d59c7d50286a5989d54603ece13abcdbdd9082d5eb992e570ad962f1efafd316b1a2026baa44f00cb56de0e63c3c4ff106a54b1e91092fd61a88f8ce5f3de03c8c84e395ce239ef67fd14dae9e7931720ce468045a50b16540a93b3b13df673f44601e25161fed496bd12ad269c064396896b40762df7b4696b3a837c69b7c7c5fd06022e97a8687b732c585f72293a13213c59496c51ef244c5b27996c9aa094d16fcbb0c87a40b99347fc6e8c86c79dbefcc255f5dfffd7455905f6ecd82123c0fc8f1b54745e1fa51036f6b2b13100de9b2d4fd13113ad2ebda3c7e3ac26642e45a2c787748a45ee3ebcc73602b6ab739bc6fe864b506d437ca542c61f0989cb68689d878aff8b0524ad1468273b36721eb5b24bb348ebd534bd1f46a443e997f96e6a4a6729d3e832de4e12fdc5d5bb06edad72b65cfabf7e1f85d70726305950d51453c2216a98cf547886b546bcc38a5fc35dc6542160b3f2fe6b61be92be8d3e3738cad89dc4861de8cd162d8396c1b7579819d34255c1dbc05257609b395c38735079c6245b51eb43c28c8451900bdf31b6e88804d92c6b7f5fa1f1842330901ab9ea3f9d9a794957639dade4b75dcd4fe6897c745eaaae4b4fdf858bf7d3d532686c3df8322e029e83687636bf9309be1979631bbe66fb07f43f028414fa09082475077b70c0a29f7c73e037206b95fa996d1f48173a40ebbc05383c5d492cdf3a283eb84f4cc71c21b76bbe2b78196841c5124014224be520e3d836666728e5761ca5b6f8ca5d55e717eec0f52cc885110b1e83fc31dd9ccb9682ac76d0d7979da8f0104561f5d5eb4ec3dc587264809abb308d8aed9f27aae8edbd50481f0f4384709bd24759af29b2a69c3e966edfc9b82741f4b4ff63561dbede8c6cc575af02165f37586c22d029fd8d1852092899e9368b1e0c089b0827713bbf864034989df1577b0cc436d111e98af789345ccc9cb67e9d4065d958223adda40a97dbd874b0d11b2c87d4ebb03f831110cda31f3ce5a303b8a2ea57ea5115646fd9f1d654ca5e9c575df4f813a653457365c06e51d2f6a113c672a942e705570944e90014c26717b476ba1fedbe0555baf66d9d9aa4ab795ef18ef142bad193f36f40f91353066fea7628d7142ace51aadde02de651cdded2a49ef91fd3a55f619a66858364f12cd6a5e61e246f09f6e0c3ae97d766ab62352e657a37147af2de4f57a432f7efdc2e27b2b514d9ad7789ffaee75c529f709bee3eeb2e3a7ed801afc6ab4633041689398b499f60905ee82f72a20054eddd27431647d86016aefe4e5779791ef62e72c9af579c622685f960c13994ffff7ad2c4f8ed16371134b6eb59c893b8657e33074a8169bd4d90dd98ddc9fb3f36e3cab052663d065c5bc6dd4e99d74704d7175cc3fc253bd30d776087f3ff2d49b639f3f801051be0436811a0fefbf6e373421d981db29f2b7228b2811d9ce59cc47ea968b73fc2ff7b8b307bebd348cba1a8947495ae96fd3edb01231aec19a5420f79c780fb586ddf32205a523999508387100c47f163182cd373591ba8703d28df3fe2c5042b82e55bbfa7739582d40dc0b37892d50e1137414b7a9fc03cfd2550124369f79f7f7264bdaa1aad16ab74e10eba16d9e37a21635117d6d77ec12bce33c61474fe011444d0eaa42adfa1ea0151567132be0f1ac38ba673ad400215b9a2fae434017d65fc772f76d171ec648e0570272d03a020d35d6376b727878c9f2e4a177e078080a6de10cfb48351dd51226af356418a9c6ac99b9ef0b08829349f0c79706247fd245690a62524405e38bc068ee321c64cb4c7e138b34b8c9c0faacdccab56ef35b8f75c3dabd79f8357653b11605948f91217948323cfd4cbe100a0913c71cf09543fbbec7b012c8700d42bcbb7ae002631e6c59a398aa13ce55a5392ed13d46cf13fbc4b0d17943f2007c3a9f8bcb8e3d2a16640a2115539b5f2dfa4493a37ce4f8295c1fb4cfd062803273b3ced5b674a536c980f44948589fb0a6ac4f41f1241022af8aed31037c9bbe37f02a0cf9e59a45e94dc71e626aca0f52887e4a69df4fd89f5e26ec6235f27257c5cb49f6beb0e85690203cced9453106b25b97735d6dfd558e237b0b4b979e865f0d3816d2a28b6b8619f2ee594de37bd0b2c46075ad03fe7d95c7a3acfd171980c0120625a27b0360e714d8581ece19f3e2ad2ac120609493493e5e47257b3ad2216db6c8a70ada91230bea04e55e3a50ab410c7f4b8a25ca3e76dabdfd80ae390690bc19513c53056bea9932fc5542415d96cde607047036c6438fb82c31ea6a7213e2ce90309d1001bb915a80b572d0c66611440d709b4e383d93fe23a9d7445457eac72ac173bd40d52dc54605e5913fc072e443073364841e97d6cb735fe6666fe983ab5bd93ade6640fe3f4a9d1d7e8a9b4158a0e55db36432babcda26465dad831514a499717a8a66ebe571625c7a09dcba9e2f511e8a2e671faced307e3573f45378f9cadd3ca60e6e6c862059a1477dd40d5950024d58ad1bd5951df7213bccf373ebc24d0a6f30529eb28306ede89305da4feb0f771299cfe2079b2a65de143f4e1ef73324b539c2fedb088fcd0bbda41d044297dde47d3ee53492bb76d18dcb13e678fac0e169b7dda4c242b1c04fec057aade33d9c5d4e1381dc2a86093f3914ebaaa","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
