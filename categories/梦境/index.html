<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3bd563a910f68b1b2f108900c7876e889756a2317b0b8f9721c0aadb74d4288caf5f1bcfc569b648f16fea7ec9b9cef0489c02b8895d2b935c30ab0092c263e690674dbc5f5f2571d1da8abebe9fd1c809e90f978f4cd7c333a41bd7280e90414766d6c4f0cf5142876605ff77f7dc26eef4d6ffeb6b0a36ed086ccdce7f5deb15f4cb5f43c340f7cd5f7d0ae5775862b00d5173d4510b150869b50cad6dd3d4aa00453d56c8e78f076418d057dbf94b30156cd925635f649474785511c23a2e2952822083c52ed62ce5c6a619462b2a660949fd29eb5dbe239aa9f0652ae507e460d413dee431b3d9164d4ef9ef5e4ddd75e9365d9b16bdca76f1547df665e749d9dfaeff1687e17fff66ef38974572e68b31ccea8b0f0172bcc6fb227b1ddc8183d1cdf08ecf03a5c6276d92b81dfe8ff2370ec4a6285c26f1e4dac75fe5a519ce27af577bc69344a4cb2d39b84f87be94281f9ce458fa6893fa976603c7b16425aa25410e5f0ca5f58cceed5b57c46c2ea42f2039e47a3ffc262f0cddd024cfc32d036407d3fb2b18ba55b6260adfb49e371d10855f54c314dab0066fe6740555a5aee58f67dad4396f1674915e4a979467ec81c9a0021b305792a38c4ba886bf48e41d0b7573cbaac17b79fd961641d357a161ae0aba2dfe828017eefa4e92e22f43879fdbe6d4a299a9da9deec2a58d91fc4caf1fb1bf658308ce507f9e98442d73f503a1ee110a3385ca90d1f0c6d9bbb77b01c928784ec1f8175f8a8bd94300dda7caebc82fceecdeef84a711cf34f68f799bf5154e64673f98a867fbc575b066e26636c7e8259b2c587ee077e0e397fc63ee0a7f6f130977b5c7807ce68210d312cb0f129ab5074502ae11563ad803371a917f3ffe601d2c1a7a89c9f3989a8376505e525f2f2a9aadac0e7aa845ebaf0f815da876e3e206d4ecaa7dd1ce9f54c9526d4260f0ded03294880d30c03e99409d92375d76bd5580f7befcab019bd8b7815b706a0e2af5d8ba2943344aa117b8634e7610170fad4564a7365b67ceaa6d4407b5d41ff8407074d1c9f6cf5c9806e4b059f4eebf8329ba53c0470b35358db97e3de2551a0f47ca64b0d7b9f61170e3285266146c04efb2cc98ba373b1f7431b2c6caf8f2f4a183cd7778e7bdead3e29657c14f42ac838e1ac0afa41d6c6ddd441675422dc05693638f3803ef04791fe21c458999c52bb2abb111fd41d59520ffaefdbb7f58a6dd258346bda379167a1e94d6f6c545f432826c0edd5c02d44c7f5d884b1f46a64f2847fd9d3c896e7f14fa1cc726e4aa11b8e4a5239ccb9e53d8c634652ce35b9e4ca036181d4b11e57d68c06798d73065ccd74640e0b9efe2abfd4f60b27056bc2fee8013a43f1a27a966a5af3f7be6da5192745a1fa89c8c35398f0089351c8e62a2124d37f95eb35ca3f766b2fd182315f63b3f1609bc650e09379a64e17ebbb4bb903e99cc17ef88e7487a44ab1eb0b6c1bd4e9800a5807bfdf34e6c15c233df458d4ad02ed40011f22cf3f87cfbf8704c7bd7054d25c06072b65fe9208ca62e6ecf6d89a8b5a48647a7735f1e30aaff4782fba493977325920e56320afda64160efd2ef4908a9ea7de8580d86382085e6dae154dd8d97c1fc540f5f9d5fa48c484fe9d6caf72da2f630fd6cc9b45edd2293a61c5d91a98ccc6424e49b1a7a3080c7b6bd4df791748490c2c8009fdf185d658d985aab11775d062876f489b7cc6a17d27d00a84a427a321a2a91150999dd833eae068195f9492f8ff336745764be3e9a5d60024772a97222f4d3b29f0e4718087d3582cb380be2aa0fc8623b0917f569a9dad522059ce11e4a7bb917abaa79352a0e9fe690ef5741340d2948f8203d3fe4446e5ac25705db117205556f73b75450440d7c0f736aa6d84415b70d1a16a908afffbd3c222c066f90519b7b7fca8200787630ae48e6775b9989572fb0ee5600dd8dfe2279bac8c719607450d6a286d51f1df5f5dc92c7b921002e0a790364e3a21d946f0a1bd3a5eb4047d295c919f016b7db680f5c3ef4fbfc4d3913c08deaf9a26e0828d49cb8fa9d1a8556cd9d3b77ad06f8b01889e83666d425ab30297d9ab005586d9a7d76bbabbbac1d0a31e3eda106618a4a89c7a5df6932422c5cbd6565a96589107a53e79d0751241050b7137da10259181f727ca4da0ed7598ed2ff059a147b473f9172d0d32d6974ce57b48f2e7ff6abd21a830e9d25a07a7722baab14e4c152ea376dfaebab01f2d3f221279d01ab4ef135b754ff0be186f35d2512b5b809aa2c9cbdba7c2d9e009a9cf84cc0ea2a6d9902a4ad58f03de49852ba48398ff9a0fcb73d316ab9a9184e4ab0e5bff1e7158194fdd79af844932c5496d51fb02f6a00532f20d57958f2f1b841d3e26057c74fa1ec1efe6537a2dbc75f01557b770d0fe940b550fcd044c37236eed69d6cfebbbee09f641c34dbc235be05ec2a25f0957095fa17f82f391f65eea38beedcf3d276e0126d248e81273af6d4a6d1efd0faa4e545de6d98acb6f2e1bc310577d73fbadd2b5d791d41c0825969ea721bf20ed7a7dc33a5ea4568608e31bbdc4d21ecd9f07f2083b529914ec1faa9f46698052707b24e974079e6ef594b4c3c5d6e7d67bd0f1dbafa051e6939ef5b739e181bc6790d4c5695a7efe26c76cfcefc4beb73431be2c1bdea2d73030bc685102cc1e843a99eb81d1d9695fedf8603761803ed80c150a67344947983cd6150a9275b13144faa71e6f40dc52c51713e9feaa5e806968cfa071cda10a1ac84d49237e46b34afe1628d7f2ba9ffdc57d3c9a8eba7dd3786cc26bdbbf6a794a5017a4305d23b414bd69e83cf49b2140c56a40c89ed693f993a81c840c1d0c7334d6d36f9de79c99f23d4d7d53d1f1f84ee545c7e4edef0cf1794040ae73bcde7fa2f74850894eba14cbb2589664f8b050ebf21cab7157e8a68acb9be92dff12e72b8bc8e82982a7eb60acd0dd9dad9b4b93b9f78f8d0a962306a1223cdea16d9b3e8a4e1cd90ff08491d63fb911931c8f6013bb986358b26cb7bea7689a3a59e775d438f9e29f06d8cce2eeeab4a602be36b10638cec3fa91c941d39f7e0c29799ab9e72841a7352df5aa9faff76d9a3af192aef10fe8a53d0a56032c8915633d6ac872a76e383d9381aad028e340119c6b021dcd8dd0ffd9c7292855a8f481465a84b6ccddeec2f463f2bd19c87febc0b5963663ccaba8bb145448b918679d3b894f3d2e0837867f2901a46d7befdc9cf519ca3dd853a647d5db01cd87a64ffeb089e4028517051d53de37965aef974404d90222c38ec5392098ac1239320cfffbd7e45bf5733106c086aa075aa12f658e2f9aff8cef5f5e1efc730fc83567399fa039e289287c9fdf165b88417b336674911aba2bfebd9ef1a332f0dfd19aadc841f4d6232531cd69c01d65d6b64af36c4ada6dd3e07356f76a9d760153694ff1f1179bc82a397986c232130449f6ee4444a0bab476e605afc2212c90b6b880a854b03492be9747c44692b0914342823ef5e392b1597d0da217535366935cc1706ff02098dacd0da86e5c5a427e0dea3630efaaf9588413bbb6f9c2b6018a4e8d1677cf21a03b39530a42b07065340c9387e30dd6eb457bd653c356a1459be05c18f1376598414ab8dcabc896977d7a816c711fb2d68a5c8e76eaad93ff04d90aaf23e7564437538ab59eff9b8a14c14265af351809b93375af3112ba15d1a1b4c7a3b18d9be456cd48ff70cb471a591b0b37087679a2a95eee781eb88d522990bba3d52335abff75a4dbc9580d55dc42ee88070eff253337bed2cdc2a7d28d0677b79bb003d970f11cb0af238b56fb3f812df8756e0deca979a0deda303e569f408060457471daba4505708064d1156d1223df7e92460339c39f473a1a3e68cb0ef9e01db22beeae6ae2a64c0c87f645c15687fea3e09af0fece61808b2caded3ce3d16407d250856c8f30aa5dfd2315a3fb9bbe7ffef9af15a345cd534dc467a291d23b707a75839b1fec3a83dd179fa118877cdea6d9f184f55159ebfc0a427de1135d2b933098dfa801aecc9fc4cc8a3443ce458612b5fa545424b0ca7caebcc837f64e90bf84a63d66ee770da33738874a0134e5805a6d3586686f04e0580936de0e79811d49ca492f48f6f325d3bf5654e0465fda6acdae3a7a79dd858fd1e2b8d4913ba73b745600c07ab9e7a34009dd37abdbb96394478dd2c613f413f44bc988fca5e6aefea5b78eeadcae276dd0725cfc6b5c132f0236550e114f43447ae815ed408e1b65dad226a4aafaacfbf286903ec135784428a6a783e57fc5a9e2aff81b0115d364afe5bb1000f4d554f986bcdb02bf999207f6b9a49ea4ba8769559f3be8a9ac2ce950d86c6eac805c92abf1114cd4c62a4c5bb5b451fd7b8f777b1f16f19a01c90b537c8aeee88983e774da4c162c92124d9d1979f2d8e116c47f26cfad54aac8295c8b436d362a14e34898fe1e7f038e98061657d9b12e63be9f074793e36174757c02eff856929b093c596c025e32c87b3101c41b2d2c5161df9fe5b9874544b100385c88159921658d5608b1b1b549721b27de991ea64877a322c00c6e51e67814170fed548933498df5a236bd4cd262946850df9f0f18c1e4de38f77fb6d1c2c4f06d40525677a76c0b8661c73a6837e2bfc8fecd685efc311192abb5eb795c664969020c025deb2d6f0ee123a36aba71b52d94a5a66a66c8769b90840c43adb33fe1b2c207fdd867cb495eff4c3dda01fa30bdf9407945d107ca6392ace9e69830f05c6913c047a9b9caaa991ed218730030315258727d4401dfd730f8a2abd8a2d8e81d585d18443b034a4f5e89f653dc39a75012d15504c21e134a9e7619fa5406a1bd6c40a01604bb327c3ae62935af3d7c52170a0cd5392355c3a3525d120c87398da691b758c5a8330ff681bdfc925e5f9522287a990997cd2108cf147198d124c4fabaea3eb4ef8039ddf2d8b1fa873ee76a453af813c15a3effbea50e0bb943415674231d988692a8e10f1981e4f080ace46d0b0444370cf76bc99afd74f3e21eace59477feed7daadd6cd23884c176c13939c8762d625e78057c6a823279f3a2a527eac23d82f5d00d20739fc1dfdeb4d34b22f6cdb3238c5444500fa2df95e1ce07bdf55e00cdb5afdd9bbb619f537733dc95cca6ff933e520b4596a198636e92091b7a52db40d7108cdd44ebd440267bb7131995ec20847d8f5837a9031bd585fd80cc1a5a5f536d16c47913ac332e2870dfbab29044dced0576b0dfc9478c064fd83d4885dad20e3e857d76fee31546d3b350a6ea8df9b1f0c0f9aad2e03d834292950c0067c5a57b1d82088f3125765fafbf12d545df289ef228738fb8faa8a21e7b8e8e6b02b214d7a4b0ef09fa8c26ee173bc2caa6bd551e5e83247a00030ac286affc345fc774ad0bb29b7ad37644a6a13a19f26cffc8b7db739c2b7119a44b28457819d2e6e747a6a767aceec6b4efe9b716cff64981916915e0f531c6dcbcb717277989e4a737ace8f3db0eab1c7b358ab83b7ee288ee08a27809704d91793f4822b8a67b6867c2ef51dfb51ce0e03e7085c8bb53011e8f9b2954ed760d192980b0b431c3d6ca436ac28376a3e5f5970ff8ee3b7091a244e3a817574a6fc8082e0d4ff7c653f1fefda76854604d81a462557cb44770df0d2bfb0fc7e9aedc00d283e17c9712336e98e7d99f20341f9a5ef32ecd42c3544742af822d6b5369ee3369376c23ce41ce2f206f747bb5306b8f3563fd833b12446e558841d51fa91d875fc155793b99cf353f3777ca6d0cd73e10787af918a5387d1c7b01f2177d8a79521b4a0c8b7185dba068647fbcd95bda526339d64b3369bf7e021e1fe5b1bc57365e1bbf4d987a45b191ac251144b3656b24f97cff84c8e596bceb7f733fa1cbea31668f83a28b9c5fa98fa5a818c839a1fe7ea249d453212037d7c35ce3cb1516fb0ba2596a44e184a9ab4934b972bcd227b2ed974ed8aafebe940bbcdd562119be5ac98ecb24dd130a1ed6fe73cbc485b5f517045ffe0f4a4da989be1ca2b82d29b01d644e9b298374cd9ec183b4c7b8a6d816a0d570f3abb784b3497f62fe3cc107a37195f58522e4d7dfe708e92c78b236601672a0e11a5799b56c7a03e753e8d4064f7a32cd37bd967dbe61aecb2a8313cf41b2004be22355520154d23fc4e250ed10fd3e53ef07774bf775a84a408356e6b65abc0fce02bca057a592aaf4bd99c770b418d067b33054d39025fe1f03e5f7b35781b31f7a73aaed5d1ac783a64025aeb563643c23bc5aa37a823cb17b34abab3824b9a4cce374a94b2557309abc864733d75d392a73256e8d216c233ca87d45064c4027917a7755143cc0561ae4c5e943aa83aa9b7cf7b97054940c218a4bbbe76107a2712301078f7a987b8ba1a58d9bf61f38531a1749eb08b85afb54be2998266672943f3a80946514f2c7ed3babc4e6919859f6b15a2f4c238d5b93c73ee5798dd4478bbf47b40c030de078abbd84f1b7a83ca07af627d1c84067ff09bc8f2e707783e4310f6e4218120847f3b34345b360ff9dcea49224ea13037fe56fd10d5e0a6bc5cf84a0b113411410a56b4cfbe09fa7a8381b6191d7476eb49470af7ef801dd1c5a32a2eb6d403c5a591aba2cc56f53001ab70f8b7b88afd725466ba45024f5014b0793fdb7a62768f53b7e3c026616b906ef35a3e9760203f870374cacf652261558ce29530cd1442c018ef9468a7996bc914a9d933b8f9ac5252a27a943f687583d51c19d6f46141bcdd4425e87f85b0470a84d7dcfb36c01f0aca5815ce6907c602ed967bbf5f3fd2bbf9670f2c278d7992716f77789675f87bf1d1fae87e8b41b72203ebe8db4396a2526cc8b6be7ae8beea7c29bc1191c51f4e86a4648868ac688257e16372fb4521db7818273fc85a09397926e01865518fdd570f2f12f5832d1a87b67ed73ad4045a32e36332b2df50f1b8a7183b74c145485224082c7c841c2de29387a3f47a1dd3a666196dc88f1b76f6d8cee04fea981569d38c3341139534f219b56fc57c4ad5b1429815fcdcc6358b0c4dc2b157e6f36d7267839005f5548a596808b4f3b6ea8b2a13ee53446efaa3dc5bdd2966dfe7fc2619b7e3b05f0a51578c20cbb99503ab9c2e8034921d9e3dde953421d0868f4a8ce71e4592fa963952174f28fae9861c5c27b8850c96ee9cbe8695dc0bc2ec0b5010e99b472794a1b7f0e5c7f7142cf53446d7a4f6407628c2340a243f38d8c61368117557e0133451318049eb5ec143e5c81331b294df86c80df30d34fe2e3ce910e66be8bfae743afcbc24bcfb01e7d8d56d53a8dba9d8415d3ccd9ed5d0e75367c278b666db6b467931cce4b5c077b006d43a5ae109050c92e212432fe2868914497f028207ee5f4700d84807836dd48cfa312b1bd1924f42172eee7db670cd67ab1dd76968f8a77c73804ee55c206b164ccf6caae7963c8565ea9f9388720b4f3740d6e7396f7e8e48de80498ad01ba25066ca2af4ae5d9ce64ea2bff6bfca2c8e0b42b4ce4d1bb0340eb4b5c145a0ac6cbecd6395c9a771bcb7416b633f0091731979fc5ab2d2d12b2015be21244af42b3c94f9ae0588d5c9cbd83749f36cf9a1ec09889111e4d059647c72262499b8edf3f57a3cb1ca942bc5d8c0b9d06439c7c3afb7311535dee3e6b9facbc56a74c2f35b03689be6220ad44d1cdcc020d435c7581aaa857b59fd6a4119dbeec0de535d1fda7e4c92a3b72b7425eb1bb6db28948b7d80ed9817469d786bc521043535488bde036d24c36b6278eb9fc3936f8dcd3c9ee1e4d0a04b17c3826265d5f734dd7a58e07a782771357f05e0e66a7529d7d74b7d77bf83f5d029a6be2384dca4d756e512e2c49dddfa7900a50e5c01f0715ea5de69aa0131e7ac69bdb8cd592d0b3a5d496e67ea23a31d8ca95be29871058717231d65a0612e06bc50b7857a0c266619b44772b344f15af302bbdf1cbf61440a407aedbc806a1b78afbc06a2b3aa74af5879953d346b24cd012a05f88a00a92bc8cc31cf3caf8ad8916f22d9df2f07904f294289038d7130c51dbdb1619407890a1c00450ac9f0d46319060fd6723bcbe0fe54a81f1588a7cfdef20a896f5f9f90923c5e7bac94ecf84e9fd30e090b0587f549d600b12400af2758a2a3a21c5617cab87c67d8ed4ed09614fb21be32d30a0be23d2d23afaa14de0696c427feeec95c36f68ee8e8e70b648005d29beb7f45419f19b94ecc2f7cf97cbbb2f2304d1752594b1567a8eca580ac6dd89a6ee5cbe92c965eb1f04bfca869e4e4bbef8e411800ec8d841d298b527807afedbabdf06e2d5b0061a0008395e06e77e1c79b42636d78b4ede5090488d9c9db29f3c2d51365b0a99d68467195c7c6714a551d917fd0e16a4d2f5166fe9703112e37cb7a2e9cdbfda199ac7b9fa968368ec488a201177c02c116c592b1ef876e1fc7afd5be30fc73c41bdbeeeec057b1e257b0ed72a9b5f8d054af076c0d82ef7ad9e1954b4914edeb77b4118794a176e2ec7aca29a1bd2648fb95d60456f59b6689b214e4814568b60cb7db87147e36ca59ee8ce45adcf261d949edcb6840bb45527a61da3eecab9b7a3143d1e9e69d1fc815f61ad4c7f93f90c88b240c44dcf55563d6a2de48070edf2edf1c29a3eca66184a170b560489174e515354bea7dfea4ac6549efd45d5cb6a1c81f5e67c461b978906de01fef7f2d4edaf2daf871b4869607e123650090cb55d3dd43cc73085bc9eaee76b48939d62886870c114778aa2906dd09dfe1e231c29488fb32fa429f3aa272fc1d1d713a89ebf6bbd44329b1bd8f3cb41ca9899631bf40ae439075f9ae72ca71dc0ca995c378b70c93e965639415b6041d5ff12941363faa343cc174ed0b637a9e4f97a564b98f4caa66b38ded0f7e8381da5c2d4b2d9854b565544c479dd80b66208b497731c3aaec3e005297ca2bb47062aedeb9786bfd5b11bbd634a0e9b3c1514f28b17c5c10a5d251d2d1670af3a923d354b40833ee6a89c0f98913d17713875180fbc18974df548c1a25357a7c99d6ad198dd745213aad9364272e9c9c1aa9859482914866837a2a35c95f426451d24d1addc8c2d4c5e15de74a0694bab7e94f8d73e5f79587e7b7c9ad07faacf852b6ca804a9fa9054c54a39ca7fad9a05b9533fcfc56c003bdec6440ec128a65989f2db632a76bc6afbd5365560dcbe7dc570323856ed5eb6ae9b9376e1c94a1125d5e26a8584838c7f46ca09e13160d01c0acba4c6d42fdfa6e37e7a129727f1f10d542271231d514efa84e96623cb453eefb17e2836d05ad28eb9b63838ad55909c6bb827783515f04d0b9820ccdabf5c1e7631bfbf89e7c1e8b2915d28e327294740e1f644dce8ccf66c3d6b30fa400dee56d12319a089eba60f750b70ec0dbaacfc2d2d4b16a5b494df0cd122e1dc092650b72274fce5d82f22b685f8dd1ddf5f677ebcc35dd5f644240bd7a130e1935a1698b781c2419839f5fa7cc96a3b756eeb4110b786ea1562d0ffa38e2a7e66307a242f6e4e730234cb4cb077b8002281052ba1153fd0d0223ffa52173ca900687dd92c9dcb50f64a5a6646dfe45ff248c9c90e5252482213f5c1615548967ddca92b32023c284b5520529d21b64f1fe60fc6cde3aebce9209f65346775e015afc99bab356de2f741d37ec2d60a86c2b426d09ef40b98e74de07bfd14762006710622379e8ff4435aced07acdcec54fa857bf6ea8b2d717e49a3abf5eec907a7364aaf35a77cca393aae896ba46fa24aa6a7c83c9442a5cc8d03ce67c8af7b08ba2daa73cf25ceb9d2db0990f1801cc9ceadc299b09a128c06ec5792b7b9c23a2475edebadb9b7e2abf2c63ea5cfecd7ba79b533344c38ef7cb0bcc76ea5f19cbfdad86aedb04e0fc409ea1a087982f1b3c758b2200cfa247063873c7e6aa741643c95abc7fc3e2a1716b08a968d082d094ba7de53e4072dc1cc29625fc5ddaca0a0a7979d7912157faf016afe115a701d9664f4607db31907ff51010dbb4ac67f67ca454506c6665cdaa2c78dea4e34a86ce1100af732a3651497282698e1dfccecd3fe61aa4c8d2ab510eca86289dbae565c5ae9695376335162e25cb9d7a703dc161fea95df51fcddf49366068a8a1a64632bf37f7d8cf7855368f91bbb4f3684704f40a71406b426d94e84770644bedc1799c12b04c6bd800a0eab9000c1419b08377fe16a930ef5b89a2fbae52068cfc71ac5641dfbd62d2c3d8336f914073bcd76a413e22fe4062f39db4ab5b4c142b063ba2dfa70d185e0ce70eabbcb44ff80a35c35a600f9ecbf8795c99c93f82f6569907ef1c86de9b222483efb81d4981b780b0d6c86fd3edfe8d3d82617bf2c5cf09f316e0e3b3424e7bd3df71260a94b3cfdc6d95c5573f5561e11cbbc7814afc5bb1504e53c0a96466962d2766f8358cdeadc113af7d69f9f82d1700ac11738dfda188af3659fa5871d39673f4fe8a4f3318595aab8de8de03823d6feff11088aa59a8be8ddd4c7ae0003825f012c01efd36af36a986f8ecf2de8158311824a108257ca199e968fbd8da0c5bf48634c2a044a25eb52f95d4a9e8b01dc499dc41b93d3a96a4d02f22920ba8a5e3bdad38789b785482e5a42da32526d7c4358e9a52ae1b39e3f94335cf6f82cf0d246b449ed4a02b3287dfdb1606c1e84efedded2c232cfe21c78c021f74987422","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
