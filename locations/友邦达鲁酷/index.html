<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a3ed30fc62d80625c0900774b64fd391891428d52787384f9268a5778ea0e51a2bc34f4cf005fcfc10d69780fc7f0fcffe5bd82a9275a307ebfe25af21ef3460fba51ba654fdc19099fff7f334857a5779819cadacdeaf515742ecadf5ec41df9ac823f1d4eb25b846335ed29d15c477ad1d5d54e0d96f1d644e57543066e33f58f8227edccab365194f3096ee7958a961e1a3ded1d5e9c8b7abcec54efa8ac9e6d21185a76141ae20eaf355ef24d968cde2cc449803eb0aa84b3e82ea460b947ae954512abe8972ce43a3a6795bcb6e22c7c8673da76deb07e4cc9bf116c0ab9229f31d15e5a6ad767d482077fbe022b9f1527c8e4c32e4b2a8012e40d4b671fec57db1f10e6c3e39eb164c56a877d6f93dd621ffc85bb06f3054ff22c049cfb2fcd703218b896c653ba8f70744285b6efca4a5e9748e43ed9388cde434a1081543e3453d1ab07f1a8d2296da3e4f319a791e482259a90ed8908b7772eb34ea562624dbfa5f9c7b7d2b6fdb351c6d96333879a786a56c45d9f907fa0aa816734b776be4185629962579b8f76000d016533a10d3e56916eb0dcdffab4022b5e5aea3db0a7a9da21c0249ac5ff4184f626f745efa00f33c9109265e5d18af33b57052e621bef7dbbf344a6b1c9953e151d63b52fdce9097e402c5d2abfc1cfe83c13cb63e83bf896dcda8b2ecb04728972bdbb4da3aef04aa27bb4c44d48a86bf9600d8f73a1453eb52f3e48c0f19c551a07281bc6dbb509d43c830f31482cf8ab05e15e57105672f7131e4b945dd245eca099be1df1d2b728ef0d4111048d24421f30630bf49b4bafc001837e3332fbba4fbbfeb37ed552700dad31816a830adc9250a465ce8b193618bb425ee02c3cca8386d7599fc9bf41e5cb9049313985d552c8d2131104a590552a374d6bf645a483f3a2f06330843826c23c97221381de656937e4050391e2fd8c072edaeb6934be4ded04b38bbdd403977299befce121a86f7a6a3b7daf1a17351ef22d277d011e24a0ea4c4139f31f4c8cbcc0aaf48072e2173c37dd808bb874fd4a434c244b194a1fac3712d98f3d4b04e3fb488629b343511a158189867d074e3f5390187616fedb02c81a34ab30933249c07768e637e1640e9290b96385d124bbfe902d7b1d88b8086acc327093bbda04653c7a280ea669658bfb9dc3cdcdd4ad537a540f76aea5c197ad08347de65013af9dc8e1338557b20b1b93ac36013a861454acfca78cb7d5922aac9fa98d420c5e01f2aa1a06ff72b0ba64c9d43704aea9264f8d2468cd042c74bffb8b6fbbf7e157c5a58075a21d11c026c59ac56732a346173e6690814262f29bf1db8525a412b7af9b08c84728b770ae91569605b0ce2a44e399277c2c08ed0b2d54a98296a493cadb2c25a91c54463d88e4e2c3a21a12cc326811ff6c72c3d861214a95d4974eb8b7b4b30f358f1960bdb1d0a1f619fbf053a6095e1f170ec6957d621aa3e6ce8e99b955f1bf4d01dcd95d4202a4db80e67450765d532448d5a46bb7969b4e3329e1df59f193c2b7ce0581f90ea465e7b59a41a75ee558efe1e0d0ef42d9e8a407d18d31bacac0fe222d77694ecb8d08d48a6aaf5cd323df4fb1e790698bdc0426b92af5a0541090f764daf8bc7753d21224eaa686c4890fc0b3493ac2391bfd661d4f893def5f4f310b529b6950d383324f4ad9c13c29beff90bc6df7b3c0271f8a4212db13b51ab42b77796512a4951323e4f199dc700ee4c806f9e2f60bd7a4e9d3b2a7acf3984ab96c7f82843bf0f7dcde9f09fae880fa32c7c936af58dcfb7ed2daf8201e336a534fc27bc0fce6be42040b00ad3896474353642997cd73865c046e71c5c208ae06717d79d07a0c11a030faef0be851b1e641d1e037143af052b451232c33394b314a5949d854cd4f628714f27cb2404949c849a431e209c8ae203497302428f38e7185b0f05308632338a044a48d5e29e877b0c46c4927f77303136eb46d2b90a1b9f127788ffdd0eba30c51a57ea4f8b339421978915508a3349bc34e686325d718a8eedc4ed80209a49334ae8bb80422fb789e0c1d4cd001c7f03ae5c8aaab07d912cd0d038f25a5ef2c74301e96f3360e034caaf2e342aff30ee028038b947378223072b6b96d1a1a7f5eeebb4c4cc24807ebae42f9f0222bc9c696a2ea00d8ae172e90c087cdb019a81232ae4e0faa4343d8714cfd7121276636dd3ddc8df970196d0ab696f472ad420efcbba897e4346d378d057d69bbb7351aa0572a72757c0a898badbe2da3584e305edf142959c57de4529afe4b7a69bee4667c7fe735dc507100512db5a84aff43838b2a8ddcbfd10a78b21ae237a21666b4e365eb93836335cad2befac5621b0573c716b4ab50bdcf93fcfd0e2ca5615e71045a70631e0f716548a9106729c04a4377344a93177e6478851be5e9e13b52a80eaa9e292beda5cd8b34d1da392d01d7ee90a29f52d5871109daf393cf5bba560ffb505c5336968522e8fe06821c69e4ea47a27602fc323a61a8b059dfc1874ab62aa0484c45020eca8b1fbdc953854d345fd4a6e59c04ead260872ac332742d11e2271d16139a57e5fbba30d2c4ac2449cb4a5e8176c9c825622b3a377c0580967cfa09def165929e0e26cc250c6fbc8f3b0830dbcbabb9667f32b58b5dd88fd42e063359e47643efc8ea9d5db728c08360e7fc5cd0a9961883da394c590e277060e6ddc5b80e76150476bd7e5c295349cafdc4f28d32f95945d365a9cb1d63bc8e6d0e936b2031dab3c6567ff09bbbab499fa8d453a5e9445132819c932e5deca5bbca1f8cb9b2ff414f236b6ced72d49413cf8b0b19fb27c9dc8fe0efce299994dba32ef108bd825ea0c9d869fca06cfc244e26bea5eebbfc7a1ed6582d52642f60788f78234af8dc79e72b09f50ec08f9e1a1665774221dbf9cfd0f0cc9d9c74cd65063cc2c2116a74aa2a740c1ee6cd60044e7118017fdeb7223ed3509817409102b2e81bc96814e9dcea67b850b2cf9902606bc982addeebff49fac75767025f71b6216d13835bf2decd109e1f51e8e318b7917757182e81983312d3b25b09afa6ec4b7366ac6a14db2ec18a0e5ab476a8d6ad85c42c3bce1e56cd8370db9b152db759f6fb8f3ecfbc5cfb8add192e6e12e35393efe1ba6d1f91e93374de74a78ae39743a08588518403a27f9bdd8ffeab794be7f4e3c8a8f84ee9e5c5c4fe26c959d9138723726b27dd974779d31e6ff5afff6e25e78df3909f2e884e042e7327ed4fe44b0a1b8d48a0d67f9d39bbf36ca82ff25fff9650fb57c1ec6101c8fded6917b2ecfab60301d322dfb44e33ba21a8a89c54efff9ce58ab1ad58b6aa0afed674cb9ea06b2b868ac424c962a17dc95e3e2385211a6fd2ba2766cd3544a355dce3cebb7757664fe5e1a6faa751ba075afad1a1c10575c0d73e941e80e8b2677b6d5c7f627fdb136f20dd22f82613240a126a8724fd14d352bb4e7bef7c49df0d91bd0dbb9f984c2294f549e964218a26f4479692550736ff7dc120c61d80b1bd5c2698249cdf8530980fe68b0f4352407071e066316a92000c1ed51fe517f29ecf00bccf89572fae00a2f104b441410b0d370426dc873bcc720c3749e0b572fc15afec87b241ccbdab8ceba9460ececb0c674b4e4c60b4934ee33aded39687157fce99dd41d9e8057bde6b95cab36e388f9ef965d42166ab1713c2c0199f4644baecaea56386f4165757a7d3ce5c2041cb26929a6e89af8b744097f35522412ec79e6a4a35e1f0e3b31f434f255ab9bbda9d534b7409bd1e10ac711ae10257dd9936170050654040f065b31a68b1d7b5a5ad90faed255ea3b843a6f1c260b5f8ed5a843dd5e365565356ae84a8ff909304bc89dd9f8f13f85f9350e1ce2f702bd48484d8dfedf6695825285ce106b241e28fb666d85724b43d0a47296d465574f8cad8e8b5f256d78a6d7e392477e0fed3d570ea4943572a843f125e5785f83284aad4b78385fe73f3a7bb6296809e6505cb8c296594717def8d8f951cba24568b3a6088c670ee1eacfdfe28b3b6289b755c07d772be99419f259103478046abb6c3010a649acfb4218ce1556cbea726fb2950bd8f4ba83fbcfcbd56bad39604b3f4317d19e2d723df2ae9d65acd2d326b6e083486375957518a9b36067f18375aef7430a8f1a9966d19f61bb6e4f5207e4a3632b3779d8e02c38eabee00d222825c65fa175e790bca33f510bac0e6403b290ed877ec318369062dc6b5a4a67d7e83fae10476118d1e1f23774f5b8ca000f0e0e57f725f45aee57078b540d655f4f392b90fb591fb79e95db04c1436b30287f320b23203c5b3cecb7e98fd07a9e9f3e8b64936619570ffa22c10da6dba2d60207fe21a2fa559e011a26337790c9ce60e6be046d1fba50bd30deda5e8fbf221ecbf17736a30e7027f2a934ab3199c46a6d09640fdbd51c34c7a290b8eb3303b84ad06bd5d4113ec1e7b40610d1555b28f788e105b6f2e3724d7a3d0316888935f80e583aa24d62cac82f0c8f578df550f7def1673b9941ff500e4d72e61c7185f24c137e5a9d987a33bf4a0c7d65597fdc8426edb04921f9b9125c069201140b0b658a2a41f33db32cb619c7cd95f31d96631febac38e48a8a1a80cc4fd9468fba840a596a21095941c70a7f5ceaf45aecd29424137d466ca636d6e75f9bb990884bd5fd8c56e25bade02286e1e99e669add34910d5031efea40b54059ee337991b242db1091312063e0f0e4213fdb7a9a702c8cceee266c8a7489edcadfd5369f6b6698bdb46dfe8acfa070fe33c3b9d2c19cc302250dd2ee94186d7d0a88dabcfb95662f549ddddf4c6d60e4af011fd02f3fd8f3d4faa39dc3065e4ebb1af459a6d197a1a21aed8f932d277b9f77bda53fbb38b83125dd1b41683821568ab702793e8071816b89b2ab0eeea2c69550660f4d358120ad7df85d4856e070cf9f7ab37d2cc42949c7473ce64f973f4d24698454219d7b1969302a0eb960a4fb842952f810601bd10c56cb1a0f8575bdb8f619d217e5334ce183fed5e19c80ec16ccc6781f9d869f04146cd2f962ae64c401b976efbd45afe503c7f46b5922a0b322d8b8cf15322014e40bb672b392a85efb15121aa3c9f82964306955962638f0c3a948649ef2db9a2a42fb5537584590fdaf7c990fa103ea9bb9e0135459783db4496a9c3c413b5b421c01bd737784f6a401bc407a6a43704e32496aced373cd07f3e4ad4969efaec8116d2f4253d6ed091ef564b7255c29d77a2ffb8703b4f67b3c60cfca881fac07ba8507345dee682aa2585a39f184072213b3816eea699d95f66bce912e1eb8ea8e31a2ed9747da09090ebfdcf12d8552336473278de51fb4a0bc233b8665f5c6056108c98e1c9cca74439a20f3cac84217bb6b69c9101d47a83c692964152fe84a614c6e05352cdd02fa31edd49b0984388781a8a8375a71a9d34ab65381f6d589647293cabfcb30981d530f63303537db3e5d98eb25846ad14b28f0e7c42f4494f2d54c88d9aa71fbf7190ac058337cac7781532f5e1115724ded3bc0c2e29295fae74fd2235a09c4626052c82f32dcf5a80ef2af8befc9823c1321ba95f6e8bc36070051c6851a1c3e26743a6a94b59505e576eeaa946f7aabce9d2e397f3bde4637761f0487b3ca88931de1a2f40019f64e0698c7128cf862076fb84b62b27632c9c55707152126e843fd7ca4199794670a11edb3786a0f83e5534abcc341d3dbfd4e6b425c7e2b35ea2b92fb3d9cb6ca2c0f23a692596ca0c0ce97281b8019f47a6be7c3159ca02173c85a006ae82c84aa09f559e92e2f9d2cf0514e9d5edee406596a10f32bf2cfcfd72ebb7cb2a16f6f6f341b556fa948ded6f2b0503b0cb638adca47f25ecefd29a69915a0695f1681ddb78f2e0e2746f357a506dce4f582c995b551ac274fcc024fecd236f6f74386cab7a1f17048b198524467bb992415d5dcfcfd07c9d7c477d11772af6a90a62e8fbb5402ddea89d1ad2977d3a07610c65133f9cf336821cd25226eb58cd0e17478b036bbd54bb89753491d1162e36b14f0d5574164cfe27a20c2316962e060791978f752d6e63bad8a25a0a98528b6cf7b956aa29672390711d10a2e6f9cfabb774da481fbc1f007ff6900a5407f54afc4be86cc35a030de479e48b2036ab343d48aaee94b2a0d0b56a17678f09d69dc6af645bdc00abf798c5fb91af52324a923633635135426b4ced314e30a043d6156f25e8bd5738f9cad8b3cafb56132ba18d215fc240ca1e5de38bddf31b275224c60cf9865cf602f828dcd62f495ea44912dd1bbe9e2178a747aa96c0b8b2b886b76e0d6c99f3fa36b1c53985a87aea256313b3ff8c209ad3a6b8b96f862db7958aefb5813ff991300601f8bbe034540070f05848f9d243a1d516c132b0d0cc90398f2a10f90e2f88d2071f224e22db3b4a48c8169229ea034184ebf7ffba779f0e9251af4968ff259b83186755c921831b96c011d09e6eb52111940be59dbb218ca1090d19704aeacd028d6408f599c568561e02d021945a68623f54c680acdbbbd20fae450ea9fa05c1aa8c2ad6a6414f589a48871c4989f582cd5e9aace88692bf599f3cea66f4699b6287abbf3a5c0603bb90db955ac64b72e5b4890228472bd42955859f5caec322cb2a096cf26a9ef563814855dc0a4d6ebc4fe0db1818abd05296a37a319956aa737984c78a22697faf75f684a04156caf5ea9636274cce42b031b4dc2dd0d5b73db07047d73efc1bc5f6aa769b5dbf064a388972f99bcb70b0bbb820fdeb272a2ba8676952c05d881264a343d5960896bc1c0fe55be1fa65abc0f1747b5794ad73dbae66ce7c264f939cf750b3678226bd6fd9e1608edde85a890b178fe4043c8611f2e0ec9f66e226f62fee0297683388426eb372de74ece0eb2d15ee76c8308e4b19c0f040f85af171611a455b21dca31373b6f7a73ce382c31b028a7e60761ff883999aab2853fbe8abc77362a02a9014c5c25980ba7e2732764211aea3419a7ab6fe6d5b58502da9f75a2543e8249a8ab4a48a53592e30e613196599870fea165703def508b8e184739e07caeeb69ad435b3e23951bcbee963eef79aae85e79309599370c7ab8ac8a38db6fd933bf0c15e8c934a1480079ccee45a38d37d8e40b3de40df418b561d3111219e0752cf8c661566bf43b00f36825896589a3db727a0da945a9a62b4fb1e4ca720732db5b07d1562137853bcf0b6fe15849973e57093b74096fd3686b0366b804b16143f3ff77c760be154f7f8a5a04f9560d1d2541f3f5c7df8d7ab8e47e71a140e580c13fa7b3b02e6e2cef3f807d1f31ef3a738e1c379eea45976452d9b0c66323791b5355accfb45e9170a2a850a51751068a6283ba4ce65bf400cb1d8818546474973452bdc716db892cb0288cdf2287ad711639a604979ee22151435cefce924fd73cbbbcc75dc7c51879ecb0ec787ff5e757a28e123224e91f75e5df95a20e63b7b914c64d472e737224d3913978056d154f206780892fbb5ba41fbfa5645f25f1097a8f633441a0c2f6d0b24964d54b6330039c16ab15f1e6d0f84a566a9d05a39bd3c4abddd44c4f7eb2ad600d2a16db200812d6c5a1d439380967c4fd89c3d1540c35683bf61d5ea8e75634cb2ca366eb62da28599d71bf6037a4f7ea0c255a1767541f539efe484d546e7537b305e0392cfbd332795e96a28d235d5faa8a705d406c21af35a4a0ec376bb1038df3b173103adb91688bf9052402e71825e2aa710095f93150a662c6513fd6d15aa1a8eba9cfc8c12c3136817c8a4e10d4a2daef5529bbe83c978de2503bdc224ec9f96770f2c8b57f3440311096f6b169c18329bab8812c58cd48cf839eff1e916392138100f6fbea73089ff3a8b624103d7b37e39d534ba2908d46a6494c30ade18b04d81865c4e3241d2921458c952ed3933a0a3a73bdc77e0dc3cb5a4b824dd4c5ff74b0b2ff124e391a40ee9c94c3ff67031eb5112aa1f1f898a850dc108c179e5fcbc507e866fc563ed6b934e1b5eda36827f88ee4ab63c8ed442a5d7d188a0fd8619a2b3e71ffce3b61488598e8ee78e5d1ab2fc1e25df8cd902ee0c23f418fd25a0761aa63ea2fd31391602b1cdd096c83f67f07fadbd84892330d5da11356aed86dd53759589b96e5a9a84226e4ac79bb14e5f418e8d48d87c09536d049716bd82ff62436e0cdc6776cdecb21437f5a56b945d0ce4982ac4027810438b5ed64620cf7701153b2d33399b534b1c489a404557a415f77bc02bb3bb100235c1deb2ede990790163d78a26d7ea5cb143ae4bec69aa1331915abf37351e623f2c7613eeab35d4b3c8754b0baa177498fcccc236780b51dc35cae69bfaf96c370a6fbb0dfdbe4595aa92077b098dd930aa7a5dbd88fdc2ff807c2a48b772db0d41cf29ad7a1adfdf82492e3fc348c3424ef02bd2e70b38a2c9ba15eab4a5e360345c649e1e81f89dc1c0ebab02ddaed3e73d2fec466b9b386f925c879e86e482e00f55ddef9053476bc80c33718831bb351501de395c842a2dd55550d51ce4fd1f7087a2755f308ad7cfcaf512620e04e72dcddeaae7949a2944bd8e58da3d7a497a02a035b1918f021ff1af7d34f6db4cf41cd2f5b34855bd7aac0370a8dcd60b929567d87630e38717bba20d64bc3ea6a612d6723031c8606f362d88269b81cf6b7bb74bdad975c7b96473de403d24ac7a1fa304c19675c1c25d4d63f934dfc83de3d547ce3b2d19aaf38a836e043074222a60f0a97af0d126d7a4f1cbbfb7e61c7a668999d627813f02b96f155add3b13fb0f80173123947a17b2cab1270d635cacce63a0eecc9b884b7938df36063045794450892e16d11cb4c0a989d9eb44dbd9753caf1f6ef82dc2cb78851c4c4fa9bf1db7d9290f1080608eab1047f47bf64f23cdc44e0c92d4ba398d707591cfd0addaac6f862e62d3d947f1cc31119fa63df484f23df5e7ed1a9509717ecee6e490be59227f80ef6bb1eb0d59ce2eb3285e1a59e4f96a0b622287ed42a3e639a44bd8b716e79105a007aaff3c7f8a444c4ca671eb4072c3ce8ba33d36f12978085ac14e5be91cd4dde3dc65c2c92251970e16542faf9c799b4140d57f9af5947b333531afd6ccfc3df22685f9b7c8039d9427bdbc835764c57b231af4fa6de20b5f33b4e10b226fba19fa2f46f200fb84822000dc4aab2c8f024523df6e8f650bda38cdad4e6141bdf939e7ee2d954f61497e03eb5b01a4e4de24ff0d75ac0af29aaae47f29b19a9dff94620ccafe221c9958ff323913387b4e127ed8bb0804efe772a056bfb50529ca31b18e22d48f852e2b1c3244c9cfad9bba9c0e82f29df1aad56c6aaddc4cafd4aa061a508f811c5fbb6537f7bfec440712bf280df79e0a3b5d19c5c1b689d4af80600aa5d407cc5cfaa711ec9eb25585ecd4897f708f7943c259518da204a92853e2ac939260cc66bde679a41f4ba89d9779f4871d5f8c26e994c56ec0bed5102d59b529898e101d1d4446b70016cc4e6fdac93291a758dea85fb8a408873f59f159e01a77116f400b3bb80964bf64a143ede5950fb6f9c237eb40d1ddda3405e34f0518ecee0006491cdefa6dbc87bbaee2a3dc0e1477d84b97e7d9b6760a99785abe6e5ab6c07f29a2dd8f61a6b52a9b530f67e5d103939657b322e0b86db27bd12a8bcb2e92647af89b9911be4bd0c98b46e0da63855c720403788c2bd7ca92c22d380e5bdbad318407a4509bd6240417278c7413f57b364ebe088b3cf3cb98be34f2ba65cf7805597206292e98b1e87ac32a748025df0f5717ddb6d344def6e0630510f5cf9cb60e42c0352cc83572335911f691d3e8c8d5979a64c0843e8154af05031b8a458a2a463a66a7f0fa1e8c0691ae979e67c93374f03c86290dd6dfae36f8ecea6e6da9931f256d3b7a01bae15700568f086624c41e2dabac40c78d0ecd45428a820553270ed064334cc2fc96745e2cbaa7a9fc22d21200ec7b520375194095da0102c2b36d1f89f1c84493168e3cde4d73bf03fdf6078a78eafa705c0b0f7f17fa6decf26dfab05de052e19b39ae49c72d18d61e525e688ee5400c4eba53072a1c9cbcae877cd5bca6ee3be428244da963f0efc73522c0f835c71d9dc881d75f19ea4479564503219a3ee7ee9193926f456b95c526d7a353517538425a23cc77b83ded39309815d0ca20248d9b004141b1d122cb31fece218370d0a12d28892864ccde49a402e71e1d6ddca2d6ec11b22b2204060aaa787ac9b1fa93135619c11e485ec649f9f1e4ad598d130a4280b96f6d556fffb448f630bd31d4af2d48383b4502e10d7df8b6e9c1b343fe2b4545622c699e2c2b9b646736c7a9ba9f74c969c65fb057c268b6060ac911f155423c928451728e82f329679814a52cf08ddd46ae44e53afc23125305005b026a89988b384878b2900690dc76c06a2615f74bb216dd387434d7dc032ab2430cd02bff2fbc89f278fc0d877c7cb2f1ac9dafb11941af294b281352da5e3ac30c19cfb79968e0787f9988a9916bc9c411c7a9c6b01d751423cc4f30e7467b2e618aee7295ef8f062cfecb1358a22c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
