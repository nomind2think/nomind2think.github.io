<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea19c427c52137e6f2aa4516f32e1a7c61c6452b248ef0e33af3c58879fcf5856d8d6493b0a350503f06c768cb7d2d3ba5ad2b7f266b50f8e465c423d55aa6fd954cb1d148565aa866fc83270046b1a20de34acce49fb38a59f3ab6da93dba76708f76abb838e17962f63af3340c7c07519b3e484618cd297cd2e5d909c49a379773f1ee515391485c2e8f44fb77d500697edd303c70cc1f8877cc64fbceef7bdb4c9edb3923c20f5e0f79f27667fc3f6ec0135b3884b1091c6bca9c978c5641b6be103f82df1e351ffea4287dbe3aa36ecc7a61c0af06dc2dc63f1bb4abf2871f4db90c90497c3c5a1f64a6e930ea444c063da466ff01ab07e2454c435b6d26335c68c4269371b5865b4b908f90f2674c57781ad0cfdaf232f5edc405a77696590f5e2130761db50e43cee3db659cdbf5f52174d36cb5953a1e93d0fad4c2401b9f1aa92187952fbabad70a7d76a003486ce128928171264ddf28ea503ebae25d947f6bc775fabade5f100d4754ac898378a7ac4cd40c47a00733c62b012ef665c0a30099dcb992fab72c0e5374b228a048e8e2af9e30f75abe920b08dd92a06f938f38ecdc9959552aa7919644dd77799166e328c34a38b2c3ede4d816e29fbf063c2855682201799c25f972c2c73f1c7b6f497c98cba1d898783853cd1ac85254783cfc44c382845d2860509db8fe743a8cffc75aeca0a80fb50fcbd7da9fca50eb33c51034beee2cb4ba8574ff45f72fdb68170ea86182b22dae34403a9670fa8eee4e8a43c62ff73f4588c7ca8f93ca94876751b9d152604fce6ead5c6aa09ad722d5b6df38bd3c42700eee06366ecfb0cbfc394596d7b3efea5b05bddbaa10c0b164e44ceb789c5585bf607e28a0108670df8c3ddf821051c0b767e9834192d2cc3fbd3da68bf0ed4c2b6e7ed36ab6527b9e5cad4dd1774d74d4c042924c8c6e4358879ad20e7cb62d92d0710aa97c76cec006a30b124f9f7f4ee49335821c0f0354af871f0127e053dee28802950b1f4248526a4d96b60770b1d1827472a14ea98eb26d83b1de48225b411929704496fc396e9feeca054c8f6f9c61cb423aa03c1c785a970d483d03a299ccba75930f9cb7bd162acdbec9d3393f447edde74bdf4da39efaa63c4fe87ee92b6828e49cf241ca76be970a89f94deb23eb31f4b7458efe63226cf7a8e1d989c96f70b36baf063782e830ffd633034b9c0e2270dd05ec9c7d9b41d14ce8152c6b8421c42a37e80b4f3ac4a02335a33a3cc9345d25cbc0996d1b2b24eae3337a743c4fc5a7618ec13b84077d4c98abdd0a005c48d2e3c011798bc2c56fc9d9a6d854a3a2f18e941797a567a6eb2bc96959ec5e14399a9c7976247b1c610a2aa0883316f98fcf5d0ed18bfddea6f7c6c4f7a6aa7c76b373235cee3cbb9f5be286b92a82b01d10e44c1ffbb65f800f509b557f84bc9780924c39ea44b932f145b0dcc68f12e2b94663b8a5c2ed7ad3135c6063e2fef9c39a02b78668f4c7dcd8c4b17badb0f36eaae54a9640d14d3104f350a2792166ea81364832d32aa1d90ea9669665738d0fe86bd33b76c73a71c04a0f8a8e1b768639789e7e86ee765d8fe52f4fa0dadbdde6554c0420fd3cf84edc4c9d8defb9a30a21ab72e543155a049c94417031e819d0df302b3477fa04dee566c0c7e7be4fb613c70c600df9986ed7493a893d0bccee495ef1a127912d59f4cc1830520b6c745399ee48a8a87dfdbdb82e22d6c95a2034d9db60fdd0a84e9e1e701db8747eb8ac2d7e08a38a06519cd45478c38b8fa88bf94c8276b623fc71d6ad4876705ee8476101ac565adc9b91156d0bd802f13d64ebec57bee7dd5495c19e56d2a4428889a7b5f66ef47fa210e89c697d5a7d769cc0d3c9a5ec2ed517709fb2b08643624e05c21c892b822b27c0292aab9527f8a621c8c7ca4d743326fd2457dccc750be9f7f94f0f8e3bac581df9ff3f1d4f335e342de6ec59eb774c79bd0cb63f02aac358705514e650caf48912bff3e74a02cfc5426f25b5e6b0eb2686e37f4f0882ecedef675e9965411a91ae5292c494b67b6a4bdd01cd34377f755925d522b959fe9c9825e1dee685a26ccd4a65645dfffdd485c1fd80ada77097c9d7d8ddb43f22b680003c58d76290b303380f22b868cdb1563ed3a64e65131a6cdeca8e09a7f70914ac238d44da926cd39bfe129a47bafba8a116ce572dff85d1c164e7d6f8cd5e5792bda46ec2602f31eaf2e7d5b2dfd6a6365b86decc3c0439a47a320b35e1dca21f1494bff9a26a0c38b5aefa0d20c40d3f286826f7564c57db1bc57cb63b92c33e0e4d2a26b0f0ba3769900126b874627825e5c73052b7363095e492dbac54a1b70c189d254135b778cf300c247d8bfb937bb2005e36303193040613db143395fecba8a9ccf32bb791954a314fa80a79ade1a5b284f765c17c558e1601bc3eed4f778d29980db86919f113c7e0df659c079ed35575ee24810b4ce073aef5f1d4d681d4a5dddadd7f841c874675c30290e4370b30ba52e0d786a04d9db885b783288da204ff412ad2cd6fd89186af65eb2046eaa6e0e7caf1ce73cb0acf0b577fee39df235f3022301e641b4b5e8eb2fefeb201b79c034e0af51451d8fe84311dcb679fa3e65faa5900aa9a1229cb0a8d57e61ae63b0965034b3cde258d9eff393b954a63f32da90e591fe7796077f3f49d528ce6d5647d97e8e056dac49e3080303f89940c590ee9232aebd954685fb39a359d3d90cf22a43e1eff372569b71b652e85fa6288614f37c05375b7a738d22a0cf5a5419bf791f96ecbf96e9798f49277fc675795fc93cfbe6280d44f467ddf57d98000f28d15ec34603e6c5e943cd99246f01034f2c6cde0cf4ad438089eafab2df17ff449b6c506f1247330aa0e3d48980f264ee4e46a89a9886caccba95b8b224d81c1c216f590b30fdb523807d4e24df73ac2d2a76be46b02c652026591ae295a26f8c110273b605a00465bb5a1e145bcf036483ae1effadaf930c74cd3aee2b9ddf2d5c296393b076e9f1806ceb52f9d2e3598462ffffa231d60edebc6d70e7cca87ef74e0334f97edfa3a1f7794e2cccee7a9b7c4b03c6155813cb86fe2d5a25e58f5392c25009be5e5f4ca2f5ed66a0d349b3ecb11033fb5b10a56e9d7cfec10a9a49459e3447d32e057add1239f20c06f80fe8854a2c04e38f3a61dea9360311261782f8f0796fd2b1edfa68fcbbad0884a30c416f19d03bfa59fc87aa7cb59886787a67540e8cdd83043a56c92f55825466a4d6f6798a949dcdb3d8563fc9c070c803f6aa32c2ac134cd6cd9d99f9e8833e0c9bf00e878b402718c25385a3dc510589358dd7208f62c8d88b614c873cda2a48382e44490c323fbed54d6fbf443257d81e8e539352546b6651756334ab8e86e1c9f3d181d510c4ded2ee3db6d3cfaf508f687335155245832775a32debea1711ff989ed163c00a279ef260db4e20b81309fd3c67dc935b4675228bb19496bebf2fe4875b040bcf42b8956f7e538d04ccfb28332a20dc4f25402ed3bd0a32e077fe7715df3c0c325b89945b4c5798e7694b0babdcbe174470bcb5e427f1345a16c745cd58e2c722f467739d5db186c2062f7c65eaa65e6d0f1b0ac387956169ba41d5cb9156d0d2647737071e495d564f476515e9de539c9e5b329bc299da570a01b2ef37fe3c36d7a7aaaf882475cf6bdcf2caf16de3627086a84c9a2cdf44ca64b09a3853a7adb8446d3e55e59bbba59e7ce4825dd829c0531af05f80182ebd80c8812eeb3aaeff5a7d738f498e920a953213e1c5408335db4612834847c89fd978c2cddb265d127e9b4376730c5f1b92ca02c99abea6ecd26834eff23f4f3a9ad72814919b843190ee0085723054412181a19f245bcc5d538a3a9cd8d484921f725411a9559428e658b64b21c31bb634fb870f7ab360c0a0054ab0db6f3af116c1fdd2e72eec70faef28862663d2c74064e929f0c4eb15bba586008274ca88b7f3a4ec82301c8b7eb887528515c0a7cc430f7eada7617ddb9dd86279f028cb5a1b7c4321079730d7c74ed3df90721870ea04902a33fd50c0069780ddc45815936b30eaa1713d30b232a1df7f67c9cb5373951e5ac9207ff386138d3c1669247f93e425794cc48cce6b528989ba0088e99a788a568606b797cb731b2859ae382da2ad8ac90ffbc1751692b3dcfd8f9ea5f01adede7b85d9ee5041ca94d636365388795da7d3d15d596e14646786f888f66e30e5608a412313e5ac2baa5ffd751b14270598199b0b6a18c7a98e5149949f561cabba6b13a0a7c5e9d0f9543fc341598cf5819a57eb4e9c28b1b428a381c71d7bc9cb7f6e304175b2ea352d9400ddf5e816767a3c6c932bf871fb7865587ddccb82ebc882ee2a225f34fd01dc6b4e5ca71d097a10b27828de72ba471a4b943e274ad8637144f98c35785ac2830ccdc3cf2dc9acc6afd0bf695aa2505b5544b43c6696ee8f716cd5dff84a829c7cf85977c5740327f083de1bd290a4fbc2916af486fa54845d617c9391242643b3a721c14a41e6bef67d84ad77dc48adf5ab0002255a499ab7b9de79ba65b779f800fc72b547db573bf8437e40e3e39a20dbfd573ace1f08920617538aa32b65e680df2be4db4a49a333e64c47d72456b03217d265e6b7fef5042ba6bf89c0975eef47fd2cc26204a24557d6008887c2f12081fcd207e18449f0c8f10ab181391a095b8cd954c5932f6a87430b1cfbdca2a8a70d2925346c72b7eb2887beb0496ac991b3f11725c22d12116abcf8be73491deee223585bb00deab32a95279781dab59940a0fc670bd951a9a7cf1c985bd76c2dff0848afa18aba9ed049f33e7bb5ba645aaed39d1251705ef738ff9f716aad3523a36761c09592210ed1f6a6560a1902260331be1ba6d33cad0f4fd3b16a32365c1438b1a4bbde6cf031f50a332b11a47bd19c92924a4fb37b272a304ec71d0d76361a70c71fe17daf118ccd6e4640424525e7df338d2878ab6c0c049088dab4746d8b4172bff91b9377d21d5c68a5e5bcd1ffff37783c16826ec0c6eeee8478d9ce4b4cd8a54587ae41438abcec275b145a2b4b5b83e3aed5216c676d96728fce21f619adeb801b61f7b485ff8b2b3937803ab1e1d4d18dc7783d167018ce73e68c53402234261459479e973347dd8c870fb0b7c96aeeb71db1e6db566637add84f3c5bdc3395820df687b071e7c049229ad479bcdfaddab97c4fe4af18d843da8acf7ab8954d0109ef2413fd3cb99ef5a707c3926bc595e1b25f4c95e3b52d6c7d5503e3519524916215d74c91ecd7c47097e37570d4d528c423d581d0df69d54db37ce95f48191c3b18927311ba2cf446ca96ad7482383caeec274c877c5d9f51c5e859fd161959a8a86d5250d008feb85ff2c7c94d565a01c90a8d42a786116fe45ca078a8268b28742db015d76ee7fcee15d5d4242b06c2985ed2a2b8f992159fcd040b460ef2f02ee36a85c03072b0d2bdcd7a9b29e658030e5a66827750f5511195a75fea4d18f07e805a0939c082cb009a12339e6f39ffcd146a7f9dae9cbabb65dc86027d390e197ddf1b48bda5ebb11e557a8e289140e4b7aa0dad400ff2ee0c80b6fe9dd6d74494ebe3f6d34ea8f1871c75cd3a7828de544a9ab2fc04ddf87f2323e0a5d2de40e2f6519fb9031e57e99bdaed2f9f587cd59d34f7f3dbf090982e01a5cb2749f0877feb6a1913197cc28e21d37c335a27728e47d21169a4b157a5238858f310298db68e828b70bc7c2065963f08a0e43278875a06afe2c7bfe8768a1eb93939004e85ec644b6d496ef5bbcdd4a215287647f04c5d91c16e3ada2fca818e41b018a3b45cda8d753929fa909b9cf2fbef5e51fd187ffc4597e7313eb57632b272db9c1e175a4ad5adf895a1f01b6ce4187aeaa750b7bfcda7460a3f411e46be9a769e4fbc11efdf659d2bb29c043df1fcab86d2149fcf5bb72d0e9e944859b5d8b22d9b53e572c222045f93261bb1137072883b2c84ae95a1b16b65806196c7864b1c951b2f6467a98abe4a92e53bffed254aef44e2f62ffd50eb61a6d4877f8ead51fef1f602d9e7e580ff39b3e547ed1a730b0daf7bbec1b76494cc5e2283a6f7c0a1c64b37bf2b9266f2e59be920c55be869bcbc46d8467a1ce4b9d1aac90e68898a834230c0a72fdfc867a27908e0df0aa9064d3ef672667bc5b204e925bc99ebc29aebe91c88f145d6571183262e780ce4e279817e6c69d0caba5c65629a42f5ea23d2b43332cdff6e4a1ebd856082aa1baf66b06359670ebc8272c74eb2c5e5bb0994ea360201c0e45950457a361d1860c4360a9e2bf9a4d8647a77024b37ba05c1556d378a0cafb32c9a9219c695e0d2dd84df7b4dd20a2817c9c7ede37da703e895d3822e2535f76730e662570c59af83b95543df3295acd7057ffb871b943be8188fbd4979c24bdac8bea97af0d7049ff4bf303e886c42f8e4f499bb69b5ff2e1639518b70a2b6297e9093123b7b455e4ecb14193e076bb297c7181131b78d22e2f0161d2939c0faebaf93fa9379c5ec829a10d5a108e847952e679f1c9f38a5828a84660cfe50b7ec77db47b8e5480819140a02ded602260fefe9c5ab2ba1581057bdb0026cb5b2ff53e5d2cb4dc532e2284f01f5d9591f2705259ee22b017f32e76a885ba8707c76904b26172c0d76f781194e65d7a11c9d7c61c7d5e86ebedf1aedf9c5d9661d5b3c035f3a9acd818f7013f4c38054a5dd1d7515b742e60c94eef88a24b9387c2954322cf1ed746b938e4117a8f1001148a96ece3950c29d3e5857845d09986f7b313a7a6b9ed1c80108dcee8ee1cb9780eb2b036ce7fd6a2e166bac819f09288a9d8cd9544779b2cb6f31e04606bf069e10a7176acdacf5c9c836b1d702f7dc10df4f5fe65a67a056be92dbe17c3c3811f1ba519c13ebd7d13b3dafcdb59d13d2d7006c040f54f161445e450d2bb118cb6cb3d8dd25803cef0f45986e49f23c86084415478facab750b513b4b90b54b17fa9f4d8a0f1af7cd3046570954a304c13eb549682d45bcbd883e7a8907e505911f85b539bf2df5a6c09dbb49770ff8737e6c1aa46e879f4f17b5dcd79a04703f26cb9d0f32559e4eecf5dea99628bf07008456dd9a6015f47159a522dca7430a5684f119ae6b1b53d77aef94bd93d39737f29ea5acfdc45024c3fd5c5982e13f3c170311057dd67298a605a65227f052272a2d0b4696b9e2529b1f2d0e37a45251df717b5a45fa7048f49661bfe96498611287dab7d9271f5f448fd786e47eb01790dcecb1a7bcd42113318447726fd866f574cfe447eaef8f960eff14381dffa2a17009a649e186ed90870a8024965871380159a2279d99d1ae1ccbf1e5c47006f7f2026557a2aae5982786341de9932dbfbe8ae086949829e94c38f73fd51db1e165590d56b7b48cb29d6898b259da096eb1791e3ff0cbb45bf899e42ae386dff3c6e31195ddf844eb6ce7360929816b67f33e80ad771864d7920ce4bd315b9366eacc93689f0ff8ab5b8051415b8e484f59cb0f617cfaca7769a411956234f83deb77cfe4ed48741ffb9648d6ac09ca0164d3b52484168d21626e97a2b3d12deffa1efb23593cf7377d8edd8613b0651faa5d12e87e3dba3fa1846c53b4c95898387c697516679a0d92199d73f8ca56c314ef7232a4b2d0c8b0a8bc0b8f2bb45e38c7541bd743d407054217580b0ff575fe59033133c96ce8ec61087cbdfa79dc6c74f16a0e465dc67ed4c7e3894e3693ab408034553de8af49e1159485990cd8631452e2c63cd925c14db32d7d209f73aee6d1374cb7ae54d5c7ae6f325b88dd0ae7f74b93f67d079f71cdd06b85785a2a7f08eb0ab40761963a3e8243cde18cba3dfc3d49d23ec21cc26bd9239d60906eba29e6052f61da51528a69220d919dbf09f359d69735cef383d0c396a352d680f8725f1273d03999c154d126ecc75c5cdeb5cedfe386794ce5f5167024d6e8876c4c3782ca1adce54d5b7775512d8df16ece22c3e0c0e00cb842f5db8e77c0a524dc2781a3b3f948cab54d3b7289e11ea2f9fe4a3c201c0e525b48c0820bed4ee045a0ea0924e17ae82ad5799546f8224b7a455afa9fbcf1cb64bc187ac5aee84c2f1b52ee57ec4da7e3dc96034170ecc17855f9e2248a948bdc98e3e36b06e0d12712372cbedbaab4af3228f508f72ecc31ce0a691ff08d08d0ed19ada2c9bf5a7d62d33e2d228c540b6c11dd63ff4df450faa269f454bf9f65e5d63a1a1753e1344530262f0fd55bf557b4c906cb87ab492b57d56f0100e9e6aa4a0a00a0dc0fd2d3d895fb4637a87c192e008812591d91958d545fe55686789e8ff5205095d726262c99e6b9835e17b179ae03c9f246e5a80fdc26287e77393fff6dda94eac42601de374302363f3c182f54d5e49b5b39c84f4fbf9c064f8b601e8a54f4ec591a7be80efa4bd508b465b3a96a829bab290ee49d79d969f4702dab4ba4a126e11e932363d92e59866526c94f9d784bd65e1effbfcb73f98681bacb4463b5493e63427f4831b46d12bc2d2e773e69e44f831564cbf81c3587a4a5310bb21725f94b927ff62e8b85ed642b0adb67e869a7a6b39733cbe9fded736830d8065fce4909f2c0a6a9556156c36dcbfb0e4df4f462efcf1abf714180da60b272840c7d88c2de5a680bbce4a22517fc047c9e75d56d4ccaf4bec40600715f590eef9a1699683c1294d48bb14ee39bf78ef5c52c3b4288b9e1020db1dcd763330c420b26324172ebf81d31c7313749d75aef6d27eaed3d70bd2734f012373cb4751625f539d3957b48abd5cdb7156b4d6f8485975b386ca86a8a1fd9140a113a2268de2c0bd0717458bc568d1e8bd4b83e02fad8c24aa6df70f7498da28a2ab4801aff7ef88f20bad014ad3fcf9ba4ffd249519933c5664ef33445e57bb550c65c7ddd402e3f537d1f5bb576c83b20c6d6f273acdba3d49cdecf30b5b26e9e516e1aa6c3d3c86cfc953af211f1f0d31a4be2d3e08df8ccf05aa7a1e9c70fe3b98918b6190542667ef8762c542b8fb28815c824d628559babf3c76d69f7ecbe1f678c73949a055fb3410015ee1a4a6851c642baaa4ad11ccabd52c748455d555a61421de15f9bf74137344370a97b820166f063221371c00ac15e78f76a77629234af07856c4500bc379a74783b54454aa97482eaf228b35c95aca1be81714c7c65704abdf521775ef4690821b8022df42b77d4ca76558543cf886a74d0dcdd9f4fd7f514f78cb3bbd1f21af4fddcde57ad296fc6037f1655c8c7f734f9f8f533a5f62e1a88faf6f169c4fd52b27b32fe0149c74428abe326fd82e4b2b5b60c13fd8e07c8fba8f5343bface46b15db64676ee913cc0dd08934cc132c647604680dbdd6e8774b02e291c9948bf5134ca6dba626c53ba0ec59ef836d3dfb16b9730b4a98421454ffb6171466b6db97e3b67636ef65600b287c711b7e3a785a58e98d136032df6911c10c8866a632b34700b83543648d4736083acd7df600ff6abac3a5658f4f14e87e3f2f06f8a590addbea9992d5af32d1c5d471d553dcf23339afafd4eaa81d280b87b66afe7826c7b063e677f91e11e0ec79d04d8dd172a7e2040df11000a68f5088158542aa05df3345c296e3eef5516de9da84bed5524d873d75f4f23a826df8b260382fcafe64e1c1d0889322acfdf6ce5381c2d30590cfcca562570284a9f662c407dc3e14583979704cb5e40e6ac1118b0839873acf61f592d4c8d89d70f79a610fdae85d417a756201bdfa05b8c334bcdf69f3550aca7b625011527099854f8f2aa883279168f79312ef713617c7ca5e611f17c13713672318bcf3c15144b0a8e3ff6112c218ecfe555c1a1c60915b1c106f965b4f6f68a6c7788298cb3fa45428f155feea0c0fe32eed3b98bf9ccddd55a687d1d5f8d0652277919515a6e3d9aa70214f117cae905f335552a36df67de56b41a04f4b7ff768a2c8eaf3316a9376553c0488124a8d4c24747f4e5ce0f26a45ef64b99c604d6a6581a128062654db510e4dd2e455558d31ac58c4deae3af5316e09ffd224206d6dbd5fa15deb433bccf22155358ffe0a68dac211f96d6b9cd27e067a428bc41a828f6292a03f43b9275059c38e34142ce5a7c9e9f2e15c34cee9d9c87486ac195ca5ab6202afbf66f5c6dba1ec9b3f7f956d49d23d50fd947c8b5da46383c4b8de2a0f08a12bc7f77982c14c120d026600bc32b3fd53418508cfc8a52b73de0c74dcf345229f365b80144149c9bf6954136ba05cecdddf9b95c8558d6ce2be10703350d847d32e976f60b49315625416c9a94f93ac351f937f0a14e7dbf2232853874a2919db483e520f2bef1f700bc9c190b4bf07808086787afe73ca098981c7c2f3b352b4579d50c8556982bb59c3940dc806b237d6ce4b67a896132e31a5e6718b487c71c76d015696be3be26b142086fb8ffb9f8a4298ca865dde088cea63d45550239a2ca90d3dfaf1f2598052b6752d237a1f789b8fc716d8d88ec5c374b8dd2f4814fddf7dd54f07a0fb832058e3f727ee05eb68589e771a1a47193f7ac68732436b1a8e435cd7764367f545dfd50ff208e72baab8fa029ce1292030ff945a84c67616748b4c8a5c942751f4589dd947a512ded14622037176a4b2b1845671886df529853e7ec2361cdb8a4f742076a4c594a08c12c65e94424d509e1cb787ef1aa56e7ae840139faeefe0ea3f4a1c79d93219d2219852c58f02a1d64c29518790be455d52a4efd19658220906e0dce95f9a9615d17d653ae149ff6f83112a8a0c30d4e448f3945ac86ee13fc0aa59dbe39aed684017e7ee6837ea590588a92f03f3f5c1d205bd4007367d99a9b501e1bc1f6d58f883197339261295f21cd185888eb13cb8a3a187713bcc120d6e3964fce2ebb135f01e80c94794a4df869391b89d97d8ac7d4c6d6ac104b6ca2c126499987ea46c03ee17c73be7d4a8cb17dc3cda5df87e853869e22a8bfe4e2a5f7f5a1ef3cf7fb9e8873c5a474fca90fc6add26e3b00abd528a3373d340ea57de716f707898eaece3187fd93dda78e1ce449915df710b3d58c956a6b3dbe832bfed0be75ac53c33d6c7fcb3bf342beec274d765d799eeb8b2e900215f020d069b1ba0ce99707784be1f4956829be50474b925b6ea8be111b507d7b12f90353f3de91ea7de518c1e577f9d1c8b314f10159d777712621ce9db8feac6d2da8112dd0fec5f2a6eeb1e766c0214cbdebe0c9c3df29befb5e5ee2066612aa218595343c9925fb17f8a1cb08f7cf5d85ee1b42289a7f16f42ca2afdc8552a2c5d003a6342287932fc7ea2d0207119c4ae7675c4138d13580339a309d5102be0ce6ff7af74a12752ca512692140821c37cd3c0dfd41ee3e31acb01836590ca568d43668baf55bf543248e7229815205cf061a89fcc55d27136703800171189f9fba0be1dab3892824a851cb9041f72cf7864e245cdee453a0dc1f06eb64462706368ec0d9424a667b39ce0203e4c816f257d4d9861a552d9151c33715c11366ce63d3d081e8f4f1daf06f4419b8e56ad0d004553a9ad3f27afa03d1a579121045543bed522c7f16ce2bdb0d53bc9864b431905fcd483f9d87953a7c6aef3cb00e8965810ea89f9e3cc7c8be9a69bdf0d91446561206d0724f6a4fcbfb694873af5c1c0e6f89dfd342643fbea4c9ad5c6bea911640d084a5f1bfd0e2301886f6b07fa61f0571b03c16a388da4e0ee7a23cd4acd29a371a7976cce24e5068d29b94089e465b5fa74f00a9a7bc80a189b54a4c2e74d1994314a136c448236c4cd4262c7dc211ccdafbf7faf5c1037f83ea56221787c81a974e7759769415e63f1007d89655fb6ea1a42fc6a759b055178b6e84535ffab73d0d18d1b12cb81d0c1f7615c50b5d706349ec4215d5078437e097337a8d4c16471cd4bff205180af403068c5658856a8919b41735dea4bda36b753fea68dfeec81ec3bd6f3c61c0b75a5650076dcb6c299a6baecffc3e29c249d76c71726cc8e56dc08d4153215fb82a48d66fb01a5101a5ddf29231ae3a593bc51daebe2db0ffb207190e572b1ab6d0ceaa003bc2d89c559035dd1caef7ab6a04c8d278c477868e0c9fe7f248b7d442cf9a5aaf9aa00d713bb70d3f974b61a5f75692c7954b086bb11881920633316dfab9b7d56ddc89e2a0394384ac5f92e4ea54750ab349cf944f2d92d9a08953985c2a5f63cf9ba297adf7f8798514f432eec7f40e394edeee75485cbd083e1a27aa9092b966807b81cbcff11b87401749e506abebf7beeff140afcfdc4f577a5c1d9a5e063c602e058104fc608ee01f9fd38eff4a056a0a03adcf8cff090a6b1cd3215531bae654e5f42977d06c63fc3bb81c1fff88753e47e90db7bebdb3bce954bbcdc2de99f8ae1ef42cc0955cbae0c4c38e1e6ae8669d16cbb134407ea6e83d9b218089efde09a00f9b5dc349969677d82744760133852dab04a449dec429fd4b0fce825a801bf4c937635b419d979c5ec1a643d81710390f363338f064d4dad070049ad081f5bce74a2f7b2bbe0453f9467a6eefd90d462e73d8b6f5d01a90d20657f215fd9d5effb6fad1dd2dba1de1e1765fb3149c1958ad307cb176bd33711452549854dc4e900688bd914f456d954c3deeb9ae59d110eaea5cee0d43babb6cf66293298ba39e83e8cd5e9c4e84d5a7702616a1bc1e277316b9f5ba0c44910f671ae0884f7f40ee56904041a9e1146a41562bc24cf0b061cfd871b4f19b622ec53dafd7eabecb562bac8194f7ba2d4c05d8f704c707980bb500c8fa2e9a5c455afe58263d8197ce0f864ac7af3b5ca1991926d68fa41e0fae664fbc4fff9182136f4ef04f3b60f095a70028ad601393e1ebc492d8cd1f2681efa0a754367bbb73225cdea6c2f8c82a23b47a09792a044e9f3d77b1a3cc1df40ceca555ece0df6467c4c6738047e7b75c96e081b42ab32793e7b151718399dfbd5f1d6435aafd0412088d3a0f053c1fe227f271a5fdb5917563dfa76bb5ee13bf8017a0259a32d2ec91a26dc2faa974db582d7335f3eb315ab63f3eb98b9a83e7c07a413df95d36e801abd9dd4183adf163cbabfea8ab0dde03329321098d2ce3c857bfee37b45c9d6d7e8d06318e0d08e0f5d6128a4d5a715ce269499682a23cc5e2d8e312a765ed512258f8c2e431c7d51fc80fb8171144c68262985e64ae59682afb7450bf6e791d4ff65db1af6a2f85c566b4c46d97a6779dffff0b328664ebab0c292da4ce12f1bf8439b778968ab7972fc12a496748d838e00257bb02c5f535c4acceed65a59ba151a1a595d1f79481bd5f58a82d77aab39d9eeb9da6cc2dbc2aa78d4244ccde274af7ff9fb4ccb64b2cb4bccf1757b8939a5e40d9adaf364660dea90b40733547d2ae54b8e3b6e8cd92bddc099a256d33482127be3fa23a84759babbffc1e68be59175e563f9e352a50d37a01edf6493b38e1f8fe5af78fcf4a481544b630a286e20ce975e9bf366804bb0e39671d697e0800acd2bdc5decf4b22638c6351df1ac7b99ee851217f645f00da80347db8360984069e38a76b73b09708f14b80b683eb3b030f50cb321b234a4a185a783f054286b1bbb980ae95f737767f2049dba9f8c7448f9167839f701826e342dedc503ea796cd4d043a86bbb8a0b9cd93a24a6a555cf972281682ca71a457f221c7270a84c274d080ad046a8aabafc857a54f73ee6f35185ce92612faa79db4e902cdc644e72e4d54d6c71d31e7db27809394df0db7fe7851cd2e1b7e0ee96468390a5c5cdef9ab971657faa30e30d999669deb658c21a8b8c086a3af2c29d39abdfce4b30fa171cb48a7ec5c6b181fa2f04f6fe1153dc4eb500851af20a0fde34e835c83ad7895bf68b0554a95e64511630dbd8fb391897131a8051a604860d851100117b3d88c97ba85bd418ed5dfcaac24073aa98ec320eb576e13f7725cd10761f47a66d3022b731edad7e30c4616c758af501f699b566b30b850c5777a6e72de23f082886803835a4ad97fee2c646401de63a38d47f36650d257cf45392862b54a146a33343323c0346381785366d8258dff963a0860a652f2cb534c3788e479f72eb8834c05449b1f011a0d31f3186886c4b1847a517600ad1403ae28c32186b488d5f01ad753be5377580bcdf0e8f0e0f2ca8473be9c9306fccbcb37c33d2d15b4fd69c79c9e603e83d7f2d9caf7ece0e7938bc08b96545145cb68a2ee7d0dbd4f93e526463cf040211a969baa0139e8c2b8dc2f0bdbf4ff9b325657f23b428371bcf0ed01879ee7e7c76161ccc7adf24f3441bc5fed7a9d4c5c85b06ec307c4e6fb56fc053e876d57f740a40283e60c067358b076054e669e71464a2764c14a5f3b7c990cc6a536aae49aa851cd7270e4ee4d2bd5d7f96ffb2df9020c8384b4ba3b54f297442a878d13246967537c6e699d33da6fec2dbff52793f0ef00128bcc29991099c093340648f6a0d4f812ef7ade42f3a5035d746b39bdd7f1cd666b418d00fbc12ce74812436e9195929d1ad37f544d86cd75cc7f4fe2b13f65c7326239a787853d6f278ed036f090925406949cbbb2c8d9d4d64eb49b8349cb3560b466eacbd50e1bcdd75aa9338b7c8206de41d982ae0ea618f0da41b4bf42b463000805e58b441c3a2e9104ed75d941d39556eb5d96c7300d98523cf0879a44fc9eb957aba9c5c533275aa83033ef3a20290623a869d74d1024be383c15d94466355fc4fd589a7c3e9d00b5f427ed186e182002c57133f2ef11a1423d8189ef30ec55e34e46f163aa6ed2a85b4b6e7782c0cf52049309fc4d12aa8e760a6a848cdca273c56e5b61b68aa0121dd646e3ffb5a7b5ec6adb3fcfa832e09696849e1844fdb63395b93afed917100c3fc4af408dcadd665ad2e51809afab45b265158fff398fddcb008bc2a7450df63117f648f4527453e140ff158c7234587c91349da4360cfb0b4fe23e321f0ea9b78406569145ab1f4b1c3c6820dfc09c445d95a58cb8ed79ac8bf06ef355313ffdb423f79488b06da61597570fbc87b05647e29f401db3ee8969aac4a35d5bdf754cfd2d548933614a45101827d85415f994507648ab424a8aa09f0e51fd5112b58be2ea51e9557a88fb9293574d23d2926e9cf73cd750d6bab9ce8025426a3123cfafe98cfb10b8a34ff5401a26cee1a22a876bdaa390fd784dda87a56762efa639d3c2c302ed756cd2e6cad809a56653732ebbdb08e2a0031021a7b9adb1aeccba4236eb78a2bc81e65a3f492c40b9ab74cf3647e8131d3b2075b856bf6776e396acb85eb475d76983ae3e0f14324a3e782a3283e957d1c116d7460e9333071766efb4409c0ba5dd2d1419fc339c733ac0e80da1f7ac8a5d6e1002676d0f4e096cdcfd08f1df6bf207d30f0ca259b6982dac6a509714be28a17e2b838b06005e0b8389138a79bcee11f645eb85d67f317013a31f0e174b7d7e3d734b336b91c75ba1eaa0505136c3e6d9300e9f3cdc6b9b7c01bf241053410a6c246a55d0c836d9c551accc8ec3c3f2896c43407360fb3caa8365b300a90056b6243bbddb8c26e5773d8cdaef7dd11f1356c15f68e8220f0fc539c05612292921edcee25c31832f6192334cd4a9860f69926bbc51a9e66e94e4d41d855fa6cb68ab8519af0becaa9f81573315c1a95f79a8196287bbecef142ea6962d529d22a567de5afddd73dea94adb5a84c616dfcb5b1c1dd54d0b718a3e2aeeeeecbf255dbeb6204d224157d3f77670b86eb2915e9076eeea66ad32ac7e6388949fd1f4db34bb6ddcecd1eea76946caa1015589ded62f131cbfcad25e6ad313fcdf4f1d026fbb3a6b07bd5e170b056508df9d018e3b292953213d968906e897ca84ef941085da735ef1573be45f9d459428d2294de441bb413866f7785656198d99224cfe482bd651a2979c807a05d54efcb4cfc9709af3a3bb0543f1440552cc2c06010924c5e239c90170fe3de29d7dcdead18112175879c1bcef220b65ff0ea3cc8cf385c980c3a5af90ce7c997c2761f24fbaf3b4ef9b958aa4855f77168b29c6577402db568dc4df3b2554a120f15e9dd107a28ae8803b3f20309276106eedc670fd28f3c3d443021fbcfed9f72cf9b29b798db79f9b1be2c47f1a6c937aa1fb598d37125dc59a57529e286830c67e9937ad6ce8dd36dbc32e0fa995f3f4d37c2b02f0dcc0c81a916d71e09e1fb521ea350aa0d54394bfbbaaaa0fa7b62536068b2dd767d63975fa0cbb351d69db5c28b98c31c2f49f27caea263c91b946e1b6e92153007e76432e5c9d02160345e671c8afb49a72bdd38e186556131ac6886d2e3d6a6981950a083310c2f30d49ef3b18197608eb54399c491fb35514bfe3004d65e17efbbc8c33b32ba8d95e557df0e3d15ae770eda3a69fcf0575419e8ac83eb0065060ad045f79db7f28c72dc34f111e30e4afa2b357fc7b583d9585a6001b196c8e977e75bc87a6fc06503aa630cb8cb8995743133ce4ed4895dfe11446f458b425fd48f89408251167d6b0aa5f67b4319bf2869257feb795f3994915955100467be250b99913f673694854e1cb080cb5daa18ad18a0189334ab32267dd2d5a242f9c125fa7f31f6a5d2ad5a19d61af1f0a99cc0046f68090ab6a10e7a5bf6fc77f3724f0c0709a4d4453fbed0d1fcffa32715addc41d31ddb0341f3ad4bea59e7c7d49512555bc36f896317c92719efd72d1cbb5280d3be4589353a237b78f8d9faa6b27feb51edea0f584c2ffcfed8387d9cb258a99fb069e13d2be3d11b1060b5b9099fc830808fc12e6654c16c78bbedcc533c5bc73be252ff6a983d70deb54d4b7cf5584560c3ed7336b9882ad155991ddf860f133bfd1fab1d927f0b54cad947d36929b8c36e7f17a2378c976b3da277d6c8efa3d2bc4034de3fab778a9a4446bae2df3e169de878e3db8903211d21038285be94135d0f31ea41e54facf8de9b0c5cf9fc9d5506aef473b12a29613aeaa3baae2a137a1acd262c28a05be54bbabf2ba41b3a8b8bcdca222978f27e75d969bcc15a5e32129b2dd5842914e38880d3ae91626218e0a978dbeb6b0147f268645ae13e3691d89ced4e3bb718b5083fc186c90fec15286d1d1cf310f557d73fa1de29009c45a6740f94ee1d4fed10b51c131008e7a005d409e2a6e7fa85e865e27babb8f422c4c46c0d19b86fd6fed67cb731969ed8b12afa73f98a34908d8fba674e1a1b84e686d196a00f4182da3eea0c22b9de3dcd947e7ee97e3ac971256e541cef5db8cee1c79f96ee8eb4eace2f964b5903f150238feff7f3461adbe59ca03e36054f9dfdbbe1924aa8bdfe7bece1da1aed3954c397073282f9515a89c3aedcd8810b6bec0b267c63a101bc498cb41faba32345fa6e90acfcae574f859bec04cb4ac6968b36abf8695530666bc67114a752dd11311c573dc70867a09b593782208be69bc5c3f1c685870b7deafef8ae8e5e8cdda1b189cf844f5e79a5aaa9da1706586357aed4100e4509e2f0ed7f20db3d68bcdfbcd4aedce4936f6ae0a85e39b41b2cbb4809696884138390768378f882e04a03d77008cf6b5d140fb34fb49d829c6e7aeb93ed940147c9d32675c8f702437d92bc59fb0e40ffb710698da427c000ee8f5d95cff84a999f592e40dd0ab3cf6923c76ea781ca29c8e85328f79c724729478eb64001e1e302e420231450c7761955e3db499cd2543a17e519b4c8f9b90232287cedd29ff21ce420d69ad48108d5283dd0cbc59a84e1b203fc88a6bb27516050ef73ce67c9369fb4abe599f79adc34f265c91c99e09ac3a15c6071b7fee6b882f2bf98c301d61049ffbe5aa6ff251e48cd1e3d07fed32dc17c9b40bda315a94aae7b8409ef61985cc264fec630deffbebc0c5cf8bbb47bfd3d641d4e47641366622afb8b1f35df8c69371c3e0c60543b89a3ca29ee440a0aefe5e2d0bb207a4770307c6dc8dd9a7199d7913697eee9f3c810fa6cff24eb78a39cd76ff93ac5570e980674e7974d3f69d168107a0111c64d9b7ec32a8060d17893caca13926ca450d9899bb3c5b71860ff892c30c1d60febd3d3c33978036a8db7295a24c841558af70142df7a7b7f639b8f09f1f888a5d863893a54543089d648f39ebe1f6a6df09bf20ac8c68f7dc8ed04ef6770e58d368849bd1d524b8fdfe60d5c00f5eb319cba9016327252ca42e19ad11d7b1113973d1701ecabb07830e008bd9b56d0586bd405ead6a41a4f93fcdaf63e9299605a181b7c1aed472b4a820bcd06d76698eeb8b4fc4300524bee992e48c2b865e2e2b2e8a7e654d0ef801c3a12b649556ce9ca30ddcdc89004fa22e2d3d40ada69ee4f2299cb8b7323acf043363b0e7d36037e8bf9b18d39059ed2e55e46cdaf2792077af90c4b91ef4b4249cfba04372bb9f33a6be9bf229e59a480f7dd61db947daddf7fd4385e7a158cb39f949c73b7d9a2f1dbf99a942f48e009e31b1b0db5283ab70430cdd58952faf7513570cdfb800a8da7633aafd7cff307e9e08a1ef39b7d83cfdd6e6ee225af58a9f3a7d13529550f0a2f28de7b3b8dcbb32a2ca6e750ff946640f4526880ab5ca579a24eb30c9d26aad841afc87ccba653399ccf6cdbcef4be501e7b15b18301dfea0fa6f0a47a4f49acca9b87efaf33404b4c8bc91681ff5b4907f2065686504dcd96d49e5bd835d3d33f8c88618b4c6d164f90bfff30301c8d4b8c1ecb4ff3656436e021a50d4b72f9b09f532c09f510bca6fb4993aed88646dfcb3f683d3e354219754ed1f08a04592360792c57b29f0d916c609fed789012f81bc1253b0147f7b1aafbc933ccebd9d36a183ebb2e947112684c7a860fbb81dfe01fab7a939aeb7a564d4c85aecc61a428c6431742c82c7d2061f877f73313e9bbe059c7695ea2f898ed19000dc4e8ebc321d96ac1810ae9bfc502c31ee964bc8252fa630ab4bd35242e30ea7fac26707188ca5abdae73f9e5ce5a37865d3fe6c214d3db03cdf3558529ac1d4191aad1685ef98b386c790431bce97505a6dbcf72b1cb165db0cd83bddaa7d424a72ac4e01b50dc38aa2ddd0a602750b60db3d6ee457a41e00cdb99beb8516adbbc46e9494871a3e88937fb05cdb0ede63358c7118f300143b84e2ec6d3bc32cca7e8ed81f09311","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
