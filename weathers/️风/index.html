<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eaa108c7784fcdfeab5ace5dba1a4e5803aeaeb0006b6265aee2bf3a44fd2a7db6d0d49d9b981cfff9b8e0be66e80618cd4482458d4c92e7c277a31d4a31d2720eb15f20de419c1c52f84013f4f32426fa11274cd817440af509e64928d5315df8ea42b120cb17433ce6252e142ba49769a64482a554f55c311a5ffd4778315272307f374077dd3a4988fb36991c1f79a72403530c2f2b7ce4582264bc39705db642d48d005239558a6d515edfeeed40bf0f00a59e4276e1d0ac81b3ec56c23825512af76479a61cd4f86667262049f6608b30b44ac414a66cdd493e7e3bd1883a8e0c34aa0f74224c8acf9c321c63690c616c8894cd781d88583f791273895e2fde7460b58dbeb5e20a206423e7a4e57e4bd7e17552f1f17c8e1a91b9c0f2d0421ea7f563115de877f10a3a081771b555f74795de49d818c3ccab57e472624dce52d42344ce1d6a19c6970e0ca6e624edd00637112bcc9b69f634ea35b6b8aa0f15191f8040cadcd0455059c1ff2ecf2e8e3e24a1d1a61212df50ef39bf98f73689d67cca7493505aa699a04f381aee5ab88d89fa79b10a42242ff219874e82dd28ad2439621f2002be84ef9b3b3599cf9eca46bfa2db5135d440ee3632ae6445f90149094d10865f5283d942b21f40e417ff46c4ec8761547113c3ba90ee62e7f94920e95b36c714c5519f1376448265a4728d5f005577c34eb9b624aa496a0a90ddc2bc3444fe27c4a59c634e4e566e5dc66bd1d591d8a6424efa97524738de127ef9dc25912bea568d911d10270f7a64f9c2511e19818654156fe4c67b420993395baa69d0c2536e9d949a4568b978c295feb2e3773d7225bba6e6939abd685484b7c53e0744bc6355783acb232a8ee112288cc14db041e4a9ed70eccbb7f4daa85fd5cd20b1d42b85322943a956b59cfbd33d3bc4e8999a80c8808f58ac851f2490e4ac82c71a2eb6831cf15b8f1dcfc90101a8e8940a16939e76af4aca50ba0650a9de382bd6c7081a664b998127e2feb60e4a14c4cacdaa3798f4f0df812128b9f622b1e980d35e30f71cc212ed703e083fc394ba497ca15f8e7b52b26b27704724d268543600e04e2549be0e7e4cd2a4ce9a22fa6c55222baa81dc3056e0db96b8998b293fc8eb843753215f22fc02512ef005241d94d5875733f700504ded6678dfb1a8e63a3e25e1488f608cddcf03d86d25b865960b320d470bdc2f66a770ca132b6195aebf8297ddf2814c163db43602f3bebf59c5cd40e225a3da93c2e703f46ed63b1478c1621bb919316cc9a21a6bed021973595cb5ebf983db309d55873f0fe10378269493b71a631a3b2d9217ce505d7f1156d4667686350860fb386f8a72328dcbd10b04b7d8ffdff4dd7444d786a2f1e868cc8b56099c25820f9b3bd37c9f0bd6a6ea35c96bddde5988968ba3fdc65412d126b48bad0292e7d1d2de98c9e9b5ffaf982ea2c2e46295433f403879e2406f338f949529bc93070238ac3412990405c0611e2880464ba9d40e027b6da92b1a9281eb39cde6d0fac83bc0f2a04cbcfdfcdc1142bcaf13020784ea74f1534baae66680921477a963f82a671fb82f3bce8fb4f6a9094d0426f3ea0fd20eed872bf9c3b70c824eee00871dfae40fe3bcbc3275d32d1d1c20ffff691975b7b0005d0aac763721631de71ad8bb5717f45ea00a972e639824c1bc64cbb66fed38a8af22503ed14b1486c55dda62fe96b444687c09b3d3e4c67cd82597e3cc3f1c71fec8d5049a1a533ca3c9673d78ac5554395fb92a8c9b078a9582b1d775b34a988aae33ca653c170325a7d7b608776fd4cc9d47d2dbe077cad22b84acd3597181b53571846f11a31af6171a5d4b77c516f5d70e33512dd796acc0f43d8ba4e7e1fcfc9b703d51e1652bad9671cb1bd541882b9a095f1711f0b4d56238eca085ed6149f5b0265a5f9417895baee69203bb92dfe14c55db7f90a3e58e552a70a2d1031ac70ceb3c369c96933736a8fc73b4a6abe51b15e76ff9871309ab4a39b48bbdfbfde0a9e57c1cdb569fd30c053481c1a728cc871a0e304df1a236323c6c8a95377f8a0825bb54763e9301396bbfb78a73629eb39c3e9cb87757de3150f9473b83bce1820a377ae5454459f8003286efce5e81e0e059d26be76e83bcf96449a1bc07ff55d5ac9a99efe4c17d73264472db6a2d9c5d205ec9dbd236a0340c83b2748f7e9dd6f509302b1d4709f043cf64d0a96d5a6d4973ac1410b3c88fa91805e51d6eaa1ac8f4d8dd1b6aeedf186b5823a891f85f3e17bef47d9182d8d429e32402fc9c48cd989139b9f429308592a4e6d12100f3a3c576cdffa2095123fd5dfa1e1d60f3d8a39d501799dce05262f8f42e9803db37106101f7c9109bb8e00a8926641cf007736d5c301d050865ddccbd20772428de67def0b40b6e925db8a69ce351c02446533e1aa4e14c6220f549f6e2e8b1800b96f3ca20b36464bbf65eaaef299fcefc6f00e26ea94c480a01f7da589213f733adee059e62c362c7c1c9db7b493a887fc40e2b3bfdbbad9312c8da363d1afff3653d8a5c12e14e0ffa084e4940f24e1d127d38118a49407befe50da1e91a38be84a7e6a799d2f255109fa0a68a68ebf3ca59f1a056a6a7635ea74209b1a45e2072e5d6bc77922282405f2555fc3e4a29b04285f1d12200eb24034f5ff8b4c81bcb1b8121c9a73f129f4f7744b6c267efd77de51997232bd6744d0f4bf93ed27cb67d722cd9425f523d8ee79ed0cdca06a32e745f48f0dc2f084e4a0fd314a9e31a1cd178ae0e48eae33c2bb2f227d48b2f34565f88e071c15bd8f7ab92760c7d8825d072a6020c76705f2147bdab97196356635c52fbf232db2989cae81d41513fcdcca68518e4cc38a6a6152989c9d0e9ba89918463071df77a7fa484a2b51287e57c4c6d23b46f56c8538fe9986ffba046bfbd9276832e019055dabf434b3edd91d694e9ff821288661b3d5f2bcb13f3b48d683734e0ffc6a04f8f9a8953fd71bbf80b14d38feede5651186d28bf896341b54242e4befe70fc4f8f05c95865fb407d40aeeff87329e822233ba2b08bca028eef7cf50ffe47b57938a9d16a8ddccc63a7c8ae4a1bcba1ce7a9e10f737d3c9b18e84678f267088a1fded4d9d1c416c86b766456e5e1ce76006cc1f093d6a2d43c6eade2c790bdeb6a2d15effad4d8e88aac8dd9564484b90c9fe6ac4c6b514bbe0c89463109068e52fa551c380c3b162629dfd67cec6b5f5c0e36c75b3888aed9a0dbcac2b4514f59fe31d1b0c7d49fec3d6b815f9d19a9e2ac1f1cd9566fb7a1e8101ac84b4f27e7c894c84b14adb7d81bd348bc389e4452566ee047d690eb479bc0f6df927b359323246d2623ab46312e1bee8cf18247f55664cedd0f13ded25f8a9ddf5723756377387ed5782e8419438deeb40c70ea91f983e742137fa36d4f5d0986da8cad7c92644c7b2849b15bdd290eb9b64b445d1306f92a3d925ec436df5ef7681bf61ee94dac5d8c058bf3a7037dc354ca9be8245d97e8175f3f7224810a7fd0181cad283b6637bf58572d194e172c533a10d1b294ec5b2881fcc879d9575de200b695a5d26e234b2e7c9fdc6440d480876d14b7c17028953d25dd60424a82ddc5b23a5deecb2b30c44f92a488456fbe62793b136493efba55844dc2f941b772111b07a11e2b2d02f99c049d61e4e143565317e743c6d548f7571935a6f50754be4f01b7c3e662c4325cdbbb9b975c05644a08b1342b497388fadbb9427d4c0f06946b6449b5d8678df15b3b53f80eec446eec75f501c4616d605f10f1515584e2557a9d351329b75807c65249779a45484c69f4ed7c0e3e165526281de2ee2d7cafd4c2487ba187faebb2add23ba6f716ccd35bc93dcf03acd406dbb5d0a65202d4cabf51b5d390fec11c7249f680bf2daf52ee28b50c51e63153634f13c3af3d31856af1d5a37942d6241c6d4eeca7a061e81412d53a6c9f2a5e13e2e59f9c1c84f0c7a48b6fe3757da45a2066540f818b17724d358300230b6c4ac6a1ee217088da699b06442a9854405c45aa6d650af487a1b960011a9417a8bb90385c55abf96a9688c512e48d70aa21124bfa795f22f6ecf26b258317e1d0eb6054f7b44a9ee8944f61c7eea03dc07304f75d11c17b759a2ff8df0b8cc65b5056490f0477ee3fdbf7b5a068a37d73897a5b1231281028da86363eae01aec9147c9f2c4300c4500cbc01695ff842399ef5cee944090cbca65c409ed2027bf1283a24c07780dcd54162613c69724cb4c2191513bd0a488416adff786bdfca5e00049a85f476bc59533243a203da00728bf78e482fd59111a43dac350b149faf96bbe786d4a4db3422d9787a412a91a1522bd6ab2ac531efe9621e01ff182d9b4e3af9990ba38595d113c95d39c6f4ed5d46e5c3c68d0c5fb789777c958ec295ced96f538545b3c4287631fcdf2c943b2fa870da13a01b74eb38147e425d31b6790431dc6d5e67c64678a1be8a6c369bafa8e25096d7e6eb379306013ade3e4fb0c02f17ed953badbbc9a63fa5ba41aa403b1d16361a8d6e82fcc7caf5334e846a6424537b8e1b4401739605cf83641865e2b99230c1e901c8d1cc21cb6efa2975f1afbff44e4f1e34f4922f06a2f83dba98d52413c17cdf6365d0163dc8161cdc34e4dc8830f0689f2fce6b4e717c035429190cf9cc676444d1796ab82ea89af24bd1c2cd74a64687b9ebf6ea3e98d7fd80207d6fef830e7ad129263e1ae7a86f87b0132a1fb049fbb008f82d3ae7afaee237337bd690f9745d8ee74fe16de8452eb29d2465af6f63c71e5e3b7ce21b0dbd4e45fcef20bb37f01f333a53ebf93d26389e0a11099e134de313f7ecfd766184a05917d9dadb38671abd96091556471c65f440f57f46773adf4904e4a34ba6a4d2be0ddc67ae9f57c028098fb5ac509b69c9d7fd0cc623437c849b110abe448c6a3a004db3fb0daeb0af6f2219ac2ef147c81197ce64a2bfbc1c7b7da2d2d7e1f9fed4d3abd1718d1f5edc7bcddc426762d2946ebe50d53bdb8423bdf3614fe54861b34804db55ec1a853d508723fb78fcc2f92a0eec4470440523bfe95e174c73718175e012851d154b19ab9cf0d7cd459b3da678bf0ef5cff4b2133d3dd8c89d8252334a89e6c2f082d41912b09261cb1c2b461ef48756e101d7851958c1151edef257a97d44f1b796040779c883ee694353581c1cc420c35d1649398e0d3b027554d74301ad2f46f5a97166473e7877af1b3f652b333b76a40e5b4b973ef2248e3fc506b4402882a75bd4246a0b41b08cb88da2fa05076c8fd8395ac7be7029f204dcfa388fb8e51fc613a41799bfb14dbd8c8a8d99531170bec080f2dcb93e1e86681d98a4409c3e1e762a4b5ee10442596abc6414453db1a87f073dcdda152c4ed79a8725dee97c1a90ebf595e30a20f6390bfba197b1c0f0eed44de258a50bbaa6a8ef62b2a3b774f32ca51a531a877461ab4bc43b270ed012a295f7b44534ff4ea14ee0319613de4e32aa42ca15d4f586edcc03d01654d636775ea561ad57baeb38ca12cf2d1dbc313c5e94d9dd4e1fddf687bcc7eaeb8f93585a5ac4862744a6505d39c6783e023767734b9659e9c20476ff09e900ebc1ebd72d354444be691dca054e57f4a2ef2e0971cd96a5405f86f1d91ed40ad088c61f1d613e6c74ea955379bb6266f0c494f42469a2a18fe1fab65cf2d094012a075795cc9936bf7280c8dda96733a4012b20d1b71b19e1b97bd0dc9320055e132d6a498cde99e5cab765de4ec61506882392822979fb82e39d33c1e0cbe39fd7049bc9493d6f3943e86de71f43dc4e5deea9d2da2d883e7acd22ba2b6316caa853978492b31fac649e9f26ae483e3a64a90198937d74d48ef73cb71753f577ac9a37d899f08d691c446c58b6069da2bbd1ea88fa3d8966e2affb182f3b227c6efab512e2b0bda844c67645d42296415df9969021b86a50161ce99752598386203c9f73c91c91ca73d49b86bc3a11565d8adf8deae4c8aba6eea0ef711a433181690faca5e2d22711db976165bbd51e3339ad48d3c4d5d196753dc7ca1ae445be567f38a86e72f097a1151caa766a8ae93f8a222dcdd9da4e5fcdc4c15254aee47bb728bdf680d6f67f641e845bae0894910f6915dc4bccc97e7e5a19c80cbd941b30c39306eb8c9b49d3f6df0a8e9ccb9f6d7bb2a3bcc13e7f600c9345a754d0f337965a840cb7f7190a014955b960984bd0e9a2b6d79edf21997f39519637f512923e88ee7a9f9d0a1dff024654bf16ee54dc1759c1d5769faa8e07c5502eb77015d55402dddf9303ea4aa521949098fb23dfda90a91586811efb953cfce7970e1587fb7b5338d23dd2b5b21d4e72fd01bbee6baca4708bda3905c965a7b353ef74ea89cff4a1fe4293cf8585df2cdd6806776f1a48bb36c5e5b1ff6a5f7ced04b96b75ec73ad02d8bad94489b033d7770c607825b6f09214f1ad6a2d16ba02eb417a5e57a87eda0842ce249b78b61192b8821b5d1ac8c2fb9db1a489b65b0a13af1db5ee05c2d823620d51f1f899e5439a8df78d3f2db05d7334b112d13e759b620e25102cd46795a11eef79d25e3caa21ace8a20421b30b853ec7252acc3fbaaa192f1bb2c5a057aa2e69a107a6c9c709a889e824f9300deaceaba04bbb923885b76b8e43c9dd409932b9358b485dc0ee8adb49f775c6317add12e1402f6bf90c5773935874855d0b8fd00c168955dec9641f09c0cf4a84e8023fbfba7df740ebb783c13ef1c5d27bc331b53182890155b3cce75bd215c19a4e11106be1c3912afdf93f296b18b0aaaf44fe2ddf139fc5143187e39a6a771bf6c5d33f9cfff682a35e1ea91656823c923fe40d2e262242761fb09467a90c07431b8f7f22bea886487f58e0904b39980588226558b471749507dff54e9cd8f85641d09b9c98cc8765d3042373759a25040318e4ded260dea70b941e4e05a7f5e97ae1225a323c3e1e02e10e76e60a5c5b21c01087cb3dcfa2d44b1abb1f650bf9737e50806955ba1cb4d80123695c0509f885ea2debf4c1de5b5fc3d74cf3be4f11b9356f83a1eedda9fef2b728a2c7ec466b55673e6de9b483894d3c84c543a3762907db6b623a5188344cfbcdadac8fcfb5da18dea30670546d8a26ec57cac4def6c5d7503db3b852538a8b7c33577e755eb2a2f3226f3a5f3ad084a9054a44bd590a1c644d9bf1f9838dc9fcec4a9b8460f4d595f9b39571bbbb01ce8b1b51b9cc0c50d073bd802457a6c12fabb2e96bdfe39343cccbf430d1709d99897fbc87b34b2d0db239a635a9a70e39c85af24b0bcd2aa6ab74feef843e894fbcc8a66e1d22ff20ff353db097cf53987c66ea7512e04a602d8a5b759efd35ddde8a0313bc7a99e4d1f353cbd1cc6aaa7d15177c625b793f6beaeecd1ff28e42ec2ad7fcaef1570e2e1bd4aa84a8c2b1cc72865010e57a0636c328981ebd63006c431b1d79afcacd53cd2d2ef079002e9c098a542a2ebd5cc3e535c35084cc2881ee59f3d55005d9f049dbb28b63ad217f23dc9d0553f9fa70caa227e7b7506e3f5df8010886d46eafcf74e88759ac6210300a085b5f10d2a80ceb58132f57ed72d4b89ce3aff718eeba57dc79eb058cfb88b616ce77c55297abc61e05e6f766fd4a643c417174f2cfd7d38911d4388157dc981a22552ab1bd86185ecb34a0f1d078855d060dc8c87e5176c18a7e83197b3bb7b921e6718680283e1edb3a0e560f043b7ce409efc23d73ff873e1c9e6665cc940365f6056ab95c21d127aa23fb27aa35708b6005cc1b0f83ce8749ff0f81d4f6755fd88f213c8a4d7825a4be44f39d49e9b7569c8c8c66d3b14603365e07d7f19e72e915c53a4728f9ad20fa28819da0b2cb25df48902bc602c7b2b49f4351a4f0fa8a4c068e457e5b3609b581245edc278d2030046c57e282e4de611b1963eeb527f809c656ebaff2ca9a842093ffd7a56a67ac61544665ebc17433c7a602d4520e7661e11f7fd4976f1f16758e4d16866643d1c43744cbcf08bd966f3ff5c84bbd5ba7c75de2d447eb7a215820a788cc081810fd234cede7e6ab22f2cad6a478b6b8313ddb64d564dca30d30df3f34f0e160417e67e808cc485451b168c7259a105c78e1daf08969f7df4959e1bb3e79df06cc59607fcc9758462e2704dee80d828a352db2adda93b6cf5c16154895718a896d4c68bbeb38d13ca449a0d6bf10512225552d39bdccf8029a04709061cc5d053bc777f6c28d508b0481551deaa07e2b86d9eb2dc6a28936d189de0d9764c00826aa7509b805a4ad7cffb247a1459a0cef7fcbbe6d1f461efa15c8300e2244c005ce373b9af548f2aac3e02af72a8ac2e50b73f79f588a15ecb14e6ae5dabf26d2562c6cf9286ff98d9eeed16716e05b299f951d8990c5578a604ca0c0c3b2dc7ee24b109ad5e7733348d2258c7eb5f612e0ad606dfa3e47e00eb0cc29f662d6a83bace3891596e1c05c9be8593b964f4cba3b88314ccc3e213116cdb18e7f61bd7e874093c7f50a22aba83739f08635be8457a260a4843e29a9719df9608e1e7d56fc8f8af5d858b6ddd8ae639e78603b2feca5e0c749dee9ca8ebc97e81f2adc721ab6933ffcd1f8c83709cc8bd6ebc9a4d5d4af9e3c98cef47727e07e70902b39336e0ab34c162daf6d46c0733772fcf8fc21e343f02029541be95993e9a657ab6281c3d1f6988c02afaf071f870e0a5d0b8a73987ca59acd78ace755e098c790194f35ddf024fa1d08fa03837e123122dca384eed55c4089c97eae840cd356a6e42b5b502b9cccb978f2123cfdc75bbedb88910adf4361172f729b63d7c42594442aa4bead9dd0b410e98ebaea76c54921aed2fef1bc859e927d4efcfffb4cee51b8fa60544c70acf707b6253be3eaa8e3872b094f433594c4b3842f7a61c5a4e8d62f3ddd40db7d6e21908e92ee0fe042b05ffb2e70d95632e97d794f0e351a9c37acafb94e05eabf3b45dce37734fac0a1ac7915272a56df0b25f9f0f76a49859230c41ab22762c69f91285e717d33c0f6735981160560bdaa1501922cd76fe8d60eb9ddccd99f592f15335e0002c7671c097f798605ecf23bfa21f0e7a22e9e7d67120252ff323304757b095e10026190afc3de8b0ddddbae5dbc8af5a161245c15eca862d0cdd285676a302e26b7f0536d8dcb35d2cbab1cefe9fee8d35c64d03e6b80cbe2c5e40c6d93b5cf0e138f9cccde2f63847fc84509e950b3b5951ffe93b8120d3e4bf17d0f522e5123073ba810155c552619bd11d4e5e65b99259c61dcf954419ae6657b252c0a061da7723e6a430f097179f72afd74a8c74b9f82a7389b3d9160d14d1a7471eb66551f8cfb66eca3a7b885d3ce799ccaa1836d817c88f50a98e488ba679eeab7b46c4eecf9e7c1f4f72ae5b89663bd61d0d01398a70379594c1ce62a407d82ef764bef518b747ac51d0a6bf39c9910a685f28de05daa39fc8b440252546f57e00d4d1d3be3faa646db94c0e887d1eb98df5f59c574c8c1961cab0f02a97f7c88c118cfb546cdc55aeff102de5e95796a02d2e5b0d5de63208873b120cc51d163dd3b25d61f2576948e6124d74596fd59d2236844e952d8898cbfbc6f4006c22224da37ec85021506ab742cef3531bf1adbe645e07d19781f1277df579c858bc7d143f13dc1e66898fc9b2e3e4307c4efedcaa1a6712f26d43f8b7da914d92a37687b278ecca337e7a8c5dc3a2cd30f8f83dec43f21748f4a16768ef1841028762f5d73caf9b4d146a514413134b5b2b7e8bb306f472189781e1c9b5daa2ee93470c612bf8074078c42186a861ee6cbbd738a16b5fd1dbe868e47a3e08445be6e4904703fbfe19dba724b670d7544f7e9bf682cf5ed419b14b33f566079172df93f58289320bf47071d63c0ab2aa543cb96584bfbb99b37644ea198a0d2d179460e154f670b2123df91d88e2efb4cf1d16b236b7aee826fac43ee94668201d0e977e233c380f375a15341e2c1872b3accabcd0ce02ec682734fd1ec0b53b36550ea8575c9a288a02dc6911338355ada719331f06be78193358c6ff19b02107961572912e97a414c130ccd116556b63d75f7f46941f510e0bd89a50e05c0f4a28728cc2fc418e4804230153773788b9db4c70c7ffc343cc470abc899dd567792a466bca88a80085c6e59cc11381fee9fb818c8afbe210fc94a83f52d036c1433fcb99cde980c72d4f10cf1b7f4df7b8ee9afd2bb58922ccb5633bfe40d04e41d8b1ab10d41cc2551c6e39475d456554237aee73aa47df0f10c10a4235de1aba14152ef8325ffbf1b09d29fd125e8b3b4c3a27a3c57eaa7379b0331f00d17c45f27e7b6779a53309b910d09388f9c84c737128d3c671797cfc6c0226cc1caae4de6ba365a3f391b925140fd8314ad3b6fba7d1756720cdf83e8ae78624a36be265cb3f4926d107ae1c3fc1d816422e5754516cc729e5db3fcb97ea8975aac2e4bcf56141cbfc3b4616b6b4a683c2539d051d67b8c9686bbe3adde3a3aa1e1c621bc8a532871de543ff6d2ad7079d26655bacd0f0c5ed95aded391b644313c5d4597e4f5567863ab4921043c6786d5c713db4dfb0e7087c1bf7ddf5e164ac6780687dc3d548e6771cb774882be2cd852ba4fe556b5d9b724e071933ded71d2c57f637f3f5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
