<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7261836bc527539f7580d3b86e31b3a8700ed67cbc2d7d8226160c92f06d6dac78a940ba9487fca4745a342892c3dbccda4b8caf5c6113088c1d49539348c078efa3d87a65709d6908548ceea919971cd61172049a0ef991719ac2282f37f92d622ea4206c069116c6d35a750e8196c0bb750cdb8849b93f926b7d3b50c3efd167f7348de4ff68165e5b21a8baaf0fc30d0f9ec9abbfaf4fcbabfbcad12324668cd38acc0e8bf56664e9b621078d5142305c5ce4540db8234688b52adda25f25c255bad75d8f7bd569f3f88ae7d4985264acbf02b180564e459602a6257d1bddfce691f63327c697e9d0f76adb8f1b97e8306be3fcdb949fea16d4faf1bd60299622cec0be540d913ffb7a386269bbe0e1197b701336400ead24a9507e77d2affe52bcd8b7434056b95636652701afd6e24c67a6da6f6ec93f7387e75ccd309e550ef415d4f7064fe90a428b6ac66fee638b4fd8928e17c32c93f26516fd16648e5ae5e56402fb9b60a94afe4b658df29d3d050b59a39a4885ee3f6dbd21ef85c1d341ce27e6ecee0e3908d063d9edb24e78a30800f6b2ad69a65413cc97fd871b6e903ef8e4410779584f5622019d5da4c823211a5670c33eb90b4089a1f5f274c859e0d8eaabd95d64f0af629fda4cd09b1b4971efc7908fd83e5f03a941ed501a63820deca82dcfd83efe379fbb2c18519c4972b787e99e5470434da88875f76fb19e650eef19590773a8468a525c196bd593ca22851a448564fb24797f24ec77411afa5495f96d5103a499634ce1f20673177aeed13ea68b0652e99be7edd9c9f31623755e1ec78277a166afad48e21e076aa2de14ca258bf756b20d90d69011dbeffd3c52755035165d3a7db549b1456295450462a7778dea68953db0606b76c4f3af289a614cabd694083b1b6b45541115d3dfd61bbfefe3fcc03c74e99cfa90d7772d8566e73ce06057e969318350979ba6c2a9f397e4b550b5fe2a17e228a290f6da96d92bba3f09079d7b3174e76fa052c56737ef51fb769c0a7caa52a937dfd51d54f3e875a2df9e7b5205821f05120022a22bf8b829c5b700859cf6b5b58ddfba30bea3ecf90554d81a9cfc750c1f7a53e9d22f1452fe167ee20f4a96644aa464305c002c0daa53f6311484f696e8f972fc59998666ee5d3b6e21edd5afd6119689f81f288d737e84495d8aa5f6dac17d62499f12cc25e76982361b1ca47b80aefb8b4c5b4f0b02f8cbed9b25db57b51b9406af5cb5366308b39c3b0c2a5948211db1ccf34d43a1f5e747cd77377e8397139ff224d1a3c6a95abb4bfeff15fc870f63187095e0a389e6e8dd2112805bcdcf5fad9f665c70724f750fb8972ec51c1b92e0cc126abf5000853dfeb8ecb633b86c3606cf8a5b4a982ad42d8ceb3b1581e1ae3af37422bdde7ee70ad97f35a9ad4a57db081f4927bf77ba0c340bd65266c21481fcd61c5c0cee600197af0c75aeb9e307f49e51237f80fa19826920bde3df790e2e0429cf70e5e2f97de9ebcade5c0a53e3f9bcea5d7c749d5002a58926ece1104291478313fa1c5f9d6f92614210873785f8559a744f42742d47739a3951593005dde473eadd2df87281de5bfece23775c6f22063e5a4004919d74f9194d2de8dcb4acacffc3732962dde76b85cf50f49c99bd31e957bb8578a76456e3112f2775890dbe19e9613bc472e86392e42f36809894f7ee09bc90a86b2e32716b08b47eb69bc2f7096462233af40384b35764157adfae093839e63151229f6b5a9867f70cc2f21bbcf6e5fb0d17a6ff018fbbfcdbe7d000dccc4a943f115aae463b523cb971adad58d542a080caf90966a4941c0ffb42b65ca60e8e9bf45d93c6c9be65be513c9a9c6008cc9ced3d148c073717389f93801a6bac8d7aefa082d2053a8158f55fc994acc679a2cc98116f21aca5ae5c08b8ffd5c82e491e209c12edba270bdf681856e6e01dedfb1dd836912f4c7d0de689a687f02c8db03e21711691fc7dc031bfe4ff9813c2cb8de779c0be6ce968070a076f1e73ea96a05a289edbd3f44a19dbd29e933de11c21bb20719e9e400c75e53974fde6532c9934499582577ea2e29ba303a294da06c370785437846c3ed85976093a4da5013ad4bf6a80b0a037411e0d6f682153066a584881047dab15f5e385d70b57603eeab98a13951772d81be936c1a126bfb65e6c9efb9256ece28082d0a9ff4a2accb47c553ab84ae90798c8017f5e22c798d6dffadf673e27be1f29c766a93f98f7e830d29bb170c8003633cc9d09aeae1a85965f7dc4ad3a19660ca9049a48864e74d51ecda1cf1b069d435d479a1554ccd903138566a2c2c03158ba8851ea3871fa519eab08eea6e2b29825d7138f1fc1d32c25805420dc4a0d5d35c4cf291454cf47c0f8bf2bb7087d2ce1afe31524b3dcb6dd59a64635e8659e100044813a84cf5ac560023cfbef6d51d494991be9328850d7b2386048a7bf06ed2cb747a6e80633b530a7da37a8d3575cb1994507d0e942758881e20b10cb6e56300144cb31db71e36aaa6c359d00e33c5c5359ff451e0bdb6c630be4fae2632c07efaaa7213959071e063d12d8da8d1eebb1b35686e97637cbbc3ca529ba63da7aadc2592129489ad925b8f16d1f4b0bcc5977b89c38951502cccffaab914ca76d2a55ef9124f4d22a186965769824e2d1b094de18b5eb44f66b6a5515e3def1703f6448f884b5ec3f75877cb4846470118e341594daafa2ffcf9c89544cb23bf279f1bc6c28a98b3fc9cd280394f26a4a50fa75ff2157e9feb8a6ed0b565c388c8f8745ca3d326fc2a0c833c987f85f33e9593488e16e7ea4a889ef652a951b95aca11482f1d76270d0b715a4547ceeeff4cf1da627b0b0d37448fda58f3c07de1faaa8b1f9c3d897332c461c9ef24aa7ceec6eee5fb4ab9e878b69b808da1c451b0c408b324221e073b57043b5580bbb21306754d3ef53f5a79fb0787690c85b1337862b25cc324972d89ac060a7c4c0f07848e23916ece5a1e8a45890108e9d03910eea9b8e0fd6d0a839a7ed127fbddcf233b0d7133cf6ba892c92604a2aaade02f7a59f99577812b5843c602645779927fdc3ac43f790153f301910a519f1c4685e572183f82dbc81cf0eba7b1fa0643ef4c17b754be630d4a98054e93429a02cb1fd24cb5cb26e67f5941cecfd1d4b694b53f62bed9123b41886fd756d791fb97ac2d96e709bf5db14ea88d63a894e7bde05df0c54e0a615d97d1c5892fdeb7bac05202c714939d38cc9d59f5a2d14e98b2fa6dc969bf15ca0d915051fe6af547ac974afa7679aae12e98e23cc714050c77e5a31523dc9aef09324a2ac34f2760700599321c2a7d37aad2a93b9e92d221b491d789c72652441d1a74c845ec4ba058a343a09e12ff9c728cf8e313f22d37f9f8c7071f2b1713884ea47420a14470ee954e7e7f16fbd1ea69cf0007b153368f08029a713da5886620a781c8d1fb9965edf0a00e6d7b607f673deefe0f454332425f0f1f4a2e870a905804f72a37b00f0a0d8012d4eefef981f31d4be635ad469b432428925ee940283ba61a0bc483a78bca23df126ca99216cf2a02b548889339e0ca4908dd7041bf708b6a2878231c8e580138681e134affd7b0c58f39e3542b69b602237cbab4f4ae38a44acb4269ebeb368a2be1dc68704a94874c143d7fcd5f371cad7d749d5fa751de46d59d3f637975f0c77f43d01e9ec8cbf22a71a41e8429cafc39e465443e5e3bb961c4a02c6a4c7da9aed6f6048fd08d3d1b04f218b35f21f9b75b7e69e0c8ac41e9d0a49990497b699b42be9012f170c32083c53606a8cadfbb74a7eb8659912c930b420ef2b97c15dd7fa8064bdf1990403232438df7463f00f7cf720d5016c91afaf96b15aba55d96b4699cc15a4a5fed1092b851eee6446ebfff183335f1edd7a08b074a08ec8d5f17ab58b183bf9f7de196a021da5438fb1efb22d3214004ef853894c544ef13d02cab5b01a095db7908bd630dbe9131878ba518ebe84f053b839dfa6ebe80152989e9ce2e9677001fa843b6d1d1b6fdd649ef3eba6bed15653dd631e83ca5bd9980cd49d148aa18ceb68ab4e1191f51fa1847faa5b6f7c9e901adb0d79dd7e19ce4b1fa4d8e480aa18bfad8bfec5eedec5820b2c9ed5178a481c6cd98fe2e421f86f7e3cebd63258715426fbd41280f07080553dc11483f4d5776e55e32f020e38fef39ad8546906f6cb7f02fe4688935dbf8473ed55ef23f5ad98d08af5ab322a1eb0f45700c2bbc38a8e9955fc8a08ecb21e5f55305e23000c6347db475209fd4c8f761a20c086d6f44fe92aae9fe539be31a5c4fb25e7a7403ba716886e8d5dc6d7932c40840a09241f6ee8141e1fa64ce79a1cbcf341bc2ee04e274e58ae3d36e3f8993a8b69fdeff2da41ec1c7c6c643f6af17b4be7aa2e6aecc6d93ea067358427b47409fe1e76a6f249439a4230fae097f22681e35123064d99b06c355b19225e6de815bc015bf2379d357be63120855e67398c1544e3ae0a130e4d742d2685696bfe33d6938ea81df8826b42267903d9a4aa59ab33c9380d1cf82af67cc17bb45a4f2175aae4eb2f948adf04fd28bff1b9ca596d875c2fdaeca594323d8c2220ce5e610ec405bb1727d5607a5773861f67b06b5fabc641327b42b6a9ce124b6119c15b1b139e21455af84f3820dee3249b3c41768375119701fec2f9f93399f0cad152a57e570a11344f29300a0f7beb08300bcef0f552611dee2a701b961797027d443e0440c947b033a7bc15b2e0a661ef761f358c06e344ee235cf4c3efc9a8e95bed85f4a2cdbfc00a42d228e1fbe307f15981c6dbb8406d6ab332d0c769369c94c2b95deb356fe30d55ec000c365b6db57c1af94a95f5d77c939009858d906c861926ca4c8cec27ef71a9ecffd6e72ffb8212a2154aea35dd9cc53da2488210ce36dac8094288fa002ee45fed4c5874b43bcea672630ff6e2a6216a127a2b0d581288a357ee147dbb43971930d538237bd9cf58c6eb199cf1f54b603fb0dc48fb953fc2e493cc261d9ddeb9ef0278e46373c71cd06d79f43519b60b9fa78dd5d45fb4a841c06374464800ceee61b8cbd3a93fe9a7112556ddc6c04744a742e9fe85904323dfbf8729fdee17fb5a58e0b472845cdfc95b72560d1dc15cafad2df9bfdd57e5e0cdb295dbb2b82c5b1594b82edcfed815f32218bdcbbdb8866b1f04b6553119c1a8c26fa7712647cb77fcdf5dec509802fca1cbce845de240d41fdecc5fbc94704d7164e12ab94a1b12fedc1131f890ee002ba5a35f97963885ebc9a6d5663e15d376ba6d79aab510ad938e758c8ec9e88f22b137985d406b02b3da3713bf3647fce8f44ef8fff3d6fce0db81b4e3e29aa06bfa530a0c77715969b4d48b93b635154180a202186f57d6f9dd6e2c3c126c8a5108cc870027d702a7e928d9c5be6a05ccb6a9b42516cfb6a26f1ec7d341c595001406a9653320df85f5a4179ab78ec19993cf64cf2c9b821d90dec3399afd3ff9617f494a0b8fb6e7c85131e3adb3f25add6ce61c736a552d8ed795a9dfefc086010bc8200eb3028fea38566208c1b31e17830c4798271699a6017d33ff4ab38fd6c9bbe4eed45c04e1e2005e0cbdb51ee082a3b29ca930a59d73eb3f9852ab41bc7f13a81e66199314ab983888e5b22e12224c7fd7e6b71e4410b3317ef4586ab38fa95074dfb8161c1636b5be909df3b51db9c531cb714f917ed63ce09a7c85974da258b452e74d4b8c87a6f99a785cc352ba04c84a7180a8ff91963a869e0a19ede746ed0e16741a0f535413e83f713012ab60efed49c0357d56edd89150a1b74815839492237b179363b6a89ed5313e2c543b176fa9cd54ea0b3b382254dc3e6979e623ae2d24f6c7b46de32e51e65d83b2a4a8046e6f24d601f4e0a349ed840f9e90665abb8e663f6b156881eb88e665b79bb90e7ff66bc29250bf9aff8df1ea3c10dcd2f3baa2b3c31bd7051b02baace95f56a066658b1777945dd73398b4ed9859c528c742d2a6491e6a26ada85d0ad17fbbe56ccf78b4d3849825367db4d149dac622ff227c20c165876fc159a904eeba717ba53c3d25a3ce8dc5ee8b2c55b59e19f205f59c8b4e114a80fc3f932e8a9986d4fd48705239e26d1ed2af97b1129ac1899b0a11885ac1b51f754c7bb4f4398a1c90db430ce59cd2f5c4848c90b39426db308b52da71c784f41892a02ac7870ecdc84521c1d12c5c67d750606933074ac176ec8927d4073649b8d0fafc74aa0eb76192e3b8cb9cae376bb71aecf68f881886468707eb2e65cd811d3e57ba61973a2fc3f56878373c1f66fe1b719201b37a6ebb73c8bcb5b913adc49a1b989058104d60bc272e904fddb311e9c6166cc4ec31887c22034ae8577c1a545900ebc784e7498bcd65c1fbd05589eccfcce6566a654346eab043c376e2efd18a6527da41ed60902a590f1deb51678e1fd942fe259acc6dc0cac25a3fc85bf7abc2b0573f0afe6dd563112433d0f4988ec47ea8a5cef2448697299fa0ecd377df8b9ddbe8f831664b78fce139f6778d2e7349f29c548fee860a69835e7d920efd2757dc86cbd7131f487ea9475b93c88f4c039b6ef009ff1e4d64bc6e5f18afc74cecfb8eaa88d54c8535afb99545fadd62eb6d9693def621e7bdec3f8cbb53580802216f39b1c33e8acc9ec40706116d5f4f7d4d3ad74542fc886806b87a49c53aeeab00bbc8d93aaf8c8d27f81d3d3463478ce734178a1545eac4a3537b2c7ad82b63974936d486da06fb06869eb1fceb2413ae85ec4a42763d441734d7d296a0b642a0e1a39a8534181e25be6651dab73157cacfdc6e6038047f59b9399b351d49c35c119c5e3edf6aa625d9d8bffdd5409d1ac70ee8fcea96f7c5e13ed23dd8f75cb476258e62724a4e7d454b4ff73f076d5e2139e69a9483337be2779dcede75803d6537ddede44b891c5619f602304bd2e61aef48e79683a4b385f78dbec350daea4761dce76e17775b3aa18e29f109fbc2eb1205fe6827de3bda64bb4219ecc7a770c9d04b2e3a8c4a70c769c8027e207b66ea01258351e3dafe258133c391dcaf3e7715cf405e228cbf8bbd522039ed3ecef00f91ee7dc79cffb61f06796f41d7e3213b75028c54bd2a6f7d19c68271234c7678cdd539fb36f00ee6f6011002a2ebdf84a2937b0575bf7a5643a4ad354e7dd855d58d304a4a8072f91fbfa65868ae0333732f88e58e94cf88d77159582689b5fe951ca900967fee3b8e97021c3e682e319eafe0ec620358382f60a1e9c4e55b9821d5849293d9c3919871f70531faa9ace2005f7cb425f5e4b4abfe2cb7d8227ba1dca5f445bdef2fa8aa06f793252e545e52725b4bf54deb7df38f2ba756ba35b3e12822549cb01a3e9892becf10fa332207f60906cdd605ea00e75de19392fabcb7ed8e061b1b8de6fb00791c96b2fdbda3e386e30f17a4c0046654f33809cbe26813f99f1922bedd94c73fdc46c1adbee34446923b29e895139fdda4e53ff42a3cc229c8cbc7c63cc4a95d79cfc252032f363d2f8d705d0855f7f20bc98507e15354a5f3af533bdf5f99fea220f71cb3cf264eed2fdcd9038e27bf65d72c00bf8afedeb18658488bb4829efb9dd632242276b6fdfe7c410eadfd614e2990db866551056b96dcb27d583e895dc1ed91b01f0064bd104bdb3309d67314842e7a773bd84fe932873d7f32071ddb2941d646c10dd09a1ee9234d080512c271b116960ff6cd8a9d25fc462b247e48e7df30159a5314ec52c2edb238026652a1629afd3c07c5f4a279c6f7e2401f14f2f08efeacd92f541c415e22dc876f47620e153b99e037555807228a9bc015d830e1578b4977e1bbf1c6b93fef02e6f3bb8102564417269adf893b6f78751acd8899132f5ff92498555d4764354e1b714152fbec022f74d7866cbc3f429b464938576b86f56b6a74c0191386b3a49c18bc88b3ef1158013f9a91f0c3fc623f4c8500a7ca56571d3124ac01954f660b70752568a9b648cf8cad86130bb7831486ac26e512f5a4220d6cfd7f5ac24a9051be5a1475ba590348925f541b76557ff2aa0c482fd74b99d4a58ba535bb5252129d5c8db986f0e79c5af9d4740343e5dc45bfe65794a3cf795f55b0acc6c3ed717e6ef3934d02e3de5e39b2590ebceec0c1b948229089ce22f180d0de1348760980364a8adfd2e130ecf8723d86af9f6cd7a6cd72c774da8aeac335d99d4db5174f8a82df9b260384245d9995b8b63dbc79629fe12ce540abd4281c0628669b0aa583ca77257921311949e86dc526be1c0bc47014325b724191ea9e769a4955e3783b340b8a84d8e32a39dbadaa6d44fed97613a67c62551e6b54c788b4fb6956ec427c0ee8f117954f04a30a67bff50fa1b243bf0506b53eee2a599cf8e4e473e40ba66f2e5d921c4606ab79d588732099b6ad093ea39151851c59e7363e716961cac586e2e543ba1ed12413b996bbce262920fbf1448b30f57b20f40ab43a4c32822cbe96277c741ccbb0137ace6bcfb6b6bb111560495cf963cb6cc7487090ab6d51ac8538ff32b289d5bfe6ce6ee473b0e2b4ee14be0b96b724fcbb432b5abcb13f672e1b7a09923357018164525cf03a630cbc13942027711bf90a13df5ab3ed8c5f026c28e23ef72bb19e620bb8a1b0c9ae028f64f2ed606ce8e0751c33e150a664a3011a1daa1d1fad9f957d8448e4e5477487b41dffd1688902348a86d009659ed96a85b97608c6a5f6bcd9ed78c448ba6b88f96b74dc7b06d42aafd6b555e4a4b40708575b7b4907af79ddfd4a46c3e562245da02c0712ba3145f8955f736064f783816cde05a2db7be2d66fb5933f3aa81997cd7df7ab6d359197e64a038059ef0273a4b1dd416e657a24245533deb6b47e0f19ceaeb081a74a84a1f0dbd4eca5c936a35eeec0adef1b7055b4835f972a6315f75c2c6c21e30e40fe158d33d0fd306afab5aee030b10918c9e3164b508c7a3bb450945519c7d2f484b80f924f12274b3a5a4831bc732374d978199a39a99316976d9f57e7f779d903aec7481af56d1d5e67c1da2ebadf234ee6a7b5a1f7ffb631b14c8f7e3725319ff7298fc3493d36335ded2139596dde60bddc05e7508b0aaa5975ffbcadd8874ccbd6ae758b310f6d8e7168c226d3990e308a2d0a3d14aff953e54d6c8415e9c04ed522b875feb1b3589fe29d417bed4dda89461ad195bd152dcfe9c304597bcf7bfe1163328fd2dd8f426e7e4719e5260247daf8dbefafbd9fc10074138fc9b4037125a9b3d8428ffc5095e9c19fd55d30eb26f30256c58eedc58ef3fc32bade866fedc97de101244001bfc908e964164fdce4ef95a90e4b40fd0ffd45fb92b8822ea283862ac95cb7bb9926cf9c87eefc4731e112eb40ed390c57efaa05442481b4a89816c85eb1f0194d43c469199bf8d17572a9207736a5be016707d2081aad1a0887b59c5224371da2ee10a340abdc76c3d59ba971953ba48834efd62f6d7fa200ba35e1c2c362ac29192d1b63cc5f808df7e4b2652cfccf1a6377c026aa54677a7ee2d20b762428b9477785e667b0cc62071c178fcf889a4a6c39fe292bf420b0582718bad6d31310583437f375e6de2bf2eee62e02463dd7b5ff491c8b2185772f72d1d048a791e831b3fe7c0ae5b9b80726654b2129c3504b9133ad41a16a5a964147398686bd86531250683d4cb141dbd2cfed0a075d35d9d2f3cb4b1f41453d9c2d8f6f84d6b89996f5f842e7d8a0dfd094343dec3b8d4435ff9412ee485972775f1f41565d9b4203e4dd72161b860aac3cf24c69cd536044323efdc123db82df2d44633febb1512571dd97e5874d891d96a95a0791dfaa35f010f6f8d3f38a9e522c9bad325c27a8dc68766e029ab54eee0b4b5ffb953958bb7eae3fe9e369c6cfa600890a9f193626885efc3881472d7203cbb5e75b56962cd23262eb5b27fbc075b868db5b1e654b9fe714a465c8b67da0e07248c045680d85a81af41ab46fdba251fb1b656dd26e437fb57cce15501c822caffba658929dafaf22a4baff1a87f105630e05708615054cf4d3fd7755ec5b293f2e05caaeaf18e9c9882a824495820688cc585d117a218096ede679a1e4a4555ba6c4ea1c3c3c33ba1d1bc74f24d8de21d597300555abcb8cd54347fe28febb4c6334687113f4f8df67ace6168e078f421b6478c519d65b4deb3b8e7f681ee6fd17a83c111b69ec3dcf7086584435ed6b7683b833bcfa0305853bbab8c92748166d9385a5b73ee815040929af1d76d24fedc9a9b0b30d0036721e91b85d2e6e1920754a1b253684838f65dd1a69295fc61b76bf255cb1b0935a9761bc1f0d0b28e9f68da6e9dca72bd79c2b9c035fb33235db6641d6d4d4fb1a3cd547083d8880f852f1968ddd43766dcdfe294f80d64eeec98b627a736f9a11411ae1b24d66ba2f7c1f659b87576eee291606355db46078dd7d3a42a4138d5555fe76ff33a6f4f100d17c7352b7c39bf6d2c77b0c9facce8cc267a7b8867134f98f44c7a8531db799b946ef19c9c9f55eb1bcada2ae4966265a43d36bd117c2c6417a51c33594bed980b928748ab87f00fb5b9d46a9aa4196fbd2288b2f55b788c0e9c0e44211c02e95ac0b1ca44ca49311803773b59f4694112f411cff2dd6c0414c7f65cd80fc8817d1e990ce837bdc7e31f930bd92025156311e0f47f3af6a1b73f589c9927ccf3371bbb27b33b9a0133f57c4ed6302105f6c350eb28ba23379680ccdbe143c9d4c27df308dd3c53746bf85df18715d1da95fb17204a0fb52640bad05ede736a267df3e2a2a03482169a9b3ec0fc2a1b84a9c0d176a5177fcb1f61ab0c5d42958af59a8d3d7ddcc0ee15b17eb7d97f3c5d5c8ca1151186b5d5ba6c124eca7a11e3cea984aad2bc45efb8d98b1fb5da81d44287c1e24ad0b7f86993e85f2892cdc700a1af1700357305f4078568f00b723bf4ae9765ac81aafc1a09082d29df9bb450665429130c1a81abd211a780008cb3e475df5c035f743a6d1420dd5cfe3a4b49b2ba85d147cc059db6b417f8284c5b189095dd3b797783cd4e8f1817ca0d209f061b7dd37c711246bee7d3ee11193a4dba9aad09c5d4bffb3ba77007bf43d36786e44a423bf584e8505a100404d8bbb67b544e54d08ff24849ee2f577943aaa8cf410f4bc694850282c412ef46cd7769ade7047ddf21c6a45c45e44ceb8999ce4ce7a5aa9360a51886dbc261f9ebcdd87efd1b449878ce3cdfa0000d29717d7403e80b2db7b73e46790b44d8447fbb3e0a2549347fa192d74e44b6cb12a5b4627b08c35cc579277e8c50e5d89d48b722f7218e6c475cb42e8d90a879f5f13c3a29b79f1b613abddae52cb56ee560ced7666f5a380b2e12aa67b868763595ecfd79e670639f60a7c7da3d937a1c3cc4ac21c1308ef2e03bd2ace4684bb7c000b9fc60df79cfdbec2506146d59457191ff3ec87306d0e0b8c220a90ddf84d602739d07d4103850da634201d0f513f77f5d76d6158468839da8ecfffdb968abe81d26239b19695c6c863bd8fbe6081425bc288a68fb002e23f1ebf133047df023dacc4a76be5e32409085dda0da51ed949cd620cc114455e3842269c871e5d79cbed50d083e9f56ad65a084078231fa304ee7d91dd33b3ac76fc5c54c57f77fa7525c9dcd0cc4f2cc0bb395a8b1bbed8e373d930229ac236062e7dfdd6d1e0582fea5520a03e8372c62307df4dc2f29c054ae56fc3b111a17a373d86736cdadbfe0969cfb8b9c239b96188f5cfb53f9a3ec345a787f72f1510298efb6c4e37116d983df9e8c17e0dffb063e5a45da0c56e319185b83f7beb87a8bd75755209e5da58f88bf32e9214bf33d8721df5f7ffcef3df4b87d9b9de19a7547d9a23beef2b3e0cfb71e868841b2a0d6da1a5af5b1c4b287302c46010996eac15c316643d5cd6dcae9b4adf1131cc9fa590e687dd5264e9ce4f0cf1ce47269a6b1918159917418d498224fe732b53ff50a8b28eee9b08206f8f76cb0d49c150d8f28640a96fe216ea77c06370aa9353fcbf6cead1f547baaba107c19e9f3b037de29da177344179ac8e229e850b5e8f88d3afb498e8dad8f3db13f1900f4c1eb282812f446d569e018c76286bf4259e219ffbbdc0077b3827216edc82e8688549d8ffb14196bda83d0f4ba13e7f31cab2427b604162ba9d59e0a68a73103948c8e19812c80dc846c500b4eacb8b95b90c708f08e61750783583e355ab828d0cc4488d9dc6748a00df8e88d3cf16f23a4feb701fd3a2b85d849c6bb30aa1736f874bd9323b65c16dba9506cbe0737cd349057078aa90df13f38f301cbc95742c72f06d2e463d1ccecf477beac2abf6ccda389acc17017cb8f8660a3661e543fed18f2b02989f954f22cd7ce9e0f94a1bde8b2fbd2fe940c6eeee6d34c7902c71d95229112656b441369079bb4f189de76d1f8296e15b06570424cc689b71c644894fee9eaf06a9c405913b703edcb021d7c069d57c9de27d1449143a63122f97545601086aea40f74d594601ab3ef774ac12c78adadb61d1a8e59960eb4db9ba289e5bd16ac2780430889089487a035beb083e065a4f1582cb48e08ae74a21d20cb7c3c558f63249f16565329d83dea6946001121905dda5a956d380b7af589e08ac902e2c7f6732751b3a536b12a1925b739bc062e802888e8fe6844ccc2e567331ee7ac5fea81129f3d10615e951e281416bbac203c457169c4733aa468ed00919dd4ce5451f4a059cdba8f71f3591a184164daff292a8b0a7dc6386ff4fd4b63b06bf52355a3f11d101c885a8763e1277205868d5d4181954ad3fac40f5507cde82de0b1f3c6d81331714edc129e36b1f1b1ac1ff948034ce9b239c75daf3bad82c0e640a01022c13250c3df4db8e44fe942f619fd4bd7fc50f705de344b92f4acd295d11389cedf0dcff72b8a5070d4d746511f5f59875505dabce8291fb715a12cd4bfc98f005b55c78f96dd4c93f2fe2ef049c5cad24a80cac082a87d7c40b7e879fc68d22b0643473b953db096c33b542931208c89ea39a17a4b6667e54ab0d17b9f7cfb21813978da165109bd992cf1b6c946f6cd06b83d4426d08fd489b6a9e6f168cc587105b88188da86002af17e623c725645b6b9bc255175f7071c9c6f935175a19680841b764f6a486609295d58f4fea482fe06a2bcb321c7539e0ac848e594432fd765574d8e9b1dd243d2388c2e362b635c3b18f081622372cc86b706f19438de614b739327ed402baf793d99403d6b5a76d4013e7ddafb0050df9eb747233ad29a43e03a4d472f269bf8399de9ec1703fde0977f5efb82a96ea200786eab031631d5f9f7df38a522141c250887c973f8ee1308732190f13a04b7919f51c1da3a8aaab418d1bac650f6fa4f7a3d26a51aa53941302c913a4275c4863687143d31bc932278f3241b4c42a6bfa94a0de1fc0e69e76df2cdf35742bbf622734d34c65e83a39c20679818f9852532baa8536d136c8dc4179419cd9e86f8fdf8dc8e67f40f6aa7a4e4943496e847ebcdfb9eea04ed8ee3d1f122a25ccef58e9feade3e4a4adfa7d9e9d345f2935d1f8ed1bbb827f94152d398c679a5f06ed6ab7ac8b2ff46843a987fb4e600526668c8c373ec64dcfb33536e68cea93f1fe33a52a32ee73acc4749b042c972dfd2d81b9fd5e4607bf9e6e8b78be13dfebf933eddfb91cd7aaad03842f24ea52ed95fcc1c4f1b2bfad0524d38961eca2c5b1614a1b32b3abe3206284ab898583614dd67e25d551699d0c40fbf61fbfbb58a733c9db8098dda0f7588003e322e26ae6a86ec13cb0fb2d7f1e796983b8bda50ff7aaf3ded8e4769186538e982106f853e9a1465beaa7fb5fe4973aedbff79d887f18e28fcbc9247059daa7e3fa5cc94b9dde30e25e7bfadbe9f8f85ff8c6226cdb7e65c3860cc27c88fa858ea3452878abb7c40c732ecd708421d040199ffce51d705588952ba11bb915d4bc482e560078884537bb538edd134e9144e88c9fc4e0b03a0eb5ddb4875520aa66f491be9115c48f815781c61ae19e3483f96f536bd6659f4b0eb34a5c82c0ea5e5fb8a01b7f73d24e6486c47c59c905c86703206f915a2a67154693516e470c02c66ed66dbde67bc1413dc7d31bb222c515a6fdedd64eff499117afee684259204c6a6d9a3d848c3f0578fadce5dfd5cc1d86bc16c87e7e80b0bbd91351ed128be5092f3ec9a520c45167f3c77e57bf4ee96830c2a45e1534fab4e88594b2902a74b8570774d0ef7ecc778b16225fed431fdb7077d79493a0a24983b59b87acf9c031c012f72e68b60bbc7877b598b8aca9d54cc156ca72611aa103000411f0ec41351a89f997fcee12d0a89b8d550f2c9c0bd81749e4d0f882e84910001fdfea07d5efbe369d9c26db6baa1fd48bd12e913b1c11a23d8275aa1eed94599a0a0efdbb32e35d42024d50088efde35179e063da3be3f47af0eb42c18d527e5ec597fb3c7aa55b3544426139b5e2475396ac2273f24cdf2d81494ebdfe4f44aa29723967e8d7a273592732d4d7b8b4b695b8282e4fd691c1e5d4428b9cfa7199f618752ba12eea2db62bd5fe843fa495b5a231728cf929ea527b081615a1a2be86ddd7a7570ee36491ff745a21ab7881515001cffe4843af5a59915e51ea3c40d4a5938f0fd4dacffe52f6d634209991afe79d6c2038df6bbb94bc843f29f7cf2a5ef3e0718eb9a0d958a996bfa6e0ae9d3693fd1f33f70aab61de39c51221c33c84c9f29c8525f02e3f2b577f47374dcf5fdf8b611888c36942112ec447e5854133e6e720c0791daa502180430f8a5675845150d66b1fb091b727e782842656efcc1775db0cb35ec45191d94185233083047f9d059e370f926d0ff3279ba128c36e2a96b82fe521c2cb670979735ffe0603a0c8fc7946b7500f57fabcb5c54cc8ac7944380b6900377258c7c7108d792ed8c3548902dd4e0cd8165a6bbc9ebc68fecb6167e3ab4a7e2688897a8f7ff4f3b8b98f231af48f15f01fd79084d72d1c5d87efee1f7767a703b26aef3eea6bb552e3c0f2ca0ab36f958788d1a2e3192c8f90afbcfcdd09b12b73860cb181897c5e2b355543ceafe359f5f353207490e8ade9319b84024dc265eb93b3fd36306bc33d9e18e1f861fdcd84f8eb8b4992edf530546b4a49395b9a475a2e84fece6f838ee8466ececc01bb885a8f1009c0d3d7e2bfc540467a6a6297bae102487358289a8c35f91db024b4cb61c8c69805c0f289bd535122a5bbe520398c58e323b36961784962d9d72f95f08698295ff21834c18454886a444ae37423dd57f157b07c6a454cc409a8b1f365061bbe8321169633857d6b68879f610cfbeef","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
