<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e523054100b15b3874c19b93b47fac05f62f0158b2cca65192ba8d66218a7d49008c277ac34cdf2b503d524189b62f5a8ce8b5cb1eed0b98121623e795f82bdcc749edff5ad68e2c6056392de1f910e3601c2747ed5c782632395474ca0b5990dc21b852fba0bcdbc3af0f799b8d6358b3f0954939af13a19de259936c0fb3e9cb41d1dc5ba997f5e284d9ac9d7c1cc9a26b19245bc78f32982041adc79e0a26694586dec81b116a6d08e1eb7cb310202e1f0ae6f34f600c3dd05c7cdd3c70cb75743f5fcb6eb8dfe5ceb75823f46abb7b29f8502d523e25534a8edcdd266e68f79720313e150326b2a9f0f78a55e65378e4249c0aa93181c3a949441d90454a0cad148e2e7779865cd6d14686b20f853838251b17cd2752a6c3abae2e216aaf7620f2a00947d4c2d94094c0efdc52a7571e9a1ad36db58fd44f64d34722f3d33dbab94feafa6d4bf64e3e108b7f6cea6c58b86eade132e0d3309a941ea03ec3726923a9dd44385b72fe2544a12c9ed8a3e09b546684a68521da5b9ab11a69b5054ab97048860870911079ed479a9f26ed36a8b661b23c1e241f3e045983e2f39672f81dbbd791b81014a42eee82f274cb8a1f47bc943aa8f0765b78e9b63ae0e843e04a14987eab044c688cb96684d0ef92e45aeb9970543aebe11c5b09c157aee19bdb6f5f037e165d8782c2ae03d1c9f9b19d9620763dd05657155766bbefd24b7306676b3f7cdcdb1db17748c6c0a31fbc62a22051d468ef51f7d48ecb77b924a74f766583d2b5af2f5dc80c02daf52edc964064cd0aaa4f5c5d658074279a0f8f64981321b690a29035e8e2040cc681e3fa4644f758a82d44b80dcc630e7620ffd8fc2208189a7c864c69ea159d73f0aa16396c2585598d359684428ffb1b7a300d34a26140f3667fe8e2ba5b31d6ba9bdc713399393f29c44fb29e7a7168f5034eedc27f4a6976612d71a9c825d5f366c7574e1c9d22ce1de1d4b4f7d2fb1e1a2f29d863afb52ba1b1469850b59cc25a3370843193d3ce64496792c288faf1f3758b75562c9b57da92fb6433bd104e855a79820f4af5c84a3981438179fcf41fd396ccc336e71f548325da7d4eaa2ad44ae59cf9f7a4b2ef899a105a0c71f4591c83da2604f272a25b04ea86c64954afcb7013ab062dc666eacf8d7acebcc26c4d530cc226925d02344c5bbc4c2605d6747cef15b9245621bb28ba29a25f74920cf5eed1c385214f4805300aad9a0885c4b698e0a6a305d027120f2633da658e3078179239faf9e1b82210433d7b0770d158f864905e0674db1154a5b8b86436e16df9724089f338a8baf9d0d794d6219696e3afcf08cae358a3c09528d1b257a8822c9bd2f29e27708a4f9b5a1dfea3dd22766b6a0cf5508a999c63d97c699d4f92b3020920dec02f1b729e57341e9d12870371eff9c1d31f665d5a1b8502962809a79a96c26b6c3290c7e5c23482d806033db80cc81665983e02fb2df5bc443d5d4871f26a8013459153247bb7256e6d6b72684647d822313a6efd61f9e4831533f3e476c22b92dbc973d746f846effda33ca6e92478a6b838f13984abcc4006f06edbb690e9644050d736d946706788f890ef11dd74ab41bbb1a4e37eb312aba94cd548e39a22f54230c0bc925d2c038f0aabd76294daf45664bdb4db3c3632352c609ee23074fb4e5b34bb1e43952b90298ffb0ff6e2ae63aae84e00ccc8b3811815beb36e977a7d1384365e7d2a23b9f0da52488157894a72c2d4d8cba1a1f2a456fc76a6a80684a5545ae44d31e17d5b9e46afe977e36d095603443f1589248646816f63c1bf20b8f9e6d59683f648db3b4dc0ce4b5071dcfcb0f6c0842cd5f1af57761c4b83a7b528451dc15b00aa117bd1b2f5970a7b9badaa2989c8cedd8d5bf2a9ee4dbe0d137221f1003103c010eae67bcda304dc8248e5181ff79b0ddf7b7415bfbab8c68423cba08eb8f21c3f9e1b5cccae413f459ca47d9509a24ba4b1fc52e03747e8a657edf180de90ca8fa08d7b2bc91139a422decfbc44c81b19d69d8757f673bc6042c5bcc80d1ada99e3bf6a373a74e7fd1f9e9d36762c5483a8be6610ece6cc71888591dee040a0af5cb5be055d079d0b7da97d3060542d4a08564487788b6274190fcc4f487523b4267c29d32ba8afb2a6a208d644045182e7ca95d4e90a77ef68958fb58b95a3df9af52b77a8227ba1646c1fb651153f3759ee6f6c6179bd17513116fce6e223cbe08b3193f48b5b4209464f142eb6ef0e8c8b13733eb23ebdf1292cd237ef78f512c504fb7479061f805e2936e76749910f78992544be369659ca07f5c692a67ffdc2cef19debda2f876932300c6c8cf520e38cf7c690097cef891f16e61031f6aa2cfe869524232999e3aeee6ca0c2fb84b3f303441f20ee9129491b3e702dab1b41d074b0053757004172aef9931f8b6c86063e3c15422a2068f8dc70f7b40cbf147074cc801447e193e2978191ab1bab1c0c4757f75d625a591ab562f92d4d8e7059a5a1712b8ea2c30457e7dcebdda6cca89f2788af9e89ebe6da5c5ecfb615c58fcdc864ad2dd91e09ed0a13419e4e558d8c7409e8d490597f1d8a06ff19be1d78ee7b255c6fd8c5e5ade1fee5c46a0225458f8198e79605d52ddb444a102e38ab979aa0f76fa15d457bf22f76a91b38bbdd302271a89dbe76419a29b25cb9a052e3da3308c0824826ae1484d489cff6421b2a238b5af8554f375a1ee4d91474522ec62d632e6ae699c47f41c716a6e529e20ea9e236ff3bcf187bc509abe2111982e9a08e9b7e2f481bae9fd57cd86d42baed146950dd0b97f725dc38ee173fc923355338f39295d25a48299292a52339334e6594195d4d999fb347b8fe149fd744a8ac58e7dd560c2d911650ff4ef2297b53e70cd57ce1762b309fca49b1837a7675985648728b56b597cda64c876828f284d864fd892d0c5c71786ae581409d1935867c20c78907b36a8c1d2dbabfdf324a3eb27441d44a9c5562b322f344f79ea345ece6151cf5ebc854f83dbb5d4855988c437cbd7e40583ede77c28288b143654ca94df030e92ef8f041054795d3545a1e62f68c4bf6237ef84355dc0d2968fe828f0a8999254de9100bd8fabf84ea971d9ccc04c7d47e97c300a8fe9eb4f59e4c5079e705001df655d4751348937741114ce3b88f0b2b7217fa9f563c3772228e092f45ade332272c7674fca07e506ed41d92eb7487746c8fbeb5729285d87258b32b42e5b6ce3065b563ca3598bb7ac27fb3ae2f71f9430e4c57901fa1bc10b480d2becc10d6dd300849cd19382849c308614ab23d53b5c8a004da62d79adc797ac5cc4709e39faaf957a72e55dc58ce108fcd0504c2a5ddf57fdd21135f8292e3f4a4faa1a92400cba5d89fee3d8c76805c42120f1ac51b9b9f85c2724bd554391fa32a81a4f9eeea8acb49ed3a56d32313307df33a6d46388043aa04bf46e440dc05c4d1a6d8fb0f86a9bb00e70af2ab6a753d3a4a4a40b0ea260f68e94690f7452d7565546301acae7bef068edcb84980fa4d79df78d40bf7c3c4c7a00164cf937f18f53b108b5bb8947764f71af716cfffc37e61fc3c62fcb12c21ee7a5e4839ec29569ccb57d407b693bc35943f67522d459d0ebdabaf6d346db99c4bb071d09cfac768e64bce0ab516908fd571ae74b59637e7dcfe981f46c18d3b1d6acfb40edf839060fc833114f47e09cc02db458f37f05208c9d49cbc82dd12d103aaca37622bb27cfcbbee9202e7bf7b723dd6b8eb27e7e9e2ab8eaabe6c5ac4446cfd56e0dd566fbc39823cd82f86e4859dd563c5d9085291baf2f07e6ad3d91c00214cfa0495517876012be646023df43559f0eaecd510bb5109040ede1c0953441e615189ae2d3aa90170b30f1b57e5962c28a271d5907709743394a36946de5602bd89626472bb4ad678c55a1327c782cc05f14c9620e877e3ac1a2b79314aa69aba176a88c3125b6236903f498091dc79613e1ca8370b2832e16f95391bc3ca67454602f8282db2e1166bc9f6b40edaa0d043ce746e3caa4bd832efccd4c79cdda22a9e6ddc1f102a23103cc0cc62c08f32f9750e446563c65ca019381216185118d56448b9e7ec330fc31cd9324b31c79162990862e3fce5262d4f5bd11e8d0caa2ed64e1d21e1cb1a5c2e6e47806c36204cc96e28497787aea2499490fbe2841925477c4d49e4c168c5571b408e7b992eede9e40b10a0b08cab0032102996bfe4158aaa5187b3df0b2dcd7e9c9ccc0a87b75d7b518c2efa68d0fc143fe72f6aee45c9c47f49969b33396893d7ab39bbd3eb520a6a76397f72d18451114c67b7478d4ab433cbbd500006686f744c2a2212c64cb975ed1d1b63f2675455a9b3cf7c0bc9ad288b19d1ffa6404b6d7352162c7a2dce9896bfdcf708f90503fda9babc6d872f9eb2f2b0938490972a5e3ea6c0d2f2c1206d32fddc0c8dd8f3bf49f475704bd93df3d2601b35b1cfa8fc7bc1e9998b147ef3c07cb4bdfe01b0c08b760c14b4c39c0524b5921327da145861c1eb49eafc9b7f4838c4e580d792296aa95a273f0b3c11604525ddd025c58dc9da81876ffdd39267d53aeb9dc187bb9f167d76787b2b487d528d83ce2d8fc118e9e7bd26db2a114a3856086a3364f02313d4e9a915d99302c18735ec08bd78d50d5807a7d7ea001831f7336870837462a33cd8289b142137c705427fe441ff2e33c97c4f3482ef6b8fa27525a5afe47976520d3b5be42ab3e3c583a8641c8d8a77784cc22ea3cc7bcc649a8ff79bdacc2d2350cf530a7b8cec79252497f8cf0bc4ae64860fb8db40d1f808ea6487b73616b37189a67c95656ab54483b06e6b90d329a153aad031187d58a6235a2e609d8754952d82b137edd4acfe163ed4add19595e7d7762ac13073c5d59fab8bacde01989bdd8b086f561ca1da7f40f91f1d7663f5c7347c61baebc7da412e619d9b74c2898d47f52565691e2e23c29944605b08337a07dc07144ea8c30b8decfb1ecaada58ef823430d9ae18218ae9680df248cc5817a45724a0d69c890ca75dc52a41b7455fb913cfcf6f1baf7278403165a4d0cc6e8a803b2b7cfb8751b16c9e81de6121857e0952fa4b35094a98d03796e2d5efe0422faf2403b21a87a5922e67265652cd47924f213c27b198c3ff75bb9b4020ec8bd4bacadb8ec6ee5172243c30b27a7d0c2e89aff34fe2efa3fad40643e23c43e0cd14e36ba71007dbeffa122bfe51f88fd1714b06d2609b10652823b7bb4460b941d0987185ef592cabba50400443b884b9d6cb8fbe9aeadef8b1cbebf7b8d6fdb1b02cf313fdd952cd3bcd14865bd19d52c830a17f3e80aeb8f512a43285fcceb4f98c853d35374da88ae9f03f0e85f399453d7fe6488ae25632f9ef626e5e3ac7138a6af6908f875d2089dbc561fe49162d71af21799b73615ac775e3a8f1ea351de195ad3e826028fc56fcf625cb00344bf50f8dd12d2f28d7f820bfb9dcc3dbe3b385efd331cd5f2454d6fe8d448b0424f733f27d3179bf1b65a6c9a1320e8e79f4b452d87054d87579c9b34831f3fd800465919a403fd9cd0f7eef81f23e49583971057073a166043fde0d42a95006beda24b95f314a338648b8ada74bd56a327037c732ff48415b8dc12794484bc485ca7bbddb82a6b3898cc96e34541a8936f62af5edf55c4f0e8e6ae82990950ae97dd6acc2b37310be222e9435474124b235499eab49b91b0865d043d05d18d94b42453fd68ba5e04a05003cf8720109c0c86cbd8f61420c583b4e48f1542423868ceb196bee6342145b0ee2ff8cd37032f30556f13fa3209533412125f728dce01b95c185219beef9e692a9d2c05b09a58fee1c4fd1e1e30567ccde27fe5700e5afdbba879dea0d586de74ef44af5db9d060f9a24c32f20c43f1256ef6eb830c043edc9b09ca163af6d61af2c4c2b4fc17306669652aeb260a2620cc22f823624cc1f4d14d8bd13fc4ad430b75b962023c583b6b3c76bbac2feeafd2617ad8ec32b06ad9ad4f39cbc59c6dd7b9bd844e042884a028b28109d488f68d57dfe9a43cf524e24b25501dabe014581dcf94268fa499ff92963b3980c6b2b2e0ef5f65e0a798517a4cd3d8041879d417143d398321661e82b2e99481ce4b03b0b76864898ccbf8035948657575d8b64a94ca4b31658dd6afacac554ed07d16aab495d9d616716f4391585723411d74a9f766c8e72a980264d450dbabaa15de81fc151c392ce0f9e7c02cb9e328bdbcfcdaeb936dbbd6aa3e6d1d5cd48045a089f702aa3fdb3e8913a14a9d392b004d1781b51659246eae858a8dde6a9d22ce9c8b0a8d4e113e8882f568b5aa8206cb8fbf66bf41dbfcc8b0a7bf97e78621b0323c840b09c276c7cb78227de535fe02ab19f3f77e2f07100817130cda41e02359e949308e4385a2b32dc89abbf4c94b2f364c99c3c55a3ff0e699e067d85417febf0fe97ff3757fd4ca37dfdf682735df73156c7cf64840947728448de38ca6a1d68454e41f037fe1cf23c87a2904a61e57439a75088277b9a673022b017b178d9acf0d1b281d2f8ab9bc85e0974ed4777e71437d2a5549cd18184dc4c6554c447df19e2827e8a92b4aa82b846e53eac20275ee23760644e806845364460b0da43ce91067dacff1f7895b48e1531e654e9774e8c71df03763690c62cfeffe115d7edc4d6b2091993807d661baecc7e7ab687e17b3024182f2a369982ae61ce23341e8d756b710d34391358d6e51340dd43e7b3b95a735d292a20318935a6e7b42781bfb96f49ab547ce4507b3e8ee348c805982f29cf60ee8c3ea9437ddfa05db4f6b943097fd0f6b24bcdf8961d223fc146b6834f066d5b5b648414dbfa457194d46f3c4a8b34c37d1684f46c4860d544a6f3478bf148d169a750b98d6e2780be5c37174e1e03a3065a608f009623a26bf44216f617c2882abfb9441a44e528c254a8d6d7ce78cc525dbc8ac2c4c7242db0073c39d930edff64e22a76cbc63fb640d2c1c6e2eb58eedf25d5985a50da07773bcf9d0b7f01e1b8d01ed9a83e45e3a132fff024d4e2597a83108931fb58392570cc7fd9da8f0374bc20083a299ea33d1716f7846cee327eec2d2553df163f2abe655a4af222f382c43da82e01b05f8dfd83ca383348e880c3e29371979433625df23d1c89ead64690db290fd3181bba593b76ebaa2994eefaaac9cbdc445476fd940aa49f06560497c45562c2b190826304c61c4d0816e8f0127c1fd3e74aa95f8f5f712af063e6520ab57ee5e86dedbdd58cfea3bc8cc0de36d2051a6ec8dd399dff00db82dada8d2672c221b4a3012a66d2aa765ea7ed3f2624138fcfe6a9172c13962d7b7e35ac15884445aedb32de2789a6ce5dadb26a6b7e8b25b74146494ee7720525fdc32975bebef6f39f80e9b486f7a43d0c6a8145a7a18b8d04aeee7e3f31144ee65e3fee01d4d1a84b3e99e4c34d8dc706b41e3ad58392e17d8f497de78ea1c5435d7024ba82e2af1e70da78a44ca6ae11853122a2a93593c8acb40cf3d4cadbcbfc23a63048cdb01c1e28933a3bf71339b2972223a3c18e791898edf492432471520b686fbab26d976f686f5ddbd1a4ab3768496108c1e3c2837f28272c6b01e027766f71b2c70b0ec510cd4ed5ac03aec270a9d864105f7bbf1494f76b5e5f4438da1536900359fd37dd9bd0a73e6cc760cabafda5559c341f7de805652db260637524fdc8aa4a24e5baa0943d2f3d51bc6f9e96411833576762438722e022ce8dc2d24f7cbd6118788e5f0eb828d8636474d99e70eb96ee25e0057e7b8ed116a98347900e44decb1dcd04caf43c151f50169a18eb0f670cb7684962d9c0b4abf496201053bef42a85c6331fc24b19bfd394a6a3d4684f871423c57c2b675fb6e7e2a6e59aaaa461daedd838c277fd6a172c6244a0f5f1daf6a940f2749e54431e80acb274c7e03d0de85e04a21c23415ce8369e886e901efa00de3955305eb9a9ede3674e2907557a14949f9cb7fa146cc3a93a0f5e8aa7aa5a3780b06913fee8ded670a3224cd951066396047893cc52aec4891e43f9c3167db48728ca30296f6e331a783dd27b5902090ca31cd18d7704230e0f317bd16d3d19e31b5af2e3c0ce134173f3576efc0e825618c1d51c83ce2868a5230c9f3c0c32b76451889e8db95aa149b00457dc91f37f1b0f34e3fbb0d730475a2d1cf87a0bd8a75a3a87c30038e1b43201e9e5cf1282fed5537396485f3bdd6de69c7abee6901a5168213cdb0ff2efd1cee15269e1044d3295468e23047adb38e5c055b797116541fe5d8c38f9bffb0cf0152c989b8354cb2f1f342b6babeda390070206ce694b898814ea48596f284cc0d26e1776b9337b25f266f7dd38d5db62440762377feefe2678a3a2b3672daf0970a9aa3ac85ca77d85bdda2993484675faf01e7566c9c9940f9ff8665bfb0c76b80d4a4f265156316b2f92cd3c908d07deab5d877ec4953c19069e64726ebf3a3dff735eceb87491c81521f3ec188a33e2d1a2826bf8365fdf395e389c45b5c3196c31ea8116314749128c50633f76dc512cd42206e816d876b18828b2423e8e6c4c773acc7f573e1dbfe17da150a48c70733465b4a28fa33774190db2e699b482bd468541abc0a1c07705dd58bb57017f015eb0c7feaf060302b454c552427eb11c62cad19ab1bb26669cd66a7b5b932595bfb21d57c5d84b9ba6673c3ee54fd9344cf9ebfdbe670c735b41c922bf1b83b9415684801a8cc2e3a564dbb204273838cafb7e2bfad74148f9f6f6be3257ba406d39b3a4362aa299eb83d8bb6995c022af7c486ffed1477df1a7302d8eb3d920245e1f4911fa0a7e3b13fb1d1ceb2e524b762b3a37d877d6de6d761485d7ebe2f8ca3fd141c7a519bde080ed2c18ff86c4d80492328c2d0204517cccd4551746af6c7127e949ac3b4c10f64203ddeb982a92bc493bd02e0d775cd5aff567e1e50a3d4fdf08a8ec98c076bfb3e86a5aa52b9d6abeb8e0a3d997ffd362afbb29f2c26ae75514a837f098e11a9553b74fbaa5c13bedd5d9f07abc600b188a40d0c75c54c0997ce09a0d959dd8b28c75f950de909009cfbc9bcbf497c617cca41ead42ea494bbc225da38297706e5c21618c26986884032ad84fcd4aff3fa8ca54b2d8cbc0c7c24b4ac513caf071615d9c06907e9e149bbeda1c0d6185784869abbb6c7947843722f3bcc419f015c0883cb0f67b79aaec9edf1ab8eb1fb0c3d9f8f7a3f82b28e86514259c3c0f5ddf2811fabc5c8dd93e36ceee808ee918936bb345ac8f22d4fcb620b9ea0510455b86a42de18c457fb66684ce05636e605bb19094f8f3ddc67f5cb2fc4d22920866640c1e63e98e7953ad2dd7770af419837ddf8e8328214e7da2d5f88f4782db6fe4febde0c5c41dd6b7fb6816e5cb3cabf7cc6b9e0472ba4ace1a00efc7e81f6a14635d1ed39b199afc83a1f84a38290d4d0a8bb5b1863d7b10ac7350ce08e026f3174422dd37b63fcbebd876b24f617938908b349632b4fdac55220457ffd70c71f5ebad08d088033b7e872806339070240fbc2fde957b4c23b874e27b2011f12f9dccbb52f5f2cf791534f26717b66aca41dcc779b890598145577b0758a87d6a5d0f63ddb4ac8ed708063cfcbb12dd54b5036e96d78f581e76db3b0b1db4ab2e32f031eaeafde31380e8968336b9fc596f61067ee972440124e3c024cde9e524805f2b9b0e4e88386a3ad6512c4f513922ad5881b70d5e040034a10e9d2dd2a6792e801b7022d056f6a9fa5edcbb006e1ab0927a88e360e8fba755dcfc812c28d2f9c74ad629b04a6daf4f1a51db7fd134585894cfecc7e61261d245073d33df2b2d70fdb46cbb95e0caa39280ba1a1b77e4463b58a3b6175821def531dd747eb19e7e2f12d955d5b7915088e70ed65a24778f85ba86e4b1780721057aa25531b5c9b3e2613ac4ba4b6dc62648a5af69cd8d697fc12e7249801665c19198fa361bc73a7bd17bc65766291082321fa0dc14128eeec9966031dacceea8064d4c21fd3b10d521aadf7b76603db762b18f83607d4645f5ef141bb2accee3571769a192b62fa07dd43e79e096bcc16c6b78bedfcd895d91978cc045210d34390842595d70419f46ef3ccdfd81018036b8b7dca5c4015dc80c70040213c669624776118752cc3f505d079d6facf6ea275563b8c71bb55308ff3bf9a1e0c54dde35927761863ba75f47321acbf2add7a2300b25607371081d1d5fdb806780d867fd6b321f7af4955907fc1d7ad5c9ba7e7c7d991b4dc385e1e9c77d3ef078a896201af2f9d123c4ee5f018fbe06deb73b35f8fd9e67f848292d73268ed664135fc9aa85c1e50a3f154c1b49d99e305e8a49ca8f1267abb69a7ec29338f4233347ce92fcc2ca17092c74720dd0e3dafb1c3228d69ac9b9effd14cbc4e64d36163a8130600357c984be9cefa0c3e3dfc5b4cb1a96c00168fa6e81b157f61ea1af15589e0d7bfbc13be835f8b7e04ce02e6fc0773eee44870a63af29ce06861d471fa616a1353ad16c2e050eb72c57719485907ef9126f791d27caab6c2e5a2a5993d6d56c8e7d50b1cbec67c7bb8b73d868b8df1384ff067ad3d09b7af1a81f9f538293ddc0fc95a24cebe9fbed95e0d12c15804d25f0613ed43f7457b5b8c085bf5bb17648a4a8a6ce4160603fd6db5287ba21f7b98712063ca6ef9d804051d60f2aae45b20a80511f02ae3da03eb6b11055001989bf3af534bc83652db1eda6554ca67f3b3f862adc57ca0af8a373e1a35b347cbc6994c4803e655c3762743338fa1996e1be7b2cc245bbda2238d561da1e0957d8bdbcc498a5d9530695968231fbc45e79fa874c416dc25550b641218d5f9bee60622793ffabd56b9386f2dc5e82c2f4093bec18053ecbdd298e17cd6310273eda05f9a717b6bbf60b10a3ef3534fa57b2fffe97303b7c5273d98bb4a795ba3a899faed9f5d4226603ddb0f621d77b1a8294f2f803645c76549bb0e55aa6647afff23288413325558de06ac5eed71b68ba7451fdba0ee772833bdd5afed0d53b6b97e732dd08001f4e21cae27a0f36ac6db31f74bc7637861e7aa6619efd2c58c618240d833a54b701ec51ff6b64765059db90a0fd57f169bb3c69e39d2c944527cfa95043d9f1c48ca30d01bb716e9ffa8648ab287a05d27402b89a17865fe8e16ce0a572648c4fc419dec6090c48232adf530ac1662ef87f5a854d627a2adc4f77cb89357c10ff0c73e271ae3432bfe7db18eb2341ed3a3c4e8ef3fa8858146b1224394f55487023e5a4e44dd5697c8d2fa0277c349ddaa5571fe7685695e028ba3060412516ff94a0d54cd0271fa05b51c706d1bbf47d0da7ee9a8a3c40fc6971b7a58084049146a279effd9994ac296924dc09aa5add0aa2ee2113d221bcecec49a47d16c13c663bb85bc8b446b8b2d4042e757e073a1a56212ba63d15b3ee39c1934c5661aa0dd1f88a0781d99815d27b13d9d71a5831577934b94991d12097816c9698bcd13220668a2caffb5bc3790db14614ae99ca43eaf5cf4eefbca2ac074608d107343b5176b0f8b14543c5401b21edbe95b23c17f789e8d71b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
