<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be0dde1b82b60af761219f7b482c4ecca009c7d4437dbf68684569a4c456a48f8ad4c2bd78c5dd9a91326c724bed41647af37db788c0496432d4ad0313cd1de9e8c2e328c54b3688eedbbb7ed0e9945e188b5f79092720c46a117b7217eaa465a7f31675b8587c740e4ba6cb4b009c9b3f68fe152830054a5a9f763adda2c993585893a9b50d3b537ee134ff64924a07bc9dc14052bad04059dbd28459d14849a636f86ce4de96b7ad08dfec3615acbed61110cdba575e34092c997e44b93422e0fbc315f06a9aec29274574d830baeefe893dcf0bea24784a754438b7f01069f58251aa5e309bbf90fa0e1dbf047ff62b6a9e4daa6d4569bd9d3d6c6b3124c6d5fb7bbd8b560725737334e77bb7606e826abaadcf1e2fb875f02f2c5e0dc151c4ede0d2d366a4c3da2d228659a6ef26ba6580569eb8da355568c7f83b468bdf14dea0488aaaeaa197d8cfda8d40e6136c438ad2b699d671902a23f674936fe638ebe141d34b49b070acf97a87c36d855bea1770bff361e39597770b13dc1dbc19efea8f9080b51b9548e4fe391573abc58161444a1771865a8b9f00ea1e659c2f1d96a503da8b08d184bea88cbfbeb7a1dfc83f9879bff7ba64e3a4e28af67d204d9d1cb87b99814022017ad6a4fc578db24e7c77faaac4b82aaeabef31220f2a3c2a18334fe72dbe68c9bd75d1ae80edc73ade845363a57d4af29e6b032d24cd6c49fa8340b502b1c3b4194421d3068641f1ca613c29f38a1e5d14ae548b9c4fa65ec1b92cb03e33ac55578dae25837afc46062e3061e188d65508ce16d12aedd75d887cad873925ed4532a0c414949b4f8a840d10b927049dde5df119c0f5de2a4a5cdbdcf8214db909d9f40edf209c7d2578bf05ea2d5889d3f4dacce85d02ebc62f5adead851a10624a3d570a28a0ef5645f0161d7db1e151d5d8d2ad6db3572fca8e5d3e70fcb5bfc691485728f8d57d514e2bea032c2a1cd8119459579e11a05d81a97040a17d3b1d5633616c3482e2043142f9640cc661e9618b8f64705c54b3243b98b3c16c5a475fd4e45d12bc8b664ca70e17f011acac95879114a9f4e29468112296edc5501757c05413753b8063375d99cb423748595545401759c2fdc79032380071ac4477474688f5e15daab273b326ed9d49f7068da54bd4d332c86042a881664af657c908edb29cefe01fa686aa2587635ba412951d22b4db86b309e7b106c92be8ab7a14b4792459c2822890cb243ef57a8c03d15c3a47bfa13a279bc305d3d6b5c9b6533a8ec7db86901b5d491644c9015793fe3c9d4231ecf4d738c5aba49eb4a233f74b9ba563e4551c560d26cf9e3babd2af5e4d5cc9c2dd96f43cacc62ade50f522692d7a4ddc9659403dabbc41bff86eb6a4fa994fc47996e7e9ef722c844a74d732ac70ca9aaddcb2d2f8648151462ca65bffb384739d0d674490b2672347b02ebb70c66d2983a9a3ac799a341a7675a4b253f7292b074ec37c5408c5e66134625ac7ed5e857e6300481308899f1b7bfa1ae93ea0625ea82d6cbe599941228e703fb87ea8cf1407b8f749d152d9682720ad5e27062256a410376ca189bbe64f6e3109075d8051fd04471711743b01adea683789226717bad25968dc03d338d73f5344e70f6c9ba9c15b605ddd91687c6eda54f3b7906ddfbc0db7ee1f5b7d670c4c3916fe4a0bbdfd7aa6c196b9ac0c2df03e397c4e7f3d837a879f8c263fc197d72abb2e0be4e6ec4e126efb4eb5a692af0dab451f2ef5423a5f21516450ccd0bf991f4ab920d5d0cee724738515ba6d23e78fdd47f78f3593ccbaa39f7ed620ed4367f47a45662f0b1d1a9e7f5d9002e08480c9b1561ca3e7a52d8e90cc678f7cb20919b9aa763fa3d4539509248ac1517a93b00c739b26e79530979a6ff5c047c2c3572ba3109b26ff986e0f624108b708164e9b137d87391e912f6043085ba8ab0846bf06009b7b640134aea42881711a271c313e599f4d11dd453ae8c8a03ec76486447c61827789351c56f7531ae8e50d49baad907ff05ba545629726927fa779b7fb99ffea33b96cba7264a6c9eb2e516195f420dff708249f814315c6cd0aa19128600f9e761f36871489e1377c28bf99bf0e4bd622b2fc49ef49446bfb3b9565fd4372797b3461be26d627794107d3aa3cba5961596cc1b474c90c67f3ffd8dc395de767768d28931f8b324e39675212b631c98a6f6564c9de012a2d9c4eb871c649d3fd320b8d4ac4663da445a04ae8fd0c935bc8484919ca10dac16966a2b6842c167ce9b1d963d5c739927accdf9dc83fb53b2e267e8cfb39adcce9c74114513eaffd1109a2b8e7dba1b730525c7cdfccd75bf06eb6bc393055dec2523bb93e240df57f4d15f8cd40c2e934ba771195e8c042d197ce8e48d57e6b92f051406f597b23b7ca8c281669a7a485272b9223867af19993c72397c882e12a95e2404a1d5cbd93b58e4d29e7ebbdbba36965c55dff1c73ff44fe3538349aeb1262bb5122834380a1cb6457d53b86ab1b14fd5c6b12cb99da96d64e838033ce04c27411b91f4231d79186ae4415aa80c919b62715725421c8b2168ea5aac4a93363b4321fe0a54f10aa2ffa95fd4ad4037aec97ee7d85b42cd4ca365e16af3342fb787210c8ec600cb98904f50a868cd100a9c758d6fac0200084263276bf11c9358b67778f83df35cd480d228dda9bd95e68cc0b98debb992c06f3bcd1936b4c7098002e6c66ac634968d8fd4450b458a41a9794bbd0f43f5e89ad9381454d1a5953232b5e1e60b2ceba28f5d170843922cf8e71fc311e659a46190262de3ae90af05dcce00fd5cdc37ff83230ca11ff6fc494d049bd783a25de7be1dcd7ba16c1fd13d0760072d174da739767c4ca25cdd8b1ec41ceaa03a1cd8735cae6e469c3ea6075e1d7093b8b3123dde2cbe18d8f90787863d1708a246168692378970fdad2c824fda7c5c8a8dc38b3e211a2c95ec3857e57386228c1457ac9e94fdc66a9548b2e97408eca5a138435faaeb1909b8e05bd5ebaecc1e0e077de1c43c16354bcb4f0c491b9bdc7013bd98522ce454637ca730a23379a2c5c6c2dba9f7da9ed975c1015c501eebe064808f7165900408ef32cb62099beef870dd5217d2c7726a39c62298004cc3a900960772fac85a664c751a66b54d77b71089779b45d1e4bcd1fa3f162c703473e68a0126ecdbdbfc5ea01a152271a17d613e195c7426d2024acc25dad7fbece1693daf16c0c8f14002c7f87801035ed2426f1f760e775e43d7e7ade9087114c57eae6fe049a73b0d75e59537d59a2529cc097d7013fe4269ed15898ea26c9940d9431a051293ec009d0994d212ae9cbf92914430c16b1b564db8ba6df839bb5612a97cefe7b9f1eff14876003513f7b84ab40c8e076b9923627c7ffcfe5a80a42a0e1613f9fe8117608d179fb11834f51fffac04d616ea90e2755425d04991dc5aff7a48e33e8800f3e68e339573886b0762c8dcf848d16e190566c4fedf31c68ed61843f7619e23cfad10efd175bef4bed4784e41444e8b7e58f6485579e6efb7f6b54b5c1d6734a9bed13b94d946b2b9903460713a43894753b8f7f524dcee16907ac5e82bca219cac761ed6da1b9df34a652a4d9024575504549ce7d930f51db1d70d7d00232eda599bf7a49c12099945386c056d113a749cb0db38a6c634eec31c4be1feaa21409062e78b17a48fe14693b8c9681b499a26c00b92df0e24960a9420e12c086c54be42f0d69fe600d1fd7f54167ddf8415baca02381ec943373e04f46f41643b5ea5f8a1cec9e744f2fdcab95ac91a96ab7cdaee468caa5329ed483c42c5d4767139913c530946933afa7fa1dd32337b1c3fd947e274c54353b8d350bd48d830abac1861a5f9e945c18ae90f041469ed95c82ce0e2b5c834e7cbab593cf406026454dda2be1fd9c0f8c06ebce90dd020f32d7bb8c295d417c4c94e45b3cca89b95391df853d187436f0e9fc00aaad777cf70826f31627588b827ea47bed4d5a074c4de74cb035a66f622e60dc76e48ca81bb7879c0d67f142b7402b05421274a318c38e22a2b6b0c2bf3b0d78cdf7392bfb0b0f5e3db32a4f8b6889ff30a1bead8cf4ef0414096198d72ae1b09f06a4bd92b9b8aa1fed895e4ebeeaac2072daa054ab562e747c1309898b6bde49e8d9792574ba76c8d3ccdaf17550d9af2ffc5e3161e4b21dd650f3e10fb21a66910aa508f59cf8d294a7d9670e8b0d9b2e48d3ba8ccb2f95bfae70dfdc7d90b589a1f239cb70d812f05d6a2a547509ad9ff344471499bca9e3110b167a019470f5b4cbabd9fbd3a8bf8851c4c985032a57eaa4708c56bc4674f0cb81b08b8ef952d046e276245f2e83474053b102cb776bed5e370c95e98ad5f0f978938d8ac01e9923b63d7505142d8164f7b20df65fe780453c5fd46f08f8e9bb8edf63ebf7175dcaf7284c29d619e8a003d49978b5707bd06c91fa066a40c4c3556618c6364484f92c6e949128a970ef8a5c2f4a379e3d154d74a2ee7c4039b09e3cfdc2c8d0ebdb769055b59c32f7f6956ffa27e2d5e746afafa51a0d9369f582728ea98cf646992a6f841a75949a52c1190bcb8c10c5989eea76603dbbc17044ca2dae8b81ac1664f136c0674d0a4176a7ba4decb512e9f5e73181d73d392a32c3e5dec6e057c2977e6e94c58b57229ff33362994db739acb985390d95e4174c1a433f986bae493233ce59027183b445f96affafcf0da1a2915b4636f5067eaa0976cf9986a4692deffc588f86501b35ba8abf2a042a2f799495a7b0debbaaa930cecfd0641dcb648bec7f647ce51a9ebd759ae1f32ac60127c4a18e35f67e93ed03931b1135c3fd77f248ede589b12e8177ab0b9819fc43c1dfd736b00501ac6cc2c5c46fc4d4df31d60b2933bab70a90cdfc36e9f519f8a5508051198e573ea730032a716a9bc78b95c556ac98ea840c2c9bc6eb2b8a54710323b524813e847ed7591e826377dc79586f4e532c11bfe53e00077aea9098b01dba222c44663c4c0bb08d22403f6afd7fe64aa0dc04011c045395ff6c43ad87d04e57df6f3b706d86af6190c562714dd3d233d53d7274e26de1f8664e0f09d8d9bd4e6a569c7717d9d1fa2863bad1515b34e21136e2f403ccb10812feb456d2b987d7418f4f1aa62d353138b262856ba5860c7fe018a94623823c8118da5ae3c493d3678db7bbeab98cd03d801c1e6c2bdac7a6ec243549bdb4175437c0a0bbb061ed3246a48520c929ddff9f0d2f53b7bc8061b6f2d5a40ef606063c9947b134aba106e72b1ce83d3f4507b13ed0da6ed60d086519dcb0daaa4e7dcd1bc467c781efd4dc2f7071a9f1c48e9e348606ed7c7f0ad7f1bc9cdd1a42380a2ca2a223c5afad196d77a1efb5fb045cfca71422a1e8167d54f658a24daca8b9cc45e57a3c3039e56c828c08eb4fbd6d9c0e86e92271dc9d41b4e36298a4ff361176babe11e033cf4efc18a33e11b79fe4fe1186566cb8314ad3381a2aa555f6796772519d008f0c7a0a3f3cb30cc1be60a021e535faeacae5b1830709b232527ca5729f9a74c77e694b88ce4aec605de323a3300eab9a3a88a8e47c026625b105a3ed3cc2d5a49b511e6b31afc74c21c6350aa3e06e83282faa91db0c4952603fc07188b79d1c7e79e38c1dc20f075714da48bb0baea73879f5082879e6d53caab206cf9b20c6fff28a351fc9040b62c675034aa536c8bd860858d0f8f7d02e87a7659c725f80c645b6fc53e4df84c0aafd1fb90e072065f35d21567f75dad406e5c27be1d34db95d8f3edbc1f7a0c7af18fcd4bac1396f54631fbb4e71403e9347f6512f839c07fe5b8ab12053ff9c70187fe3c11da265386cd7ebc008d45e682a19f733746ea4fd8afe927c33c768951a6b4eaf277eea65d45d099a7876324860b7e6754ff4793e2fe800978a3dd16d405539b4bcf55c477d4f7eeaee06685ef9d58c8d940833eedb3e37ca121bdea5435a286cef89c5caf93af32e34f9866cc2c36ecea0fcfa6adf5be8f79d2a0c2a47d3656ef10b99f823811329d53f9c389ed1c842a2fa1059032090f0159fc907dd14b56cf56fd029063bb14be3935c48a0eb0f11af79db3d4ad3bdc955513c30954fea911607e683d4c85c9235b49c47c36aa29e757ba990694529fb567624ac7bea221d4a2658553317826ac94fb9b84ee2428a63a44fc49d82bcf3a698c26c8d69d50523e006d11a1b0a6b1962c15327fe6761fbcd15dec4a913ac14e1b9702b3a49de6bdee77f9447fbf4b882d5c2fa0132f009d21f189226a569f804380782a8e5ae0356a6c102aeec7698ab21a424a8bb630d53fbe59bf59a242816dc85e318562ac5a2af18046e59bcd3e4572d215c40225a553656a1a69b5178da5751054bb3ee032d47a0119a076c14a00dc219a9efabbafb22ce45ccda006114e84157f6f7f38418356750440d27eb3d8d2d46e4ce6a400c9087cf7266327bb8df6f72c5ee340eb6cae0631a2e612c3e31aec4d18d3dbd4f4e5098807e5e450e6aed8355850a098ed9a15a1a7f17a47bcc7133a72245093f2537dfa5693649b39a1092654bc595f643d67976b37264a584e4c48b83c68204435cd5f2b8bc725d19620c2bf5e1c6fe3bb5b128b66f4bb85abc4232d31033da9d14011435b647bd2a09001e0d72db52206c4d593e06cb185ab66a3202bc6ebd212783dafb86ab723eb3bfc814b25d7fe1f5fd493e9d84c8fac02cd5efd59af590196be0329215a4affe0f7df4ef34f5deecdb0662c37984629ae243e84bc427e4a83d78746c35069859086634d7f50d16352fd04f1bb60615c8bb95e267a761b7c23d5b2ca11d9852f50c002fbc6a929bde281306572136ebf9523db25a0a4e351b7f474a26a466c0621165cf99ff5f4834038859bd2dde1a51b550fd7e13a4ca5bbb65af08a1c655b119da5ed6f17af5e1a9138b87b3fa1bde5391a9be222d00f19692f39f975eaab1376002eb85a71ea2aeda93345b38c1f6e14b80f7d4201103b2eea87d3fabde3aba4fac24083c443b13d6875ddfa0e9f60704421d530378a84650057db3c6d2fcd9b944b435f0ffaf07bbd3892d657a8adb547d7dc9412e20e0b065bfa52e41f19f4367ab7b9876a6616046edc90eac033f774244590a0c614d406dfcddca1dc451b012b930d73a30119af8772c187ff739943a06f2b142988dce42994c6b8b1e6e4d0e6072ef3656253c9e6f0192ba6e32087d936e58d8c050800d0ca51afd43a38728af499fa75c30562513822600d914512d7d2f7ee3ed9be5336fe8bb79518b9597bf30eb426d52141732b7126462905c344590cbec83614d95cfe85f7de41acdc80039f2672956e2eed4723a082e7664f0023a3ff2da504070120b310b919a5b18d4e1a6b68e3a0c287bc7152e7011d7f9547b0bb8b2325d51ba39dc3876c3a3a2d9c87402c9b51ca7cf048046f90eae6fd4f03c207bdda40e65866298f6c209a14c88e4ea50515af42ad49c281a6b44f6399cbdfffc11f1498ee5d934fbeee3a2b35c745e6e7757435eb6d89b699c0acb8fb00deefcc5b52c29cd00de92429f6ecc6af2603e72cee8942f664dc0c56aa4500ec118c6570445c0362b87de42d7cda232a5ccda6990df9b06848e88c45d37a7291770396077cf43df263b41272a0a681d257a2672440bbd5b9ab00ca3cd61c86877902661bfbf21fad26cfc534ee1f27dc8268b488654ed331e36913f622263d006493b32c8693e1af9f441e78a49e4b375d3f8fc91f0d2bd331f155f057455f351510ee5a85031c69120c71f514ad82af8285851d76b41138447778ae5e6cef87d2c964687a4708d335b0b2836b5959bf59fd6185f29b32e76d9762eafcc73a6221a95f977046003b14a260cba00fd42e9d8cb5fddc648779ec9d5c3f750a593d149e396ca8811571f3e1c26a1824e9c2ce26733c1efc2988d347bde712f40c8ed2c984ce78f559d802c36e480d17f1a538794e4f6f53f71f652251ac51c6f1c2b993b9bd9ffc43cf7073d74f8cceb39bbf6b88ab74651344b0ec3d54b7bcdb81558bc610250a852c683c6bc4296153dcd2e237fdf0d401093407c43b92106c5d92cd33593d049a8f9117c89dd9a72f1a4879bcc05ef858ebfa7d505fcc54c0ceb36c8e590064d7cb24836a46058e00b084a4c1bf150f75c4160221396eeb041046443b40a32c059f6a0114b4547e5e9fb664c3d9ca9c38df011cf703d9d6318a8fccb8b4774eb3204546a2a02766cef0abbf38de52b43f1fee9e197fac32b44b9226374fbff8d22dca386962e23545dd4fead4110bf0b37569a5be3cd4ce38ba104d4b6e131bf70a12658a364b831e65fe3a2a39e72c104b716ad0631e3a55db26c68d8f6fb54bdac426c5e801b45e33004f1f926a39d17bfb4c1a663c8a66a7ea29fc60edf4aa3ad483d323fd6b25b6fbb7530906ecd00ee386ea5e06d70fe32740e4080e0cbd63a9e0f5294d0c15d72b5b0260b9185278421baef19a5cf6b841118a3a103dd52813d1d10254369d2ee22f2b0e3814d23b31ccb8155b9799d21d0548bb0b26a86ecb452fd62e58de70bac62f1c1e8e40abec30cbf5b36c7c78b51134ce6fd53b9539e2ff828a57ab83aae54d9c6ef589208a2d083c98020214bbb19567eb58bde35c71b9cb135d67a98f2d8a47cb7c72c096c5fee6bbb9bf808a6d8386c5d98cd78cdf5a121e9b90226bfcb1895334ff30b7cd4eee409fd2ea34588abfe5befe1ee8ba0a2f2e7644af784d41409562c07d52bcd947e3598c9e41f2e4bb704dde336c2777e1be77afe4ad061c112dfb38a7d85addaa07c99994bce6856b0e641acfff1595eaa491a3aa1d0d5f2527d11518a76cb1ce72fa8597974cdef73712e3396a34a68232cc13cc4fd4dcdcf9763c4d49873fc290b42754120c0efca83a35173a4c4e0ccecdccfa07a2072380c1aa26cdb6081386e06b591e58676b6d70984afc1ddb813d0c5a347cf495360b749a6840f656c5c2d19e3a5907761e1fe6e98c2c90d2a93955ef629146cf2cd435eb4119c3e80f672bd7521a9746adc9e95e0138dd85c9f865370ee1b3ca6ffab6320687725abd7e9088e7f1a43494a1009946eeca3044138aa5d0d35a264266a445950e3ed1d98115a70d857e3f901f408ba997c3a34f86887cfc108f228092822b6291434c105be1105a7f5469bf57d4d4c10620086edde3129bfe11fb2a10fae648650c0d2408db41aeeeb3cea96db0cc5f40e83d5a43d18975abd8e653ad65c1b406a95e4d5b3c3fadcd57a1399105d74540f4a6b7d1e773b1543a3ecf88c8644542301abd7c3cfa48969085c64e544b9de80bca30103395a2d18dd9139434d4e337bbf448eb47d07a4c24dd87ecaa892087b91096fd411df220ef892ce4c651ebe595198239b8eb6bf625ba2d7f94af092dbf3fdb6f7af7efc74498e133a6d63a9700f31639914c0e020242f4f76e6d5dddf0601b9f668e4b80445d166b540078a59bc4d1d686128b5048756cbe3492ba84b94782c8479c61ecada004446c12a15251b7993872869a317fe29a32362a590a7f1ed553a9a658add87f564afc29599eb7e9f0ec2843326a83f2d0973b38e583bf3e14a865bd7330eb82ffdb5c5d32e551c155a864f4f4140acc60b3c7183834fdeb0e38da070f6b04c84aca91a3854760fe8cafbd8c590d210e95e3c46f72aa18f1ce9efd96e43cbdfb8ebc8f0bc96d180b433d51f56e3d75c878a37b2c531072452d3146c08ab2afcd789cbdbb0fe71e63f5c4ec2d70ad20ec118776c9233015bda10ef24befb02b7c3956136f921ae190133a67d45c2b59983b28eb98ddc5f619a720e1deacf1595ed3f20057a4fb339d5e559a31aac10378db61da54d84b75888e963d2f2351c2e443fdf3e2b699ff1aba3601ecaa67f638d66ebaaeffd5f6fa5918f4b5910b5d7065a7d6c9986957fb6a896bfea93cdf0eab725494cd424b8be39edb3c97dd2c4517db7a684e8148d25e84fb5e9ccdc0fff3c9cad498d49384726c5a7c187df5f4d4f05fd6c0defa1d915be927c17ee7986b14c2dccf4310b69101b28bc7767eebd057bb79245a10d6820230bb34969e00bae1f1cd2621887c102ecb4c0f701d8321c761f573aecc752cd727867d6f787cce4d053cbadd215425bf9194fc0fb8ec4c789301682e7b2625f674ee959e48f4c3143cf2fa408d91565fb7685ae07d4bcb5e239e7e5db84c632a7d508396b1953c60ad5203e18c2522e91860e8f552eb3ddb5a24af501bebd12ec56521a41527b86cc92996e62c7da116505f3d1db2d3cb3dbc71dded00c322c80015ea3334fd204f8920b187cd167801d236e598aa61b757f5201bbb41cd7ac3adb3d05d5f25b44e2c12d1400fe26c1386143ede9891fffc5378423c7634d2c789d50673b04f12b0f39e489f5943d84c0bda4dfdb4d84f98651ec17c9439f3d1df8e358558ed6d684951539f318bf59cc96ea4431475eff47823f90b45ab9b346aac331338af47a1cab24e618a9a2e452c6e4d6d2861b4b5db6db4d6f92bf87b7cd796c9006daa4f14b86e41e12ec0a283040dc5ab22112c4b976ef35bb40b074083da03a631c55015f4db1a211bca2108f71304e4644b02e7b469269b23eeb442c34c1831bb7efb8239d18924f152c0dc7c1c8170ad5fae0661acef01d31478e1e799276075eb707919c4cd9b77e29c7cc58b1ea10ebf96359e371ce65c819252ee6b5a7c26ff14f32352a9c036fab11a8970a58125cc37af55e635c9a1f0ff3a9276eed9d163ab229cb7b3a89be82713102a239a8096abc8175902bdd2fba9b050d918545a2ec7ef7903a8d9d6722f8a7a70f16d7c91e099b9d3dd3642a878d254d8649e3a9fcec1be8c152b2f95e3b6ee18495d63426ee8ea4f1d16a58e2904eb0d1f35d29f1e2313c01c9271a6416ef3369919ff5d6c0ce867f6665e76cb8ab5e8ba8cc225d7b7582fe2d8ccc2ca91ac5cd0ba4ab2b875d6786ddec569c04e1371841f48a8cc1ce55f88e8465ef3c6eb7551d50be105001c7cd4b3e9ea854395dd20c92b99f0b447cddd8e0d778263a641f9711b060f3e4bd8ec6da6c4ef600bfc374dcf0352f2c8391c938ca268b8dfa083c148d9613770cb74e6ac8fe555f179ec3878c01328aabb09e0f3997982d2f67c4a7af23c17712842b8bf13f1a0cee12b328f77f784390b3caaaf9f054777b96e3ff088cdac68859a62beac794f297e9d3ce11319e64d83ed532a82c026d60f326340e749063c27b418cd63f8befb2bca62dbafa13408c1c696b9a72c311e670d2a3c9bc30131113f106de054658d17e9c0864d322b7f91417a912b0179926c365982d1e49db3c612cbb282483c37a057c7f3b85195e9854032c620814d9df8faf1d8035b66a07ae2d57478785f5b5a20902d400e8eed630adc6237055203e4f584503b87549b6532038efe563e38f4d8155b66f3bd5f0a1709ffb67ae973767ae94d440b2fdd0642a5c131f68d9f4a664891250030909a68ed62a4e0543a43197c5447a9a5546260b16b86c7c8365af7df61d88be2a809395ddeb2e822ac113ce154ceb3ed23797966a86bfed0117bf10d215e2e3436fefb97ec98d7a0715f9d969737aefb1c58b9906c893e3d943b13400e1cce46af91227c8db87aaba8ed4c3e9112f5dc408a5fd5bae1400f566820ac94bcba021c5d8a6100129fa0b52b31b3f659482cb9934fa0fae5e88f77003d99add7fd0818e89ef30e607ceac0beee334fed1e85eb27cb55ea2f9fef64593f1f7803fc0d455ea38a4046cb4dc577866dae196e443f890d46e60ac035f303fa6aaf61d5a380818004866f15b23ab896d3afc0014e4c5970d273d7d2de96dc39fec369c41ccf4a6434a0e1aa2866b562541e34aa3a969b5674d5d6008e2ed588ad9de960d1b9db38f5f840cc8cfad8559108adb337d420132f05ce14a7e2dea152586528fe4849cc9153b00e5abe8cf1a379cd88216700fea6798c63e5c794766f7b2f622e0c4f2f327c517b9e11d966eb5528bcf8348812fea07a689d5584b6d6c102238d00e31a3da03233523277f09ac99ea2f470d054c3c319c74be592b4244b91937565cde865d4241c216c99ade3b71ef252632314b2bf2ede81e1a4a2c12cf6628138c245adf6fad0293bf17410eed6fe3b8616c8c1f31c6cfabdf07390ab97a440266f1d87a060bd1d1086769d570d5784b74e4d1449e99fc6264fa06739187dcb0e698e3bb454a3b683afa1d79b798a05a11930b512a4a2cda5d328831f201bdc70828333617ccef2997e1fd0ad80832d3149e82c2aafcc641fdec479502b5726ed313e0a21d26e2ed8409dff6692351fac3f7ca7b935cdc029a70c3b32abf4dec0d8665fae526d55f173e0537c200f9c0a7f6796c37ad6757ee2f44ecd8592cb59414734153ba38c1e4b0d3459f975d614c0bbf5ddee416d7fac7b0162f7424e422c6f0d1f501ce1b01a1d9535357874a5f25db7168111f49c293aa480438ca0f13e9ae74d3913ab4bb2134531cac3153256bae8d6f8de59daedbdd252ca9d0c0ae22e49f56981ad64ac6290c25de36d78a878178f38b8a803160f39795d3db220b2a6d617381629dcb431ced5efc6bb7540f6724cf5e12e6f32da47a44d6e78310088b7581eda179cff6b84475091b3f651660ec580bc342cb550d55e4ac158979b6d3687144bd0698aaa523b691f2a7ac6ab293a64974ec42672769ff0686521a184dfe5ba693efb72b00dd0f79969a562cd6a5fea404b5a79103a474e618915575efdc70c9b0c3590ad4c9c2a02cca3756ffedfe0fcc8f7ca93705c10afcc7c4977784ac0fdbb4d7e9e029c8d41061e25a5623dbea381ef8d1722ad183e184fa9285ca746ee05c88d9ce06268cbcaaee909f893327dc8a332312183662ec73da2936e4e553b13b6bb0e7938f1accde719d4489ae299b8932d2523271fc6fe31de4dcbadeabf8a18967ed3a2dd11b662cf550de983069475171f90ccdb87f36f2e81fbee6163f7688a73e651edc4f73ecd1814c2ddf4591a5bcd566ffb3b8d1090690913a8e293202666a18cf6fbe76e532ad23cdb411e67ff6610b66cf63f117d759cf5213f8494c35d95870afb9d5a48702c7a3ce227b0a30f0945f4f71a33e399bc1f522155fa190cab6cf66dd19c5e5525132232e80bce1fb3ffe10b132d37957577405c29b1ea50b0cc863d8a6d761c68ce5121d6f9108c2b888e2f6e6f6bc3ac4482a8a524457dcfc5d603d70d2f7632a81d76acc64254587fd6e2da1ed4191ed6674a113c4cf2eba5666aa9699c4008598d8b28988cdd7f88ae30255ee9a18e56a60f45325de13c3866968d42141d68c0d3914581692128bb247770aeb2c1e1b9e82844301207875bddf28550218bcc6192572a74d45028c9d9bfee41c7a73a87ac154939fc36153941fcb2aac34d0939f77be2070a499fb5604b2f2e77f75492b4271f9871d097b0777d452dffd9240773c3297f71d82d86e7b8113fbbbb3598229f596c0472cd84a59e9658d0fc81143e8867092c7510f608f4001e231b0b7bf3880f996e0c83c413f801349a2d81e2a4017c07153e8aed30a55ed840896a6105c409c8c4242e660c362c4772332a30108ce60c08fa099047cfe1243791ecd45a925fa68a7a586cbec725b316373cb34d26e9f56889804d281304026b894dab96151512869352f9619de06f1610a548c01f2f927bb46cf57442ac0336e621d3983a755c5b551a555a637f72dd76857cba63949b253e205d3b9f9009d1d3a4c7246525abdb5880800a5b8e028e133a75b0053fe7ec805fefd54e7727809997a6a433cb736822afa9406f7c8d6deddd938a93e42d4289e7c63fa7a2c2280f71066c763de4f1878f671a49ed22b20f91d1f4200111c5f282e9bc25e1ded2a55c8f0ba2796f813ce77590a34fdaf937db15227f4bd18c117d448d837da5ee99a287f20cea2966741488d17f7bc0ee6e091a6663a6d17e2208d557f869263ff20c9bccbe6066737aa246f7c07d1f7971030cb67a9e3fdd24498b3c20332be6f1fa7a838695f635e4715a03a6cf0175099242199417d4d3777bcea2a0b68ce91151d7e3980c103bf1b6c6b7a98a5f8a8e81a108629281ac4bd8c256ee9b9738b052308659b5517415a81c379e9cd7f26c496ad4f291f5854e40647e26562aa0a83a8f0d4aed6bfab02dc2f20b8ae5a329b5ab148f068a235e7088d7c9eb924fe3ed9197449c87fca63a459effba2e54c688ab51e201bed0a7030722657497567df92937aca636d6e05cacc2121d8e7e972fa3cece9f3ccdb6c745f7b198522cd419a26b8e2d0999bd549d82483d4caf6212ca21cea5e0a651070b38b86d40b0d15ce6683b898b284eb917d9f80c953e5146150af0947312a633bf6eeeb37600d6a817f46f6a64fff0d2ab61cd140ba2e781105cd9ce46dce604fbf77556ba50088241edef3e763219d395820d7e4bfe59ae741a86716fe36d4ada80372f61bdef52dedcb9602e4f4575c9ec0877dfab8299c716d40764e92331f154f44433ab697626e6e624ebc2d463ba50438735e2533f13c05c3ce02b57e79e7742388562ef6dc4c677e4e85902cbe120c757143d5c4a00ab3e57de0b4159a856accf3a822621c27cb6f7c21956b75c1d0cb7fcd61e8211fb7f7460f24cb2c845115796aa4ac6a8251225de12e1eb5e6960208ea6e35523e514a9820231abc0234caa98fc58b4306e37d5aa5deddf82874d5afdb4376d9817b89310a621ca6ce3f4faf6aad2447e096e6fa60fdac875a449aadedbf75ceef6393500718f39877415e0ff8770ed027099cbaaff7b2265dfb69c31076a247d1270eacaee3dc5cff4fa7d95a5f4572742e7651ac5070ca8ba7afc525a7363171c023d503515cd7fba9d89b18073806c9be0fc9fcc4b73a971f5cfb5a597a8263350070884645917c4fe8d7cc35a15fc15b99f10b0136a729eb9c148b016aef259e6aa3350092939a7ef851502594c56df554f0216b9c7be5df89d84401a507e1f3b622bc74f4a162ecdbd5305528c1e60249441df1d5d34d165be44adafb8f52062d61dae1afb1ea43172186b4551a8313c29f8a3c0c3d0e9164bc2278b4e20349a5a9e19bb0011c7a59e88719462068745c181b156acd0e491d18a8e35ef4df7be4327a7e7f49ede2a6156ad8c00e660533553156cee2a2a25e0fa0f53f76bdd08aa376361eb49153b2abb9be282e5a53f0eda8fac673a9ea0e9f06d518325ff582c5aef9f692261179d07ceb0d3d778d6b37f49297154eafd94c7603ac70401d9333fad1e51874ef0a2ed1b4262e1d81fda34dcb3addb6df9783a5bfbfd233a8414a1b0af7f8f759c13c0ca72f9bdaeaedf469d6b5366bcc612b360a86975fd1609020beaf52bc97c7204ef9f826ccd4bc1eea8add9036f8d1542a2fceaff55a1510015b6878e3e711a96987243bae336835e6a668a946e7795547929b3760f979d29eea88ca0463ecb57de54944b1d26296768608154745df7f95277d26bd2ce5de45717d5e3e092613df445899b59a8ba9f350494aff3849f041577135b7188bdc365bf5682c11f8b742600e6722932699d3135f07631f4d27a965dff8324394c392d01bf0aa63641ffa0929a41d677c49c74583d3945a93014e26c9f9ee9c09a7041fdc463a55cc4410ab879d5734aaecca7a75a312f403213da52b7c2204ccdbc2aa401fadf1913ff3775564a1f1f04daa5ecf66c853a43652dc84c6937ff7dc1bbb3ca53f79bc214543d4ded11e7b13f8dd9397c6801d0c622c7a556420a02fbdf767d4e22cd524ca7f0e5226bbcf9dbbb3a7454ae384004f65c4c2a8c4b307c9e606e1f58ec594495b3a80be3f80d5fea683ec39bab16d877bddd38bc05a164fa00613fb4378ebf7e1e289577d7ed36ef5d75a0b463169bb8cd5190c1856021d73e27a0d00d051925018d936f4b2b9353733dc428539e0729626209ff36c362d470d75fdef1362c89c6bb0f72147906d8baa4e853a4644f2410b145cd399a6d715386342661228eeb9043ebf00aa4f28bb13073e1fa0ee6062d1e8415d4241f2205e3f639ba8bcec02791fa4e0f03379eb121c5b6f506fa148d256dc2f43b262b937b3848b91eec7246ae3885cbd087e4a38f2f260b78aabd8cf2073c97100b2048e46eae6ae9b1201077ad3d4551cacf4de5b35f4877a437bd30c9d791411a0ab921769a078e006c7f794cbe583a2f16c39aac6a123b9495d72b49b3b7038507c2d363242cfe7b478af355ad3b9d8dc256a2f26bbf235d2c1dfd5d7777a28736e151833ef81926aaa8808ae85732f119dce5feff546915ca7c5f6e5ac99d042f113893b9d97a9ba5bca9899b8dd3d0898685eb93281526980a7dc67398b2596632b1c4979a3701f39dfcba3aa873105c4919aad9f04de3c99c2130c0d2d6aee87a94194d583e2694c9d2ee000011ee36832a4dd4b90bab62e7d1adc374467b1ac6d4298873f8337c9991435a935a204f3a1ebcb63a7321cf70c275d7b4c83a5485af5396561344034d0e7d3fdd979305635c5d3a47732c72400d9ff90c4ac6f9c9dca7e087cd754da73c821cc7e600d330f2169a38d60a740fe853a5d4b67ecc676fb4f26776dc2da24ae0a52315fca3313344630b83e0319ab8149a84507d3cf94d202e2b4b84bfaa125f140d42d2560ad4a237f1f21d13d03e4cc5f991154a67be8f399aeac60637bddb116b10d3c6ae2dda319bd18d0d406bbc32e7d21417ac145970a80ff3e9b379349efd6e067b731cf8f768f9aae70c18fd6f8d3c4d99a6dbd5dc2137102bdb7db67f4a4512fed9062cf1654d7f91da65d67ce37c9fc2d004a7d6bc3420fcccc4eb1826f0a54927263b057b2c336d8e529099981554a9fc31b240e56c2c38d4d72984fbcfae67fdf9da7ea5df22b7342b4b5f0919495180d71bbaacecf41d55a151df573673a849d871ce71fbf07f490e4aa880d3887729373d456c2c753b4f6806c78cdd5275b2bb68b44a854fe43527050c4cb173eed6b86ae0016b7448aacc8bb93b07679c3b6f38e40ef67550d9a8679e507f8f5016730d33e9a16a146381d6dab6a14851f1d69bf69ce828a5f427359e705895f96aa56c9f22e040c978d1bbfe9f48a0de77ad9c959ebf69ce36caed5b3ddab444f3b24f6b4fcb7eca94e2c4735756c637dd8b579710e2ff57cdad377976b548fc7df8e29bc62be9da685","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
