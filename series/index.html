<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5edec8a8e66a72a2c1a46017a4705529c9c9188a16ee8ff7eb6d11724b3061cbe49d56eeefd62369b3a5d85a062444687dd335f44db205c99dac18c547cb9ec42ddc07a93c743b5f35a8ed8af56d5e396bbfa2bef6a6f5c37b2313389b1cc7a5838c23c9644f5f2125ae5890a0bad5f94a5f8f4d25627020350775de2b67146dbbfdb2e95c399addd813a6f35615e1fc817df09c19ddcafb1948ecfe3618bd422d9d15e2bf374e25a3a59fcc3cc914497fc09996bb8991aeadf49ea7034d0e9855dec88bc6012c5fe0020d65a895f5bc50e1e6c57d599e4df8fb0abc2a9123cddc0468277e30c75157c79c14e184689403fb0c7229563d925e675eb050a3b2606968995b6d0473a2d220b65d461636841ba5651d0cda476256b6b248c46ae49696f7f1b04597b7dfed49d0ca2699e1846626efb0a220c91502310ecb22b7e0fb26402e73afbed78ed501120ec6cf4fc11437ffeeee52d343e1f2805b7c828173b782c61d4344967546ace8dfcb116fa6dc3774f0377bdac39a6e56eb9efff2df9b8ffeb7a07d223fb9ef4458ad1efcfc63ea016f9c341c7bbde066640fad40b518fa53e63556c90f7e082319076b270e978bf8a4f15286a7d291e82a162149ece29b3ecd1dfc07ee95c43be28d700608404f78534bba312ac3d67d79c54921e11a6c07b96c08c9c6f2f1b600da274e1452f10864ffbc2ba452379c30d4a8790c3d3a70d6c9acf73bb07ddf601f642c04ead85ca08d2752b9f07bd2abbc1ee5f1a1998c3b6fc77c9386d3622b332b6658e88578a61e9b1af0b896e9668df3401ddce989cf313e9860d12b2289025f7a8086f25e3de57854f794b61ddc2cf3caa2d5d8bb5675924afa3e9dfe7dc6cea67f5a7043a3e70f036ce032ae6a01ea00b942ab66da9977b52b19c5c1bcc5d637f30041b0e1223ac0a1ac7e7f26e8cc30fef5a182d548aec27cf6a719f4d63f8738a3759bc502dc1f38a5cd76f091edcc444f22f12dbea294550ea3ed75daa4d6fba8f358b13cfa9521a21f35aa0610c084ead34593146bae52fcd37ef63eddf902fb96f24fcc3012d374ba8ac476f86e993b586c7d535609cc482de9e312c40a20d4ad3198f60395830b155b03048f55ebfcee7eca0e9c9c1c017f2e6f1480cfa5a1d82088d60553b675ba7d95d9eb12807d3140ade3806d3e666f66f36d9483a321d3b43a6288a691a67305b2a9ff0a19650f2603fb60c19dc012b7ceafc1ac98e9ccb57fd7788d4783e02e2166a70385e6037f01056338178c431d53afa5c25639e7dcc3e999ae78287a3d4d3486d8969a0ba36046162cae475e07f70b2973aeef566022e860b9577d392ea3f03a367a673b48b9df6902479e9fc0e034cda92547eec4141d2a4c551be96157e07f20f3d7d1d31488bc4b14721fd4c067b3707e59a925b5437ba81fdf0033ffbe380be37cb3a496b119a5f62e7bdc9ea5712b3b5ce979e1d4e1c69380b09802fb2a2642141de39562d66a646dfb7ca840813cb88e9eca504e5b94e23f2c19970fdc03c67475f8980103f6ef4d7d96aa3d901cf586edab24755ed07b9b739d2c2b286572ae40789b0ad9b52fb450c2a800bd3fa950e4753bfd861b2282faf6c5f03222ec89c7d89730b1eac7b72af75052f65c8429d1dcf4b201ec66bec9fa99585a0c372fa5d8b8147cf01bc3a072e31ea3c83db63c1c08515877043bceb04f47e720e93dc18762fa2c640df60b7b8dcfa41932176ca9783cdfbf6a3fbad6a4b7ce31f050059672d385d4b7fd261584ef0853ded8ca4c254db56815d7804827767847c672f1bb944afacf08eb109257dc903f87f7648c9dd940fbcb5df7e517d0265fadb48d2b9621871b27b3cd106d9fe7e8b59d3957a555f6b81cfdb15ebb019e8c4d2d494c6132ad4597875c9421b03141d372dd8d435565594028da7f865a66ab11b54e91a00a17137dfa8c35feaf7145dbe44da4ce3cc7bfc348931265b45ff7aca866b955778d93ee024fabb8ac5077b734467f25cb58373707eebc33f8721352b15cd8fbdb2ff671c7a910da7cd43895eea46e9ead61b8bfa442bee84dd1cba883e44348d7f018c0f241cd0e9f87c1bfe1f1266ae5905c51d3eddae32d113a53ad851e53b514e9e5ae317158df6e3fee63ee82943a1fee611332abf2bcceb63c1de3b4eb6caddadc47b339ef509f8a87857e88dacfb2261c721542a5c0c80c3000918575f7056292d1f2b342460a21c50f1d7318afe0c19514d20c44865cba25ee69331d8c6742c3fa5332fef673b34378a525391186579eeeefddf87f6f839270b5f16566cb0e276c9c821df2afe9aee1acd50dd815134a0f867e592399d9dd962ef08cba3d3c6c333a17c0e3de145c35126ee0d898e95568cefd11ab5312e8954e72fd3b63ed44a5f4a92b894b7253e31feb3a9d8142c8b56e66429e7846580005d4cd2e8f63fec61b32b89fe0abaa9adf26f91762f57e75c9f71d80c49a5fd1d6d67b03f903371bfcc331e5e58e7a1198d6394ade2972ef1bd1775ce621cafece735facfd6eb5445484e07a603a7f4531e9e58df841b89250eb9a26aba30f4697501b77171c35f460311183b7eaded6160c414a2bd5942a9e3887bf10f6a9d173736752cdd53cf5dd43f8de5a11aa99ec3d0fe601bb40401ad52c0a79f99fd6deb1f684ea1841f6a7c03c8b80f3a13ccfbe2f577f7103f267350840d04a5f76677ee526f7082e0f36ca4e65b750f24949a013b272d6b66b9d6d3088036a91c278f94f077c2d7a7c56883a1b9ed58d41e6700df30166fd5f7cdfebd7a09cf723146f5953aa43a5ad9f92d765a0bc1889caa739ec4b2cae562edad4ef2e08197b9f131d22b4d0b93865b806867966003a77c2265a4648f92b446e0d990e571af2e9e78a4adf82ed152de147e370d745300c95387b6ebcfa00ceb9b3bd32300d932c5872a2ec9d3663b14fbf0eb1150b1fd36a9aad1e899b93e4002e3d91bf35a0f72044afadb20641da02136767d5d99e36cdf6194561cd17983bae0d475d38db89afa03f5a0ccf8e18dec8cfd30a86debb89d6894013fc58b05a436a69515f4382f575058dce6917594b802109116076fb94b45e577525c68309fa1ce28d63655a52cd3f7a461d0bc360fa17cd8c671c9a14f48b8e14b02f237066e7023c1ec89f967f9f7ebad141e2f36512de61a753b6f315cb1b19fafbc6222b64d18c2f9ce0abbdb405d63cc6eb80ad1f6b1bfaa1070ed987ed6f00400c71fe6bec227735680dd1e6321b99adfe4792f3c3800dc1d14f09dce30075595f538a9dbffd8466149e392a70d93270d313bc0d6972b91408ace9bcb1d2974ddf1575c2b3b4f71c5c62fce7969aeafaf563957044aa27d2f15b0571243cd1e855f81081a461112f07f8f2dd1a35fc9794d8f875d0a783fac7dacc3a99e254937e070ed8ebdd70e7954b10400a1325e7ff165c28ff489096a7f1353c667f695d2c15facff5f36098e6891ea3d6a47ac10bab1abd97a62c1ea89a3d0b0c49081191aedabc0219fbb08ee3318ba282dd563bc4222ca664ab7650bedfc96b65bac909eefaa1d5ef22b87c929c2822c87d5c2c23cd1dd97d44ac040590f02bde4c26ffae1fd8c7a2675b706662a10398e9c31e25a8362ae376ed53fd4f4fd261d6a5b28f445866e61a4e82ea0eebccda9549987a8c40dcb8dbec109c7805fa0af54bd97e45c23c2c07d48e8d86ff393c59ef07ef2f6a1b4cd7041af70c5b1dbbe6f302392bc99a2d7e8e6c75b89b8456487c8086fb2f1ed17fdfb3bc6cf15c360bff06eff2aec2d4c74588476ad2662d51c13dc35de63f33200e84853f6b31bbf1b2372d803cd35d16001e0434a3870329eed5e1480a5da295fd0d4848294c0eae0abaa0ec65d3bf0b05be80dced51a804148c9855199cae1dbfe3909a5a44c2253d8073db18879901bf9b5aabb319900d32e8a5e36f0da8f17ebfd72d6df5a6fff410cd7974ea0931155af8db2312a799c8771a17b6aeacc8509e69eeac1c5b352a362c3f4f64c786ddafdc1d42dcc761463c8ff4d855ca192e94b4281b4c6b1a5aca084522aff1efbca7fdba273c052c85270802bdd30e5fbd6abffa771c0dd3be028bc03528901693ccc7f62a3e046e5e1948979f12c013e89a5ddc6abbfe4c67acb2b75c3152907174006a1cad4cce6ff1d9ca4bf44e63de6808e4e2e73cb971ea254c9a9651438f83419af99cfe1be2109d0366361a4f95e45a819c7f03627d3c4e965bb3f40edd4441ca4fb45bbe1c4f157c8ca89923be4cdd2db9bef99b6029be069ef7ee398284c037ef22b9c2a81ea86436b09ec85e2157a2ed04492ba5dc39d19243c6496a4b1e3e761892ef8ac30c7b902ddda1849bd6328c7b104c44b0d00b0b02ba1c022109181bf7d2edd066ef55b3bae3e7f41e2859ef057170d15cb4ebd9fbe77112167c29dfd88f1a8c482a64f54e6b760e482e35ae0beae913ad5d360a18563f2ec60c8dcd6353f1656bba0cab0aaa18e1359770263eb8b7503a8380276b5d1b27b484bdf4fb2db8beacb3040ffea755c2517e1fd42e3b15e13c6381c34beff245bc98b326f8d437ddb571e2858463b7ce108cca03007f554910e1ac44fffdb4b0b7b438afc7aa10ad2de5b8708aac28c143e8cf2645cf5f5b2d69ec42f833cbee032d6296447cdec035583b8ae5b9e254d8abfd4a6520d49be0978c22ee7f7f48a928706383100ce4816a903aa459653fd44354b6ffbf2bb065e5bcbf2bf32f92fde4b2db5e5b29a6bb65c93a654d321fdb456816b6bc6ce32874df6ce829c85e464f83377bf44e50875b760e59cdbb5565c61c7503033e893e8922f4f8290c332c944a0aa00cbbfeb2a9bc9c5c6061ad80fc65cab44dd3b7c37e9ede6011f032ac01b62fcc3281d56497560fdea8e81bc498c3fe78baec69073900fe3be2c215f50dea44001a45a7ba878b48560de029226cf874125be1e7c239d68b79cd1ee2c36ccfb8182f5a8d8b110aaab4d096a0b7f3aad712976ae4a492c6c933227627f5d95245ae54c8961793322986373105d9acea8c6f27de4d70f4f01a00fa7d3fe4e8ab62cfdca87105180ce27733afc94fd53dd8b398894599a8ac78c3098f7741aaf59189de45b197a6da2d564900b794c44278c38cb575082311e77dfb1fb804358902fe7fd7fd75cb49e7fbb41d61deae0eb548afce882f6d22418dd2f46bdfff433120bf4a05c22423a3873ea9e3ddb28a3a7d17cf3faedef8b790322ce0eda3bfed42604e5c52c0c4a8b188882a50dc54531311a7b7b0a3ea3fa01006a90a5e431dba9ee67b29784241f22eb015f7feb2735d93d245f34252e1fc2ebdd114d1f19574940dfb222a7658c4157c649af163717924ec502cc47e6b32aa9766f7fcafcb586c5ea2241f772663505e219d7e1f217df0e5d5aa9190a5ede6c03cef675646eb8dbce747721dc9a9415e261b51e60e0e53050c33fa6f4284b63ff298ede18c34e0a43119ef3ab88f6fcb0921425c50c150aa51dc83f3d8f209cdd3380a9c039e73537a35d314a9be5590575057da60049a00acd01c70f4991355fcf9bfac3951e57632edb625b7722f98305eb6470df512db4715b517c5f3e7057441a9c9bb1fb6fe32e14ff6e2ed5e177fc35d16b47c9b02cd1fc31c22a2182f935333ae6976d9286052b1fc3df5d87bdeec212578490ad12ac856fb54dd3cac0f8f3b0899d59c47f878b36bd5eb9df1a55f88b62648fc5f34659b2798f857dd42f81edac2134eb871c19e358bcc9c9531090e8f7faa47ee453ca9b3186612d68679367a3b4765a0761192b705aab88de54e518a6d89b28ea6d4960462fcb4042691175ee0198e706408854157485983fe08022457833dae2de07a66f2e394ff783b2397c5a66b7f114509020b382276b23dbb4af6aa61f25cc459dc1e94fd861ed926536fde62127cf650689325059d48845fd411790bd5d6a1055c106341447ef07455541db7b37040027e7079258e196e94977db854172de90dd45e574a8f85d641f210c422be11048331a2b58ed27d48fe213ac474e84fc42d42daa4d221f12e83025dd4f43422847d68984c192c30e3391d6750cdeaf316a7b148d071470aedbce040493b61018479277f172fed652e66989b8aec577df02a6a33405bdda3294b054c96f98002f659f5b0004dd7c803ecf1be1325ac5745a9c31bb5504dce6a2c8bd388aee2c02d0682ce81ef56482bcb829bf4ae1c9e3fdbbee236d1c625f41ca2fdd5167c49b2c5b4f9b274fc8c3fc6f8ec9cd96aa66512977fcffc325ff7ef05d9ea459bcf1c9c08a9765ace2235196b9b5082994e2812a0ab8afb5cc99c431868a355218c1fa0d0e4b006a1811f3a6af1dcc844fea754855145a0effbd8067b1b4bc073e97ea69cf9819e4ad8afeb3fddb1e7f1c83b0da12331a453d57049310532fb3dfbdfb95dd31954798ccb7c24da385691deebbd09ca3657563f79f90d828b728bbb80b847bbf90dccd95a453f5312b143b4f7b9af60215ef77867a51debfc1fc70e07560a417dbf81e5d97f456644b80c70178e69b67c5940cca5f989a5ef482b066bd9de9fd8642a910371d477edb1349f305ef65c14330a6a700c38e84b4045f2b6ce2fbfefa804f6f6710eac1b2a6dda9945442d7351a679a97e37cf3a015d537fd6e9912fabd51de752ed1ec774cfc43c4c3f08c12239f4752711b15fe6c78db3d56b3e257fe8c753cc8229fbfef4398d25bf380e592e01b4582b14f03a562ca61cf7f41f2e7b88e4e7a8c3afe03ea7d896e5d59f360c8ac6b71314d5b2ce1b179925dc2df51a751b0112dfcbf1e2614ff914b88b65088eb4272ba369ebac56196746db02dcf59083da57c1f75a67d6846653af4638a5abfcf44d2f17e31f2a6d8223e61d4e843290ccb7628e1001e6dbd6a07a2f29b097a8552ce70c8af49f540205c9aed6bd8d5396ab99cd54d6e22898fedf2e3d46abed34b75455d874e2096dfe83df1fbd976236c0fad720d9688b1df6b7a13764adc0d40b3b8875abf8977ddcf2839d8dd97ccd7eff33a5edfe76054c2d5edd601d414d68616838385f93b358c1c5d94cef546eac905f82793a428524fdec13d8cc4d148af23871e1e20ffe0fb82b9797f58ec8edb622578e866bc4c782082f14ed56010edc881829ff724ac3d442d3a56ec7bf7716d364c6abd3bccf23150e8d95a5cbfcbb657cfadcdd5067d9e15442dd9610ef2de2a52318b23571839342fd938ffe5eb4c82a6e67d6d37fa52709f214a68e977f9e395064f5dd2248d6744921499cbb308c3e62a48c229cb10127220a0a1a25e35ffa371cebf5b4db13c414d206c070b57842af4fe8a060b136672f6aba5494821fb832e2030a7581bf31ee40a0716204efd114bf8c08ce5c202899f9e7bc7a65da43c4d322adb16e9a3839272faad896033f4d65060392abe9c8b26167f98c5152561f4497fe9f5568cedbed05aeca33b89b3d1c5c95318ab55a767d21c9dfd71202d6ff8c37c0eb08a8539551d71bbfa2d8eaae8fc6a52da4fcd1ac64260b4de7ab99306dfd1839ab8e5948c13f0301aa6cf3e75321bdd69745c74cb67041159e0e45f79ea56a496753975273fefc245dfbb5b9d81967a6048fb0b0354d9a9f60c92614d581e976e7d3cced37cea7b30e14eef7312423e2c46e713495210305927794210e4ca8b0377b620542fae6583c26f1c5f1f30da29998edad3d424c18a69b824271fb5b55018c9e4b08bf07a110bf1b90b6ef8c3f9fecfbcd41b05fcdb3e267c5958adad6a0a619767e9677428f82c709fa8f9085b40a044ad2c71f8c747e0193ba3f06f8f3c78a8ecaa0f5341df05d10d717f934b46c071e2239a1b9120bccd7c980f2655394a1123a41de40e75069f847366cdb5474142bf38179d8101921ece2fae8d211541cac587b5f7417bd199de5650d6883c4cc94183093ee41b803e34eb9b0cf9f205bba91bfc8c94e2d08cc45a2ca9b3c05849cf5d2262e03b158904132d301dcf0fa9f36d3bc945aecf53f9b669c257067b5dbc2b9719bd8b081d9b8c477b862a47053586ace9e3055afa97a2ea8765bcb644a9f4e7f865840e72118534ba84377605330fcffbce81be4959795e9e3c6729e34702519aa2363dde59124d57e561b255fb038e5d9f096a16cded3ae2c61c9a6902272bfa627cea97a51068645fecd589f947bb37eee40b1aecdad974a4f20f57b228ed7c8e5056e5ae2e927778224840e8234a2108b556250ba8e9be2604a4ed1f157ce8ad80be23dfe5f4af09530410a9031a6c7c0b526bd761dedcf7578ce8d7f021df87317b59e21659e65bfefe2b26a0780fdafa9f38fc4d7562921db54e5fefbd2fe4566b6a0dd12af99f868614741c1b0df0fe644581ca60c9cb5f44dc4fb7d94af95665381c6fb2d3d1d96bc86984fd5d61d7a9ab11cef8a9db2712de3e64d8d6beb0ae78874576832e16c9fbbfa08f52e5fbde733376ed68785823f1b1b15c1b338be5cb7b31bf5dfa866a6ef2a609b6e1510abf9d9c32990ab3bb17186923a08f81e8269aa9deb4b8c4ffb1e89344e03da547670291640fc6b268560fdbe2b58e31594630cda8879abd117258bcacacd95c296458990c1b96a0a50fa39d91474c1801c577623b5ec0bc54e6c758e0668fda30fa7fdca7ae6bd9447219258fc224a409ef3a530ee883e633880f9da53c0845a71b1df99b8dbdcd3cb64fbbec9ed5576569fdc2b09fe0f48b0f824f456003a70fe470a5c6c5dd2100b47f0ef94634249b25d63e1f3ae49b87370e834c6d9a9ea8a180cd238821170ccfc4b1b48cea2ec4a57ac36317f0c23f62786447c406f97d0f410d6e859c57d87a2b851df61da8c88b011d461f3ae081f7e8d858e51a4782edea41e12541e37170fd2265f4840a869a4bf3d34dadc5f39a6e4be298183385ef25424628e6af6148c6b196f5c261e193155912d4ade82404c0d2678f56bba028405af6c04a3071de560fcc63bdb81cc5c9777a6fcc6f953c78ae4303a72caf8f90c0b6001b2f16","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
