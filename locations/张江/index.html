<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9b1201f6741d83763677f5545d4962cbb32df7604976d8e2f6e27ffc0e6939fa2f167bb80b2853c2f397db450042ca72139f8f8c07da69b2935cc4382ec00cad8ded181bed5394a9fe10e23baf76c19c06afc266bbd943324c24ae07047608a8fdb701bf6cee350e389c0f24eb11647ce51cd0adb320b8e0f78203e635bb2363761ec8fd481bca81dccaef7538cb239a62c974d98dafd9b89319df188e6c585aa72397ef2412249d66ab688c89859ca382f478e0daefbda91de013a99189e8ea26934ad496f2330c0aac1047734940b447880956e1ec92ddef9722ce85f1a8ca3cadf53b2f09ad1a13fdeb90a8de9f1eafe60785f723e104c48e994360fdb2c55b4ab5f3ca364fcd5799ca47c0cbfa9133b60a35b56946a5682f1f0d57ddf3aae7147b2c8880c734ddb7ee543d9f38951558b683081207a7171d992c793a7eb5f8fe0b035c4c9ab1a85b4c98fdd4f8c65306a580140055836660268a371e8b5cdbce791fbffad121f4d5ab52fab445ddb75dedb28f16877e24f8636c984e8233c12d3aabdf67e2370fffb0551e7cda5e492e7f96fbb8f71606dd34573880da9cae91e71fc1271552f53e7be7b70f15a84ed46b5964f6f838531128402136b23c919a371ea31f3c0f66e225e65dee4e45d9e57848409b26e4177c6e701eb316d6445be03b96ba2f06b2abdd3c2baa1dd96d58601157ab813b5f7dcf4f973607f5e1ee7b5d9da204914ccfa169ccef4b967501e18d1c17144b0bea6d9426acd56408ec7270b3a1d2346928a71ebd04db4f00a5eb200f5783c86b6042aea20b573269b7415634f21ef1d4505a959ce785c722d9908fd48f972539a6cd6b9e753d3a8e8f6193f05952c088029c6db486f15ad8e9cafd0c952824d909bc295684c694ff10feb3976c908d0421c924f449596805e979b20ca06d2e317db874e863ac05a5653f833e14fe987a4456cdef282a2d6527de219ecaaddf187b1183ae2b6c2b0433cf6a4c6f6c319eef7a846be7ac5284f2651fa8c953086f7877b55be832af27c916142e709abfb60fd14f98993e5bf58579f1da892746c3fd3270195f2faccb82a414f947919802e9e2179ab09516cd4b3cd193e728c2b55cf4a98ab40b2c548f16634e98902e51380e2c97394be218005f8d7efd643751dfd61f1967daacc77c5b9d10fd0aa9e0fe32884aa8eb60f177de665f3a1e5d5507e841cad42be1eeb26eaa7d9f0760598b8d7b99d531e2aabd12fa0538cd532bd756bb84e0d2d15e82f89c2be8e37d9434d751320427a0486f6ccc9fcd3fc0766abf3570741217737b40004b6d131e96e1207b68c63aedff01fc9c581ee796542acf17e6b6117e22645c2ab49fd7951f32c9696675d0af7ab695231cb8cd60b903cdf6ab9ff854c735a18e2afa3be420dba1c9bf6c80017de16f9869113312f7bfcae56cd550cd5def9112640062994a1bbd2b0666614622c75d14ac9de9fbe6c7c6d18559b7098cfd4081c73256e61f8951133f38b9c842db079e98bc90d3adc1215965e8a39089a9d995385e7ed4e7f0fc38eb3ee1376e4ba9f6bd12999ffdc3bda2bbc82bdf0e0c5324824a2ee7094d41d83fe1a66c677156bb3134812f6ce227a01123668894a43ad26468a0b1714525dd56c28a41afd24d12d63f7be2c22e69623426d3f856bef157e4afee71b492362c01868401ee9eefb3876c8ba378bf37dfe002ef6fbd758e658ad13244e205dbf0c53dbf9688c3daa7ab80362d64ddb8b562cd44e06533d32429cccd5effaaf9e1fd6a5414e08ced478845edc820750effe51002d5cd07e8428e818b9de8872523cb649dc0a9caa324e64d0e5bef0e9aa45619d57872d18b752a6936cea7d1617169c3526e71744a4e2d6200353f12e0369b066ea7086b2cb068c44483581c6d26e323e35f196151b4e2990477aa26e4a490d91bfec3e8c82c6a898e176d5f821ffd54a90f2ce81d5495867943ad9bb7da51aad790cc98dddb91da5641c898b4a60a42e158018f50c22f6bf340d547237719e1b7507b764e3633275bd848f34679ccd4fc29f2a2c24e11d454567f4fee4afa8a5e15070003e3a814268b1c7911e1ee2186ec59c186b21d67afae3621e6b537d22d166f3d342175fa01dabc83064db51a42fa7ff0ef59e4209d6763dc9f282101fa737ff761ecc1bf3b6294af848a060a0a0de34325ac9fdbf97e02065f61cd46eb1af4195ca08d57f79fa20555e64deb3f2c89888e14af037dac8310b25b8b481a8d202a2e1f3478fd86f5b224a4c7518da9c053e0645020caa85a3cab01b2ad1b1ccd31c46cf67aafe4dda594fb6b48a2a379ebff45b52a1ec9a0af67841c301852e6a43ea8977553bdcfd12d6df87c8558f2aeb7e9bfccb61b7b5d420d0fe06055499469e839be3bbd70d04e0b400ae20fb542ff4a36c6df67bc5dd4da66846fb93e114d3a605c5b1796f9a18c642bff25fc6d98a98d22d41c931f6faa28d09b160425a2a55c233d1d764d15479a57fa2970446a3d51c8bc361d51787bc6c62d0a51d44b80586d93ca7479d2c855d6ee037b2142c363a36974cd2add95b02ce6721163d826f68f03b4f4b5b39dc5c91709e434bb6e79ab32a963486f6cae41012d9d18178208eb3ba205a6b61837bcbabf927147ae98c6d75240bfd25148fd6a8b90a6d0feb6d8fb715b7bc89d0b123e002c1473837e0b6b09970d012ee1ee1617c6640aa4c1281c368c5f8925b209229a18c90dfe87370da3fd01188b0825072b5f68229e43ea92af45202faa47d2780bd21676c12f2e36f76deab84a65b164e6525e8f7fb3e4db670aa6ae047e64af2aa33512efc5464dbe94b84f0c82043a4472f14450c858dc82cf943647b4065d29b1ae30b63703e6dc9f71403d403cab75aec0d4ba87688f442ed4cb6aaec6001b8e62fb32c37e2b58fd592e8fdb7cc568b4ebf9b24cae4ee594606fae83aa9d873b1d9d25bda08d05b3ba820e66f56e31bbd7b8b2c8bc9cc2cd51ee6557bd0f6d29dc6a2cfee4ad8d6e4b0f5846982d62a29349ec4a97e8de33597eda7841519858764e87e80791955ebeee673d5aa64553e5d829b376ba2d4de748edbd457877305478c4188c120adc01a779b40595cad2e2919a0ff08b1e9cb0f988e67dc2bc171df0dc8953fa5ac67bdbca276f41941cbdf8b6dd710a5b20a6c52e5c563c41fbd07f633f8b0355c25f1a03716a2e8057d42be995490eb7d5faeae133216bf405b1e3b6a8578495dc33fcbd3d9753d8affe0f45d923888ec0ecfa567863767c9a44d72650c620e28844e37c1db1758133c3857a791fffc87381a73f2accb1b3578eba9634391a9c28134e25f179656c76420300eb3c2f1af5b61418a279a36e122ac1e55085fd0b26c8cb2f0ca21fe4feac5c20a1922f495b403c01b14e4ac9e26a369be7ae86a41428e74e5cb062ed03964ed721eae3934d78ef0fed1f649cd53301052aca3001de7d3d1a4f8ea6cf7212c7d5c8491d5cf1bc6589c9e721c73ed9ccc1a2c2f51619ff4f27d96c04c4202007613c98f76cd0b97bf79c6e3b905ed9e6ee67adf4d2f284aff90f600e325e0e720392c8e8c090008f948367150bbd2577f4292925e7f18c3af07935524b864a7791ac748a6b11f3498c05642e0b7ed2a27700964f32c752d937e474c3656b041bbcdd3973cef8f0bf4c50f39e6254b1b92220d3434d7504178cb350378521eeed61a83fc5edd3cd031d3533d1b28092e9575d1cba8b0202f2eda17b2e26352747b7d7d737ce06159be0127b9319148a48254052222aa96d743915715e2f3f732921f86d3e298d511de760b69b7c6e7095f687a4068150d7cdbc80df39d055c6bbeb2c90161075f936ca0a79c3c30f230f3f6d94c318cc14d4e17847496efe83cb78056af8cefea33a895bca75230db7d173388a3ee4d635938b2792a2f05a40cd85968dd171befd17f78cea08468881e29b8cf8f156a614534d1d554e1af8637a62104c96b8dc6070febb9d8f1fa028f2f85f7cb9d0786900f9e1ba950e14d90f66f8ddc3097795aa9826afdd6f85dbba132c8ad0de54f130f1876032ad0dfe8f1765942f4e577d9240b4931bfef49c84d9ae42246856154253fc857bf0f39976326609d23f569346a465ef015c2a350bbd9f99d2ac26507267058aaa91342737f3202b1b3ccf3ae1bfbd15078b7b7c50875ee5c89874ef89a9556e23257dbf5e1a18fe635ed9df2a7527d67a5995da52225f2744b8cd1bf81b94cb634b564102036ddc95d968187667e11faaed90083e4f109c36f4cf65b3b65644f6856c9966aa3173d3444f264f4f391c498426c597353fcab54f24abadd75a2f54bf84154a6350ed8c6991162db7ae1233ef29012f1d24227b56fee180623c5e7d08265dc52505b3be924dde40af09a101a60f37ef7334dd0e4a8fb64acb1862d0b04da5bc881c1fe13e7e7057b06dd5197bc97dd60b61e7fa65caf7010c7fd2a59c6eb3fbdd89c5f19d4ace4c736f18f0462f90cd032b936784bd4bf79b44bdff393362cee06c4c7728a75f00683994b055fb2579f0070b76f267a6c003bf8f2ee6ca48c494c3053565e9879b35ed3fa310b41cfbff792e852a182734fbe4396f486aede5771df41c053958807ce3b23b5a5b31a84c8d1ba2727b4c1f228fb8a88f6da5c213624c5c3907bb5cef77661cc6751aa6896a08fd70ad96e0402abd4a9b203d28db4502aeff0692d862d38c54f83652bd031c2ac8d1ff24194af1b0202b5fd9cc2507514bf22c161bfe419362baa8577796a661802d21db950f3ebd3a333ce51c1e70e57af53f948081e01b02cf9d5658cedc6c1f885272c9f0cffd437527ea34972fcb2a544c2804b95cb6daf14bac66ffb979aec480860715ebb27865108b9c992bae4f2b4437111afa0181dbaf2e27485a00d6a922126b2f6ee85303839f03397bb89f2da1dd22e7808e116c4186a8b457db4fed440bcb1ba13e81da5e26c9d3fa1028415bce4b97e92828f227c186faa805c60a75e6db6f3c3ab9baced47ec298ecfb2817fe07ebe12a43044f7cfc60eda8c4ba771a44b4f4b3b86903012b11d2207d300b3f61c7ec09eae2854ed461dff8634c255e7e11ced0dc6937f302ea35beb4338d4fcbbeec725871328aa5c5d1d26376b19fc5cec9fac84c07fe048844df3beeca6f6983f4af1b322f937a3431fe427accfbe97307c45ffc3c4faf97bd519a4575860c60fc1f1b8ea1e029778f0bcec4c3b1c77fcbc3704e345aec21132dfd06bcea1608ed6d5324bc6ef08d995da3e599074d6ebcf45ac9d5f5af452104545ea8764d5fbb837febacba7a1aaf3f7b40446bb6bb1961c13652ce7d324f3e6af3e4646fa9b865580cefa80b57d8c6fbe48146a0d295cd29e7078c7f3cbff03c3d6e3c8227aa9aba5d6e873b423a65397d0da21930b62ab2ee3de576966d939b509788f42df000df7aacb56a1c7c42c4bb69019b45a8533d4e2c51ce57528ba1a6fffcf3606cffe84ac224b003ca5e346e692d2cd383209545684ef37fc231be8ee868ff2ce9f8f919320fef567ba2894a9f52a0783a100ab784c7cf8a62e6459b4e726d67414982c9496a8e28824ebd355f1307149efa734b260eabce3df0283fcd773999526e35d05aba615bcc5d41d4644ebd25682929ed37bda685d75ca4b49445aeb8db9111d8432c30016eb95a794273ebe23fe799fb2cbe86649b0f1a21a707aea006cf5968aeca79f4c33852b650353deb1eb77f1dcd41ea0ed4bc7b8d8633ddf540e212a1f752e9f2af391d76420cc1ed45fac1be90d04ab0a7f1d0dd42c5124d8683ed8c4ce06e1a4235a0b8dda624c34b8632869cd9df941337694156792012f87c5ae4a320eebf613a98c4132c310f6f1e0b6a97b57718987d9363755446e11c3763aa962d69d6d392347445afd98d262ce49a2d08e6d2dc4246126bbd86bca4cdbcc3859f696bc36c8c644dde26714749ec8a504e43cc600913cbafb5bc88f7e18b6fd00317a5df7dc9076b1c24b469160f4e61925e8b4ff2088231a18e77018686e673eb2774409ab4988275ad3e4aa475f34d4f75f4786e32ab6827a8642689c8f607a254ff6db567cc1cbaa182a67e8d9989155dce6320ac8d2af3b2e83025814bd0bb6f990ad52cc2f494cd68d65dcdcbab9a90d1feca166996576d7e1dd6338adfc22b92edd7a777170c9757f1ad9c27d2404bd147d77d018dc655fbce7428dabb029723616877f49a2b8c9a0be6fc18ceb8e94cedc5d4964dabfe576223e18394b3337aea4605d3fe8c56b53c2d8bf71559a9ba3eeba542b9c3679cf84ff25d2521addd34072c2e303a2b6960bc406f281927072e34fd3b9ca71838de4c6522a849a01be40fbbb9eaf851eee3259e0ece1de16b48f4ced985997f7937634d3355f770fd23dc37a6d16482daa0f3143218e30c60ef95f779e625dc81f647c8cab5d86ca646350216494bb75cfc5d3e0d55f7509e3d0ce3cff46f9159c5215c1e7d94cbb44ffddc4747cfb8e5bae8dca359b6aff70b309f2c99f7d026b177d9c026fcd3d7a11568ee62381e4803edd70b83be5ac1d573630ec632c5d9816ff3b1645ea1fcf435fcec3a2e94775c3381532363bf7a9ce315887b85e0f43f8c87ed518267fc70763b915f12e728e39a5ce752df414befdf1f4eab6c383ded8df16e561158fe46f651d287a1aa008206da7e544bd9015846860bc303c58089555d8a980d0862828efc04fefc4977a462017ee64def9a041ec0952056d4fba388c8d007e222ffeec8b1028fa1ce4051f858ebcfc01cf4c76537ddd9fbfd6091d7cb4e5ab1b89602f3ba223c3e55767b1e9f367e4c88f9feeef0cc112a8e518e51b18ab128d6206f3753ad989c23fd2c8bf5c4f51c4b755af25a353a9929a831e025bfd700e762f74900e08ba2da7b5e5c79b3bcb743ced0a554e30187e5f94a5fcee003ef5db712710167d93147eb34ba0d0c7090107785d4be2609765db93f8caf09a03af36e3b1b356c246910fe40b3b1f79368884f0cd7777525f5b32a6c29081611352bbc2ab61c73ccf6713f64a5369bbeb70b9dd93a1e8fbef56540d23a1fe3115051fdb9eb116b85c1a33a9034f427205c09f3ace520a69571939403f03643d6cf50eabb4a095adbde35af05c52d4ad89bc015b3077ace612a36300c2e54d48d4a181629e680f0769c43667d79c9e219ff54fad05b5f23dc2dc27ccacac572369c03cb18d889a6b56b3e7925d93be2733407b54b9abc5215f13bd8adbe70709c17e594daea51889055d31b7d3285d5380c9a909a61e491f9c2a5672b8f6666c398070213f01bfe476ffe3e6e0012dbcc1fea7cc57d8d6e8508d2a0f7f775c0bab1ee4abf466aa1aea82f1b0f7d56194f2bbd67e256e59d77e307e7612e36b3553f12438f7f6f717c66cdbcadce6bb8244e824197c377ab85fe5f1539b451490bafd160b01acd0d0857a69eb4d01d3e754942b861049116839967b0b46b93a41e7bcf50f76dd37a72c06e3500f3b07986dc978042143e11b5aea4dd4f9b49cb389967c0aa8fe95432f37c701d8bb9dab879628d3575eced41fd7712ab4897795f4b751eb9fe8eb330828ec8791a61cde453dc78d163a01bd19397d40bc52662107a4fedee3298f0fdd06147778ad7ba20d8adb8c2746661a2dcacc7992b2f7436167feee3e7a273b22f8b76e1f24fceb6024ab93f8d91e51fd5fd7e13ad0c1b0c68f1fbd388cd76e9465e06b8ae0b932a03c26d8f130b50ba95937ba3b818a934b7ea772269f73e0b590a08d1acfcd5e559c385fe9289f469188e87e1317973724ca5549af87a546e5f02d413b3ec180017e58d3db999439dd9823b91e8656c122530f435db33152edd6e584ab308883afa9d0a4e35b61153c547ee4615534c29febad0f4df1b72fbc94165de2016bed24bacd262551fcc688d7b64a902a26136fb06a15608cdeb2f83ddd0e105b308192fbe064a22173be68fa554498d228144e4629c10442a71e6158ec0b53294f390862db2872486c9ae3f23cbf1a0a8639b0b5b51b0da6063670ad07a969b2461c29e9061a02478fdc2c0e35372ff4ba71022e4f1c8051e577c1aecf4d6fe9ed1f494aadafa21f08bd34dced25a0cec52029a055cb26c6b1935c4f5110b81f61bab24c71036eaf7bbefb5d63cf7486faff41eec90ea9b0ea4d14b5040be008bdfcd6a8ff81157225b29afc9c695435c97eabb73b89ffba200bb2dd3bdbce3bf1a60dfcbfa8381a06ac9345dc89dbb70f5d4383c7846c306f04fbe0ee1f46c2764d817cbcc930a1273d5211bb91ae86a8eea6885d322bf7f201bde83b608ffd7fb958e9a6bba733ea4ccebbb2e21c4241d6a6235b19450e4d8ea13e1a298ad23eceeed1de84363fbfccfa04c391e63c7be74d879821eb0ddf46e502e541d56d53b2f5deab3f51a486afaeb452d80f800902bf2045d4c05bf017339b4f56af5f89449b3ce9763859c01a0338a9a5ee5820d0ce7ab32f83b8085c74cf19cd05a912309e0e79f2933e4614f98881b8bfd1925110644f97931d219f66d7dc3f2680ea3e7b9a1e8cab46f1fdf6a5b87b6b4d893b6aa06760b7299f6db9a8acf6bbcffbae732bb3ee88e1b223423b95a7497c5c62d0330c1311defbec03131fa18be79dbb41045858c49a3e6a81718b1cf8e4b04aea9f0fd69512e018c89313f1ac441b0ff1a509cde9d13d49db7d9ff806bdb3e1d6be42948774746e7500074fc171e0c31134d0dead50421ddcd43c95ffbcbf85b7b62afc30d000ddd0139471d2199d59d89fe30b5214e049748e9a9c7ba11740e8b6c01a12bb35f630807990871eba550a578cedc7800dc17188b0bbdd2f0b42649faa480f0e0381a39ea0b6d2c3fba32ff127ed98b1c02048e9bb9ac56067be5cbdfb4382a4dff915baa9cece4b00577b33af6ae9ea5420656db4ced432c8fcf055bdb7ef19e4e54c8b35b416498e0e20462b47a92fca7aa1123f3aae5827d9f4aabbc32e361a92bbbccbb212545c934004df539e7bc67ef7a4b7ebb88faf7b69966ed3f4acd356d6a1e0e542d27c49781159351f46d28c42b4f99c3cd6dad9c7cb27e20c28fff0b68ecd05438c1b2f8c60fe9535379a86f9d5ff094bb8354fcb0ea5792b4fc07c2a5eaedecf64bd83885091d2c6d462d61b73f32041dfb72ac408c811aa55d84a07864b2106195c5a26e8e20290ef3f01c48957b979e878d9ef1b685d1cfd48f180faa4b1bbd499759a6d6140ca1a97cecd75fd1dab684e16ba5a18c031a0e6c50b6bd8bdec5a383376a0fb0afabb185b6860d00303909a18c26d3f7c159ef718b825fbedec63b3fcaf3692e22c1af6778feaf0ce134884169ff7d55460c6269e26171c01dca5b0b8c1bed7a13a5f96bd48394bfd89e6585e4e7afd236aa0765246e9aee101fd463282d45a2d9a3311e20b784f2c03f7745eb5d1338dac31e6070448e1b4b9386d4854f7210fe44fd2e9e4198c532528f4e3ee4e95db6321cd63c3e69679a20e7554b8770a72135b87432a2c79b677e534c8973cdcf4b906fbdc374e7e30880550c380c43cfa8215364139640e61e9e105727d5329edc8efac8559c541ec2fca6bad4bfa16e6b8abbe541470e225a8a3a7bd82b59d3662c3a0a97d5d2ec4420d03eca5336c57b023d0f751140770bdf434841232d9c85227edfcd3b882073edacbc3b20a2e8b62cd5b4f35272678fae74c760f7e59c6aa32c52a3d849f477d524949264c2629b0e55593ae940957393a0efd36d9c8d1aaeb7d54518e73f7a86c9119f34da58acb4de2259eb73f2b04879f416498cfc1e50e7e4f2f480ccbddb9e8b59d37def192cfdde0fba9912e9850f44653e441be7d8da631b3a5da6b60872623d1c46e1079509265124389bb75ab009a42479e861642945b3919edf1d1b7140e3e414889eddb9ccc48d1a6a792af46a4a9d0417abdec7fbae941ca2d2ae07daedd88e70a8e69960d6a7fc2e4dff9f5bc68c58777ce568a8ca40ce66d42e163390d3c7c4db38712b0321b8beb118228940771ecb33778b95de46f297ce5e2676c4ceccb63939edec063ab825c71aa8270fb10b11f1faed34185246f40f0a866ede1752de5699bd2edc5ad8bf7ad84615b3f8fbfeb360f678ae423799bac9a146b677584c4c76983e3f8a6fb1a40decb8538c44132aec0a82bb2e0e844b84ce88c66a913c2bcefb5583e60bf4949c22a697bcb2217e374143c33d3eb2ba69b9a18491e1e29180232d86e3c08d15344db87e78358f0697cd56f9381ba5b10b75042744acfc8222f9de0ea4a25efc7d727d234d33b3d45e7243450d53395dd0dc33bb5026f8fe187a22830f3a15a398a96940a054711c5fdfb657c143bac7af49e093d7998be09d4cf6e7b2dbaa26db719afd691b04597e46d57af8ca100b5ef2cee8582beab4a5be660b1f94f1be2aea47e97ff24a4afaef5435f4803b92411c687667317c264e905267708bfe305ca4e12fe8d3383b6356527776d78a83f1faaa2466ccd66ad0a5d8e8aac348dba46d33b98ad89b0e6172a3a8d2fd223db620d9d4731dcf8a3a6c84df6693c02f36e7635f571a7d4b72667b22ab839336974c92106afa531a628fff16bef02a91aa59ec257015deb94ba667ee1978bfdf69c5e4def6d5ead564ac6269dffbda5f5c9c8572596e2f67cb30544a2bfdc8dca573b2085b28f42faa06f23c66f62c450fc4d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
