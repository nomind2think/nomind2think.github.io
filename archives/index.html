<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"85dbec160164e94b334d0b122c9ead879da6a54fe1445917b6c96cc2ce9927c1ba8442be0d21e96639c33fa13841cd0209966ee27bcd747dd42ee8e9897154ba27f6f2214f3ca89d7f9b8c2aec31d48fbbb2d38061761deafb7e411b39b696860d5715817c923b4eea3e9b2983e8bec872803b769d0e06403b1015d468c8f93bb2a3d40ca5c1c07e4032e3dd8f66d6f14877d90722da01f62192903fd3a9b62c8afb37a9fc7fd3a9d9a2531be5307002770cb4e8ed5eeef52aa484a9fcc0b7692d6302eedaa3fc852d0dc304677ce3a50aa0c8247e0812b6512a60a338ea5efbb83ec66e836dd2edbade94d20fa994cc6c68800c8ce36018c7142bfb40c1b2ee3be9e90233a72ee4962d5622e87527ea9cb3001c3e62b051c087d5917b3d67d0a9165f96c513b48453c1351762e0d7958921b986dc2f69d7ff49f52ab8abfc483426ad1d411316c5b6bcd71d2678943ece28aa76f2bfa41df8657a138c6231ff4574aeceba85d8853139b8b90c1ea0f6aee7c1365a197616be2b9068f65254ae0233676c82a3d6fae0e460b361d38a137ded9d584b99a56f7e33591cadeeec44c58502d5e8f61531d8b8a40a1d5ae184e4dd7f7eadceef9fd4c01264a4ca5f4e7b61f94cad95ff9862291b08284ea95a015ebf3096b08fb003e4171bf5c2d22ef94d6ec3b120878e4c7d7c4dcb0c350f8803e77fd38bbc601d85aa4635d3460755658966d8fb0b58561e6e853d090a83a8e792f6a72161ab404d277a170710f8ad7f550cfaabb20221e8dfeb16e7999be02b836f26dfe80680beec49b878e656981a9ae63ab5dbfeecd69ade15078857b5341c81401665df044c578e12b00e5801bd2fcef5c257cb2b5801a60285da900bcd1c56515f91ed72a6d0332286bb0f7036e6447a8398ec8d816dcff224b7dc6a45513df1756379f7d12d905db629614e60d54874a1d981af3a5194b4513ca91820e48d841276c744d33e2c1abf14bfbd5949713869bbaa1edbd3c6082201be61a9079c9963945e4d190bc9d7a63dd9a4bd079c206e6af62ad493c72ed8fe63d95a39ac31883ace69a86c88496e1e6ed5bd81f4ba235ea0bd3822f48224d62148d212677f4f6704ac11e84415e7a38c025d155d2482d8307cfe47f567aeaac3c016ed5646cb71263b66c9b6437f6a0f30fd0c143a88ae20169e60bd6c187806dabf77fcf3a1fa30f8b4262d698addec18cde2300ab01f5c5f7d6289eb445003979339e6410f4036984e82f8064a8326cf8149eb125040cb54f090d28ee61df7bc5a814cd9f91d374bb9b9e85e2c6fe9f79736167e7bdca5a43fbed1d44dcb7891a7ec7c670218b6f30d86c3d930229e259106f0a3b5f588ae1c00d78f3f6e4d7154c28d2f0adf600c14cd550799a183c5dc73b694d8fa5bae99435500b4c1d6d8d8395661434c968471130e365e4816a96ac0428dd04fc92df21c1bfe7db853d4a2ab501c6c061a7c6a9837efeb8e3f6dfe83e24ff6825da6507fbf8fd27f54327d7b46ec3d0768511c9751fd000b0748a5f7f651aaf274dd8df244950d8ab6d22d69c0e13ec5dcce65d4c44e05596a1403f25cb2b57b1a6116ac88089f8a0e39897d5d89131ee0f2e17f884231ab3aae505b9592214321aee8eb4d5a590c5251ff93443b632fb78160bc4b347eb33a29212dc175d4b8a0499db6d941b940ed70490e0418f442ae0cbe1421fbb0d5ccc2a9f6dfa1b5db24bb66d7905e0410b259656044390a6d62c23cd1e409ea3c4eb2a2bbac7c67e2d10d88287f2636bd360a2580c99217b837ea5348225912efb2fbafaa6aaa73d775f7d5a7973b2a93bed7b243f71b74c6629540a63faec615df17905f521ec7b5daa945171bde6a366cbd48ebccbd994ba90d398fe7659f41cc3984a28da97d4f3f80a6a08fcfbd7ac1369b066c389ec58b38dd2dddbc45eb11879d4a6cc7b18cc333e348f53d448c1c16b620861e77fd7238bceed7a8bf1539be68b4cdbcc3041e7eef5ada8d33e06c808856a6be0ded035e074bfc7aa9766373b2918dd02712eebd995af8c4c59050d2ef2ed8512aba1034a19801ffda05dcab6b4fc58632ffbd9d7b769b4d3d3bf08fc427dead75a59a399829c123b2399cf763cb31477d1d70a7c51231e628393e11e40c6fae355e44a9b5d2cc400eb4b58a1d8aaf958113925b86558f0fb8bd93e431fa06f53569d93032849589090fdc79a492edd13a3b999443916f5a79c9fd9ab72746e647d041c9978a7c63d7cfdd7f2eed36479ee789b730e7dfa0e4e42c52245db03fca758c87ad31c9ccd90f3b9313a0a700a54f268f1c8007e7a7bd551a9a4645fbd879aedd56d66024ea0daea9eb0d679a415ca84a4c231efeb2f4a1aa758e3b3c09e101475b57aa8c4368ed3091154a582476ff3e11456b0b5e010ac7c815404c2af7ad04644b9ebbeb1d12e8d8945736be644adfbf37ffb33ed10962747eb4809c3b8216b96864e039f7df4c6adcfad909efe5cde66b6d2eec7e0a15b0b92e1c6f9bf4219f4761ffb06431756391316a79d995175bc7b283d3bcca749fcea35b84004e1d5f805866231a87289318d9e63e7268c36162a1085ea8cf33224632460daa5f1b6fcb0423ae8bbaacc5097686dbe01c94f538a49a72875a7320590c798b3c8ccc02546c71d2bb4558f2a0a0975e1cd6fcd1a00ab4c5b381a90f22a755e15d435f2e27ba638434e3a824cedcf488a2cc9ed708104127eb5eb0e1c0cba7281be0fae612e8fc61d143c3417dcd2f6a1d3a679289a98ab45cc87f88f2c61a9a81e314e64f54c2d42560c2b8889b467c13f39cc30bf8f4f4fa7a72d60b967457cb5176bbb80bcd797d2d8d5536fc0d045c2dee170fe34d0c8447ba4e79d066da13c631f712cd1d6c29385ab0166e30e6bde4c0a3e5c143e3d79176a58cc3ba9fe23f510d765c5884aea86ecb546643734258b2d92910b522a197f0125d015363e8bad9fab4b8f937b2c452e463907aa60b9251166f972213efcc5500c533bb2c226eb514ecd070abc4cbe2fd5175b1b4aa9f4ecaeec30f29478701a935e2e60fbf3474315d183fb5a6b77173f8db4901e09ddb78204f2a2c85f909920f284bc02be0217705d2f928c5d89d64033795f5ef58e62111944ec164307e97386563bf917fa37c75f42335a36116451cf4085b45e3ae89f84c3347e61459b9a869cda0fd2e90ee693766ec0a94c7c90418499c999ceba39a1b2260768b7d5d9b7e36a3f6d91763adfa15fde6beab3652eb76527c6abc6a4a5094e6b6bd8f9745372cb70f7e998115b1eb0104cac1d88821eaaef3801ede43e288bd2a13dfac812a78cbe094ac383be6b7a71e36acd21258d5ad5168fef2797506a426cff46a1895d998461852bacc84f63f097401fa7a13ac4cf608dcb27365371f2ba71fe60957cec29f3e605eecbcb3f8c7900eb879c897909494249fc80edab119f69c83e77e98283fdac8b0ee067a6db49a08e0414ff07e3a5d3ec581e493c41c516bc2bb728f20c8fb9e0207c78c0f4dc60ded1017e444df0699f074cc140d1aa702cc9cda0d1325cdc8d7d0e58d879eef92e2f6b8af6ee4db1b5a0d5c803dc460e8b9c4571016856e8fc1e266bd06a2f8d06fc38006251b7c1a91f6ace5f4212cdff988849ce023871374e86454bbf129877c8b0bff528bde8533e105a986f12fb1237138b0be20b4ccdcc752ddf199616b38651d25bf90ebb4a4a1da628e8f3ae5b4174c5d1f773f6fcc102796d53cfc0201fad7c77aada5847050f98b4963819f35e388620d64b9856933eec0ba6b359bd650c19c0113799559aa1a2a50b4cb0f6ca7f273849d4abcd951063d4acc523e4df403a7f1236e20219b4eeb7a677709ff1694e0604f647ffb7ef8138e5e861644f2f7d980e4cd6eb14314575f93b10a2220fd4b2a5ee5adab1d202e821c1ab0ae372c3570fda6342bfe6ef1d5e16fcc3507cf83368602db1998fffeaab99808858f2d261cae7a3e2300afb8c53758e3bdd4c30e0059d0c792a9aa146f1d8888c755c63eb6880c69f42a7707399a0670da0697e17b23fac271f6572e1f7f2a558e12c938546db391c534e50dd4543eb4da65fa5702ab1c14ba7117e300cf894e3a53d3297464e355d2dd5918db5a98d21505f10fe9e5d3316516251a498f74d1e344ac83e6ebcbc4b1299e810ebbf0e35f80c405c8b251cfeca284cc22592090d314630b12141194aec4b4ef8d1bf1f02d9946351ac550e46dbc054d27dc04b646825cbb492501ae728c538bc47627310acb0fd2b5d3c3f4a9c81552548315a3727707ad9b7d707f2dd23a63a279aa89aeb9f8bef9b8519fb1c52b2eb5d53e9ae1faca8f1488e82a078e475ea043a567c5f6bb51eb4edd2f01c29a5324ab486d54dceccd7b849b3ec41f00d07eb8db6f7dcd611e28f483551c87b719d61c9a52b50a5f4dd0128318f2d742064d0f1fd23b0abc9cc84516face150472d5f9e2aec468f8bee7b8f9b09535bfdf2c84834cc69b77b9eaa45ad8adaad403e2dde7e010ad7410e0e3799eb5a0d9efd259ace5460cf05302b772274765ad0a27ef84bc03e3bbe18d1e74d032536588dddc3f1a290c0bf655d79005ba7ca7b724139fe49bb039a8692fcea9db68f24800a067d8ceb85d907dccaab0c666cb3af83905f55ad9f08bf8bac178f261e530a6d8b2c5e4050e6f3f5dfe1e01d5e25772ff20b84a8c55d67f6ebaf31d41e1a0362b2e064080410971f1731555c89694d49309f3e8a9bf53deb3183f2e3956fddb3f096a98e0460dcad86c5742083bbe35a260a25707a65b27419fc7eda26d66ef604f2848d23e1b27e0d7937c5e80245febbcebfdbd85ffd7a3b894ee9f4f05699196c8ccd8ba9f35dd1b5b6b68595843778ab13e293585913bbf021faa576e2cdd4d2049842b90a6a57af94b18570de96cee3333cca9ade4956b911ca700364acdb27d0b076f33e9d0e81479d2dd49968007b5cee18fbe134e142b30e33a8fac2db3415a23929e4ddb7a5f14cca42d66ab2629467a4f45fcc32fd58c0cea71c96425076de074bb8a6f616ad0866c5398ed690ba5319ab4c5b27ee3b81f6b1dd8c88d421c4ffc248bdb93e6b051dcf46bbd6512d15ea12313641c245357439fd014c961fc4b1f208a56f621c483066e66f5ed4b81e57c2d29f83252569b23fb91fc6dbc2397d321bb68acdc1a9665f3745a95a123b5e16f88ed454f57862a9bbc6de9a54c0abdd4d8e284c4ce1894fb17bc88cbc3199ad3009c795dd8e059b7d4bc10cb036dc3f5cb87f7526ce302478ad02b342a17507fe112a80f8ff5e96d43bcc6e3c726586f9ad6228a587305a62c27d70e75e98e1593752245ecb1bb32c2ed1e9b4f512a705d329666eb20945c3889b86140d968d8472232e01d01be2ed1bbbd396201932635ba549cf27e2ce892efdc82a9a00f00bf672de3ea8ff6b28cf1a9993fbfec4b1e8eeaba0957faf44205395afbe00a6cae19e8eba66aa2567e317c774845201a9561cf77d1a10d7a70fec25333b8eacce54834a7276b92ab88f071b6e264647c9752530e4895990981d503d48c2f89ec5aacc6fd2386fe0b0677ff3a2d24131695751785e35ab0d06257581673a071dc0d772a181125b68a3a320a1db965cb44b68cb7f68fda516e652dbf7af56668bd767d3774ea7a8457be8d5cdd747f50925f4203d5ba87648822bd97440fb230acb1d2102d4e6ca57fa04fe72c20287837f3134a3c0ac187e8cf3ee0b379a47638668b841fdb1bbacd0629d52141df86228b4d44b1210ccf05727ce1edbfe3895577fb1a7f500215b638dde33a485c73fe9ec28023d6481e78bfd743e9268efdc2509066728bd2d956dff51b2f3ed3102062f609e3b677785988d3ecf5fa6a54441d1672e75c192c23e534c3261adf2c4cdf39eaa836ce71c0548d9eb587f5e932b3efacbd7b97733811bb05f8c02fb0efa9666c1e8ba4e3a84ffe07174b8f72674b68e09cb14b4fb088a7a48dbe5b9c038e18021ef5094786a3abeb0d0ecc9b3e0f18c5e949d78fbc2bb7984ed20d2ddf370e181ff758ff5018428547ce85e688cafc72b607571ee5c3ab5b5a152f6ac2cef93ccfb874e5390db97835b6c58c010798f14fe19e40aee8fa29d250248e4a34fa30a3748d2fcfc0d0416098d9db657ae9d65bed9be0e7a4a7659a296ad12f79fa602fb3b2b88bdb7221adee0ef8f98d02a1c5aba49b99234f51f34a63e87fbb142ce4802ad0b8ac80e15305dda610f6b7e07783b4329eaac6505caf88866e8228f831458d6efd46677afa71ae7f28c7b8b32cd0777a33bb33bdf2cdb5328655755cddb2a59da337b374a5fda3699c1f1a93af5fafb20f721a3cc292243a0ad33e7edeff8139e72e37a83a691b489bbd180202c4c80615643f7100260e1c1b7819b4f835327ffd146942ad80970893cc3b46943a3fd26a07bb3ad472f5e2c0458bcc29b9aa704e865afa08e0a6ed003976e3894f2fde73733ba2f3e53ab66014ac144f034772ff3ef64ca54020ae47e35dabd90928f4c814113496c69e53ad5ea5e7d7bc50fc56a502578ace99578d3d29f01528f0227fbdf01a5f2709c31e2e4213585e1dea3ee0fba5eabe203173ed210eacce0f1a893b5f979d7b93f9866a0c883f6920fc43c3a31506cabfe3b997e6d03955260dff8719b40bebc0afe3c3badbf9c980f704e5b78526b0c22cb8f726f7b2e7304e6afda09d3a4281c831633ad317bbbd9a1546b631be163696f14ec1d4fb82b982fe8f78aaf1055e473f69863759501d84996434281b0c9822bb236cb24dfa18afe776f5443a3037bf8b20360563ac0075e1567ed340c5b45a7485a54b45f6417ac94bed050dbea7bb83a740de7e613d876c7ab15777c5b0d260c33de9c84e2b16586d972c7a3feb069a494057238135d9afd9d72568474b36f996c3d3dbb2c8fad4fe3abb4db324a678c6e55b89b07b1fbfd18a75b5657dd4f03d14e65fdfca8685bb6cb77c3373c07f3f2a747e9d28f9a44825ea6492728f2068a5820f1ef3d848bd50ee3082900ab0cc3f0aecd9918026c840132bc80920047f4ad968c592c8ceb5e6a6e8e71506a3024b6dc5d569bea0f9440a694e82b49756eda4f4185df6c5274ee709007f018cd0535b755da14162c7235b10ade0ea7b45b36a3bba7c22071ed0eab1ca32ae7c53d8b00cda04ee1b56c2c37ead44fc4bff3965bc81f399f4042059251c9b8cf920a57661ecb17d99aff3fec9ef2d00fb114dbd3b0e621f3f98edd575ec448299bba57191e92a6261c52acb521829efc1260bbef31b81608557464ea2d65de5c019a47146345af259a0f1fe28953ef4aac0a417682fa3e08c008bcd24d98714413e23c927f2fc4e626f3f07dbf2cb93888f7909c6ee64c136719b131e40cbd93e8dc98372724f2981ad6cad5b3f0a8f6e8a4c3403988737aeb1af4843becedd092630e0d14b0d2fc671c0eb5e5be42388fc1a5abec7098756fed75ee0c0c0d5d0c9e9b600489e6b83ee5f2ae253f960ead0d57bf203457951fb85c9a18c39b9beb920ae7bd7d30377724582cdfe87c6e588cbebd387292a09ad6adf74ed58cf1bd3a764c9f9bf43380074d118bb2bbec392497ce5878f5eb0e0ad55c7601608516e5e6fe0477dc138091099a8d9022fd48ce9d74c15a895017b50c6f9f9dbb4deddc998de4f33c3a088b56449c8f838f8016bd88611496e1a1f71d4f5f1e0a1fb36691a6058a9762f629db9276d31fd4ffdf38d7ddfa19d675edfc7dacef13ca52e812c30eee3ac18bdadc743d684e89dbaa3377fa27e60b3ab894ad07b87802dc8ff0e5e67b754a2370d9189f6a95e6a473ae460a5b1094ba58736487cc63c94f1a63a96084ce27852089a48e3b9c11b50d63f7c3911fe858688da030b00f58d5667af3f6cbc10243f0602dafd4e03c77b29b9f928e95ac36005253ea5bc1e52bef4db39277b2967b9916d7837f905ad35693bb96d8b7f5a614227e5b1eb72e317f905be801ac3533e35a4218ceb4edffe48fc4654020497b33b11d35d0d401b87852547105e655ddc34e6839f64f5b8dab250190ecef8868156759acfcf69c500a3d3cbbe425f54cc5db93c17e6c9246bdc8a887272d106a372b71d277e9c61f9c944f2b637660dcefb4a2464b0bf80590d52f23980ec186c39cbf7e379d6b2f207bb53e103c067886d8f0a171a2cbd7b75bbecc121c53a210c677011a5956182026ec2a4032367dae4cc50667228f860269cc11632b668c83fb694c02ec03fbf69e9b69cff425828c730bc2202ca91cfd1312a47cd760236c617da8c5443634b4e360bbde74033a480a83be15224e39469e1961388d50462a78e61b0aef99abc65e2efc592e9315f3c18929754572bec63a0097f9c30a9245d9e8f025b068b09df442506ad40a043a78cbe2b1594caaf21fa321534524ebd48f399919db5e76f27129c3c3f090dc6c0b7d51b3a49197e278d62bb5768ff7d671feb53ef4c74e32fd4a40cf3ef152bfcbb4c7656de839ba5124054a7e8c2fe168076ac00adff1ad8ea053a1ca21d49e90c5f96e30df046c6cb00df9342ac038cd54a2684bccf5310bd89e289cc5db154f20a01f6949dfba31f80967c250dd2fd0f9aeeb35ef4338207c8327fdc635f19e18f030406d8b9e64902402e5fe75290c7a88f5460a48408bd23c45afe6e309ae4bd932b1cb01030861a69a51fca16cd8c9864a40e561d3fd33f0f0fa238e5c7637f775eec8f7872688eebd0eb88e5e6c37c5d24dd88a9285543ff0cae1698d61f6e483ef08e90caa2877b097b3b7e65d2d765b60698d0b5daeff9d1b48a3e4055d05a721e5c23e95f1b5d3c15007d253800efab7355dc60440317c8968da0f5369f1b1be4c13ef74356b1b8e35f3f93460fb3d41395415f8cc47c53236cda58e1425d64ad0e06e174cd9e0dbda898d5e08906ddbfff2937705152aa47d00f181be6bf58976bebd1792f4872a9ff6d8f9d660db40fe100806f90c5fbcab9a4147d6927d453ce97ba1291063a97cc15589180b4d6b98669c1e43cf347d04af2b93ed72f9ec9b00c9bb8b5114ab88524c9f2124abcd91e5049d2d67b88c10ce443068c98c6ff4a78e510cd95766b58ba38badb9e55a0d94ba234a804d37dc29f972a52a04bb1489c4c57689fc4f651ae6e8cae9d4f97f125e0d57638420c0a53900f332f6962f1c47981961a8cfa19fe0ba72731152ee15b03228ef75184067f89dcf25b99b0c67678e481cb8a49d30f3de525152bcbacf2f10eb806f0e674722ec3666e6c90b5b5ad8847b5c1d772b3b4d04d379817a5097f839ff429bc48446bd26db2b342427df363080d8349643f7411f21b8550d46825dd59c0472bfb0dcbf5e99f84cc5e091a19e37fdc548370fde28d3f076b61d9131d3fe5a9a0e24a0b25eb822732515becd535f09771e1a94b181377a68715df1975e9b90eaca8ba0311c188947087c62d94e9b93e98a1c894dff4e07c4b145a377ef91eb9e9c107bdc73c1f3707c063cb7e84fc2a686994aae1a17ebbf4273ee51a949de19eea462159deaad25510329d954fd929627f75fcc09ae5c888e6c66a43dfc4c6f20095478923a6686d641982832712f0dc7a6ae991633bbecce326a9956b4f988477169d5c05bba4823a2ad78fa5d138e9b1cae080bba5dfcea6676001140c1b3a73b6c7e2f0ba25f8d42c924bd09cd62509d44456c267df3d0a9a8e9b6cfdd37214bd5667104e7d5c628e23d7b0a3f4fd952cd859747b30abc45fa4c060a9db2885fb108c9c5531c72bfd1d4ea6db34abd15fdaca6ee0ad510009e9875273e1dcda612f0e54079cb6f22cd39808f2dbf9e65b1b9b82ca91a592d8e4345b47f5456ab0bccca3e85044c8fae70898b7e81a8a45995f2b459b4707cf277a3b163d9f8fa6cbadf599b6aae10c5f4907623563930bb54fa88f856a030f25d6e8311c0fbbcdfbfec5910e036f5cb39504f0116211b3d47039a24412a7bdc728d58939bc612ae010541ddd57ef51281a45667990da16d645cd43b4239f673719f0edfd530c0830a523b5bc3eddad9eb41dae4cb2d81ad86e709318b70f6339342dd72781e3cb9a167bb9a8873d3a0a389bcfaa2c3365abf69459723657f57401f540d0276250087908a2b13e89e3d0db6c39fb437a9af7fea83d50beca3c9d6b0a4a9fad32f39a242dedcbc33e75c6817c00dfe23cf13464d5df042351b8c42f0e7a8856050cbd6b848ca65b394f1f9025e051e361fb0f7e8ff9d78186032568ead70268be8f042ca76d0580948636eb42316d34fbaa71d2dddaa3e366a8aff3217c0a4d55db76133988baf85ec7f40c6a86fcfa71606c9c1323f47920eb20ddb80560f63cd40fddb7a217fa717e23b6c56a886468cbd8f41b1ed1faf08f125e23ad8c1dca52f791f6df5e81301c24fb7455004347a774045caed5c28e1a0e0496477160378477672ae972bae519e951b4ab05ee9da18a0475c4a85364e8eaa147c4c03cd3f0508293ea80b76e6b97a86bfc2e61198f1b49706a4a03f6bba654281df4f8f79b4dbc0747c63fc5e60a873d03a55d990fc282f7a7314acff6864cbab654e56efea368c0b46ed41a84984c3a490dbe0c062ea97e03d58c4937e6fca892ba349612887da4f21d97cf393225e99b39bc9d30904c8126d4f798f3a6cd873f3e7dab3fe0f8dcd313280356b691f8a6c66595c7eeff7cee40edd1ba3b56f41498155a60e3aca3942a50103a0f75d4dcbb6a5803762f3af6cc3def1f8d034704aba7b8fef4bdbce8b2f04a4490aec8cc83bfe788c886d9d68540bec0cb5774d1b4d9956c7184a674dae5c8169599d04a7a4128192051d027ba540d352c2434755d66428ff98bba20b401018c35cc7ed10911aa98bf745576d887e12015cebc43f53cabf8e4bf4ee3c7eca3fd22af8d87b21e9883b211d46d82a186da99b4587c5db8e1c6f7b3856b6de3265ee5d471f009355e87fb0b1803c9101958f308baa3416752f3af384f90a06899792878ea6efa6a6a247c9211430bc014caa6e4c80ecd43e5d2c3eab23950eb540cc8f1093b19e7d7fb14872cfe204fae96745513781ac2a975a1048bb5279e5aea4a1187d64c0c65e10637bb3e70e250d63412b8cdf293199887dc20113f5576deb3290003e8eeaa0096e273923e116bbc7014e9fab900aa5a9f162b3afdd2469af686d95d3d0446fea3cc74052cf217cbf7403d3941248d4e4e96fac1f48062e8c8d15ccbec82187a331e992ee4d26229d7a5e4c036388136e81175f58f14fc003362afff9228d48fd26724eefe102ea0eec434050077c5155b5ff7aefef4ec21ca9f8df1109d6bc7c8b764fff2a87931728d427b6e12234cba877d0cc6d7220ad55634f1a5321a7df7387719d1f7a09e8e6768e2dba8225bcb15151f3b80f83833dd0b69b265bf2f096b36605a15e37e54a17fdbaa26541ebe9f471424183be63121d7cad75784990029151498fd66f4c67dd687bbfab185e739cd6456026cafaff77106f6b0fc03abd2530a251d00e569f690168887e5c24da5de1d84bb6ee16d0247cff18a6c5b431d2a13caa3dacca661293afb0abc67faf3433df57f24b6d04b368dc0428b13792e36b8da760b4a48db9f60f95a9ae901ad27f262bd0ae3a09686279fa3d7818f73e8861658d3322139221f2e1d8eaa5feb25a0c8da4461ba3d6c3cc1edbbf544fecba9377df49381d55d9fc52f8399c8a0ffd0a95a47cdb478cc5b9c866faeb5ec3a6bf1a6a7711be2d464ab2b013b2b44634f3b316de366c6b2b1d6409ddfc105e8b5506acaeae4e3643c13cd3586a07e245a1683a219bd9532a86edb1c2b16271fd87575950f0881a389f3041e41800c315b70f6301b6466f01d1df457ba13047b68ac8248cc335a76cdfb3eb5480f801638c2ff0961379aeadacf0271311984b361534004aa061c9aa61a9c9244f50cc06933d66fb14a0e126bbaac585641f238bff3e7ec3f4cbd581990f921b9c461597562b3b2a1cae281cf5da85a9d1408c447cb7cd9cfbe6113ee533a44ae240d57092c73b59bcba4616ac5acce63ed472260ce2acfae8c3c9470608a62b2fee72293eb466203c01a09a3ab411e385bbbce96c0823202f74eeaabdf7fafd1506c9a413ca1e428344caed15348c5d97525af29c96dd291b4c2829854991152281317204afe7e54491708f8d10ad256607250b7c592ebefc45e6c71cd9b50f5e7ed24668cb18b67d91820c473ed69f4dac3297c915ee74d324b5eed897c85a942b55fab99114065400371f383ab1a6ce4ebb6596c4032eee09cc8b880593b69379d05dba07ed20a2bdb9708d146d8fd455094d2876f0094e268e2b82bb8ebb93f52a15e2f6c5e74325a8b2fdfadea88ad002a7d6a50a090a709ebbd960b16c7a8fcc55c616881d67fa32a2bdf8931e306ba0c4d1269e56955cec902940a99bde72a8db97cfa36747da27a4cf657de1fee7c4a16834031ba3dc46e6cbf6ee44dfbcb38bc2a1e45e3d2572d65e7c9309497d2fcae32cc5fdaf641d5f4b3e035556c4237926b5f0db03459c9c316d1cdefec8123d502e84d813acfce7a79ad14b57235d2d9446f8f0e13d61333849942d8c06a946c5b744b509596cfc3e5a44e982bbb09cd96da8874578aa4efb68b19847742db19e0ac77c2a2b7afbc5810ae6e6e4e71efb3426f2067332ef260fa67b1617fa0ad81b9e129306496913201942ca3fb68c551982f882e0806b1b3a5ed4d28bba532609ce0a316d9127f7bde29be3ae641509dcb54e639193fbc2b6b165431541b0a5a67a01af287d91126e7c0a37e278e59d1e0948e709378c377d8a7c1e8524c5a85563b8922f6bbb19895a240cf27b668399b944d449b19ab3213fde1806012c27f3690a5b48f6fe0f94ae3d8afb7b383a803cd0f06e87383ce3a598d65b1a2e2decdf40335eaef78802118c2b0eb15cd60940daa8db61d471fbbe161d8825b5f01340da36f232608720559449ab522f36fb31f43cb35e80fa09f57fd5e907bfb2f5253e50a270dc8f44f55bd3acf60c3fd14abbba620fcb545a136119386686320d2488b702a6a3feaab65bccdb3c2b33e3b163aa2d56b946d7d709d74249f7ce4372ef9e93e3ba5b287f9e693a21cd51dc6941a276700f990e1ab05b36d32682e7af5976cf043f758f0d7eb2b087df99e324ed4be5f9c28a2d1ee1b7e6ba811a28c3ca966a11c71e1d679e94c57d7221b8784e894ad6fc6cd8baaec5a3521faf65255a23095e5ca4b2a8bbc213b7e9f3a74b3adcf5fbcd3cead2db3f8364c30510b6f7f3562566f4e0421b11297c3b56fda78cd39d6f8a77b6ea2603e8582634c42b077cf5b154cbbc291cb6ed20c07629ba758501524fb2657c20cef172da856cb43b9e6068e04ad91fa1dd7c1afb8f22cd9e7fd25a53c9648197564a6d36760fdd807edf5d9fdce49ab4f1b1fcec9cdc09c3c3556e3022c152b517bbe0468ea122e2e08cd07930a9d1572d26eefb0cb921f9335a75f4f0492789743ac9ae067a9b23baf5bce8d41934666cbfd7762788353513bc5be43f646fcdafd5af418591666dee1eb4cd3faba29152fb8de2ed6e997cb689e29ab419c7dcd368acea8ec797d46c5add868e657562e8cb2ff3d5a9d175a943059a60b8b71a853c4a1d136b541f6af5cbded20379ab513105f801a3dacd5bf9ca2a2e9267fbe1765dbcccdc5ac1d3668e8b2fc8ac2c9c837305647af09e8fad328bd288ab3b8ff5a9d9bf1198872bebd9f7376ee2dcc3cfbf16743d256730ed8616c6443841d0c70f9946a133a4e57ea29915f29ef86f7cb54f23a1b4fb3b94b0a22c210d6bd1d2ffb6f4190bb4684ee6cd338943e80bdb1232790efbbcbb65eee9f15325e43255f87ade3a9abcc493a28c4c39387820b414ab62c203e61cff4690ed3a436e1fdc29bff3305e03df385197319816008b071a9b929fc86e387c73e4fc4c254b29dc9ae4d3ac3e04c2cb63dd9dc829df74b8e07614145153a7cae655bb499db5c54b9cc84fdb23350a577783f88b40de90d121bcb409bdb5a573cd998048ce0cac851a84de7378a4acf6a24435a14c0d14de769e45da8a1e4242c085918cbc684bfcc25dbec282313a79d4d2d27806b74e285f756cb7be5e3579fd719633a4e9fb099ff0f91d569c5c4a233c05812c094b325734fcf55c65592d2e6f853c9bb5fc1f446845fa92df32ef4cca00b3cb06c5b6e9a7160ea2e0061e9b77daed723bdabd0541c4255a565a14f9bddb5db8588e9414611f68e8bd2174883f3b50685c5f44ef28ce05a6ea3628e1125c957a9bfa70310c455a12246bf5a4b0b3d41cfaf3f42d891e95c024db512ca8a97f6f12842824426160f858cff4323fd6cbe3429e640a53a2cc7727fc76ffaa44f6a2ddc7c857d2afe434821b5d7b848b441def843fc3d10cf198327875e0f158f7f3f43a46de6efe38a1b0a55839f84dde44a279f581e7ae64da8a0d570a07ae07415f8b3cec31b4e4c25e5172e8ad43ad21cc7c70431b37591d3ba2a9009f81bc56492ad73117640edd442eb918acf5fc7622806dfbe19f348412609f2e1cf9734f0be6afbfddbcea413fbf9ddf257d89cfea8ff0b5b2789871c9a4721380e3c2f85de2461f2a283a30baca685dc566a29a5a02e1b8bf7738b33986e8288cf1bb20fc3cb0d085698b112b5edf3a91e5151058e145158f91adec65e24ac946075f158543ebf44b5a367d40db83c518492596417372c8dd8b8874baa70ca3ace87d751e386b2f64e01fea2a47e5df35133fdf9ad84cc91d7dd82a178ac3f60f9720a9f5ba7fa5b09e4f0c361acc66062b70b19040b611dc7d89703cc4289e3c1481a1d5f3678d212e41e67bc27d85fe91bf7c8ff3a80e02489dc4fa97144d5e6d6025ee8770d796207f1fd7de3a65854b202d97644bc0c8aeaf27de66fb6582f897d0e80447f1e9cec28fe271e5d56c3da3a93fb9ed6246f9da9600991e2dc6215075d7c571b99c9ae5a2e77572a5d3caa7dd945d9e921fdd6068108b332803a9bde784ac411c910d95a8d0feae78269898bd04fdb0d3de53f44f0175cc9c95326d9b01a6e9a0bc8b87163239d87c966d552cc62c46c91b4f5607ad0bb61536c203e4a1c74e9de5829d9de206c4ce3a6f4cf8c882d7f6100abae17a388d02a0566d9c7f2fac128eda5d86685069685f2307314410a516cc2b4b359c9709ad2d1c9b627870d63b256de3d2c828904cfe548409e6a760816434ce856712e22774a6fbe95f73f9daccb2131541d6cc91db38f27b5b1e3c26f9b8cd73b05e12e79dc08c68c3330a6ea0ad9b8b8f7be59beac20b8e3e73d556231b224e0ff708aa603b85a3e65385de8ea5f6d48212e3881724f72a4a9b05723dfff773dfe301173a7ea05b614950b2916bbe94dd4eedfa9fa391b62121538272ce0c63fb98474e56bd7332d2c45623d7d801a80dab509c286527d65312d66d16629a85f3b43c84a63b11484ffac696b63f84ea163b4ec5a6f22dce9d7eb0ce9697806fd583ef82e0da50f68154930d412affa8770ef794d0acc48783f087eb47015abc53850055c49ce2de772b26920bab3d732d92ffc8b0f288bc3dda1f91411f3108c67eaa8082a52fd1a33d99fed4e27a814b604dcadb0e04eb90f58809edbd5aea1b4db9b405585b3b77e7ad533370f3376958838b49357c68a7edbb13f9285df5487454970bfdb2f973306f6c8a51d29053512a4fdb3a5ad64eb180ae7cb7aa6d68d93ffc2e215b3c846e6953a629bd2bdd4c2a4b5664dae4edec4075c56092a2a6ace3714b2d26bad47112afa6f60d30494185eb5457f92b72135b7dfcd49dfcaa876446fbbc0caea6c9aeaa95a0b94736d8593c072a2d26294bc1a12346e2f36e7a592517e4ea1e8d5def5cf19718f8d6f8c824b88a4008a50d8771c78bb65593a48f4aabbf38466765751a9527b878e5ba6cdff45c5efdc353c27947a1b10dcd92c02338d79e817a8111b936a66668a319d652f69766c1e0bece5d0e742274d8080a343a59b3934c318db8946c470988e3d928f543eb9c0eecd5a530644f8684eae7ebec8164fe014ca9ae895776b1aef0b19312dd953221b7509f6e0af098788e8cbf61ae7b95cf098a351b6820d91ed7779241273064b6ffe63198aa8f8d98abc78d9141a2ec28c7ce352689274dcd1d6a0a4f2486197a6b0385f6ca3f1feb8f36f8a67951211aaf9fc197b8f4a4dae271fc6075d50b8de630cbfc2e60ab4f1ebfa6fc099b08cd2ba507513ef476a2654c6a88568dc858995d2c769261f125d2a00c5117a4e3c3ca59f4ea495924946252f313ed56b1f4d3ca6913ca2ec22984c93ee0c9163ea292373cd714b35dada9de5066de6196ed0a8240135ec799e8b93163e7e7996ef5c8944ec767cffd7d2ca8c8eaad04a2c3f5cc8983dad26a7b10b9cd9c4b5200fc31ff901d53ea35f155e88c7e50f83f9a888c522da27b39ccde4d83479674235caff2187aa9932a233bcc236381463af54f648033013118bc95b32abe741622cddecfa8197e32c43104c269deea6e7851d706957af6842cff5c30a18133fb276dc4133f191099e087860e6a776c5806c64055f8e47dfe6d3c6a86d12107643948dd818329af2cbcfbd50c839a1aa42f01ec21fae84078e916318526d6af98eed20b7ff92e4e8368643ec620719c5d2f72543e5be3a828d3271f66688ddc3a064d0e498f49503e1787eb287175a4bbba2eb8600a54e51d0639222e204218c68a7e10a308418035a63639a4f974ae45eebbfc26d47e512a9132cc4ec6d8d11c6f4681ff32ac349f1197e57c44c5df24fd2b82bca226c7297278b19e275db8604ad6a3f99205598c42759b1f3aefd64e2ffa65a56bddec53043e74b87ff461ec067554736b05b12654423476a709138e586c2eacd5437a068e56ac0e4d48929e7520bf82f43c2b6912ed41fe3a28712be30c9c507959407d442d499cb1be2eaee59d31a5ada55b87d455d3d079d71b9017553d0b379211cd026478629cce21975e8afdc15d7f5d70072178ef50334eda47aa00ed14b3dfa00b4e6b47ea28aa9161c6de5c3431fcb9d595be0664eb954bb9ef841baf046be61d3f89c1baf33ae5e220d8fc1d9846f4022d563c58a14187fea7e9499c00b30dbf566b4cbba691b3693ef1eddb9610fd5a2f41d3b057c00a707efeeac40d3c52594cc5ea066815f50a3775dd8d4607b3348808a3fc16c40c77cb6ed33f81a9bdf091bfd4f6068f1d8181d752932ec724d0c76045258f07aed63f55ff7872d8eb1b9e540ac77d762e1c848f1e5a7178ebd054e0033a5111526a7c734c772f052e7c556469db97a456ac0cfcb2d9f074b0f81557efb97aeb530e299ec7e7758da845df5388509b691ac6c909aa6f6346ad48062f5ca2ab8ab8e2def2eb68283214783b28d755127f0350d362c1ea4f1a16b8d1ae62a49984fa116ae2b75875640f9baff0b2ea898c53e628c25602f4cc2549e2716ea51783a7a6100833bd90db2f20811982597dc74a62e6b07a91c70027d4244ce0ee2c317a29b18131f616327c969c8c49cc73fadf0166242ba4dee16725cd7684ac7e1a1cdb7577e86ff05fbec3383bcf10b3beb057be1ab58ed2354d13ca22d92a4b88c71554f2304e1208fa775f9272cef590abee5e2cd76388cf9d4bebdb2841d9db674e2ca09842985549ba306154beef7090c9424f1875828f222d95a67ab98227b41e90bb64348907ce3717091fdbf9b0e79f2c87fc0d73b63588b5b70616c269244cf69179e112346a22ea07614a0463ea9f97f20d66f8288c02e1ddcff0ca0d50a5e6953c2bbe0afc2f54f95dfabc636f994116823e4b62282a04bd82e388a8bba3397ccf8d35e25c958062032ead21f98ac489205b4c2f7cfe110794463f3a6e1c1d4d7643782d1ae7016b935cd9e981a56160327c51ae9c405903ab1cb6199f85f830434a2aa752d40875a92466660f736704e74c9160c53b0e073944334d5820066dce21b46faef3378f0b2330918c5ba9df4ff6ccf4e208076690b357eb8aa0e583de240b6280393eb02a347eb9f23e1aeffe2889ba4db74685af199f92d357efae7a4a38e45925b165624ce81a1a9b5bb92621437d45e53a1410d5055085fbf4e41a4d8b58189c45792886d7e873f67a15d7cb5c57a8aa2dff6a3488f85aad183eaffb1c6f51d09acd9492d5dd51f6b05dde138c8b8f0a658033d37b769f49eaeb4b3689725e3d7fea33db4b6fc4dbf3d25c01d4adcac5e80fca3665a84d26acff4891caee0c22eef0cb441b91089e40ef895cea268748eb1ec9dd12133dde908237c4443be501c5df44a5e25e9b8123c06c9a4db9dbca42bd2a1e3abedae0e38d81b60e11d43ede258c4ff8b637f2d26724636db96696b18aadd599992aaa1cc33bf0ad1dda059ce29b816745ae29c7d552a86a52a2141b4e1295631524f97fd3ef518805f324c76b62129aa1348aadec95d080799706d2c1ab9dd10537721260c74dbbd601109e0dff91052731db1ebb07dedc3ea6e7dc1dca3b3d0272958f24c704668833cb0ee7c36738c33de9007e98368f445c422fa0653398355e3058af2c67ea010d2fa3d13260f46e3e6bb96174f78519c4ff7ac4ec1c153d275b9f658b757df3faf23116986df2a5c8a2cff2d124e3aa11466c4b5ac173e66ce2c64ec8969bea688afadcc4e04883e0bc49dc41365f202cd6e053fe553df5b2a39b4fd90dd946e46afb8221e26cec4c2cfb51f1227aaf30e067be8353478d1bda4e9a207734ff50ffa4b2b15282120ab913d59b8577b5138fde710f9973b2d355e581834ee27462029e36e5ea2e9a63e755573058aab8f3cf3d95234f147c8df97b05ce858bc97df670fface50c38bb8ab65b60df31873be79dbe036e89861af1413bb1c5bc66194bdd683b820d5008ee92ef180e4a2db7a8145edfa80678204f0b1a46852a99edda5739bb2abc8f7eb95934efaa5d60af413ab74dbc1ab2525b15f4bf26e74161fdb6aff9914e486b29b8f9e4c68e8b6446ddd57b49d73a3f543ab0b1d8cd28b582271961eb2bd2f88aa9140c566a9f4bf9f9cb262faa0442f4681217e1f3a8572d48dc14fa351ab3c040f7ead68eb8144553f7f4b719aa881c95d651893253612933454235fea1d1efa151c2652508dc26246357cc30893f56718fda6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
