<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd96adbbaae60e225a9ef3516d6d2236f555afa1555e2507ffac3f61a910a9a3b28568eb02e8a1b5f5f1355d9dcb8a85788bcec2730ed63e2f72067a414ed3527a653b4e81649d57075cf92b0d50077a9b598102e607eb952ffbe0ff536efcbbaa0b2fa3582fc3738a4618e32efc4a5942816aed2614a47957f01c373eb5b686e9ab8261863a15eadd489b82528113d8458870806f0db130ae11dbacf5d8417d11580b01bd35cdab3aa76a08e5865a6aee84eef34efa21b4ec2bd78b610cda268d3bb84486f4c9492dbe326d09428ae61165a0e9c8c4b2b1995912187c7b0896be98e43e46fa377c68dce66c90e87604a452ea361ae40ba63b6b1fe822bd230d4ced8a1ae6bda38608115920903063de36600a0a816a4c4a60590981df0a45409e0ef386d1dbd8d2ffc7bd379399c49352a56f068e84d7da34a3ca2e20fa867fcb73af7e40ee96424c58f6c10e542cafa16e0bd8a0566d0027907b4d6698923549561d3f6a5085e42ec1f6b8b2da17b19f87636bfedc281b3adf042af844fe2ca1271de9925ff5bd9758522af0bd56fa8c316bc3a13628f5dfab67348941573e3a45779680f139cb281b0e11c8b45f4e3f5386ad00ee3c6aeb80401d7d391d5c4dcb4c77416092b356574e94d10e3f4c4ab603810608d1d1d6a0b6565b2dee7fcf1c198058e1f50859d8cd480844bc8a1ecf2cef7456a5b4ce970e80ea002f854bcf86f6df78f774608a8194c7fcb93689675df9b793c4b05bd23932db98c53e57fc54393bba5575bfb822cd9da27e95fb78376cc00b17a5cbaf46a3668472e4ff07b0f0cb49c499c7b3db5160bcdb3d5fac1f0612121a0cbdd5ad716fb68f71bf2b497337dade5e8f4a17811bc29bc85ad1634587a87a7c166c5c371252e5d804011fb84f84f5fc252570b44366046625ae957d7d6339088f0a276707225563c4480b688a13823f7dbb3e16ecda084f3941cd66c8425e6b80a9d798cc4d3461359e8dd6177ad50625235b3a7994976158f6be0f471e8974b0af0e078b651d77c9c0ee1d32e44a5b01a47555edd7f3405e64c27204fb569ed30991392ad52f5c90c91c2f54f248083be4b849c3bfc9f99759d7a23d46f2f51bb98b1440e1ae7ca6ee6498e0d2bac266fb67fd7c595965ab99b2626b2567dcff9d7bbb79fbd9102d19c44e34389e55e224f45ca3bcc7f9e92b8214240ad56fb7659fb27dec3deaad12c73f579b1b9acf7d4b17a8234f97c4ea2f14940436f362a9e8457257a2022f13ca4660b6905913ebbe0d913840f03678886831d8a30f0cc004372465c6750f98893db2ec4dfd584ea96187120b0bca5ea8b70ffa0778a151b19c9ef3bbd37fc52954a62294afab118c7ceeac1079d2cbb55833d230ea8d43eae2498ff5ab21e6b059e96f847d732a7c9840398c14d95cbe317fa0ff340a0c27279dd76af647261a2cb11331501857ccbfaa135d58e85df7a5c9e1131ed792788447088e019bd5fe2b922f06041c806ea501da15cdbd5cafb4fc636f692534f6ea517f2c26c0e5541c4ed3dfda3040bd1fd08ef73bf6a3bf93ea9a87370c3d01da7d6e77a548073f5a2b182b83bb1bc69dddc743f4b01276333deb222c0f14c713a238c6dee7b8d5e0e8361e607cfb7830a0945741185054ca2f00dfc8391d50137f7c9d55e6ca274c6da5fc2974eab61c406e2bfd3c080e7d58245ddcf81262e5949cdf04e8c4114997247605e39c1e620dcc62e2e461455e350ed55915e3f8d541edd3d114fa5be359e20ba1e2acd7e0140c5485e5637f796ef4d808d3b6f3d8c64abca36189117374c87b1efe16670957f961616b28d37a6ca8078e5ba638d2e4930ef3643a2e4c66a35440e319a964859f6481d86ef90af09dbd018a3e5c30b390d5f59116b0d5c91293eb2998ef80fda8c0bf95218ef57031f407dc0359bf92ac48620bee2f61906f128562b680ac37a174e74d2a788ff6acfed65639e42eb25f640320db76ffb24c19cb21a19001e5eab4ac8507f1fb42f42a7756c38ec08e7405f2c6bb6e08713a692f09261f398d80eb3a0a9a34f66ecc82bd81800f76007dbba821f72585d5b6b363800e71ea0d483cf38560e0dbf0f3637165177ee045562446ccbdb4c22411a0140ccd95ed0a09493c1b46033aef4782f3a35fbe54f0e6c9bc1ebd02b6093872ac9a215b10ea31cedd63b7a26128446da0e68a033c983fae7aa531a06ce74b75526ac95550ca03b92bc2f4e41c79487be141db25317693d270510fe0b21927ab1f4fcd4b7c7f2b550d4eb20585cb7b1d64be5a43ab7c15ffe24c04010bf0daeba0adc1d440b619a33bd09a6475b2aba784c6816b8fa305c24696923188fec07a8a503097e6404d8fc74f81fddd1b01cdbb90b99616cb85a8930d70748be3726caece7f74ec50eb0ddb0692dd7c4f49a34d828c862b6882bc22e44eb6fc6d784b490302fabf5ca30ab79591bd085a25d061267c47664601738d1f8b611bd437b3a45d1ff32437c4c8faf0504707f600523b971e6207771eecb0cb991057c83fc38f58f40fe58f0e9c8c2cf37fdee788a621401696173a06dc066a93627c1043a9885d27ac04ad058e5bc2efe694d0306ce56c1d4635780177d3ecae8c418757133ff843f9d09a2263c00a784d04f2a4a5bc67776e858c9b305bd5c08fc7fac084d87bfcda5b96cae388f87c4753d909129bc331fbd316e354887e9af67d58a698fc50062970cdbd2e0a7f00c4b0e982b41549ab486919254f8b123b5a64a2bb1aa2992ecea74df4b951cb35239e10e3796c7de4cc3a120b0d2cb91e3896cd70718d96da6ffc18cb55055fc791c85d45f4e03da6e49ea6bf3de6a02d7e6db2a4701ca8f113093da6d580a8982015c7911b22b0264d3b85ef428fa5f5383e684118b662c377920e93b52521e667f638fe46a8fc891ba5127334eebcc7dc87cca0c57fa5298ca2d9800e3e931aaca60d8e6498d3ff92b2f6a0c00967953e19f6fa01f45221ed291a5c4819f8d6cf5f37cde227d55ed0bbe6e3519f8aaa2985d21489c201f340e2336d9671e06a2a130bd148b3423e2535691d441542d85d4c161768d148da33b3359633932219c9188ce37b26e3a4c74c8a9882550deb591e195d99ce4c3485f87746af1d61cffa3f2ed8108cb903b372b8e1a88d3916c9c96bbb7aa11e907207e33e7de64b78deeb3177c87b7ee89b9fed2e0f2f47dfba68bb3ae00069564bfa583465d8e7b4f08c191972d140a40c56672ad70fc0490c75f2cf9cf07b5eb9e09d95d33ac70217f4815a82d786f3f3813a1c7a9fe0942c7ef710c0647ee8a42f67ed1b160e9b5632124b33e144f4d172a42cdcd0bdcd66e62b71e2d6c785c2152c1fe4adc325cc316074e18ce909aa7f23f1015db58c7a3383a66d828f46b543f9b45f20270cb9d4482b8b848299b6f5b9526ef2edb24cead4f421c2cb390bb1ef78579606554f3b88c7fcf9d88cb993a699fa7cb7a21ccdd552e01f1ad81f42f97ad7bdc5434165fb9cd72428e8aab488d1221ed021199226ee375d46e381bf259b09370827221a3acaa17250412ca8a8605545d41dd5040a5e8c82407245f4b205a557747a075997710b940ad9afe74fd20121a4eca931b6e25a89d0f08d38e5417436a271aeab043f7879ee004885970ea754f9cbed51c3847480829e7e8717067796da75483d4caa4c6703787861252ea4b524c9eb85169d895aa961dda6a72c5fa391094c4f8215eed46d2948e523bd6087b794139a7d45fc808fa9388e4e0e37d33546896dbe1e3385a3b8d73460f6c20e93e7b74ebce6ebb1b862a1e7bfbd3c1ab03b42fb2d9b6e02528f0be4bcddd905cb380c62b54d316f620f88c7f60ca4512899dd299804154a28b10afcdfd4cc68e614cdcd57466275bc4732e08a2d2f7fb8b5fde13ef4e11166a1b97f952ee321d488bbcdb560039d2261c039579ffa601404e4f3bc7bb632edf3354d1f6da50e01465b6be56b9fa64de61fd7579e1bb8a469d03a5e0d97f33855bee6d5888369045dbca01b4516a348970c10c155964c847b1842c76256228ba18ca99aabbd30357eea18d41007ccb5ffae2e78019aa45008e3fe5035a951f4d2a2be9451b070c48b478387709c7b531624a181c690d24be2061a5df20783de80cd49bf59c770e7375a1483b1258226942aba00a4dde91abfa502f4579de6a9a37c96b5e76f29b0af2f54bb9751b264d7351382bc180d7be8364d5697089cab2f953c88b83b6aba72e5643fdfe6d090be2b0212e08f9316dc500695abec1e793e38651c5833e9ab8d74490009e6f2b9228dc911f1d55616262337a19259017ef8b10ce1677ec444eb17d0ba8f6408463cafdd01bd687761cff30b32b4d29c9259b5f5eea80b4c2a919b70c44286ce913236173af99b14f6b7fe7946b9e990f6ea9b472e5393db4c878dbee24d7a48881cf51c387872d0da574045beeb027135d94887ced1dd21cfcb3e1b7b56e9c7cf91f1d2c03df9392c67035b60e7a389cc190c3d13a0238cffbc8116f1a599977062e66e87eb42d480ce544d07f611c8242473022c6b30b461647c9ad31eeb4d29f2812c27d308fd481c57d767df9a0144b8925d9a4c5533b74e42e51977d040d818d594009a9c05eae3c0dbf2fe13227d4e00eec6b174e8a078aa657f71f4eacc298fa27aaad355167ce666a519fb0d72c5990357face5be42a8e51fcb88928f3518031746233f4f24494dd3c7bfea32ea41baeddaec36949e46b872894a6b5d9870280be0768d721298f3fd85c70e7e9bafb60617779eddfd3f69c9361f68f1d5fe8ea8db8bc12864ff159650f018a2c76eb3196bef0f607c023fb9d361b950692b648f8ca200690bf1a8d324ccd05d24a77340a2e190bfa50b3266538c465127b2100807142fcb862a7e5e80573580d6fc8be85ad686a15611b5b0f77e721cd936a837b3c3dae4016c01c0907b0d5bedf106cc090905498c8fa452f5dd6efa93a7d8ee00d65d379419fc36a3993d305e32f72731543a42ce8187c370932bb364fe4a35ad15dbbeb02aec87bef7073ba7bb65c0204795fbf3af02020629db5a1654e47f03e914e7867eb3143369b7eff7f53ee9e2eae257eed12f1dd32f0a97a592580539b0ad2307735599bf2292419bddd96eb879948e45d0ce1117e09b4987d8fa7cf1d5e928c30ccea7d0a3f1b9ff50617f64898a71f1d2f99bdb7422df74e188b068250b9c225923c883efe218940f11e550d3c339dcf0dc5e7e76153af315a1cddd60d4fbd172fcb0ecafa31d10498cb65473a7fe34bf43275db41b01a591ceb0dddbff747ce112cd4fa745fc6014ee5295a1a0533ed1503ca354de1fa93dfbb59dd813537932fbd4aac495e3cf00acba536a1c21f78bc3c5f84f6f374451e0979d7cff35eb204d8b2a754be63056f7ba5abd31c76331f99f346aa7b11e5ab78dc9b152194b9e8e67346e4b58d2fadf034be852a56eaeb42166342a4036a5fe23f146e93858b800e67c43bfddc5bc3e64226a9e7c49e6a5c168ceb349d9791521f0a0f80915bea74a4d4e144832ac560b470e0083f662f6ced9690e97f17890e08a7b1eca7d70f6fc56ab5adeb5b544e2d0cc4de0c5d4cb83d2f8fba81ab7e824915c03b6b194f88c35d43f40bc840b74243e5455ff6427931687a04403fd3523144d108e9148cf4c67585ded27018b6e94baee1d3e9de2b3671bff3eee7856b1119a7321e1b9b0d0a3915a6c35e76a9a833c6171a54233c65dd01e201da35da567e8cfd555ec3d9612cf26d67c700f25268ed102c3b81f65b3f44a424337a796787ea48d1e6d6b351b36a5c8832dd6378697bb37223fc32839c60ab0fca7eb3cec1ac313b8dbef99e8e022ba4498b5db79e73e1a55bf1a28c3192c21926be602ba622cbe4b060750ea0aaa89a738120ba1016ff24651f0c7319ca792cffa33aa5140e0fdb5dca77227bf4df021a4e54ad5dc02f673676b148fe69ded017b418f209e25dd09a674dc71c1138743ff633f6625ac3d50a876f1fb1f80b0a2dfd35e8973e1289b045dbea3d5731432326a1c38985e6525207bdaf130d291d9be3a3d2a6c82057b181fe64c8e168357675152d29b757be7603533072945f3ca1dbdffea2367662a23dead683e0db4c55e9e20b9e2bd249aa5c172f8dad30398a3e145447baac0e397a51a0901d570985860892c33aa8a6a3608c2c8bf2c4ac63e22923639a6b06548bb1e52f78fdea0770665eece5fdfddfecb48518f204836d174a7107cb67be51f3c0a0ac9ef3a6e86dd0b20119c6d371c8a3773aba68ea33ca9fd606938d629c07719c2f796d5c3ddcd2a57f912de66a16841bfa17d738b53e0732db8934240a4b6799a4bdaa32c24694fd9a7a458e51f190148602421c18f15a2631caff14e64b92303abfbc913c8ebd6d8dd041ac3ece08cb4f0a16b94dcc532b264819f3d6d6830de06b4c48d6fa05dc463943a78bdad081c940eb3c5dd8b1538561e1948654d7769e1279eec90715cf68afda703fa4dc36b3aa33d38efd8758ec078f344bb8484531712e699338e16e2924e0d5c5d8131826284bbecbf61054b4781cb8b588a6b9a9bc194d0efc5a42198087d45f1e886e6dae533e18cebe94965035192465fb11685e257c118922ce7d88ed29ede2c01c655bef620e7010e6e03ac9adaf225a603865f46792dc280bbeca5e4ceedf2425b76ade4ffa26ee2a03aaa8e4a06d8f3a94b8f15935065e17cf816abb69da37a76357d813bd22c6de5583f89e67ca8db21b96b31d0b47154039e7aa48dc6f13516e8e492318c812db82679e16d21f5da1ffa987de4d554349eef9cce4f74ad7a72bdff6f2362ac9a5ed4be0e7e832f2d51f8763207f6e712fc4f7020339c8c8b0092f789415dfa84fba1c4a06434a3b25a977c6e3e141c97177578a308ef87354d38d1db33964b6fd1150c670d9f9fa17238fa2f43a0ca2cfc467dfed583ba9f53152f8dbac1ca0d5d80ca2175ee5b27577bb27ec4e0a7497f3123671b6d894b3c9ab1fa3e62105bdbbac01c82c67cac64b1462a4cf34fc10e77371308a7d480da085098f2bb20352c9aa476322d332b7e7c49ca7e9b8350de4bd9f05a4a4651f3436d00d267b7c30bacdd3144b05f9131147d8ccddba421d9eb66840c819e3e0e3c5a8099b12875ab5389972e28ddc6fd8a105c4c81fcc587374cf86ac648213b5fdaf5383c6fa2b0bed13d3c398a1eb54142b450e33046c54218ed42a64aaaa27c26a5750eff50c5ecfc54c23bf9c3df60d05b4c7189b94e4a6c91e8094b0828810eb3e1e28c084540c3e4f7c8661cfba1bdb5f81f9d98577bcf1d3e8dcc59582b4f161740a3d17133879d9c03e0bd31267f48ad79a0b768379054554990efb5aeca4efc6e490e9fde060ca415121a68ba1f05aa3384263d0ff6001afc2d0e5648b49d6f71cbabbdf7be3606a3f0f080854a2c5e275dc09accf86a906d12dbde99b24afbf5f2673d00834b8547759eff1d01abe148b81937b2f4ca411642d2944b4bea33c7036774af45e7e14245c820d70bc3a18f3c21fcad1122098ae5bf46c463e3bab6f8afd0a49264c6295441767bf79df05e3770010c72abacc4ab141c2f537ed45a66411eebc20338c27c75f0403dd1cdf6d77a6f36d1b73c963265fe3022713d534100f5506bfd48958f8c595ed2ea58b0b81a55bd5f23299f75c028ac530df2ffee53196b7548d991b6c74aa46678c27e185a8a516015cf8cb5707f4ff3973c1ac316dc50aefe6d543df1f83a9b535e577e12fc4c4b4e080118a460c16fa73d917066ce3045e50bd021e01f2e4bb1c6bac1c6135d7de9b856d23c77115052aceeeda6e612e7ea1fa4be872c1f50e4b311c1c6c45c2dee647e97a8f31766d1270ae0e98e471513cd257d6a8e100f631959b62684d5b15278c67517198338951f3c70d4a17dddbc388edc6295cb7274a14b81e0dd36c54103d37146a9f9e96b3d1b5bfd46aca75d1ff75ed716546bc9088e8ef940b58ca1812445f08f1a622ed29f249ed9fdef214c010e56587166aa804e4f902e71cb6e14fdba58a58624144b4461fe07c787ab6522b397e20d2c7b192d6756dfcbbb0a42a1e164f7a294a4222b6fae430e568ac2585679629d066bf2b54eb14b92a2a78a5f7e9952367243f49f362aeec62ea841a4069fccd0cda90a31fa7b0d6b6d58d8df808f6f111daf2fb50c7fc37519a757f27139bf6c0962a59eaf6e42740386febff0e61bd82eb52366021df0fb83577be4feed89ea3f8c66029c56f1fea567c5561eb87407cde0d266428f03102e7668e0596533780d0ff8f83382921457eda734f681516c9c374ae87c45aa3a54f32d09b83658fe15f830313e7e3b8e25997747b96b8f150dc8b1084c5ae70d7460d90b558253f536f366af789d5be4c4aff2d3a5074ae4638ad05354588ba4fca6dabffa54326cb772abcaae1a8fe09b73654b3df8e4b612d4d3cfa416a1d2e48d540510323279b4161a11bf1ea748aa1f551eb5422749803c6d6005391719e5e8b97c5f34ee404cc165985c9ba9923bba493ff60d8b1af7f1e922798b5e47db5a4397abbd5b053382370df438a2767a7e8f49392304def34aa55741f87ee0f5742a71140431d2cc9a64926c6fd2f5bf5b896613637a698c33fb10ec86dde23b94f6ee6ae282646adc9712d2bdbe024a1688fd139ffdc4944249ac033d6daec06c148014b4dc4be186e5fcb516b54735b3a339815ef13066f5346cbc680c22416fec80cbe7e625c28d577793747e4e9654f3e392a01526834cc538f7106744fcce65d09c34c3adba6847de292b4f0438b36a5fa005cc344d52735e15f8cebca3ec472495ffec3d47549ad4a1eff7754705b78b4285c477bba4d574fce552ed31550c96f15d33265e4d3c93d646f4942b9ef595a22640eefa696a86632c83412475c2fdee532d5e86948a789fec20481504eadb9d32053963c14a76818aae70ed8b2f614238225f54edc35b26774ccd1fa233e688a2492447672fc45f359d30ede1f58f2d2860023d96d5749649bf2655a9c49ee6fca89745504a55a134342a5a3ab5ae6a6c418946c598d623d4a9be5d95f6e4376f9d2b0c0641ac0587fe9cc679bb69505976baa6b78c626f0b971da256ed8da5897b04a0a866bb742196cf82f2d57c288aa0e9461a5eaaca641a51835f2baaf428d488fe369c16a3aeee93929210dcc1ceae486043064b20a0bfb06cef2514fadd5b225eb327eddad396cffd0c01396393bca95b91f3805957ca0c978cf6f5a1a6a6d3e348177529893406d8def48d772b9a3bacafa70e4b12257c37d851d0f6d891e20f3fe69c0961f45217117ebe27281e3cf2c878493d3cc4ad6d15e3514eeb4c504c21da5daeea597e1421f742e3191c3d30e496b7f8b5c714643356a410a681eda58d6e12c9b900441bb93ed422ba5672cf4f03b0e26a5f6859ec6d7db5e40aaf93002cc8827fb9250d77724e99707bb3ce226fd3035c676ccd3b3bd0b45f27ca4778a6ebe63535d22ede5bd641e5e6069272308c260e9543dde2af6aec2f6fff983d135e949c7a5deab7382f6c0b7c1c5a84aed319677304bfca2306c99d27e84b7f8ab017ae27a734ba87521ad367cb203f851ced8c5712eb5b6421d9b5e64a31a09ba11a0b77f34db95de9b4950384111518e7a64cbf861339daf622c39162078aebe35ba84b1e57ff3b944993a0f56d2758f866d5e48dd59faa4dfd34f268aef98c865ead783f9262a745fcecf648617eca55c43cf95ece4608be9346f9793bf1b7e6a9f6cc4cd0e0282b456f0ab4e4182087d64f0e756216b3462cea235aa9cc8f43aefb33d8144e3cdc77a75621c3392a869a456565dcbec700ad3d78dd0cb4c6a4105fd543b23a206ab5226ecadbbc391227820876df89d882849a5ad598430a000d18572cebd423a0a127b14b2ef278424144629524b978f478b5072c8323f716434927ab022441f926242f4e611040712173de335bef7038143c6212e6ec2c9ef2b79db1c880bc75c794f9c7ac85f881eb5aee697c1fd1e8bedf8c89d28753e8b26096d2298a2f364bc682d6c5994d5848e3a4b9b23ae83207241293efffe67a8d344775e6fb95bc3d4948e714b804c847eb76e1d0e01e5735a94daff86aa976081a19f84985e2ce12455f169a2a07f6f261c7721bb8a95bd823c4700986b8b221e9916fec4903debf617762f502adbebb3201178492049b87d05607f2113c95b0a9f2f07ddce84fd730b7cf1869a179f395232b7cb824b3039912ab9289d53f507de275f8b933cb47b27be638bc57638bf220a4d31a963b2c1a2eae444eef3b579ca8a4e9d556d5a4197e545849094ba99c4a300d80bc84ac14df256636220208d272fc1e2ca4a8697d7cc4d74d19a2e3462cbb86eb8df3710d3b76da7930502cfb4aac46749e52f4e54c09fbcd4efe57115c12f82f4870771e515c1e18c94803b42a87a8d17c15180435318856124f42da2ddf7ff2ac0fe941f963b3221af4e04db969272eeaa3864d1ba168fe599e5a327004d1cec15e418d5bf62e8a93962a492938280c69686cc141f37d429174480a93d91188ea11078e42997c8f8743c5c8783bf5a24d12d16d2a62bd8e75741beb86029c46d43e90c4a7ed20bdb3e91a426857e1dd94b4b98186df0abe24ef05e93402036f421600252d8e3c2c0281afcbf6dc458dff4e03164923810c7235c1e6eac9f5b7449a20bb5c70158c2ff9783a77b50229931ca02281159c05cf5d4a44d4f28fce62ce1e8c628f65ba5af616b547bfb2f9d0d34af9204f797a02649ff1802542dd37db5c499857a907f374f23d0e158aff055e0b77fc558cbd51b2d4ba397484143ddd5890a60464a113ed82dc67b708267254f131ddba0b39b6c5848c6e7f11c1c6360fddcb04ccea260101d0903b1adae24d59b9f66cff7d9496427266b6c68ce43c53103a5b9ff97c6786340fdc676f3b127599a640e9dea9eb50b8c72387ae83f32d86e20365721f33ed87c72232f4b3a5d0b526e101e9ea378e85fa211783a8bd8ed21e5aa9552dfc1ca9dc1c03938fc2b0e593799493fc7d7b209455f69b6954e0dd66d3740e73564ac9afafca8e0088abc4c0ea7b6e5fab71eed0ae274ee26c38909ef5eb352af954157c67e0180e52cc9692357fdd3c25f31cc815159f311674047adabf34e56b0e73e891fb4dd445c8bb44636fb9f83cd995ccc79f2658713d91408926e615001284b55ac5639dddfeacadb5be78fdee00e10ab45f8eec6b899023e54c4a6b8fb96277ece674b971bc7d708fffa33a2c7b0d55c79d206f40b1b71c4713fd67895a65e535fdc59100b90538433d0aaa782e9e05a7e6a0bafe4d1becdf772d72fb69aea3821294a5116d0222a10f0d17f05a18c88ab3b0ec620d08b4db43e5c40bcca6c6633e529cef09f2324d4c3cee8a01483b34e15a8c1e4da5a6991a4f77372672545817a864c4449b6215b953a07e8ac0248feb9734f174d49ca103fe68c17f4e06d266de13195ab73eef37fc2e83fff1e38529b66bd925fdb2c229bea7d48709f9b76f0f0bc54fa89bb47e5004f9103e68879dc5f13052e11131184df339a969518bab75713b313a10c5f5114790681aaf53164309e9259674ff0da22ddebc9302ab19ca2e09d21dec826e84a3aa550f44a97a1131161daa023053bde5ee9c8b78980ecf586c5502f26f06cce2d0d48a3f0633ed91768da79ec7bbd60068fc745ef3e1f2fae7b5e5a2ba9c9477c41a133c2e1e37f5c61d764b3de9ee03884aad400f9edc0ee43a45381e049bf07c445c59e60fcfcd5383ec99cb2a109e5f7b05e21a3667593d390e4d6ec7ff3998f298e899ab4cac5e21b51c71931c5e02808d6a7b9e4de667c64936be8f5617e2f8152402681446f5a85d4d074f129e79ba028b54714d74b3a412d767fd1ae0d0371718cf4fc4069a35521362531187cb35dfe6fdbc67aa2a078d320b3fe3746d38cd20d06abb9caccf48a8f3d8b88631c9f8538527e567df76e30821ee2dfb3c75081d429e4a9f5315a36f6a90c951e8795a8c52fa92e31c16cd0e3c30bc16b83a17d188f491378c9a3d5cb8dae1932585c0bf401bf2fb2367d1c1a287db5b707efcc94f05ec422e7b8d202800d5117fc5d27610a13505fbeb7e24c75e84c384f68ee50bfa3b2760523393c288e0bd002f67833eda251125c660b5c9cee9646a87f8d179a11760d93f7d87280b6af9af121888c2c1fb742633277c39bf7cd8b4dbef1eb344b96f46f63164a8f0f5176891d6a6178359399970a3cd3d86e49319a53b5aae7d59102c674de8b24860d151bf753b43a78d0386d2e07f85ed06ac559e0e0b684d4210c4f69d7185def2f2aebf7d4e95abe1275ece5a26f2571f71341cf5080429024b798aa657d82db7a98142527e28706c77fcee2f5c4fee9c04153e485d169599430fb08409023ca4adc768dbaac4d9257a4681251066c51145c151388453c80c5be73fbd4a7c231c036c5b36fd0cc31156a84f89b9accfc0aa632038248725356c3fa89df4f83e363c7186e3ebb299bca7e7e73c40195bfa1b2ed92384b14eaa423399c28e5ea6f196bcf7bd8cccb5038410a7d1a3edf8d297ca25f2b1df3788bbbce9dc4279e49affeaac19484324126bf87cea4443b2b619ddc5f3ef1eed27aafe3542dc51aa4fb3d9b346f10e61df77a87a51b7cd5c85af9f45bddb874731d8d2220a9f7955dd224135f977cfc93b46bc658db4bdae56da00c82e3aae59a273755a258bef2b80a96b8d52495d6f12420cbb53ffba3033eb369598f27579690e2796f5d465ec66fe9d5cd0d3e0da0f61813a37c77ff9edeb2f561e1dac54e62c12415265cca7bc0413e89b0aa6bc6404d70c3b1dbc337445af367292f0aae1d7653e8c8824ef320ae446d8d1c8412b488101132eb5caf7169f85e4d6923c3012cf13787813960500e4391a3bc07ddc8c9f322709350e8269c2733211ce2107a33e8d5f3c90796e57f9b8e2d80fafead0bed615d4002798dccae2b6cad441869f81e934298cca81f1fba6fcdfaa336da414efacb16821b543a76603d8800c71da8f583d756919f727b1ab473a3b4c3b077c341dd38ef2cf6add998b1ee7aca0fd17d2610020ba8894dc5bd91514b47fdb8d9bf61315e0de24b3728e23b553eff7141083b543cf732f6c87c1aef7212ae2a06766b1328ebd737362afcac4eff2bdaabb383fb6f2c99691996d3a2bbbe89305f05dc69b10e7914bd4553f8d01c147fdc6f64ddf613461547ee88036c009fb921dd9a608480f43f4d5243b1ecb9dc2204d65257ec822ed898dc784d9ad58e77eca5e0f2b3e2c73b3588bf11ce7279b1a95343a7ed9ec036ddef4905e929a3518f7859fd04de37954526eb832ff9620860635a53436217f70b551f37511804bc09685e086fe374c9f59987ad9decbc25580993b040db018db7ef9a3ffbc7d6c30c06ea928ac8eb352e34e34dbdaf1142a7e4b3be464ab35eb2456b3c0966a2321121a947f6246aa3b4ab0636ee1613544417e64c2af81ef6896a7a222df676ed4aec637e41b127849babb6a46916b9b68ce69fce499f4a509d51fff21567273e707a40f245db0e57f7cd6503ab3482c5ab96118310a61d4e6638d4577d4e525b687d1f7d124542ba420948d11a0011a4ee3b4b199dcd1212625e705e1acc2aae77d5487694533676f3472b417fe5edd173e0ab988d1dab38edde3f8f8a88e0faafc878c9338c2be78a09ac3c6b770fb643b8f04e66fd71b73c110048471f34760d6c4af176a411ad1871a8037256798fcc04e195a3cb19df47eae579f689d57bca1ca522e62ae8393c2f0d27d95124c5b77447fef9b3a203fb87697ae46a89f011ccfe5bfd92bd1685011bad6798f716315f57bc009418817881f1a8b248eaa83ac88d7659662a2a01b91be336582d7025f8598a072a739247ad4d7138dedc5052b7d6ad482717f31dc2a8cefef938b6cd3465271607256398e90a2de09ac4c1fa8c05f953dc62f33ee0caa8b17ca2310fd03f1dc2ca0b564688dfd59f97aa4d7e0b0dcd87b918089280c6543adcf172d4b336a613bed1a9d0c5d16641653800d6e92603ba8720898169f4eb64d2ed83d454e00d67d5cff1145a617089ec35bb6c237747d7e465484610d993c4468a8447e9364f246e0e9835f3ef84d7afbe102f3580349bdca0d374a4f4d503f9befdbf9d246c288d2683699bb49142d378e62c5b5bd4a918af8c0aa8f625c6076cf71cd2dac3947ad003bbee0fbc3289dd381467c7adbaa9615400067e2259aa8731e81f035cfddf2a95cd4c03dc047a97f929f8c70548aa9fa2a4d22dd0e7626370d53e5f1be403329b255950915f44acec77625b01100b2b07a6ed6278511c41ed68567d0403f199e99de7e06f4a7128c98f9ffe25d6654bdebe4081cdd3364a6551cbde07e4ba0161b2dc5cec749560a48a1871c8d3e7b9008f48c3540d12d430655bc4b34042e3c80ceaac505c71aff545f0ad52ab5c80d9cf0b0ba2b4bdec37b6a5baa8bb74fa6e5496e6fd730e8cf8dd48c3d8112294e633dd023bb1415177c32aac6c3d54dd3e9a27b9b405c406a6799d15c4adf791a24d38e27e62b0e96b791762e43538f2d0ed92c36c2e239762ba50612b0820eab5ebb903ac3a871c2040f4015adc364431bd92b194550f975cc074b9af929f0c54bdfbe0e87568294650e20b0638060dd330dda1b3e6f0fc347303dcc1841db30d67488cf2c6fa54fc80bc58b6640e5661f0f8971205ebfd6e4b1360d7dc9628e78ecbeb1950e27831af896c34bfa9c7e40c2852896b7ff2ce105e0b0561e05f118c6bc5460918ed816e035f21905b5379f6f522967dd1e40d251c0f2e14627cd94990e8a72639f5370cbfc39a8ac01b9e2d26898c04e181a4a1b71795b32eac6b4bd53df6bac97c412164a329f58d6b027372cdfea502b680b27b2095515d23d874405e16c5aeff1c7f1daff4ef12716a96858cbf2389a4e76317adb293dc5d21e47c0d00cacad390d498a34c33c9f7fdd6b70b283992473d31e01daa684955a8323cfe19c15db7a0c9e6bb05c068d76d376d4169d7b7eadb10092b9c2002d2eeea500d7d1bf724e55189adbb2e7c8f780f83438e1b1cc535f13609a47c512613c2e0ecba6d5a79d3422b787a1e4d856f4f94cf25de4d6f49baef94be3c8463ac3a4967877062a3bbe80e8d73f5208c14a98c9b9e8984904bdd16284c2cefde6ce5e651ecb7c79572e27852e3ba19bff90504f4cc2ab4cacc1d4dd06cbc8dcb23aef89d3471d3788bcf11223cafcb3e1af23fd09b9ff9e5f6d25f28dfed5686b3d45c83538a415743fabe58956e13e47c6da8fbdb0dc2ecdd9e62bea7838a3f0dcccf6b8eaafc","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
