<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b364de4d7d0df34410351527524166f372b673e380677d83f97ebc02929572455f938ea07347d9f9a95f757c068dd5dcd5de50993be0dd40bba48aff79a2c590da7ad6b54102ab19b6bc9b84ea15ca413626827743094bffb5d1739d04dfa4de9cc180bf0bf06a645d717242898effc1deea10b33edb8b55c3878b8e5cd6e15db95881e4248b04c0c62a760fb0d8ebba94c235254453a3d13a3ec95626f29cfb1df74a31a051b2e07c080135de62a68e40ceef5be388e01161a5e41d542ad142b680222b21aea7a98b132a2352884c8710748dbf0be43d488bb28345066c2e3488caef5dd9e24d1b8c26905535fcf79b243ffecebc2323a7bef5fbc130c0846a03c3abbc6d6ce6b956631de9d60b90e1619f307d8f0fb3f8b79c35a499dc5ade369509c13a78147b64d23872e4a55cbca577fb47ac463fc74d7292134d8520d63dee43c5afd0f5a24d15ac43834e9b2549c348991a68a8332e20430d9b6c1dcf786a13c177477024bdc26c60d9c583820646601cdaaa437757cbc9160d49aa97eb046c5fa1028ef71a29196a5a162b28863781cea4309cace932191215524aa6a11631230e52b6c0df9775a1d8ae59e187f5e2309ae6e7097150980f1afe37f7559eec747bd773124b19e95b769c0a39040b269ad359b62ba7ae462ac43cd33ad770cde80e920a3c659fa95013dd45a439a5d340d4114f1d90d4e8f00b02814e357d17470d2c4de88f6eb76c551075e8401f1e103686750d08f05e415b695cf690e2fcdbbe4a8223dbdd16d86ae8371e36b789c5b252b09950ba01b14e75469bc3ffd63fa597a13380c6c19fd0f768e4668c9a090134954fe2b0cdb87c7e486ea848a65fb1197915b62ee40cd2faae0c4fb4ef5ec890d5b1362469c1a719387f84f7d1bc969aacbc3a456a529a7d7cae9da0837f4dc2cef1b1c6ba1df4c35e0218614e9557c8fae972f2f0d1ba0524a5a198ae337c8f99aabe70400a2babbe2c62de13cdc9c028a66d0ce65116a594e224b78878883d1b8092ec89d17f11ebbac6280b59cc36b3a9b8931e27a4cc20c8989ea5c76e12d50bfb9ce87f49f56ea75cd2e7d48717ad93cc0180b6b85c7989838d4ae7bfe331beaad1edc019bbb5c6787ee2089868218e21fb45c1059fe03ad3abd3d06f4ebd8cec93cb6e4d3112eb10cc7f1d3ecbe39a766561782a8707f84fd55fef583a22614b5b5d670743118053f545ce1e93d9c8ebc007037af19d73bf7bedc8b709f84b157cfb6a8f9d84808f48c89fe0ff4da59284440925faaecbd44b00ad5b656fde7d08263f6d2dca2ef56a3fcf61fee6ed7d4f1b97914029f08d00b8a5017fd7559d7840e7616fbc8bdc227fd2931b48f6f2f744876f5b751c51603e73f4a066224d2230c75bcc3621c37e6c9637315c6273f6e05e9b5c6355cc2ea4709ef8ed279cc3b69cdf6b1fa803e971ddbc7ccdb4fb9fc1300f7ac859f8518b8f8f00b7638ed1987899e28d8ab0c124413da898c52a23470a9d7881d151684a0aa773578f058dc61d8baaff7068d9dd5b436955060f7620096ebdf0350e7f66bc019e41b1ea2ca6b9c0aebff2f8bc5b101769ca38f260b21ef491681a91f5e9a32cecc9753c16d3c9c0b985b061344cd5bfa24e45f95af244212b79c12bcfc04eaadb71aaaa754e7db0b477778483cac3427898c59cab27e1c0cf1651e48c017efac43eddfd2f401ec08b3014935593aec7f8d15a69a734d28ae9720964dd1258d086c6d860e49c1edebaa7c358c01a1f90a5b3aac638b57894082f72ebedb13be64bba99bbabf8505e5e8d3a2920098ff3a28c34e4e1f2c412cdb4e5d0e172e912878a350fbe5157a728c7ff664e8261d31cedcb588fb395d8600c2bf2cd0086717e65bfc97f85bd2c181e8acf06d9a5530346df7e6d95ef0508b2e7873cc7076e70b2db0a593c4317c061948180772f64355e3005eb5e83e5f594e08551f6516c7d32b7075cff4d6365ca9a535040ae90443132aa6d1b8bdf8e5af2be1b00069bc8984734bfab486ac8c7cd3884add90fb33b5c527ebbd8c70f95a7b5a5779abb6f2b0234357f1c0d0dcdc8b82a505fd1f980a898898255bf77bc45b4b880ae8e8f812da0e851ca8155fc93c235093f18a2493be5f4c1bb967dead285d2f4cdd67b53dc62c5d306f614919069c615f34da2cc425298c079465a50f54f6ea7d80b1ff9f649b73e0804307a7c4851d9403fe4a3832ac53b55400611328e9aebf370622c7a5c4773ec1a4ec0f6a78295359f0c2a4e35c91eb1e7b6edbd39c6939c90fc9f7db6eda180aa16a61803c155743e16d6f8bb3bee518765a7f90494affe9b88c42a3b4ba68477b2575d6bfaa2555583d252823613f21e9f757ae1f294fffc64cfd50d476c8e05eb6b41f7c02c1174948e60a23f846c9a2482c67dd82e0b1c9b20ebd82f274baddf236ce86445155dc22cd3c7e00775d422fd843dd593fc4ae48fb31dbb7747ce816a84dd7552e780109dc703136ec7e0072ef669d2d876f6708dc90af4bfd09bb1ac77937cda6deb63c4a5589f699913e0bcc260e57a36898c6429418c8f8c2f48396a51b80e99084c268b9a6b5aee84175cbc86ae258ecdb62dd2d553ac3f6756939e196a7acb8800d20ff883e3cbfc0848877da3e590f2b273d4b81f22880f163c0fec461dad27703b4669ab738e69b7088d4b2d2377e1d1bfc4682a64d249b53624dc859e7cdf2ee5b70311da4028026d835e3d4f3d390d41969dbe5ce62b9868c95dc5e45305bcfe1236c030445dce5aa5eea37eaea59872662317f8187bcac0c1d576bc8b09d9861e393c393753f6c516895799e07d1421b7aade7813c9bbeffa9e50b045f15470ad6184f7de94d351c535f27d2bddb3f45310350d033220d48bfddc38d2717dea9ea90b17c9cac1720193ab6416ca6d289370205da39413e3ee1d1d4ef5d2c3d394d468af5d7d88120d2574b58de08d0ed13333e6b93a07d8986e43b2db7a6ef7cf0661f7709ba6d0e4353557444850216ab6afd239281b2665ac61cd0f1ae74baae014348f69756a533f3c6163e585908f8c8705bc1efb23eae7acf0f11d9853e683778768fd5a52dd15926c6257c907ea2827cda2eeaad5163e6e4ab5a3c5621de90db746c41bb12714e40aef49cb42e3394296dfc911602e4ee22286f5598a2223f778e7ecdbd6e88ad6476fd86e26675f4360e2b55d85513d11c9764c5681fa0e249d01709ef06dcde4e6900ab9d1551547dba8a6a3d1574c567bf975f18772819c561b31e3e2a65eb6c7778f9485687acd0cb259cd46ce4cedfb89839863f6b666da2ca92543373dc54e0e8f60e4ba0be306c11f0c6e1981428eb753bb1c63fd6bd3a39e447b4d93c968ab41f6de3c9012e254471387b24b90197d1e3ed5c216fb2bf98dbec28a63b39d04dca5f2044fe80ea8c6874c7c9a94d78543becf0068600feb1f526970dd7dfa18b4ee90a0f00c64cd957bc83351ab0bba11c3cfa2db6ecdf6ce763ed1db28c6c54df507062a4a73c09ff3b78b4201f2806fda2434d263dac6aa5030b81f67ac026268b96d33f4216ff4d7051a75922cfe9e5a587753a0b7be4d44784d2c0e5980357a3502987fdc16d2e0627f6379ac9bec4e28eed6eb19c8e24487e77ab875845f63e89a29c7e9d77547676be10fdbe986f90f140a507375991df6d2591d3ed91e724c120eae296ed304673578175264d9e2ce6d8edf69655001c210d26dfccb859346b627263e12fe189bbb4672dec14c14b6db3a2218c0cce1c6a681b27118611e61227ee72120f545b4ee7703a0dbab638c777182a728fde2c219981106b7c9ed6178c24e176195077032b64053581870b663fbe8e1dc85656c3f8d330d57d60ba7dc51d27b75bbff7fbe3521ff5ffaa0a1e52a2e0624fccfca0f44c022ede2b5139364fb24d13f89a9a34bf55ec9ef338f238098724c9db5b9819cd4b85eb7ddcca02981d89424c6d8fd0d701e6d5fff5be8b585fed447638bdb0a4409e7ba70e245cb4ea420440e5f68fdfb369d698c22c7091c44482dac462b43187d06b4e028b27f91e1712cae771ff0e9d9cb562946e7cabeaa7d48952077e51fc3020517e4006785855367f9d141e82c01f70e013808b0dbeb225bb1d8b6e9499e0d09b5388cfd089987c3865265f758facca8e07fd9d95e7808353884d644a92b9492d7f7c2356c25c94f0ed89a84d9a6bcb815590553291d8358a0ee2a199b914aa2eac528714d02c668d7e9ef5ea8c41a0bfc8074632a9a5aa13a0018ffbd4f8098719567e2e1e0b070335ebb98c1542dbaab96b29105c4f3038b9a2369dcebad968356ee1dd1e1515d01278f47763a8d3f3681c3fddd512ae98940245852e3bf02bc538909264f84caabdb75602dc9eeb9f182c0bf96c651a0dde21eca1d49fd73f7cfa0a211827ecc3afefe0c004c0bd1ff7892f764d5d46045343cde643cb823989f48d8bca57770059dd7f5c57cce37a5f7da8f3654c0f031c93f7ea8ebf2183d6d0842337b3cfa450f511a96805482c2e8f1f6ee36900a9bc37a819e652a2a5cd6da851693b57247ba6fe19751d1df8720601899d1bb3f7162634a1325d0f7a3d71b503308f96656322e268cbb3710f188b79dbb42db43ba2702214d413d9cf6117d5bbbdf7df4b584f96ce839bc2a93494ece6a2e97fc7914dbc712fdd41b28fa9a02725b13bac2f75278b884ff17fdc79a55112d3a9bb5ec0053880a11c10c45e9c857df34d68b09e23d11a0e3b3b4d81373b1713cabc7c2369b9fb55c62915ec038361eb8fa372bddd87927940e26135eb122a33cbfb88b7688d874fa287a835f5941198a9cc1f979c875c7dd240caeeeee5e6dee92230971edbc0b1485621d120bb5e7df531b11f2863f57cf49a112a9ef4af412ed882849e053eff071c810d36865ef914d133cd12b46011bd2842a20c266efc6f6255a0a80e44f904ca2cf5ab2648f84a6f0d0f537d037c41a19abfcc97e989b783613f98b4997ad96df898b492c8b7813b1a6dfc19e6c465a688a8734b5f88a916faf3bad7d0ce4930b8e19863963bb2cd5090d2f691124e9e90e68c018aee02227512672122275b232ebb2d71138064d148fa94e53722f95a41ea249a9a3a8c727302ce0ddbf8fa67c192d7ccf90b3cd888b7c882a173e8a59dc5629e83e39addbbd2cb54501984d5d9ce8a4e2a439cbc068d87c0af62fcb63a06f6935328368f9393d1250f19ced1cd1de9768289f60cf2ea80a8f3b25f98ef9b77fc8281df883d0192e50a50d094d23908dad0f5f4dab1c0e26f5741c524343dfe528e2320c56084dbf99805908ac75d872a1b934b73379234fbbcf7ce8588dddc9ff7dfbb9823203e97e431ad0a341398e5898dac95b63f107712bf46d96a9584dd90c7f411b71864c9544073da8c0a9436cbf6ceef1fcb582118ac190f704c3003d17388ee5bb36a79d34da071732ad4a633abb8141fe936f5408e6767d42f32bc705c07699d56aed731e6b79a62901a7b6a523aca1338e56175af68ee9d91a0f40e722da44e6df76503cb7c5cfd62aba878edad67f1c3d9025126137d82b6e13419eafbfb917fa27544eaf2f29c486ed1b317b13e87fc341398a4e5be1d9f68ed132de6ed22a487de47ddc34895e2b68a79c4617f9510e7538c88dc0ad5da326c44234784fd2321dfb49ff7433ba2c9981fc21fbd4d0b9e1448ed23d497f8de3ca6ef85f1306f62b828cb6e4c9a70d48d270c500a0d01cf0dccaebcdd3fac5b3aa67d37457101d666255628a03a229784a282f8abc825f1bd215775602a42c42d1dd8691dbe63567d62381e855d63bbcc1f8808d2077f915c0902766b25f8f7648e6305a0b898eb926b6d926955d2560a56b9b940a0ffb3226fc545b113c35635cd4daa29d9b304a86ed6e1ec3f0c8fb9d415c29936c744cafb6f0bca1d1c408817acf558de2a9f4a3a9346bb9bac6eec3a383bf97e295859f4cc89ea31a2a67b3b75dc715ca537bb1b37c7e941b3ddeb6292c1fe345dc34eb54cd53a7f7cd6062c178b6763333482cdb1f846a15f3d6bca4538094a74650f2df3d579eb370444d44f10c58a45006450b478ad3f0935dfcc05660fb8482175c096228fa9cf6e9c1d074f08593bdf4e13d3713076e1d40442dd8e8adc3cc2a129a86486ba19f02d5095402c3093adc6dc2022a9c65f0c526e506081437d090be1c4a7ef526872ce0b9faf3a44ca1c772cfa30128550796db251e4f4df7b94c01e9e68eb94a30029e1045731e561ca352c0a0024f8bc9d32920b328fc67561cf7905120024dd63d0c987fab7aeaf08cde97e7b1e8ed166644486bb647245290798132795e0927cb0a9148ad7f98b427275de93681e7d03aa57d760dca89be86eca73a3d074b37c4604159f52e56e45d213acd345932d442f46591a810543a557faa6a37c9d8c69c3985b6684d5446663120d16a7bad15d9c1177973a8f9e057c9b53eeca1ebe2311d2ef4f5f0cb4683d4cae5cc4bf6cdd1d4d967561608fe4f4b2d1d7b7fa8c5167b7fac84033efbfca7beef22caaab11cc0f76ca3ddbdf6b2603f49418cc1ae6ea2514623a5b29cc182fda9493295d3d465a2b8f0a7801f1285da047d0d1fc3ac0ee5bb88f9e84a36611e94fc4949ddd390a902fe3fec6ffad4568a9904f43c53c88ea9d2b75826d92ffd6d2d25fd0801a33d6e268328fa2b016f29a02a5b75a8a1cfddf2c9696c0d9842b64ab88fc6f7d61391f972311aec464093625e637dc5353df726e232ae278b3a6adfa2ec142274a7d3b3f67dbf2aee17357543c3db6361c5d8d7abf9c0be06908596840207622f9b3fe0919db856b6915ec448c27d9b822a6e03cc0bee69b2aae77d1dfff1f4c23e24ba58f710671b69ce308717b769fca16396a0c3d1983560780e695d796fb5362b5be2042d1db23c17155f165d0aac03e9fece4ffb1d862d7991d04cb0202b1387d52524fa227b98f206a57ee1efa12a07166b884ac144d2a843f9d14c4405ce2e7a0018c4e47b77289a783f8ad4cb9c11431b8f110c74f478c2c0959bce6c330a2704371699488429e1a5521ef49fd042dd1b8dbd8d391e10ef4887a270f54e82372bf4ea63d80fecb99d99fc1b237aa530b54c77c8301de80252380328c4bb4df69b771960b097c150dc351303e1ecef3a6c7e8cf49a366cb8268675d3cd6e1efe17533fa8eac3e495ca57c78e7720231dece24274744a8465fa21bc6d6a081b4f6c7eccae799a289174c0f7380f2d7d4e67d6d17959c02a54e2954659bf04a1e341451196e403975eb0b2887606d49a69b47cd81615627b81846dc6ddf3ae61efdf4f0b34044744929b97cee76fd6f85bcee1605bf7fe22054386c72d302d06eb492fe41526c5034f64d0b1e0195cca477538f02bc51d19c10b53a34e1061780632021f61b0ab50deae15a596671748e3ea5c9d85c6f4ebee102a38b2e214f01f9fa16eebd28d015ab7c9e526870f9ef8fc288c1d7af054b0150d24803e34dd4f61c973be13374fce7adf5e2d5c70760e098c5c1775f327c04f8050b71423a114bef49910bf8f306ee1e66cc047d5eeac0248314fef72a59d4b071e51f1c8c0df3361f9a7bcf1c2bb04ffae0afcee0e853aa7c5df72c36d0c987ead3260e1b7f28bfe1a71c26cddfad69ce697597799f984847ba6fcf3ea36c615c444af7c0eb348b5bde593f860b7b8779f383622b3a95326b7c0977529724c51ddb6cbda35d4d19b7a3ca8f10ddb662cf1dc28a6e132f1284c3545e81ff96af9dc1e3931aaa362b783b3f5c9a71dd944eef6015c8ecb1b96a2455956f8ea7c76277a44d7033daa388c22f571c8d3e1bb07f4ac9ac8b3377c68d9fd4d71ffd73a6e25cff5e1f6f6257edf4a0764dde9b88ece4f09a2580044fad29183c28969bf5d4f6ef98a736369f2e6af70fc7d657410b72e6c8022fe41572833e901be58e21d60731b5428aaf8c7bf9972b550952f5333d6f8988c8793129701b7caac0b3c67d00394f0ac3a1d7d89d7c074a2308626f57dae9bceb1622a6e5326c7de882b4c845b76dd5c2d17886b15fe03727dbde678a73ca357eb88ed52120354f6264423838b8b0790e19f575c05271d27826cf650cb0da12a30785cd257e2670de123066f95b5b25b587dee50b3c94119e23fb23b2eb69ee2fb2ca1ee799f7f7728bc1dc8e1ef3a486d65c64981564418d9bd41611b8822151b37f6b8ad4a48ce71452ac8c6818ea6d4070550da017ec195fd8dadcb1d328519ba51c4b2bf711d5bc404181b0f9656a5a69550597486954b291ce75c10ba5ff76514123f0edf3c2dc5c1fe7b04c37bc8e6ed9bfe289cc29e78386113a7d749ba43e7df813afaa552b3959adee9af4ffa89570734c007da58a238def9a4462af66803101feff491677e9897917c87a146785d04b748bd2109a8a3fa58225f1210bd60aedecd88e09d7d6adf45b6f76c90c88779e90c2989f73d8b7772fdc8fc39ba19a54c608d48c2b7b55ff3c00af25fa2f63b55cb2545956fe484fb2658a3b60543214e5305262192d2235fb4e748a2e8710ba9fb026cd0d8c821150dafcece609649009f86c16ac2843b17b06564098b4f28cb2dd17840584b25a243d07a8a6b24bb9cf9ad8b2eb24b6f72dad8795d1e626dd3557b154e7a669d6fec2617af536e197ed4bb02b91d564b9e1d81e0ba50de6c4b0e11415bee73c2bbbf0b7a4ae81d07f01560ee3d02f77194d88e85621e601c8244f31eec8b222f12ecea219f822ee22ed66fcf1cfea91791497eddc39229eb081a3c1ce8522e9a5ca7f3dd4fedea4610c9dc21c55bf373e92905183aa0fa91fbfb02b96eb2b231104c66c0cc6a77d50bb181bde82328bb2fd1009a2b66582ffbe11ec78f30f4b0d288cfa46180b72ce00d787c2382dc05e812bfec5515aaa33f209a8f418f7569179b9b82d7e49a2882839143dcc56127c94c2a7bdfc96aba4e020207339c37f384b635c6b3a25a801a4d5b6f815cce8efca0e0bbf9e859db77be1fd814fb95907ba75597c5e243c4f95d225494f3509df95ff7a57313961d09a484ec106d659319711dfaf9f5f0f7c9512eef915632f12bc91ff4679476617a85d7d829d5184bde9643a78949fe9a2038d44a403ef1925d6a475a8de0f152d97f2bb8e7e12a66e6058533c54f0eb70a411941ae443d0403fa713d9c79c1aaf6962ee8b19c00124822286bb001d963008ba3c92085a6a152155213c1dcce77b2e6fd7b6fead46a661a02c56748251ef41a2fcd2e71da66233f8b0202839e9c6aa5e9b129bd194073c874fcfbaf15718a8576b431bdf6806d47a1ae2c2fb82124f2517807f1ea297032cad5564222fdbac9230894e163fb88f656e11cd0cf75779fb27d80c56f6b69973e2a2986ef104a4488b99b6cdf02327fe5e7a616bf47b3d180a7114da83533307230d25953191851fb543330d6141634ac15eea5c299bcdbfd4a7131344eb621d8553be25278dd680a1873c04099cedb398d6c7363fcd2432af99c1c39d88368e92df21ba4715f2de587ff81b165f475a49e9720724ea4acaabc70c23ebe5b87a2e28ff674580299c7b32b9b0f5be9fa1d7a75f4c68139b0ae51adf94c6754c67e4b040d97d8a0c5017a9b788fc293f1293031918189919974ae5eac101ca23efadca6921b7d2799143f272232acf374bb11e6084480d849a76531628652d760190e62cffee6e8954b137078cbce5abe27a519d6b3cfe36c86e1ec8b6680f37e08df58fe3277d550f3d9de0534eb7f1af2a7355ce0814bff1faad0ca9bd5f467886390bf6c11c237e9234af51adacad084d0e8282366b74a3fa70dbe97b151bc3a8a75d3d4a82bef90695c1abd084ab37971facb994022e183d994fa3d206ee566e66d83779af479d15b66abc1ceb71a4acea9c7cf737978350142222c7951ecc5f5191b4d1334edb684fbf367edb96b8df7ca34d3194e1124b2de4dc3193813999d23531d9a2c64cc0304cbed1eba00e2ff5b8c9376ebaaa45afb737b120a6383476f35ce037570deb88bb81ea5a1e0e3ec6ccf2cb24f0c125c54c2ce3a76acd6fb0e851191158b1dcf3f714f48f0ef1fa11bd74dcf2adc71a9c7fef0ae859193008f85ad30ba9495182465b265abe8e84e3f6c6db31d1c48f55c25a544d89d3d0ec78cae1b884caff7a24c49a5e72c9824af84fc8077fe2ce0e83c80eac16b8f778a3687c3e911962ae9add4c44177531f074bd261f3a95748a97d9a0fe38c1cd1b52b75a58d49e8cf2abc16dade5e27e7928fb565dc38c11d39172ec1d97c4c73deb9836b7b6489adfc1df1cfdd18739d5a8815cf2c1eea1973fe6ed0c393d2484c57b054ad8c6d45b766abd147834bb1d3c74e4d40657b0d60ffcc2105f2ac7fbb1f4a70c6e2dd6538c72df084db11b4e199f23128c93ddda4bcd58a3dd5bea457d48dd71c31e703f7242c44c771af95a6106295ea287c6c963512d8b9978991dd3b2614daf3be3bb4c723351caf08abcfafae4260e41858f92b94b9b65f74ca7f5bc18abcd6d2e986f2595c4920185cd918b475e1b49a021e536caab27f2449467b7cf1278048959cb0bba80d763a04eb28df841729b3bd29e10d992408f4ab1cab5732ae7387fd30e4e3ff80d06794fe478159577670ec6cc7d56286845a032bfa128bed79869e5b4b00590c6abf2f1c08a12257d094f240defd3d80561c459d788febcf0d022ea497b077b712d1855ef7e87b7c4f57d4c638dcace0b82db74760ae9099bc27fd706f8d7b3dd2bf0da5c142345df4541a8a99f5c4f13eab56c8a55cc22ac5511aeafde17442ab621d6b00a2c84499cb3f88b69aca4928b9bba9a09cea01f4901bc574103e513e81fc6672f98808b58c15ca0b71c52e993ec5ef643ef307fe43c5925251d666b269ccc5bc0ad4a28c8859b05c832ef23cebf9c62046067aa1fd89b1c2a9ca65188bc278c39b2fe8283df45d38b5ea6e43844bbe77f6f13cb128887cab25d4f210c6d2733dcdc19afe46f1cf23a921f936273ccbb14ff883d659daa3325e95f371538094c00db66554d5409c95910c809258ad452d7e38dfa8d89926e792dbb8ee88c3d4727f6e2385aab8c51fcbc8fda90912b5ec43509ac072b0d4dd6975ead05fbfdde8574de4fde5b089c75fa718d33eb002a0e234df22bfbcaa3868358df31abdf7b1cb112f573fc08f1e9dcbc061bf46e76bb3c548265d91a03be6259e4e3b005a10c4f9f5f1643437a2fae344ef247c1ae901faec64401c5ef925945e2e8578f93d12d6d521dff1389a33d681cfe97677e254aaf13007009cb472efb134a2de94a6b7026d374f2a639599b8fad9a1b4b4e6da19cbc1d6932da9a0621b4f8fa9eb5fa1f3b77dbc237492ab9fa8020cd43830a35c1406f7e6552b02c96e88186243c0b83f8ec2676a862c56197eba4f2199bf8477004a712a70597bb3182deb16e3632e0cd9ccc71bfb3327132a88b9fb4abfd5e8850c29f5693e22674e53b39b67edea3a140559c223fd7cebf9358630b05a259e557ae3e52f330283696aea6a151daee1b0073af67662d1ca6f9f8b9afe3caea52040d06f59af1bf83a8dfaf6daf000dd72435a27fae25066864ee5ba1ac4b641a5492d557b8be94f4aac6038d9b2744b1eaae8da9117a84c353366ab17b0e5d602d043ea231b3ac4951614fc6dc3e0072f613b7308554f854e1aa5948207a61d59dda685b6721773221bbca7ac8ade2446fe16b30cf81945ccf1e9167684ac749a1d7edfd24191244c6271b512e6335ab90d81a910e53335bc22687980a9072c8f1669effe1c70edba27560aa925031d891d622c493c0f2481fd80a8d35e69220cdb629ea5da61ad0f3d1fae4c038166f02f6e02ec35815761416a11ae16dab8064eb8cec05576815a3433b90e4042175132e02ce73365ecffc10818908e2e279422bd5da16a9862a0d1c9403d80c94d88b24e2a3cb42ca540bfb368ca59adbe3e17b7ef86af3e42fa96334c987e8633a0da04986566a0fa02c00a604756d2b9a77a0d8a716830cb1489893fc510210f271ec4730e7e19110ff8e82c61b944dab34a9596b59a3bb294853b318be06a95b4716efd1e739448f88058fd4f4d31644dd3ced223969e6aaa71daf1b37dcae197d0d23a0dc81eafa95196f81bf20e52fa531055e64f3904221e56c0fe4f417b2d97f8e0141cfb011fe560d2d893e10e4b49bbd0ffab16e765b776706c4b685930fc2ee6a884ec959c0037de012b99f6eb3b1cabbd1c9da5f359dbf2b4365bcce45a6c7e0c2409f1e8e456f4e7839bf4c11d5c2221df3e651e91b9cb81a421f31d16081f0b4398f90b40e5a48b501309b890c14a5f70e8fe59a05db3ccc6a0a9b4bce467b9833ebe8c596a7cb0db9937911532192594a2138cadea33920c24d70923f0067681c9b0b749d7aa233b6b01515dff06cfc1c007c415ab4f69a89c579f9c68c4b20d91868580d9fb29954835a617d97010c29069c7273e1e5ffc8b97b548ce04e8a781f712b7d710fdb8695cbc1cf08e61f2a28349e2b63672dc59055633ac2f9c3f3b48eeadc63da4fdb0897ee8ad78d7bb4dc83727c82f52abdfefeba30563d4412de1ed646c9f4179b3937021b9feb1453d56e3747b9750e6325417d203e93b50a199298e252995b03f32b84e2d5829e6a7d8103ba2540429d6f0f7d0c0d22a94983fc612895adbcfc385e6528c206289049fd5c3090fe8a36e412e4919e24c30d81bee549fd5faebc443b96daa8ce7278ba488f2e3d909f78b93e752205d26df2a2353d3710a7bf33a58afcbf171d9406aeacb0610d7a1f0b018811dffd591cc36717de87896ba6d8c5a39a3493cf1ab87eb7cfab4349aba5720ef3f54d83c48f99afbb02a890eb12533f9a432783bf32246b98a62105634286d7eae209498b109471c063dbb1c4aace66c4b98f213f2f57b0099e9ea8a5967de2828e77ee3c7b94a57b3930a020e98dba9c99ce01e1ba503a5d6bdb8d2f58e20c96efca398a8da66c022a324b4fb474fd03904ae5d79e338e9ac00303f4425beff7b604b2a6c85e3b79fcc2920666c16c26f60bcdd79084e11c6e0c20b017fd1b00d44724a60f50aef407539d8eddab0106c5f771775d8ae66b84e5f57becbe6f76cfd08a90ad76d81419540c000cfde8a3384018592d6788f5560f63c46fb755cd5dcf761f2f30094a4b0352cef61f3e69da655f13cffd1fa7c5d77b698e15bfe72ec9e67d6f3297e3e18b366c1539b170563890c4629821d748ed9a55effade390ae0610892d89f95c83d724218f4583c4beee662a942b48f020370681b3222b11a5f73fc42ff1c336705832589aa4c884c7de363caf3b66d36ae3c4c58614c2288ea8e4e1081e2b7a8e3b675eab0099e0bf7adc8d5a2064ab1dc2727191b25f820b6cec8822d46f9245aca2e0d13578142e5b1b9cc44f7c13916b0e803b297336e73dc93a08a44bb9ba8c71640f1f832acc062ec61d0ee9b20585f7b868c3c08130e9562845994dc14183d5e44e3749de1630a2d5db90b7e2eb4085d4a9cb8807d4dd219caa5dac5afd6a396ab0bf025e1357646f4d26accba2ac139ec8864e02ed3b9d7765512b8a37cd2559ff8b12097ff1a54c4c52344c862687b158259c1f73c1a69ab6914b81d59a1ea40676e00a5216720cb0024db79350cdec58f7010db74dcdda4d7a3de38cb961d14141bb0141b9dd7d59c40a17b806c2f294b94b51be6e1dab10dfe35a82e22f2338b05fecc4a2c358179e93e2fa03b2a93c49f3375ee02778190cad88d5aea872f2ca8e793d486aca70a4755c221455bf734f92a3e207090b9241a97584d2948d9efea0bd25722145aae783ebc320b800cb5a95afb48563dec6589ccd569cc02ad3ce352bac3ab9e371f644589687c361704f8837f61f883aeeec9c3275267d75db3185fbdd2eff699b407bbc90c77dac7eb3ceabb470b994b57711fb61cc2e164af365733e68d4f61280e9f95166c106cb9e74a57878325306a1cf6a55678dc03681d7e8eba7644702ea3d1cd617680053081d6e6126ea1e05a13f0c6f39962847922acf06607d2b787ea2abb1afa7630558935aebe07f12254cb8a0bb785cc62d4ef82ca8bce06f9bfdac8874c9c414466226e13dad2a7f6f8899ee7739106e54c4648b2c9ffcd73f435da6b45aa27e4e7cd49e43ddca6316891bb8e127415e08dad91e0e25a47182fc9e0b2fc79618d6fe3a606f7cf33f4bc95ebcec99523e550908914ea6f288e827f9583e9813626b0176668b85ce14863050f61c4fc195099bd3f0b911009554b3e604a4b3ad29030b5d4883b721a20ff2fd99a549027f900d3764c716a7cdbb2f0ee582e5b0fef4a62e44168d7e3514f991e68139bc2ebd4a95e6ab197474cfd49e87dca6fe9763d44638ea18b33fb2b9942399d23f52f8826b60297f14fc71a0c513ce751b33aea1653c7d87b6f2d14e91d9c0dcfc6e780a92293e55d1af87fc504073f2e9109eed02f55dc35384ccbeeeadadf522f2f885ebadcce97f3e58b6923e944dc5feb5a338888ca6f7bb03a916a6265c32dc9fc1b465df072b444f5beb73d0a3cf2c5cb5d4a565d72600572ef60e86d0ef1b66cc18105199ca376c8aa4998d26e40246b6acd3bd69bc3d09f6355b1b94db4a79e86a99ef766f55c62965fe3a3efe5d4ab5a1adc3027180bc814e63fa71ebd5240cff4deed343bd23813363401eb70ca77e370ab9f7e9679ecc87c7ecc726ab6257f959cba31b125ff9ba953995fbb7942f4e01a7dbd9498fa138fc1651f4bfb99bacd20acccb645833bdf5c002f35df56ad5981b388d7a46a984d246f9b1d89dddd480a2363b84bd0382d194df068a2c42a84996ee19626bfa55fe213f0f2abd874f13eed183d7b3e8f4ed41f081810feb4ed20d0b445179267be315b1d3a817d664c03504cf5dd8b62e168b1ff43eddab3feacb224eeb18f4f522fdf0379ccae1a63c593d9d6ac57a862ba902838a9c864059424a97d6cb2a33ccb5b0379aefa9dccf2a798a2f9bf34de51adbcb568b4eb607ace6d96b497f0143825e4be9db8514e930f09773999395f53527c17461c8158ea19f6600bb5bb436f5567803f25e3fd4d3bf9ad1ef00ee519000a7bd1f509266b0b62d1f106c92f2b4ee0b86415a53cfaa91192c44b5900776651d5a2aa96388cdc68e078cb3f2076150e746d848ab168c235330e8f5eae6fc685857af8f09af5016f61b924412237df5b0a6e09bda7cc1cb7a075b299696f6724d2757fd67fbef117f8dcf60d7992a566ff7bcd9ec54d645bb779510025a38d93db3b14a10655f6934556198c68e0206566d7412ad20d2cf6da5f807a44ba55f7d4d5dbeae58071745b555317340a578ec19a1c93131d9cb1eeda0b730ee58da0fb827495812f8c2ec052b018ecf4e8720fb0bf6c93af8bd5080729ddc28253589df9d8cc9a2025d188e2a78df16ace34cc3015bc8652b1e2bc37f2e1d82c55b81f0b9e5083c5ff1d9cb8dd30cf56145d629c5562a66a7ed9b6bcc9a2ce8501230ae022616d99ddbe83199b3138a40d450f0e43ea43330e8baa38a90d988c432291bd12ebd41f2964738829dd18d23cb14905f2c563423da70c27754995f222d4e22f2d8703e19051efae881750e2aa4acc950c3709d51f5506b4fb78aff84a2b172f7ced057f3a29033f142988bb42fdfcf7653b620e4dbc373ad9738e5fe7ec54d443f186f37bdc709379ba487902f8452e1fec66d44b653aeed53f6f42e7f700faba74d0eb1de13fb0a3a599b72738d9024267a99246620cd531dbab97517a670750d27f9a0599293d478e55b827d69ce9c4b116700f167bb725826b3886f5a0cd0e5782eb6652a004dc311cac7befbcd77a6d4786eea25e60337d435c153441933b6322030a618779c0bb81bec8b21cc0456e1f47769e03132384d1b6bd2df64ac820264fcc9ef1578592cd23bc94cfe8778f02769d2263a3e8622c308932a0a22f2b73478deb2db5f2a457af898abb852149c7072eeb9178429748ac22b2030807e485a4bca2810f1291e7b39ec6f6d0654d47d13559a534eeeb4af8f49bb89d6a3081677a94745b501dfe5a15de4f95bda796b3001bb65a8e7cf0ff8dd28c3424e3d5bc7d2d6db7522db17aa72f420c089dcb6dc436222dc645bc211dd30040d45c7635f44f2f5c9d00ca88b1aba6828aabfa5d2f87f2ebfb9cba0cb80769889e468fb6b7566c1c8b65d953388ef3adbad8c769f7d8b1eb1a5a084ad1d2d023ea265ca9e1cb9b403a12566b61618b8d69a1ea67b6297bffe83f9758b523331c227d3587f2bf2535bc6f0fd825d195d4ad96fed2b6bff44d786605aadc696373fdb3e08feb4d6e66ce0a75a608ce3851baa649992b8dc2aa86fc3be41784f60e10ff91b842cf50309954438c1807402233ed29e54dfedcea60ddce3a56e6cc81fadea932f1087b56a78478976d0189fcddccb591996a809691616e85f0ebc142938035e892c1ed101c9f1c7aea53582fa76da21454370fbf50c3ff2f5285f5181cca379f6f4f666ad924a2ac66c8e12e8b7b0293d1f82da05a7464292bbbd17cd631dca722dc1e49a4704a542a48df01","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
