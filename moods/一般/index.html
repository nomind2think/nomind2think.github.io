<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bbd04303f1bc51e9fbbca4b5aa84aaf7c6df4eac656d390f1ee4b8b8b3ba6e6ebff869948cc14b1c45d8b3b66800a73f2379ea102b54a53ff411f0aa3e43d21af5a3edd51548346c80e236140e27648f7c9fb682180f51c551b1b0fd6451761f3bb18591f4f240e46ecea51128642b202b6ca2bfbea0dc20a66af6cb2a6cc6222bb362b94a3ebc6add65e0369cffb50894eaa2797498b74973248309cea143fb24f134b1d620eb2cfd010da6aa87df6f7a7a3c4d098ed6259d1d0bff80823532d8b57212ba18c68ce253bd7f13abe6ef519323671e406d63601e4193e34a957dc61140acfe78219f41312704c520068f4115e451ff47c5839c91bd327b9e978958c6106892bc7df2fd5194b61424a253010316d8da7b8ef14baea59132d8251ca155a22e8c915f2366179bef342fc6a378a22fbba7828617e7fa7caa6970ff408d96337cb60b90c84a8d1ce9c1e3ae815087228054ff7d2af7950cdb3086beac3de59c6a8206d64ccaa05321ae0edb860fa17b4d3aa8b6e398ef5a479ad573e1f51ca8eb271bc878a35d5cae7b58dd18551604964b547f3f74d0e124656df4cad00a7390f76a8c5ac0d352d9e0aa59093bb0118da941cbe2c71b8cb3f743bd776ab1133d22b037b1afe35f17a2d5b87a581738bbfb74da6b8c2d912c71f7aed1a189389a6a6792107dff360983d54f60de4b2f4c5d116f828c75444563801cffff88cd8fc1e16887d7f1a4ac851723301dfa8079c259b4dba5a7cc26cf00c4aefa6266adee65a5eef0568fa93065f7650870f4ad7f4740ad9e72d473d191a1f21d4b5b2d6da4671db7759769a5b32054f2cf55491a87396964978d38ff68516bee99123d33eb8f9af2cbeac6f84df2c054078f4e944070ff9442eb6ff5dfede5f21b62745fe5e5efc03d7dbbb436fbcd9cdc14b15c3c11b3654e6d8d16f7c0d0fdc16077de1bcc462d54af96c84f0b5082d7da3057aeaea39b264f09ca63c8ff8aa4df520cc1eee0118b25e90430f2c6638f7371b16bec9b5a362984d6077925727d3cee18dd0477e87ab906d6769c1b010b4dc0b8e3dccb219f2b8a6d09879269b5f15341172662e0dda1ad6cf04ebf53720a47bdb1e01c053f9570408aa3653cd5740f3ad24c344efb65a48f8e69b0eff188bb5edef9b374e7dbeafb5c766a98072619d0d6be03a8d4a16af994df7377dc932cbc65ff3bc93a35f599d31c8545688da652ab2d8bde51b2586134fd7f65d30d30ce35ab35b475a9d84566c3f953cc21803928cce359730608928eee173e56e8c65558405f12694ae9894bedee1f59be9055412112898fd32415f665650791189fecd0a69f2a14b618e71cceec500ef9ea820495292d87aada749a66695ad4ef19d4c1179fdaa5c3edb5ef4b9ff5a0aee5c694d05574501c73053ab0f0cfbb9d9d4b86083daeabdbf1978b06fa22c4bf7bf5482e4e169e41f79eca98f045ff0d430ec5dd852873060c362c6ffae517c28a9342fd3c9129a5aff26bc7798aa57c8cda96ffb99e21eb9c8458bccd5c1035dfac0696c9b91d4e1f80a056f7b291b9c90852d4a8d7f9569abab571d4cee3d0e244770f9c0a9010e0ba5ee09d76a9f37d031f355a265c94db7eb3f1834a7088d42bd82fdf41bc46b6a0aa049922e57268149722bd78cb735d31f7346253aab37b8cca40284b12c136e48bef8ec96b587eb65e4d0b57ea51703ccc3def34459d4053dc1d1be64921e0fb855a81cf8b111aa468401d7670bdbe6c5272b09fe1feea92869191a5781319eb3f672b168cec8476361dc1078e2f27a2727605d8e6a67a6fb99b61f5e2380a6a97148166a4ea6fee1cb45d889dd7fe4d682b1688ec26848ae9bec20150f58e8bb87001007f33933203d2ae1f8e5c00b24d2c0aa141c4403fdd738c86f96f1f5310272330085e08f84b06d3fe064618f6a694f82d7a80351a742b7d969a9d1be3b556508b425e312d7dfd1375085aceb6ea971a96c1a081bdb0807baa78e7f9bce2c1a3d201416d343a445f92985b2993c0bb86d8b0bd5d6a9ecab45904fdca2d9651f18c6b82bcf36f9dea5cc177e39637d9a73d41b3d5dba1f3132238156adaeb16a76bcd4cf1fe268cbb20a5e33a9d7d398c4ac53a10cda31367d76c4817a00e23884780b7851fd9e489e851749ea7e7db70e4d5dc65c3c06111180b4fc23f27ec2f8568b38d5c349d9640284ba5adacf610d39d773aa14c746dd5cf727646ef9f998fba430431dac080638261daac7ff7ee1a474e22daf4854212299b2321a50555b13683543e1b6bee09829f925896fdbb0bf14d64a7d0ba39132f9f8497ebd6e304e81d5d9f1abf886f97bc662a17609c802c44955a4831f98524764997be52590047d7feb01aabdea547a144489fea58b81f6400ee179fd29a6eb09bbec931f27db022b67e33e3a97a9bbbebbacadbce995b950d85eb7a5b182008ecfcef4ed44bb74b3a31906fc10e4592770244d3c3d4b9cfbe740c16eff62a7b9890447252e160a36feda5a05430d7b2c5f1073d8ed8860af46d05c6c0459f29737c2491e2a4445a6a878218f2dd51c14d3cea74d083e886856c5e2a9a322a6f6c94b0df34f02b0195465e8b95e3379d29fee1622e80b74b743842a5131b6d41402ebfb4739d00d0e0549493161b954ec9244a614019ebf99f54481484f586197abba2ae9a0d84854250867e973e55dedd22bd18d443e24ededa408989743415f48be9704f459a1bceb83c07bc046dd11f307eca0ab6424a995b338f51b17b2fe15b31c44804f0816ed75fcd648a24c156cc58bc378ecca8ef11a557456ea5d0e720c11384da7c4040f50330abf0c79712220f245c028f93691ce46e9bf5a9d197805a0091ecb069eade9c9230589c4471c6cc77cb88cb5f889276a9614a02b4956cf1d45852c57caa7850fdb285b9d010e4cf38b376042bee0c8a5566ec325d29acdb222a485fe720ec2d6915cbf324994179ec2f7fdb6b2ccef87fb6d25712ec36646a82f0174da8276076309fab7245035072b77dd5cb27ce1f9beeb2f5643ef09a149e788d9a277c2e4420f6e2ef6308315992c18fdb53d976f85cb632a17382b142d1bc867ad84096184e95f39ab4640b32c2f6d116c781116cbdd086ccfd472ee65f3563071f8576a8eaae7e79134c64aafb9cd53b531319429cb5a69d62ac96a0c46320b8b3aadc0b8b5914dfd37b4f3565a8150818f5071aa54ad61e6bdcec2f960c91726a75764c66b7066eae7369753e869f87482cfa754ec09b68226d6ada98ea8fe0292063fa5552ea197ec389db6f529d70257e6ecf6a599a9408fdeda434929326ff0114fe1d0480d137c876e3ed71dadd2720a191c40672160d75444b0d200042bc99b3aab1f3ec5617609c8029ceec758759c5676bac338a0b96511fc02ff5196e10ebe5bbc0dc6fa76cc4f0c84e32739e27af568ba8c17b85e6e9aed88858a909c76b2a316293400a8e69bc29a60b1bea3254ca091d81adc644c9f5365fad2141bebb73fe092a9c94308faf1a878b9a0cb4e0e8305635040071c0daecb3b4487c8b622d50436cb01112e8e700dfc3b5becc804490f24d536e9405749bdaa686fc6c39cafa20dcb6ceffc0eaf5b59a17e5854e2733d09c1e15381cd7cee894bf469a68aee703d7103f0608c9bea588bfde04c116e874d148e2c9599c65f0b7801c7a52c3f3e88660e134c66f212435f26e975b40a101255e1ac98f69350a679db24a23b085e7891d74be535fc6f8ddf40ec9c01df06e4a37686c1ca63ce3e5420ad22b3c50166931961423084c4b6364415391b2425a720a2842b56ac4d92df6825a875a0f218f81f703fff46f864a3e7a37d1879a8e9ccd8b11919c85c24bb93664d22ac4dda61d87148ac1c33d3d4c704a54ca3a614604a00871150bcbb6a15f20b1257438b92c86848825544844352d54cfe743244927fdad8391140ed6db5c50f08b21ae38f5f69059e7b64eca4f346a5100b49a03e6e934e3c8241a8fd06e9eb7cb996186b47bc944c60a47aac61a62d8d1d82f116ec1b696d77f1dd0e3d00c30d10ce837945087bbf13987561922b3da3a1446f18d64fc53d2382a11e7d6fef2524760e8d0eec44fea5d7cfd60bb31855bc0d84ce27705c6f2d673e3c158fb273229edd3bfbb6ec616eded802de11698f4291cce4b27764651eb988d31999e8316da7e57203b4b69a5fc1037a544a9f63a00a44fbc4b1e477e11473ec5ceb7f2245b890ac222922c0dba1a51549a47a27b440b25d64993f3f9d70963a80d08d90da3ad34679463aa1efe49ae0cbfe806cc9e4d8b496fdcd3efa5c817de523625209c5f91db670da65b51ec5161a8e09464147d3a33a94bf5a00f84fc4d91fea883caee7c3c030d5b0e89be86a04944bcd70a94e86e8e58a141deb43f580db337888eb3cb4708380e53bce5369b2ccf0b0b8dc3595d5db201b968190da6541d4c59208174a9a1cacdf284253289d393e3c31b3849de38517b4edeb0fc1fce8c70428d529c456650b796ca897aaa93b09e509d0ec64d1eb74432dfcf8a9f8ebc462d82541a91fc52dfcdbd37b11436055fcf75d7c0f94a76a5afc6b5bc62918978175371637393ac09af8f4706714680644b7255a2f1982833b55c0d28dad416a88e64117df474d75b266972186c363ee04724ec5bb49efcaf40a3fa5e4cf58c2c7763857f2c5fdac15ee5ad95b885ade9afc814e631c32b149c301574d7d73971018be7fdf835a974f4946613352de23670bf98bfcec215d188f1ec6ab9f7f7863b991bf65d89bfde9b8645715c01e0b38b19c5ed946479457cf24160292cab6f7125cb39a3e5c0b23342cf6bf12b409bad17f08692794c0e085f79f787f1d1f34485a96f18f525533c90a73078200eed1b1f5f960d2a8772f106c2c1ef22c3fc9e99836f3b0ca8e4120c6fa34bbce562a8506df356a96b77b0e3d951c9138e67ffbc3020ae8b01f4d928a5ab1cbaa751607f60ea2ab2925499423b412aef9ae13151b6c992ccb8be725776b2466bc3d0a8e03939ab409cb6f34b069b5c15d7d26f7d3d32e1d3e0c4b6aeb9856a8fa9e3a53c120949a35767fd1eaf4a0bca3e588abadbce45d7e9e17b374c47f10afa6a97131ea1e96c9e681b4ebb1a07bd35c459fef41a5facd38dd1528e3ca61427e3fc48fae758010ddf227bf9f1e93bc330ac22fcd23921016fe51e347c942ca17c827b58aa8deceb8e55014ad0cb27502a2424db53648efa1933f821644b9c7a988eed33dab0b33e89a9c7051130d5f27829bd557655bdca63a459d47c9eb4b5f73def06643fc46e1f682925b0d8532a6e850c6e17615eb87cb3ae68ba9d50aed3d09c195dba1feb665887043069e9453ef1d60b816f751351fb1bedcfdda7d739343788dd8813b98184634878a68db3aded4a45c46d004a0f9ef2d3235ecc372764d5f1ffb89efce867e5e218638a1ea81f9f1e4ddb827cd8429da3c77696a37ac21859b38e335b633778b4752f204f0cd688ac4c68ab0886bade676d7701461c6c006363f407f37fda68f1c6aaecd437f56e2bbde8ea194e545c387d9705ab9497311c9ace8a5015060b9e00cf3020f6448442f4b739199703e10b6af078cddcc030e063d352afadd2f796061d97c70cb1cc9d24a68961c9b297d0cd9123b0dfa889bc656b7c3d53332a1c65153316c5c499b795e64fa607e4098dcdb76645f9ed3c964e2533cf6579e15b03086548f246f0c54d8ee718542c200633587a58b66ad18cead273fc04e7fdce82d9926e720a719e99397ac491204ec1e5e98d1e99fbb85d0dfe1da6b4886137ec85b824f7c890e078d9f438736d153a3e1ee8c5f6d131a40111666b586d2471c7605315b1ac46fb623de6ab3c39bdb70ef99e66a4194453f0d66df74d41e69913fe085067eeb0413657de5e86f65a27051a9633ee6f7c9e32c8f758e6c6565f9380c39cd5ce6e135bafedf8d2cddf4a8a0f4cf6b8ee174dc174a58655292dc88df23300de1e0d2e38c7b91a1bbe23f1b71fa6faaf6c3224bc0ac66583020832f4f706f8de650bd8eb9fa89f2730a595364e98a38866928146018e36186637a9f7bfbf99d122edcf6d8fc85e18661b93a4c86d0ccf03a3eb5de3321a1589d2c0d84d8360d054f3a24a319e315b33296b2e242e2aa7f01db8e5d059d9c519fafc53c748b8c7b2985e1d69f4f03016bce399bb2577452e56452d5a405943716b5471a18149f9b79c1875cd2eae47a7262e18dc5d6f39539213abf2fa174301f47a4b3302d0bc97a85b250f95cf58c72f68bd32b07d7d059890cc83cbf2ee0d410b8d16796664f84df1ed07a92c21dd0301c7e367c6c6a3b4da8ff305fd993983ebd7e9bfe7f37907d95bf59fc537930482042e1f4f4109ed9feb1c89bf57f58b29e32bba10c64bc5314514d4eedf0df71b3fed914fc74afa36b81e1d188a0720fb10cd391e049d48102e4c32575965c5ecb5a71733c7151b75908fe3c62fb9e475fb70f488f3ea14076dd8e128a9698c80dc68df9a63f7210acb5ea6bec1a0341cc140ce91d272ab8a0508c885e5d44e1835271c755c09f5cfaeeb6fdeacf5ba902a349112fb66100a5f9138b0e0962f04f206bd810070f816b342e0a5c990bc4e830a7c15762bc96c8ac0fe0b3d6c8b5abe9cb2be0b3f7312911aa50fa8b37c2b98e092e11a1819af1ae3b040c670a14d4e23f2d5ef7397aa7fb3a1d87bae1bd2bd36116a86d638f899ec6da4153e6fbe8a1ba9525fcbf26ce3845f7d19ae1c09302744be92a86f7c9f586bb632bc613b017ab3014da370a670626e2c9f5e30aaeacbc305e88fe46bf71813160123c6f08f173bc4fa7506db9f0089542f78920cc2709185a6aa9f996d8c8b981b844f63e9779fc814a0b8112c189d9dcc233d2ee8e6779ac73570dae2abbb292f6b2eb69616f34546d7793bad28f5f12ca5151c663f0e99c493e58603f06bbcff673dea6af40463a4c5be1ae9991d108d13bfffcb6cac2ab1934ca0124b3cec77707765a6c99da3b7938ab394b964c94bcca5000deca0ff3aae03976f107811c02a885c504bacf521e0b04a06cc85e0ac126da5310c6c819fa2a53bd94901aec184d25dafeb136e803a12e446ce590b792ecf586ae8fed95ceb37b3f77256e9e695e96f44cfe9619f0e1dc77fa12615d2aa019339671e58f29c355c146c514f8c1de4556f201ef0d2f309cb4a861b48c782274d778bd65f41b9b72cf9ab01e71aaedb3ccc8b7c20870e6061a828bc8ae4260251fbf020f8b609a1b60c5b4276dc23df9e7ccfd7e7acd9cae8a9a8ea271a6e538791c415e5cfad517876c6ec8d005ced5cd44a06d615573ec6a78f64cb7903abe380408033bd25d59c3d805073fd4266ad71008f6c58d9b0248d480a91983b2fbfe00ece5ae29d2fd5e887b0d868ee0ceaec41e7514401c74bfbff9dc8863852eb276765685805f6e0a0d282c8e6e38f1b048cfae369be4a93fd4f584a857828c572aeee6270beca87dc94c046ed93362bda50bad0990f1b70018ffd9adebf4ce467e2282deee31ef23d066920df8e38ceb5d84ad077fe5d984bc75103d1ec27dea88fb3d88b885f843218d2de8314aaf3dd8ca934205f2306bd5760b5f878766e7b1c907dec10621f68d3be6bbb0d0f8bd494431d77044fef996e46157b8121a4246822a4bf01668349c1ae6be34f305099503d0683ff9d92060565b2600401dbc773a91ed6500044ba02728b16637bb75cb6f6081c6595bf1954a13e601746f7bab34547357bcf781007fd929aab04f5f26a56eddccbc064bae79b9a4cbaa2a87f79e040a20b8a114b8beeecc9f981481b51a2366d8d773810461f7ce546d8404d4f6275eed8c98de50f67412cc9cd0ded7491d221bfda9c0eed0d97fc825ddc01b684126ccf5b5ce8a19fa234a6dd3fee49b398abde526e4cf78e75135e736c88d28b6a006d538755074989f81d97e3b0ebd8450c946b62d043d4c61d32fe8257465076e36566a7eeb30a9958d4ae228bd053b80ac3c5481bd693b16c39d1413f2212245bb9c1be889370a4756b732f8cff2b056e74d6fe287002a5bbeab21bc62bb038a536fe1d88ed65bdfb153fb4a385b76068cbf9ca5993c0a4c8d51258c0e6cc4c2c323f2594be4d59de08623dd5794bb33c0c9b0c1f2598ac469cbe876c65228f26031a7086c79937db617b1ce82812a966cf601fb74c3bfa0389f251ed5fbb00637dbb2c112dba3e1a1c1acbf4562bfeeaf8dfa4d72b1c4b8dd65eb879fe4732e99fb1b1eda247fac91cde4cf2bed56c5a340da431c3ed43b077140a5d4ad813dbfdb2b13adcff84ab5d80b3b5dc535d107ac76bd3a6be78fcdf9cf075f1de142c345bab53af2eef692ec1a102ebad1c4549c7029e7a8c56f853551284b11adaa7290a840918c2b0ca926626e34219fbb3587543a4e4b2f515c139592fb8325bb920984873a1483e9a791e14a09982421597eea35427408e126b3a082671d0cb700c17478f94da8d3af9ce47b51ec6c99206e23924e0dfc1f3b4b95d0c02a60f1c902358234ad9e5203cc7641121e1ee755537f4504826709157b79a2ddf19fc2b43555b3e9800552e434b061824a70f64ab53ff5ddc922c889361c2abe029e49bd5f8eb26e538387fc5477e57945bf41c8406fa58f29a9cfb564aefafbb92d84be7edcc92ad160ff769fe4ceff183f3bb489417b8cf9bfc93411b38e8377ae89e81085b4121384c019becabc1b7c95b6efcf267761c43446118da04fb5b79c9bdbedf70c48304686449ec7d0bb905ff218192da5d37fa0f528c6d7696a4640ee09592b7755923cdd2e5d674037ef5a32cb9357612cd5e94222e6baec2269a21458330f7476e43b81bcb79f19665972be03d4bc4584f2206814b26de0570293747e9e3b9ac9130cc7db6abc26c16324a58d9f063f5889f3488ba2a99868eecf2b946e8c8d5ee8939a8b7045ed8ae8ee4e3986ec39aa8b96d812979a1f33fbf6a1fa9ab787878f260ed67087b7bf1189aaabfc69fe916757e6a017e396f0e414774750c04bfd596d29fb3cefb6100f3dae501f7858e3c3381dffb7282565e741a0c4d9bee367e4271f8632124549755bac25062dd9ddd2307821e8dfc16c73e78da2feefc5568a4dbbadbac6f9a5f1c76452c49cfd1555a5c504ccaa788a4ee9764fef1397e3f4b40444eb9cbab14400152130c22211ef45d383eadea3a37e113685b7c765e3c424805812ec0fb28bd19cf806e4d3b84ee3fa8dd3b029d0c2064372cb134be0e3ef8b554c0da1665074f401c5b27c5ff456738a59f0ab8ac3819d479ed8e495c1c44360fac96892dfe6fc65b35cf84618d7f108213eb534b24ccc8cf0093e5bacbdca5a420c6a7fff9b11f3a790e09bc240bd291e65d56c21442d2111f1920db576bc7adf2cec836b66cf059c46263d7d95321ba70861fe37cbde14df8101509e6f644a00520c8f89bf3f82e2e45c452984f4a6c6d9fa5c816c9155a78ebb67859dd85faf6454e23066df473fd610ea96b2c30b04f8061527af0eaf1e7d58457a3e8d080d5e3054e10ae335307b3b3994b9a3e4ab595f4e78315c12f9e7020e588136cbd17f2a984bc2ed3e1ed2a0138b6f38451af9fc286327e31469335278fe1f4be3843a97ef6259f1782f2bfbf5e3e3de51c824e89ef16b2677375ce55886e79a2637d578e0360aae3cf91b3f05947a10d821b305b8c189ee607b37960521fe903881c8d5ddca3f06332380596e08686f139b532b0801bf0322215d897a5aa635db4aa53edaf519daffcc581bf9ccf597dedef6abd5e4c5705a128bb55462ca4ee97df789de44da9775a4122bd29046c53386057117032168ff5bcaef681dab18f81b6efaf23b9ca6e2e5c51471bc7088d4c6df4b957d808c860ed830f93fba747c6adc4c5880fc9f98cd14a83fc7157f834367d0cb8a61a49a1de224e3c48555da58b9641b923db3676825aca2323cf12a97abe1397500ae8ba41b466880a534df3be3ee3a86e4e2dadea983f25f45ecb0d73af570ce4c0aa4aa6456f69506451e98ccc0e174bc6fb5d3b4d831d1cffd02268f82dc23b4e96fc2790ce21986fc0c469bbf3116658aa11d1b14133eaa7bd6a2d1a7de6e1b1f4cec1f52d6d69750c755ba26f534c9f789b8e087f44900d1431d6fcbb5a6f02457ea8ebd46d012f56d31b2a15c1ec5acce9d6d61bb519ab0ec5e05847dd90b7796d8684f2c16a6b563d510b2b37e0d57adfff79febb32ad8a2bfd3ea857ed145529fe39a2574d4296b84826166240662caae342546e7a90018a862b48aefa7a71017eba168d18575fc89a49d9ef2928185a84b25bea88b6ceba11a5573ee8ef07886e3f11c5d70d4c9de04a181aa155df62fb2e28cb77bc90f24b6458921bd3e5a9e5ec21f074c8c4aa8c2bc11f9bb89f27da8f8d75ab26b973838faca89549364171d8ef1d3050c07204835bf11c327a21094878ca91b652cdd088dff8945bc80da30231c326faef472c82602f16260ad112c164c4cc0d9c724163e44e1420a4eca9f560f4243c52381ee696c251be6521812cbef64cb16edd6a695f4c0df2b79289ed646cedca400f17979c1698cb0d15cea5d41684139baa8cafe01d39e9ab17abf45af47f31dd4fa583ee9b9e9f47a6e816847bfe668f0e0dcc279ee6067742057298f6853c043f83097f655c674d4bb910d13fc8a4755a82813b84a66184b3a5d44389a4631948bd36e648243bf252c167abe17d72a2133f8fcea5a278ff127229c534be090e801aad9b4f72be648884254c183671990bd28b964eebe2f0695abf17b2b7507bf4dc907b468b37393d757b226f524f208097403398f96bd1041dd76c18ffbd74296b4e8acb61f74f30a3c047f59aa1dec81837630c83f3b34869bd6bcd8c8f26dd9a841e54047eae87a9830d18a6d918c18c6ce4614556d76bb5989f53a07c91dd48aff5cf73a4e0648ff4817ee460798d63e886168db19851ecf8e113577bd76fde0aa9fbc7d626b689eaba273562eee7258ccbe782e2fcfcb068b25508408da6969384ff2e9d1e1a2545a043d2425a7d5d1d3d2736daf031cf1dc904a078f1af136ac58c817f43811bd94ef4a736deb0bd7366a5179e5f2c20c7d449508e5dfc8cb32eea75089df45bb637afd738480bad61ef0264faa7186867d74c2dd32bfd3cb8eb4faefbd49e6126451ec3530f4e711ca467c0150796ce50c244364909ea1a1697d2e3278b62de81258a17a7051dcab7e3bb8b39aa54a35dd7a98ee40464d49441ca5532303192d448579e7f12324b7ee8afa93eab47216407951f0c40bb1fbca2c55f5bb0679eaa8dae608f1727518895304bda95fb170563a06ea1b5b56f550fc063f32fb991a40619b95b57d1ba855670aeda328091a190d5a1057b31f6cf474a697c3c7b828ea4610d843076925505c8f7cf6634bf3639b68e11b57f77c7a25e0a6d3624bb1624cc384c25934c85ad91f4c3bd91bc902cd6e536526b8d57d68244bf934b68fe092145468129a09ebe1439d3148cba5d75d695f1faf2baf5e9e87a4cbfd94563a9433a6f210ee51ed196342cdda30d3d6a844e7408274240a1e427535fe1d65a4fd0ec622c13c6d82711ce722c3dadf5bf4580396db3ad1d9987f6ab5b0df5f6fe33888c03d55b4df75ee0e3f77320c7f53b8820af76a0e4b9257bbe497b5b043cffb6aa7e365e1b454e878eac980d879455aa4147058b97263e33be6f4f7c63285936aff5d574fe20e02b61e2674eda13d1b81a654e099d8450ff1d7bec0bf69bc06d4aee2f15fd2e9b04cb19c544324ba52503d1f89d8a3e291cc4d5bbbf09e729093ee69429aad5e5efb8659010f0c888010daacaeda564e5dda90a872b8578d16bd6be040d1510219836c4dcac67fb0558a1ac5fc5bb2fd15939d88fb18476dd090c02123da192c591187523c7a1b475d4fa6a52b2147124156d45d51e3ed7e47d1728bdc9d18132af9bb4de2608501f68334184a56351c458786570cb21422afdcc07574d420ad8bdcf7f7b6b2c16f5d60f92bee400ac0a00a684d2988fa40aabfb0aac6e80c332dcf057ae928e64469f9900c5b43ef64d3ce658cd049102298f42bfb076af9efb2c575e9368b60bf5f55aac1d6968b42aba4349bbddf62ef98bca95767c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
