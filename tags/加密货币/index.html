<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41d459e2e3c8b0b5ae3c5cdd7b0ee4b2c72e138cf6a41e9e033a4149dfd0f56f157558acbf5776ceb89c21406fef9da4bfac9e5f8f33e219a4a386fb28ec037a1bf5c9ce3da37e285eb5af48eb9a06b4be5fdde79be42a608fc1418ae2d23a51e865dcc6d5fe5e85e995ceb4549698660780a423a2a129b19bd1db7886d24624b44f932744fe7bcf3a230a51dae32aa9e0beabf126652452accef802999de28b199bb37def5889c83b9b484574cd4c2b83b84ac440a9565ab06c1acdfe461a50e65f9d783c94e6d852c481cca90a8bab5a7f48591b551616a08158b1329ea3182129a64f3080d00b1e64c45ee5b7b7d4d13df5565eeaeef813df9aa0b9fc90f818d19c32b37ab4643ed2d3011b77617ca868d65dea0cbedb7e0ba8c9ef93e71bfbef6ea2d839b2230b2e4b17044259493183aab0af8e316d1be889f6a371ebbd05b115563711014b0a02a98c60a8e4c172b7be60bcf8158ef87470d13b777bee160f6189f2c17682efef3ba925fa971a50ff4d35a82c486f95fe781771794ba5b738c3287c527a8f99fd4c84dbd9899f845dce2e2d55f15264e88f4b502e749804c6ddc75395e1a6b476d8402d91afb51ad48250137ceee0ba75c9ea4043522165e785ec34de9c0bfde34e1a65d924383d66b8c0e219f607274abda3cdbba8de0f0c9d4207235cb9f490152f301d4dc0f4adc701278b827c498052df33dd283f5fd0b2b66a61dce5b70fcfe4d1d4004f44c603e54a3bc4ef0da7e7360723b38ae09775de528023913f231fe937f2e0c6ff5fcaeeb722754e5d565c979d5d63e8d1e23844168dabaff7fa2c298c23f7d243291f65964f4f9e0f16b44943ed61233143b0bb19d45af60f0e67caf61d3209b415a0f36a49326ceee9ed8332b2849c0c9e71c044235db8b07153382f2578b5517ef658f9b3ccb3c946931d7394076e674b7f3b6cfba47fd31c7a6b9ddbeb756c474b02c1f8bfaaced4765241994354fff9216dc0c63ce8062d011252bc008ebba3cb66e0a91d9bce496d4434235fb36bd059198d3c9938fd0a0697a693ce989114d395c768711024841aa5e0e4c1ef49f62d645c42dabf26d18deea811ec2ad0990a458b951fba013d6a74be57d8ed40fcd1f2d75144094304846ac90d55384ed7afa1b36bcec1c84d8cac1b1ad5054266e8446a3f6d6dad8adf17363bf8ee4abebaed2977d87137730a4d2da43967206c642779ace57897fb24e63f039478dac4e11e5cf5d240115115650496e98a56af11e508f5b80d61425acd21f545afd0e0e2fcce307c5ac3f316ed169109ffbdead35fccc17fa557ad892bd5f7ef8d3e60ec84e3d4509e1f54f9c17c0adf2cd93e3b0109da7c9ea9c4f502acb3a6c0f420d51f3773ed77657f341da8122736afa185c6387d3009735a6c4d332304e3d5e4222007f8819f617939b9c8d8118b3840e4a05c40ae268fe546dc8313621474b71f28b6f2bab21f349d74eb2309a240f8c968d7d46718242259c6d14b040480fa3c3a6d74e94be345e5f9192db9e54ad95997470e310e476d3f9d7e809c39acca93a8a9f5029912fc667ddf24d66908eac44541e483cf85817f2d2df76c5e49598d36b394e2f3d3d9b9d488f1b9a050f1f0b653a7fb6c1f7f9a4457ad7c17f579d1ca866c72c4b2464c2054cd79fc88b1a670db01f1f48976cc9cd999a5191714856b60beea8d59366bfed29d526fad23c2d4b1d0d5675e44a6c758d56dd08f7bb031c72894ec94f64862a545024ab03496580543d012b7448ca7f621466a258b599d12091d5dacc72c071ad71b6f3e8a9cfbc44cb5295801d3464be6c5dd49d6c87fe78830e76859001058baa315dd43f754513560266ffe015fdac4ceb45a62a40abc405cca2fb68d1d6d920cc9e53cf9fe349f22cd6d6d80e443f4334c5888b14a30c99c55c5b5a0ce58a4a1f1879e4c0e08d51301b837a0026fc4e56b0d15e8df94d46c469a92cd16786607fcb8658c73b656e44f4976a2b9edff702391af15419e6732662fea735283a14942dc2ac073f30e314e38ef8bf8dc163088ededcdc47d880e9af1bac1e213d8192db3a3d65a540e9e50b3b625605c0df71b8663ad48dcc59274dfd5113d95841decbb76b50e45f757a46ef05de879afc96ea4afb2ffae7cddf925fa97f45d67f5e418d2b2385ab98da4cd2300be347aab16a55b0f2fbc71c79570263b54d00f33bce7c43305356d5d42a9191e79de19f88c31f9ce9d5c1044f843cda33e0968096bd8f49aafb2bda2fb983bdd603ec00d1eed00939ac5ea1ffba5b390c91f3ad2ea7bc4b79a4e2fafc883532aaadc94d3d9267ca73d18055abeba92682e3714333ed043cd02e62190e2b7df2b0c02d3218c9bd98de370ca48903edd5c301ba829522d0421db4307eff9e1b65ed524ae626f81f77c2ff835bedcfc6edcfed481b96b3bff9941632ffcf2eaccfa8262414f1b5bf7296dc6110cb6ef2f418320fa70d4c54c46d6936eb26cd6d3ecda6b12e4847371abb4b241e0152eac7efde4623d80b14adf68ff6711a62eab1ca9df2bc6437bb2431f29b92e5d8e07255e411003f9e04c6edf72d506b9b0abaa559986e382417dc129ad60e3ed15b8b4d8312b8491916cc26d2ec9fb1d4fb7258a28476b1618cdf1543f80e8de7f4d3fd60c18bda54f24e04a2ca397ccc59d3ef9309f1ade2b2ff0c9624ee1009488fe16516ff2b1c54f0a5d020f01ec8c52c72c797132b413b139b97efc87b12a0348d1065a4d3343b2c803c2e33532b74393d6e4ae3689176d86aa63a8a2211d7cc13ab5ee70c290bddeb2240f075b595105b9a4f3a216e1738f4176b74a942e55fb3a117d2381d1f87fe0baa8d84218ec1359bafea27360276aecf981b852453e5e374bbd70dbec14ef7c67b4a7f4e1aea0a06cc40d44a2c7cde7d38c5ec6ab95ccda6d0866cdbd64ff7c24c0ea8db3b1c84b96bdc5d99214fac9a75dca289fa9a5ef7a52ec14e1037108a301661081eda0e527805957729f18535e658d93c2308b170d7717c2502b16a1bf604e7f34ad1f98d9fb4ba1f8a2c5c126ff1d863fd28d131f2cf09259e7a1c0501d763e2bb8b325ec429c103d24d5614d04ac48b98409af01686328793741e66e36a596dc482f387da1b86cd4896813429540e538ad78ffddec00a2fb2f50f4b47ce04f2b1e324660c0a8d0addfc28b7424cfd8bf0772368aa7bf136fecee5fa5e8712a1c18fb4611b7d771babc54872796e7dbcdb61bf18b1dd41ead5a21549c5be7ea751c991b07c3c0ce2444d91f5502325aad16cef83e97aa1e910a2d2fb989c2336bdb73a34c7c3fcd848b17a4de9a9a00f5a25e7bf073c2c509b76fc78574b2c684e7ecf31ad86d6052b7708913c6cbdb54d46f6397ba7c64090ae4159b9525cd3a888826e8d0d67a4d9867237ce194cf5ec5afaaa8b5072567674277c8654a16070c715d05e40e0f21ade320604c707a637267341c4a9fe4dadb8d393e9f925c4d47574e6dd8fa0c49834bbfe2d748dabe450755352d43e869b64914885694412793b394343c2ede94afe830a228bce87fbfce3861b6b47ea200888b5ad3cf854a6565911c0e23097e389236f23b54b2ad233e6c9fb6cf3ba3cbe69efda80d9f8584c80e0a50f8b0930a60a1f96d78979f85da8db2f91dcbe4b0218ae048d75c56727fcdedc6fe4ef1538ef33e357d4dc4122a9010d85f3a596b0cef104ac845c1218390207feaa47b85aaec6b92107d137655d30faf48d558c8587b4d6acb124d2197f702f3fb44a0062604d1881174a764911b0f0e8b552d86d3b689efcf063e913ae11ce6892fd8eacbd7d8e6da3d7f3e013af319ca3953895d937e87f060f69bd442373333da251f36603000d321f3c0d0236782c6bf0d9b730f7208d883728974a3cbfdd77c682b3f27ce238eb3b0740cf1fe0c3f5f77ebbb825d7513c5e679a073d0370f138a0d4774dc4ee255778dbe807c6ba978f82d408bcf26cb298db6ba408c33333afc372d32869362b9669161bf72ba35a22f0146df33e02bad5a1c87d49c6fc492fee51aaf02dc4e8e81d10b429869c7da45742adbb24ac19d677240a3b8eedf01190a376b6eb14d35504d579fbe2fcf5e0853a2290b86a440d421ecbed4916b1489e78298742fb0117a595ac7a33a51122240f873aba53fa3511fb57cd4ac35241955b39f0f05f59a0113617bedcb18170153ec9414d61105742a83ea80e223d0fb25328d2690d27d3b899cd947fd2209937f023e714f5c92c9cd616522dd3333c51e64c57688a42d8ecd31f6f46d90d22abce5bc810b510225fa58d99b4b1ca39a8ae032f04331a0744b89f72315eba1a76854851b6d548f64af07a430cfddeeea160b4b9430ebc4289eb5c2b836b3767fbec02b1ea966e3450f1556645d16d80844847d3268f72079d5cc3261e828a02a22541927363099a376600545732369188f34f52906fe9efc4a0dbebb17c50c001b17af06e7fe5bbff5ad64ded355bde0d08cf2e6de845c922e1512263a0f3e83463e428c294c0d3608b5be47815f878cb16a046cc695ba7faca43271e9ab9c0349c2311ac9bd707d1ecc95425704d03f35904c7617e71bc3b32612ed2c2cee004aac6871060a0ce9eb4f647e61840e4384cc2512c227bd9af5d3965aa82fb91543bd78f3bd0e0c0f47d3a3b0f7aa4b2350f40ae7925e2e2b48b1f787dab9ff91ec5e8eef81ab73bcbe3c05d973de5460d34f3f85f85386eb84ba72c0b7bea8af6f054cafc3bc6fc737b820e3e4c29af8e99855a9468570c2dedf4cd948a632be80b4acbd42f5c8789d1083a7a527858740b2a8a696112280e656c3628f6b67fb3fea266b169e65d9a086ddd59d3880b685f0bbda1f15dbf90956b43782393ff526db765d5dec6cfce60bbf9a809377f521dca5715d12ee9bcb1ba13b5e793798589ded84dea8f89a031219bab7378ab2dd32bd576f19db09cbd452e633f251c548f82e9679d3b2c93368c3e9648c04dc735389a93a90c48a8596dda4a026f161a8c7e050cf18ec62190c86081340b7f770dff5403000e06b1f7bc876b9479a4020e7c644c31d6ecdfd6c95394d3f6eda8850f7b04da82e41a1b87793d981a87e4b88142e97ef44ed6e3de23a438838799a113f772ff9388733df1db1139ab46b63f1efeb8bd31d640d2bfda2dd33c8f6ddf2bf03d53fda9014440306af9e2ad3e313da5a90f661685cb123056ce291809454e936ba14ceff060e7f3978bcabf466e3f258e0232bcddfc30bee7c87ec71628551296c7f4524e4f604e44c6902d48e92c4eab2a79e4b3a1080fb317c8a4ff11f937fc94ce8235f69cb482b09253e7d0eadb1933da5647c438a25e4feace6d4bbf23bb80347118123ba5c301b57fe1c9c745b09e21ad04dbbd8f7a1b2f2466c61ae547071d301924a257dad2813d3f31a4f3ecebc510c24ce81bbfd0b457488e8c7dcebac01a43b4412be8957bec671330b62881090f453abce955871c297e37238d7b53f979f7ef1fccf3fcd3ffba0efa742feb4644eec4719e5997a63c40f7da63849c56e0b6acdf8b632c571fed49eb97a386ad1975312696bc3215f1c4daa5bcb002625a1115c18ee0887ce4160324ea0282a213646031b73a2ae91af4a52d46e1d4d3efa832d1365b98218825d3a6a61da3446b2a6656dbc3342c7680090e8fcb476dfa2d2ee99e878a4ba2bc0860ab160064c018f0926ba766d4d593836ad9226b2d9bda4e58ad3e9372c5b0493bca4f35a73238f559b302e6a78336c6739df7c2a2cca39bb1e6067607e9d39bf19e7360db737e0bb0c48a8c8262751c559dd12257414904a0331d9a874c89dbda4ea95298a5475381a07bbf6842b0e4087792db12a63b58bc9d1b60306dae0f3389c66c7c39c8721aeee04dac62a229ed05afa7581bfc9bb5fe4af0b273567270e532251b303a6952e6e4036b2685e5ac704680b8552b1376de6ef3a1dd48cebb12ad912183c8d522737f5f38908edc31e0b0bf8de5a96f5d6d8d597d798fae3d326eb56017c2affcab716f6bc2599f06ee35afc19b446bf38d972e774f0cda53b2c19d57a24402dabf9c14c825ee69f21747a301af366717cbd6ff20e9775e680f7cced759dac6ea9a3b112faed13a95bf85f11c03304dd8d562776f380fc0368a98543d55b0832dda7908a01f97c0c82f6c644ad13ce9ed1fe5a2887ed206e65921707d0b03fa8e1b618e8590153c8f723a6f414b9c398ac1bab7890159c95db02c51652751b46b341ebc7b14eae3d9cd8e07eb92ebc5638cccb680bf5c9132aaf3fdfa68e1d9769a0585dd94fb1f005fe8e5b892ba27e900bf3033e92ae7ae8a28154e038960f0938fae03262e96e0c4fb69d4f1b6544da336c961dd2b38bddb5fef8f31eb462a608da1d5b3231f3257c4bb87e4ff13293ee32cf4bd7bf7ca90f834513d32108b969764466c68057e23e6295f96fca3d865700fac08e2bd58101ee3fb926883ee47b55ee1c23aef6b188bb969123f0658887e9a8691555c4b25b0dfae5d1c722fe3bdf97106466ea054e29129af6e03cfb457f870e47c86757f3a43fdac42b8c84d68527e59439f95d1dfad298c74db244479a5810e51897562484b2770c4957fd4e065e642d9de6deffb4d2192b050b8ab1ef48ad94b47496871d8f02e5122e0659eb1d5947711072b15089862d3c1ee28cd910eefdc5291f000e608693fa376e47789efaccf7b19511977185d083ee97782b720ed3e1d961397ffb92c61ece5ae71ce1f5fff80247f4630424764cf23551a4773608fcf6e7c650e8df502cd4e17c796be84d78238c321989d22a57d35c9aff277d3bd8ae833a6483b1af84ace9ea715bf4d6a63700020fd663d5f90e8ed6f00e78de205136a4a6ceb9f74917fb1d5ff7d5635b269035a5d761e6290fd85cdb801829778cbdf930345565107a38655fcbdc4dc3715ef486678b380cff22121ac1359cf5b34db689796915a1d83969d593ea4563c611cf2b646b142fdb85e4a1d0844ebf9cd45ce49118d4382a4d3d57bd4121a1fa2e56def78dc29ae4bd6927f712b7eec22833016df4574daa1279d3a0535d273d97e9572718e01d39d370d5373433cb865733483783bfc1ad47384102e0e9eb01f5135eea5e017f0a8cabf784ca79e9ec2df95964a4c13d00a0a215ee808e2ba11c6d8533b0e0cbc4252f55a096532440efab8726c2b3384897a29de969d8483030eee926e58b75895dff03e249f49887f07ada2ff037731413cfc34550349b0cef53268aaa205f35ce61ccec32f6d6ab9331089c6870f530a98053a2aa9b357e27e85cbd8df139728fe448e13c58fe840e1bc5c0d72f4824c0ac3d369324a09c4b88e1898583a933781026f092ecd4c80035d0f114c606516a837a399ff21475aee43a38a81b262dc95b258a4e9cb2cab5913c9eba4e1adc39549d368178f35d92ae0f77f38d1b92a23efe4847071bedfdf3e6ff09b291e570f4b6f89ec3e80d5258b15c7baf62b59fcc51904081a982250c75ab8e5654345dabe28e0d4ee9937dd081a7f1151ed82dfbd1e055364daf9971d502aaa601ec24b921928ee22cbfea48327f8a64da8c35e0d079a2929f5305f044b99c798ad2e5546ccd3b96a379b89ba9a4f5f0b627e3bab2df5ca716cd3e0044ca61fd56dcd498b2fc91b229bcfef9143af7b6cc670889b967c35138d3b00d650c4efa716588d3aee71f7d9c8c32cfb5cfd09c9797fa64c14df9ab023b13e9ee1912f664f34623463d9934cf4509865ef4a9c4d8ad4a26cfeb531710c66dbdb122b5b25c8bd22a10040b10195167560f3d824d8c5ed126fa7e4c98579757c2d89410f21d3f163fa3e5431e2a1f66d1d2e4d6cae312577d66ce453d814b6f3b84734b683e73883cb5693f9b87635c596e49d3deafdef585a582d6980c28b59bbe77fa8a8ee41e88d44336e2b02e4d413fed2158b906b85dbc75283292106a1f87f326de827b83addeb6784154eca40e000e6dec4abc6683d5e34d8c0b9d903c9f2cc25c28a52652924db7eb8b36cfb3c5408082d243a3ad9f2ab6502984cfe55a3ddc884daec6451cbaff1bedddd5b4957309f52caa3f4964c2a308109a916816dcac521b9baa65e6efaed7d204c2bc06f7a1b019435087796ebd96d5b5218c267f8c97040bd8987b17a565c399a6fb252869d1a739bdea34d37df6728f4c518bcec9bb23103a77571ec977afc6d974464b5baebec4fa5e7ad4ce744699012da958ddb10e217bdff1aba93ead98be5123abe380aefa953b8d2a59da19b5ac6ba9b6b802308efc1732d6d59dbed625711629843981fd95ddb7bb0cd3d61030166ae1218245cb2d476308195f675c63946b62d5872cfa72aea3ea1ae60c6aca9cf4f39ac7d108b34336096f7d3d33158ca81c65d366e555f155a4629ad28c629dde4f4772e2cccc23826d47349096cea937b428a0eea65b08d9c35ace8d306ad162305ad5f3b0e42c2343e6c62090806c4a822f3b55b7a89bb98b0006f7bebc91ad9113597a1ac294084cbffaaf7fd2884c18dee927a0b5ed3dd12fb45e53c1fc690eded27f18c99519a16f4c6547145db520413b09041d7eb684ad0e61dfe6b4e17d7f991ef9a92e99e50cc6cbdc0c78cbcd3bcf8b473166d61744218972e3018d4d88600f173ac6808b42f0472f78d22fa56b16372ea0326c2b0e88925f658f0b9af768598982fead5c5670348fc66cd19408dc5c641dcf460b585ed90247f2e82de770aa75885b003d38e73edfd7cbab49f48056d29b2c3dc6939854323287f3042ecae5d8c1825149f1d20c770f5f601075525d285fef4977e168617f812e029e78156c22d3850535a41062c0a43a82848e9dfd9e47463f3c0a53999275813e7a8e8554824bde08b864736ac60d144b077a7a7d1b5502872d33aa5e01302f4415c7cf657560ce9da3e8147aed1ad7b9ac4573e7141d771009fc622c3e3207ad2fb2d6bcae0e8dea42a5d9a6e921af65e96eeadaf44b6cd89d531162f94772b4e9da9c4ef6ee393a77686a65bc2bd804fd985b2f2dff22f3844ef1a15c3fe9db829c479f5d2f7ffe949eba87f06f20f6d6963ec13a14f81054f09aeeeba035559af734c2fd23dae887b817afb65e3bf2ae01c988cf742c8570be95f8020594342108f8f6deaf12a5f7c44d233ac3b2cf7fa5d3cd6ec4872f98ddb001cee5cc95b4d55c42cd7db110d7381c151e7b488689b633d97e7501cc901638fabbb521fbcd5f5402ae7f0b6698235f78e72155e3a25f975b6829005947952fa438f51dc5c34fcc4cf00ee6ff641e14b17fd25c2755c67257417622cadfe2396594e399e890a5c29489dde777ba306f31d6ae2a6bc407028f445b286d76c5f1e7656f7d0da91d1fa2d3a8249294fd83b4db32ff0d71876b68669376f6ba7dfdd99a5b37e495840b367fbf9994849ed5801e62a4560381900ed4f995474c2a2bfedd153988963bac928ec6a109d3db7dc83e977cbbf3a7c65f77f5a053956f21559cb9ef179de3f45d0697d8cd6f232cf9c18bc4366a5c0b1f26ac5041bc3753c4ca5937452d7f40991a863607822a51dcc0a2031d6c18c13e7aa8798247e96c6bc9c18047e86fe6f0680879b05a9a37387c45e24d8dadcb89434d35d2eaa5f0a4b4aa2c4aa5f009f2143c38291099cdf92da9ae3908ba2ac28d802fb28676284dcbbd2c8b81c618628663383a0745273f022be33448a57531684c121dd65e83ddb0fbb1759ac78bf01d8d25fc91aa03b49f5b009a6777bf260f2581dc8e387f4f8286c42a235275e5ab8e658cfef09f1ebfbdf1fbdbcf0d5b339eeb6b416329c0437b0fb482409fb6afb8b05fe2a2bfdb267f26db2575ddb928ad21bf4fc6dd58183e556ffb28c2a5fcc21926fb9f03bfcf1b0d38dd504b5028a72acd36304cdd958cc10f876bcad5bb847cf052c223752519ade422bb3d825833f97c06b00aeb8f5428835a76ff7d3958a9a00aa33751bec11ff6e0eb9dc98c0e664b217f4090738b35a33e2ab36ac10895a27b8c8d701b3df6ce5d47c3e7fbdfc87e44a9726749fb9149c4203166c62e1498089989f1ceb3118a025c64da8cdce4cb6266c82081db3d03b79e322c007f8abaeae49c6cb3aa7f0d78ad3353243c6efee2ca4cf61e677354288b505cbddfa2c608a45eb39868a9232070463455027f20a0a65d9ef665b949ff136378df1e39594590b1bca0b4965c06fcf483632be26ed2970fe2725d1472b6e7a5c11b403da816bfa210d2ccbca0ad5c8b1f8b7642d8a2b6e64b9d104ba52d0a5e01fe9591395524643c7a8ddb0e5949af3d7ba0260caec20d57f4de98cd8aec31092bdc88cf58bbf261c56675e82590a8abcd3822d02f102001ed44f8180d6ac2bad3b8c6252be4d770ad0ece64e4c9f6066dd7427e4c671f0b28320cfc34609f280ac290b1c743185fa8d2b48ae5b37b522df693db1242e61600faf2d480e84bdbcd9de866ab6cf1028d57a32a963ec6d0db99d0ac8d248b3218551d666a16ae88bd16b1107c9e287ccfa348a87a10ec827859df432b175d8752fdf71f3eed29e88bed27f53e3bde8bfe5a0160bf965ca8961a141434620d8dfdcec1bf65ba888fc653e6ca3968c43cc5889ffb23cbbb4d3eed21f32a273d8681de4db53a0de199f7a33b451e34b6ff2f6187c812fd97dbaf320292b01bca585ed659a7dcc4c1eec482af3f233ffe6a16134810daf4d2070f42da3a96f4e6d751f72cc1dd18e796e463c476620b8d00fddb115919e9c8a8b2448a604e6ba6b5ca492a423715ccbae5bc1d8fa8afb1d4d428ca7654c55d54af00f93432d93edaede03d597a369818ab52035962a7c67302bc43343374010e8a21d05fb21c3743d4c4f1148d06b68b304a3345a3dc37d766f084a76e4a8d0b18450de47a53fdc0b8e943dbb15598213700b284db520abe3b212febf2a160e95ee19f8ab458bc376f4775d3aefeb42c96dd246db7fbeda5aa9346a03c4abb4a3180d60c4c0bb2c434b1038e8cdcae25622f7aa5f2c609a02b2410d45a280b411649a2a393cac5fb7c472e5fb37f0813adf19047171035fd37a21c6b2f9d39056f13b20f5aead8faff30163c3fe9c35bf3574aa43d5ae6370b54ee280f1e5fcc3a095ef2a12ba00415c398505e8e84225e654a5d4de4b854e71f26205d9491efd07f8abfd7ed2e2cbc4e557d4f1fbff5fcf5813bd04edd0839c4d8734f1b268059e4fa120da84be8ff84eefc15bec6c2c9c256fe62c4523fe0a9be46dc065da43615e2a08e9bd146f8a0f6052a7e627e118a667851c938678b4c2136f3ba01af401380576d530cab685cb2b6c8125c0bbd115ac783fd7042412d53ae86d0d80f3779efdf0366a746f446909f16e87889bf9d3d831e00dafbd5ac25dde93acbfa2223f6f320d3f3bd314e8b8d09a586b16c70bd150e72e843ca9994c76e07aaa416a88f08a9569be20c84b1c4c488e1b7937d7e06f32984c42a3a6509bea5cfd8e7482d9f2a2ee37aa54153a4f2e7b8d54a07ca8a53c4b7b9f3b0a8daa4e68c07ef9e45738c187f926320fbbfa6584879cd64af7884d6746cf953d93ecfd3e957de4feddc3692361efb7dc89929e123a8f2758ee8ec0a2d1b2ba57fc28749e8deb7c1ff0dc85cfa9e547da2d249eb275a3861cbfcdb9106b17ef1edd2ae66dd75913c094387fe62b6c0ca922725aadf447458fea9ed3f5fac529fb13c77867a56e13a790e79649323584f37e3f44b0c7634f58f5bbe60a3825a85e359504723d5b2427b2ce47cfc19d48eb63e7af32ee8784b09d455a578b20cddf1cc6b83060f085f1d3f20e85c28560214b5fe1982b6e1c34955c335be272885647deb5fea2009ef3fd3a463d308441d13d8e28679ef49239c61f29c8ff1b1d601b17af13549462a70024f8bdc660a8f4d281f9291266d24d529770adbe1908565ccb7e5b1b6d1441ae51103b3f8b03cb4014230034180248526a246c57ebb877c0c787d5cab22eb4ecbb50046146669c98a23fccd7c076e4d322d4422bf92363dacea16d1c701e4fd6cf41d3aebac200789dc3fe670a7a60894e5229bceefa5e114718b95d07f37cad4ba7b08be27f4dadb359bf2ba89402ee1470ef313644946df121ae5686ce5408bb3d9b57a092790a674703701fd93e7bbbab9d202740a1389504df2924f839a7827d234d0abc2b87257246380a8753009b736542ef66fabaa5db4ea85bc130e822664c2e0ce9a25f4651e39b52524d01ff40cebb93e2ddc0dfad0570a52c6cc44bd0878d5b7c3c54ee4d4621e21a816ed745d057387cee415dbcde7b4b2adee0f1d3429f32f189bb7e3e644d4e102d1d1371a8eb53b2dde70b2c897da97af26fc8cc5f78c8f276bdfdc0d48bd7cf0b709e52a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
