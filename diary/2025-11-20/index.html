<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7fc17f1ec0fd3f3b7985b16c791793f09146b384a88cf82df4e623e91e1be04cdea1ecf61534f027983ee46d16c4f372eee47bd275253a7fc4a04ad5866f8a531e1bce75a18b63dc6b4f9bf470813d5c66af30da5bdc6ca153acd962a30ceb3f68635d553a8558abf7a0de7f208a485c9d510c1e4f8b784539ffed60a843b8da2a19a45c653e728bf1b7c3d569aa1f1bb393ad2b09b080fae7f43f8a10e2d306105302ca5aa9227eccbdc1b772a786aeeebbdc238d3f47dd84cccd9372cd28fd932cdbfa12eea58b0535b74200bea4cccafc923803ccba8e0b9b5eb1ed725289f6704650ccef8f9574a8a62b8d44f6bddee0703c728c85873c5e7f967592556b26d4e3ca15e483efb849a8bec11d23fd82490b084e392fbb3df71fe8d0c34d56b24b206f426620e9dd819439b431da299138326c66cd70d42661900c0b4453decadb94b29168852e959dc3bc0654af3a1d60b95329607493a1314bf801471496db469f38f8abedc60908416e7614cb5ff0ffd0a8956babb6c1e51f6197f7c0556b7f5952bf332c66521c89b04043375079cf77f2495f12b6da76461f67283ad3b68ef92a8c20a28dd734fc655b08b3186aa0d1c2d85d382cb17754f2f9ce205441a7c562284f9ecc70944aad8849725008f9823f44942ecbf956f0b6b5f833d65894113b2b9c8420af8b97b667197f237f9c9031ae2b4d729382af14fc76b067bc7f5a978a3e42d276d64a6be3f1a608df0485183b3e1819b19caedd0dd87539d62f93de6311f1dc44c0b69bcfebeedd61258e27992423131a2900e35ee32f5e499f4270356daaa3969e35d00e0fe8d67015f08e7c3625797cb7fba8ded02f5925641b18b39e202920fbb7078ef579a0cdf84b05d297689a85f973c286af9e717086a36cf152548786bfaec4be718f9c74045a68c60ad594b8b45bd0225f311320fb741c69aa539de9dfbf057e3ede2bcf36d253c43cb6bc739cde9e03abdd8bbd6c0e0553b1918f322d1ca03b521795f23c42ed3eb5256957bf19a3d60ae211aba101e759a20eb19aac873c09ac910c5dae2d062865e520ae878ce0fb945560629afc7d21f9141913f1de0d8b67fb6cc0c5ce102f5d2f299ba6910c4d8742ef419d93b6ef47df05626c0bf3fa9360cd8da5da67ce0d3417dea07ea786e0276ac7422ad23be7d675d32e694cc326a5894173d4a90a7394d637f58fba54604d1e9a1aefff626c5c9ab624ed0ca656e0197d41a1f5ef36bab223ffa8772a1c5c3a952c36e6db93cf7ab1392e1825aa44a6bceee38019b999a40153cad2c8680ae939cd70e38fd1146c87bec55e97be62cb317726ec6f1d53e7a255668f2e817e3c15ef5b9138330608c146f51a73594239025bb834213274fc50c85d004dbdbdc9a4175538f28395bd638c511dd42ffda19a7bf2fe7f5475cfc7eeeb09008f6ed65f02a5e6ed603015e0428b8948553f00f53e82cfdb5dcfbc9cf6dc995a0b23daf1c9f120f360f1cf64fb760422c3aed61cdc28669f07e5ec3751f1deff5b3e66024e90052f9ff930420b8acaa64e23da866e18537bd2574f0cef26e66999fc5c48fcd929ea16db53f5e01ceec97df98d40357736eaa96e22935b8c969ab1fa7d338e47991995ba0cb1fe60f1a756dfbae2b84e64770a711c0990684dba6d702eee1f0ff367b4ecc5a8c64408a69b9c10e750ff53dcd86e74a06f721c126c37ccd721949ed74c4737dc74885310e1172abf6435eb4081e9f49ebed67aba6c07a8a4632c3ce9dc42d55b803c5f370d7d27224a7e1c836833ac0c25b6b9dd682583bda0c4c8421993da3e3fbc193890bf98892e9611ce2b0f45e016893857e8d3ccdb5fe0b953c03470a86fafa15213507bac9ded350002975daaa68581d0296a333d5ad44f0f8a161c02558d07aff54f3d0dc9a85a7c41c57627b65eba09c5556a750c4767b7a9fc217a845fbd9ffbdbdad573bff60ac137f4c5b14fd0ec0dc3d267056d58b04249b8b0770162155533124896b9f390fc978285a158f19a0c7ed195e753fd34ada82fce2cf06ee3d7ecf96f4ab02da607a64abce47178b434c2ca41de6847de66a519d16c768b386aa87b58b75167473a197985dd6638e846743f7ebcd580903d7d5ccc014f915b835286d1417d94c70eedc5dadf798502d216dc0872d5932f1b708474f45ca214d229c0d257bcfa15ca99937e8e65453d4407b2c9aed6b70db849cdfcc303c742dedec952aeb260936201c9e8cbdd364cf0c4bc642183e6203f174d755ddd0b5fc6c3e8e94fe13fed3afef6e549f91a04d9b06f8f812268fd480d564f1ba72c10a0b1190ee1d5d355159a0af1d19f4fbbf88b0abdefa46d313ca779b94c8c8f796608b23ccff3eb62d15560d50c268d380fb98c5b1681e55883fd9abfec9c54cc5deb98b403236a6934f3dea052822405a275701798e4998d0f142010c534131cf406d16aa0e830e3ed2706dd963dcf7856879747c12818ba8f2120a87c10831c574790d9d8b858596ead960a9a643f5014f342357eacad1058681873010d2a59c3cb42d38abef8421db78fb51b8d71e3375c3883b229b3a3b6d8e37544f8d378d584a9bfbedc079d8f57a49cdc823d9b437f197191efc507209db9b0170bcbc0245be431c129235cf1f68a6ef4be6b08b5a7f6288b7d1436b8edfd16b1c9fbe15dd3690702f71b645d5a62c465d838144a75b42d70a082242e8639cd697443bb9210c6734d93f3cd4bc3f96d7ce131c33f0c4a44d4853e321161d1f04d7289b54e41b62940f16fb865b909648891da9b92f68b8eb51e8d91006cd2a469653d7d447e40d37f71ae7c91a5feb9b1f575a06b3803e01e7e6c14aaaa4f58501c7f6518330d8febb31d5a20e2dfd97bd54ef2e5f81456546d40062c961f1ddd07bbd757f205f5013e264841bebc579c2e3b4a67b61d41bf198e16f98df67ce00463033a3bee2a6078cca1c8241243ad8589785eba2a4ad83bcf2828a68f351c3bff787f34ed8d5be10d07aed08b1f9a21987b29c1ab68aa370616d6361132b0b041bc597d3300b9cd7c2ddf5d905f8390835aaad3dbc62c095b0d9be0eb3ef5746345752a1129b4bbfbb6b1af994901dc4223ae6a2269b3bdfe68c089713894a690afdfb23a641bcd3e0abe9dc670c9189f039607f90c82ef943a3423a38d2de62b263e32fed7342fd25ce797425eaa409e5b5465e8c53607c96ac54b5d41a0ceffd598464d94a45e722445d1023b96b023cb03b25c86e148c823ac677370209bf2ff0f1bb74c1f338d67c6f370d5f4ff14c2be604517f50a0a5617295ec976f571072ff8725f771b9611f5cb146bef51279b326c80ab4ea60e00997867a749a87a8a034aaaffa0dc7d5ef6ddd14d83b9641ef943b14663312c138863303b82d1fd5f6f92d485e0811f35dad2c4842b866ed8104b53ed303cf231e04849409484c993d01b9533d917888f3e297594b3ea8109dde1e9f3e70aff3a228dd583d4492b2f7990f96f45d083d69183b88f4bce3763195eb97fd62ad6c261227995ddc9be6dcfbef97b6ef1eaa3f262e2063fb9e61a3a8d1352c118cd8c92616dfb02f28aa8164142b3f185ca7a6e2f555a2c141ce9a422df1b44f37eaa5de85a555a0db1689f72450dbf45b0135ebe45aa1a93e33467f13036a9bcc5426447ab5247d494809dcbd12d6f4bb50dcd264df769e70771045e9d58a976e2770db36f9dd9d9eb772ebeca650062ff738583293fe1c5d2619c3d5482dcfae7accef493f197e2bd6686ddcdea10241d2742e774dec60bcaf7daa5121f8fe306844426ee59a13355fec67045185f9af6ef9ef375529783e2d3fe5f0ad5de70978fa08b6aa64404591e90bd9bfb05e9cdf83b16d9ae6404a463071cc205fdf131f52bcf365779d1b9c8d458460195605d4cc694c28241ae9b81d465c2f63372973e124b5de89f3a41b1fbef29e45b874bc0d304a655809d6379c0d4bb576c5e40d63969aaa58d5c4d110fa38e7400b776077bd31ae535789dfdb4931ee63faeef1f16568f86e3cd768cf0c22238c330e5afcc161c0c9ebc9b46439f63326657c4162262f43c65d383808b0beba302c95a5bab4f2583dbe1824b5c1ebccc2c35748f4a0dd6b30a8aebe6c9cbac5c9fd74562b0cc03c5811f2a7688be94ae4c5110c73e090ff0c3bf461b2e0e5cc8b34919663e3531cce4e6adcfc1df87e1c0273eaba9d1a2fd3b2c8ae74a77522b7489d1d91d7497ac846b6dcd69d4e7a4b3d707236412a0187e3fc1499a423e39ac319577c04cfc2bd7ed3d5e67f7c48b752202244a3d0449de0ac03fbe1c9cf38abd49774de43161df3f84f02aebb9d23ea26138504573ec4e913e84cd33cce3c67dcb2784e241cf6a0f2ec979296ca2fab40223073e44a995724a4229b727c5fe41e256dcb03a51f1a392f4819b2f2563d776a5f478309c3e171f4d2c8fd45f0a6abe461151fd2a862bb8b9561a6d09a018698d6ee5b69795eb690d278a2c9d7d062992de3f546ca2dec60b7b94dcbdede343a31d16e9d32d540035e9f13e4e8b2e700d4d05109d31891db67c79f31f051de0cca17b2f9368a7a46f58ad745c433040aed0831500882773b2ee6a0bf3abeac164942157b98d8bc876628570216a4a4d8a9dde420a5bdeff8ce10a24f8aba48997195c0f6560fbb47eed8d0c9b2c718fd72b8051b092b3eb6092d953a34a7ca9bb17751f6b60f9eb0ff218fc4317819b57cfcbb928d0b25c7e4407f38d214e81a4df24d0d16c2f8ee96f5072af13335ae693a409f8e982d73d2a6b69c5fa5cedf44f4b54980670c6c839da2c8fa5f6268cba7f19147bfb5bc17f6267094e748b241757e9254e58fd9452354196a187175e9f6220b1c07b932ecb92155dc4e39adc70d4d90c8646232636431af9d2e8b69f7e92972daba0116bc31c115c83f45567d1c927263e43d67022d4fc20f8533d9f53b658037a4e7e6b07f6039f16922da43321299121a290dc894738aea76c010533c1379be01e27f4585080d4d7e744053eba25aa2395afa78dbd3667f89f57641581880a4cc22f776084df7207313d8a2c84a69099e6222ee7712934232ab201121733d84c9c2c90ff4d5c4a0d7b326adf4b302b338d5a995163d32a4e768208273f78682720f12e00cc5495b4baa2ac3acca2960fd9e8d226994af2743f37025793d61a99d9e3a8c101b2c717a9ae7bdf19aff794d51524e10446b93218717b7932c77256517cf57897de2bbe042fe690c632a7410f54cc1661f2e0e2eb2a72f0ca75b7cd8c52750b8e02847f892f8151bdd98e63f486077bf08a4c1dc6f6896c28fdc6db0120a965eace8942c024d4877acea0a127e4c2e8c7c75eca503fc7567e56ad4fd232a870a7be03ba8372e8831d697faab4d14be160fbd4214518a7449c087f453be1b55844fdf729c834285d580af68840ba9d86782cf51126654bcd88c3875f2977b0df4f9a288ed3f71672cf4e3833f91188ea4e342815fd4e31db05ca322b93baf77b24e483934b03d432d3c78ef9a477b207106f5f3ad11d3d3eb98b3dd7acfa00c20c45a4ba63ba7c5a909d8bc3edf3a3ff8836fe74169619e9fb3935269af74113085b272f2361755e1fb9e035d93ea6403cc9e53bf62dadbbe9de36681bc4f71d584d71a1a73f553673aaef0166cd8f192a11e98acd9bc8f33fc23b5e53bac6b32698da7562b3f5cf24bcdf0cd7d04db992f0f339685128c5e20698cefeca953e441f2962abac56467be613ffddd54c676159cc258a3daba9044faa49a243116d530ae182089ad49bcdf4b65cb9186c4d3f0ba4422734d56187690d90c1f4f4dfe58b85c2288616ac18e31bfc9490ed3460955bd9eda8cb6eec7ef8b35d1a8198e92096709922144b84e82f9c2771161153d9071baeea774a0361f0a802abaa2f6ac54610a1e4030194af388df787d54eb3a65bc7fb4e1d5cbb2d4d0fd8cc72bcc46d08e8ac388f514612a8b8081c0ab42388712881e48fa9e41f7614ebd2bef1c80aeed352ccdf822116f81fdcce5705c9a7d474f109bda997f2cf7a189777d28b01f58286ddb4343496246cd38fdd9f176ab11ed5cae169f64036708946045bc2967c4008eb432c6ea1b72b22858754a675a00bd9b6df443eeaca0588bbcec7ecabd88c925c131743135a0d9bfdc94f44b063944adca96370ef6e5aa7d230eb1e1e643522677a76102e6d84d89ba667ba5be81122280402d845800fcdd5d8ca8053b77b5564fc9dc1a07bac3e68a89fdac28e668be3b8c817c5d15b6e4e90e22b627fee1bb8ae77e5e1c2daca8c72561fe42d7387b857c81fc77c241744d43e3a049e35a61c1ec83666c912f811dfb1d92c00a1a0695be94180094a94b561851c8309814d9a70d38566be7522518a7f33548d1f5098a7e7187d731f4546cd76c7849e54d5776c2bd5bffffd5dd9222fc5a3b864fc84c2234bc5d08fe32a38d6b12abf750a3a95ae7beb00eedab88de3b135e326bffbd988a523302a5fa4062163112211b5cc881788bf1427e3bf64d0c7179d57d9e30f7552c75c3731cf8243f02700c8b1be394dcadf7b7c8682466aaf8d44a0f61288c95b98bb67587f676f6ad4b232fe331b66995990399ee09d9f97ac77ccf9253a0bcbb3d66ff4eb07e07624eed0d893443ea524f25e7c85b36b44537303019b44c60f05b7361b3932018c7e325a2dcfa14e30ce7ffe11ec0e3656921a9c59069d8b75153bc64d792c200624401327a53480f0b9fb727778451ce6625dc6bbd502f68f973350fcbb729b4394dce56bab9e726d7a6f55732150c5e4854922e1346fe8634fb8bf068a47f4621cb3df82efc42460bc716c77abd46095d5a92c37ae32e09808f1e548d8deca36b3e1694c7740f5e3fa5f10bf6a842effcd30b24e8ac9e43bd8a1896d0e6249cf5f43624eb0a38d1fd01c2c6f95c1c00e6fa79d351f505dddbc7b00ecebb440aafd4e1d3edeb3a8af53b9eb0c024d6ee38747af9f79cc9f32ba2ff43adcae51f01e1afbc815ca2042d9c59a2ba40595e9ac15322765aa2ba69fb98aa5c3724aa30dfe40a11966ed71cd364eb64d3922c77393f9861f63146dd330718ddc72dc2c840fbc238f56d514e796a756ad5a23b4cad3c63a03857f54ada0812d3b720235d204f432480e8b7eb518076a2c101830ad0d65e2e01dc6945627c4a9ca92c38f31876dc23fb52b1e68dacc5b7e855ef3a9b778f45428273b00a45dc9a9d9fc4c264494afc0fe6382da69196a8beb484498124110cf1a19129f85dece5f9d714021cb2da478c390ab681eed1d32d1a3a1655590c096fa896a5cd2ef897c93c1ea3e32d39e7774f4f386813eb8cfb6a5c17ee912b68e5af597ea51338d82b99c2a3c7cfb292a8bd6d880306dc355c95e30888e80c4216b7704a5b1b93a4314c67b4f12d8b3e024ac594870e31043436ac6c99cfff4678fab3ed361c23b847801b4471ac173f9d677ac78282a9f57ca47ca7a1557b05c8deb43f0c82e85aa996b542e0687a6fae1d9965c6b5898c449c3b2c94fa54c2f9d96585b60b48eb0f6aecd2f0a5a569b5ce4bbd71ba10de67979afbd80b417bb21e5f54a614d907bd6174c71e32af64c209b65e198895a306c78dea9c7eef410971ed1b4f5e6596363a72ef25fed645c3ae5d48f28f5d34c7e93cfddcd4465e94610c9532d287a33b6485953acb904ea6fb4ab1dc9fa4beeade67b84d45c1343fffa866af9f6c95e5f861dd723ad0668b68e23792825e0ce401e97bd24140498446c5508106274c1fc58e6dc083717891f9caa11184c89f2a62eeab96c2444755b88a49eae1fd5f41b00155b87c50951be6039767427b90df48e7229abfbfc91d895511b1c2fa14b6ddfcf20691af7f431e3c4133154c603b81921d3d663a2e037eeb8e5a5568b217a1aa4ac345a044fe988da844d8dd52ce8d0be6d25e84788982ae4295a851f465b03f7e7c578e7816ec0b8608f8295b5a882eb440da61228a90a90d698639df1e2248f0728c02b36cc5bfa75a7dc0312330b42eaf50d82ac78dd73ac7321fdd79ba84225f35105d19f763452447cdba5852013b7c4cb914d18bd5ce69d4c16f77d075dbd3225f9e7e1b798b0960958a87de81ffab11b9f070b84110fd73c8429246b2f384312ce717f5eb3796ea1f2ad8402553c74928d6cda74a34767124dc7f88fd7c02fc3cda657cc6dfe732bb683987e79847bd96f0c2936dc93e6cd70ad98180ad5699fa5d9b49282424139579b046627d0d9b24cb41a35fb5e583945709a30cd69eecf353fd504983bd250bab3c0b527447f1af4829260ff2c2d2c1621572f11d127dc3b3ef6f77b14e0d2f6116a69a660580600f013be9a4e2fe1a056af20ec63bff3a99a2d1204bd3567a825576a406522175e466486f180d6802e8d3c0380e838802f89b4fce831e5c00e3031e379ef778be7143c4e0da1ecab5071168fa0a4a09bb36b66ad1df5e23da26323776f2c66544f74eab7ffcd435391b35433209062e7f845e566272f417448c0929a10cfd729d8256586c03f02396fe03448ad658718f02ef819206d5081d1969dff49fdf3e190c6d46d91b41db945506a702cb55e1e9bffa7ee9598e9c161e4c5925146d6129c8fb5de1146df7bfd83453d1f5824e5b4c1dd2a6028caf489b67e3a90b3d8ef7bb9b190b6b7e472d42ef5f3adc679195e9e0b934ad35d62c13daef97531400d6cae41edf548d7bfcbc20d8b408394c9737603b602a18e06f60b3f1488ba96ff907718e1f679aaad476a7476f6da7b7b6acb5ef749881aa9b7b91b76c80a62c69516cfb5c1595255266925bcc6865a7bff00b87c647bf3f06c60f3f4986005f958c1da7f3be0b74f03177c450b20fb60bebf323938388605825180a4ab5b815be2eb68de883c28f7f497067ee83d56b26cea168a06cf477540bbcf06286904f9c9045628a669e0bb376543cb34f69a3e223f46048134cf90e4bee855ccf597a6439adcc4de25ee7303ca5b2ec2a7c470577b3ef5b8d806a0319966ecd5052c521bff1c6711bbc52c249c15a27202c0ef8fb10f0c19930ac4107e69c9153c79af404943320d07f1ba254c92de15c53c3ba6dc51aed79e1e79b37123bcd2d0dafc67481626acbcf14232a514c087683f289ee059b3c7797ef15d7f360d4f7e903ce2a8d7c4de0b9a64e08cf63d67b682ef3f9e1295bd260338aa98e61efaae728443f715728566ff8ef845ca980ceebed9e261542367076aecc99004f1bfeecc4dd48214d32e9acbb2b3c2e6307dbbbc76c49e4177b17029c90e52ab319f6801250154e3a250eab15b34159c874e9a7394088d085e3daa48c84448b85a65fc291914c973c5d3061d2fb12c7305e765ca961cedf7dad04e84b8f673bd8d434e078630285626d1e7b732c561ec5a091b982bb29e73045f175f8b337972d0f9326666bbf677acdd567d978380fc9398a2bb2266c6db5f852f5fa2900325c67ebdc10d67c0f6b7378be2af7a485350efa15fc52cef165efd5ce71c1b6ccc8ad68fc9ad0c8dce16d7d964894c60d65ab839bbf69f2b3450ce4a8183d7bf2e7906c8a9765cd5a58494671d544fc5704d5df31468d12b9503bd2c4aa20e34d2c4bb189dcb8d994fd6d6680f6f64d341ee434d49a554e71afd300386da9344e567f34ce7ea9dd724cd0518426f10d7cfc47fef36bf0ed13b0484ddf6cfec71d733392d15afd5142a3065e5b3c408f40881eff0e260d9ca37042ea9fd10b0bea4b109bd13c5f17f8a5283d9d48415f3ce3c9fef0e9d168cff78e1727ec4e1b30cc48a8100e3482e5d9cdb6d9ae4527eb8eef318b30119595b59a8acd9484ba5bf5d18f0c3b26397172f3256d46c3b512f701a5a23dfb53a311c782df46fa619cee14b2e06d5ac5ad7e778b4a1e0612fede3365a44391bbed22bd5027d4fe25739502bca4c932172e14830f6919ddfbce1053924769539a5355f8fbb91ed9861aaba680bc79e686855748d4914ee5002dc95e8b429064baa67778de9138a058e6cbf6d0e123c8f8405d4d315e0fb36a879f7901d8a6191dc19df7857895b89b1fbefb7963f3c3aeab400e86ea7b5d322101e1a153b841537f9907176a811c7ffd456239a8844ff9fd2df002d4f676ad85690dda283defcb73c53a3f28ea1172f13ec62d80033d393ff947876e3a42e003420efbed0635991834f8bb7a9114ade700581b0dd1439def54ca4fe9a6024903defb4bbafb15a787db5d201abebc7744ae06cc3ec1b24226b46a2fa93bef45984fca5a53b5d4268612578d745b1cc5236a2dc15117ee406f7bdf4517fcb467c543bc5e7cf0046cc4b65f4ae0b9e46e1d7c01df093cd6b8290bab26a940a8d82ea21b62aac8010138ef0c969a9b4155b2ce4605a890b8f100827824dc3f50654326c870d1e67973ecea11bd3696a962209902d1c4579c9456d8165acc7153fabcbfe0c4c6f5e4a08420e1469c063cd48ec0e98229fc3864862d3ff883123025632f9552994dead1745068f75674edd6b4215adc9f609a0d5fe423aec438dc15b1dae8db35983d03d1975aad3bb92432238f49da0860f16f566dba0006354d0d6c455c7ee67c9c8c1841d9218bf183eae729ce437e1f80fa79d4c1de175ce5c72350420c5472c27fcbfe5d00714342baecb4fbc4f64e5c2a64748075cf8c787df502e883fbabb7f1677f18d5cf5dafe013406c312bc2d8cd6a2842bd8bf661b3a823cf22ea63c4181f9049ee5777bb9c3b1a1404cbc15584ad7c10a0183a0b2863f7f2683ea6848b10e37fa82757b48394d00ac672220c5d5a4fb22c0f3a0c66439b5c3c58aa2e252b339666e3ebf64db4c8c3e2af1dd892461a6f0b0079edea6b6e9d2ed957817068e34ab77b31f75609fd9e2dbfee4268745b7fb317fe2155fc4e7c27c9f47ede4fde5861ce4891a66e743b527263956db793efb7ef5cecb977b7e70f273c83ff28f79fd626b46df8c6a1fbc5acbe75f4505972e20dce734848e7463eeeb0146aac747d773d92d21963589b8f1ed369144bc843e9b642cfa7257fd120a28505db736b57ab6ca4bc0e30b33abf7cc31d1284b6f96fc2445021555bd03b6563a623780b5b0a848083305ad0f4f06b09cb74947700221255ab0b3234f2576556c92752a8c0f864d843d39d23a7a914cb8bed6bc98a79749e7abac89ed47dd4f25d6fa70aadd021f82586b4bcc88947e909e8bdf1133bc4d2e98bca7c15c2a5177482a8cd8d554c3687279bc3c32fdd29a493a4516e6f9d374662a0e09e62841e0c6c5b6081a74749255cd717ba6fae835f306bdb222057564419eb2758432c2ff9b31fa30fc97edf3aa2e4da60d5bd7470c34d5071cccc7378cbf44afe123c8cf257feb7c659bb36dc705e0bab05447cc148c48054c6a85095bf40ba8883ccaaa0e87dc7f0b52b07152ffbe1d28eaa17f83184273c4838ef17267f681a245d8a3cd9c52e29def888ba98ec0bccc65b03007512692ffbfe369caf681a2319f1e2aec5feb6fb2806c7d0882b98450f7844526321871fc7985cdc0feb34023abae16295300e80927c099b8353b62a842addafebc6ddd1a7863cf8ff69e74406faefe7cd58ee45554b4aa8a332922e4cc6e5b6fae4b472b24388686c2ca0e4ad35e094d7534202ddb423089dd03ac65c394446cca5f92651f389982662dffbb96efcfff618785c5d5b1536d4aab05572f078f7d41acafa2d92d75128a887e210929f3e8479be21f3ed15cb89d5966f7253f9bf60bd0826278bee032a7d20355bfce013d77ac6750713e12ff2a0873ce3c28b54a2bf383e34a7ac104b7a0ec44ecbdaaadca0980119d8fd095d4205761f84e3c53e69d34c538b3ba8b4ac6e2328d2e5e9bab9ae097e18d081130a94d00a25e6ed3cecae3126692c41cf96cdc61823ae34253f2c74f64400fb18c74fa86144e140c132377afecc33d75d696a475dc8ed6a6b7e9a588b53ad60b83d2fa8bb4375dddb221628894285982089304f6eab35a458241c26947e1bf5d8a964c3f9cc6093a4c6a3f91e5b1910cc122166802ab2fe54f83a8ab10475a258b15d9b45e1ffe7bbf04c54c6f56b6f7e0bf860deef93273fc6885d584b5ab0bab87172b76edc8709c5650f7ab6ed70220393c6909bd6c6bad5836d7b64cd091652c375c1c5d7fd637c11a43167ae5756d5eb594959558e1256fd0803a37c3983eca495ff22901c2321d3fc22b7003c017ed30322709e2705771604632c81d918c6ac0e49166e49e4bf36b446886ce06245ac7ee5888479bf89e9e6d6cf99c89dc801640cc64e53ab5edfad4235321f073d7dbcdfb96409266d728c4e81119fb6776d68cd3bed226aceb284fe079279f4e93080c0d5b190027cdbd306c084ed415153eae9cde4c36c4ef26e783b358eb95b56dba1558677ccee250e67c55e57ea8fabf5100aefddb8836dbe20dca9076cfeab776057a94f534fd9643e28095f1eb5c335813722c942dbede038f5e9ff48a4654e0751113e8c2678b9c46b2b7f40dea51f0422fff1da8ae43d34a73c00d28cb55836f4f7f42daa6414f1ad20ed36e0f7712b46f0bf40d491dc3697fcfdfd6b2e1e60aae31508218b9c17d6e8c9ac04362a8cb5d949c4135a64aa69a72419bd9c845fda5c82410cec4ab5800b3bd860cc81f01a66a3a6ab6c675686403a8eefd85a22e7056ce1a6286cfeb3bf97ddb927374ac77124b6775799dd63523333daa4d6d353774fa6d81b65752c52294c1787b64f7e45c1d82dba0ec16d36f3a5a5e73eacfd6416592ffae79431531e1f5e47bb9d4e85539598140bac065df83d6d97f7a3e821af66fb7c8124fea616d64bd2e4b03fb990c1dd1e712dc1f4623265127d05426db7e7a05ce04e661ee9999ee07960bf317e9477418370bb978f54766db31672898b6c00238bd690a3be5741aedd6da4626b5be942f6d2f854954e2b170d6c37fd4a16620357a5595deb30760340fa6c8e5e460593e7a627930b6b4a56afa8109c763183e56e7f0a7b48abb93b5bf94ad5df14e07c6f9807c748ca43a92880ec73f453aa7dc610dfd084384c6126498f6d4d8d629234b1ab1364067a484f85d1032040fa048c22fa8c8d6dc30cce45ffe38c430702ab893b5e0fe3939180a22d61c7355cd27e4b68acfb143415c307e0cd0ff4a93cac388459161e73b08f8643e9d386cd14a9f56f1a5a33a70576bbd7c4886be38614507fd90ff8616d9a20d23dd78067b9db2a05a206f8387f4eb1fe05e31710f08c580238f5a85f4adbf46f8e1e0e1a69371928432ec7f4ff693975262430871da55ed3416cc844ab72eddb463162039f4cd707ec976fdc70d9aa0f829c1dae3b7548223f15be314d0da7f90219253ffc537f33abb67d8fe4e8dc0ecdb9bbc60bf61bd63ddd93be7ccd10e9be01c431ea9cc807a2902ae4b45d18f7ad7ee0ea9223688c078e91ebcd8c53f12a3fdc679995c1e6e510c7be38ba2da3132a49553f092e38ebb33fd5ce9a792b1f1b24e33b312cce521a262f8794213fa4e9773f6b9421c17069b8bcec4bf4d1e56b71d3c7d604964a977b5b237bedc5685f81075510783f85673f3771fae866e4576f1119ebe789dec59bda9e267e6a838eb28a5c634ae00d71f006961b4198c19a59ef8accc2d06a10f76d11877f9944a3101525c3d7b0056c10d20719c785671d7c48bb66adce5e78121b73e8cc352f8e3c562bc0ff4b6ae70da7c5ed7f7f3c76762fefac7d71f2a1ba6c3d18afae5581084bf1aafbf53530710c2f9b04960c9bcecabb24388ebdea68429949ec54f1eb159e7d95b80e3408092ea36d11a8fc52a4a0e4ac0b665695488de03f243d86edb1920e091cea82bfcdeb0a56f92d5d9573255eb1b1c2500cf5ab17584a8709c632c4520c6de66a55d26a9be2102ddbf8f1c1ecbb7b5965d8ebe48f5aa33226efa5de1824e05417d80de8a6a6340c6585c06051db3b2faa8e04cb9d612383620b67e4279c4589347a041af0290a601f54f63e1b26804e44498a487f68ed25be2bafe0639ea4b6abfa62125605b5dc74f823adc24e5094c2147d9558d758b1d008bea50086cfdd747247dbbb71bbeaf737aeb762ff7584aace78968db2327e9a94456fd28354c49d42ae3171b7c3716d1b74e2dcebee9437289d637496f700df543c95e289d49bab0fc08a8a3c41bc834ca2246723e12126a01921ae6083b3a15bbe73a7c9955f31a60154c14741080ffd7b5d97cda43f242a06db13519a2f6b0714b24aea4027bfc1fe95733f8a7364999a1ea22991c222c88811210be3ae8a9c46f45607e06ee8a7258b72b16a79a3c145014c96718e249efec251ccb10b75c2e6e7dd5ae78389e0306a618cf323fb2ca8370e0cf6f2d1bb27d3c15c7e50b98a242d142a613cc8cb0fda4f0c83517d20b1b219ce5db5879568005e6f61211d20bb616d97bbb531aea1cfb1c83e6552bcfb0d6dc12748b2957ed28422e5cf4a4e28767cf0a7b5ff8ee4570efbff6e77b593594295b72b6ab79e04dfd1ef2b4f276f0bd614dfa285d231501d0cdb3074cb67d874112d028d231d8bc6e771b12313a6c6b97595ac89effbeae5059ee6f4464e48ac0f462bdfb2fbb2ea470755e9a77e035fb0b2af3c1eb86052cbff0df5e379170b2b7e679ca8fb46f2402e630db8d4451209239ca13921a8685dcfceb1fbd10f1d6f2a59c344dd5388d3e6c3454ae94dca2bf796bacd18ea0dde898e01720ae74c66c38a510305193a8477edd17372300f4d0576dc2c4a8f7836491adfc5be824e64533dd7fce68e2cbc2c2011054c4c7e6aca7d85ed6a016988aac44249c591802a92caaa0063e87cdcf4c188300bf4d9c16aa0c03b1e7078d6b5d9bf000c0431199d0410911e567b950c315d2bd9073fe13a6616feb9ed5f05224d359e52cb91c516598b2de9cc6ff850058de88c2fca2f76553ed991168a2513c924e6d8e332f707d9ad7d7efb3c97cfaa647aea578f0abd9f64c7a4766a025444cbda9cb8127c2b6de04700db02f86f2cc769d982e2b792c8a2185f1db6770841c82f1982d3d9f75355caed08456b6f7bc5b1f92a6903d31ad9a3b1b878ee809aa8830b79c179a9946c3d4fbd722dd7c59d9a91dbb275273f6266f36cd09641e2c6659231edfe865e0853c0346b18e426a53a7307e887c7be227fc446e750af67b31b82519bb3d405c879df79db4cb6af98e4b8e811ab7ccfd00ab668d51748f86b770c83203a48da1b8d5e099b530549338aa98b18393fa854ee7c852c8193741167eea7adc152690e3a2beb059aec27d1cd12817a624105cc9b7e489a2eb187ca559a2b2794377730584e98b79838021af2023c1a62e08a46dfee87b642a861e528bbd54049d43aa8758446c6d69eed1214d7252b24c2cde1d655dbfa61ecf4deee20d67cec5a229e0d455253de90be01213c3126f192513f855c8b8d83ae9cd61234f47217aed872bc6116a5e4e9f1b3bdcc0453bd823d29016f2487a60cb277c2e2f57815c1e3a2424d1f72be33de8e78c3a50ee3fe0b658becfecbd27cc71969cf251f9c997b191c60d53bfdcee9deaa954ecf80f564182f78b29e01bdba246108bec6270a44673c99367d43939f0b56e6a5b84b8422c37edae55da059592e081d5611af456636c63b2e9473415397717cf2cf41e6dfa6c45219b9ae83ebe1d3fde68a82cb391575000160621bcc795662588f9f0c8a71fe38b67894e5a97566a448193a1d74431333d40bc5c82b558ae2bf9a93d0f52757776a3d8423787d6a5d49b427954716a63c864120537d99ae650583b506a10ce6083b246e932b750a9ac692210c6afb069d60c0c7b24ae35606615341364b484db770e86d13f392310e9c9d1bc4071536c2d16fde497a602f31b63293e013866c5bf14accf50fe5e846ea1dfc0c1643c58c3ebcd1de536a17df906100c30b87daa5ab700709165d7c980283362df4ed724a66305c834c2f2b5d48c86bfed1f7510052b5f36a95ba22e9a2432e5679b4877b3cf6ef3dcf0607a11aa9a332c6f3761aa27675e7342407d1b05bd08643048156483bce747ce180c6334d96fe2558153676d347b92e54f3fd644528b8ca290f8d43153c86f34f98c59d27308196092c015d4c584def91960b86b4e427c7562204f12e8fda5c76f5b2d24a445bbde4ebefba3bf4be405364fb8d174c37c20f8e5f754cbb62537e162f817363a092fde41a0bfd0327a619534bd5727de4e62b38763d87c97fdc5331c3789eff08aeec6c1e97d2f0d8c579b86e8093e4bd6e24e8185ebcde4eb42d6c5630b9c1c88901dc8495cf744fe7106765917198416e168e08851cb01583905b8755e20f762aee7a608e71fd4fc419a1a13acb0dd09e3782cc72f11011516a1a4f43d757affa43c84f112ec909a3eea2c9c79f60dd677cd2214063ebfa064bb6326389f758c617c1b49049c6ecc26fbae2e097136bad337478aa629009f1a5c4943891e4e69b2765bcf246d339e41d3fc182709ba26795e5119d0f309c885c15770dac3003bb22ea8a06c9777c4e23f6b4be200f2106c784247cc0aa58347e847bfe0b280d90a8fb70f10d03b94e883bcaac1504af28072c3969e5be68e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
