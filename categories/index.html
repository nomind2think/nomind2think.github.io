<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f5d68169facd1168ce45a0b6d054ae32edc7b71aa571ccb9ee8efd6664861fd058ba363f2022b97dda2e1272561b52dc056630ec620c9cda686362545bb967b3589b5a0acd0f603170c344171133e395a4f38630bc0e61430f384190034a387153e140c589a49af76378b2f137d4ff49ff389a4da6844b91e97227b8d05c9bb0687367cfab3253bc4d72a16b3a88cc8541180522bb26e62154809f94ef265ae0a05d6f6fe26c44351e461d1773c4a1c293305bb636c543f834f4a02fc16ff732f2b0cad790199876422e544425fbff3f917c72ab65bbd3e97bf5b1447fc3426826397370512b2f9a14c71fee6db36ff8754e6917ba7e9a0d06ec98bdfa33095af5afb26be0855c5b870d5251af480125f0cd8a1f71e40c8c7f4d58c45da1157e78ca851d2169024214dba5e491610e59b0b533bb438501e527e1cc11f04522c6504f3f288e859bf184c4cc8458782979a74a3d4c7de9a82d80c3888dde6d594ad8232f046bd5bf2bc40f0bd10b87f1fb48be9aeec115dabe0856e9861d0c7c93407ca194ef451f1eb6b0f449c648231da94dbc36ee6a96ba3276ddc3f179f6dce274dd7d0b0939a04f093726ceebf47f5e12cd93c4b66892a6deb517075c79c8b5cb97ba73da2001c1585664aaa20068be7dd5061b75b260080b2272f7afb22f631ffaf82c3322c91bccceacd751a3dfc21f842edb88a8bac0d88fc0c2379389e951fef54ceafc4a47213ac68605abb54ca3c98f89a1d07fac2624866316308cb678803893da346b229e23c440cb4054bc95d73502e72243fc79182855ccb81de5331d6058aac8e28cf5065a09521eb7db0bfeab21f2f3d1ce4b03ed8a30b048ff487751f2467320ff3596f6f61c0719396124c793344e2eb3afc1db2863e0cb83738f37a132ab14b3fbba4c32f324a62ec76c368efd4d9ac78b2a46248fc7adb3f660bf346716eaa5a1d6a7240259e81bf2a957848aecc4758edd723a0189756b3b100eb4a151cc135ffa1910f221b6a22300fa565aeb3bf8e9f3cedc867d5cdfc02630c9ea65d3bf4101cd0477f99b9262578342771f55ff0fece8abc13d8347f6f10b8da29272408dbc1e4a0e6e72f5b8eb39e2288ac401008b2339a06e9b7ecd46aa0758824ccf48edf0bedab932343c88af9fe895ce37a5d21f318e979943593fefe68ec14f71d8970d3df4745132bcc25a79057627b78174071a55dfbe444d6d45e497bfcc7e320e655e2a15bc8b3b06d7cef0fd60db5c1d470767cba4cae1417c692617b5981daaf138ae0f3c07664feb967928f55a1a98291b0f446c8cc76b745e22bb228eef00b3d1a5dabf9c533af27a9df6c50ffbcdb0ed91a7584fa431c5e9b70dbd3a2d3574b2369ac610046a611319a492b9529b753740d7beac9aa0d27510ac6728b5a3142b0b28599b9fdd0d52e001cbe77fe9a92a6d2efd1ea2d57812136aad505c4b6a260187a5883373e31455045d24710d2161e689321a3bbda81fb2b861715920c2aa3ec63722f08c4f14cf6469b07b1f5a1e46a0804c54b09672233b8582cee9e46c887608724dd471f235e3a32bb412aa964eaa9ddeb728405abc50b7cd1748d83d7bc1571ecb335e1fdb73147ce95cd84354b0825d2cf8e69f107e0e22dd6832c4207c9c6b1b8256f1e6c06853ffc100ec23caa2d93d38e9960aaafcb8f764c42263d6e4191d6817f2808696df85c609b7521309d90d7a99473dfdfdd1060354b9bc962294bbc9bcb2bf7c496e8b3dc044036c5bcabfcf910e6bdd243e07002c376f1e5cd240614bf98c0079a69b9f937657036c9cf63de8fd15270c69548f06634bc3f9d403bc3e49d40de4d5011df7493ab26f26714476c820d043eb9b7368783d3cc474fc750da9fca47903ab9ce5395ae3abafba1925f12001ef13827442c756b1adccfcc381ea9462df320ad585d2af37a2a6fe09ab64ccd567a77a28dd022570a9a093f833267311bbe84f2dbe1f120b85c329bd98ea0712d7481739a57d52778177891f4267a305ff3cac928f68f3240d940bddd08f0acfc79f32f43ec788ff8bfc1fe6be2899ff07ae147bc40bd603cd45d3c7c928abd592c9b267606d6c1c92113f13c87a1a5235e420d69065cd371982e48268ee5a1853613d253e20092539d21392bb554079bcc333cf5cde85ee08080d9b932c70ce01c9b9e740651ad1ba9ab4b8287a5b8cac38670674b0bd640c32936fb84a6f6e6d58d67fa20088ed01cf04094691e9a6de11a14720ba1b09ef1a01f077ff6dc070d30ca4b121b5d78fd2f931c0fb23bf4b793bbf4962069e067690038baaca3a303b0ab3767f440c2cad4f194f004a9ded502e38a8335520b1c7382540dc9a51473a54b044bd2c20c93ef39d1bed49254ecd6cb9eaa8b9a369a4feb27e6575cd2aa835675662e6f11726bcd88ca7c8515e96cbb07b880acfe5f10e027972e93e34b31c2d61b5496356789e609321c86ec012292cbc713be4286a5bdad74862ea5d8bbc1aebe2cd600304d938e058be2ad2ef0736cbdd374a831e61bfaffd32cadc06c11bfa85d6d1d3c4aeb33ad10ef66adc2b0ffc9b8f3a78e7a372af48c69954af7a3080debb4501f16167321511f51ac15df2f8273e47e2997dcaf002da6d14c9fb3efeb065ebf31b2b796197fe46e90b452ad1120caee64c0682de999b27e148fc062502ad0aa430ed3d7910299151a6e838b5e7c57f498de726a659dbc263202ca6315591b9f03d75a8ce9d3632beba8562e250bef3aeb5610551e89347259d3b6e1df44fb4ff61a530e40131bab41ed9bcd52d7ba2bfec542ecb001c9437b9a7a8829e9dfbf49beeba75d47abe370784b99c349ffc482e32df54770f29f3437de9df622f2217ce583cc4365606c0c9cf758100c108983dcfdae32473d25bc4603709a8a537616a76a91fd4ee257e6dd1b19473ff72372b0a1407f4e11a7d6bcc67695007dcf9f6587dccb5555b92a2d2bd4ed38822bbbb374882fb69e779bd9f105273c6afeb851f2434102f4b998e7969aac4e6565617844b47061385d75157fcda2a9c67f3b723422048c0906f6f6c8d2b5c775a6429d2ece8d9d1cda38e1e6a2514cd3818f039f42ad2eb7bfbce5c4f25d0abcb51b79fc1596c84ed4e27eda5d55907850ad1b99ec49803e910c52af138a0c07956a10b9d3189f535fb32f9d13e51e5d190d081beffedf02d6c570538c1e90cbd3b1baff3d6a6a93c76a864994fa5777aeeb79ade91471943640554f68e1e2016c2acb666a197b161090a33723f5a85291176b4bd0fa53437d1697f174275d558bbfb7af1f8a4955ecc9d7c648e02ad0013ba0105bed37baea8fbc63b9c0148803e95027b119d4e39ca3847623b102892383121035689f126e911ffb7da89a9cadafa5653291c5ac5ae8c67a9458d62b1957aacd68bd0b7c5cc4ad42d8de217f9bdde5be9303b03a1800e56fdb4f65a3056eedd5cf58ccd5ebc7433b0e96a04aaa2b5346829ebf863a49b500b0dcf5daddfc6cd92a4004bbf890a9438406058fd4716469fc41f463de372ba8c3e61ec5c97d5c1cb38c9b89e1f3ab126a5f999f671c4cafea641f758a443f769f2c1649e849f39cf1f43fe11ab61247dcd289d2885e153b277a1ae533ce5c0d1dd48981f0e54bc1cc1b38556b5d6f334250dd70601be7f461e1cfaff6f19738ed13104e6d04a024db8f0db260fdbf994dfb2c03fe8ab16b198c84677b121027b203612bb1c19fc42d9cc9ae72b836bfa481598859385879093a9dadcc9011372ac5d8740c6e1a9e32b8fcdd6c002c428fc4e53d12991b372a8821a4f2ab01fc4d690d2c1b5ef01d3d676e9d887336490bfc8701a23708c0e0234c3dcd2ba267806137e4c4ff49f52b11560332fef661696be568400dbf2ff9f962e2b63ce4347c41aedfa6e43d0cc8a8fcf436a46646430f527e09761aeb6d97fd5023e980be1f3821ae452688de7f61b01644e141a1b25ed48ddb812f87af51a5c75641d84205b5461eb5d3d63d2d0c1977c929a27b7f9fc3dabab4ba933a73c3de2b4ff130c9cfdf06a0815b2d522dd03f5b6267d7fa5cc14529da8abe5018d957b55c325aa7c4a60f2895beba3da5bf97f661ae8abc7772d26ddcd3912fbc0e79606a2cab9540fecabde19c988ca991c9ed39a3b2fd3fef41be7975df435fdb43037f2af2d9537afacb9998cabc6c53487fd9257dfe3cd130b95ff540e7bd54a2574535a7348b084f67d24dd8db45c6d4c154d4d588e276c7153df43607b268206a70cf5c0d6c6cf42762f84cb25699de2b429ff5d897f17f1f96947d1dcd07b6f4831f8e31d6986dce261df54a186ccad4ddb4edb45a7a5b2432b92d1d8684cdfcfa65fb46eb2e49dae008ac933370320101b9847910645435393ae8c980f13e4a267f1ee84c76824b8ff18df4980862d3c81e1890bde11758f22ce05f4c2c6ea53b09d8d41e6dbfb7086c86aa6e7ed1c3e1134e580c574411a0f64a6f709f852a0c38a0425c1be513e00998c15a901e6319a5c58776c18def4306b86bf5dfc991c7ec9fc3e2f28bc944f6f0dc12692086bbc9d0283e9cd2688ca1c6a97f5b2cdc80afcaab380d634f09bb9d0f2eab87316e941c1889b14dd9ec1bf3fdce20490e0f4aaedad37dbd0eee9c63abcda9dfc651eda3b694f6385582a7ce041cf68fddf69e6c3cafad2285a5d31f7d6563c2156d735a2691e2020afdaf3c01146a773b01c591a3432abd5b49f332c4a13014ae929e9b4edb7f36964b764e4a63741fec7addfb1d6fed96b0c0e7af4ecffb15465dee8fb052a366372ab0a3f417ca6bf936ec0fdae895964248f5c75482e98d8c6a4f7dc0801accb94428be2657354d2c17052de5d6cf1ca8e9d80d9ea2a190713ce527e8acf7df980f2dbbd7bb531b25b2042747f03c6e47cb186c00531e9c98007b4f057387878456d526bf9427944cbf83a8ab28ed4e03938d83d4eff85494b3395a370e1cb7feb49beab7eacd448fae6d29a44848b19a54602c513a7942fb5ddde0b9df3b8ff682e92388b63093e36cc246d0fc46558c343ef7820c9f4b960d35fc8234db57b73041f9514fe4ea289cf5fe968b079b2041eda32298aa805b428ab1b32a70a5332c00df2c3c3e84b3fb1ec4272405fa8d4d9d2bb19059abf5334b2a179d695ba8f2c03e0ad600d2e9d027ecd471b832b3e864aea14d2e09e8524dd6a328684ee1fcdb39fab17797eedb53d2fb71e684e5ef6be1dc0c8797f68b4a8c2e05485061a75fa730f09ca07992b0f214a3e0cf446b53bf3749bd99aa8b21ea55b823614dbb845841626da918c89c5c40874f43693f930d646d74e7a83260050b3dd37bc9accf121078adce71c6b8662d863e831a00cce0cb2c08e9b80e4f85022bf6f4d008e13dd884bd49f4c9eb562b6f4bbfa8083e2b1c637b2590871fdd6eb54237987688728c6f234dc4aca9d3c0c25e382993adf1d2c3056ca3dbf74f08c0a5609c129c90c025784be84232974c40aa95540a96424894f3e28ddd39597a0a8e08bf16c23df204789783204b569673c8b431ebc92ce3f463b42f80385b019982387ccaa32fecfae71c4bde4b6a10aad60f252890fa4ac1582238797146207f0ef6c68d6e6db99a983c2267d4e8890da6a736afd271eb64c6bfc9bca762a7b4bb20f023b7a183ecb81f57b0301035bc392640481ec6948ba6ec984c9f041867dc40eb084a9199edc0862b1a5bfe95a81df32af6cff22fcb9ed28299b2a72c8bc681de1e9a5d07f39c966016bf870a1f98bacbe9d0fb38f7bd2f3086c784a19b55227acb613bf787c7acf2a068b555fe8959fec93dd1881216a466ed5deca3ea07b659d07fca96e0247f60eafd61c924b3251db3d5b3bcb980248c97aa6ed489465b007c8ec6e95014064ed08dbd3ac2c841e21d7459a97612b0358f15dfb94af87f9a6c534d8b597eba2c5a20dee1942c6821b63a60ff602bbadf2aadd98f0847d932550c99d1ac09b2a32ab1fa3dc2420f49ade37101035dfe2c098dc7e33649b6050fe9e46fd9c04f7d91612f6e4de39791479150232b6d4c18a2175c031fffe0e31997c532c30eb6a4ce1b679e4faf815d8319a40f1d19f72adb2e1f533eb250cf538900e337f14a4d8dbb656f97c5a7731cca6116449d939cf4503abc6e5c2285ee29b37b9329dd8639748ca9b8729aab41ff1fe415fc9ce40ec0576a15835ae37defd5c8357465a9ec0a7414ff31690b9035821bd82712941c82c3763dc62fa924d233c72f4b3b4dc19007f2d7776f44ffe0e3429a57e9a5d177d0f857b5dbd7e2dcabb812f7a710b2d7c0baad02fba43a9590d9c5aa11aa3c08c283efff3d9cf60d1eb26b8791e6dd976656675173325993ab9e0ddcee630d034b62055fc1c77b8f48194316da306059fcea41fccf5fec7078181c01fdbd29d870284f759047176e75e379797418f3dda88b723d58eee3e90fd4bc9ac727b3f42594205da9b5ebfa840b6db02b953c30ad76cf0eeed05e36f8e0a66cef39fceaddae7a3b57e7144dae9db433616b0bf5f85efd0f78aafab6f0f32773ba546ba1a15499a93ecd9f4540872e5dec587fb268915a56257f91d65be84cc2b400f294dc0533da8855477bb751b8b8df7027fc5b2405cd128ae724a263a9c5d5f9a49ae59c8b755bbed046bf3f708772192efebfb16626d6f3743ce760c9e4b3bef7b61326ccb3b3069c106c5c55fbad2a228539929ac82e218eb17829d803f877910c64821f49a581378b03cf68e0371a23794151980d5fd33d855e9f0b6b7e05b6a3d2e6df5deb8683336751305eadbaba7794aac53620ffff8e6ab69b5b07e79b51783439388f58fae4b6022f538dfeb70d002284d57efc3f74dd25a9e993504bd67d441bd87bae2b8edab21d857f0dd6ceb94c071223e83130e66b2804972828071f1ae433e989c6b0f7f59b3dc35bc7815cb62c4bf14d7186da8e117d9664b132500746c84da905002d5750227991e965c995c8dab3375ef03f4d98258463e00becd4fdce368604f88447f7eabba637ea0889134e8235e50c8b0918f5bfec75266a61734f8a0c759197a15783344d40fd825c604b5764ac0732da2d14e4747b891bf0ac6442bbd4131534aee589c97d08a340e7480e9bcca255af7f2f8640e899248241823fdbebf0077ec7bc39deee3eec13f9a0d068a16c6e451cb815b622f59e8fc29f16e7a28432769df7ef52a27f0c1faa2fbbdbb025d99056c1a857170de16c97296ffa2979e90bc41dad63a99f172497aecdbad285823035218980e82793de06dcb6bad294f00e77bfd0d3a96c33b80d27a078123e500355d01072f55b3b11ddf42243ec2bf42f64ec24f8d715037c861ed7c0a0bae6a04b612d7fdfa63770c122738e6c28b388c2c10bff55a99bef4eda96840ac2378f09e73ace54a2985b3db6f816fcb21c4262f7f3140bafdd59a5888d882fb8c6841cec99b9e1dca165a92a259284fc1f7f513de47c2e9c121422980c846faa5aa7545f324c6e65fcf0ef89817887157b48d820aac426ac87a1018cfea1e28b3c54b98ac088fff5f36448e43f873db868f3d484d0e2a8838e03e85d632667ef9b2892df7c699741dbf2e74ebeaee18222176600e04407404281508b15509239440386ae1a5feb83e0c205af3c8697c184994fab8c553fb78d0b39eb8f9706ad5aab4c74f278650c5ddd2a3a5c9233b7b8925cbb7ced671a919543bb902140b1db8af292eb5e551cb7211d700133f1859af51976006b46480c04585c537b15d424ab8a1f1b9c712e141b0b3c195029c9755e209369f671c75e3cd76eeaa91122a0d0d0e6812b84a03dc7902f3bed7183801871264c5c468f7dba89d5ba34b4afef4d8027f82d80c988e1de6d5cd2a8634d7b9e2daddf835cdc29e3dcb6bf208a9a9a7690e27f87a2dc661b8555880761cbd7ece868689e0277675d3a231e3a88aaa2e91d9d3fb760a3279955382128633f6a026bb0f778b1bc8fae7699a07e506ebf6b55e8926d9b378b274156caa531568e25d9e99bc2928ea591b6de442bb3778748bd811f8d478e31f491f0e40c95c86eec351af98b8f698718268e4e49e3113aae4f8966afdbf9544c433b4e3f408499803c389f0a994ec03f8f348fb5a54ee8b9a10049e1a4865254aea20d7ed5ed02d9d7cea6edfe333f2ca2334d1b025b062a11952cc6a927135a47ffff59ad5e42bcece5e8b614db6038278e88c4f539acff3b54b16de06a07d054f50fb68923aeb0e98ffa9cf775d2b6707a6ad461521f10e1177ae1ef1aa5289e43b98004f41ceec69835114e3bd3e818e2dc7cb03524a9e743c97543a4c184003e7b5e6aa8779a6b9cd36c92cb85b86a76111ae18130d318251831d8eb049cdbb4d8cdd80a11aacbd632a6648022af37a5f17c88482625cd928a716a53d25eba85c3e89d89f067a75970135247921e73b3e1785c43f06da26d7c2493bfa8ccb5304a2a46fa476c5e08d035551530f02e30da94b31fdaf728e0050379e64e08255931de606101c0fb0567d811d6857e33ba032740e9db6aae65a1bb16ab005e1d7dd190a4e1b1853d9344207bd15d21b0693cfc6de5215e5165e5d3cf0ad9adfac39fe9d6a158cf0618577a51f22a54edcffd375c24ba774fea30acafde808848b6191adc33f4e284d024dea7d985dd597d2992e3f75aa25ffc036f3773fd8af18019c3a5526aacb02e77a04e874797e01d5123e347263726ee58770f0c168f1eedea60d27c042f6342b28f031e0455c472fd765db5d3301420a7797a42fc3f2169df17968c0860fd021083c37577e4d74a455d0ee41ef005b354a126445988e3a1e4a137e0a1de32a5ea32b20b6322794c4802fd76092ee7a7237ed0df09bf09644355f2641ba0877d2c3cb2be4e2a3e0a9f6d7cafd15971d555fe64765eb8f5ddcac485f058e9f1d595f38f1661d7e4cb0fddff09a630e9d32be614782e4cfe551c543801eb6d27b9c3277ff8a4321f75cdc1200ee8a3286227f589b488ff9b1c94194107d904310a75235ac0bc0dbe1d6d354d81da64cafdc86d0a40d34bea53bf8fe28ff6290d843e3ed0b94138cc8d5044af31800b6b0d491fc076a2c5d921a7afd0b84518a8a332340324f780e6f2f1eb32e3d6a0489ea399af76dab752956f82e2ab917dc416c7e910fe095c8a8f8a12d21877066303f11f1f6e9628806a4e6ae58d03d67d97ac1a47fd75c2c1ad0984ed2810e2e992b59e920fb71d5af28e73e0a2e5629408a83c35a13a091809077fb73b6f78a289877d5177b484b80e06e61beb7ddf48615e079f19fc5270145639953e22074755a868fbb39b19d1f07f575b6c38b56ae2aa91b40742755c309ee41ead18340151ce05f6d9810fa1f5807","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
