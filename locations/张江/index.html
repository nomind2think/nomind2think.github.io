<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc84d001cc0324a5103c7fc353079e3040dc9b6ea6492db4fdf4bbe165935d62331cd532c963644e61b0d7850af2c1d5cf18eacdf3f8d79dbdd1db6dc82e64c91c93bb44530d433120dd7a9f511a05ea39d3466e1085e969c8c9f0e9747df2915e5b14516d06195d6ee800e5c0ffab5cfebea93be2f666244b46ed318bc7e5d028402f400047d677b8effe7f809056949ece593b63cf34ba4fdb6e66acfd373b9fa58a381dc8614c622c30692124dcb6da4ee5b416e1d17fab73f7adf46d2f8157d76fa1b5c0b0ea4bd911f84708f1c07bd6dd77ea9e170649bcf84c674fad26cfddb625aefd2dcce23f9a8abcc5689d5959f1e4cdb87060960d2d685dff52cc44885c59fc35fada1ece3fbd239bf2da7a8d7166c7c008eba288514695b64b33861d89c7307d685dcbf5dd7f7ac0c2d7aa2c5cb32f256595898c15893af7ea02720c96386f22ef976c0874285ffff3e12ab41ffe79b892416121ef1cef5484845350689fe31d29042d5ec579374c69d7a77966d47b3ca780e07f4339b7c26647e5e8361dbe289a873af91445eb132f9009b795dcf2b32df2565faa4673e970534a2f617a9f1d95b644c200991eeb8738369f2495d778e6f8b6cdd59a09d171a8039bddfc940af9420a1c7c5a41baa10f9dc155132345334323ed1a85541bd17b195a59318ff81448119ca83969fe0ea126107efba98b41c8a069ee18ef2487bad9c4d29f20de02d691630492c3c4ea70fccc359e5c2011343d7013976fc8e03775ff72a74b9ba5951a6282a038eb0a4590beac7c067c61692a70604f63f214181501dc36ff547fb36a9e4850aaba37a2cbf0b719ea909dccab597e565b32dd017a2641a6186c6be15fab74bcabbd60cbe664080eda50165f9caf90fb0c8de413ec27a01cc9473526f94a59b0efef3c15f95c82c19e901554ac67eacb282ac629f9266060a68000f3842fea489bce4c8dac785d31d9aaf00a6be1b87c4b2076e51353146d7c097a5f7abd95ade394354c0f2359ff9c8f38788360c1147877cbfdda7b87bd53e7e49b3f0c07e85092ab481caabfb78ada2b0bee6df71069ddf109e9d64a1f361bd35219365294d324222246fc802058ff932be460fc2d219f8193bd52f7d1a0eeeab97b2870048948dcf4b3f0fcaf1e4d9cd1ae01b68fec53f2a4a1b48db73c066420e8c7ff5b2aa98624c319c6986471895ec3620a179c8540096da2d7d4a723306fa06fb0754f6e196bc23919063659c11e594390d5665b90a5fbbece81ecaeb359d03aeefe27342dcfec82bdc68de258b5277402f967bfb6a17dc3ce92106d171a1860b504852fb950ce0622b907e07e68e8c937707b68e7d78df7bf923631b2c4831b8b654483e7fdcf90f32aad0c3bc9c7615f4df5f21c555f9f33c187c1a501b4b7c8cedb49ffd6ed6bf21981a1bc92ddd95706e6b170e2b930152441264d2acd1060fb75a8f685ffbdb336839d269ae3e1197f60ff11e382230c1d11a702dee2927fdc7024f9f2fc8169f7050f43ebbc0e90e8808c6a846ab1f5cf29e0df30f353c3e6971d78f9af9a746f88baa199875b98c99b5db6b69f547497efab93a48a39c22ee163f5ce832fcd9624ca4bb45d97c7c9c756bb87e2609c0c888cad017d1166adbca574b92a644c0426fc17c58760066484e54a36b56da06c2ef47242c713c107c775a019481019fad6ed68a454d10567322d1d6e67ab9bea3d9af3407d68a8b28f198277c0e3d4ed552a06e9bed747f9b31394c6c1658551c790cdc09af8464e73969a075050cea7f36ffe86cd2b353f6550173f35f3e6608d642ec9346a3a355a9506979df0c0ecc75135058234827b169d4117358db8cfeb13d8aa75b1c866ffb5719eb4af230203b8e0ca8b29dbba4ee98c91c7161d055a04d50bca16b8510d9fd9da218f1645772cade8af409e50fd17a74e1ca68e7773fda1a1a17a14060955232356cd563d5091b888490f54c1b9b5be31ba4e5b9992578843d3d7c4512daa2a4a9be222af8e66f071a74e2a466ec43fc6c6e2dfde8998f067ed274890aee6ef3f322f6491cfc55223abcd11319eca99e478a52872fb59323ada6e09e138113bf6638f9cf6b5619f8297dd8b2221545116a4dfc159c5a21ae24f3d4810ca1f86b0b7a072083b3701c4dffb8f70c72d43a8a093c828230904b31a974e0d2446833035f89ff2148bf069ae69025e117bbcde65d7e66c7b79acefb3e8efc95834077fe940bd2ecd73a0848306df523479f1f34cc4bf3e677d0fe6338f09fc66236c0226db8202b83e8434f87ba3fcacde4b7c86fd726d69ec54558b2045e53fcb28817b70390d2ede93e2f42b1a11f183ecf99ecd52aef21b281c6009403b94e07e39c972bbd6ac6302d352f7b485dc54f44666c53c8ebfe7b87577cca44a2abba83543449bf162d78ad0bd099fc0b3157b68518186623fb7d7b9db14059c10a35a187f0b36775bf5f13ebe44e28dc8df3f2fc66d4a02492268b6d25eb106fbe418d02e1b6ba762569e82d7609e79a641c172073a4ccdd10b0b747fdd7f85ff3c14843f98f08866b390ab50712cc3616a8cda6eff1a9f3f70e95b64c09f6c7d420f96f053f6d8ef343909ddc0e16d00e813075d5d18fff47c43970c92b83c4b73b5a6ba7c86900f898ddf8e742d1d39b0021b6d252c0517ad09b25ac40621b993ebf63e739e840c89e9a221a3ed9d8a0b9c5b3b13ed120d3ae2b556068175ee338d0024907f1836aeb8ebd2d00432750753f61e210c69998f2f5b3986727577185e4dd295a984fe4e0e9397ad279b08070a9df969043c66d1d766b9245c7a5b3aa8008d3286fbc3034457c591c258909c228f54d3e2fedaf2f526bac18bce5cb5fe12e34a7e87c95fff18bf3df54f9b37f4b2ea39e95d8925df4d5fc6fde67991930d1e7918ea68302409d6c596b2ef96be53362e360562e7e1f9ad20b0606729c80e2005ae316d7eb2f356e6a6761c097ce587948885a40eeab78ab7379b620a406eca739d0737b2666ceba12cc7b83705309baca51aabdb3aa3c67d68751f763d30ecd3fa8a68209985619aab8aac665a07fc19fc9eea42f2a370b75e55b7d8a90184a4003fea5be5714ede260d0df73fdb2879956f7c145d4b76ae3c3973e9f960e45afb77324e44839c2a0bf670a064cba397afc11d2553aee6dbd72f0fd6b34a2364577421b9fa0bd51b643d8baac2fe20e6bdf4b3763a0a99434ce3e62e02cfa54d9fb18f3154752e252bb9dad08b13921dff2b70caf0e4053a39ae056379c4d0b130c1f8e8b3fa757f66d06a5d32d6293991072857873f2e4270444fddf0d8146fd6e2ae2c98e00e78b432cb1b3aa13bedf709b61611f8b36ffeb93fa2a68c8efb226086a966db0602cd00fd34edfea666ad5b917e53549b6cea5428dcea334ae5ecb66612af5b15236845a958b3fdb99748d7fb271fd1b793350899df26f5ff488dbc0772d6c82d0d99c344e748a36806adfe542d3cac5d8df4449c80e7a21e3f78eb37a4bfefe2873d52bd9faf17cd205de00597f5063682460ca2c684f5974853c6f87f182a094f5457c334d9aa473cd5433b62f6b07d914090832ef2d5ff595fb360ef9e69144e091244ff9d308cd07af7ec047ea16a70699117db99b0f57c1e4b0c2b205056b20a31584062502568236a79fff76398fc2fab890ea3fc1f6fd0b61dc359d4e4869e4978ea18651f4c0264b97a3652a72ad4c4fb626ff365d57278a4ef86909f6c8dd7e57dc0579098292a5afece53aae793c6a23523cf11e4e60d0f29eb809bc3ddc27a2a5bf9c5e7b49681bc52fa8cd8a143a17ed53537462530f3bb742e27b56fcb08d21698d16220011b7bfee9d5cefbe0018df33fce02386088a6688b73d71820774f7989303fa80590ac3a11f85e4c3df100d06f3c1e672226a56505ceceae4b9eb835cb013b11609b1e1cef4396a4cd6188ce53ef037a5398ed5f109e1fc392375ec224a64ef3f5748395f805712ac591bcbb3137c8fe0da5e26fd46d4f75950098e4f90eee29cc3b79e95758d43060c4c01a9e3a7da53f20c204d346362a753004e7b9449863fd618547dd8c9a77c893950a0f75429c5a0ded3500a20d57b2cc79bb63c95f9c74241e5da1c77d7ac72bee002caa9a5c55826a874770fd354206471ce7f95ba9a9c59f428fe7abbd2458e7d730541ff0b88d977cfc2c904c5bf4663ed928ebf4364f66306aa53417974e03b113a7e8a1bf0ebf720d482ec9a52ad0e9380d0c5ba05d2354ae9f1230b34a542bc3db3b10e95b5f6e0f2467bc5a871b4c2a6521a1f6f7cfa959dcfbd616adbfeeea5d6a4f7e384b125a72a1d8c183a9d5292cf6c33e9bd0cd7c66bf051e641bfe13c3df278fe830a8c807e6341be2934fddefe22223cae486c25923778f5e22fc3a9e48a0cfadb94befbb78c3f9cd8377c0da65aff732772c1742a774db838bc98a893aca7c2bad210ab00dc85c806677bef76a2edf75856be47974878866058d992fc38310fd40dcfbf592cebd11ec55cdd9b4746826e0ea40530417c63592bc852bd1cc431909bc3ee5d6822892e3c07cd66787c8e0c97da6a9a94fda639d94242dbcce46faccc9e4638aa84cfe3acad92fb8978fcb7aeb58f01056d7249c0a7a0dd9f1020c7cf60bebb3c3de78f00b6c236165b16882b7cba036c1631a531c1992b1d767cd66f2c000b7818b127a434f628dbfcb470db17af4adbf92c9f6a49fa7e080a6d1077ffe805db54d7c852e2b1952b55fdc1e97e70294694f8b0a8ac4526f778c3c934079e6ccb564271704aaa2cf0bd28de8e6e5ae1ed52e8ff76e0661a82bbdabd7350f8c11b884e268148647dc1b92ed763ea7c3178df0893ba4039201c2abfc13447c9bbab52fe4340dba36eed494733064d8bf8d192ae7db1c1456ff3add964b19393a494ff24304937be9ece6bdc034642c64089c52873075a25112da50d34cae3bc5e4fa6e7ec7206c39f36f927db26570a211a1734b7c30ada68f63db9e0a1a6b797af256e8e58031d693ee65f9c24084db03ca9e848b3952c25294a3f303caf8bb39c1376a1663552228cfae3521bcb5d54ed1af45be419f62e8102ee50a53edae40fe4058a7a4587a1309e8c1bce95ae9d686d61176c1b548903a4ca2bff54c3c7dc70315ff33dd799e57a98f30ba31b9b4dacfe6b95e0a96e9d9742ce5aea2e80049f4e88215f111047730720b4622eb4634841bae2648b222963cf3cced232836a23ce7c0a28b0bf540422988c89a5d7888a18577401aaee8d30ed054e2667d859149f5f3b378123ebb1cae684eb47f95d6f870e5e2051a7e2b4a6e9b3a560774ced04493bd92584e2c85b0ab8df80034a5e1afba3d65a3f9d8d76af927df17febf0fd0359e2e6fcabcff4e8c9503b172e69b550133be22cbac154a90d60d84d0fe0266d3b5caa7771855f9757c8bb0de3f02ecee540da4bc6e6ac7cdf79230aa38a3920ed06e2b4c386cb020ad2815d59a3637ee5a128ed785d2d1c3444354e399afde22d07bedacec0e02b1a43b658486867d451eb2a332e4233b902f9e44a8cec153be5907370643dfb53faad7aaf325229dbc0ad550c51b0e11e8361448292c092918dcc5286a306fc505643ef1d7b95f010babe362db4dbcadaee131082ae514c07b5eaa23e2ef2bfba02a30a1789a97350d3866dd37d688d9976a8225434f8b71ebddf8799dc8ee7e8f4d1c23956ebe994418f774e0bb769b563239daaf3d434149ec6fd941555db9bc2fdfc71b4744fb9b93e6c4eac1c956b8c89c26f64a519f314781bbb303cfcfc6d39cb8b3d4d037420669dd882690def35e3dce7fffd65f61c1221b86350aab9b67712f454da4a4e2e83294dc406636d8b792cd6ac84c9d50c4f0f1a0952e15a7bd8e0c897a472797a9900d431fdcd534c11eacf86a48e27d8816dd1e53954ff46c14063b6594c22de2a18a7cad30693655c0f646d353523f67770c31575fda2ac5d828cfe3f4ad95682a85f8f556acfbc8af51143bca07925b3981ef364ee57ac9146fe09aee83c2987ee5eb37f25d9b500b2e6c94ec0e2bf8573b410cedc55fa23a2c542701fc6ae15725b2caf312026c362cdbbebf5df089dcdb49c153a5ece913e0d98ee8036c95093ee71ed828b48bd54fa5978bbd43d09ace884cbb67c4a9bc7c0ef153c69ba9b19a75005ce359e7ffb0aea1961f7af9b38c15e32586b2196b5d0582dbf98c73db463f306ffc63332e449a26cd323596ef33c24dfe11a6422794ade5692fbad2bb7bb764046f39a7735992d080e858a9318a642ddd1eff1364e9dee4b0a2dd3422e61a4d6907d851eaa1b7cb0655c8890f67b4f0f9496a7353697d6c6bc3d49907f068989db25b23dd93d249eef6b71ddbe8567c51fe70a27429b78861d421947b56be4cdf221c079e099fcb4039b2649f03751f30197bf96a270af5f67787938970e8cd1c221cc3d0ba7ca96de321ce5c1314bbc2b256fd8ddde1016ad0bd29148b0362b8aadca49ff765e4b72ed904e03468ce2f9b309b991318551dc12d69b7faef5f377ff59dcb7713f2857790f73b49245a3e8194872a64455be3fc0b7432d58703bb9d2c8cbbda5eadf62172d05523503bf67f68003fb85ca13e1dfe00eca666888bb30957bdb656730a214364a6429f06413e8f41803b9c077545fa1f04e1a5bafe516a59982bfaa4e486912b4cb49bcad3ac03bad5dde98695b76fc466f293e83e72ed55b662655f84016897c9941f659c0c217c1f18db4505c4933bf3874178391382ca73aa684400190d3b7bea26da8c5b94c9034f31416d5ae847a2674e5bcb96af33ccac7d994b56288f3c28290fca27aa1ddea83f5d243ec2babbadedef45df21ffb0fce9a61db1c3ec074edb43a733afb200f096d5959e7e476b80d946e194668e567e37d482d140740acbee90200b2e274c5a8fa0ae6624dbd9cc2ceea7b505430ea274e8e1dd90cb40000e144edd1799ada9bb914b307ad662066151ec2529aac80b098b17da7526e76b84da5008ca5a0ae7c48961a116b2f063a9652b119a04bf6053cd561db86b2656d06e26d3b43818d632686a13a1d8548af0f080decc1e000d06d04c21483cb84c7e548a2b69b9e0d11662d6b910b627065f11620395658ddb87818147611a8a0fba3981fa1e5e90ce8171636dda2db267240e15665948562c84c729e6f5b7ccd8f60266534147b9f8bdff5d0b8264cd3cdcdd439f453ccbf4140f2232a01544df59ed5c2a77d8a97029c2fbb94b6b9f5bdd4371673236329988cbad6af0d149a0246717d21abe34be39c9b4584c2a8a4750ce57c1135b608720b9d2e20825b400f3b73de7792f2d468263b45024d03a83d7c0f28285d87459e568a58fccb130a9cd3394ab660b5bd970aed006f780d5b6215905813e07200efb5572a6dd6ac75adc3f0e78ac9c3da19802a6db0461d6c0f6ff5f79738de5e8ea81ab40b7c827c5b5bd1b474dd11df62dbd5b009839ba784bff3de16c6494964b5c2b1220ddb8729b81d968ab140a93a9c65cfc038d86234b0bbacdd1929e998abf397b11cb0f5257bbc06a053b9e40467a1bb3cc626d6bf9a0353d453c93885d8f814531eed5adae11f6a180d79e648eca79e7530a88fafd623c398bb1ff7032a5ddcb30ce55353c0f2be7a868bc4ed4bce5d771de7a977e30577c36bb69116acd53d2e6af2bdf482ec861a9b2ed153eedaa49b8b6d1b66bad331a916c037f1cef36c853f431591e2b51b81b9e5a39c163eb5caa4bddb481d2c827e8f994af7fda529ff5ea0e81b0158e584174441d8dbd2e0cdd1a8db06d0f35cd55f25e265b4770d043ca694d59f78aac689da3926a9d2a354acced44ba0b8a165d6155a2a6fbb2cc8eecec356a1a74742f2518aa7019019ad58c7c008dd9b5ca6ee8b2e99401f24382968a1d38019a39a278e7f66ea5cc7dad774e5fd5b5fb86a9b7cd9922e348007945e416c15c4abddbe9b7fee66ea1fce9819c8579014076f7b31b942a08aaad04a3abe8d57638cfead591a7108331f8575f2e561e3deb60555156abd07eb9c051c09ae84a759d67511723bb514e4399500416333e5ca92da31660ab162340b4cb883db0c778918cd9d60a34ddcc688c340a58138061456812bd332b18dccb0f62c81455f89ad1cb42a7ab35dde14b347abbb0d0195b3dd44710ede0d5cac7fe436c463de1407fcda1ad099cc46623c3848289db955f34cd6055fe829e5a176a7141509f16b169e61823fb55514428257e9215a7d9566cd6018852f56e80fc855b6134017c5dfe13c21e208d527c11c7d9018ef3be56f1cd99f8a816f9c8dd272c524c05371ceb076c2b9c8487bcb73b02e8bc9712a22dd47eddae6310676dfb5469469cc2dafe92c6a0154dd97aec388b829a6d88a46b8684935392aef89a69f29d297308d6e95487b5644f6c5f8fbecfbd9edb067db4fc0ce8d87dd701b4207a16b77e182a01248738a0649c6691a9a569eecc463c72025b1409d5c76c1133b326cc137570a9ba241b4c23cbb0f50c762beea4d13a5fc059f9d3e280889ddd530c6f7f177ef8599eef9ada95d5d0cc2eefa168df7c7c8a021697895959ab14b9f01f4add337c78734fd7a7bfbcb4b74d87d5b68357c104238270988a898a2ed9ffa4af007688a17679c0e71810ddaf550f23415d3b1ecbd873a6c60d0581368b8c45f6f2fdc3efd356f00a91e55d1efb03a523a40bfe63cf9d579a1e4f3d0b6adb4e34fe7c9b0498b9d79d07629529020255ccc92428d4d0425ce16e1d4e606aaf32b921dc2bb0669aed8092f31fe824eb64e53cf09ac7f005cce743443d24255a797788f8481a3de8a640a164a37b4aa2db78292bd94a540dd5b3653034feee079b7bd7322c17a3b1dfed685a3463447ce4924da1511bff1901053a3506a023a6306d70ed701e42903951b4ddfa37126e5d629baa9a0993c9b01356c1417fdc48d792555666d9b4814c726f2fc5266007a5a28faa49809d81f3353cbe56418e2b253077de0b6cf80ece8ebdd7c98602faa8ba8daf67e29458e3c82c6c548f85cd5be5aca84382f6664e4a5b41bbd3864a4b0099f76ef04f2004b44f38e5f959f1ae10721c0f7d478995bd281b5a5641d435782644c0b6b21f21df6eab26c06ea1b989f992d884475b98c1649b152e9925ca6e3bd90813ce158f4afab6fa0a0a69eb876472299511800516212ab19034bd4f9636d5b77566a61950fcae26f3a360fd4bfb5ff2350dcefc0918c0d1c6ddc82d3d674ff0ce07153f1a81611168765c326031a30bee7e5a1cd566ad8d8d64d93587eefe7f39e4dd349146b925891bcec690f2dd665b15ab3318dc1cbe01a894939435015f72c89091ded72684617d4d2b494e0710f5b2d011bf0f7067318667638fca2511011becb87c8eaddc778e2fb2dbc17dc98de4a233382c0e8aee2b4a77b359f91b960231826cb271c8142e9c52fb819be8f405a9ddbca02391718ad121b5a997dba8ee84b3eaee1ee4e344e19f033c2f116bb38b873a27068b4c95f5cd1e59c2759e048c9b4d7c6a9163c6d6e2a5523090cdb7841be2e425eeee51d7b7733d1d54bad3c33768d2af04ece3efe8f9ff5398648bc8db34924a57a83d4eeb17367f83241e776fc4b91904c46945deeb96d23592f78b6032f5f3efaac3cc071a13b735b08afc83a238d8cd94f3d1e619a22fcdef8bca87c4250f9696b49e22bac7779b7b7066b25feffbc2d7cbbdf374b54b4167fd0077803db85b1478aa13aa9d95cba49a4947b559d86bf7bca91142816ea77edb46ac59e1b26a18fd830969b764bdb9beb8b7f13e174f25993ecc7c9ac95e23574452a98cf2429d100ab5f17e31d82efc724e304e4c1e996a725d0c71967cb61389dde6219bf29ee5b362535c3d08791361eb3b8264aeb275933577cc3e5ec13fca1492c3124a7e1a5d1f1640a9036336a94e24acf6575158d3fe840bb82e2f2172f1407c7989b8bb879da4f0f354817a9b5822bbf27862097ed074bc7d674dbdc078f9e389c3f5f9ffd5e03d64d01bd58643fb03ff748aed7ef62185c78dc29401235d94001f6aae26c8f46fda53de971a84c525f3ca963543de58a10b7d9bd74bbce64dad5ff404057bae0c5c4b7455cbfedbdf3bac5d772d9dccd1eb45013e0bf852b1b281b6d7c06ce2641941e74025fba1e3682d17e60fa0bff5a3ec1ca8b5d68cc8aecc35b29fa712f32493d65cfb515e254d544b749162eda7d6dcdb3af908cc12ff44fe9fde4604fb54b23288e9f8d1c38d8f54d0e744c2ef95c6e293a1e9eaf9608324be12c59d3f2b6a8adf023dd90f70d4933648566be3e8c0815a1362fe920dbcb02584926ebcfbfb5699910142e5865f58c33abed717806fc464145cf73bcf388dc9ed2f206f314b9974dd9836d9a625ee143a0a77cae1407b468e7f74c950f66fcfd3ff0b07fa7d661c4512a0098cb3af99e1187e87e1bd8a01ffe152269df3ef7c364f375d5cf8b43921b7383834642dd14d4bc6341cddc6e1dc4532bb8e1b6c57c7246ed8c30e93ff2320b64ee365cece12434c698b271099ea2cc0a0a40be7d867db3e0d8458aec22cd02530effe95196fad409c16c677d300dc224959cb8588cf2d487864c26259c0a893ac88d3a052f958ee964574a479c2e8d23c6e24c02bc32a522df0bdd0d7afcf2a0c3c1d2a6e0697ec0ef060b84829d29deab4fbfd99734d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
