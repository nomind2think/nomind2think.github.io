<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b47abdc28b86716beeed9d6f63577f5668a18e3130076c52fce96f6462d65b4a835172a5fdcc41756f78099ae782737266f43c6f85a0daf22cc63e9769c5703f1343ebbdd3dfbd1b0b62e50f4a7e2b72aa379ecf07c445e4d94c86d8cf917616997ac9675ee3d804e95f5e0d773441bddd3f7f29cba4c3f368efe8548d6bebd37e658f0056f1515808b21fdf23b96664214b962aa51a7ccc33603de3f59a682148cef2ea584eb4c9f6bd37bbeca42483e57277ab12e8a5b964e8d7048bb1bdbd601fb4f36e5dcfc66e548c2f22461776f0434e04deb773a4adc7b4e4269eb041a9d2afa3291f265fcb40e6e386ab22a4290991fa8b5b3f34f4ffb64a8a1dce619a46290adca871de6b18041a86c3cf8fffea2af9f7b7b19427542ac3b9bd90651d5afe55ccc7057e878f9d507087f7a6861a2a4be3afb9e99065a1be337fb43aed75594ba59f060956db75453de4bac3f05fbcc0e85271f43b7daead9f5f359cef062909d54cdf073617da77ce8b04b71ba90e013786f0776e4bb906c187f5aa10353b5fcd1ebfea1b69a52377c3f9273460e84c5ecd254f2637495013ae0e37525c051659a14c516f80b27edceacba1f756e9c1b1cadfe990670aa4a5fb7f037947988ef5671fc5a606dec6c17cc5e822b823550324ede5f98b096fe11a862e4d5e0a47104516422181ebc85a36185f51dc262b511dfd67216322a510613de44a5f4008b1c9773c6c633f6ccc93f4d66ead986ef07f600e608982e1ad1ea6aaacf9ef5ec9c2c1a58d70bf5916f2357087474fb60f4caacfeef13d9b0181ccc065d0460d273f9d3187ab4941655eb7666bde28d0cbefc71773cc6a19bce4d6168eba6611f030da45a631a152208e34b6fb0ce3ac28c0f7612be28078df3fd12fe83f10cbecca71dd65bc4b0b975442d139cd185206be3521a370d2921c68a343c65bea941b11d3d10e0a82fe4bf30a207ebcfad277ded054ad4ee3c2fe9a3485e48249af4b89501927645577c9953d41ba2ff9a896a6ed7f78081e9be238b22dea0a3ca6396ce1565720112aafb28edb29286dc7748571110d028d17195b511f277c88a78fc49f87f82ce5c784633d7a06f8db3d5805210bd53f852529526a8d661f329c4c470651fa29c99c93e6012f97a00ae64357e94b5c660b488398b3b99ccc9871a479bd1a9c9cc02713fe62c70c28ccc49c0bd2851e9229e06fc5c649c1c6e5564e171ba061f24c63b5af268a8315df2294afc0b2606adf31c744eafad906b13c009ba9a665bcf2bd3a3323e91dd5ecde74a79a8f521cdca3473cb53380e5792d4e381204bd2206c31c6c8ad25469a49d711de3bb3b07c6ab918a9e47b02586302cdaa8f28db70abc68d657c7f6b8395fb0245f01ba859d65fca1734ff05c9349fd2bb19f9bf985b9d63d66f46fbb7ac798ddf93b534a19ce2275c70c0ff67adaeb8dee4dc982ec6c40e4c8ba931c0281ca97cf105631c993ee4e9bdca7e7541e7268cd0cc4afda00d3687081ab548dbe0d11fc0a5bfb13215160132b03204e3a8f59b26a57cccb4f47c8585a9fcac11f301ff66101855853114c6950fd5e986671c825ef07d43366e7a4f5e8479074fb651c4125f692805587a19180ee8aa64e893083d1e949c82d14d7afbce03980e689076fa4c517159109f486ab1523c1f031853fe0595031b9968f585117974b7dcdf63e5b4fd9c8e7acaeac94deb223b0701531fcd9e7936f0b4a778d00c433f6988caf69a1c66900456bf8ae75b6e8bd06d65be3fc8047fdf26c54144409e1e19f2e2d5df2ca774800a168f113108dc5a3ede3b41ce96cb49f477e07041f431e57b01a41af663b027ca61de1a1dcb80b2411b10dda2849bbe0e186a41d8c00a5499dcfe30aa08db22d8c2fad24a649e061ad2f04a956ff9d725120ef8d573ab47874dd473cf473a886946bf32f51a73472f8b2aec560442440c0fd861c800de3a745cd6212e6033f5afcee2fab312c741865832d8199c86e97c19dfaae26bd5f5112b402df80170539f420ae8528ef5bb827e9b44a4d073c869c87fe34dcac0a93cb7438687dbe0d0a8d960abde6a1e457694a387666892ff9924fe55942701e79077ab407aa13dd400568da3df4c8c18a4d73e0e694b74cbfaaf02c3d5dac89b011b3555434233e4d1d981294070b3283cbaa27ef1823184879f50ecb9d671adaaa1580ffdfcac1f499fa2c2cbdb9ef54bef44eb2cbcfeec98be4214b1a4fc744e6fb0b1d335208d8579559df868cd6442b5a54781c23526294f8475126b618e7ca7d9b267e6c4132b6ff57cb9f5e70cf42a90b04ad5a751d01e39788232430f1675a0d94c65cbc952ed089c1e0c626944b81886e5440c1b4d1616637f95581c9d043f2ac4e58d13fee5823573b10558c4ae4880f8c5c3b30dacc8ab8d7e98a219d952d97c6ea94dd4e91220b2edbfdf29021640ab900469f633f528221b88b7686ec7dad4539a6302a61d4bebbbbe5d048392fd6478a67e470a1076be642d19400b4aa17e8a3a811425eb8ac0bff2456ca3041b25cfa44f1aa0e30428a76cc9145cae516a61c9c1482a8c2548d472b5354de5edf0888447b11b648f07b4b4dfb18deb0f283e1d4e82669e1b4c12eb9b0e76a3d168637b8ae4972966b7acb4fcce5f7054054368ab5113d6c8d6c5f0529e6f6ecebdc410c3d252bc3d215000999a23bad2fea4cee306629bad6ca4b10d831bedaa249fbb55cf099dd9954e87b65d73067f53f3295288355c303309ed7710f0472fb611d59e5ffb2648f03174818fe01371d19361bb22a3bebc482e3bb9cf4c7d55302f150cac2bf6a3d2eccd6d992ebd5d9699c0395be3c4c4f205495a79910238fa7ea4d1cfe51b5f7281222010fd9d1333e1e88fa8032d8212bc977df58c40a0f25f72441923a1a318ced5583d389170dfbbc72aebfa53a2e34619647c7fa3b998dc12ef721174fb09f7c89ec5760be25787521d617d4de0018f6048cee53591217434fc99a388fcdc999aeb1b8e1f40a6d849cc5c58058f5a7e88a1c060018b92ca79f92f3a30c0c4900971e0d09afecfb8823ca0bebfc4b13b2f36cca00c8a1d86c0004bd66e82f4d00a2ffa5d488f7fe5f72348744a74b9c7fd10966eab7dabd18ccc18b122efa1300d66916af6d17ae47f50e3c6d9185034e80255a917c07a511b25f8d4e898dab1a4ff9c4ea544e760a08ca411f0965c2eecec18191ab599ce627da1c264b715a89b814e4043f6fd6e38dcfedeba0bb0ec3fc9ca2ecff9b47444d8f6ddfab26aeadf2465c498775c54dcafc185edddac42726cbf0dbb422346d22394998a8dd7f86f5a613f3fde4a13f788d1c44da69c5b71d92cd5753f827a429ffb4a10730406101b557056b8d8ded22212a43c9a66883b68cd07f99fbb2573c3bbb79b343b98bbbff1e57a5377970d3e89cced3985688229f301797362790f69e63061d6c19be3c8a1044fa4fcc5e6673f8d9c3bc33e0bd8d2f7b808b068aa7dded4be643c3c7bcf6d377f4b13904df54e4725e6fddfed52fc27fc85b25b7baf11dbb6cc4bb84c5c17eb167fafc4884b9c352508d5b10da405005d01aca44c3d62d1fb7298729c36bb00e7e7d8af4c4d338fc209179f67a92c5760212d578c03803c2521408c701f6e38b5807ec054ecc83aadd38d35d5a200bb96b9154cff6d66d996a026ca550d03cf12566f36e853f0239182426a5391c022625ba4253926eaa3418a50884183600e3e3d49f9198ce6ce993f0c26288c41ee731ecd6be1ae4166a00e99b80f464ccfda57dbbda515a702cb0f882101ae09cc364bcf3ea75c9264c7f17e5a7ad3a21c18f29f97a9474e62140bcd3efdd05e84338c794cbf5060b2c0a9f51285c9f50e3afdfca71e8bfcd311ddef0c3cf59769721035b52c21cf7727c0154f9d048b82eb419c06264774502544a8efbc1517b9962af5fc278fa180e8c1f3e8cfd7703b44cd36434d3c9cf4abc1544f22e4fbe2b57b697652628c7d17ce67e397fad0b18d92a26c4f65695ce4268ec82dd31a31983b09692722c04eccb22f410c61b67934f7d58f9ac11b09520fbcac501dfac196d7d65074953d2fa2388a76dcc21cfd59bf6eccdd7afce9a73dbd901d2ccf3bc0d5aff1e90d269a7f7ae42b86035af503a15af41b60ad6b54eff4e26d9f1cda646ae305782d279819e2748e78b020107392072773abb7f12dda7359aacee50c1bc5be6acdaf3ac3ea299a8c1b896976a15592202b3bdb0013d1d8ebb8da335ec5b592f82ad9ff0ae06571ccdc8923fa42dbdb57fa32df6f80b459c2c98461ef0475fd7547e5ed2dcf168c8db1f080b2e9c540e3e932ec297f8f25464530f5969414fa436a435910b13d68989b179a09f77f58f6d09a4111553671a4c74a614045936503a5eb3298d20d7ee8c444f59f55c7be7bbeacbba40e716e4031f8d65c1f20b38ad37e92032ee496a613091f41588f6a38b524bd78d7fb769e0b917ac791b3441f24a19cb093498c8a5a5b47be253f12c1a09577193cbfa0c98ee9c1b5f448e43181507f6094b39d474dc8b108b2b388884ace31f686da7d90c107ddd5cc570e7b5f7af71b9a5896dc4d29ad28a229dedf04ac0f1b9064155b313878ea060b1e4068bbbb994a992c5ffdb005b70b2d7c2e01e11db0ea994d05134c5d4603731f14255c1d7139cf1742200698aa50d339caa3411da4685349ab7a2fa73b8064af2772b594c9925cce7392f33e92888b23b20272e8371e7262620629c744bd605d69a024b404c4858591221e451b566dd323db63ae02685beeaa096f7da0ee36c171f395befd8eeb2584ea6531e528db32b0c18086e6494c9413b6e914d4530b701d8f398735badbad83ed9e2e385b7aba530f37472d490e28133b6a28c30bbae85b0d0a8a5f7482f13259cabdd1440dfd7c2d1d5f3df80486df1e15548c5a297bd1cbda02cff8b2742b8bea3bd726809651f7d617ed4c083145129ea7d6e60575990451eeabbdda8a892392bf8691d62af014dedfd441c78ac7fa300bbbcfadec93e29766bf25a5987d03c484f84f7840d4c8e583b588f889286482027b248d7f613fa63b243e5372723d4ea86129b4ac95258ca1e485afeaf9a1f3d5245d65884b1893d0b70d765b2a35249744a15a21ad809f15c98cb2252414fe8e1c2c6b5c1db753690d0762f0217cabeb8bf7ba632f840e67bf2c6198fde853926ebaafb1e6cc46089b4d8607cd2728acc72712c53797de764f8144746e506455d65ad41a109365c8eed0abbbc231d0b4a558b1884387052fabff6897ae02f0e7990b3b823282d3c4a1a95aa9d5b650473d26361100ef0a903badeaf5d1b3200cc4d1203f8fdf281b08c064108b3c04ecd5fb3cbc8c1f92264361e0141260540147fdfc323e6122bb4163099512cd5e4d52afe5f8904bc263194bf963584727077c07a5e9b948450f409fd6def0eb619e8e6bc55d3c7fdbf726099f93feb9776222d3ea81c058a24a2447709acc7af87efc430831cfa39e935f0fd0e4344802b416ae089d9a8be3cb3c04131bec75181590cd3102930099a23ae22c84ad5c10b2bbfb6c79589de0972dd896ef391864d78787d9aa6ddd7dac56fd3291648bb0c9b763432aa90ab11612efca1a8f38a9e2efdacf68ced0fbe493159aef33013bbc7e33d5fb62db1f9728ae2c2c2633ad694580948fecbf99b9ef0c9a3216336e24425983faa207f2cc8e92bec09925369cca84f2fb7f9c7e122fbacacc30eae5615556306e9690042768f1162bc4fc329d339650d765bb4d38e4b2242b3ca2e1a5a48c3c74560b80575b62a278eb6c095992aa67de79f40ba5167068074a80a2a4175ec9697e36f67ab07ab3bb6e0803dc31c6cde8ca36b7769ddd35c5243b7894c9d6b3815c78b6f4bad9cb00e08ca8577e2c7a60377f2f1e2a82477ef4b3988aadcc125023fd8641c8c13025938f9e28dbe049f9cc97c2c757e5f733b2adfe785c7d0762710c26e851bbfbddf60fa424e42d1b8144d9b109f3d6b7c5d4149033e12d8911ae93d503bcc2e3d5b4317098f2e76aaab5e9c521c9aebe4c9768a296c81413800956f32db5b69058044b087f2cf88af810009c22920257214ff428bba281cfe577631cccb570f12d87d3893e7a493f6ad3a74716ceb0c67be7446298453866450c83d364b224545425c2b6aca442da957aa7cdc328386946273e0fea730d54ae97f58e75c641b7f0d3c8e84e257851c5517f0c6336bba1e1795a50dd18c34ab7fcf7a893c2db246fd1467487d0147c69e292d9e3bce687585a5ed4bead187ff56d8f7553713a2ecba6fa55e91e4d22772bcbabadf0b79d3ae131a86f1b87c9d8a2c3fde70355d4c882605f30872d409520ab58601cd951e18b754772344916a5aebe213b12b8375407a3df74142eed294ced222fe1003411fb5afbb0629bffa12dd20ce7418f034fdcde4000b840341696fee11e515f8f871ea001377cbcec92304b9b898ad9ab407d5f358dc59045b277920275895a600966c9907234ac9ce39694e9ab8a28870e0c7bc15ec446f95aaa2fc0d1bfc2b659a4833d36d4f39eef5c96ddd572ca55a62d2c818c152ecd83063b1b99f12f05d12b468239924c36567c546fed1a5a283b83f5901b1edaf0644dcab2aa58ec692bac157567874896d8e47e46b8c27d241beb4af9169444570ecbcb08289cf95f5ad78e686ec9cfeb6aca7c08afcfcbbf32eceba1bf35f949060d86c35e88824f928fef1e3c216b453826a87326e3cec94d3d2a71e0ccd5a83c2caad8fc591c79bae2bbdc90099426ebb1cababc9bfdec6b97793e76ecfda1fad59b3c86684149a790f57bcf0ee288ca06acaa664f540f1fa1f794a8ff726e267057e22a74292787ad2513b0e4b87e9190c87fccd43fd69b8794dd1ae2e61a110b7ab326b0fbdadb7856b50560c14777811f0aae0141f22a396efbfd534221a0874e50a9761db5f57d225fdc4bc71e04fb5425feb0eec21ebf86b2d8361f11026cf30fd39b12ff92b10061f303990a5e145e6e347cbfa35d5454969b81915833673749e48c93c58e1fda76d9b7eb67ef7001a5d881f78eb26f0104d1995652a98cac82255ed93fa0fbeadced738f0bb6897e0c225168c63d632facc903826982f4db2110487f58882e995b5f23cebfb455701db30a8acd0fe335024c983d659262d189981893acf58b4f8689bc47106669fc6a36c80ca9cb2cf1478795902eb985189bf919bc90e8cab26f324437dfb481e697ed6485c4684352e5ef6d7023df80b146550c66c4e6467c39daa49b6358f060a338d9e6abca6e291a7dab5d34e95de28e5c8945da29e626ce6cd865b978880272646ebc4664182ae86c043919787db9b95202fac26464356ded3f03085f783d98c83d3dfdbce3c5bcd5a88738f22680c85370a1b172b2dc09e096393fb2da7119a49ea29663541b5720e51a2aaa72738a0130c886cf2afb48715f8ffa91089de844e8ca38f184a14fc2b5656c7ebd8ff6493d66323e0bf96ca7adb184bd911e4f1bd0b97ac575394c2427a3e255449e19c44708a8241e36015fdb92ed97463363b03dee1d25ae71e605d1fcf52da6a53c55df15e28037620f375805a280bbd8d04fccc70c02593154452df62390cdedef64bd4cab447c768d9889887c0a15e42706c3a37b7603b8a8029ab6ec4231805e651edca33c7b2ef7b9c20bc9a68b9602338e11b02066b1995d1af2e965cb9e7b7168c227cb839d411d13f456d0630667a6bda89e98d1166bbfca4919f75dca22c77d3ed86f40cbf0dcdb5f0b3d633981804bc52b7ad069f7f7c6c7b8ed3888000bf9e596f28bfda7f1d28fc6a96ed3b3b55827292c2319e4ba68d3f37b4ec8691112a813aa9e66669801b38f46285a17e7b4e93106cb063aa9927fbcc39a726fc9ba4f92a8e0e31fe24a44a0300d8a29f162665192742b0df8b913016f9491d4d46d93a6c1b6a8a4a69ba40b96de65e8c5c1c3bb5f2bbc7add060da27993b8dc41eba525659255d18ae97a6c46b5b5a30c307bc6ad3b556f7e9f00e30bc2f0d1364d16f9cd77763aacbde6baaf0e44983e96e0df1586ae31d47e0a17b222afa94fc8f399e60a190fb9498862ce1eaf3842cd95ad858accfb98ba52a405a688256e74625be20975fe1a8204650c0fc6fb4dc548678289c107ebd90adcad663c663f7c093f66aa0cbc99f7acdb1ca5086cc3e231426f451e70b4579c1a4e2fab80ae4883b48653334f84fc63f25268174939a111bd091e2f593c8839d0b5771cd206df2592d1a6b56d10fe625a82f2227a3daf30b5450186f8aff0256401ad499b1c4b66ffd6333c0d347cb6d3878d7268d132b257fca2a9741ca4b47443cd1a9b244e13c8b147448329feeed2e842fa80c93de915c1204e5b060e10efa8f79b12bcc320d435257a52baaa0f3232617706dc7c56656f8513f1e948a8ee234ebd7c4e4790e9c4bc304d217815f2c7f441e0e4a5b624a386582c996ee31bfa8a413c2eaa25fc1fb3616f72305ad32d5cfb96cc3dd85a5bf5afe2ac7bf51a60aafb222f9aec38e40813d9aa381a9a666791af1b585909c6339852553adfbbc855e61181caf07c288e3940bb9c99e00b2cf2ac86e647e053e56769c960f2675a476845b61a3d4d0dca1d373adacf4728a65ec14226bb302ccb4de640f9221a3e92833fd213919395405c687cb98e5e10cd6d46378ad52d5bf743ab7d95f9f2a13188c743c1234443fcd8215dc80cbd00a8ebc2859f61451f6503c5f4286bcdefce9da5e86fd266b91fb47c2c3f76ec934d5b350f8e0b280fb437297c8440754d346933023ece688ab973340cd3f10d5ed5546e9daeb943a0991d9880b1621a0c3b409c609f3674fde1acbb35d620eeba4a3122b2d8fdd5b9e625f6929cc8698eeb9f3be6ba429cdcfbc43b03d26dcc84fc8cb42d9fd4f5793c0d1dd0a22ebd0adbb4cec477bc688488dd138a73712bd6600bfb98891da88c74c02e353097b4bb6d465c65db821ad933fc359d2f55c419422ab16bc5bd4c51b2d4025337a7db36022b53e271715ef7e169fa14f77418ea9120952267d5c1ddde9d9b92cf72b69836ccda46de3e94c37855e7909e74977a2e1e9945f865b9088c4e950b2a34ed38840fbee9892f7c3671db9a1f8efbcd279a9b3b0f25fbaa427003360c0bddb3bca976584e88f5f96f455a5172a40efe49b807bbdb423398a5dad985b16953c1214c68f851966127af294a11970f6daeb735fe7db59bcc1afcdce336fd47686542242c33d21c40afd86cb8b93c5a6bf06cb4c83684a8319c0015e3faf875596f51888d1be12125d13d2be864d62e8edff002f6056b3d2d16870b2331ad774c885f0a9037924a72c438a10b1623ab3f4dc5948535e6eb2b81e976a58202adef8da4b1c9408efb5d15d61cdc5e6fa12e46e9699cb7213d570fad7087c8024d389f5554f08524988f67c6c130a95be97faf2fbcf51cc9cb98ffd76e85795979cf81066d22a7267186a1a111420cba95dd0ffae8845187ba71b992b320ed93e6742f74e7cb14dafb05cb32ed0309d41d00f4e309ce254189a2f43566d9e81fb147e161ce56b622dd43ea02705fe4930636ecb6276c1606fcc1bd1c53184c99de4127104ae1e56b21dc848d4ce5fba613a6d7aace439a0a01a9d7c9970406337b081e1db3dd3cdeb0a6ef29075136525fa4cbd0b0f8b4a64250c6746747e17b63a06c62ab63707aa15f59816d8f886bf7c8939b8de5cf7e64b3e645968a55412ebe04a030a7b1ae9374997c2367d43577d3642208b7aa864db5f8479d907b446b40485d5cbd5e4e759ad55c518af894c467fb819d15d2ab91af3e5df5a4135f9289fb0dfd03cd16cc8ec72f78f73c5fcb0bcf531dfe868333d0da91f8cdca461f0c26f2d965bd7696430333f6fbf3b723719ec62a8d1d0c77d37451bef9c4cbe2a7ac3df8cd34d25a0813dc4801a9bda530fc0dbbf35b235482db463f10aa8a16578179a71bd052f44eff89ba7b01628206bdf145f8d12ef06a6116484651dc102f68a2fe4bc214a49d9374c2581d6133535adbe710efcb6d031a6a8050af977ab09a2f92aa1aa59806c2d766b836cf19c9262e88353535f848a397a47140e704b7757c569dda6648817ddeb8019c99c68a47549e0c532b035bfc766d520010a81cb27b746de46c173e7a4e832feb2184bd93285409908bbfa5adf5f1c5ccad0643f2cd5231c26376b17397c512f01e41957dddd5cc00578e0f0b3562b10e893330f0fc80dd5f650b34c64d036b13a94266d25f2bdd2eb99064e0d216c781479bd3bd7ba3e65996d96d0953a78f6788dbc5689957c24169b10a351dd6218a99e9122a8dada73dcb9e763dad6c8f019e7515354bffef82e03340065b0faa161b9cd953f267c275151226550d984da04efc0717e3f08e42ab0f684144085b17d44f6cfe755438185d2639628c5bbd326845195a83443f638e4578bc63e98a8e28c7464db42ec2d0cfb0b890fb2a2d52af9be9d73dae8cd04a72e14916c47eb67ef69fd628cdb3a358df88a766f28d4acb144454ec255036487042f6066f2b2e68ad0dcb8d3bb8a8fa5fbc359d230e9a85a907d47f4f9fc0b7e0020","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
