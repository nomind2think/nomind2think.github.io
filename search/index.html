<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d6cdeaaf46266606bb703aeae494273b663efe44ac33f8b1d1a97de373b1303320cb41578fa8e1cca3ff596b8bf999910b25339313b831151d1f20808be58447761f900801c76a24fc030fb4f5b68f4dfaf8e8c30b705cc0608230d9ba59ca6831a90c837d5515a93a42f8f7b8f70e1852523531694bb6ff28a370af094b94e7cd3494830b3519923d61835e18c6ec33a335efb6d79f5a45952d7ca33f28d73f49eb1f436850a70b1e3dd25f1f80b9a72cf8e4257b03b9598cc251ee9f0e997e225fc4684b00e6e5519f2a256d0c019b0be040cf3b2266c9afbb6d7400d6a7a9781d011f4bfd38b6faf5b3404ba6a8103257665abb01510c625de1c1addee47a40c6669062d7702a0c3dd38ce1aafd86871758682334361898bbff6dd142c2941ea8fe009b789c9d9b2b791ce75fbdd978ab17775544a450fc0016583c29eb7ca63ab8cb7c89e5d2383b894a686be0e204411d18e13afc00fd58ff9f79cb8aace83576e4c5a40d73f7e2835d42c1c0d5331835d9b33dac745538308b01006c344b70f4c5b7c2ebd2664b2ca1e3b57c6a7d286fcee113c173d78c63d965a18e62a9d7adf84d4d6059879e04816455edb81db7279793b1eae17b2f0532aec5ce5a80de3b8f7ac43b0287949ec1a86c0a9a284d61884b193445d550a3ef37bf78425d23509b77f38b9bc9d6e8b341443a5fffd1d2a22418faa551bfcb83865e2b452825f84accb6a1d965b44e71181ea246c150b8d39e2fb0cac4b40223a73619f9f7e874b927f8b14cdd11c14b53b9059d34488ab4b7be4dba5e46a52234131f6e05c811e4297d06be276f4caeb7c0a8fd868f11a9df66f11fb8afc138f27555b9f9a406b969dd26d9a822b047ce87ad149520f38dc990442ee36d523d95144df1e0b5531c62512f5c1944970ff4ffb193153601d2aa36d1409c96b522dfc2b3b3c127f4d7ed8ee521834ba73af95a237d978568591f8623bf6ebcfb72546f3ebc02dd60ed95c8ae18df1b46c7fbebb36d820d0eb72170f43971fa569a796ae18d5bb853f15381ce05dfc3bf4a3cde8f28d5b937c685c7079ee1d804e723615002160777c0a87866ab38007b2636ee081a4c3c6a42581211bb1229d8557d2aa0f574d9280b54b26adb027bca9edae2f966868edafb65e0863b015b252c60b1e641ed5c66e21f4fb7869779e53894db21fcf69714985f02bff510a1bc8c55f9208025e19172c1291650d89a420c6612788935280b41bcb725919c2e6b0f0b14aa747d4a864912d623ea79a7820df916a083df0497f44d3ac920d983ff8c09cc150ba896282749419f9787872b1b5e928c01c1c342292c942ae72770f1942e369894ba43c11d53271537a7112001fa2a6a298767bdae93018a3889707d1ce492a3872bef4b30ae795bd30c576543eb83366032c2f1388ede010237c438d7a7826121a17828c48a86a5dda95866fde386d4bc6037df0cf0568e32363dc674c061a0ef6788a2601c63a8141154dc7e4d0acfcca593a49bee6b6958489d08038f24fea8cd167cdf9e007a40c23e5507968b7aaa70fdacdafad970f17bd181cfeee72d90bdde37d2c4c552bd143eeb3aa3c6c84607b807911fb5f6453aeb464bf6f808e7bea26f4b5fdf6f9cd93d09aaf763e7d28407e1d0e1b1c8d144774593f53b07bca2ea030adb52c7ca483f4cf7effd44f03d5d159797e24c5592979a5a39ede160b9160b76f217c7264bc8b694b9dd5cad33623c05dbf04558ba934ef4a1ae39910ac8afb3d9eaf5a9beafbb9cf0510f9de245b9aacd9c3e071df7f537de94054a23d6d41d148a6ecf07a36c3a9fdbfa356c495c1e9c9ab33f5a02b93bbf8cd8e2fe048e289bfed0ba7693f43ff9970594258b596d04ef1193c905adb27677c59157caf09123d526f8bcdb8817bf7c7a13511988c907e377cc9f422acd02859c665225e0db706f200b7837d7e46be23b370657cea9d99e8e507728ce887ea2498d9d387e5f5edbf1662f251be769fde279764c557d7836c69912fe42198a576274472f6226bf1324acc3a069a44f16244cafd9d597680513591b91e7662ff16318bcf44d79d0b988f6a0ece5b8b1f79d444764bf0ab64f9e6bb021293506c30a2a6c90da9b11d1fd452bbeed65b1eeaa173f9faaabc8b6e8f2e36179e6ae2dd92718fec37e6ad9d3f185ff7636b2689ac0aaf30ba5c487af016291c631c6428a14513870abb27fa0eec200036ad1a9ecbb9d3996b5ca317812d21765d34b2d9cb3ec034c0369d296e54b746b5ad764e60a1e91b8497f65e0fc368d7553b98b0a706a727d69616bfeff63a667edda0474336159c6bfe7be9cacb9217bb2a368ac1c80c97f3488233ffe1f490dfa573de16b2f2bdf212e9722de616f73e17a730d18281b6ee15fef121c8914187efd277eb2bd8a221f690ad998a5ae4ad681ff62bbd1d64f9fb340668520297a913878a5889daa2c0b5b47a8001be45ff6a1463714e73a9d68e7ea6c79f0800c229bea332e0a367d29ffd8e757d7fa6d4ca5c431c3aff48938f7d596eabb69d20352254f6eb1c514633c95413d3a4877dca37a71dd318474101fbb3add1ff83d4c5591e3246784696323e73718ac7b82e57c80a235e3874b0428e733ad3c4eb005fff634f2acdd75220fdaed3ac9c50a2338c65d3d79a9401876b82891a8d0266e97fde5dd93e58d62a6edd9a3db8bcd4c13776b1b6b1977b3fd22c5b324721d6feba5f8071a4365d2c0f35ae98c6339eae58fd03a2cbff35695f4617c3cf5d1225af959659f4b929685f2eb0bd3f420c46391f8b4adc6e84225b503fc37634f3dff30752709100e28a6a774770ea52579b45ea5041b1b68382a86912844374a4daaf78aa5c8a798a90507beb64dd1ff1bb1a4be13f43031f78eb80885b562051b1e0f66dbaa1c850526150260dd65b3d88f3d79e53864cbcc107d25b6c1487e7a331d6a73f7b7ee9cc9fd8313b327c01e45830ebca40788d41165852ece591b99b440460b2e6e80edd67aa9c4a4c6245979e977373db1f388f145bd1befe4e12f98e068c001e7b7a07ce36b6339c702f0dc8818c1c3ebf9ed3bfa7b0a5713ac377ca9bc95275849db4e23247a2b95ee9a2fb73f6a32b5e06c753d7b7ae7f974670a29bdd867792e4caf9835419a32367bdd810f88edc5a0ce00440f1708c7fe612508b74892475519e9506396f020b7a0af82a42eca6da7e4be99298f4bd0d985e13aa94ef2357be3d647dbf7d74de2b6c2aae14dd9f8c2cf36a8d9128a1af5678524afddda780d59535f37751a56a136f27950551b65fe4a27bfdda1537141b67af60d4aa47c58a633a8e3789539f866a29ca5ab9ca30f77409fd2cf3d7b3a9569e4e316d2730d8280ab34f57afd824641110e9f475bb078d52e40c7c0c4d44090ced1261c1ff294996e882a73e01b0d2b8b36c8b7a2aec09d71ac36d1870c8a73f22e9b54378122dedf6e781961e16d63aa7794580200b3733bbe58a5a994f91bb42c90521f0615d981c1b5ffb17a06def0eb1c46f7149cf5b85a3787557883eb18b0346d05be95f4cf1cec457088d3c2e5990950106fc1596f590f212783fdc69f25ab1e26ee95a43bbc83ec7a5d86d3e2b3b27643e21b79161d38e4fb51c7f5794679c51d10bd05383f24d38d82f436b0031c7b676ba7d062c87f4dddda07a53dca48fc4a6899df2c5f3e1fa0c0284dfe7caa40abfa8e3ef2104a1fafc01985dd8b708fbef3a978ef292d55f77e605f38370d3c6153b396ef4e0f0340fa170241a0574d2d96a89d659a91857664026ec50989bcf7b2e644ad566eef2fb77bda7d7dce981acfcf553fd097afe681c8149cfb6a3b6f94f7928e94cb4cb1b6b872c2b3f4f436691c9d833e3f31859da5f28cfeaa0552bb83ca1bdf92ad294e8331380e2a0b2b4352da677772dbe70b6bc5d348f913611c51155d739f47499fc7f4d8392279764b587390cb630797cb4e1eaa284c51c9173069c154e80d98ab5286326e4b2d2ed8fb395af29ffd3add0754626c2bc0183577c7d39248ff931cbd3cedfdd665beec4f65e66d8dd87fe57bc798cae59343324229be02ea69c54f2b8cdf9bfd228ffc2477a76248b2773d753f48e81f8ecaa8a54e0dba4e94d8fcc954e7b60b0c65f22c7bce4a96fec43811f40d29fe2b25455a28d4898f8c46fce85194e9363cbdbdbdf1c56c9fc5aedd62f1c0a0d7600765a9c8d6c1c1c9dc089f605a791eb43801c6b5cca7a6204d572a590c70a1e00f77fb762ec57d19533db014ac38d37e0a93f00a94137fc4bbe14220d8d1fe63828e3e47a08b26eec7b37f537f444e09993b5d8288004592e4215849a35ee6dff34614da33ba125da8dfb829272f6872f86c34766a7ef11e8e7ef83f6f01114b3fbb70457e4b35557e5cc595cec302da312c715f709bcb797e9d0d75f367b76764fcfa75cd44aeb99d619a493db4f0f45cfb8fac180d378daf3b2d4c16dec5a21061faa9b56e33267a635c063838e0078efe8e679f787b9ca772274a0b0e061696a0eb4a74929d6c5594a783a312a572ac7930ce26e057668cd39f04808688eb0e461f5aa6cae3e0ccfcecbdd324a498b48d11db830641bdb71da6eef3e584f73e435f31fcb1a24b669dd69d3c84fa721274cdb11c44b5ae1c78720979f38753993da8a72ef171e6472f32064f4bc51125f4fc8b79093be6277b69e7910312c39335c0a36ce572c090a03e17a143db92afc582c3c93513fc08d525f76cd5ae67f494a609db707ccd581bf8cf30d25a3a08bebb6c65dee79b318fbe4877e66d1f05f99606a8d53da673f8a718a2332dc09b22e072fe02708c0543e1afd7c2324ca7272acf0a9f5314d7bfac21d6e3b198d655f49a08029b76f441519b0b7a58a526a38e068d712f90b336b9e774cd41e4634e40be785384bcf51b19cafa9aeb3b271c513c2c4eac46f2fdfb68be777f9516aef6823157b8a80a443cae6e50f51a0f0c621c0a7f99ec6dd1f588916532d4e75def72e36c4d2d08eb9b353f1f289a138f89bad5c2be2c7cc2e9726cdd31d7e8f42b30e3b72143816b0edb845efc0bb50ba18c6e169422f251642f3a00823fada7395c715ab56f1c3f95504fd1deb9b692bf941f101755fa2a71b6063dac6f4adfdc695544f3c62c36879c771329cbd000b01b7cd8b853f35529fa4d48969f0be41e7c7022658e71560e5e4c746bfe1e43bdc7358b0517e9024bed47462840b369fd8174b443f2b6cdd95ff3690074b7022e0f7ec44b44b8ea0a20512a6939398ffbd1e4006189038d5c663bba5b7e3477843b453959fe3e8a7e87e1c64b6f314ac97c82e14b518aa7e9dec85cbfe7497354a83916005dfac36f1ccea398043eceeee05b83a5ea0e5c1f87746a8c83c3b0fe372dd1b3b79e9a396d1eb02c51ebdd4c472fc72849585ffc781ac51c211ef375ab12383fcda05066c58bf1e9e6e8e2dfe229e3c445231d92d1c2a4a124600534e74a50853a067b8578f7d516cbe7678edd89718985d2ecffd079f8ec8f2dabfcbb22b6b21d84b624c520025aeca604dbbd0f01376230a4ade4d02458414426050733ba1ba9244b155b778f39362a389ea48780499145002b22ee2aee6968c724ff04cc06fc67aa12b98451e44b6b2303b8e89c82992937515f546c57cc3f1abc98aa009e701ac6b8a965de37b28a1654647897b56a9e8c5b65d2db739c2dbdcb0fb98afd212fb97aefd2e7355b1ecb2dc7e5d8458b33db387f6d08e783d992bf8cf490cb6894a5987d3b2ab186e9448b94a745220e0004d046626d52e94feff95a25309a548acb9da76b3464cccc16464b12f32ab273b2dd3e2ccbb604c7286cc58034f698f2b3bccd7e92490e5a6ed3822e3769ce480df0f3a1066bbdf6f750ec0647eab18dbffd3d3ab8c1c767d43f2918ae00c513b85df2d084ac99d1f2e771fa51e0dfd1d0b5596e7b30373bde41d3f7c1dc7b2284c73ed8fef09ad91615497868cf38c33d7b8cd962c95053b7c407a2d0258899eb6bce9f4631b6ae429e188447f3a043ed068a8d7c8e1864540b7df07d00b4a0f1fc4320d7bd0f4d56570c281e92652049d2752afee17447d64e8f56ff4eca9b0691d8b828b3b90196be54dca6ad699de5f2eff5df18881a8d72ae690e465f06ac74a0e17807768620c04ac33560258c00e04f43b1b107d50e06d3f6d11b0edccdb81b9f8066637048303ffb704dc3144f6bd2312c554ead11a45ab8aff2980121b42fbaab7176710ada2e4194d6f78b506a8bfcfdbe0f944c8b516f07fe94a1db8b24222c7542c6aeea87081b5878890878dddde9cda3b43fd9a0000f35e3512e7b8d56de11c29b0a1b3d4c424c775f5aa4cd2eefe8f947b02c4f48ce7ae3f9fa83d06e31e2d1e93403cc89eeef87aa830f2986f9e9028fee377ada13268b15a99eab0395c41fe8910b23ecb792f9beee646d662966c1504ecda55ad3185e4a2f2fedf2456ed2ebb336c476f0037dc2fa218006d0b68beea4b3cb91dbb5f5862f5b47717a83851cb95bb61de956529539af1e6f5d20568f17d51939eb6115fca9c13f7722d368cf67c209b6e3b831914097d984a1218eebe1c4bd05dfd78537fcaa75dd3f046392aafc231e421719284e408869a8c091c21fdfcf3e6b344c94f2a7f835a7892a2493532ab4369ce9a10f83ae967a8769b87f058526dedd1308d159618b699d39c5fea7c0d73dd164498b7d033a17bf811af721b5a9e88c89cb4c07549d0eb7472ed42afab36f59e3c9bc53930540689f580a461350396561d5c20610b0b4d3bc413322fde8ce23ad94eab622e24fed480881078442e2c28302fc1755f9075751d55c591caa7951fc0712c8e8e5d74da04716e2a7cd5334dbb6aec3a936fb518a268cf3f4a90eb9cd18493c2b2b464a311ead824b723fba245092ab82769bf68efba0e74a460b1c34b9c1e1291fa9e900c62eb841f33ec1b01aa64a70dc2cf025ae0959a6556e8926c5663f75e4a4e0b2e70a29be8299e69e55a2378f0f3ae3f472810081e1321738d923ffa34d58395503978b18afe9a3b7525b14ec94f4fb92c0227414b67394d2effc58c2884057e5e9fb9fe722d0e6f89835af977c007c0d17bbc6c22bccc97ef597a22617ae1413845383953fa22850706e0e8ef579620593a9b76fa69aa592679c14767a1ec2deb87018084edeaaf3de539b9d9d8abb5463fe2f66d657330a5b8ed9d8444c2b7e99ff3e6dc47fe22d88a299f9dbcb5c860b214d11fd62ce92c2dc342db89a2b61f1a0ac81fc104975234b7a70fc968b31378916affc6ab5c493131ed4685fa7c6f1907e9667ac29bfbdd90157066705716e6c7c94a269af408fd4c2411acc85b56d10a67a64a5bc47f44a0f55722b1e98126ed912bb66d07aa91b9033ce37c1315a87eae48f08503c1469f19ee3515c8ec97b13a496972ab3cbe4e8a766bf43f4431c7e6d59f176d2ca60b080a0e0e76f6580c45e986e630abfcdb1613dab6e1ffc1f072b68ed5159a7db09f704c87f9a3e7c259ef8f2a76e545334defe190638bd9db96d8961a895e432ca105c043626fbc6d1ca5d6d9551a71c56d32728a2071c075d068bfa0c65348638809c6a701fd52b6f02777fc0df412537c5e973ab5e8865ae075ea74b5dc7949f593b6bd2feb803f34e070a8d347a3a0eaf6d1b497987035fbe12a7e506a2de38753adff881afb1bdc9dba9e89cab371a0bff94d68a45765f2186c1c00f05da19159ff0166b31e52d44c026c9a16429e6228256ca34d5f876921c51329ec09415d1e705ab43931034df9fdbe46a8b0d88d554ad1e6a5cc82237b93d99e95c77adcf7887c8db3ddc050e217152baef40b18d69a7c8ba955597276339f8f538c2ebfadfa375c871b09326092ef6f4a27e544e0ac2873a90061e2fe5ba043c07329f1ded9aafdf85a6f999cea1cfac2599da2a5a601691256c98355fb339bddc14c1eb11cccf186b98c9226a74d54fffdeab1a19489fd32ad901556b7df70564684f136386d520d81fc86a0275d4b413d9f70e7799eed7f37b7bb155ac9b065e8cae9ed468e343ee04e415cd8a72d643546cf01acd6b070e3604bff84f8dc01dbd85f08478464dfcbd3dbe28a0da8a23de0253d40da08b811aaf7d5bef2f74dbeb48fcd5a656caa576d0d23d55e15cc02e6daf6d7a352c5a79b6dc10bf17d7ac2b80a21b27110b11cf7078870d7466604619b093e97376e1dfe9b8d109b7078136a22c4913a62624dab47ef33dae24e1b192cab457645e36fd3e96e674d050d7851458e976459efc340974a4b0e2f29f976a75019872f747e5fe014e558b0df47d9c26b6d282d44d876209fd5b2c87d7c8311cfad7fb26693c1f3eeae89abc6422c71550db55b31fed9998d5f2b916e042403687a20231626e9929ab01724bb283f230b967e1800b39bbb50b528e0bf26349074852823a319cd0ca44dbdd0b39bd12a49eeb93f89a0d70cdd7292ba5f8cc3ecefd797b54d719d566e087ab45bebb0d1e1d42a2f740787cbf82977e745748ce7186cb01184fc25db3a178f7f26cbdcf8fa7f14bd980fccc73bcd25dfd07eb1da6ad8dace7ee5c855d7de92c87b3b35decd7697f100489a555e92b5ad929cf3b3ae7f490b2bfc80b3a3555e9505b9f395f3a4f3a394ac9a9f58cbcc7a142fa8a9746874ae0d32eb0d6c20e75abbd1db02eac20c61ea7b499bce3d19ec2390e98ff907e41c6e7c68d8dbed570325affa2e0fdffd225f4e8136a7fc6b6d66e44f83ae4fdefcec08e2fe12b4e6383451b541bbd82b343dc88775d6f98a1b42f105cb7990df93d49673b8b41eff5b3c849f36397a8cbee9ccb644cd22d7272aa9ccc85bed8012167962cb2ccf50d72f512147e4ac9b34519573925342cdadbec55304ca27c9cadb2d4434bad85a2054f59279995db08e3e02c1acd1dbeb1f7a4ad54b01c42de47394e081da5b0192ff71abfff1a68bbf8f5961d9b9390ef5ef9c454d6d15f7ec4a0b040dbb98971434dad5bd8ebb6a2296e9d72d1921f4192ecfb66117adaf7af45c2113a21969831355c632b4d4b4c70b85fc4c1141c26fee6143c335c2d91d08e234f58634fa2793435b34b19d06821e60397b01595e2f0fc9a00c8db2b7e619554204d9f313708e8c8d3eca45370a269a74d68f00f5581e5fb2a86bca62233d8925234aefef3ca41fd85fa85988797a49365363964c72a061d272087b2a54049e5c71999c7258bdad7dd9f0a505e8e56bc757990edf597f098b2c699b8af0b2f543994d86421ad29841263c8e1fcc40ced31604d9e489156797149989b00f8b10b5c16e459f3540570c08776e48bb575cd31923cd370e9e3a7ee4cde45e8ad0d487b548f6e174b1e73cd3cf0efd8b3d78c25500084162e29290f20d2579d5c029def7f8d3ca47f32e8d3d46c96f7d203c4a38e6c52c2a1934c121dd716cd0d2922f2b575b602db8116344cab2e8abf9009c2ff6f28448046640bde478521071fbe7ec13c991701c9dce5c18a6b5e138b68b4643adf330807f87deaa724543561fcd166a905c21c00d58a19089856e7312aa4af611ee028178972b02002f33f4d6dfe8c9bf25bcceeb5a8fbe2d9fc2b12a1c6fb15214f92c05ea2abd41b19ca1a2885f5ddbe4e7cf1832f9f2056b091fb1ca0b4916a8d7ac7422d57c11fc9b8a7ac5e537c858aa1c9d062cb01fae1bbc1295d909145327152c9b8aea60d53409b220acb51de6ba4f37411826b1c33100ea8c7f8f7f248aaa5631096d0faa09b318d0c25afe92be74c276f8714f5f73219072836c46e97b01227f1b1258ad2d66cf7b352ee0ebcb9d29d8eb0b55812860d44c73d14b38e96c1f6d54b74d33a9e703bcea512632242bd3c114f676075509f2389cfbcad67b62e396d02bc97e9e52cb1f7a57322752a27d0967e411973424cf09f8c1e3e0892e1fa54d1929a73188d06000208c5512ae839d40c14772e9734fdf21d1ce18d40e606e97b782b191429a99c483173b5f0446d76a5938aecc75bb2a858ca96cd1f9bb7e995bb994850aca8bc3a40681130847d7ed9e7430cf9eb1c20074c62e6dedb8092d88e59b1e570cb84036f5c889d02275823ae04a3fb7e27c515f3b6ceb6dea430f5542b20dc8163f6c1d386d65ee7bae0d17a12779becf50dbd27afcdd2922b5ad0fbcd9e758d843efdf53ec1baa0c1dbb7a13d3dda2e2bf71f91d8cf4307b2ac5457b33af6818701644edcd0190d47ce9b644905702faa5c62e123b3a6de8f217cb3a1dba11bc13055e87b8da854e46914c9cfec273ac64c74e95ac8d50779ac52f164aa1a345c712547f50565b46a8b097c53a6bdee8a61993e3b55c055a8dcac614655486b9630d716fa0c3203a3d9b66859d46d772fae57b4471b451643ea672470ec9f2fd3beab8e0c1c49b615c8766ead6c1114105b4e770a1e7739bdba371d59e7c95514475f1007e65884f736791d17850a733ecaa12ead5557c15828223892612b3e1e6825a4c3f448016533aa65e3a3128fa53097043ac1ebf645c29b71b32d7b43ceb74dcb04552c060ef82fcaf4253571d29d971cb4080270204dead4efbc36f2c8abf45d32dba99fa32418cc0fb4633a7e551c852d1f25152dfd07446f62db869b1c214b5f972fad8aa115715ea52a2dce3cfe096ea5053afd145a5ed11c7d8e6e16a77cb9a73d47cef4f395ea764ec8c9952caf145b77487023fb5dcb6ebb337ed5f12c195802c20218780a600bca7103a2498820bbc6a1df88be2adcc7348ad1a14b077df51b24f9c3600b335b70d63674dc9b8663e541c5e8eff51b9ddbd72a51d4e768ff2ae61cc5e0865b7101ab9af8b84f7331e67e191fb0ebbbf2f6506d442340de556f74b51451884b1b5d4be4b068ebe53d66e4ce8899841b3b9c64cd95cc33ebab43287ea34fe25ffd18244cefe31cbbc8ca04481004bcb40ee1b2a98b16d8426a67e2b83208e41f90a685eb38e50535ee3558fd13567c5a18c5d25de1e5872ef0b0d7ab2a74aa38bd9be2e124a096701385c96c6b4e10c3c78dd2f876b4955e60ab7be169f631c3c8b46ae088e4823f9aa0767fdce6be3a66c2765d5c46d8befc9aa44895a49236b5fe950f5ad352158e4c4566cf5d2781b29b7aac9873720f14aa40fabb8768987df993453d8b96e65b01f15effe20e80ddef20a53f826d29a343ca98fa4fe4b0360becc090bf4590733246f3db44cd4b0","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
