<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f99be87be25cd7ceb96d56066a8febb90390a9c865a2d62a5e0b348183ae30bccbb4502f7ebbf7680dbe1eea470fc491c9c332e564f740d8fd1ec9f25d6203cd36ff6bca8cdda2223cd58886a1288f0b63ed0267ac601e8b0c083eda55d5f47c661b285ccbac4d5fc9f040e14807f49d623ed6982615f25a5a9e8f676d5e0bc9770a9227b13a9923a65f5e9e6f8029e9919495824bf91ff145cc77f7f042ed5409604754208c8f396156f45e2a8ece497dea7157043fd3ac499e5c3de2cf5191547c269700ab8a12b84ff1eb9ad854bf5622eb0642071117c2e201790909112ea5b45bd1df5979e2113455cd4b35a111eab64c9017ea2908db28508131ceee8a2ab5bbacc9f5d88851450da6087f7a9ca7b8fa65a888d641bd3044ae8ebb4a5792d8a60b7358dafab80d6024af5d3590545a616fc1349af7408791a1e2a487360e8957e6b65382a5dc9ceb07d3844a2e2d80eb42f9451dab446ed9a6fbc5a24fa94f0b8ad786ac35532cb9a61f411b9bffbf040ca7dd61969ede24bc4d59b44e28120726674b909b5d67738fb52964604f83975a061471dcf3cf4c6c33ed622f9dda9346acf9e23985d69e852c589f56503eb6b973329e8c1681d3bd269ae33e9d964620286d4f9b06524825af1ffab0635cd316678818d5479598ced962959ddbc9812e7ddacf89e7c820018340c074aac0bbd8d417ad85ed9308fe92fe3d43967f434b6403d2c027beea54e6b555ad4e48987d06c0ea119a8d869b9355190677f014c84dad38c484ba29814348c98fc59993ed4e11fe1b146bb39b888b4ebea58cb15a49a5ce21b235bbc5d7d15ba6da1ea58c7e186668626c0c8bd77fcd69b7c74cfd0936d2257521b03f6aabc96e2ea8665518c5f216413ca54a6277c37daa8d17d21da42a945ea3e35599fbaa6ef8cf28b9701880d13c837d27387683ea94401888963b0a74d5eddb2af460ed470492126afb633b6ce3d889802ed6acfc80c0bac15db95293bd498a50b00905264ba6d4a7532cf0ab4f44565bd69df0d8e832aa732a092fd792f9311bfb5723f49ca1de36a3e02d81b99439681718dfff1420091da6889f01134242bdc19782bc5feb01666e71644402af6673917fd761ef8953e86d8eee979cf61ea286804759c6e82b793f3adee6b87b3c4288be5d42a905b84ad6e018981066da9bdaacc08b97dca624f81b1e8cdb6617407e697df1b17da01ad402160c7ffe83f502ec90348a3321a72b7cff7912c47e2437decaaad366586d0d4a18e1a2b1d2f672fa6aa245191c977313442daf21bfa4394e95d83a109c0d8ec10592303a3819ac55a3669c01ad5a50c0b4eec54c362e100b950f3843dbdc20dec2aca774558294b09c0c44a5902fd50dfc691cb69f1cb6e53f6a73ae93d624c9de8ee325fee81cdaefdd49ce6ff012884a424fd56db367ba285e87a5b286f62dc8a090a6a2d402df2675013818baf190fb37a22fa347b681bcfbb16514b7d9024fdef04a17ba92cd647a2de27236eecf7fe4fb2fe7d73fb5f54aec404c9e9bfb76f5169feb4b790e3213780208bf78abcf01d06609012ce97daefc5ef6ddb7792b64cd403420eda3099c6436e11832a033b8ad797e72e96ed9070501ef09f304b8969edbbb3e586f2e6c825ad5a0b3a5ccde607bf1bf4de7051d4f2c2f561fbaee024ab1e065ae866010fac51d902508f982081332c9a1953035ce6d0b252b524170f081a22c792c0c9810e147a60c05dc0345632e1043fa90233b59ac76e808ddaebaeea6d8e146305b36b4f8ab05871e85ed786b4b3375956a49f9b84cd943f14a3de79bc052996fce9ecad6268b40b88fa5d4e8c678762a4de0d57919180bda31e202a16f9cb0df662fcfe79cc5ef7b55f60e2689cb8273a530eea2e15b5e1511e44589bb6b7a4f184c4536e0197fb747299125d527167d9831ab91351ebe9c6cdd9158f57207544e45fef17090c87111a4fd47e19ba1ac9668cbd19aa0bba26584567d9b296239cef23cdf68bb3b88c3e1e8e891a33e4a0ff3ba5fcc9850b42d187f463172f152b83b911f9faef9b33a258266ffdb977e15baf868931a13788cbe89afc1d2e212ccd9dc1f83f301ffc01a19ba511659d4a655d1af2044ddab7a4e178a4d4e8780cd87aa830da1d8fdf09f565cbd5e763d8dd2ccec736ca6affd3b976fd537c9aa2b5e30449580323e05a1deaa5592055cfb58e887f516fa87ac6d3909a2ae13f96ea00d9d1127cb3957b1b3ae93c496ce08fa634525b8fb781972f7b8607a833bf66bd16905734bbf6bfca449d50d901b76683db7cb949cfaaa7982a9f4e32cf6a6295d6bfb60892e84b0b51763997caa1dc44ade36c5976a1a6945023a4869077aa33bcfc76fc96b237dec48e76161017e74158e1887b7223bfb69c465e78bdfe635a2b8f71d27b735cddc4a35c91dc832821a3365f63606aeba591373975e0ca6895eeeb150bddccc6e0fb53836aaf6c91dc8f4faf7a31d5728abf83db754cc97c5835588d69f8f03a9feeec20a6978190a553d4732bc02c23895b4021e35984746bf8537b8b96e458bad75b672da5baf99133b805f21d5865c6186e5c3c48349d0fe1b317e180613774645162e9486ae989fd0fec3a7599f2342f1d48011bd7c859ffa80033b33013189e47c7a57021c12d387345b8e817ed4ff831ce5e63acf72985837a50492b6ae117a13db447b0ac59b6bbc53923ee16c0ff091d192b789e39057f731ed4dd07bd044ae7cb35fa8c6b69e855c400aafa768147f1db6ed867adbc2c3f04f3038f04529e1c1aa93f44c791618d78375306f17521d1aa2490351c86d89a0a1628532a08f66f7548fc406419673f9aed32175ce18f5ead9bbe0f2ee327981d6c16a2d27714bcffff47b6b02e77dc1c1ed8272ab4853fdb1807f55b9d94ad2c951dddae3b7e5566d215f3d9fc0a024948846e6494fda8f94939fb5222d9afa86c3da8bf99d09b399891a9cd732f94399501ef6751c84acf3738cc4cc679f70ad6ea7d1f135b9e9d60a9d976fd6f5a6f7216360dcd7c1555f69786ea45e43d759046c7db3a2a5f71985b80adf770292a3f7250355c8b5f44bb299c9b2a33339cd2e126018008be1e5b35732e5e87ef8c428a74f66749630e0bdc9183cfe6d1560f2b5dc56260ef21112a892306f383c92429f599ee8fa6fda039f44ab3880bb51895e2c39c63458516c472c21e0924176308091e1faf31d8e1c12d5c8b9b70167b4c329aa4c6540c4f8c4d814d332b8659d7242c19c11cd51d9b438d27573a4fbf445162e86982828f8ffdb5f66dc6f08e82163966c077157cf539210cbe3f69496d68135ff3ba685c673741042a954342243d061fcce9507d958ee7ad3b7de2937642c06e48177b54846192e45289e9a504e5b6738236d610395d2ac0ef25f74a2e798f1e5507ae0d12abd435bbe6ac6143d1cea402901c6893b1de4e3dc3503faaf234f301a129308bf920b1e00f9ac0fb2d5a2f4b2c1ba75dfe991c1736fb3441b9e499fcffdb80ce652f5839f4578a963eea170061358232a0c6c448d2520b12587962bc9e0a99133ed325cb492a78cc9e49f054c8f3eb7e82e7e4b5d70e54ed10ea95cb5e650884403562c5c7e8b511d326aed4306135368b9e0d582ed4f9a083f48442e3eb0bdf25e8227497504fcbd843a1ae9c7247a67d16e90cc52079d25f5d8c801ca865bd8c284b8a2c9e558b6c47d838ef1e44d3356140e3c0f889e066e51ccb086fc85fc8475381cc7dd260871bc9237330d9e7fcb29f8f7e10c05b6c53906f63f446784963f7b6906505f9c1df11c5b0be250a77c5e27ab2aad76efa471d2653e94f90ecd3e792788ea36d4fe0451fbb93231e31b9ca939b37eea390202de0ffc979d37c98b9ee1d59775ddada57f8d8cc3e737729411e463846649cf2d2331a70ff16831472f3285c947e820658cf532683d742cb68ac62165cd3d07d4ca44d17aec7eaafd86ae1d247fc501cdf2c455aefda3e89b8fe634021e72f3c977bfb3fc95fa82a692a3e142b64a1fc44af233c56e14807037c241e8cc2743510f055fb39876f3e75a765fbab59acb8d1b43841e21e31832682716580fa02695880d45c21a5470bd45f19a440e0a448fa387dd78ab853b8bbd2716e86a5bc13c2df250946e5fa18ab766f6e9957914fe837470f9a557e71d0a687482c242bfb5d74c4402c2078c93e0e916a1d9241d08b68a17650511767326dad70a35f1ed9f4e9949417c1474a8fbc8a1638c214284686c5ba9777de7c4b346fe564bcf880779678f1f862f0acd835d291b0202ea7557a97c13130576d3d719629ab4109537b903ee4073e042cc9c965146f15cb7f945905a6341c18f65a443b3c5206e6ef396dd59aafcdbae7e97d5e735167895a7dc24f009967af281755d096f1580f7b7bc5fe17ca869d819fa79a3980123a0a7f5b4eeb93d26094d43d59a1bc937ef7b4c62d3a4e97025e0aad301ad2caebf831e279327af9743152ea1722b7836fbb8cac850f965244aa3c8d26692332dd8ebb3460685e8ffb82b8eb4afc9f64ddb3fbea56b7baf9e0b5de63f561015b2f0087e97c5d20588a20d9ef36e637bd86aa29c5a85814f2d57b52f2e899c802fa81c6e4c2a5f3d9f426825bf60fc7e69eb695cd65995dd13e950d41dc0fb42eacc30f18d201ddf07413645439c89d4063d3c830bc3a89a51ae3c2b6945b236812ef22e14581ed6a2239aac9c68b4b64b4001ad87d8016314b5e346b030b015ed0c92e165d6bb806b73cdd5a06db343d56fea25a81149873fdb23018c1365a4bed24a45f23bbf0705c87bacec69ed2a004d25bddd9ac8af1caffe9324b6c651adac809580a940c10c9a350f292a44d84ead961093a66b1d3b4d607ac24491dc0b0c6345efd9d75f5c0bdb4633e557b8f96b23febc618aca220400a586d40e6991ec29f5962cead977bf9b49620454e44d3ef06f0082b892d6f8304c6f2287fafb0dfa57d1a955e436b2ad44b9fc2caf8d5d9e2f20d4351200dd8ca0ecef27c60a92cb374ecaeaddf61736a9496f6fe9bef0d71bf2c0e5260117703f89a858821f2063a26cfa5867f1b852b420721b1416d18a9bb611bf82b055435194511b087df66a91de308f431cc84d53f21b04af9f7d437bac2163bf2df2694749e8faf8ea45af9be9ed4d430aee8304e15360dae8d0e158a06ef51d18f23a9065d251b9fed0cfe85c2628b078e7905b5de38157459f66144a4894a6954c79ea74001cacc28074a40a10316535096125bcde7ea360eac15ed0fdf081be9ede9a20b8303abb038bb6749695d559d7fa9027e6c609ec1321c7c4944e914c0cf98134e34b161c0b2e27bbc72781aae5153d22fc1caaf4c187899c152b301c6d43dc3ff9f99aeac8e334d9b7773c573a6eafafc69f15551af9f45498b761a202ee3058fac29615936af3260e5e42420b132ee5ce5f631a5889102f29bdf1b55283fb419f9afd5f8d858840f2db565fd2911fdc8f25703083a34e58f231b23b7a0def38fbbc032585c189711e3e63749edc19b703987505367fd0e55e30ce6ac1bb11a02b064a0bdcab84c7d4c68502eac7adbee62f62fc8fa2184558e51ccb2b545348a2106707f181b49c3b3c85b55c4956c287e604861258e200e35f25500ee110eb70ac1aefb27827ef26e7b051a68da7466f0fb3343b1201a5c021097e9c35e7118f04fe4eda8bb38f83c6c2a0fec22f95494d3200cd77e1aada3fd394df4fcab7feb4bd06693414312be580eb2e030950cdaad21147a3b66ebc98afb8a202154433069d868010a7255f6f2e0d465bb1e59cbda719c2aa14053abfe38022808e9881717b285a115c57b0eb8c147edd538cf8e99452a15738ee36e3fa8210830cb6dfee6f539110234c25c80da6dbb988b4aaa8a43afd4b3686ce21a2ce2409eb9a8de76f991b207fa1aca1e3fcf95de024d9055facc99c47a2edb398ee62d935f7799d9574070ecca817b82357e838a19fef346eac1c9c9319bed9eec2d4ee4eca433989451add06e378c261e30b20eb4847acbc4adb4f5a3fd937ccd67f5082543b8d95d6429dd405fca04d4c64a22480e73a89cd8c530fd4d9158463cd51ff002b303c23790bf57cd55ee7805b5e9b0375701a87f2f7849a2e55d9958ad403fbd73e1cfb579e8d90e105bdd9c00cf718c94bbb196adfd332d82747b60e0541c7f699a16f1be0c93f46ad4efbd4c7264484ff9ccf069211b5a3678803220d914e8299d9f677d1fb7613e7ee43d1c6d6f2d6fc5e6630046226b9b1682bb2b6a9b75b706f8892340f51b7adfef387eb346692ad2c1ddd94d524e2d68f8d68054612c69a24c0b8ffb222107d45439a4dd80f2e5d7d38d0a4739f2112e3240ab2300b9c9910ebc4dd9036757015c48e110b6785ba1b7b9e7d18b0a3d8d8edfc7a57f3be15ba06a1b5ced58d504ed2d14de9154dd1be067581302580901aef8081d8a5d8ce3838c9ccba7ab99e23e2632d5b8739690f46e5b045c771f1893aceb53f6b06f34d91fb8c21e4fb28f8e1d0e9145f015c2fb0a7216aaae47375ef388f34345a0aeea3362d8d23de81cfffd254226a6e2667ad095812e1451dfa32ed3fc3cb1c8717e8e23edcdb16d6932ade1a740994c8a7d4278b9b3654a3b4c86b6fb38014ddb5c2c73e2805014c72cf2a38b8a1597329621997eb7bc43239d142bc2e0e312c40ad72f331edcf4edb2ed7f0922e48d1130db023e0351332b1b51991612001ca774e39b54044d96e0b26a8cf5d17850afb905ed1f38e1e029a0be072cfcb7396649cae3f6d63b91d4fb1a5bf9d66a53a5240a4101eb46768323360403d9a934f70e7d609a69b08878684def0f8f9c0c265ec70d8aefecdf8f4ca1a3383dc16c4854d725f7d27a680f3fa1e0e63360561ec60096a4b9361948c2538cba22b55f98ecf84fda4eac0ea644603e93a4f48d8a3ba27a833dfc58569ed1f7a650f2610cecc243794caa3a686b97879ef87545e18869581c68d2a92306abaf6592c43d8369e5ed5360d4d1aa4642a237a1536b61de99497a7a1c39c907ad57032f32520b6da1eea791f572a0da6c126a662542aef6037782d5e2d396be7b22ad679714d296a1bc040ace065543851d72d1c3de0d2f6f0f985aff34e8fdd052132e196b08f9c1e64532ac655f949ee77d99ccb4f08228617bf791c47da09bc1bfdfccb1828348dd979eb7c8e5875dd0f8f6df989a0a7bc481edaadb7c4fbe44dd690f2779c56154fd3b248690c0df2c3f8ee7f3e8740ceda643d29d98390be5d75c3dfcecb52d2b1fe4f0cf416de291b7831a2e0430590cf58681308b5949460becf65e623c7bc5ad8025ff4f8ac0a226bc7433a17a2cefe8ed70dc060dd6488d7afa612100d4e7ebab74dd387cd718aa8780e6db48e9c78c873c6a64f534747f2fbe3573c502dadfa9def774b82d1f4d115002aa288d755ce4b76033a5f7d3f82ccd61d61708e8784f6c9caa37331f73e79ebcce21458bf4044d844d3c1a1049070bad29df3c2b0c5f8e4d3262e278b01cc0b6c271721218a6af545e9cdf5d14403ad71e0a03e3c9a32cf8ddcfea99383a5ab696b4d0c9df079c2e2235ef265cfa43f4df1976a698f97cce4af5896a6e99452561dfb058383fe9e688887045e68cea5d6df1d5f85907be74d21ede0c221be82b7da33f27441e1e96a5c8bc97006293766419ed5e43582647ee62dad6575d691e94e955d9b049505278a3693d6e19ecd450c463f79344b8fbe830a010df3ea1b4b92a083c2687abbc973fab4acf3c9d82af4a8ec4a6acfcef4c1446c5f615b4fdddf3bd095574e9e860b34a6873c6e835ddd0a05117915cd7fe1e7153e33e4661b926a7ec1bcc68f04b9e7f086475cba3cf2dc71ce9cb924695b7c8ee25af56da1714deb3f01a92f640ba66a4bd7f072e8f9ceafa30a3a5047caa2c81e6659ffecd7e8d37f6df69df039db74b2695982932d820f349b7bfa9d416b3eae9ccf6144b8d1c742b71c202e6def5d006d5905e528b4af55205d8ec882a0009622221a63e1440525bfded0caea906a45438b9cd0e2cd98ac8517e1999f70842fb6c91ebae8b6ffcc6693136e4694990ce7b8e72aa0132610e5f89462bcce10848b8ddb20171558c7bd43c6daf3e11b4a65fde481be593b8bfdbbf6dfe9a429c9e5e26d81d7dd7d0f2a7b164c4d7fb9da8216c6394226973bb9394322f7f154cfd9dabcefdd7e294a8828218d13d6ee867f11d40d209074a019363b72f8a1d909148811e898eeb05c00cf51b820e69bdddaf509a7b122771394d5328b73b5ab6a91cb67a866e35b8affded427dad2d2604f67d344867883323708146dbf8c7ee973dc7605a557c3a175f403bdbe0abdd9bb8f45b6648e9493dfbc89fdb5eb25d4df379886ca800deb9563576c0446d5f36def7e89ef2b04100f46fc4555096965d1cce5edfc9ea42994db37e13cafa8e948ee42c0a3fc736d2fd859e74e8517f0c06512a3160a1405ef6a530d9eeb6338e5a64b3074bc2434579bef70d2cb00114c4d444a1af987b1a28309701c9d1d24038d18f09a4be8ab1849f26708025bd10c8a819681e2cb1d3c6d6576bb05c1970ceebffab09414e1084142a6cb8e33927db99319e29ba5a6ca25ec5edbd6c66996b074f5fc9c26a24fb31c41eff17a8bd5711dbc9672cb76d473c67eb91cde2a2a1b93f73ad77cf1dd30d64f235638b4ed1921d7d9f47efadd1bd4706b888b8df9a8cd4413f1095f4c08cb6406040bcbc6ce361be6795d1dd9fe395732e1bd22aa76a96d2d06f52521c6ba42739aa84169178dfea9ea590d2da450ca21b0a14d58b0f05db1d959b933490854526d428ae93464c20bc4659b45aae04ad19d9519bb892cde630aea674085bf7016fe71881688b3aecaaeeae55304c791fc63d7a391ae126c1fc5516e2e63e04bcd32b389d512e513679e68921c303298e0c5406b3a142ca69ee9324df925d149ba7aa90921eb3e14b43f70e09d2d24905890d77b435a1aaff4d78de3584320d882474a2ea2f6dacfdf7c9cec49cbd79d13e263a347022ebe9b02f9c6dfefefb3fa7cc32f3067badddcd70578f2ee4c344d22acaff59234bed30704b1cd1cb804a3c77ca8cd23f20a4998e2edde0e6fe212f0ff7a16a9090cc15db507881c6edcaf665f49e8652189b729fcc85408391359adb462d07ea2c657c5236cb5d9251fe164b76fa4c69b8003b4e26f36f8498ff87a8abfcb2c3a3ac99ba1fd53bf059dc59a17b8e7835e692004973330f7d548d5272c787e967ff6de9e5b129f06eb61a45c72817aac0da5f8535c886821229f872d441405614f2efeb85337bf1779a9bb2e2b01d83a277abcb5a15c1de6898d3cf79a1416355dde0919f62cae8beb8563eb064ed7bf94ce662ee986dbccf955566760f63471ff5a1aee592c687cd5da9bf3c3d1a92a251c62403a842bb12e5912ac9fe56925854a121922b8fcb13b4c4588e1d4ad8acdde3073dcecebc7e13756338545b3e810b384a85415f333204603dfaba5ab029ff9f2ebf4ae9be6d33bbe758194ea776957ed1655b4a86817b3e77212b0d6db0bfe97d367a915e7020f9cbbd7b57a9abbcc6b29c263490b2b61ea4c1868de210fdd7cb15e9ae210312d4f96d22d9bab10d201814598ca4ca98047e963938b0ab5b11f66eb5268ac8578ad1e8c60faca355d8e0221cc6e5da541285ff8d61b186d7a19b1d7bbc3fb101d1333b75564ae0c6a9b10f8155b0a12fa6abe4621ff026c6452a0907ad60d6fe647bd8e57e046c103e05325538db731a30e7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
