<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"abffb712503371f73430fce4cdfeb1d3bb618da6e9892bad82c18c5d757b64bf8cafaa86b78111d60895178cbd64bb317a5dadf90e7881e9dd1b51c406294a4036e6aa8163437d696241d5d1902682ac0db1adfbff7c86c09c485d6ba67c69d1e0a4a264ed9c744e209a3e49305b92a511a4c0aa58f99e38ce09dc8ffa42d75c4c87f64289ed117072daab261e671f7682d038b647586556ec88dcd597bf9759009f800e5f65fa5fcad3b0a90f4c7a70298da655fe3b05755ab620b35b61821b7549dff0c3b8c34e1dc890fc9a105876a32064b69d6d566ba405da1586b6fc1f75293972a5cad197527b396a55fa4fab676f436f7eb17cadf237685eade194b6f5ca214273884b65398267bafee1532cd5ec9a6760ac196e70d5672aaa7c44c7f8dbd607cd93e733d0b2e8d7b03362d23a9932350b3e78177c3a671f25aa8116730af74c7468cf422f41af0fa0c1f13128067cbfcbbee24f73b91c5546932b5f186f8e6024f04b4edb5612a842b6f993f33a985f7cbc382047ff3f90de58c3017be68b2d5507cf8636c112387f6ac11ca2604834d276691459e4ac0398aa3fb1f02fb197fd4d36278405847a3d53337641d175553454adfe873fc6759bb53aa8c6568f3e86520560029901c7073b45285ddd09337e2cd2c9a475f131237a89c5ada297686a81a940e286540ee0f3b4ea02fcca77867bb38cc8a64413797ca1e86a9c940c0ac219e6dc3679c6b808fc63711e7eeb52d4d36ec990bc8c91837be490d2d1edb3486ce6dadcaeedd1998af97f913bbeb7e9941b8832d5dfaebb55bf80a18bfb8b6876a775456159fee23967873480ffc2f602d98033feb1c0a77bcd25223a13780245e0e90f907c09bc982d6ba6baab3c501b305a66ed50c450851059ad992ff7d9a189ea58616172650b5aeb4149b6fed22f4d2014d95d56f5e72476f50579ff576a76db549b658de3c2ad7b8c1be2bca8042b42c70899814f981d02a122ef13152870d259aeb3655ac6e6704f6797d48f09f9a89b18356fc9aa3af17334a6d8f9ea38c5635fca35d8ef2c92c3c9ddb779010ee81a794eafb4cc70397527bec28810248a73911e9d22f44bf9a9cb7d34e11e76852350404fe1e264fc5b55218accfa3017b88cb416377cc7b005c30bac994b986ec04cb7936dfa59e09cc2b1ce1d87f222a612c3758ee909dc5cedcb9387c00a5f0e49d2003b2c3b3a3be1fe44e45935760fde2c5465b71cd74ab732b783595566cef57e3f8421f567151466b09a4984cacddc7227445aa6780b01ceedfc2bda70e074f27ab859719098d0f2c84d84a6eb54d6f0a170349961c5b1c863f506b511d211e288f0c6e3554eebc8042f63cc690a1f44b2f8039863b8081da4eef0359fe2e9c6dd1e8d11e3a5c81fcca7b4c6ef0510d0b511def305e175960a39a0b9386ef6d4ff8ea3b05260a22472a3b2b297586464fbaacc32b4559e752602e688315b70160502699162524a9307feb4e5c6c8b7f12ada94fd01f902a165bdd44abae609d23ddae473661e965d26c9b9f0bf13ea842a2e7251ab42f7dcf1fa28b6a15c20e33f2581b69047b277e0484082a5e616ec9946830ce02a18e345f21956ed143978104d28ca8fbc3448c956f97ee5cb520715eba9e832da58233aec01222fa2c657142ae35a0854435d2fe788458d18d8ab421b297e049fcf769aa0e0b2c11de65ee2925bb8bdb8567488eb5eefe4cb9fbff167bfa0db8935d6ff139adc7e09a6cdeb0f623d3124351ee87bf52a7c757eab41fd31a6782e47062e6ce081b972924217263955d333f5d7321c605865b0d2a9d1fc5a23a7ab42ca5aad627145224ea9067bad70ec7acde5248517aef4e520449f025700dba6cbc11a614be0ef9be61f1927d22c413c046126e77edfcecbaa6835231671476ba109bfb353de8e551fa9f37bd7a1c0f63beb230761eedf83fb1eb3bbaa7778a9ac72a6ad0215e461f3f9ec7a69c83ccc906e05e0c42c0ce26af8490bd0366acca3f99a4bbce5ac186e16ade42827725f6e674ade2801f25e96991eee556ad7674316b91c52005c8069942b963d62d6f1163fd299003b105c00dccf3a11a1e92929762206b55a72ada612e26f33b2058abb8760a602389e02964447f06169b302cf05310dcb8ed1d25454432246192aa298d6de0b84383aebc97cb8b0bd800ed8a2c4f9260ac55c0b4240aa7bbb08ba8ce5a6f9374f72f3d1daef0f5fa305e643c3810d9312dbc7b5c418974944e5296d0e2ec4f6b36c31b12bc63f48afcc3e4b428f7702934f5caadce14507210c32d00affbb90383f209784629f346023414793ffc459a37f2a759f613b971fd29178f1a7ad1cad023160cb8a8ee5a373bec0a38b93700240738fefcbd76b651994ee596034b768d263ad4cd29065a7337d3fe58a96ee3a71b8d880cc8907ffd79ac18be84ed92c69ca7c4150237085198c5915569236a2bd1361e5a09dd5600ca5bb7ca56db05199046c736b9a32e12d2032821888267832196ad02732f45c798422622fe5d9b691d51ce184738bcee058fcc7b2b5aaae88456e772fbd5a7787046ec160a28c96275403908993e2eca5595cb4c23894700eabe0df6029b0db1fae318108e687d1172a7b864b43e07ce2335d3eb989294342a3876c82e13357c188a1d63c08de553936cd3412c7610de47571fe107873bb663a260a43dfab30bef844cce4664672cc1b474a5c21d40692fcf558b3aee898d6cfb613adeee9c513f545267160fdfc50f665e1e3a125838e1f6c2ccccfcbe6e6db48895aab1df8f48705a20ed55f75c5246eb7c03d1297d4b400f3c72170bc1ca31d7cbfbf5c76aa95394941785c6940de65d5521b6a28518af5ba6b695c2325df584a3cf2d81630c6373632e30dcd9979f989b18e666ac907beb3fd77fed7589739e4e721294f7d5a2ab4cab1382e6da16c53691e77622bd1a3883ca10a907451f4480b33ed49188c14d7ff15c4808bc007d8db2461bebc638aec1757a80f139422651f55bd57d767ffc5f2cd2ef1a725c489780d8fc7993fbb08e04b059374d034b67863b00ac5773714a21effd6a957ee695859c1f594e84f2db91930a3d3d3e67965cc693c380d605aa68b642e3070cf87cffc014334c78fb65b4873fc0c6106fa5558c7ddec4769d5605470a2a201f375bc380c41ef3bb94816d2e4a66112dcda416c0aaf93d2337ecd4574313a968159415727fe982715cde2df98d2cea0923cdc92f485d253053f11390cf88696b02da55a36bfd0f593d9de4804f6c8db51b0d2717f020aa4bd772175234251d2a7c4efa79cc2b0daa18676ca99f681b69cc9fdd73f7bf2219f8d79d3edb3dfbae402347bee73e3dfe71e4a8a0df3df9d7852e18a4bad360d507d9ed51668d92b200b5d9408fb081d78445a988a34234d346c929bd86d603e99af0b475a4dcfec9a2e2edb3b00652109182c6016f0a36ea8f3c6fa723d209af1f755464bc3cff4dea9908b97c6301e2df471db17bbd539ae44758f098bf95599370fc8c10bc8d655a1dba79fe000c3e3efe64abc87274d473541f8f32e8b5e8a294fb3192096d52339c10cf3e95d3256c81a190d2dc49055673f542059d306780e0083063d852e9e77607b1d3447a9089b0629d3ddeafaa10a26e12c834b86887d8a3485885ae463954050c7d46b7d30257233b29bf479684baf39644260ecf0098e1c5939b12234676ac64946a78b7037fb55dc8b825dd25c3560269ea6bf28e145b2af02a374a2d927a83db906eb584161077cc4556608847cac90d783bdba4e8d9e068172041d96a6699e836dd5772b3040e5e48ef24505892a79a5ca299f5b565bc3d6041c8fb3c841a064e0ad28fcf8318c67f9d5b3b19b47f743c615613511532bdb83292f0a175539f4f61240905df000f4c5be476bdb0c3f1eb4f4c38ce7883308f96b83a3cf1d34c47ab71c4c6c4c0aae1b69e2d15254e9c151c11a0dd833e5c841bd0ac114822427eb7ecf982326a37b8bbe0a5563db86e09ed0954305bee8a33c009801454da64057e9291265681a3cbcb01c9e78ec9d5814afba2ba34511ce8fa31f0fc31b650b1f4a8073a35e2a392240e61cad2abb72eab0c3e8ba1e69c621dffdb512bb046e2cc235026b48c7c8ce72efadba18dd828c0332f7895138f7fc2952c2b1af03033486f7fa8afdd46480f1ed590eb7d6961e602d7f00c8bd7360c6496181b5a490bbebdfa27190690fbf9c1e7a6e60afeb1f1613887def89736c638400dab64dbc8eb0323c4a55717eb7769231654fa3addfa205b26ff038899ec44164493fc166f03f4e39d9749b729e3edb5776ad396df4cb1cd5633963e64cb58436cdec8fdd3047b3bf206e568c9fd86fd5ffbf91ef504b9aadf7a6722b2556f6f60c1ead4841ef8fa38eddcb8516a76ae9e8c266a54ec7fa4bc8d95e21b6582c993ef8024cdca5270eac6a98ef4cc7cd0edc2e312d0d66de0ba74fb1ad9e4dcc9c982163706fda993edfbaa96db0d8c4c754cc28af6ecbc5d1116f594721b8e140657aed7cb247dc1271c06656af3eb8d392200e7c0748272dee32baccd4673930bcfe9528e9e97306c5c245ee0a349203d92d880a21fd4b981d0c31150aa72677914980082fbae2be87624535b29f97519132fd9b59c63b82cd6f3b97e29b9a5a98b12cf4aefd65a6ff1bbc31d582efb23e96ff090a4be38a8648a5fa95195c24bbea3c684596f84f50ef202831e968b10ef3f00f70be4e008c584427d382dc95c3d32ed514eacfb4e5057a367986a95be10cd3e48d347c0cafdddbc3fe0eb11bea180e2ad7f0cdd590f5b4ae25f6d548792770bbd9497e864fc82897247890de81ab8bbc1d8b3b4bcdd45b300627d76dec6176e9926de7aabf2c89ecee27ea0b88da2390fda9538c8c065c77fecbbfde392108b5c622ea840efceb5279a35f3a776081e974d7f2563608cbdfb9b67ffb196b1197074fc815778f1d5adc1f28abf0c41fa4c8d445d50ae13afe1751f6084b70a3bd792fbaa2d5153cd1af41a710002b29fa2fd7796565fefa1371080f5d913e1837aa0873adcf6df6442b11ecbf4c1c7728ea52144f8ce880b1ed86ff7687b86755dffceed3623772d1738ef7ecde58d7be706cbf63718ac1cd437f4dab7b6dceb1d29b0d44281a47388e0c98c3333119fccecaaa710caea9d085ebeabd7922c91880f6e8a49ce11784ca25eed37ed29fab9f3c5aedbc99ec1daea7aa1150cd491834ba935c1c644e8b238f4a288da16ec3ecd6cf7386895f96eebe06a9a6117ae48cf51189cff9f8783ca6c581921ebf9c4513bcfdef8c2f95d2ae8ec43e19bfa3514fd8161850520ee07313b76b062e1fe31482634863a688b6421c1d23475846bb9fe0eeda0fc5c7db2386cc06a310e1399df429280defbdb330c8a23fff1bcee6ce49342964dcd600859192772420381648898969bb2e37e6061cabfd741d7b9bc1873955327a0035d06ba56ceeb02a02cf11fc480f36afb40d6466e1d6b6ff05d6c3b8265da3dc7e84c696eea70f1848e8e4ddd740a2fbc2988663bf0a0442ce7882241ab454a9d0412e28d05cb8c2e0799772185bdb454465fbeae2ebc6eb87585eff552d181c0f60bacb1788752bf12be9d2751b548a11c6b50cfa99d6641f85c61c807bf292d4cc9b684545dca0df234fbde502aaac42f8afbff04553ba60dbfb3f1800ee4593d1895a2a9e2f024c9bea16eb452b6c9d4980af69c326f714f11a1856c7e753c016b33061c58d350ea6dd72b29e413fdf8f58e3d9f40b082d1fea481a923f42ab5eff3a41f94e67335198c28db4f30bdd41d9a04cedf15bf02273160683606813856e3562c5cdcdab2593eea82c569fe8d030b2e62086d4a80bd2dda8fce073b8d4e469acaf45fc74cc25ae62effcb51ff97fc30dab7ff75a4c5ee1b51524cc8c4f03a83c01efd4d7c3cf04b92486a86878dadd46a527b0904b886dd080e128e2234067db19af4f12b4deb9bbee7c13e8bf477c4cb8cad0f9edea93fa2346d7ecd0dd09c7f28aa24571a5b315924d02e4c2317f5ba466eb5dc59496d26d3afbacb3d891c216de825c3813c7f3e46360ad3bb0b7895f60d41676b32b7a725d8624efd884ab96810e08b81d268d68058b1b3c149cb8db2dfabd2b35d4a4c1d7e0004f75df39f1aa24822a658fd38ac1066b254f6a7376e07c9315e675cb7f9e5dce146e8857063ffb570c6f9815fecc87990687536318275d5600964d1f03ba3b84c8c488e8d26f8f652d992ceaa014ddd4d0f83adde8e7797593e98c4c3c4f510c47c6fdeb36eff4da0761b2b933b2fd84dd04d302d67e4745ac254d81804a8506040391dac98dd32b897d848563fc427e166017d63e06585c4214743c457e3c69a8495e7634c00bb8287a13e2dd96d50704639ba9c14abd975b460750d84321a6ee96320f34fb91025427c392be0a5fea35b2870eea99df5ce0e646d5466a0176dd890eeb2576427a1ec9c0bf2dcefa3858cea5a3fd7a85bd32a62b61ed343d505f904528f66c722bccf751a94f9567104655a1a2afa61604db4d8efaba1063a94c6eddc090cd1ae8b805c6b5709d05f1b08ed43a192a7b35d582da4e138295453f68204da5953fbda25d1a928902e583ddab95fba5c349c80d7211d871cbd88630c4686a3bc067dc120b30d4fd8eb29b3b2727da7231dd64d595aa16e726892f40c47965723eedf9dcc7ed5a0ab97fa9b6fd670372e82ccadefa96084998b4f4f33239d623196ca35b4b9cf9f06b8bd8c12bc58c73c47db21147b867b53e5b8a738218ec0f407c9d58f434b03e74054a4188d3235ee475e8e6d543a4c2fdb4b87186aa9dfe8b276a599ddb72a01976e9ba1dae0fba4bc8f2e8b0825827bf5e890f31cacd70504b577f974ab0f52bc0638216b552d909be3e9bebf023a967dbee9476dfcb6c2d4261cb7f81cd4203ad911d1969965dc0b4d1d73b7ad4b849db1ea97f37ab5a2e57b474b8fe0093d04aa83fb7370b43d6886bf8717fe23494ab7838c7c7f16c5306f77ff3e14684f57543c42bfbb4f1e3fd810db6f478d3383cb27cab31f3f59a21a3dc208b359ed0164693cf6abd66c71d444fe614d0bdffe4edb6a1a60c30649af2a86986d271260af5c6e164850545effc00c168d1b824c0e3ab70d4e6bd71e72b278412b09948545226fafb7c0245b2d6f13cd55202fce9aefca8977bb24922cefd92439069a45e7ddb87cb9782af8ed5ee64bf16f7e2aa5230f20cfc28d62038223a51f2a7a372fb6306a2be959d6e3f8263c68c2748fbe320092060238fb878343532b6260f410f1f97b9fe651c0fdf4cdb8ae6678c923a9032ce1b29e9545efb9433c009bf6f389153c8c8af0509fe54fac58502c27c18094b8e772d0126b194b34b51e0cf7c5e529f1f9cab48201cc42ba97e0c462b8fd4b3c97ce6ce6ff6312a82e05e62ce5b4b31caab07f93ef1a46cbc6d600aeb73aa6a196a1d1ba8aa44c82656745059ae1451bb07a450eab622e246c2a753fdf3664c8716d7fea2723f65ddd6141a735800a1490421c6be56945cc12d47e5a212a7a5c5cc2227b91de6f338bf7f13f193bd454e934e81984d4f04625f9c02cf8c3312e5e864dfb80a7dc12e24cc82e7ab212f16585157e910457e54b1491852d9712408394abee86265997278da57691ec84f17b522183b5f7478b51912ff9cead74e28cbb7832ce9c3014acfb4c8038f5bdf6cd4d5914bdea40d8baaca96b8369b588d01812c122da591547dcaefbe3a27af9b3e4c1f69c20161a8d6802fe9ffd909ce95f8cd78591c4cbe526df37e5a6b54e6572ae5c26babdd23dc1b0006db318854e07c00f83c21b94fc7aad7102bb0c9aceb5eac0366f4b768d0e1e84a8729bb2cdede4a8591d76c6585699b765b3584ab2441e51ef29bb78891e623b33b84a8991177bcbd98ec1968aca342df2d48247b1ab227cc5f40c7c36b3aff2978b9920ea80ee3213e474d5990ffd490d2fdb67d29120139f844156414a3da873b7ed9d5d5d339cf120010525274eecc3553f4ffccaae5c7bed9e182b90d02788cc3b50d584f69022e68155d68a7829d44b7ac4f764d866034d7c1d2219343e13d92a0d39189274178405b57a5a4931612b73cf1f8e0a90b6c4bb9af1f6e2ebe3b1caa8458693b1aa0b1dec56bd47d0280b22388a659df470847a1727319cfb8767543fb8d75acff43b87789597f63cab897a44fffc7044b27978490e0c398e78a7b53c2605fc92e3154408e6b6d20b5545127b6ab5497309c15082e80fed331d9b10d25e6b10bf51cb3e4f18b7f0b53daec5f4ddcf963cefa069ff6e73200805f734095e2b064ad6e85b7a039bf3ef4a0c84c579c6ad4a26e49f7afcfde6a0a9fb3a5debdb6748d3352a174917aef140602c15ce381ca060630c58e5aa072c0d8e825a5465226fc28a7a0ad82b8d462eb9f64c85de942d4b1e7d0076c59d90e9ed1f147f2c3ea3d4be1986b7d64be1dff2a25e9de2881cbcf269dbf39343580bc57092436ac2d3c10bce0194b0604bf13bf1e0158b608acdb177568ce11dbc428f96a8a1bef21b36eb707087f61b2623ce7f2c8d9752f963a4b1bfa7c61dc6220df2ddbc9a2253810b615664403454bb7b4d94afb8f719c00ca344622cc492d61d0f59ac6c33af18cee7a9308d3ea210ba37005e08c0d61f87f33364d711bd58976ee7ebb4fe8928d57d4d84f846e9c62714d8c8be267c030bb7003d8a0effd108b94c287c1dc40122a308208762293e4048fcb30385f41f21a9d14b3e65ce6440a7658630576fea2ccf48d58c52438a97855988f368fdbb37ffed43c0ff430b6ec18fa1d9400bacf932a75fb7915535918fa6b8ca4a5a47728ed19bc7841fa53f33264676c675214472e000e039b7f7f75a5c1f619ac4474ca2f968f23a328ee300943bb789e8ab03d9f20403f200db9f9dec7897115faeeff8fb803631d32ef1769f1750e1b8c9f86bd425b9d509df4a8aeb278b7c5ab3ad05d691d0f16f179c524cca87be80ca0fd11ba3e2069e0a3182a09d0161f3c4a74fa47150ec54d2a2a1735b0356f47367f9abc3c503a4d132d4ae29608ad063649541a1a2bbc5431663aba502c06b2c5469a04c0eaad13a359ab96dc4b2676eaaf29001ae25f7b7996219d7e9429a19bbc6d8581b04538b4fc2bdc0d73fc1bf0361dfcec1e797d4a02d674d830f4d65a821236cf969475e861eb7c5d8887b6b426f8fbaf7fc95095b974e3138254784e3bffb7593a7624565c707a7688ae4584ffdcad19a6ab76096b4a379f7b33f422b46e3edab6373c07df5b595a3c45bdcd2070f74587fec6f3ec1f11397e155e7d189693dbcfc319e80d582c76cad3b205fa8faa39b46c91b2e3d0994f633f72b3b08372176be5fb12f401d7f7a1c2e589e93f4efe432d1f15ce413dd4178d581aab7de512e1a007bcb2c6a3fe4d5311d0572240a0c7f3209d041b3aed14197429e67ce8b0b37d43fbc63c0e82b413b8783d3edc4086066f5853580b3fbd47d84746ca6c8897ff1479461b6cbbb1931dbe77f5e7e0fb3b6ff04fa5e417be47639b2a08094e88ee9cedf1ac29ee732b1065d23b8eba093113e46d19a5dda94fe455c50471b4911c10338330c4234eb15ea5f9593614d21f0b131430e80e6e060632d4d88698b6ced23047af771b2aa6d62d3abed7569e4b0be1a4f0b1914ad6a282587a4bca36e1ffb897c10c8f70bb9db5e2356c4ebc05be90b3807ba35cba92ab44e04b1c7b2fad8c8f33fcc1d9d0cae888967e885d987323bb9c77bee133527ecd677e753645ef0f63bd93b8e98a34971ccafd15ad2a4b65990c7196b6a962c509be1b93e3645efa01424fd11e71d3a2355806e9fd7520bdcbb68646e79f1bb6b551a1e06802f3fd8ea414a5af93eab16420325ff85e481f3fec70ddce34e5a1eaf138ea4333c6707682fa2f5fd5e658c29cb8e3b37be16a9f63bda22387cad98553a85a97fc887279b3cc295e67707d5b7e08f931cde6dc9f328ee6bb86a44258bf67cffd2a1242a503903aacbf49646a61b29e96e33658a0dc0af332942a4c1837cb0f8cbeb0a46fcf400f3caa4f46095b74954c498a48df96bb543664dc39f5e802b9bb8d9ed60e73a9054e26dea328f989802a2ddc2576e0e7327a58c4db3a67de5408a9d7c76d0d8c4b97ba2969639d582d2ff52dded8e954d54d6f7fb3cfe49edba4b97c3af21f06e2b8e971f278a877c2b6ddd7134971e3b29302e37dcd70792947674634106110e2b48947ef44fad4447cefa0d60ca5cae46b6a64c15117300035d96c9531805cd31d2594f28e709745ae7d35b6414a63c3b8547042fc41af3bbf61becb1bd00465b9ad2e85966f62e58a7e3e886a5cc92cf0c4d33ad724473813303a42ebe0f84f69ea658a7192982def30dc23efe94b0b16f807d9154dc84f4e188dec734eecfcbf0ca6fe0cef114e90c7734514564a600975333c980f022b18cd4c2dc063c4da0dc86bfc66f3bc85519da7bd308a1b5dc4f9d65afc4a9afdc5f5f30d22901118442ceee4f9b64afcabe6e8156ca9028948fb8cd96fc515458715ef1fe76eabb6af6c1362c5658721344930c93c82875850c16a0fc7e991dffb23ba76fe248c3840fec49edf26fa00f98a0b0c8f4481ffc428111ee276b423c82c62235ad9fb5ffd0358e9248a5a9fbdb33ed622d602faa78ecb5e313054c9143f47bd13f19d50c2a7ca9930dfa491129231ae210f5695bdc1fb3d094dbad0abf7c2454393290d545c4ec56593fbbcb9b6b6ebc9d5abec5d363ca68b3bf9dda9d5c98ec5349c31ecd632ccd2204841c4cd24435fdd8a5b7240d2efde62e71fb9e7b69cc6bcdf97ec51024a2dcbc95d5d0392cbd662e7429670379e01305e24852335c3eca3a582f93e3e233ca117f15e6cf03c616384b32d608638bcffafb55502710791e8ef3d15972b5dc6f9f85e68a62b0fc1c6ade84a8942330f5f49dc0794eb57177a687b39d5c616e826f4f9d1abe1dcddb0a3a2b6f53fb62c7cd0fcea22a7801e9ecb8b58be2f00f1511a0b214dcdd43365c8344dc9f22f914cbcbf13a0a5cec84661da2f9bf92c61c26fbfe6b05f3cdf36fd51163be3cb434d21d49310a28392fa217f04a4bbcebef54622b9c2125406fa164820ded9a826fa8b497d20dd4a712645e751c909a1d232cd046b6ee16f945931ea59c6e0f7da49601382fcbec23c054c8529efe421ca3a30549fba8c37fb22431fe6167e68f932cedf391dd958a8bdfa30cd42424e0aa6565e139b3f7c9af8627330c5078c15d33af5e442575a897f73d7f36edb7e441e86ad6dbb93181387b31ea3ac22d61381057a98e350bc5ddedb974546715adba19c7691550f22f034ea3ce14c5e3707222817ac752df4d0033055490260534645891a9269bed8b1f95ff5579cc7c19dd29826695e3c957e259faef8ba2b6c7ec5df631fa685fa0b0599fee836f4f941970f5e23f73c340e72e817bd21323affa7811c2b92e84d086b7aefd233c3789b3f0edfcd6f494655d7c1de06a25f97797891e347f936622c23b9916117c672effe288d3e9be14191be2dfd16cf72fe8fc758a86c1e832de9a245fbcd5920aa0a9ad825cc34f7fc8f3dbf6c0949ef4eef90025a6938eb19fa51209bfcf4c1ad6e2c8394ef8be3bed32c37d7e5d36ae60c3ed713b0480b0238a99ff1836e1a9638409f2ac5e3bd1f82cb4082c2364d13842c2143527e12abeaac641e32631aeaf490ee81291cf9d93de83dc9487a7c5a919ff25d40a9cd1b6f9aac3de2b40d40c6ad4748a3d8240a8bff4464cc7434b9ec9159f41ac1d3abca3ff7cef675ccd07145fcbcdf183778c058fbbf91256a52aa573a616260f553125140da8d8d89c91717cb26eabe240139d6b70fefcc9baaf3bdbaa765944601ffbd6b660a878ba2500d60d6cc216aec8f7f3598a1ec8d5c425dd0e7972ef433dd8070d774f98957d3848f999a0d37f6fdce2461d96611afdaf66302c3f00a6cb283cc7496fee7832cada6485d03eb6b66a256ea0dc4e8590ef187822d18109d3d025ed829fed5baff3fcc6940c94a1d1ed0f96b376f8e661667290f439f10f94437526a1c3c9c94ebc0042e9a13b7d4ce8b4c146087b1623f85124d478e086e71e4d398a80fd8272e7de1318e55400da30d80bdfee6d217b9623711ac4b68d84c0ef9990d7db6678eb2affb7e5a87d1ef85554ab0faf2d19b34ab7329b4126548165435a59c0c37307974b4e48074306b4a6e64a4f118b6e8cf3536d1b44098700ceea4d5227a79beb28c5d210affd786c3b2ffb183b52d192d1ec66bcf4c26273a54aeb0639e68ec9413c89e988ddb78409ac3d7f9d9b804bda359c3774ae1ba6f52be23503b89998666cc48ea65a9306d924a558143496e910c595d0009544050f866573ae12bc05531bc91da06d95a00cb260625243f6523099d08af86aec468253af37ba9674e2e64a9313eb98af14ae8121f37d1cd93b7afc49fa3d04749505eafbb46e0dac7405242d0d4c502fdc7ac107a403c9f7790457925457021082f272b9a0a9531b4e7115347bd08cfd2c663e3d59d5a46559c22e80e23b30bb06d55db15afaecb0f12848a7c5ab3c7014b1701900a7e5757c5e116b5593bcc6180b43e83dd160321f4b0097caf64509d54a8e86f87b0cc51b5bec4dd2103e0a5a65ef7fc5153451ff6f7452f43bd093213aca82121cf33d81017fc0984b5701da593e41b8a09b52562bead4bb9cf984e387b625a0dfea73918aab5b9c386b4ac2204a45655b3f5e1e5b5a4518cb59f6eb712c569718706824ed9a5d28b184a829929285b07b74b7dac1540358d2c09138ef4ba5d528f95393dd69354ebd08eeca5d2b0523fefe553159691de5f9a57430dbe732eaa56de1a875731bc92848847b1223f36e975c132b53338c046145eaa31f6022123b157bfdfac742278566bbd2b07c3544d78883ba06d4a4497cdb4d820fafafbb8449ddf734b33202e7c44d24478fdd0429741181db44883d5458244dbfc110c0009f596892709b9327cab7b59b371cb5c2df77e5e15c5ee319e8bc4c3c72ecfc6ceebe05efca16e4be8cecfd1a3707b93ac80cd6a85998a726abbd32ef7228b575fd481eb0ac0a698acf4b5e2c262239f82afbc1952473b02d1f968d7c2ada56f631ae0c523e4702604f1e63c39ffadd1aea44da015e9b7cda734941d25b600ebeb2a1055580840ff60fcd28e3010154013c1932a8ebd3e5c71a27a043e59b795bc1c3ec3064f22cda67af6c0da55d94e080e25a410f024688d5638e1c7d6bb2437e77eafde953f62cb00d35835449af8e5babb2e27b7efc7bb53a70f0e8697b6a7f25eae5650c6eba7b40527708f00376f2c3e310f32455aecfa9d380cf26a5909680e0e7f2fa5dce0c5131aadc0fb2bd7c7147946277fb47abed60e878bde47612e2de7975e975208535335cb625a8661a3348daa069dcd38c1c9cf376e4ef459f15927004a58bb2d9f06417014c71be836d565588af50f2f5a88a0d243cd043422ef7c04d84dacad59b6567d8a2b0f0a9ce509eab85116a8463b881b7ec698337a43419b6d986e5deb55553b8f9c132331931344047e5f7bd40eb43c2ef86568396cbaa636f6afe10a16793c59cd1da6047e4ddc81db1d421ce5b4e1b47d1a20fd62bead0ff85b6dda10836d7945e70ef1cc341c2cbfb4974100881e93cd3a9d8613f740e9d8a9d32b325610a792a319238537acaf9cd04ac348ca1093d8f49a22690e2e2fc1a791423ae70363c48dfee0457fb422a96e9b77c3b1491e9bb2e457ced59cedb124ffcc8c162ae722f43610869a7d281df8e78d986ae565b7c01f8b911322c71263076c355823b7bc4ab5e024c63c866c37390badcb067f4430e66ffd90cff5939cb471dc4fc478892b4389b20ca101ee5c0340ac4ffcb4a662c76ec5bf1829db33d99d9559a37e8a6be77ef30714f638c328914ff8a5a009e3318ac187bb4c21352bc7d29dfed2439a8932f3c0e26df87abed15af3aa6c4c513fbb8316b2375bee6c717627003928dcf906a182565e090618bf6db0068c0d1a1763899ebc628220561d5557061fdb1d3e4e8bb77920e1404c6c2ed5459fb4adf05f4e6a4cc7622a85a30547629fd8c1c4d50c5876c90de25e24d2b83cdb15f775d8089edc1ae29d8a3c3eabb3744bab07f4dfb356465a1f1e8a45d25fc76b62f88bb1359e6cad40f9de77fd2ab8b7a47575ccf8eceeff1b46554b354e55ec135d97e06dee1289374a910d20b26a83dfd4ee601cf4c030a4b08037a634a074000c472d3cbf20950d0529349ca0d5b19b6227cf611b80c4b85f901e5a02434cfb69b52559a3e15f925b2d049d7fe97caf88b86261132c6be83904a13692612e41a6fc8fde554c9861e008fb0ab1bc393845c5d450827aee15f14158e718770ab232171e74b4f7ba03df9474d16957243e51533a1c06a5351fcb026ba39b31a43c9e1c18d3c2eafa1dfce2e019c302e1a86bda0938c0ef8b18136bbbea26e746e50b0d1bbac04f8d211197bfb21e68e6930f91c5464226364a3cd8e24d6c363d8b48563cf9e8c6cb1d3594d5279b79f5077c3cd48b7f935a6d0e3c3a67a0871712df85dceb48a0ee8449a16e631c4d1091f309f0a39521e58a3c97039f17aaabb93726cdf9dfca4bde383b478e7d9309b732b2bb9bfc9caf6def62a1e38a47d78e1062428657923e970a514c60a5a0f892be8173d0d0c1ca21f40af578f42826046448de5a46f4ed678581a821cc4cd9da44751b5b7d9597930b4f4ddd8d2acac78248da96bbf910d921d1e593b40afab88890f4fe7519aeddf7dd79595571d29d3139f55114efcec9887b5e8e2018670031950afcdbbb5b313dbedd728f33cceff93ab5b4ae32d33ba8293ed6ff66df7b67802b94aa7badffe2cf5148fc8de945e1700d98835b708a2a9f0309a98693a92015694cb64feaeae0b07945f415063b5cb103744e6ec8956403d0dee49c46928b543c56afefd35fb4df9fc4ae5e5e2bb526f3a50d0a4ed592104483e6c0a757ccd3529b0b128e25d56b6f5bb02f36040a29f63c0b1250d999e756409c719607fd586b3e585ce9e3529b01f4585919c6a534a0ac65f20b165cd6fab26d025c5ae8b20c5040c6707487abfe0805e16148225f5216b6ecf755b91fc010ab5eadc672121ee835e5c5c00eeec2194c83a7f24486b3637ba36794329bdc48ae26812791a29fa6f0c562a313306181354b7a140036e447b005faccdbd75a871746de8fb4d19c5ed492dfa71a5891c5176a40fe67a3c166c5ecc94f9f199a92a2a48bf711035881d0a9468fbfcdafce4bd65923a33f8f3da81caa502425c658d78ff8fb087f99259b6887fae286da9c92abc3bda61d621ade9ba145469400b8c53df62a4afc2f36b534e5d1eeb0d6b0ed7a20c7e29d44cc2036a36b2d8f2fb992d728125390e4e389636655f558c17cb3709373921bebda5caba5eec547f077539e6bf7cbd014e66b2ad5a0329d43f862d098e13de843a447c97f7d2c4641831056a937bef25d60e2bb18245c5a631d833ba9c2b0b41b1c186838874403053b36d116266300fada1d34398dca0afdb0c3aff351198a1a384e1d9e0a5d4c8f3f82a18292378455c00971ae9d1f544ef96573bb8eb07dd674ad2892c38cfbf14402b78d6d9e35574815e4dbdbf867880b3aeb860aaac63129b95f6dcf465afe7586585dccc3602681e2734f459eac3b91418a3c9fb335a3ff9f4723f2cc1dd12df715713a66c7bc8cf31748e7ab78615d59e817ee065290ad2b085da0edb9d16d4235a7f85eddab4fcb641cc19383d8ecb1bdb4a6d1b66d837ce34f2d0073df4c5612a1e6a95e3c2921ae8fdf1dbe2fe27429812b41dd017aa861197eb84d7e589f0be2685a790a0fd4255e8febdc6cb2b93dd52dfc9c147b6e6ede58b918bfcf4251e3d510b6d5c5e85a2afec7a507340d3d8bd17bedf60ae452d816dd3311788f59e9a981bf7051c2f19f8b2691bb0cde2b42bc44b017b27a51557a0fa9e8ddb253295f05160d2f983801c65b2a7229743d2879940bbf9fb17e22671b4016a223f2617a8c5b0fe58ebddec3eb6337a0bb0044eccdb00b56ed4b86291012dcb0822ec8fbdf0ef67102324e0cfad08ca024ebe504e68e63bc0495c93fe4c38d5f07701b997ca5fc88fc5a8b83eb05c99ee04d97af051b2dfea0cb292ef4d1f5b3be1cb5166fafca75cebd6d8a734d18ff980930f456090128e3dc84aecae2073e74caab0ca267d520c266b58ce8319b4295135b7407e07844e2c64c21501f43aa3a961847bfd14e225bd88f19b8c59b8d8d1fbf41f851944927bbfb2054b9734ec7adfe15b47700d8be758ff454463e36c1f9022b9a23f758855257df123c9f4b66a3c9ac61f8a3f812c12c447fe188651591b13c139a18c50b47c8db61d041fd1985e187a9426347feef923033420dd525022b4a399fc733d8ab2dae6411cb006748da18f691d77406575f8a356a61171c21f0eb099e6550ad90824f252af4ca29380f7f5921b1be14680571cfefa1f284d4e3e99b8f8c67480ff35e045516841c3b050ccde9c5c5518c6276971773a43501f48c44517391ccf0b567fecddec0d04f2677a27ca756ac3d69e48cb1c50f5b8211a79b2bd6293314a17c8fb47fd1f2e4c49c659c1eb8aebbfc07b24c33af2d0eca4f76af3aaafd382e3390777544134d26a23f27a0c56bdde3d96b4c2e4c6e3ad23ef491286127876722769adf539ed6b8fc68b0fd37c72f7211193db828a77dd523be01a3ab2d9fa846c5851da30729b4320ae83db40c6fa88153a0eb7a0addd94505409df77ee604eefac6c8d6dc4cd8b7a4740f1537bf5c7438e65f6cdf41f0a4ed6b99c6982161d7ce371f779dd91754940d4ae7be013410ca8137bcfecb751956c720e225b50a52e9f5227ad12b3c832a9ce904e3d0c8f5d68c8e1dee591311ccda3570c858709ad089227b78695a9de8f141aa8abac92e41c1c14579e28f337983ca2ec38642fd9c339456ea0d4a1836d80ded86d8ffdd0ea0a39b795eda5a0338bc7ab58ff1717f3790f8bb492e2a174d0224014ec0a7f3f05c7b2299d2197a58105292d90246d62ac866a53b8c08e300a98a921268c3efe4bf1dfcb71a4c5d7f65876dd219d5dc424d8dadeb6961a60b92319fc57fb48b0b6bcb14188dd6ff46e4e62f501ed30256a3da9762588c47b8dfb651e9cc8251730ab5bc6146bdf8c372bc7873ddb5c511c8b56ae1e8efb0fb082767feb5a9f3d680d07316ca716dcdee1ff1e4fa990886adb82897f88c27513c69bc63acb8d5378047cbefc9f39e20341751644ac1bf2d87d3afd1bd119c66f17b5bac42a879d7b9fb22f67636833cd912b53689e2bd4887c604919b44ecd7a042304026563afeb69da07a387e266e4f296aa8a2c19be31724898fc1f4c07964c600a582d940ef62ead52788cb55234aee8f7c3ff0e3d9145939969c690aa1cdda44c2d36282ae45baccdb1e5c6e9b72a54c310c9402bc7940cfd3f79da12daacc41f1b63286c1600349cbd89cc976e7dc2ed59c3d0f2f2d76e56b3d6748f0a2ef192365d4501f5a7b6e2e53fb05549cdf19d73e930b04da41cb861bbc7e60994cf70de31fa2e4e3b29d6c1bc5949d882f8f1d9739f5e57d14774c37ffaa3235be0f4dc86760a5d8cd7f18a0194951fa9c5a8193f99ea7d46f5900a8c5881d6f0b33e70dd003c1a2aaf2d438fdcdc04df7c3e64ec552f2529cec032650e9652ae56399c2e150fd37b59a3d54487ba4cbf2518bf2afd586de067f0bb5b3a5a6e25cf8e64fcde762fe45bf0b2a7b9c20ae5bbdd4b0a0be958cf6e09973ff9eca15bd7ef310c0876aa0725a24bedaa4c867c14e73898f048f4c1c0da1e53806a94940112487772328d99f647505f93648e45ebf0259e1b3c8bc0cccd0ead955b238867d4ada3b576f1a73781097900e9722dcbe9224a7d3e8414ec7dc62ef1576889b01ed939aaeb2d06c338a414b2a207a9e8574eeea9c7765f7c23254d7e9ff0e0da76280e71622b64b4486fef9f964406be2651d7bde9a416eb68b287674537e1ce882880cb7d2b0839c0274018e0fdc17ae1e5b81bdc99fda3334f238468b68185f2cc2b1477048a64e33e040ef7517028dabb7fde6fe38c84cb0e95206ccb6ad677aae7ac647edfb0b9203c66e60709371352be7d3d2b086f171b1427356dab0af6c9087b1c90e4f18226b9260c226c04310482cf9ab0c8311eabb0c136ccbbe3f301fa9161c80ba54e13a29197f4cdd9f17535476f6c676d128bb4919518ce2bcb2fe8b405613de925e987a3d36278a97552b0b53ecfc2cb1150e4f29502c282daf0c4b12881d2665cb2cfe4b64460f429bd438c0847c9fdf098065943c3483532f4cdf2543262697c36508f2cf7445c5a9665836a2fd2c5d5de069bb5986b53c225777256acca22bdda915c641f8e5a3ff664fd46f0aee501c3db74a99d097866f60f5ea30ea4a7c52116e17454d326465d31119b3caa5b0814333611dc1ebe53f264094f9f189aeddd3e0aa1999d6768a9c246d0f3df65f421432687bca7c30c1fb77bcc561cbec942236dc3dd4c10459daeafc9abf7cdadb11136f844e66101f921bf531d99f819e563fc0b5395aaaa28be3e5f332fd921ed8a84215e1ea939cac58203edc9c26c06540170a5e3ee2df23828bfe412bdadc959ae5b2d450105896d6269b981dcc656ced98dc7398c7b0d5211c007660e33c4622b08a9e0906049af8149d0301ad8cd53c79bbb72d77bcf1da04e49ffd1f794d164a0bf86bf1e197dbe5d50168a29d6dc1b9a26ba6ee87ecc9899f50f3fbe7dc82cd3eaff3c031115aa21286c5db89f8e7ae5b2cb7c56276e25d983a3d33d28e2fde2cfdd3c518c1ca1981838a4cee5e84d5c00128d1678af40cc833c368223d69cf613a754578b82ecb7749bb66b2923f269bfb4d9050c2ecd6c3e39d94b697f8cfb3c6114b45693fafb8cd6a7794d015bad6120b932d1a3c2ef47c028ea2c82a69ec3ea783c6b925ae44398ec1262db4a7bba5a9664febc822da539b19b60d948145914d1449f3589f121092886544b3a380a8aad4b701f3a3521770046de1936cdbaa928d87a365423ce52e157b8439a126fb3d5c8d00076afd270adda9a320f493553416a44bb97cd09a2e0cbc58ef1295f3f1a442c78f7b457d96e11bd7cd5baa1ea740f700e7bc7499ff88cf2dad83c4f892679aa604f1924ad52bea8d51ca366c504b3e67f476a56fd16295a97f996c672c4a0718353c4121ac4d158e5bde7dc992fa173e8aedcaa5fae0a7ea14c835146d6712810be5f9bec8076179a730dd8a05098ce1dca36a0a6cf2b38088b1b277579c0e8e17ab44ad650f4239690c15f10fdfbdaf6d35907680b74baef3f1c5aca5ad2f7a82c70b998153f00158c7fffff37bb475f0071835f59739b76ff06bdbd10bbe8697020f04266028111313ba6c967fb760ef813c7b623cf7e185dbe979a74186f9692d1ef05ac84ccf9bcc91dcaf0743dcb61ed609d8c457741b5eb2284e516f8f077ed33b2f0a796e7b7c529fc108e7e807c1415296e9ac4bf35bfb795ceda172b63fce14d9d94b3b083e97efe967b6e09203b4611ff38b410948d38fa9e052bb0fc8fc0eb74dedb7c030f957be8673288f9a3edfceb2e82bf1e304bac297775c6f2380b75786806f05323fd55a23b7e40a1f520a0f1f09a7ad84381d6e665a68ee6678a17155067861ba7e0a3d4a21f075692e11758f1709b171e3cbf0d81073dc03835ef42a0e43b37cbbaed55e1f358c7c772a8e7c3b92063e39ccf139ee9f51812c92562e254ff5c44ca512729d00cdb8e44ccca18906abaafb0313f2044587371a8bdeedd4fbcd8a0b220fc74adcd906497f4f57472d3a1344e4b1b3cd8bb8bad5f9abba104b3c45f8f9c595df4d4e8a5590c0b1836564d998af47fd63bada35b061d8c1feb0c404e4e889f696ba051b5bce93484cad0359d839ba67f4029215607f1001ee3a1f162fea63187b191ad87dea693f2db83fbd2dcffaa25826e3796b3b72c254c54133cbb9c44efbc3bc47269c8fce53f1ef63d66cc482d8a27b068359b9b1fc0d11f9d3670c7c53349e6897d742b9ef7d388a06917e498dcc5a2cb0629b73551b01d77e8303df9624e27d3239178e346c2f06f3162ab09f43d18cef7d5d7af4be294f80eabd9adc7ba5b4e0181e4a4d41785c7ef568be15ea2613bbd64031ba71dd4e4b41136c65ace4595e902c0ab34c3e22e6492b417649c64c5609ebc3c4f0dd58fac07ca28687cfcfe1d5e777bab8438173303d8fbf054323ba916d64b04edf95abd8f68c087588087f81a8b261126dd6cb62888627fb217f042db1af4444289d2ce60bfd62ca11d7afbd2716bc6ca8cb75915f142f4038670e5ceeec30a502291482d2072c168217a3a399dde11ceb3d757c5dc144abe076eaeedba95cecd28c9667f11b20c5b2c6eca2847fa65933d30e7e74703a636087c61a4f06b5963ba64a513300676a8026d551d0a1f4bba4e1d960092aa6c8799b566e56ee45dd7230eb8a08babf0f1311a4101ad2135685adbecb301f874d6e7e8041a3bbefb9372242590c2722be0238f3da2dbb55fe205614c7718f68bd193ae9d153e4914a601f36457f791c5651a52b8ac814aac043fe8d10a5b2d0250c81d99c466dc5e57425ff","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
