<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcc5c21ff04728fcf5b56811899d8dda5d5db1af8bafb6047ec209284d92c2b388be8a9d7eca4c8543a2e273e7d8052f24182597c9073f030c710a5a23134e489c0fc7c02908c691c2d80564a3a51d6e31acb323657dae62ef7eaf3bd3c06c8ab1967fa475782c7cf7d5be21842c360b76632360f3f7841731d68590e5bef7b410201add031672bae78c7e21cdf1f0553cfbb0f66803d9b7367cab5661a3498228970d0802f4ed21e2552069366a0ca08cef195b205461a07b6e361104c4731dc9c93844b9297d7f7e89035e9ebd76b81c2badca0857c72802a537f41da9072f30aad19df2af236b7fafacda7238ba9e1293c7dadd2feda40ad6547516a4cfdf945d4b6ec2232c863aacdef1023f0de092534b750f4cdef1833f6a230de0e969f941bd88585aa073b2284aeca8f053b4a9e567eb29e02d793598d04c9a75c1453f2578fff07cc2bcc0f52696d3b11791eece4e8318dce71315086f9f5477d46e67e97a29596813dc2237e448d5480f6aff396d4d0720fd1c192e26f4644f2ab06369e84f216414b34e04fa6a624c4358f80a990675d4017b0bad7add235e4db5a92bb66cfdf0595dfe2d0a445961be134bbbfcd0af62d45235485974673d5213169c8c33a35f94efb748009c19de95e1150dca430511e0a5f7db20c2411ce1c5382912752670d69bfaec0f7faa0acd3d2866c7593eb4bb01932a960aab7fbaf177694fb252b235365a3bc09e984d87af477abcaca5d9c4130948f6f1949429393223e8c1510daccab208e46d240883ce8ca2820c278faa63ab444cb5d490b33cd6bd604e84251d55b6b89f9a7b0b9a9a6b15e940cdeaf782bf635376c027898fee3f70f40e044c7ef80c24930f93d9c4194c4eb6efe4a3fb4d9bb99ff35cb54d8bf69ecc2cb95d6b92dbfc1230d52708d311a869ae63af487f0817b4ebd921a05df8ca708e3d57f09b0bf98070807648298649951d0ee76900792686dbf5fb786e91394ed7393ffb9a52acaee1acd7c42094f40453edb88419136907f467272989f9549993a86250095b513e2faf6a3879895cf502b79dc58ce6642a82305a3fdf610808fc77fda572c8f64e43030c19092c2f95ccfbee5023ba3b6ff1f8362fc2743943e311c0334b7db2042818b3a7c49e8eb59f9f86bb3b479cf13f6ae219c6c921a36bb396f24a8b17b918ac0bf5b7d52cb2c206436f79e2b7bbfec15eabfcf0815b78c20c27dc74581e70c43026ecb4d8ec57d8dcddadb367558678169e70c928d65c7dc8a6cfeec087de9c352da4578ed862698c75f819a879e02e5288093b036cd45b9652c15ce1a3a38c344cfdfca026ffdeee0264b2668de762e6cd060a1ffe139f7d5a4db050f779d95c08c909efd88f0ff0f26f5e55e98f80e1b28d314721e5ab80119a8351221423c3cfd975f9f6e8b63d1b3f8798a01b6748abd8426a2bca2166c99f9a28df780746faf65d1c47fd0810ceb7aaa90580ea669e90efcf67d0cd2b7f9c4fb9b1ffee2f5a54d97a60cec18a99745243d5e55e505984f0c255bce90e18f896f991f22fe2b1f8f2eda1bfc701a8dc9cbafc2cf535c09d90c6f71477add1f0e44cee00b1a1e91f161da9c1c1145653dd8210da671ccd20a136d4772b7aef7318eacd5a5cda51caa679659a2de2f60781ef7d6008a75845f3b4dc31e4531190ba01cfd3d12984773d6e8171e79a3fe87b9149b00b2f012dac6dba8f7c8a0288e9611a5a66745cd6b75926d0e167aa02816afd7334e6f977f2cd9a0565715e01139b14b6266a2404c77b50c99c305c564bcfbcfd760711d1b2fca59f3dfb3fd7e92192762fd2c097761db2d7514770addb3d1a715857e97d99712e5f863b74db8e29d5a94cfabce44b41f544531bb45b46907599d3239090cddf23ee17bfc74b52934db2ef479ec1b644e93defa938205eba27bf5ed5fd3cb425429015808b7955d9bff1eb54637967a9f5b2c1721849fc991f95a356ac47bf1a6fe0d149e377901eba006f0eec092441345bb3c835b9968c3ce1d0a5c7ce85c072ffb0457d6e4265df0d0c70aaa1be210349acdf4dd7912687ddab66813f6cd6e00d1cacffd0e467ea331b59062c3f3e6edd8f0bef17aefe4279ae7cbb988c78672df9470e39d60d9e404f3271a97bf06b894631a4b45e44a7ccb9c443c59d78390325fa2b8dafd0593f626b56d73cf2e090a1951c88ce8ac6cdcf20110e39c3fac4c248011205d02fd22734a195b8c6d10e209a4d8e19f525a9fd574e6f343a57c18cdb682f7d2f477657b6e332ab7773e4526402e3a3e3608d191bc720c6889a22dcfae750beda5744a96903262bec877675a5967c28cababc576629c28c8f902fe538882f2a9ab7238b4cb125a89af907828df514268380913bdcb12ca4863c62a7ee1d2cc61c959ff98e96ad95dcf506db49f0fd64cd91d6b9d359a3aa7d01ba4294b445662882caeca48718184772a6fc8925e65c7379901fe87d9a2136053893a2e3b3809d33af4597e5b01c549e5f10de18a8d642a86f622d9db11d6614f6d9dc53591212a185003824c2fbe1aaa4dd8a160541b40b0a5c78ac2bad8750a3ca7a978460b369e42b1700e3d8259fe491ee1d019ea66648b9df80be5b4044e41ea58aac35d5b182b0f269510a8c5c4e30c5f9cf497a277568ffde65abc6cb8b15c7f2f31e378056231a3972ceddf6597cf1cd71fae18f04862fe49754dcf296f4289926c29010c7785d05975bb8cbd697947e8d0b0a45452afa9b91a987bc7bcb6c76e217402daa68617a1e2a49362851dae9d7a1b976965e1a5de5171be5dfa47a10e9ede82f8a3d21209876e19297e70f9ee78b188eae26dfbe81640c5201f53c7d79200235fc342aae0948a3aed4739000f5713684426aba8c7b838afb1a467362edb9f870d2351a9b5b807c40a031c91fdadc17b5f2d68fc57311fbcfc0ba53f2b36e0cca4a30a400093b2007ce34d167acfa340a60c0246db80bbaf7b0fb974525eac73d0b14dcc20f7440d23d5703e75134c258d582c62ec93b4aaa4d0788536d25ee6c13c0264436ab206819e806885aec5410ff67fb78c2f3b5ea685e03e6cbb80c2ab9849c3c30948f937ed62a30ad6c27623ed9020c33814a4733801f7fecccb082eb92a51e9abc181a9d7db6f47d45cdd081980ec2690bb95a9a935f4afde4f04f4dd671cd80e23c183502c42e5b2e34d050164cad1dfecc64d7893c92529a4dee308e3f8f81d3360193d709e3b5da7aa749998257bacf5406e7cee9426a4ea114035e7f51f7d9803cc7e67629d037a938bcf7e1f0a89e5bda8508c24b3d0aee027d744f16c90928bfcda981bbead1ae251ad5f7f9a436d2ea0c56a8ae35a020c0c7481d1bc3b2ff9eaf033699a35c30c90638a89cd9549f6f42eb80eecc543d41614f5b8f06d3ebbdee3d4b479b886dc7614ad81fdc22d42fc2181e38460942e59e97298fe56db7c876627811ebb69cbf16a2fe1c8bc35de5f31a5fa67d64e146652d647c4d6b2ffbb9951b232f08f9870aac0306c5391cbc895325ac1e52451e965df1d29d91a1bd817cb3c584a01ef315451e3a1432e111ab02491bae10d00fb2c212927fcecb811cdbf079da6664cdb073c3493f6c8945658d8cc033730f928670c82658c5b53b3a7d5dbed2434e8576f8a09e6678b91c10ceba79c66082d0dd5428eca3aa710fba0e67eff6b3d811229ee5dabcf37714e443300f04b8d45924ab244fbacbd06125bfae77bc66370c29e5b5a519be70b2865f12d995ffaa02d0196c2589c9f196422c88619a1d8a035ca90c05272cb38ee94ed45b0e821e44c3c590312a99a278d607be792659bbea13cf23472b5e0f5e164ceda0dbff3ffbcbd78c6782bf0bc8825f0afbcda49058c0f1b0ff7455be9346e39f0a7bce87eacddae1bd7056a1167332c6789778165061881576394b569656505d316f9a04df2c86b4a4759a542411398366519ab3360ad3eb63ad9456ec20e9835e99317f83c41e811bb37e5ff065d3e56ff81c5fb502ce24d726f4547b54f9444ed326a3e619a46fdb5864c7b35cc57026fc22713b7853b0379df62396a2846e9c665adb432509e2491c2b05ff754281b81bd2afce6e03118edcf58e3369f184cf8a44d45a7ff8754cac18020e3366688cf8c4ced4b678da104f30e024430ff6ed295b6b3e2a98a482ddb657be024c5282e0a55ade3ada5f85da83ad5ddf26981baaefab39683f597be1cbe9223e76857f1d6a158b08db600d6a4c200f79662c37f291c4dcb48e8a6389cc8b0dd3267c082555cc6063f16da828262239d219fd60b181306b481f40d7b797fe053899d189b1b0cba021f7d506d7786a798822463e011aebe091b345a3e0eb38094c7c06b2d2f2a7905e2d70bd323b41280786320f61dd527e584c2a0ff28a56e104023ab55916ace9c2970f40031b92623b00150dc774b7769fb700e2e0fb62f0c23941fc873023372ce7aa69e95c4d570d9a44eb048da30536ffe0b862408955c51da7eb657b1c4f73a910420ebcdcdd53547940d568f416e8bd8fd33fcdaa031411248ca2cf1898062d3f07d853fc4a78347529926374a6a33ca1efca984d1bd13eb937f27e8cbd436d269aa1d0de81345e5bd01f875e75e7539f37827f6029fc922cf583a8f514484f8e38c7fb45413c31c9a7244e1e61549381efbbd360e3fa3b77ac016d281f0c38ddc420d71fb946114f054ce60a050c1ea5ccf377ae4de191e346360b00b85f6d73f35e8d7de2468f7104b2175882699dbb526f1ebdd6c86eb6ead85e4dbd1b7f5d4191dec9f33be0a18f0e97a46bc884b000084051cf894bfa13469e3db90e2151f45e2d9b00264e62ab035a073bb1ff9f5d547ca6ce50d8c565e00be97cc747380872102683a8777eda3360af14045a35e2bce2efbab4389a951a1bc24e49cfe9af68ab8003417920b67e9c0b5035216026b7736e8d591a3f5abb683e034a475265770de5327f204379c5a5c1b6cd1e05e4c0484c4e5e3c5a867a45b02b88a808ba09ebd7ebcca6d3af66d6dbb565416f858a16aed3af8049e0ea2432c77b26477e5136b3aca1f1a39115e1b6aae3ded1a27506d890a5d2f3ee5dfaaf645d10e98ffa79130b19b62b679e192e5e802847463a8f6fa424c3f20ec4ccecb04835c7cb0f09e20bcd3acc8dac65065ea77582f25bef359506eed3456d3d423ecf08ae191857144b1c38013986235ecb8b4c92923214e34035087364441e17413b540a5dee78af5bb8eca5205dc7044dc6e1f3eb709c36646d3a14b886fed77d8f676e5fef6d0055bfb913da792fb6c28b765193d7c583fbe0a6d6e3969a15ffbcf7e6a5dd0b80600ce5ea4e459a9334eb0cb4e21a0831de942c13b524d54add11ff98bc980b8de5e072fc09cf513a345c6efa62c6eda5436bbfb886432ace3e22a29a83ed652fd7e4f3b91da6ffbbdfbf7276e1decf0031f33f122e7646ee19f0572d7ca4668c1607b659a81681f611c17752309c27f350969ef490ca0c02ee16961a9ec79715641d282460de5169c9545b25c31c70fb0a98d3aa901965a239dd9b8c07792737c5b0b36b64a4fed3d955bd19bf7c47a4f54b8a3de7c17d27c1b06a22a1aab320040b363ce8cb4cf20150bf96e9ed70d523fe5be22ea3b93e8ed1c9b75221c283ce0c935c1f24ed761fbc53ce3a15d23e636fa2567ad8f27a46c2a702466609cc81e57211186f92d4bea48e20388d6d91751e5d7a2589eaba890b7b5e2a045bf6b40b8d45457d29e476abda2af03463dfee4ffa29d030fbc61fa7cb0ba03eff7e2484c6876899c58b2ad57c9ae232e9b6b29645ad253da80f206f553396d766e52d43ffe9a93318f485d360ddf1933ceb64b34b324839664694e2115a56e16f3b0c00cdd17625e7f68ce45ab3021f4bf52b73199ff0f9054a691e19bd9c45f296ea47f30479a9797fd81f5309c4319bdae6ed1f2c02baa4ed11964518f293c75c08d5dcd5be66b4ea40854768f1ce849ed3207bd8153d23018cfca35c89c5bed20df066ba567adce54341892e9c55c696b33cc5b8acf1859c52d402430636222bdeafb7c02b1465500ca673cfb84c22dce01cee91f4a35b56977d38586f5b13f9c22c4577b218e86285e38bc26e2253715dea458de39f524d1a5a8648853a7f7fa0038156cbf0f055af620490cadd1634daf2d22324b87bf9d0574471cb9dc7160faeae263999264ecbac6c51d38f19d3b64794ca484c1ee44ceede7ad7344c6b18cf6f1a42b73701d971aaca9cf69d31ac903356b35d90f9645b0362304f8404ff4a8d39e0aa12ac1c0c8eac40742aab3fca0be6ecbca828e6999212619a053616ab277eccc98d2ad497879a1352a4d0c12d87c450193322ad6c3a216bc15647cb59c91d1b0ba0297c179527c419be8ca65d6840997486e0c94ca486ca4efcf450fcefe12171df660fa52f2788b2eb2b2601d1e4b5fee0f9ef5f3d34bdcbdcd57a0df4132600e4aa29b98798ba565b5df05bb8c04835cd36501853701cf6ded46e7cf85c8f24fd6d284da230781a0a9115d8156a814b8022516975067bcbf874a01aa0fad892c100c42cb0e783d78f9537cdd4a6e104b49198e60b2eb2da37084f1e706230056e134218b331e240aa7dffb739b9683a2c83021c06dc37d82fed5d9312f3ef5ef82d16a86ecc53e98388604405aadb3d070a6572282107c2f3f8c63efa6dc586e6db0edef80b9fdbf785af883605e34744e5535de43f309e38f7d8c7dbc58ec7d070a9c965f3d5b9254e23d7d9f4c43dd5ed5f9c7ebc758df840b9252a71faca29630e11276e907a492dcc874358c3959c5200aa65bb86fc8248d499c1f66b9604bfdff23f1f6f7d91ec4cf5af0b1b7bb76a4ac877c5ee7ba93a08da276672baeefd84ab38409918fe55c6c0d49b23faae45b535f07a8dd277ee46b3f8d6896564b05c3dc09a1c4439d96adfedef6876b1e0c20dbee8bfde6692a1dadebc1bfde1f278e7c9cc11bc5f052f76a24728ca4b27c9706e8b7cc51754a673d3cf68f85e972c91ace929b9c3c1f9a9611b0f63b56c303670308c8e496f68bf9810843df59596b56bc8d3826fce05d64658bcbae7ef7af38e0cd89749d278c77e50f1a61e18ff38e383f4bde3682867ae0d32a21836933660a68af36b606705352b8f243af9b141c551a7f796e5302a130fdc3944ae73b45e24d997b08217a56449ad057824188be070c693c3c1369b7aa0085ec1481b79728eabf9262859f07203a64bb9fc2d22b7e5fe345cbedd940e4e32bb17cd1beb183f8fe5678094ada37e22b89789968724dec0125bd33838e9cf345f2ed24f14b01d81c9e2bc68e7f337a4abcd29e051b232908528589018d5d8b77a2ef670a19ca804c1fecb6081f7d2a8f8e9a6ac0054f534fba6376b9cb88ffefba0e886149d4e31a861bfeac3f1e3d8dc785e3b956dc326678be46ea98cc16785148b7be4285054c798d51f10b8cc4c50a50fdd77e482a9fe4d1a01cd3b31859e6889b0fdbdd813d30ea4d600426a027a4ca7c94c472bb2185a54d040be0fb01661081f64641aafa8974f4012973bc485b35d5a757747fc70a347b38517a30d384365b1fee7d971ad489e54fa7007e3c41dbdf5d69342a3173f06d6b87c793e1515fc84d92c32be375783a19af9c405e82409dba336243c80459fc25ef400ee728bd5066bb423e0b45d49f95f663580cbf3323776202169a3058744c9aadc5acfb96da593fed17518c421eec64d043d474d0e03f15d4966d35702fd4f979344501ce8fd371c3e39eb28f3aeb59cd93ad798f0e5ebd92b48143996b6bf7c25eea6fed00c5dc01de09088d50e66d8ba815a8aefe05f7a2962503faaa2dd08c7ae5260ec2cc503d76866d184b0b29d411fca006ce107e337ec05c2b7fb301f8ce59b36ce77da7057841ae5e910ce6fae6aa8d896674a95c01f643703d4c4034a07c3838f5ce44c64009bbc9436454b28777a7be948def5768d161d1e67db3f7375ed4934c5241577e3ee3a838fc03c9daa5e748c62e1c4d2458d81dedee07b463dcb58f498020fc6f3fc72e62954119f55c3f84cc1b76b449c0e133f156258bc2a2b68270af0a2ce276e951c6925edb3ed3b6acaff86ec6b90dbf9a7565fd666d24c79bbee0cbde218ddb96d73059f2363e3e347b6039781dc9560f58b6a748361c08566384d9d4eaa3e867d91884b0fb05fdd8ddf16baac22b0d2155b76901660e8bb4033e1344cf81bced4e73fde088370ba1a858902fc134575251fcbd680357fc5eea5ba7145982ebab9184a2a8e8bc3152b723d4f82efc615a7c09929901c4cf048e77d9e74dfbd22eebf3785c28af4e97a78f2c9d01320ccf80fc3a7c468a338a8012e5ca78b49bfcf2117b56c45a1317aa91ebc42eb35309f615fe911d014aa2f52d6aa2e69af589ae60fa0a0f52496ed72c604a0690d07acaad679573c4d0dfb6745f6787624fd057c1cfaa003103405bae29b31010d0cc219d9af25b2dbca86ab65aabf6c08919db322be4c9dfe3ac46c8808a061c59f8c728cd06daa7bb40fcc99c6f2875176cfaa8af21917ea68efc2486dcab2e2ddf650d8ad2c662da5e9a3fb5558966553e53f066be7ce16743755fb4b654343cf58ceba22b9a8e0bf8725f8a5d8a029d79c6216177821d88efdccdde6ed42635de406b33ff307208f475f08056fae635f5b9f61db85316bcc9c3cc9be37476547bae1afed24062a63577c1f1e9c9c6549c54ee5fbf65df358e85e18cf363784ace44c46edc9ac9d81fcd0cde118f6b3b420ef477e5a98e5b70f6b8c893a99afa25f87a409cec4dc509ba288b7280aa224d8f983bd74c1ea9594a5fffd7e058b234244067c8f5c57fbfb5dbbc6dfd93a94744d1c666cfa78ca6dff9f8edffa37a89862f0af7a0555fda76a6a957ddd9aa5cb050eab5d68048da829a2411ddf1891f7d4a30dfe0f1f597c51b74801fd089332c2a13f2c2444df6fd0ccd3f760af1e3a903baec8d420940af87de1d1dbd1755ddc2ea61beb1bc98b3b598416a8615a3bc3eedb54a7a5a8d1c44ee20bdad1b0d77d7d9b9953659fcddbd5c78a86f413c2feed89ff1a3089464d21618d4633dcc2380d63196688b7af4e45474a770a6369ba74873520142c3c555083ffe7dd10219cf7be7c54a95d96e48b63b0bd077f2e6725fa7cc08131d6a2c8cfc658f39aac1c6ee00902aa242dce9754038bee115a8c01b38ef252890ea2b67319e832c51baeacca73d85170959084f610ce08248c5344c9562036513b59d2890d9ed9dea67cf3c52a74ebf1789187bd31e459cd8a4bf1b101284db97e19f1746bf9769c814b821f69a1a870ff0e91245d925bf3770f598d30f2fb9b5c3c80df7139288e09e6131f587f9739a41341a2a28317a262eb09ec3e87cf7428e0edabfb7f57d485d05c83e5be981cf513671a727258f6c50f6c9ee4e5dbcf1b0a9f4b83f3ea78efd32bb20ec9c8c57c02cc2ec9940fd1f7bc158f38fd6dc935665d688fb1d07abf6807668722ea7673ee0c62346fcade01ef019fbafada9fc7bc29d220ff208f71d7b84d20d809a1b561c53065f85c3e68cc40193869600cd4728827eab8291c68879563588f72bbae1e2927677dbeee8cb6acd085c915d3bf1075d7f1272e46dc9f0614d71d1b2050ffb956620d295f4db72ee48ee24bf7a3aafc9b9b02f158d5f21c937f62ea7b6fb05223f575be64acc109e57c46d026c55ff725a73d66719ce2c775f4126739a940cc7bc1c22352748eb5d0e01185546fd3c68d5aaf1812d47056ef3d661565ca2cbf74105c5a17c1a934f4f5d6e1e780e07d807d86ddff3d2bb92e7fc439c7cb7453b39f19ce0bd1cd1d0cb1ff9fef6bebd9aa608851295fc9fa4eb2df7bfc551a66074bbc3c3dfd04ec18f2c43de061abdddcfde3dc18adfcda69c4dca07b605871f1dd161a4858ddcf59bef86450176f62a1a1adc9a80bd4021e877f69f25c4aa6560a39c53eeb7f8bcbb69a782d52b62fad3aee31f2fa5382b3d3742e62412d786a4f40105d4e942d2e5e416420bef7f5696b983672917b59337734d7efb5a78b836b330904af4f51ddc3c7d462b4795ae962ab15af2af1ca528b3f9505873f0698198dd2c896731360bf422a04c3ed01a55a19a366bdb04fb581eb3ba5e35acf4fc8e54b7cbb7a037ed72e8d9ebb9bd86fc001f6b23154e446b6ce061b1eebbafaef8e224cbd01b05209a224b2c2ecd64fd50fe909d4b1604b5b685380e7a54614f544c9286501f8f4e25d7aa96b109d0af79255d8bd4c96bec3aae71d0b20164557602ce4e7aca299be72ac2f0fd349353deda005339b943e5aa09c048d3f64267ea0736b5913e31014717cea709871b6456bbc48b6c4df2bfbcaf240748b0106ae04bc3cdd51cf169517c8f28a8cbb1536a243b8d202070e963e20606e0709075c7dd421a7e6e5bef07b525d553189d953cb204ea9075c6283d1bd05814fddd7a06ce6f67b5fedde2f29823050da9dd3d171034d5ee276b7d3425f300bca8c27ddcbbef215867fb9d5f887e2a4e78aaae182856902ab58b92b7f294dd8e8f4f68939510a9338ad6b8e8a3b5f55b581977192d0a655cf8c437f4b63830f1090600b8403f973677029751c42d938501a6a9b5f54e49e896fbf7908cf7cc78225f54c884ef49012af2ad974df9a0757b2da669c580a2c60c61af41cac37fc50636f5162b52b5e3d6c6a5ab2a9d6e5f7bc079767b3b4273a9cbe47e73fa631c5183e5119871032b1d0762372d12c753466b41facee227907c6fcfcf0d4e855a1873d1afc98443c8c9ef4bc28571105a2df5a4594005cfcfef9e2e433cc8521363efc0cbdafaba0adb477bc362c70fee007edf8510435578946fb3af366a9d37df2c958855e497eb09d920282a5bfc54ae0f97e4644545e1c26f50096890c300e4c570ba412a0efe7012f2642f6d1a36e5a8d7f0ca2b5f85950b286cdddb3a1d97bdce10209d0cdcfcdf07393c0050254471eb62d4eb9d5e368ae1cdf8d0b5d6553c131d472c9405513b5fda0cc437cd8775d9a54be1a737c528eb1fc1cc846db415f6170dad7e0d6c4c46f0c58e375e0415ff2a6c607ade74466a4d46d4f1492535179fed41a8ac5e3a62ffee817997d527ddf3492216f0e57204da6448442990b3cf1265f654b40f46a5520e665f9fbba54276f6981366f2172399fd301477e6d8bfaecb85588903c1b43719d2dcf93a04b24f242f9faff59d9f2cc2c095dc29fff1a488d4ed581290bd0068683733619babbca9cb5c13721effa606978f34ac1491cadfcd91f5b375ea7187b6434cfa71f646b6d7419e9232bc0885709f626cf95ba37400faab55fa1db867fa2a4e18aa9af85507a6c767f42bcae3957b9d2fbb9581a9bc630cde6f7719cd2ffb2ea32ed294b466b324d54fc92f71cbf40eaef32d70aba31af0a73b857b6c5eca38acc41c8e9a1192c83bdebed37bf3cfbf7c8ae46f15cbd6974b781416d039474b0eba9c84b841afda50e5903e4086f5f2e1aefb4b90106f8ce3829f7b865834cf015d676ba5cea77da1604338e7f96296d11b71a1274eadc54b5137d8a4e774238d2c96a88594094fbaff8bfe0d41ea8957d5185f7368288db38a4c9f43b8b12fb7b1871cf19e773055edff42e6546274698854765c7446e12f7315e410e4e69476839a8204aba76b7bad2f39ec635b327bdb61d51851cfff45b63928f148433278d8bc202ab2ae6af0a705e5fcdd723a13882551f2c211e74281eca9d26519333184bcf736c4dc3cb0861be0339a5c09e1164c74dcaa1b9c3480eaa223dfd1a2dd0a7cc5759174e7d152ac193370908e1b95a83ca1c80cc33b2f65f253d69cf41217a1f821b498cc93348ee669ac0321d3a571e04613d8c16c69a5f4779e81c99400726a56c832c509f9774a5293afaa7a74e83c595926eba531a0fba1f8bfd09cf1d5b513e809b6128f58c30ed8927794f4928e680171967d8da0328306326049b21f626aa4c4a4dccaa8f136e02c3fef264710e66530ca36164888fe9a5e009e86d80d8fa940efcac79426e6d827ca10d92e462fb12b807daedacf9162794fb1903547394340832f015b407229b6a6487673c30dba0848168e54aa1211b0e1b765a8754e4cc9015f0b79925ca362ea0e9e2278ec020b5b41bff9ed964564a5473019291c7191e784d00bd99fe9bb35760855fe0088b189bb12625f92d0bfef56beeee999675adb1bfc06dba4326ea7c782ebc5f133a14ecd4886bb191fe621c786afeb8b1f6895a95f9b9d053bbea1f1ec6676fa5af8582b9b6eb15e9d9ac9268961983f8d1ec70eabd24952a1ace816cf7db7db641c3dfcb19b8d583d8d4fd2bdb89d1dc8ea28d3e72a938b34decd19e9048cacd36ad1df54276bedff763ec4525d85920c521877632d787c323bde12f412823c715371660ee57df6b9558d7632d55b70bcd3b3cc137a823a700c1fc86acea9b9be3b5de7d9255dacd82d1aa42fc5b057776d9f3235c2afa03af40d4143db895e67e9eb74e22f8e91d853cff0cdcc80b16723dd3eaa8e846bece02f5b3b529e0f40df5300b91117d5e604c9592378d4cdaeb2d78f4cb30d0327b661c67f529d7f836b64769d254937e86b31ac8cdc596954a124c7440d205f36c125e67dc9ffdb7f867099b6c1a6eca02a10cee40e032389734a7a2e273357e8aec4e322cd916cc1c051059c87847d42a59ff49edb273d1114acdf169c0b079fb97caa130504b65002093ced028fb731cceae6a36fecdc26453e6760086970c39b1ceb4cdfb723cdb0d14b3e58c72e435812f86002b32df392c525a3032b6dc61df0d5007c405ff739d26613f9be985bd037dc765f0677f7d4a7d5174d4a74d709dfb18903b27891f931bd0b55605895f2411572dc38ee348194e99e2ea2390f8efe55649f30335f772185a1acef0250dbddbf57f835e95badc683aaff0ad338f7341f6e036933d71ca55fe367e2714b780e97c38b05b9082949f3263f5ebd7dc1f0e3e9bf0872b0080385eff5d65e45dac6eab76f0d0ec407eba35cb54a8cbb910b6d727a145c00a330ab2d19d70f48f34fa753cb88d562c317352414dc977f01f9ad17605a347a96cc45350aa59ae0d64704601f9c69245338b23f7d8130babc7f51abe642ba3c762425df57cc3ef01db770251f4a4f52f5c5f1abcd200939aa2aff7b8d92fce4e9bf96dc5f3a205c8f98a1f3370c8e11a425b7183bbd0757371c9be4320963f85f4eabe7e5414cf7cb8bea83b34ab248441ded82e37ad88e385e57a624467d0eff38cdf4c5b4b3c4ecfba584f7bc38f212dddd88a68a10a925010fa4d1ce8a19b27f07d9de2917936afaddde76637258ab91211252017349bbd8af32b0b0deb7f29d37d0d90776f5c124e7a24422cbea2806bee85e7f673d37141fee8c2761a44a87aa3d8a3ca70818d01ef4a71153898292b7309cb43465ae3b5e160bb80e72675afb2fd1dda017bddde7ccab53433a90f8677970d101338ee93f9897f4169b50847a860db38560ffbd768a4d81e15fcddf13fc2c262add5064aa4f48e2b3618e1b49b8d0e0b13281b1cc118aebaed3f14767ed2ab2e8970ddb5447c9477da60ab658552cfb9511214928f2e92accb444006734fba7a77486f3d27d2848634bac81faaac7900059106f0e05355cf7369495943183835473b717b3ec1bfc6d6e3c3fcbef147c4ade70d6644695911487fb03d34b637a04fa5f2a7e89f181a45541981f8a5afc9017c87f5630a04c5ec51e9633087033543fedfb0c75936cd24c34e2cd18a8e51d898e4051363f555637348236e45c8ad8e6cc9b31730b9e3b36c5b23fe2f0ca80129a43947a92520fe8d6e89e1b5275dc9fdb960e0941f94bc294a176a0e096448283b79b36f8b820e8913f6205d76f52225f622c7c52ccaddfa94a27feca0201e8adb4ef4f472468ec3f8780ff1bba783561462e26eb14328b45c2b5e08b4b62803dba9b64306a14c43bcf86b3cae928e3a14e047f8dbc57afc122fdadfc62530cde76b6491e521ee52426a6000daba5a4dc0d21715d6e858a69ec965f983cd0d253142dbad9348ee89a6423d76700167ae25d4fa611922e1025f3f383e66acc831819634bac0f2a4a60908c10571f3a3b205a745aaaa7afe420715cd037592fadc2896bc8622d966850d259fe02f5e7ca9ab9fc068985bf54e6f45848c113ca8043a1d0d0a9a521556fc36c08e96db50143028a89b544600e752937c8b8b5c80aa68217660dcebe89cbef726d5c3d39429f8123ba314b1f4afab8b8b3fa0c973503e21f8146da658d6795882a970d2d8667d87becbae394c3b6a9503c10eed0cd65f10feaafe70af26cab9f149fb816c62dbbdfcfe9074ad6128daae277d359cba3df3cb31f643a1f713b11209ed809621107eade2d783448a1843cdc10e5778c7b64360e1f5dd10823a67c4e20d3650a0af3f2dc382c438acc4d6402410f08030d5d67f3a2eb71b208ded5f4f5c4da7e7deb83f60951b93c7f9ccacffdca9da6146c069c888ce4bcfe019715a8efa4608221cd420e4bdae85c7be7983f5e085c5d843e3ee80f08b7340bca4fe07955f5abed9dc8ec9d4377503696d10d0997cf280a70c2eaadd171af5b33e47b416578ddf5a56077007c808063691237a219bf26f59f9cb7a5b81c94156186230da5f2c1782bbc38d9ed745e49580c3b3f287a0cbbb967f67d7d655ad408e0c817f1bc0ec08979325c1d4c7aefd06f22b61e98ac0a0e489abc1398a681cd1974df39d3734c3a5947543b7c1f645c7647d80c295231c339a171fbd2fd02acac7d92c5bc358bacba461af171df7acd4d0eea8cf72a5aa173bf2711884da5e6a1e004ebb5762af9f31b22018188e629eeff87128dbea191f7b7e85a0733f2d0ed8712dae12dc1b52e92057a3b8aac2ce6c2ebd93eba9b415d2110270e5cf539f6b50a87ec609c905e5a758ab127869024e7e449e17594fb44cd6768890f89fbed62839a3c4ea241baa0e042c4199485df15c88e1d267404ad34a39fc82910e7ece39401d3f320bc49b51e5369e1571585e35f9fc1ec38a704271fdb93ef7ade4f454016c8d1f866eb6d3c10d29c35afe52eabb99f3713476a93a88a42762a698463fbe2803631da8c09a8d06d74110edf2fc73bb608e689a0fa763a4233c38858172f19396ab987f3a713ee994fa94d3c48c3c637cf8d81bce8ba1da182cd86c1fbe44804fd1d361dc3e3b8acfd075faff231a44043112d8f8ba855d6b3b06a7faf4cd2a8b3fed85e74b33cb1b3dff83ece70d0249ed97629def5e37ee5ddd5b2c6fdccdd30bf2a16a8376cca1ce9d8bb048be252cf7d341e3aec3721f551c41d74c8ca23525761b5ca776153022e5aea49e7e9cdaf2f48c133ea34b8155b3a438e3f30a32ea6dd657a2180242a0588e45c465ac84dc60161227bfec54db42ad134e86e663704eda5c0a908127f25aeb911fb8b6b6df3d2ddb3c852e55ed7760b77ca2530b3239babd55c151eba4ac20aac0999fe3e247602a1d2133c72389d02b886fc7206c7b734d13cb5d775e9803b8ed5016e9f3488a88b49d30677e7a7fe7d9b3aa13881cbe556e612b47453c637f78b93a54c7c2d68206e4cdb26c374cb119bc756e4b68884426987f8aef0e0385753965be2183e6b622735b56315686d5edb86b3af600e564335e76230f2ac21a3b349e4e4d72adf369ced8fb9b038992c57a879e7608d9a1440dc908bc84b9667a31baa389bcff77f07cacaeec2d20ef819e5452e4bf5d1d0bf9c24e9bd551c5884b30a6ad09b0df62b5cdea8009ee54642968a875d3e86c674e050d73cb8f045f62a6387e0c5a8d9a52bfd866d8e7f5ea67424d65ced6ec0e64409994ae5b6f4ad6c36f7120a6396809b141848b312e918583d3c657d55ba8bbc2416700132f7f1c6a0b438581d584ee7ade1cb8273af326887b512b3af904e8cc2d3f8fe21d7814d576f918c3458ffdc28cc84c3117ac583132274f6a7fce5a84d018fcbbc537cafda7be57b515550cc65fcb6a3f39bd993667948e4e830648b72a46745bd607d19ee6a5431b6aeaabfb50fa729269bc2b02a8ae690b7d6c98048e767552c195cab93597494f1869df536617ab430f309319e04e997ede4086f7503619cb439b5ca9d74b6ca985045f6782760f0647d03ec529b7be42e755aeef33b6385caf5172a245d066c0b5f9382b3b406b42fc859c863daea188270818f483f2de66726814b1975c4225177b333af64117decf445c4f881736c0bc90b224d7f504c48a616d2433ba49762c14928bea0e2a4c3131e59df087449c3e33adefad125ab408044db8b4b5413bd4b4219b65bce20253cd674e8ad25098230d536ad79bdecf8f547d63571174d9458aef54a11f71aff4abb62707fa56e75c057f7bc06cb0d115f4fb1e477e41c22c560f3f9a431d0dc07d13c0af7cb379dca7c1b41c2e3fde0f440ca9431c61a6e990cc1a87349180b46688b861ca747759716d973542d8f3fdcd09b37fbc7a893bfb45b9ad21a1a658549958e5c7eb0344ec2991cd2f0976539bedfe40606bfb4dc08a0a4d040299e6878d506baa83bc0b743c71d7a05ff9f3f8055c425511a16cabc102989602bb2da2aa7fbb0e77916836b5a7c1c21442af3164f961346848409502f2ca3822ecf92b29d31fdb6749284b311b25b5497928b9d4ff72031383cef1da63ba2c69337f7f2c5dd2ff3d713f1e29fb78c6184f03971c5d755395a24a4c205abebf7b5452518c1c882b036e625357aa253295896d13f3e349b5b6ccdf07f1b061270034f00847835b008bbacaa14d94fc4cf2a15db31d98783451a4347b678e9ad3afab5433066c157bdfdbcf51edbeb1ac965463d3d6c82d3e6cfdfa6e4c0f0c2280aa935c1e1819bd91660245fef1536606a4e7706c5f4dbdd2c8e94541442e040c124f800d0c59b65995a4fa3503f75b1e2250e5fa488107cc5ba5ab330726917c7c25d707a2b9230071fb801c568be6b3bd01441c681fc822a47a8e25571e50af042e9838587b69bf5525b19ff5b4cd14cfa4ba561858f68804bd399ac67ec149b5407ad891ea95b78c533156690aad73252628655124edca42df505d916f3f641c105a59e3428a6d9ac420cdee43d688cc9c4199b929207d5d2de165cb30139fd3abe67f8f631bd902730d8be34d7037ad8ee709d299deb7d98902b6adc0dfc0fde7ebadb3e3c96bb857046875c0acae43f4c0bd1b0e673d4c8c75ea3c35be99f672f9cda901beef9bae32ba7aebd2b95a06b1e0f426e1cb6a8c9cb2f3ad0b2c596679510c99f7433c4a4c8dc473dd1a111204ccbf5fd4af3fea70cde3d4d3e02e5ccd1652aaa8fe29e62c9e1640468095b0c749e84cd0fed2f70f71236f531ba4078fc0076828fdbf6c9e45d919f83d2f93295fea08774075c7dacf73d474a8f0e20cc90fd4eab1406da6dd7615f0784ba645fc3cbecc39d544f40be79f940184355459b5def79ae0dcd7862d33af4f7e3f92a342dc78780d5de09d386b956649808af387f556b0248d4b8f66252f9b42d17d67f7528a6dcb5417703915da6533a2186bb7de9d364bb3da03729b56a51d7f6015789d64073f919b335350a6ef8875d4a5eaff4c87e8157af8ce5e836b0dc1f28b3e29edb927c8da5598743b2d217846feeb0a795d6df6275d0e35d0941ff16a11d72bcd389f9fd3f568fb097e4ee1ba06fa8749d08099d92640a2f66badbfcfc51211e8a248c5c75ff35f42ecd4605e04a02fe4c93a7d455e38a7703786736218a22f997cbce56f89","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
