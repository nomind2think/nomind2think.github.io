<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a93824bbbb694643fc0fdb8a3bd9c105767d842bf4316267ba908152bfab53ad026f1847218a57858959809d94d12f197f24cd59baee63c1ee67f7cacc4c43baf35d36d42c8a4034f8a432890c9216c57d0258366b76a259d91c3f5da6276fe50f8c563c1e9e264fa05feded83174ff4b324da3cbb1220acf2da6de93c444d9fdef205272163998d2ad60bfc4593dfca95dd18104368b2d1a55434daf41b3778556da5e8c5666e915fcfeabe6557c9349c8faf8a794b1a424489f76557eea6dddea7d99fa4a68115f827a4f5499d53bfc969e9f37f8ceb878545424bdbb6969b71d352620e9d2acc2a75f43d5fac79fdc141e5400766c70be92443d7bf5df98bef9bab7b47fc67b5e2251e049a0e060adf6a02e079f7344d715ee90e6275beeee07f926a0d3d4986806ebd29ec7c875dc7d55daa3e37a4b75be7a546f92101dfa2f1977f1df5fe72b5f88b4143d7ad8bdd25c5fd96dc9d777079342629053a22183ec6e15de85daa0d15054d562952840c24bdc953807ccbeedb9613bbff585d87b2fefd9e9f243df380824519171e09737fd53219fe6438fbd03e2a6d03e62b8c9033a2a13cd671869b38da313460bf5ed6db03db471377cfd83d69bd5d3b201600907c036eea717f151fcbd627aaab34dc8a920b98def6f2d9e1df33b1b3baff84ec11895104c659cb7c77e457ec40714a0c4889cfd908d5b070da4489bb936a45f6c2481dd383f42f6269b1f3ee432ebed0145faf2ecea196a0132e1255b472e07cce018c0c39290cfdf190eeb0cb3a925319c7ee4e81dce5b7b77d947d06406a4b3fabab654d8d0c60dd2c38eb6c3c4663a1ffc32194d8aa40360bc6a85b188a24bf478dee0f3b769efb4cc7c61022a3b58c63d4b8efd86e2cf82ae458bdfca1f4b16a07a22967cf7e3c43255668a70c735f99a67d563aecaade547e93e697ce287fd0c856b55928543fee83e303b079462c457d9352fda25d8bf4a4dd3256556ce98213a5e9d3620bff61c352bc2dba4a16417ae8145155de4817e19610b174188570430dc2313fce9edec12b759891497d999f6ecf147cacafde063ad47d96b51c2eeb532d87c9d238d61129083e61457e37d0131a38ba27494837794ce923f0bf6181b7950d95683bcf7f25fbf52deb8a200d899217c18211080ba8db799a072f21d0c93ebed02cdada8367cf115180f039a331ae37bab8b1498db9ec7ff5678f3b753c5e2f912955f5fa89cfa31513a67eb07a61900a1a2d82560e4b93b0135a4d2f6538601acc29c24be3c80d75ad751a7164570b1f33ff9bc9b664c725b46ac64ba222a03afc38778c7b854a8b2df498d37b2e8d811d04963ca427ba18c25c848cfbf67f3c70f80ec78135944da3e9261e351270bb9ef47fe91d126e4d0796170b588c203829d870d341110ff4c0c181976bd340937dc412cc827f4974752f6fbbc75f747b906f26ee9072e8b682fc317c33bcafdfc45a1ae45f25000a00c22b745bb068ca9adc321522e3d09f7317e944af589a850eb5bbdb1667271803fcf1820571eceeae515d36583222c2ed712618cbf7123aea0934f06fb18dad8979382270dc2d1b2eb4d5861ee05968ae62403174c13cb980f32cc7aaa39190bdcdc1dde8654ba2a37c234d77102b559ca2f06f9acf4a1308ef0e1d8695129feb3994301e996e6fd11f1f0af5c5d94617cb7d3027fd18d3c922dcc2da8cdeca9dae3f8219472ddde49a53e3dc58d1c6e3612c177d6bd5d2ad701d2210b8e8f3cb35d87e0da5cc1615c5577e45a3bab493b7e6de2eb64b56cab0c8a32917162b8a5b6f4946a0c871a406a9bc108e4245e8c966f6595d944648f08f8d0581e869c01df6c83e7b662e86011e6334a7a3009ffd96466cc9c633b8a861b1eb9a80f6b0c7ed34d87bc743056778afde254f58a0698830d79f01406f22a564608283b5cba7bd07a1e76c3b8a5890ea2cbf4163f0f510f1b5d3b72ca23d2969bcf299d0d9ee4c0641eba5a8c582dd1a38341cfa1424d6b992497167cb97f1b890798da7518f6fb8af37a290eec8f8ea745a1f17c8847b711fc147211609cdc27ce593ce2e3e7f7455db7f560e19a7a843d138ba7dc2ecd2f2d5c9d86577b49ff07f75b52c79a20cea8931c95ffa7e4532765db2c040e4b92e7d93df1c7a99bb00f4b3d42a2712d06d7b0b00332dc5cea833273388e1c6cb4e47bc4fd0f0a1b0c2f43638a84b4024049ee2a0cc079d6483173d6a3bdd56f15bc9ce034e703a724cea8adc21ce7f788bcebdf83df65fb2aa7a99c29aef0988cd3b439a8a7c0a8e074e01b1a12519dfb4080123729291846482dc6ce16cdd03ddfee5fd60774fec70cda1858f439be39d683462112889b2c4dd787f3740337cb9b1883db0d56e42eef9e765c7ac0d0e6cf163bac3d9151e9caa93e3606ee004003c2330ab728580236e9f84a0a84d10372f65b2e756755f55dd69ad52752ddc00462496cc44d1c0a61358b5174317fc32b543e3ec16c686b1027829e5400ce8d07b5fd1f5b3269b7ad4bbf9804750ff91fbc18549850ebc8e67782646095ba5b0c161290433f88e008740cdc525416122cf79773972cc07405ac80cf4514e504f6909ec95b81f1776a3a2683a945640560e8100e8fa90ba3500aed67fef911af05a26b5cb3532830bc002545a6d772105d1e893533f5918331a7526550a664f52936acfed1cae813138ad66f72e2bdb64ec374b3241dfc1bfe65d4d4da059344341c9659443fe250ac0514aec446b99e33325c0d57423ab6a4a99a9ed11db3644ca046b44753538be75a6bbbe70b14c190cdd738ff3117a6780d0f71422dda25fd5d4a87979f2c30f61300d1c58e8cafc927b7f3a84a1fc771aa7c3f95fae8e5280a36e968c05872274f2e6b07626a63934bdae295b6dc55c4127627a8ab49e1731c35f18714c8bc417134c32faa339b420738e45d89bfdf780ab543367b2f3bcd2f7225ea59086d9e2629892fc6b60bbff1c5a53f3499970356e3a246c5812fff9057ad7388066af0c1e1a14345a5b8b844ae532b3b0577bb428be3c629ebf3745f7209f3ff8088fe0accc7f4b77daa10ed9250b0080947e98ef6e9fa3aa16303cb0eaddd4b7f52bfda64c60dffe22277c4ec1dde9750b0562520c14f9fc4836db6818cdffe928b26d6b4a62808dca8d2b09fc876efc71ae2071d1d94ad31f10e12902bdb8b828c91f594d72ee6a4f214b361e260eca9cf3faf92110bab9ec4094690de5400914a870d2e383e94ed0e7a6b78236f4a3de90137dc2cd767766747dfcb586d27f3499f13b3b15d68211f7543cae2e65f7a9d5ef877ee3c41afa29ec874ed95a22bd6634c851dc168e7faec982d3215714d60aee21c80c0ec7fe1778573d5239a0b43d1ba57f2c66d5b2b26cda72a1a83ad051e6503c0d7fd628873be59acd1e75ebf6ce45d92e7156b3b312b9f1efa0b0674c9eae1229312b0cb4cc4f587240994d1e693d2ea4129b14ae64f95aec7473c931ca0958728aedce25a8f374b5c1f7c49a7432dd5a59b87818bc065a2495ae01bf38dbfab8a80fe93a9a70d6bcd63e615bbda2d986334ff7fbe8df98a5a20277eb204c3a7879ea30b88de28e31d21370303c35bfe56a007242bdfe568fabe9b50f2d3dae401fd5f38be183387f20353a97428744afa73f391f918bc93203618006d9c28d2b58c55c401ea3428a760d0fee9e5deadf65c5c107dff3e65ebee1daf8002fa328f357872b6c6c6c3d9b5d9633da01ca988f134cd37654fb1ffe4bbe8ab80b50f718593426d33e02ea2c9ba1a1466e4d7700abd94a9380013ddad05c332b507aa6b587368783647742df77f576fadf60d3cc3e687aa0321da3272a9e64021df4e676133b55a107971d1194ec8d4bda4eb67975dae93c6495f9e5a52c090213888f63eb1fbb7978bb74bdb87e5f97fc98be379096dac93a092c32a36432ea584122fd250193e15385a30063d0e87f94a0c7c1683dbb5aa68220e429eef1e579e84e86f6ad7682a8dda681120913b41bd7ef6190275d8f6e5dc0aabc0c76f15c82e366d460e50722ee990c81f9506fcfdd28f6f43d476cf83fe8b419b4c039ba8dd8832b1596cf68e59f4b00c4d5d6156611e39a2e7b06decdf4269b69b8b99aca2793b71cf9bd46a57eebaf7c12aef1c9eeb63d5c716d07054c1c55450787f4d1893aec923ebd737a7a5bc5db973142bf45cbe29bbc41683215ad2584186691c65e1f6a526e42b8c890c8a90f1c8410b761fa45d22fdec48d9892537ad2eff77cb7e1fec6d6fd40beaca0d93b53e88c3547b59c4b37c8e296f54ab23a04e47de0ab688c82adfce8967ca0cdeb9a0bc277185ca9c6d51456a3ada6fcaaa7562cb0ff4f06c6bcb826f3dbbf981f1944446e9296926fd27be84ab1afd81b317f316706f3a9e63c5b8b322bfc8a4d2f0414772f18a7d8037f6a49552e637debe1a98fbd57ec6604e73ccb1de71cedd3c8f5a14380f4a44e114545d4035d6176ba576b57100576568096e69a10e8b132c00c48a75965edd3088b27ed5c2949f736af441e5cbbef24ef4d52dd1b3436ae9dd767466cd876a9bf6b85994b6d04c439a38ba7045d9037f170e7d02e70902364854cc210bf875f91445e877c197826eb1c6df8929b50000d78e071dcc52d3403b67499024735827b6cf2b0e52be3c3026d47a27b411c561e85f3d3102a514ea05c288080c492776cdd345ece0d51e3aea7fc4103ecf67cdb6c2b541c2906014d37e82cfda58f8516122af6537cec40faa2d7159939e4498e287cb96b5129a51b3b3627fef0c071a0ab3e585b79a76293a98008be3f539f324f966d9c1453fc5e5a88276e841f133f535ade91b6118e72697a1c7f9c3d1a692f12fa8296d4d5e1d0e219db96f2b1bee5f475892debfb93bb48057ec7e38da222e8768e44cb3a7fffec1ba0f87b4baf7c3ba4ce700e39e7ec2a05334df7ebd50a472c10564e966a0d019a9b8c4d1fe7a2b63794860492fc3aedca5b1e1faa8a98b1e824cf52c5557aceb617b644d8b9129a70117d328b3b70c6626745340db3e5046d9f373d4b834554d4637eec977b7a367bf6b0cd9874884ee6b05168e0ef2a918b6a5403b923010dfedfe8543ad4f719fafdb4607c8cd5c02adb504ea71dc41fe8d9f2d928d267a85f535a60370eb6456f1aa916243d11d1302e87aca0c3459828ebaa9c1655bd9fc60a0a62a2a3d4f98ae7a89bda23cded321b78ddf8fe28caccda953e846cec3bd5b10cdc97bd18a3b4dbd6139f0d5ddabdca22fb48035cad770018854ebad02eb24581a7516e4174ca1651b09f744549ec4c1a635ae60b9c6c1b1fd8e38cd100755280c6d7f14e646990befe9bf15ee34414e7bc07f082992785d3e8ddadf9f79d30807e0f3a74dba0d77d7bb7a7cd41751b6c14173e2fc8692dab875cad36fd8a7f94415f041f4b77e1cecbf8aaf01c9c2cc745dff45744ed15d3cc5dc7777642ebb5218e9cd4126643e0dec138631a6c2bece2f1819fd107bee66bfb35dc5938366fa2e15ab083986905962158eb7ad7f6021549074a47a44007513dcd9a55fe326b13c4c612c6cc6680a39539e324970ab43fa799d25d26c0822ab7299a4450880a5973ee212ccb0f3be777a0d4aef1885ae738de7c0b288d601ece9f4c4f4dd5f196c45233246c083f3a115273beba8a68786ee7e2cf6ff0a0a5803ce8e2a93993c82850a603737a098ee4424273bf17b64d478342633472f40a9624a36d128fb772a1528b5e3084cbde64fedeeb775b5afdceb775e36a3757c0927c90f57775bdc12932b2f45bce0fcd0dc9d8583421d8f30a6a997cf31fa02ce284c4c311328860efb93b8a69d18d3897594d42f5ffb041a812ddaa621763c23d0dd57b3f4143c585e813c20f2d90cb7bb2a2dfcdb9ab99f83720d5584f8b5761a6d64c8fa1d8a105d5472cd247bd2365aa5a69add3d387b8dd188f97b4ecd0c7745430374ff18c9945b752e9e2cf846f4e336184d39116a2ff85350c3d48825f2d12f6129200789bfa7914c818f904a8a5f8fd4e87acc10d72d9b81fb89cba6b98a1ec10cd1edc9db74820bb54a43fa5590dd3c17a05479a24e1dd05206e737ff37d04e33c0169d2b7799c46f78894b169ae061404e6b3724fd5cc3dafde8f5fedd81b5078fd78dde731cf7929c43c9217df2f6ed4e2bd029306b792f8f20ac2bb985e6ca9dd16766edf7333e28ab681add672792fafabe668cca50c0690ea83bcee99a7c853f931c58e7640162dd6aa0bd2319719bee4236e1db3fe8dbc8ac43d4115a7465dd79ad843c116695fecb23e372718bee5ed6a774626c30b4ea351d55c18165e30ffb502bda5166a522974ab06e2335eddcf56dbcac347a6327cccdf244cf18a4a84c9a7ac9f5a53e08731e9559b443c5c283421cde542dc3eb30992623c7b35c09521ff436ba6ad2395d4659865267a37bf18adfa35dc261be10d2e8311e7d5dfe7ac57d486163c3495c961fde7a452f77b01e6437fb26462b0feea39e73b8ed0e421213240da4239f1a92200e70692c78d351f21f1c6a5e2d644e27589ad143e4bd4a7b06f02329018fafbddcbe463f2b9333bafee8d575f13e3bb2486effbd3befd474ebe0fc83b68606576e0c638ac8093a9d3563f04cefca25c3b4164bca316128b1572324ad40f745abbf7e5305370f88cc925aaedd2e45c18c296bc0c5b69ca11189eb188563b3b35f95b51def2ce394390811cb86aa74050e525f85d5324a81774dfdd2d90d8ab861ce53db51c93079c5b037f66f98a09921dc861fa938a13e261bc4f7977577d7f40ff506dae7ff89acb48f582466689277e5af2b5565a2f0f432f34d88d30711809c1d44cda69033dbf410b6e7736b7f8bf06ef5abf5e8959092740599594efd8538374e54d59fde3ad8ba5f0ae2d72e66b30b70c2f21ebf16e1491e0a53dbd6408966367f369289a47eccda53c6c97c62d528376bcffd7bac752667c72ad058108637c16aeab8dfd6daa69fda76b9103fb8a4111b6ece5fe7cc26619094ed859c9bfba322549f33dde327d9698ea82f2f34784a8746bd2c379b556465dc0a722f900cc8e2b6481d4f2284d4fbc2b40db6c5678969f051d7016644374faf167092ff12e908fa2af4e53bd2a89ae130f2db3701b2c756f81090676efd69db9eeeb136f5a0ffa58544248e7f96bf5c0f17ae90a39152b6d26bb594e8b87f6defc4471aee1c0183f464e55f2335ddca4c87e516c5f1ffab7efaa8659a248a2c81bf16dae7a42c4560a776956f2c52bc7335d1ee744e89da54a739913a7fc1244760dfb2f7a7d9efc227d7a2059861d48e6f56272f188f135c84cadb1ef7ba2e82b9baa35d42ada8019397c6c3ea0a0913f84e808194e75858e1a9e7c96092bdcd54b522dc5449af23c0d80242c2cac0fe704227600d5094885b6294e0ddb8a3d8596ef1d5d89a66ae9c1ba479014696c411e7a9e5f821c06d896b6b883448bca8869ddedc35997222528d0009930bab1a1d419eb0e6138abab59958ba01c1258dd634b8d98022c116ba4cbd14e5a4ab04f82434913a0a75ffa3711518c22a8306463507f3a323ef8a0adc2253ef40cd4573e8eb02fac1620e8cf68a4b098b875868ca5bbb51702edc881e94f8c84d29abe486d7a58db12f97a22a003118851ddbae8c2c54f5817e0303d2ede1e9f55b282459840dc1219c7983b75e54e25d999b4e7805ad2c0eba9efd1662b1a6e4ccd83428634bfc9bd179f2b51cd15ac4367699d9f2129faa20771608890172f428ed4c21811d0eaaef2b282584a0d982ae2f034eaa3909d178b3a094f54eabfed43100a25447753fd11de71b2543b058eb891ae3c08e206acb185e4dbd7adce926185d9b3919743afa181ab8bbbae385de454c7f6231fc87925015e3d9812780262610bf89f8066616b00d3c3ec1490fe341b11002e897645fc5593c0cc511543de3e2b279191381e21f9e997a6f65c861e906dba547378fd6a771394695c478d81580fa940f2b20ac13c16dc61e3496bb19029573cdaaa663418d1c9aafd2ef933291bf6b471fb71b0ab91e67c288cb76153ffe22d3900f9972a49a565176528434beb3f231aa6893cd237e47e8497f5a997085d917fbb595e2193d59f0270a558e00633d9e2ad3113778cd5c0f68cba96d91de9c24967763cc3bb00a68f15f6a104d8c1ab12d63bad7be701eef82e06aab3d391deabbce6c09771496286c168256baf3e9ed7e7c85621e8a1211e40535ce6ac27e598728e2d2140cdc45199686706628cf686502db12ee47dc3f752c3fcc12f64f3ef21fc440db47f1767fc1f43d44bbdd0ab7ed47bd74ea78b05488493501932b5429a5dcdc5f8283ebfe51d7a8430f1fa6fe4b9c7fb8c78192615e9d3863ded84826b5b314f9f3785ea6053c3041b2a5c8283c71ad1c08de2f2e56aaaecee2430bc2d7cf4b06d9f6da7f685bb44cc66a5a76849798863bc5fbd9eb349206b10991aac0d860a66b15c48a7f64559524c151e3f3f5ec1d29e8aa76a2aef7041a48c3b4879b712cd226b0be65fc2740ad5b1e8b0d0b53e0ac8ab5c4d1ab4781aed7579c6393dedc33a669dfed180770392fae6ad01317ba0db4cd2e3da6bb5556052d7e6f44b2786e4c7bbc78b24078d237ef3f0763a213d82374e22091a59af5f275e7c50d300ef4034c5446829f33fd37045f906736d955f1e889e7d27e009d15356a1a6423638b9fe10df45e33f7c13e69e443a74303c837f6a88bad82413541fe299a76883fa9c016dc38bf103437c737681ec8f53c935ec0d995e04298bb5b631329405587745b0159082c8ff4dd211db109e79819391b9e8cbbcf3faf39b4c10c57bac7f3ccb29ccdf99b019de3dbd11ba4ecf2a6824dc6e10a44ac550c5062107ec4eb9ea01512bca7f8b1077865567f118f40ae8a5b1f1a20bf1ce9723071f447a7495a955280d6b83719d0d1f9f2de3a8226e246e9bd971aa0e3fde157c9fe64238f59681cdb6c0c01af1caa920550489f5da2868db86d789bcd3b2a50896b2469bb67d17bc8f3e44ce4e40ee9732de8da5ab84dc18705b485f4f748684d80a9b5cc48798e4830064f1f232f64aae09261191da9d35fb4a98651b3906e2216109419e5d24ac4bee0cea62fb764284609c17f93d5a21d4deeeb09726c5a5491d442a50d3486e91d39b91363c1ceae88aed464015cceef2fcf1f5a857f2f8e21a269bd08eb7f63da146082b6b042ca8686bc7f399a99e7a6f52ed9f8c809ac27489875ef4c52d573eca6144c4ce6dd9d1b8347e47c29e3ec55e9620d78b83d8cb932863f44670880b31d22ab768cbde29e28706844468fd90388e8c900736dd8f1b7297ffc62e94df2f517462a09b66842a0adbe590dc992dd9aca7873c20a07015cd02c75a61ed252070008d6a7cb6943ccd0dc14eb195c3b4d747e2e98bbcb3643505277316f2529eefb0d83b02bd01010b1b2dab54a8cf850e672b29c02b5c0541ae4cba095b28812a6a6318fcfe690998e6405351af7a73d4c4e558f0fe08532cbe04d3ae1115d3fa09e16956323cd85de5a9de35b4e32f08341d8c1e0abb0d0b009e2dbb6ca3cd356493ebcd648655e546ee2576e3c491286a43ea866b54fca38f9ce88c4dabfb58f4b5b4f3f5f0412d639dc200cf5c1cf660af5bd8b023830c5947b9e66481426b63dc97577d394bd4d5eab107fbaebd545ebab2cb6a08d331f5dbed9ae43f3d188921c486e23a8d5f490e5b930d9ec3ed063ae56c507ad49edd1b81ffd466847c07fd9161ed5041cb6631050d87967191f7bce201f5679b993e8ca44f094d3eb91a16b0eef778808d43993b57e5c1c89c54be0b379f16c03e35560ff52aec0f24ca7e58928b77802a8440d23d59b684988408b6d420bea1eb26d00666ba2d63252d9bfefc4f691d2eee62c34db89ed3a1b712d6ac8cb18ce65073c9f899e0072febdfe5c5d3a72c3d58b2ecd18538f37dcde860d33fd13a42f95493d81e8d245f9477a009c23e2b714c6ad90d6a54b292d1e1ec51315f4e2b16b82f678d4b7699565b216c7b0f36349f5cd8987c53d1c556ed82ad550d074e0908e5019af470475c393facb4245c48cdd048bff154a6b8a95a774f4ac4dd0d4e9cb64922f4de99cb3edecd89e5d731f9f85ae6ac5dd3f2f0d0c53cae9a66d32a4d73f1b72345a032bcf717e66b1c4ccc84814c2227495fa73f8cbde2eb9d725c57ad80f901e016bb571836d6ee29452b2037d823f6e5f4a8563f429b57ad04597cb55e6d1f57ee99836e85a0d2ac8100bbd08bdab96946697a288c99a3ec4598bc6fac9e9aede36ce049c9c879be540766306eac873f5c4b1564a42597f0b29a9b63cd67a8ffc3934282d7cf89f01abfbdb82ad7b18cddd0337a22790830ef8306aaed8bed92b6ae9c2dde03e74244ff1cc1e738b424086f5eaa6c24351ea414b9e830f68408cb444a9ba0c078cbcbd58225dbf4ce7d64fbccdc902754d89bda5d56a42423a12aea8adcebd3186e14f652bf5a5495550030b5afa898a1b3e48a1f4fe4425279fa615e2a2d78923577fcfd320da4d0f7c3c30b2527eb7edf530fd2347ee42bb6dd23c0d1e51301c0b1460faf726a6f6581975b7c866620e2b94d75ad6b596e9b4970def14a4e256ab08db8eaa8ca05fc20e9f16b28bde7ae23708d89b4b34c11a4b221bf98d9c926edfbfe1986b97e479743f8a6cdeaa6c907a4c36e940dafce2f422","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
