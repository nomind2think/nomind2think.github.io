<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b1e90229cd4cd896f903d5642d17d35ef9ca703f2928b37841fcc48bf7e8bf8ef67814ba1e668c805fa35314071c3cf0643521a88be8c4ab731e5e126abb3f099dce8db0cfc15bfc0ba82627ba191730e4bea8a53b73ceb371c10a94c71e82963672fe5b3201fc76c434798578e4b21dfc5a3faa805bcb1ef0ca7a9fae74cf48c139c3bcdf2af2b2b8e3f0c35383c4f67afb67aa895ef628670e85555a0a629d63bdf8712d5953628f3c39926e5f203979841904a3e846e6a89dad208032f341dbfe7fb17d64bc012dd7b2130074e167cbc44aea405f53fd66c0029060e78423828ccba60e4e137d7fe856da604bcc088ae7fdedc14274d38da915025acca5a9d5ddce92ff5bd2b099a7d5c693bdd27137ec6e6850e9e2c0a7bf7b57769feb69a4bdf5ffcae7afa77fc47ab0ce79f80221cb8e69f1f59128d2bec451af5252fea280c7b5d416b5ffb8b6e8ddc5c82d3a75e2f6401ee520a815f7f1c87f83b1d551f3a4561c1d81f23f0901b8930227b078be1d7bb3dc5c961095eb4be96c6e94e5b2914563843659dfa85ebbc8519264ade5605a101cb667a8401e83270647e251357b9db47b1d17294ce6d0bccba404868ad60434f18eb219e31e0ef5e1352b4a3d850d4f288f9ff7b8a5f08224e9e86d5cad9963da09d90518d8e2a438ec102eee44e09a199935c247c9846a1050dc42d79a8e79d954ab3dae4ac4516f768bbf6e6f23e4e86a7e895288d3dc8d238bc024e5962a2ddb45b3b81cf354fc9c29ed7f48d7076b4a55d99a578031997d4480a7a4dcf2e64279224b79ff4f67d06eb78b0144b3f47d8cacf375518b0351c46dd8fc21f37af07b14b1c9f92babd17081a2e82563ab012c99c63169f6193fd690b6b178fbc97e37ac48c26defc5c248b267b9336db4c5722d8f879492487fcfc22535af47f9025ef118281130c3a5fc489868531b31fe06b5752948bf444cb09bd3dcb255148911aa6f1987ff66ede99ba87fea820ce539f86a5b83047e2644d31c3e96227471746b6d29c2783a31767e926e8814b986cc872e9a5811de6afa722faf10616169f52e622a12dbfd94e574707eebc80c09ab1881716bc8cc3dd2b784fb5291e53a5117e76a9658751d53201f7dd8c3137582472a6f247acec98974cb93b8850125e7ae2656f5b02adafc5d2284be32db3d6a5fcb541860744ab7f4fff31349446eab3e0a4c3787770c13cbdf14556cbe3185d8da134f8829b3186dc39782bccf9df06c3df88330e46ca9d7ab2541ffa0913b51c4eba3e31ec615e8d52d24d39a828bd182dacb68910e428139a4223393fd2ccd1fd28fb96ad507e13c7758f3d157da7fb6d26e35042b49d7f4393697a0156711a3e53bb1c603f9dd0f14087eb9a3dece1e91516cecaf6c4afbd217ce2c1be705356150b316458aae892a3890bf9827a8c16422dd86a39a01ca816d892aa2cbe4d39781fcb380faca55c4c9560bf466d9f532559bde61dc046fe4e8688d6ee5e9b85d11168442762a83c2e8f8d5a930b35658a31499f23fe5b08240fd4ad780fdecfeefc2bb50f26b48a0c021ef90ce7b45260d8343b406b70385e37eb2fb99ab431bc73d793a5d0e3f9c7421efe08ff60e915df879e4178477655003d74dc3d7617bfa48d846214c6782855e874c07375370090bfa518db4b573abd6dface12a053e95e62bad013023acff42ad9550a2983c944fca7a0d681cbaca1c5f8119f30bdf7d8753afce9ca00db442ab7f168e0b24b6807b5518512e7dcf3a144670a3202619e501bd6de50d6ae46f179e8734d957678722c9108d78eb95ca31f1c9bb07022badc78081fc8cfe04d394c8fa3c08484287d08014b8e9eb33e2cf8e545945b29b4d46e9120296bd4a9b24c758058b3774f3d94311a1543da31743af5e2ec0e937dde3748be7b23dac989c3553d240f776a8cf274dadb9e5e25bf28e990dc10b19412acbd301076b327f9c5bce1714a9149a40c29841104222ae05eec79951591b89ccf5f01913303f24e4ab3b0cd04096c764c1fcf7a189b1cc5325e102d5edc2241b68a3aa699652215a6400c7f6281c8a455845f86efeb2c4e5a15364342b878f7f500ae30105302e7f1ad9dd71c639de322092da0be4ee9536c38e2eb95bb27e57a7a7290b3b09bc339ae0f4ad69dfde09864047968bdcf916084045a3d636c97c2e39f9e8ec7e2e1e3d7096983b14ef07cf14a5bf67ff5ab12e32fab5eccabacd9c569059296158f221c17d5d7a4888325849def839fd255c54cef2adb50c31b9efdac617e79dfc94ac67d7f84aacc2d272a625ce349f62fe76b8405835f02018168347beec505cd9adec6fa0717344ae9f7985ca04815eabc3a25a47c7662c023a5937960501da5f8a615e26722501b21e94a9db896f28576843953d723af5442729c5ae245c0d224a2ba14a047979f7d70036179a77b30edf1b0f52ac9475ecc82d15b13ef8c1769dddb95c505ba2dc8d81eff423fe3dab69c305a4cfc0d739e122257a226756e494397550a0730faed56fb855b03a3481cacc936b1d7161ce8e403cfa8b94cf9395e579484bb7c11ff27f512accbfb517d6fc331d268af32b641309b5ac41ef374c32ffbebb4d8761cd38b631b0f630a3312da047d13a9cd5fe89de247f06a0aebfcd211dbb318bc30652d6992df735dc5c02d2731bb346c34efbe3740d7464f9c5c3d41f29fbae2f9ad1af5f70dd42aa0bf747f626953afccae845f1e8a370773b7223f01a813086b01e0954a38adbf74cb67c8f2779a8df576a9b3e229e659c47beb147a99c1a6793c62ec19ed39b4b5d5462a8887a44a9512375d3e943cf024609853941c68446b24b01f9b248cf0c2e0734ff6105b62f5b6ff2e9e61017a64ce98d9eb9c3f7dfa0141ef5b854afcad636e5fb4c5c76ce43c42d6d582d6a49b7224aec0f527c2d4e8c43641d2135f9b9ed3782a9f376114ce835953b840a71aec461bd33106ff7dd43f81d0ad31b3fa209f2e1c820a8646cbe1f7075690af43c6b93224509c6f54dd59d1811d4a481445419bfadb8e767b21f1e5a0210f6b7b77bca861f9537df727ae2b086519b04761d67dfa50ecf18bddf076e317432234cefed7097ebef46a0bcde1b8e59882e394b36183a7c66adc8a50da0322a4798ab4f5f1974ca00e565499c8715cb70f5ceab6935dbd08abe466ecb23f6ee0194c5d3504311a22cbb2a36e55f4bd914ff5ed45dd3505bcc4d671b5ee217df5aeba875a0ae7e35ebaae47a8a347826cea3948ba358474643a78a0b2b4c13dba0f8f8352445cc1309c2284ac2bd7360e9f26c7eff4132631ff1b9af59ba01170f9ecf9e5fe3ed717705b6a059bcf51acef7a24e62f199a05bff4c1990133338d1866abfe6841d55203463081b333cf1793e502e1ce24edcc4e01983aed6c12493962f4364dc1ea21498f60ea0a1a494a5037f52f32fad59a617dd040b07d7f7c930209d366ccb23b83d9f89d927ccaee79d8ecb957305c6d37d7064a9bb68b2115c0d0fd9b3c42d7fcb0e2c2118a6e4adf7912ba9b0ca0aec3774a36db27b5032042de9aa5c8d30b2b9897b8b3a740a48f3646d72280c1be877250823ef8fe7e1fcab76d243bab71f91a56e9c94496fe831514f15ca7bc4c7925b39a1157ade5d010e5041745cba2ca4a02845072081b875016ec18a907e7e6945a006a3f927a71cc846dd63dcbce1d3b134313f6907140cdbf859cd2387f21e0fb65830f06317e8aa2b632c368555a2d9c4475468afe1ebeaa1aedba57c8d1ef19f207504d964a6374c3bd75e0e49b22dd9ef44dcecc2c3c5147d73aa3c5d37407d978989331889696083b8da96016b2332350317d516a3aacca7e977657e1659a194567d808fb347dfd2cec9c246b76fc3d9d6bcec66b9b4803e232c6e75831609e138d68a7a22546f129b01c023b98fdfdb358f26c81886fcac236b19e5bf55edc2551067d1f0c15c1850fc7d1b6013bdd5e843ad47266358495cfae6f1ebce3266d4520908d4b736a1ad925d867ae4f4830d7a3f57eb382f762409d68b46b0f27f53ec564762663a5e15ea6d437377455c9af4237c58e497429bb3d0f24e2060309c55b17ed4419ecef67cef5d90e66912b3d434789d28167ed976d1a0346fac02045c1b58d76ca1f9237422263d8ead6a92fd89d69b999d3cf248b136068e2ae9a81c7ba941040b81a179a1bc7a7c704ba73feae4aa0b89fe8cc19527bb3ac68b28ed9d0d6876c622548fdeb3bb2a6857c1c1a9868f3f75c998bcc27ed2e2e80468c4af724fa3b6bf98a7812fca65dba16f84785bf8f2e8785bbdca7a110da6861216936a1f3c83d1ee014ba54fd0f89e36ab0f064e5f0e525384f0e89ad09f99ddf528422723891b0f71e9b0c66eabbf4dac6b8bc64ab91d1af09cb1bb383b98e97d4f9b32285707e94384ee50e45cfc31cf513885346ec36b04dd7e32acddfbfe2929f1c55c58baf70f2c41a5ff00cf2cd79cade830b5c566204ee80027e267ba886552c665369e7bbc250b0683d66eaa3fec2089087b678eb0cb512a1d5a81038001e9272ff297f8761fc0ddaab523e69fa0cbff2aaf53407367d5e2196c9e1ffeafd131b85c58a9def1b04e6e4b68d75d33764774bfa45ce44a6529476fbcc2fab5725b627a48488d069c8208481c1074c0068b18207b64fd81ff8e443749135961e9a8e6462dae2cb69db2c48fed51a9b259e47436f5ab0c881269c801d497b81716e6502aa77b358a63d3a731d91d64b3af30d659573f5799262168301439b341ea09f556aed699859848eb4d53ecd6678f9e46f34167f96ff4a06616037da51376bcf4a83100f646c535da0bc33b541c0629bcff77a73043eef7d856b46ead664fc2c2244138bc96c130e5364cdb955e79e0427c7e6a63c0987ec00527721b11d6fcdea484ee2604e5574aaa1929a499704cb4f698d5da1a1891d4d45f72be6eda4aa6d37b26aed07c92c3ff4128bcec54afed76809ddaf1dc0e00ce5bbbf897cd1744a497a16b2b02593d193c19049f7f6b22d61c3772b0f11e970a7781cb2bd8cc4d4044de53cfaeeac7ede5f1b124d39b555136b1f104f0e7c4602c2e0a6888e759bdbd45a9f5b74ec6dbd0d68853b93e9ed9c04d2816997692e845e49df9bf34e544a81cdd96bff3853223f04418b70d3f864fbab586bd46834ca36046e1f21f3ec162961e701176b3fa534cef7c6c6a1add59ec70ece3eac9c63ee81225fde3bc6c69cfd0007252ece59588bf4faa7bdcd85deeab3d0e76ec968a0a164fc95d712905171ccb354a368a45214e962c97e128b535efe28eabec13703fea672375344ba41d364e92c75a733488ce08336070f631aea744d39f196003e8c0f6c4bfb8d00bb945d755dc0faddec2cba4dcbb61c46b9dc4c31e5cb227122898301a09779b85b00c2325d060d0c01eeb6158541ff4ef45014c907481aa0bc9515420454fe2f33b8c4818eef2e9746c2d2c54a8c397a1b11572dc95a712fecd2034ff231172b0b94bec87e69965e396a047538803db0ceaae6b10bdb155f63495a49934f9cd88a5740636670d384455c0479ea991bb5a6735adfc8f8d2a821cc6c40fe4c1c8f4b65dc05998b8558631f3f626ce768d8fb50bbe226414497c27f3972c031683accea55c944e6513f3224ae3ab2f1df44fa3d2e2249ac4cb0a60c5c305df3acfdee072b440ace4b2b4fa6aba5c50cfc904c321f734823aca092490279e5ed73ff8cb8656460b0ca7b3e84eeae4aa7857efadaefd4102b4b594200c1f28b4ded757e8b26d3f7e568fec95230962fc24a94e9c9c51680b91baa3378ecf2f4236a60e5a3f2e855f3f2170159e373ddc0da3b19e709bd99edb7777583f1ad4f72886161d9ffcfd1ee157d9a01430816823a4fd9ee84cf3db456b7e46d919ba563b9005552432ffb62d7e34e2455a88faee024a83feb742a0390f9842f18a0ad83745c78b85c99cb64cbe322bfe005f20d014fdaa57e18796a2499e5e2aed27d042db47bc0a53d37088f671459fb5aa642028985d61a3cdcc6f4a64dcd6ab6215c59554133485c95b83451f753f0f2ec395c25b33967ad74d6eb537943996bdaf2e9f7efaed12a358d6f18e6d4135801feb9dcdaf4c44db87efffbc39337abef4242c520ef8785c562fadfc18052c68a8c777f9f7a4c23c080fcb798392baf4cdb553c8ee30a5fa599cbd4ceabb28fe2f695dcaaf1f6005d0499728de6133b1bb8db295050b8595de46beeb5cacb4c5d6030b01c603a41946456a0a77d6748ffbfb142aac8bc581d0ae2880200ecca04237be2f994782a4217790f7f4cc97e50d1f310c27b63ee48aca6d846883c3e399bc4c48181c003d0f2fdb62c3ee5e322ef7e9ca68cd7983d8b6eed41360ad3f64279b90162b5cd3a333efc583fea06e9357c1967c511eff82a5ab85d45fc705b69088d874688ed1d819020d80abdf713f5050bba43ea92c14e2205ffa345658eef6a2d1f8060da75eb9cddacaf349a44f8b6db64c26dfe2bb336924b5e7083ee85d0ba6e000d3605c9a4a3f9aa0e90be50ad1a086dc363d98238126f7b31e1c094a2363cd1415bbff5019e37d5c128b434e2d5ed47bf40a4e6569e3a97dde7b41c662ded6250129b29bff398952933e8cbb8b03110686abaa1911ff4e9d82083047be713bb55ba08220535864466e23d25e19558da04ca67f4080e0bc8066e90bef2b9c1d1579e1f8690e2911227ec9109416a5b35492464883aa37fd6473c03e0bda1a82e4286ffc605424df328cb41b22cfdf7657fe3d4f35131007424c360d440e2e05f2f864f892e57e2e750b4e7f46c7e504d6840a112526d68cfc95e7710c61259b011f41a26bc2a4335eeb9fbed60a92b96240d8fba35b52cfc4e51fea5f2995c06f3f370c3af979b2966318912f0fe909150f0580848128f2ce66dfafd726460794c4943650bb5eb4c142d5772fd67f437eedc179ca590a2cdafc78244c8be14b71f2c517c1fea5918b144782ffff6ec78e1aee767924514d55530b0f63f5a4a2a5b8bda0273c165fbb349d6475978ffb69f330c0046a6a99b2f0b3c30e5756ba3343c6e848bfa926f605a6fd25145f87aec35ce89636752f770fabdfb4c5d1305495145f300b2fe1225bfe4d555979f9d3f3ebac1b1670455c4a80238436da1265fe95f4e2bb94ce860dd395ad0e5514b293fddc93146e246b5deb13e604c4607aff2e2ecf5297664283b45e54057042ed2dc478fadb61bcff59db4fb475e545248384794cd759aa7261b283e50da532795db428a6498b76a6ae88875af95f80e8226887f700d2f179f1f5fbf54f0a3c90dd8ffc314ebd87d4caddbc58f2f1b7ef4a678bdf9fa8a92fb785b0f421fb302a74bfe8c1d36fb9657509b2a7ad6fbafa52d4c123ab475953e649ed1df7987f1ea78d50551bc7cf139df62820cb1cd171ffd06ea67e9718803249f486049ca90098252230e5691ea85679fa14136b0e21afa9e976c17aa30857b524c02871ff913df09d82bc12082751b36ca1ea0f9e500e0fa7821918033cf83de539e34649f79c08f196dc33867bff8d7882fc3d9891df315e04842fb899d630a59ee780822bba30cceaa238db306652a92d9de969adcc696d4da51fcc3a843dfc54b0a44246b70d5d930dce4fc44bb11a3291425b93f5e2d469381be9678b0022564c692b5a46a8b2cbc2a9d00d59ff1f9f146f173db3d148e1eea73371668adae52b7e65da6c10750baf47776b91f4175dbbb085a6970bc40fe4710a8e4ae929b6c4af634ea0f5e9544e4a804907b60a1c32dcc2fc6d6d3fb001fd15bd52ee546e5913f875e1db7920038038b7325ed4e1a09632a89d9eccae8c0eface247082e7128a71a997ca27407aab9634dc3ae50159084232b84b947436ef799de86fbf0b7b45abeaa3d8b7f09d45230f52ff95f26ec837f9207eb31b4293383934a993cb904b6fdc4bf02750f101efa0389e989625a8e20c02d6f295badd82fb66a0912758e396efb832703b9c2a9f594d92aa5f9bcc31d8dcb693dd8bf802c5152de643ac164bc6b253eec7a1ce7897bd59939fefd01f24f45da109cba80d478adecb3a83e3f98980a11193e8ca6e6e6909bd1c88b56a7c7b8711d711270c9575bc708ad7675ba8cca1ff5ed090c22f0876f34905655a310c4858078afcdf925a2105122622d7912ab3901e96840d60b733bfc8d8af97539f812e48b21527eea590a6ab1fe441fbfabdf81d7b09f272e7f636f91ce7d45f00ba1d5565e406c41b8920b360f6040c53e37fad5269f51cb886ede5f55fc93b70b8ef71c49b18d638b3a81124bba0305381a3c3cef39a52725643bc047d9f52a766ae277a084118a1eb028d6e56ad7e41be169b422baba36006446744bf6d74e7298f664fa8af6084a352479fcf7c985233b1360039780acccbe6800c8c1ed207edcb38c1f398a3258c11033616734a2209312d0d49ab747cd1fd5a514fd266d382118db24caa994379c74e0eb94fd75614fbd2b196cce40bf37bdbd7d67e064f704e6a97a7f76f4cad7d31ba225d6fcd04c89917b1ec79d3e39f7278dcddcd7421193ac57a9207eaeb970d2ca4e05411437a7b495f2b3a608e1463043034bedff582761bf64bdf6cf56324638c2121fedca58341011443a89a4658f1b5543c64c705ff72bf555f1335d9291e67b34aac1f229bc7916856ace964e1cac5f78d7ab7e3745a68712ebb887ba6e1ef43678b3fe35922479f6cfa664cff3fd0beeb5858eb3682f606ee2bd3acc5675ea0eb0328e308d7bd67694e0757e961aec62f694347fc5b899697d64b2422934e6b4700b1f5a938736ce7977ec36e4487bec24b25d8255a86d22976d32dda8736a914c86b541c17b9fb2dc5e7dfce5c8644c18aab5a1189abe32dd5b2dc51f0789afadfd78bfc67407b5d0dbc2ec524ecf076ac424dae08ed78aea1488095693013d4d5c0bca636cf99408d258545bc81da294e3fdc9a4b8d9689569ced266d66ef85d8bc2822834faa39a5cc7056e183daeb5155543e257f191ab79ae4d711b98e3bd0cd1db3e7e4e9d6a9ba1268145731af36fe1643a822f38e253dc1b314ae463ac3068fa76136fbb93c90595e6b66fb9a29888fabce110279e6e36e99ae7de6669788deff0363e94955135df1fabb60072303d70907b52e4f3c8027d031cecbab9adbdf173b0445b708a19e66b93f855e9ebc672739454a700179690f436a892687bf96aa3a027e039257eb16fbf939267ad2105b29879bdcd13f808c66077403ad8f69ae6a12b5c43cf5f53edcc797bee72abdf0be0e3c05593a4320875ee2c30686141550b3fb172ea4093301bac7b1cda23bd1790f5f7978039500745995e9ddd671231d78504fc37a1f40d5a2c76ea9922fbbb276d666ca47ba26def17ede490462516c59c372fc3fa17eb60505894aaeb9e82f7c5273dbc78bab954651316e7958dacecd1ab29a862db08bc1ec96bdc04e922792dfb02227f87604b9516c67818847162ef376326ad6eb22f6d785da194d685762012996ce066b962e84968894fd5c0c7079bd5a5464dbf413128f846cae4bf1a9708f8e3b79763a87ff3b146c68245a575e44288232b383efba3436c35b9c71cb70eed9752c61de716263ed91d851d0af80e150e3ccb23c93ba4a36e4c92b9103451ebf078e8749842ee96d3d64edb9817830ce48091a68ad9cf949dab54b9a44102b0be96903924c5539654f8d163ddd3b18992ec8a865388095fba0149322b4c19e782cff5931dfaf461d9bb7dcff48ef6e34a511e8f2e9ad9b3a24418156d53cc595d07e9cd14e672fc1662c1087e611f2d4186e413d26931769d0e840ed92224381a4dd11254ac587ec14538d682a84b8732d90cca875559b4b147d2c80c1428a15738d0b1362a556425573de652ce7bba18da41559850759b3ed9af4c40949412b722aa5649be9732d49d148b92da8ad7c517facf2e2743d881c78fec96e1c4f25bea562af9b08f7ad02937847c696046dec3f2df0496ca6a284c9c8bd0d1ae7d268e851e842c2b922dba01e4c147ec7067d2a55f44c263de1d15800c69bfa9cb049757bc884cc01751d873449b6ef8bcf4ddada1b433b571e29c9f2db898154f2e7fe71aa96b2531b0c19e6804699004933fc3b2b51a1b2635eb9073d123ac09d4976de495d9f1b30be00ee5e06ff62e215605f5859e7de4f3143e46cacb7b8c3e237818e0f4eec8918e8753f060f74dae965f2d6f3ffe4ff720efaea07bb6c9f1c868ccf0a2d949063eef67a574a1e917619d503739b963953252fb91e481fbfd008062d920dde7f8727740b98e2c859ae6570e3333ece87f9f6d4333c45553a8385608169b31448117b1edd7f50e64601588f1918fbb64df8c87b1d072b9ebe9236bf1592727feb57aec62e681e8f80d6f0423c85efe1bf0a938a4b7f7af2f248270da25f882aeb7663fe526a05afb290f2222829c7dcd50053e634974dd4270cdcf609ae2b36e5f592c541079ebbbe9864ee2ee02b5f0e440a8f447fb85d9419113bca9d16cafa6bebc9556e61f2305a1e195771d85fa159d1563a49370ab98438a8faa2f092e453c76e7c38f0fcbf1889ab5db3854d2f2e77ea8fc9a115230d4fbf13128b8d1c80323b2e1e7d8a7fc5c78fde83dc326cb6ead977974b2baa751fc1ab129d40ae1728e5d80a3a15a9f1976059e43c9a645dbf78c997d655eabbeecb03e7db488324ab96242756dec0843794fe7543655fee64cffd22ac585989b66987a0e54ff4ea4ce800ddc3c02d4ea1b32469c41f886aa929bfc6f17acf80e4589fac840309834a4e9b65cf4c8b9ed013e82bf5e80203a25d39003ef94f58239536f629b8da76543fb2bf8531d94bf4a51f7d0ab48edf69eaa0cef18f237a9f0c8aec45fe2d4090a7d0c7838de2b95335d7ebeeb3f0c888fc55a34381a5500a5948b201674b7e828f71d3a20c7a86f858bdec186a50095eebeddf5772397e6b34cd6c1fcf063379ad7333f0245093a1a2e9f07e2fec7ebfa0b9540d442c4aa997534abc657f0e5390a6fcbfb39ae8a7f51d65c53021c93240bb42d53d5de0b6371d22418789ee0f1805f6c0b7e78434c681b039e6b051e6956be7492888ba314356d940195c2652782ea0fd599f3dcf8fc2b9195faefe10cce82582c998cdf367450e05929d46f002c6bb1b2d72a2e93357300475924f93bb646a4fd9b19afa671d9f1c1e33b7e0b09f12e64fb07921e6f7eba20bf27f77c4a483ee6c64da0aa56cb024a4ac189f8e5760b1097d94f90fb974702d3fbb74dcbd009b205a4572a05ecfa878ec8d549f9a0ca05a771f916613b14fb97899a22595df29b776a9c257b1e8cfc7fdf88cafb579111d76dfb537f3952d8a935d3ff0d4691f64a2a8b7b69d251927481f73e3da5a830259e0337573739393a65c27d0e34089ea3c8339b84d42f2dfc82645cb0caa6cc94847a1b0940806910514f8885174e986c479a949f5e7b7417eee6661ff3f612fb9dec4a24e25a3d90de7cf40f3554b2f18c1abdc9a75c65921cae878bbe42d78020df8a49e350cda24ea056d37b79b699695e7539f9051355acb36a2b378ea6f90bbf80b8eea9669db3e63add0a521de955e587e46df52b8684fedb28a9aa33993e6dbb2952096dbbf9b0ae379e41d69fdf8dbb9f3e277b2a71cad27ae5b426e7945ac1301f05f8504ff7d686122e12efd85ed08dc177caaa33fc599f54db5e9c47807f7553e7aac3a864946cd2e796e67dbf04948482516d7f35c18315365956ab95fa6a3106c653479e3e69e4159b87c090e0ab79c03c18de98c8b08cd26a9cc022f01b6bbbe9073e074b27cf56c082604e95de454671cc86f7a00106b65fd1f4a8cb1e8b4c4a4f1c3544ebe1d320513997c86bc0663799e4849a7a7aea8391c4d49a44d36301435d0da422dcf09e833e2b5104f9f29668cb3c37a7bac0c4d05e63c99fc9bd3417c00705a248db4078b1550f6698831c491ea779cb34016463baa2972e2d8da0350805126e502147bb4ecfeb3a19cbc4c09b22e9c403969d5195a545d2b3d2704e5e843e257f536ce8b97e752d0dc819cfefcc8c5a0d9bb9e18b8b73a7f661564a73ff7f216db900e46f961e771434b21b0a32c0fa16dc569154726a30969bb9a8cf2275b824f24f4f4a627e6dd597706c3eaf3a981b73cc5157c0b94fd2cf9a14b7d324b4470c7c9546cd8f08bf0c1bf2e3ea91df3c6fa641a32f851c8d4476bbc3d067617f23ba8d833721ef12e0f2019b95b05fe312cf3fe5d7667b0e853d7be1e5837ac5f0cc7a8dfcc4eeef00ba238f0bc437f29d9382dfdbf75c9bb7ae79f8e8eb1fc40ba7f66098149f553223b16e5ebf208431c3a25e14eba6755a683e51188c0821e4f148e41b8d47b32ad3f53438c8069d43d81483867f797fccfe7238bf9308c349c7530a60c78d6aa0ea48ef724271d8ab7085bba2005c9a4292a3a9e9caecc5d8a274743985d85b76d461ca2e9b72469b2e4ddf80158e22448a469e8167c4679ae2b222f205f730b3349a512e2b4390c9376a825bc7a2fd77e58c353b91a2255ce69e48d13b39e26f91c0a8d854c586736991e6c38a8c4c7e93df30727b5dca66da0d65bc2ce05a53a88b70aab2533330a560acf1da28cbd06a664d24d5e6e71518f1e22b7c864cafbd5171b6b07325c1857b66d9e45ef2f5cf305abc424119278384cde7029912d87d8c74f95c97b8d6f50a7bcec0ef8f4c7df991a95d067ab9b6d32c808e041e05bbd9d62e0c7517ead52942e574fe99a8c0e17070c2d64110a866e1cfbc287a63a6937507c5b9676ce2d944a05f674ab4ca0a9b64420ea3d18f1aa311d8ad54aad7c9767259db7990e74efa10f1e8d0a7d8d0e96a86294109764785caf2b1b5f658790cf4cad8702ea516a773f87b0701af647380cc0f20f15810d18a300e1ff4c6697e207121bfdc2b8cc8655567cb1827ffdf560dc2e5540ef15ddb5ea1ff36bcfc4f5c238170b367b0e48f847e1ab2d71a567b0ec063b7df9809ee56b86b31416a229b3ee709e7de32509b3736eee079c8695501edcc452a934a2bb9e454eb5d794a9d21fd67d33ca852ff76ec22ca6ba6f82e937d73d468c42885b9556fa65b8629fee70ce1b16992911dc117869200e26ff06ce82a4a6e8c008dd0247f2859363020d5ff73b68f548e265e4b9e7d1ca828b3d9f152ee47a0e16537ce4577b8092b8d497b373381ef5d40d08eed3fd6a9a81f1813bf33beabb144fc13a0cc5a40b50d2fbf965a96d3068e0238b5917a2b6b45365c0394ab1c509107907ca976af5bb0214251d8d728662a3d221c616440a4571d145455bb1f40b918710e26e7f270c88fe1de284f8152138aafbb628f6785deba3a207ba0f3b97717c3e7c8b06efaa4013b6c8fa571e0cb5f36f4caa22ac60485a75e233850b45234b2fc6b880f5f3566680671ce5862a404982eedd1dd5f575f5a8a712ea483d11a615f48e938f19022efb489b0fce08686da05e175e4d85cd8cdcc9046095cfcdf115c9257fa2efda3ed48477cf86a67639e44f1f8fb8f2bc4ba0295235cb8275b398ecbbbaabd5cf9016f91e421d2610715c62e5436cd35140e6aeafe630af87c853e69ba672c08f5898742dbf6e16d11d4e3f8b181290f8d52698092ec9adfa812d0ec7bee1b2b94b3c50552b68801c050ae95e50da8925515a0fe88493db4fe2d1a8ed031877c3032de66ed9b73c8f43ce263e1378a6916b818775eafc5bb0abc48e43f4ddb83bc0d537b17450fe20f18cc058541d3a0a6023ca6490ad84b41b3bf80fa5c1368400117bbd6f226dcf42ec5520c5d9241a08593924e8d179b17b17859db481bb4c45f2871e763e015c8db8b90d2287ef14ec92c86fe052dfdf3d3a1c485f2dc208e00ac8fdfc9ae88c4354f7f7c22dbcfb753be8334d51b74f72d25b868f4a21511c1e89901cde77fb982050a3eb2bed8752da0f303a39b212940bd7dd7db458616adb7e008f2491dc26ced66147b848504e4005ef08831800684617cbc08e3e10e5cef7f44c011f8efdd06cee9de12ce0c3c0cf2e622391fa19aa4bd99390744666871cef76bb44da9271245abfa64b76c2f2ab75b011bbff820d064631e0c51cc89d3ed978574ec707c53610f23aaba1821af3e4033529c8be0e79fdacc38e436d4181525abb5924c3db832757f68ba5a31f6d434307d8380504c2ba7fb69e1279dc002591e3c751a37dc5e32ef0c5c84d0ca366358c8182c4e0f8eeee2b4ec1546c9c638e582d1f2b249a8d609e3ff92a3fcb5650d49ecfb7a2138b06aa72e3b2af3a9a382d16f029761ebd711534a2694ceee4ec473ffab8534c0efbd1e31d6477447cd97944d9d66d0132069c8a6896ef0406ae9dfe7a877259ddc4ccb1275afc76f8c73ce75c4e1a57ab1d48215ba43db0fc57a73da9577486f2e4783992b23b7ae5e0af3b66529a514e068cb3f462080dd8a803ad4bd0f7f65a5a46661a246d78f42f3838c19076c3feaa680bff51e9b9c16c35abff9c1e837798850fcdd556937b400d8c4fe1aa60fd60a4e51577dd0894e83e3459f3fb337aa1f17737cff2c8f4feeec1604fa90ccccf99aba4033d389ef686b42c36f1762ce764d238662969d70975da6b840bee9c22727d1674748518919b680a6ed518212bda957a66e66e1e26aff8ef2142a633aad03a4f9bbb6045315f7a0d858e3af9ee16e4f9721a530d5538be9ec8420cf956cce85d176abae56ab1c4a5bde10d6d50093ab6bf00320cb56656bc69514233bb7c6bccce421f53c07b7f96ebe2ee093ee8dae777e67dfef4a60b0e4647106d6ac8778ff4dadc5e7246add2fce39ac6742089e61b7e3ca83988919383b24acf90f2deed954290ab32ec368a19484f934500a45cd6e8a94b46448fd5363a64133156cd68c166f17999fec1d4168f1a73da51d50cb7131dd0f7a86bf608d9d89595cb1698a6fbf2f811cc0ffc9986c71e38a4536957ce05f3b0f0755615686783f32b6311c4a774de1756af044f0071054413407d28fb0f149969162f925a1a1e19824e5ae9929a9b5670189c2d5decd49c8330fb265f3ea904a087cb51a8b9d79ef81833a87a8c2f20b1e24481a5be5dc9e276a9d414346c4c308fe14342e1216d2c753d0f84d50826925a4c411807503ef351c43484c19e49a47566d8c8cf51d4a8b846d131c1c09cfdb0e58063361acb0689d5e7dbd4175391d74971ef33938c3785a58672d211700190a2f8d7daa75b44ade275f632955e86cdd4fd76e9d99e26454908973d2b4a4db03083ca85fa20e5294bbba3a03e6c22c759f1a75f7dd570c3c39404c297bb52cf42436c3c68b76a534f7972b3a65ca9e3f3b0a8233939c309b8779c164445dd95c9f4c92778fd896e2395d09d9e7fdf446ffb9a14768b24a987daa883371f9c6a1d75452a6162191fd50d0e8787cf00cd01d975a0fce2fcfc426317cd2580edaaf0e9fd9e6a0af82e8da707d6206011793f027a6ab464aec95811bcb9fd5157fbdba2f26f491561320430478a5319e96570e6d641a02560270f78502cb41e4f7fa3203c79fd7cb0cd238e73e4b8ed894a57d54e94fa5e84b7388e4dd01a4be0bdd556b811c92c88630d989f02b7de1ac30cdce0caadeaeef0547f5ce2080afd71dac808aa2e3a30e708ac800411def4b10a09a5f5578205c41640587cdcca5509b53a19b8b14715938dfc1b600c535ca1e4deaa5fde2d4328843745a8922fd26d622bdcf2aec65eb05c7c13a5bb42a222cbda5763eaffeef803eaf2ca23486aeee4505b3ca855d64570aca8267f06a01d35fbd6ad1cd91ddfd6da918fffba37ed0f38b8268814b49013ad8e0f351a0db7095ffb23f75f3ec9b643a40d4d68d73fadac7627c951eb1e0af841c0cc4ede1bd43125c119e8a0e8acdfc19eaf6c5eae9acc79d2a4169fe35aff753b332d5bdeab08646fcf223eb54ba547ff016879447e88e2ba00a358e3019a19e3fb60bdca1ec757e4f086478d8645f1be6fd7dc25f9158db1c24609466e1fd9a6e8f33280321ac1f149631f888e90bacc86fc34f5a91e07009b32b96de9a0e7843e6a72698b8406f52b399e7032abe43b5bd02db7878ec92a41478706d161497ecd4834a16802e91460d5c3da58d1c6d599828e9567055d86588f8fc500701a0d05998576fc227431762aeb744c73f233cf10ead32ef7f5e71a514cd38863e970356f013ce3df83cc620c629b0458c43126b1fdccc893d9c17a235e82d2f304f5bb7b82e9131147abf1d9d3b4fc87902131d90b65997e7519fd692e17ba8d0fa9af90e36afbc3cb6198891bf4d699d013f468efbf5d6ff413ddfb826e4ebaf0373a42d3e4d556048483c8217ca07fbeecc68ce9bac6e2b72b6ca8b1880c4b262d275811546f0cf2a5e0f88994c1253bfc1d2bf90b27d90b28872892dcfba7d314a4ca4fcaa77389b4ca800f40880966cdc4f7b1999d9bf32ca10f9cf5c3bcc8b45dd4b911c4b204ad1d7d3135a9dc0a505480c7508a31baf7bd64872200f8c3a2e74405a5a3cb3f9d8730481beb9f3f454330ed32256689f83ba90192207192aee552119f20c57771ae7a03c115796bcaec7f31d09a7303f7e8c040cf8968293d3d1a976d61f07c33f4f58a88912ca064490c82c3bf9e96d41e7df56bf155327d0fff8431d509587ecb1b4c5b3cab17c30ae226b7e20444fef6c4406bb58d5931682e26dbf53ce694ccee9b708f03e5dc64313f0d2b63f3ba6b54a95ac0d348c91bbfcd8f7cf52d67a7955033bd8f30eb11c20fd555358b7f8dbd6e5aeec60d78c505f76dcf957507050b285c9d77ac48ea1c34f5decfcc1f930f861ce29e2dec608f2aec81bb90e7f34c0d382ebc30ee5c097cdb20e5caaf93c3a65cc3a137e41c38e92aa58a8ed76d7972888e0b762a5fb19b840f490bab82f1a8bee2f44a94af4b6b4cee1f895a494a33061dd3cc2fdad05d5baea6435fd2e17f2dd1249a3371b20e64c9fd67e07415bcc9cf372b2d5e3c19fc72211db8d0d82cc636687604e6959eb3c70f1d6c7ac79bbfa8dae1a6735ea3d7065ebb3683e134704fba76e7e1bcf3c01011201510ff0217cd7502cf144f1fc294e8f7406b99c0ac3779d996ff2e2767c2eaa5596d5188d275c2f30986ef27443c45f2de691130770f13570f039e384cac69761d18841580e2bca7d8d4ac3c2befa1a99de0e8e36317122c5c27daffa6b542b59a57ecb2f589ed91cd477edb5eb44feed563a6b699db12ad3e17b15b23d9e84a63c904ccfe1e4b80af11a4da0dfb1656f602c032ebb7c6bfe48a0ec893bc5ebae80c0b912bc0500c3fa4ab838fbb72e0447a09f7dc6d0891ebe5ccd23f0c0437e7be2a7e454d702f87c9e843f6a7bea9ef6a8ebecd3a341bab8fec2bb526a920ee4b06c633c87e39a5bab85e226b2ef4b35a8250bbe636b6b19b53c6c1eee65c7fa7e35930fe44a4030c47b2d742a23cd98deb3969d728fb7e20a2b3ee68c85623f858b8f08d9fe34d8060b27939f2fabfb96c8caa7f0bada93f33cf6b4348610dea030173e7626a68be766f54fba1e2b7a9c93e07a9ea7299530753fd6c72ecc224d0bd7c0af8cb3c17c2d8818160f941492355a3d98bed2a48495630dfa76ccc31bc74833fc036b244742bd1da6237a07de51e4a4ea964fe59535987dfdf0d4a703cf7862e82ca3b4cd6b097b7ad30399aa1d9f4db47c864d13ebff92c9c349de41844a198079fb536f90607c951b78623b30847ad55618ecd64a485db65cf9b98d02bf581834d5ccd6fc6136703d43bcb8bf72e4887d2b248101f83cb990b5db7c5bb302cc64f3291d8a7689bb3f7f438ea739937f096da8e457533c87d6b91d945ef67aba26365af36c5586fc317dc9a6480ab20a3c5c9b3a19e814cdd386da0bd4ee1fc7eb8627d5afd8d50cc28819f27c09d0c60706c3b17a0e44e87a72691595e17bf98d9848be07302261a05c839d4344426ec5b9319f470b840878e251a14e21c87f944d226e6d5cd78e4bdf61bc28503257d3a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
