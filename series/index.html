<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"328e2cc1c70fd22fbf034d8425df38d5aa634d4c0f35b926fccde5a13f6cb8a815da6947d60cb5c2169c6fe5ab9eca2dbed7b02c905e611d97682a2a4fa66b79e76be87468a955725d5e25958bc14f5dd8c97f62ba29f63113a2048d74e7e811081e21be2ef1d5fd11ef8ade82fca5f19356e458c282875ed0a5267bf281d924e3d75ec8d30f793d8a083708ba4aeef5ba1054f1a4ee42e9638eeb00b58780f93ee5a27a4465878540e3aaafbc5b5c895821657a4bad4dcdcb0c468b7cc1580443b439537698381a1c6cac8705423769ff25fe889d57296d6d23c3ac1e7ac8a77450b4a41f9ecbd2e574a5ea30dd0979d2528ddc9fa8cd488bc216bd5bca89e0650bac5704c40a1a5d97d460db0b0b6982d000da2e72a797cc70b9dfe437bf26f073ede2c5da29b793fdc028f0bf84968fe9645050f359bf50673e63ab0f36f842a9432e812e6e41009ff9f5e5ace14538ec7750dcc3b82602a8593ec28dcc2dc5521fe01ccec6c615c88cf0a4597d5a64af7d733dad147de14e607ce60d85bc13b89c40a2d7e6971d1601e3e20b526f940ef4010d63acfe120437991dca0a769a01bc80ab7c2f642f32d48d37b817eab8c6b83657541a9be47875649fce785340b4cd40f267e98d13d8b821a91dbd3bfef26165402f111b687611bfc15eb02eac2aeffc0d4c9204700c5a002cb16702655608e28703bda3c7ef01fd93142f4bab1b671bc50d5383af29334c9554a02994aa4e1a8f506555d1717c04cf6e47a98a9d82e24c2f3ba82b4285d191b38d94207afcb1cc357b2e363fbb5c3c0a9820a8c050d94e7b02b40015d95cbd4c75395c1fb5ae9784891f78794d57a886f3b9e8a25047aa6c19944463626f4a264b410e469f47b10bf7ff30781901d025696f9deec279a098aad2dabcd31e66519bf2e93d081c815ff8ec712353882025fd8a9b892af74e04b194528e885336c891da409fae436626de9447ad397c3534597f9c9c108827690ad174f62d8dd10867184758fb137ca7a2e1315afac1a97625dc726a46d250d5f85da01a6e4c0df92eeac391889f033cf0540af3f85bd857607d53f553ff95e355cb157ea5bcb3d6c1f60f7b56179f4b561f0e3bf28acaeac172e0cd1115db6c2faee90415711b32917f9cc516836434cfa6c8c4548b27561290d3dc5993fee071063e6e1f2c7d3801580b1b00742d7c415f61494f5c9bcb608b5f0c9df062bec6f04d5ef1491780db52a8e60081c9504cbc31868b47eaae02b1b996b3487d106b893ab9d91d163d68fe8201290e2a6c28cf7a2dc0e12c9b874f9a21d2390288d73d13d4d6c8681ba3b409f08fcbfd289054deb4f943c6f38b63c257b2c5638b5dd48a697368d11e163009750b0c1df0b4573fed5eaa4ffa2a98569890125bb56e074a933f8fb60bcbcedc2a9c8df4bf5e67b1a7da12894d5dad1865cce94298ac59c022d43db9f17b2823e5f13e513703ecedada6465958912a634d5b9d5cf502b0c295cdca590930b801272222722b641da88ee3da61b8a49e292134dcefa279db03ae9033dc45cc3e3e514e70d155a1574b3dc4931b418ba38d224243063f17cc3d7a8e72d29f1341404fdcdf47fbb73f50a093d2b21f773e0fb76974fca9362dc5ae2db00bb6ade317a24281dd0ee605f60892c610ffe87c9558806ea34d3ba9b4755b1fbcc279588e1aac91b3b0dc78563bec5417ef013f3b5ea0032c23d5c7645cdb80fe331f138e7cc63bb211929397f6692c8f46e0acef9919cb5811444f1283a476e8098ff7a3081c69b8fdf8594f0f3883df73c42a450090beafdf3ff0477bd3280d965d4d084e9b462644a07e6e025d9d4c82716f26eebf50f8deb73327e38ae3fcf0d9d67b0e3a9869789a6796a3a571ceb09c8e6ea670516f77aca31d4ee7bab5e051c3cad1c9216ea0e091bcebcf969dbc523bc39bf2f66d814485f12e94b1c7d1bc7eeab3a961a9791c1453fb9afa3d7a54da6bb5a381780b329235c32af69018112b0c0062773ae4348d4bd72c6db6130477de8e062ad3490171eda28b863c0fff594687efaad017ae263de5cc1bebc61170b0c593005df47817fabeb32ed790624b0cb8624bc1866a72e6da81e721a5bbb8573e5f5bacc6969d94d327e40162fb6087a0bc93b066ab3498017d1c4d6e9f0d015f0c6be1c1b69fed5c5e0d439ec85efae89f4622511e73f3407a9b854466c00de7eb794014adddb05b158b24275c3e8cfabb93fab375aa1808e15b3d2de5f143ab5184520c3b24f60d8f7cbb07c9e15b646d10557e0200176942165dcb40fd529f1f5e1f0598873fbe09266ad1281dedee1515984f560c978ee38ae163199071317d43375b7ee4ccd5181394cd37821346b5ea5710ed4bc6990d13fa143c6cb846a31da7b7b4518bff74a6f042504d96861116279dde209cd2844bb49315b51fc0cac4061c990bb1a80e8edcccd1832bf03d7e01e3a589a8bd3724d973c691c086f1cbc7da0ca94eae789319d29f873cf942573982cdc19f1fe0ae7c0994c54c712b88372fb2229b937ccaa76e6dcb268beb62b97d1c6c9436365c1f842ae1db94b3eff0f6383e2627f59c41464339842e4fd097c82c7dfb2c4175b2d24d7c1a13dfcfa55f4019e7928fd3e97b9250da1370d1ba8653264b06e3ccbe486b499e2066e38e6ecd9a2d97eaf07e68d95df2276f63d3e10c1743e791d27e7f72367603e0067de644e2c1f028fbb8cb3077f4c3577ff9ec83c9ae37fdfb24e507bd122d50658f0835a2b1af193089139d7a052ea6f7af9c2cf103932f3dcc40a4a33762b28ceb2547150df6de115026a4cc901d5f5b028247180055148991d695571718a249374e65e3e0686d062fb4fadb241510bdffb1723763837da52432d38c0df1c2707181ff3783b6b50af673fbd6d78ee687f6a497eb6453c5d31033d8782b7147118e93fea8d982a3c20800efed7fe296d4090baecb62dff66a001f9c49b85fbf124f4304295626b0d4ee95192ff334d6b61c9a81b46dd746f0575ed8fd941d0211c831270ed4dbd3b75fa3cc394c44c47fc8d639f6fbbbd404fafdef3778f47701af5354ef3e189f56a9ff2f33806537beff973d6aca22c5ca86d72a359558225ff20edbf02699c11957a3ae73a87312ba737cfb8e9f6e5e708f9e81ef28c9de20566e096946faeb421657f33d6857499f811a93b855480f5f527ff7fe77a14a742bfcfc8beb6cd6bb6dcbba07492e54f3f847cd7d847038ff051aa9afd1465a2bca6788b50f8a0811187deee5a41850596e52cc7ffebf79cd6b2bc42cd7e4cafd2df92e10e695e7b0663660b0fa41fe7afa3689b44ff35b2c3c576b133ceacb65a66176cf4a0f462129ad20db47c4b6853c0c4b30aeeb9f3a6156696b4199a7389973ca052dca011cfb064c3093945355450cf60eb18717abb6fb530aefaf19334dfe4e3cec1fcf8467a69db7d66a6603cefefbcf5d7829aba9f347b1bd0272ea371c6c50a68762d2e58ae44f7a459865bf981312be2e2444fbcecae357ce235dd262dec50b5ab0aeed76e06c8b8b70158e88c2122f98aded9ba73fe6b13289b866873cb4261d4d0b26f207f8a2da6c17d2f697d678bcbcff53c1097f8699df5ec67681fcbab43564326ebbece474158698fc47484852350001f0ca22521857d9bf7e6ba2fac2a4b7bda2c2e2d15d105370914251177b310966525a6334f034dd74c1246e67c893d65a817daced1d648e7a59cbddd93829153f96c84398f1a4f343d8c976a8b825cc620864052109ec6890115ff24b0fceec7488378cbbe757c0b6be758161dde8d9dedfb1a3b8290f1cab830a3a1c6f9a67b2293e50cb3fe35f2c4ab03e620356eab3e9afbefe312c8c0610545f11e389b27141f4981fa34da06fd8eeaf12fa969a51e9790f57e8e092ea0f37d251786d8287b53cace8f5a33043a8bd345777f87dd5e6dfaf71094eb8940ea382523addfb5986cd389068878c0a37ab6028f04a78205f72acb4147dd632ff46131b0ebc503b0118578d5e712693509d46878326d00d7a773ceefb9edc313326a20f194aee79643a5673e6e56b799743e38a01f1fcc359fd497905d345f1e9e3f7a6a557150f81563c8cf228416545424d014ee3fb9f2b7bac66bd420537e445e09de4ecd3460c917ee5a942b05e088b8e6be6abad455d1aa2131ffad1cfd596cc2647303dbeae2c51b38730a10cbd0970415abec0a84afd7825db27b779cee1cbfda1c0687cde4ebe68393cc887bf49daf5e3d130ebe5576291536d42c8957779aa22db49e3fb7543b9f05daa4cfb45702eb08f348fb56fb209267fe7bb9f3259fb583a2a2914430698be068fdd52eabc06a69c14984715108ef3c5b7f2c854ac5aecf2dbeb8379043d5493bd0d650798e983b59d41eb630730ab5578fb562b7449d92e0e59b84dbd2691b32e6106c241c144aa57ff587e484087243c69c5be39600bdf60b943949dc8d7d8a2967a747bb15faac68aa60515c3b44355ff3d3ed123bb3c0fe2fa1d07d7f35e45cd319ddf3a660ef1c8cc5a63d434cf51f5266f3e477cd9f1763a531aacf0c03f451a85e7b9aab955f39d9114c985ae5fef89a65fe8669617cc2c38ca6ff7db8938d85b59001fa5bc237b9ac28b2fc99fb8c97b137279041b8893afae252d1b1e427d6d77077d1e858ef97087ebcf2266bf63644eb1374283fe9e8fa0ac1f21796f96a457b60c45b4c99caab9790c93b8697a7d33b274ea0fa599f8f0d329fe700cafbe9b1aaf5819fb5b8525a1bb6cc0c836f015a54b4c122458147d24c5d7be00affb9107823738c737e80772b14c7bc0fe5c27efd7a71e7a06efe291cb945197235dd9c736e50498e77676ab49a7152afdf5f340a6b69d557501a8ac70a4345bd65310680a150bc7e2c7b4d7bda42c7c63dfa17554b6844b98ba2ab76bb99cc40f2c8e6bb9c48dd9a188622d433b98b0f35fbde27803cdf9aa91cb6d3120df28004279e77c77e0d3906e4b821feb03d39dbf2b1d46c1137cf0dbb1e8bbad7d08077582db5162751c9cd82422ed674505d6c9d7f406057ec85b99b840f20595ada9de11a513feade6de87ca85eecb49afe454ec7ecca1d77739ead52bdf3f7f6daf306f99af21e3370f41b95689bd202b95c7353a5b86229e87abf45bb2955bce31f6ea5f06a240a89d6310c1a8e324b387b966d442613daf94739d626f08030f2b99c7157c7a3f831821b0dfc6f34c76efcb3365ef9d60e9aff260312169de3bbe442ca3c21a0af0c477564abde5541e6c8e8294427e15c3bad3c383617137ad6f06dd7715c7412f8e6373a800b56180898a0c0e8eb8045ae62eb4bafa1134a70a8c9abadacd95c51af44eb3c6e3ec9f52254b911c2dbb50a673c77506e01906514260b0cebdb053166dd7f94784d746798aeee44bec8c7db216d8135b398a6e10c90563ea67619f22748cc24fe890083da746a242e47085fff900fad761d97d594462064b972814b59fd6e56d1faa5ab0381955b277404fc6ddce36099749f8e29a238f0bebc974a2f59cb1c64d7983dbaf757e0797e10603caa5c6a79abc0a5ddac9d0a52b748aa2dfe334e10da6f62e3dff45a8c19805cb950008e01a7eee9e0c9727725d48a8da2f141bda06c880dabfef24ab94bd2bdc25262a3e997a0c50f28bebdc256f29fcd5d04f841fcbc388a5698f0102c086c1c0e5025b14878624e3f5bae8442d7fa917ec2c5bb2928268886d8de67c844cff72127a46c71b90d1f280baa671c6a4c7d1a1d075855835e7b567d085ec3c8598d4481c5877a096a6a0b2893a91d6db9197b6a17bcfdd48cfbc5b442bd121440d9cbda9c162a9af31b7021cea012efb658a534e34ca4ba8162eb031f589ab1ec374cdf5d1d09da00af7a9af0dbc56d98b08716252cadd313412f52a279f74e01f2e67b187abbf96e2fde534b7227a26e81eec43633a90e5ef216196bb22c43bfc240c64d12804cc965b6e0e48675b97d4703e5136c79819e0ca126b0e58c724c0eaaa3c8e7b9b55f7dfa05a2929822d74ecf2e0f139ab80e72e3ba7e77be6d005dee0357b5bca7aea14f0fa63a5e7a1f621b7d6906b84c90fcbf15305b9e973bdbfeda754b844346f1b11908a296e22900b6032394cf47e53e1bbb04a27fa61397b91aa13cf5df07ee06a6c58e01cceb556f2e705761992f760ed1cca3ccb1b93ae412f6062505d10fc6c15da8dd6e121e352385ade1d9ecf0221f3740d29c905c549526b80a42afaa40f945b055d9194e5fe0385cb7f750759bcfa954ffdc91cdde084f38a9fe100cded8508a8cba74347033878047d607a91018a7f6e0c86f3d5f7000ce7c0f38a691be29530a58ffe8aec207d2e5725a2a5b08c2a120b7dcc510e0c2d0e2f79c12be8ee705a7e9f740ba93f6b05aa3014f402361aa173685507e0944cb3fa64850b5db69ca4c878e211c17116c0c67782ffa1bbd960a9df62a8ff38db6482bed80fc57c120029e2fd10982d7aa7538f461ece5c907063e95751c034ff3f33f2e0d83c5a1bb7a3f241be9b118513fbab1d5f51437dee30ed6e992b9e642c7638a7248e41a962a6b9c1b89fdd7ecc8e0221f7636ee07dbb1a374c68bce2ab61b6caf0dc006b84f6564bd8dbf30851b21428243f23882dca6c139dc0fbdb3aec3ec36f94440a9482cb981c8e5973e7693e77677f80f1c7a0c38e0000b9a98e7240c634c8e1226562a38f7d316374a9ecd2aefa3b8f5e95918ab310358a3baef25bddff61557b63023751321d0ce2f8a6628dfe8a7e2d5e31ccc03a6c61a9de7d689d9de6ff324571c0e5668c9ea068c29f30d392510c01ae41ae36ad7be3b4f12466d918ab9f531d62f6ace21051162ab3941cd5c32fbd7c6556ed9e15b70065980910917b89a84ced36acf966e48da96bcafb2a19e384c7364e6a0615fb356306fd5495b84a0ee747f7b0fdbd1dfb2a6ffd13fd9fd39458144822b0f7119372a8ad4ee918729e0184f5b6dbf174b0b790c148686e8c0b79f37171b8caa5fd984784799a601b670fdbfbeb947cfa09dacdb72b4dfa5cda824a0e512952f1da93e9681f10166bcbbdfd3b46567805e4b74b3c68ac48bf764fc8e773b0d33e40677787d51d343e009711a5672377bac15df27add2b660b3ec420f815c30ec2f5797a046b5355e605d25b60b0629457b28c853c2a4705a0f6cee0774c3525e34394f3d341b59bc17fead1b4a106e768632e5c6616d2a4501d89c8c7a89a2e1b1ffbf3cfaa41fe548c4d8e9c40c26c99fde467e515ee27dfbca01c7727d264b1cdfca43dc90c0a10e8abf67baabfa580ddd648086136b174194651a750c08b4efdf9a65f00ed1d226193680500d68ea29e48cdf254406537f23b17ab5a65cb586b5735a46739e956a5824fad54fb734c7d0c5e1193880e1043365d6d28d25e431e11cf8627fea3898901f8da7331a2b2d74493edc18ff46115cc5d57107c74742b283f0482f897b7c5f810a1a5bd6790dc17e0856e5743af709e1f92f60c6fdc1a05e423a8450bef5032008ff69a250db5b2b2d833ccf5d068a72a1d80c0915dd526b1a7b2e95739357174be9edaead9e13f400b95089aad12c41f2c034fc1b3ad5bf62da7b756033b9f57430d2947ec7bba66b6beafd701aea4bb8969fcd1fc2ce619703ce04b5b0f93f41ed34130d2907a22cd8227b6a0bfba2978e66ab15f4d7a0689f14432f6f04d9fe9c3ac5a1a3357194e92df1dee66c387121e8056fac7d73d0be568ca783e4503115f8d2e02b82f425030269526086272e74c468d64502e789c3cc15e6da3c775695490481f5286a080d4af4fdf440fea0704719102f174d4806598e7eefde6417b8cc84363d178be4307d87cf4832c956a134c2816086f4320ced59e25d7aab60f03c4effa6ff6ad2bfd599c08c66f29186780b035749a93a18f0662ff4d04119d1f02270e7f449a148a8cbb613446ca27e43320f5543aa3e62f6bbb3d9cf802106ee1287fa00539d8da7022b6f4aeef4bec5b06ec003e345641cdb08a4792c8bccb8c5c05b21897e1586ac0300b29bbb8cce6d8b405fd1683d9e04a296c6863188f85740cb5782f973be96554ef3361de5a3e5eca24cdf975ce604a23cc579dd5a51c118aea911cb3ae2e4ee1eb59ae5bccded4df68c1ec58897e9838e46386c15305c73fdf5c0317024ca8a52407753a88095da8d17bcc3e065c2a355767f3a061f482e5ee7d84aae4142edeab0d895ece4e43baef08b7e58ba9d57c858b0e83ee398bf0aa080055e698a387343313d281a5c77730dcf819aaab90ded5bbee8890b3d25fc3134c7cc7a7d88ba767ec68193fcc69152e3bc196899ad754bf8e24d61bd41156a6a0f611b480ee284ebff3e603f699015e36604c75cb72546a6cff9dcece78ef12565a5bf620f0d3603f79848d4adcffb2268b364c299b5242def2e6f4021fc80e9b62794363d01aa42911eb59ea72638e1c1e1031c86feec7ef907e5d277f9dadf109d053382f2ebb22f9b5cc9a6b005ffa11a81c4a24980fc0941c99b9db112ee23f7dcb97c7b3e7e36c60536ce0b4349d9590401d8212adde4112aff06d5e140bdb9a3432e5f4d46f0f80befa12a0d15be285add053a4a31a2b1d2ccd013ed8325aa4d5e2d1abff8ce3e9d7ff9cadd33b19ab110beec6f394694b7d92d910207df76b9f1f9621f655f0a9b0fc22b3ac54ed109f8f48d46e8c31d820676d7ea32da82f9e569054d59602a812c9adb684e90fadd6df6e82d2355dfe739a1ba38d1c0d51ab2a47b4ca9c0449ef1cbfbc0c143487ab4fd7752dd408153670dc519c60938d549a9cd8570d527f925f3ff74d6749c2b85d91a84935be04e4f1da697202c872c519a375b41bad510409422861f4ba12f8d205b57b92367ee9f1613b6673c6587a2ce875a93b27f8ff795685219fcbdf84c667df1a4c5e7c4c9232fa3a109b0a329a855e59415e510d693ab1362cc39a0306414c4358680ee0460120a5238d5205ef2a2efdb4f2e357652bf7387650a410ee00425ef57245bb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
