<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d41e67b461fd36848414c285f94342b35de488101d60a629780e62d85b09b50e3d47961caa7e8bbb71139a8432adaafe8afb57d1a018a8c0214e7862649e2c80e838e0cc0b4a8d06802441fe6f05e691a07582e99d8afd0a31ece71d812ede16f318931cb1be3319d3821e5b9ca5e5a9962cd0c84e0a1cfb8b6c13fad7b14f000f97418042745ad9fd7a9684c00610bb0931eb9f963df0293def19a4d60aaf4d2d316592151528e4d3639c87937f89581836767eb4bb197bac02800a5958fecc001abde3c8c89fcf0d947b60283878df07c65d91db1c3435ecea59753cd83cfe52cda043f3a75e92c8362c09c952987d559b4a96a14b5472996cbb554c1ee578244de8c2423d5b1329860b2689f95c59d44e8c6db0a77401f0ad9e986ab5588ee040f005e1db9c5bdf5a151a7aaf976efd5cb9ffba665553730728ff190bd281c19125881c963158f944340510cb88b959a23fb3822751de1f3be79c3fe7830bc4f5fcbe468f614a9b1ac286956c1bd38262d80cb1e03e24f9b88cc395a24830f951def6cbf4ce387d21f4bdad4a5ea5b91aa404dcce33721a3df56b0f4e5daffc868317ac617ea681e13f309c6ba372ae84bfe307078d0916dbb47e928159ba5de4d68945df534a3978a201dc72d4e2f0a1726f3feb41e697a6d0408d89fb55344c462a6462b9aeef5a25874b078ad96c26cb2fef76d8226080e45df186e4876cfe8ce5fd3f47624c0b5589df3562185266bcc355fd5e4986a070fb1d77269154abf1776e197c7cf8be68db251a51e3ce3f7a35585060bc81a5f4309f5b0fd6934b4253a65a9ad1bebb45bdd53ef63e8e49e235a18bf391347c30bf701f41da3804263dbe0a5ef3490196e06c4fc32f728d7469db80a25bc8e783f3831561c32e44afdac31818f127623b33918f61ef945e554b28f0cf8124295202406c50381f12db6bd65f0cf46a6fb29290570ceeb064728794d41b71f0f74e4b71d3811aea7087ec083584631bdbbc6b3522daa0e7db145bbda14bf9efc7b11a83df48ace8112e25941271d9a40943ec6ca8b056811ef2e9f6495cb522efead682e74c26ac619004937db4c7a852c2fcef85ceb90a6f4eccc401b74bf196402061014ffd6281c2d7d54a9505ad9d32682dd646b1df40cb22619e3f242598d4e80931de8406209524f5342badae917b6db75a66915b70b651eb6824137e2242de96508534efad6b7cc5959ae19e203de42ee4452d16d2d426bc36cdf576205ef24a5132174bf196bf227d00e880af92f3fc99ab348f759561d281f27edc7b98c6c6395306f8141b241c6770d899e861c614d7da48cd3a0a05aaea0b7f76c5c1b48520867081ae6e0a4562d2d0bfd3e0eb44bc4d2743c0dd20f70c0ac62120b0b4bbaa7c080f8e37c8e55c040c8d364cc83d049a3f7d6cb955f7ccc8f8e9867adb41350319d628ba9ba22d5d1d56787a704aeb3573cab377dfd8c2b88c7165927dc55f38b0b43e92fb13dda0b0791fb5698aa26595c110f6fba08208a56b36160c0fa630d7d3d7dfa0b89dcc31b78d8c39acbb9c3b5567e2204a541960c23637740fbb165640dc48ae93c50ddd68a9814e3c52e209afc4d7efd77a2db7f28edefa47bfa7919020352f80a2d2e9cc50b335562d4c8a083810f60c6ae9dc7dda2f054d5469eeb4c369bdc95856a1723d599bac2a58d9a10b1af2311ba44f8cb779dacffc21479eece0af53f80b3da8f23717cbb457ada63a94506d4cc829f420bc6681d58765e787c0bfdbdcfa75a2a722562d3b8748767ce3822ea65acdd4b3bd3d02f9dfa13685eea9e792180caa387eb58b013274094812198020d510290c420b6a28984c7c4f1e5e398671957b09e6f3c8e7dd1bcde78933fe9ef8b3c4f0ae8f4050edf9cd236f5ee4e9ebcf6cb993b3be8809544df64484ede13dc88be60f7e6c49e77d68fe070596bb88289452796ea98493ecc26bc92a281d5cfbebaa90d8873ddfc999b858b5c60ef6b2fc0e9c65dfb133f5e077a53dc336b1d0b441af1103a04b262e1d4957237210deb1bc007624c2bb6f5d50c2070f4a651e2d558aeec0c0a1d3f26b4b27b2dd690b961ec5a42bcf9e4d0b0387dcdb7ed0eb72fd4af6c16d3187ebf0e98ac2314f25e50125d4543ae32a1bbf24c016bef5cebb13c57e4856c6b361415484510366c5adc3775e435c88ed6a60969d179812334f4af60326cfee42bc55d82f3bf249f343b351daeb0b2b1614bb18c55f8761c2e479d7f3700e77c37d0f6344c5e0d4755720a9e139916cc90e6e2a39de51f6c49d44e48a40e5881c0e608f48bd1b674b232395042c4332a602ea583eb3a3438276d96058fa0c7648c1cc9fe0a478fa133fa5692fa42752615301eb67610c6e184d73f1c09b2f2e551cd193c9eff783aa39b96774459c44ee10bd007eee2e8ed4a5ea1ffdbd37365d7da0b3eed93115c2d0f16465bd0e53657f40651a2d66c80e2d1210bf59dea3069979b6374949d7959408e22938fbabdb34b8ebe955c077a5e714da7474100aa11705552a74a4108e56dcc6814fcc2d9c7367c6eaa5ab33216aa3e6109d9bb207e70d29bc05ab6cf9210b07ed10192fbffc0fcc7d03a0ad5838f96b2bed1636baa677fe4c6465b3b991c6773588b9c8db8416c04b46c994925e617a7e606ce12dfdaa21ea91ec9ec71f66eae718c825055588ffc34a682d9ff2226b38efe15c0b6bd09fb9ff5da49ad1b3239fadc90cb72b62e31a0f46cd5ed70ddc4435037d4b841aad2a5396080568305f791bf0a30fe45b58cd003d5274fa9941bde895caf6556fba3d15b5c51e5ef63f70be666e6a81b71f52f32d5ae9cae3bb014c2cfbd9e2c31778112f5afd131de10f9c276d110af0a7a17d9d2dbb40c4c7c704d83c8ff1b66c3f6d745cedcbe23d6fd361fb2e35e61c2035568abf143b38cd892b2d75d01269a26ca918183d1b2766887c73ab82c4b05697b20bec4542aa69956b5b14a773df9fb52504f54dc67dc03b35b01206e21a94fe02bd61b294c76be57670429902769105ae4d949364249b2f817d6fa3702220dbbf4165990e311090f66ab6232ec0fef777dcc80a4281a657fed6892e2f99e7b1d57f8537bfdd40d18e9e9c30772b18d00ca978f8558d7d8bf5457212052d573f42518a406701272837c1c49f4cbc700819cda177f00ac3a74c6944beb6278f521776043493222a0a268a45891d91b55ee63a3184bfd5bdd324711b37e46dc44a2eb72f2ebb0350e916dd18769de67330fc773ce3edee7847e732b27b46caf4dbc88fd8873156f2fcc189904b0fc7a1d9951b4d1965787cad42ab02ae230e304758a86f6d26d6902f48ec4e46ed0cf29406a0808e0e099d169d3d8bb313811e9c65ff7b997af44ce048bdd6130d31b40efbd70f24a1af791516afcbac97ee2d5f60edd9a618496043f605165d8cb39a3d2cd5e04ea00bae89fd8ae93b27bae10847bec427c4e54a5c30a4611ab9a35e09ab1e68f6bdcbcc8b19294123c3610b3c073f8a62c279819ae12a50123a5e2c2997c424b327af77a0c8fa4a80a8e6cc034a8eb5c4c79c22955cd85488d62c55a2f2b1f1634ff82353fd19a302a9f8ede37221bc908df105c8f12226a4181a6eab14b881afffefc7c9a7e35931f19f11c803f3097a73205dfed68a85696ecf7ee4b9e02dd87f8415bb6a213867327a2ca1dceabad60630f64767ea7ab77353cfa86761dff410132747897b16fe255747e8fe75c28144a6ae4b6f8ef788c3b6a609361531616ea433a4ad99d4d80f7bd9c4e92fe1ed83db149879ffee2854902afeced5336d157e2b8e20708cb5068d23d1840b40d852b76ad2e2c89dd4b651862e3590147ef3c929bc737bc28a6d64b47c3e3232b5568b17dd91ed8886533b4703fe76eea215393d0d160e367440f040edb2da60aa8eafe46f0d4aaa6debbaa4aa5ca935d7cfd39e803050f21f54e88bad7c9640ace847885e0f6083f3aa9b117b0331715691326c570fcc8fd9eb0dc9120d19c2fa414ed2ba656997d46cd43f931354a319a387fc760a51638ace89be8746910eb3edce28c8e8ae22605ff88e8efe788f41a2e6f56670e31da7e1787b156ceb85ebbbd578f3629a18e0550ddd72eff2950bcf082ad8e6b8c3cd9abedfb3df9721a4c8dfb744670cf3051958a78d9b891c10d8bc89266dc832c9fa3d1b12fc2c2ec98dbab22b815d9ffcf020321a2ffcabcdb8aa79bbf2a5baedb7eea009f918dc7d3b7578e21b1b8a6d049857afacfa946e43e62e0e8f2629bc191da07d5beb238d82bf2a4221fda7637d51266996dd0e45cd2b421ae43eb73ec699cec59714d1733f723850972d243645c27197eed9858374eca94deae674841eb492e1d156caa121707e3a5bdd5a34822bbd7ddf47b2cf6a562815ea495ad80a9ae4ecac8bd373a7c2ff44d81402300762023b74c79df24e5c5f76a346c837b53c31d072db915d416f39c39dfcf8f8e47be2955620edfa013291f70960359a5aff29e54806b222f11939676293dcc686c0e5781be7562fd5b45a0ce063e65c9bead8feb225380c7b8a30e4a4f6a5ed3dffc57cc2a0835b764d8bbb4053837f7d52d941606676453a2554510cbaf7c55013650f6532485da716f97db0b1cacfef948753221d46eb6d51b0f92d6df4b5abae5235bf04523af50c51e55b7baa270f9aebdc81119aa1606aa201567c19bc8f341eaafd2ef880bbb170295ec4472ca4e93eec2b44c26e5df107b779057e7abf632a37285b244791c239c4f4a15cb9ec6c8a679e40f36b18fd82caf4079261910f9f76403f221777fd31767c1681bab80ad49b4b5ebca7551bfb9f44831b2ba42109addea158fc791398e93775b3407ebb6e090277820dc5462c33e3979f206b5bd739f1f8c2352019ac6662c28d2bfcb415873600687e8e1d8a4da7b7bc3bc42362238262ddc5165a950091a435325f09ef6536832066888dd2f180a54b53dd3358f98352656794f8289b23f1243a2e36506bb887b2e992297fbe6b3e809ca6409c6be1a33a31f6a4db891193e737e658a17b4407692e8a804c5d1f077cb748b63c50c87a789e3bacd0007e3e7a0163faf37c72579edaf6201f5900c9f31cfa15be3061136624fb116031bccb0acd8d0c8f9818278e6f96879dce6c95540b7d9d1fff81a1d26c8717164106e10e3e9d5af2068e9e9b2d818d6a24b19b093e4a08ec9e66a7c766da5ed4fa5db5668d05b363e32f89092cefb94616848a64d5dcf55b3d4dc30fcb349f407eee235e54da9e3fd280b8e3b50f953e405d765e737769883858b0f580ae83c01be6d6c117f44e38d15cc5bf0adcdab32af97db8837319ecd60be7abe393af4f00bec1cdc3219c71ab6ca41c502814c0be184ca7fccc4a3605a101121c3e40b72c8d66fef21ccd92336107b36b77a2dc8e7644a5f212a0c1ab5fef6ebed761290b89bef74531579d2f995f9b7d1ccc89996118ddb616c38e431b21295271bbd2f439c52a8a363c9f042bbdd6bf764edd08f5018c801ff782962c918f0d26665eb7d7c680f44109c555d009eb239cd39e399bd40e9207a43cb25d43120e64754ee271da969769b70f68d306600c148244f14ac156b2964814fc8fab8f511cdcfd0bf86d5326c5e806a2359a93253b797d71b7c4e86a987e74b4c68898d1806fc689c12bce9894687b04d6c0879745786c80c482a84ece191e18e809585353f2c80eb730b1558cf894522da2a2726d07b67ca57332539d56003ca5b527084a7ec757903e54450b094d0434eaa4485dd9b97fa8dbef2b1d48fd3ce437778d5e5e20f796eeb8f61f8c416098799c6c0ee9b213cb9b4ac2ff1f8cd8fdbca1ecea3183e4903aff3ee922e99e36e599aad193ed0ba178b0c640078f4be6ae29afdb6f5c5125e05b29823d8325f3e50a9a5326df9a142478cd4fbc81106f22e85da3b4154f948799f3ba96b54ab1f83f0189cc902a5f3b2bb6f5e2a519f7cab4a5863e77b0168820abff534efb643afae3d63c084776fdaa0ea7108ba28ba3762c0f3ebffe862e478447e96b275991ea021476d010a1d16a3d3e86d32c2bf79d86a1a4f0fc8f00ba8bb6b9d7bb95cb8c14c809bbb66dcc27d80d081733a295dea84a1dae5472c17353d2ef3817b3af124d7fae3a2cdeea5ef70fe279f1a4063e399579ed56207851be8ccd6bb5eeedf1e14262dcadea9e55eafb14a15b43125b7f1339b5c23dd37c45aa03baa0602c733e73112de53544e12e9530b95545e81f9203ca69facd3eb371a9dd3f477b4593cd5eb715f989559b8d8c14503452b877bbd34c1bd039067fe1845be5a5deffd0edf65a51f2629106684c5e4a9404512841734ede2eb339c89b18c78139a949eeb176c40d842ff2bbe9812de30142776b7b7ce02544528e4d7efcf1ba8b3188a0f5e5747b950d0c5229fa0c6059e2f9ce0f09b8f9cc6e3ee2110fdbaeb509e64efe3ae2788d8cc61f02705b4c29232d64a94fe8fd12a1445ad1c4ce6759e3857083aeb64fdfe9fcf55673a482e258a22d6c81c97eac079a56320a288bf142e41608eeeaf3a98314640440bfec56bb7226a0d5711b764569dec0b06e5064002a09a0b36aa8b3dfe3236b360f8074ae38b08def88c1597de0dd40ddcf0e14d9eda33a44695295045883fe8d2896b0b3dcd6af6a3089736d3b5e396abac9b854a15ddc7012a215abed2accdbab99df51d027b727c3a44e8b70638af80b0d17b45a63af32cc819fa749592450ccb978605653a79f98781a405f43d7ca4f850d88f9543c577234700faedd2a7d547c570dea7b7d84cb202cb428dca7182794a1e1ed8b8dae7844061faa6f0449edc8dbf9620c5db5d9b4f1a71fc8aafc640695a704053536f2f16f8c2bb7b63f45450e1a0a299b078079baae39f455d8ec2e7a24df2e021de33df315737f46699665b5fe35e33cc4f1844415d1c602c2dd2c2105076d016e5dc9b921ee858e16ef83b46a5edd01644dfbf01bc16ae11418447317391568e678e6d6760c0d78114c8f78bda9ad27b9677a786b53099a7c6ebfd25311cbefb4f8032d71c8f4a3f77c578c967e1353b3164a19f5d064780932f43776f439beb49a6c9994e865b7e437e36198dc2c380540a24a5c52bf8e79e0ef5eb75feac80da6ed848d809260b6cfccb700325e0d5a556d56ecc98e9565e0dff557280c7db2ac58ebe42d2946d683b276e9ea419be52b7242669f2257d7452aa513996f922f96fbdd1cee621129145c1a0328a4e97c2ffca89b81c52cb3b3716c7dd8b5f28d562da35cd03f81c7a6abf87cc8653f4b42b41c1d829ac2be5b2bcf7e5910dd6e374673c876bcf4273d8e67bd85594c07d70afa83b8239aef01ad0dc99fcf2b7690cbfca6c27b7b93e7fca43a8eeb835e0b3c6455477c08d2c3c60fb881c8522e7ac2c1f5b7e505bba45902c02d9b0a0166ba1dd779cdc77166c928c2c4d1048f0ca401a7cf7b8d8071126b65c6b4415f510c600e1169afe278ca1940ee3f05c562cbba2cd351378db8e6749c33e65d960c181938a00160d73c1258e987bad58a8e0a4917337159c62b520fa11be0b263d092d1f15ba44c9af2862908f9b189e311e5ff6ab5450f947551adc62daf460443afdac0f86b889746f853715b656972eed720999b3ce25f4c297519becd5ee90dbe2fed38ece5e3b9dd4b1b3a4ea3f5ae8dedc580feb9ff8ade31f3d772c6de4d13e7e9bcfd7f3998676a77f95f4eccba1fbd2f121d0873c08fdc9ff070092b65416f2a8216ac6fe570539f4e1e84ff8c673eace29ca506365bac9d94f7ff6263869c977efc437166222625f3b7c810424359290f973ceda5c3bf555c93c44c0ab6ab63af473c80351274a0e25047f8c9b86d27989d5eb7b252b4928009462bbf46a10b875faa82cf737c13fe3afdd99fdf357964c9d6e5ee5180d9aad9c0e6f5c6c943a2c30e64d57e89bba3168f7cfe2f364ef8aad84ec3afd3ffce3c3e23b725bd3bea766ee7b564455f1f40a21f442b368a7a9ca26c28d60a8b17c24cc3c19a916bcbddbfb95e9de0c848b77127df635964248a6a928cb5ea45e4cbf4bee4c6ea37009e99692457dd1cf88a842fef9dfe31f8a401cfc28c1d768ca041af54091f4fe238712ba5b2737571b9fb092de4a3d5bed16e109eaf02ec5e408bfa62ba944668e7ce3afe58b12257c9a81c2714d0a0539fdbb3d8d276f2df3269f6bcd03168195e5853b27c0c84eaa07ebe31d90754d09eccafa33220ee4ffcce01252da8761b236cb64a0027b9f114ac2971d9d4a6c9a50e1a47c202c5f7a4ed4d08579904e7f51779d2ff836c00d399ac003b7f675f6d2eaf426f546e05b05117d9cfc5e28c3f42a43bc5ea6e15945c1cb1a60e5f6771bf9312f112d52681ee72935e3564cd15020e2e177eb4008fffe99ea4397080ff376dd39bf3045969adf112653e62aa5698c65b5a139babdac47b9532347aaf17abda5d921cf44119b279183fb496f4d498c3c016dd871107b579d603e22333f73ee20d9fc6054295fe7b13ab8edb64e577a5f70db7fef4227734f695ee2292c510447224758341327803169a57c1289353b486b440beb8db5015a4be8ee24b8717bca9616c0763c2ebd131604bf9afa56f38fac0688a88b3ce2bdbb7abc7f991ba999ef0713480d00c566d1aebd777afafc5b7d43185c70263864f47dcd44c8202f6ccdcc5a7a6e300b0a205f20720caa1ff2eb85cb08eed6ffeddd5669ea3ef5fda750c49b1f9a008738841bfeb30dc9aa7fc1663fe912a8398fdc17c68e02123fda5e9d7189617bccaa5331a6dd5b90e0262ac7898aa27f9ef4161c492d98050dd7c24f1f894bdbc2e2683f2c2b047714c602ef06b098ad2f6d4986ec4231ddac0b25ea02e37d8cdbd40dcc4da84a39eb5d78815e2e13647c43e6c8d16f4a8a933337a5154e9c76413433deab8c6aea7e3d51302d7fa60580c3ac9dfcd0a0123df238038fb3912b2385341bb0dd96486f3d385a1c624e86bb298eaeda359d7ab06846c0e3e0d603425f1f7d3c6324829abba975532111092f303920722cb082c4f832223a0ae6a77eda5b3d361830d44061f99d7c27bbb2c2a38d56fd32dcc20ada943fcbcedad3b85c6e7546cb918288c55c2cc9ddf81d782d83b9772736cb1ed33ac510629eb05000f5dcbb1f48f40d403de9d38802d1746ae8dfc48c3d3207e23e0349b851434ef27b18453cb1768fc445669183bbc0781cbc9b8a95b1eb003b88e75c388b8a44e3fe05db4436b32f3b2f83cc19be1043af6022a89f348e9b0a4eda61823b7c84cbb0413ddeb994ef515c62db4cc5cab4c2206c41f3708cdd4298489421c1d53f95b7ec6660c326a337bce18380dcbdfebef665a5b6416816055c3507723c05c7763b5d903ce6a82bfcd4715aea3478d26c0c6b97a99a979961baf85aca3e43bc8c7c2141b33c8547626e6ac90519310a0e68c841ebec4adc8fa89118702183aeccfada7b9455ea4afa02b178d274bb1ee64cd29b2a77a56e9782aef2462a7b1934a1424926a1d3832273e87a79eaa5cf3cf5e6ec106363bb2690471fd783139d66f547d2a0969907a17cdfef4e5c9266bbbe214713f929cd7332e72cb339cfd973462224962648de1ceeea91742ce13201305bcb6d5d1c123386bfd9e7292b5af96d36f8ff169a4a199fabc1d70e7e196e48fbe7ca591cb4c2ab7baaad93d13b37d5633d2911294ab4343ac74d91ba513353c6689f5327a8eb4319725f8f11aae2531169555b168bda177beff7b3bea21f8f4f982f69685af359340108c704536474c45d40434b0f8d05a7daa355f783a8c48208a00f62d6e19929f406c3e881c243236908a74b92d5cd9ceb2677cc780e3e465952ed951ed2505c7750d4090eee765c1456646ca7728d6a4959e822ed8fdd898063629a6e949a01b95dd1a12d6ddd545fce8bd486c5770464280210b550628eaec7e267dce07a5ab44dbe543cd748e48771ffa159d11b777c06e6058ee486d5b20610f3856cd1295939b8588c2c59a888ea1c384ecb33bb837d41cdad7949c1bb5d8d82b5bdea4c268cbd472f94c357043cb850831118aa6b285c63acc840031f14c07142e1f6ac6897e703bd68fda57f634e095bc44f1d777137adaccef2e232409486b0885eb6a0b82631380b669ce412be37ab82ce30c45450c3788e64f7e0c8c84004f0b966e07589b4a78387b2060a23b53ada6ec197f371e9402f2432449c6603a7d43b46f55de64c10e9759968a6b0b6451aeb32caa54f1bc50feafaf013bfb50d39f6dd4a27f9d10e9153afbf6cd4634457c348cdae0c5a89eefca2c314c619c3a373b53b9304c45d6b7e5a2940c5bab7f1d24b7a7ab70f9b3783d623abb6d180d79ee5c89f407df58fae7df5cd67c636e44b7ea76aa3705897bfa545255d73730276c01ecc5450a7aa8ea3701e055a894e128b56d131e1459c1164bd10dc2be3628231c07973bfdd79618bed9f005d5a2b7d984a080b0f46a1f78cd6570f37da6b1c641c1992de7f9af6f72f871a6822ca055c7a60cf0d39f27c1513ab534337d06be229dede0e405ac0508abedb5f5c0ac64213ce218698b1e43e9e572de235b2425d0ef390af87f0a16ebc5855a4a5596d9c709a0e60e1302a5b685c5291c3ef1cfa7b642ffae9f5bb8541efed351a3a2ff92bcea1af5e6d321e55ece10e5c500cdf32d6a26da8fba53cf3f716bebd7e692e2ad12a329808569fe355d776927aa248bd350e28c3df5e18ceb3a335dc6b5b17fcee9901fabdc8e77833ef496d221fca252d7d325e81e552ae8a27ace95031f335de1873e616926cba93efc5eb9881002fbfb23f84564332d4a029a1fd7c8fd714324d3de59e025cacb504324c46655b74949ad507599afcb8dfcb3e81eb9f55da39a4a6a3330040a4e5ebd566643adbcf87cd61f57519e40b008c1e3c4953ca059d7ae4e1d89826e2b6ec6eb6de9580ac24b11bf4d34ccaf0cf251f62e05c730d3fca8d07a93451c5374d4ec31afd2cc44942cdc77eaf510abbf556d933c75ae1bfc67b0d6f1c7122a69233fac634a92771f250b645197a5b40b42fc881ce9a9558526c2d2c49b6c3c7bb7105ccd38f1ba0c6eb78e4424da97bb4496a25b6d4d3cb48dde5ee954d85b83358e64a59466d99eabbb619292ccb2912f3b14fdb96c1e01912dc31d9b5bfa5fc7a9694b53c4529e7c21ac70f53a8a024c80a77ef0b83fb6f7c3ba5b22bf8424a139c97aea69278a6b588d55957e56a0348256740b9536897f61e22c43b35d785839bf14a3b247edd42f0fc6577c3eac06a74f4a2d38773ed0813e95f3dd4b8fd6e4220267eb2f26c185d58a935fa893e3ac20362a2eabe17a4e361c2fabb505811bc1fa644b1d5fe1e483740cf1635911793ac1ed9762952455e862faed16a95ecdcf126f9e5a9e98634d0c05b5a39beb52f63d233b802316d0cba08dd69302e3c744840d8f2d816ae422812af7abcdfac6511c56b866e23bbc1e903781a0c457c1988ae8b85acccd8ba4da5a7d6215044a317f784cf2b092a007041e58684c352c25070e041853e2d057039666e6abfb1b208784e9fdb567e0fe7072bbc9e40898e09a973e689e81596b56c83e3e0b7d2d2325f70c3408340e71e0e34fe30e4f1ae9a085ca974ebd07f9523b77947f7d19566a167cab5b17decb98d90ef10c0ca4bf867fc65708794921fd373255036ea846ad79c6310e146e76428f78f99ac0afda284023fa0d951fa407c3425e89ab250ad8807a2167c898d0a2942a746101b68ba87f2429f5e5640c1cdb03df0ceed1d3380a68d71fd4cc4f8642e238cfae78611bb04bfcd477c40da2da4ee2c7f0157de595b842132f7029713b86766fe957c9159cd260d9f6d4c4d19e99ac527450326894419f8a19c5267b6c2d01c7b266a18ada93f99445be228db1f7c9423981c1680cb6fc2cfe2443f91b8e696eca191a8c04ec118e0942cc2473d51effb9442fffa67b5861bc13bec281cc6ca8e4c5a65fd3b67b59cdb06377c36beccc7525f8bf0f9ce89b12162541bced831f96ed73a1c2ce309349c5d0ad5a1bec03193825079b23b9847b5d31cb82f543440ee45e0e159e3a139e52b455d59210a5e2170967d765165a5101eee0af7bc41728b063208b5620352ca40176380bba81c5c817b7db51ff4d562060bc0058dd8ad256b595418b3f6a3c2a4c1a3fa7a96a0776ad4f8e4df364864b029687cc71189b1e101f5b67b2f2cb0707b1fa172c91237f23bde9428ac533cc009480561c91a1cdda9e2ffa17fa0a3aed665e26f25a6455aebe0afa40837103b234334328c5b8e387e57bbeddcf9d5c50460b4c81ef9302f62517cda39274aa7b58ad402688ed61b99d8365588d0afe58530aff1b9332199b9121318300b1aff305901a5050f9fe9bc48aef5818605d5bf57769fb24da1ffaf7a22f2f1f8369ceca7fde6381fc9ba687ab87082e23976aebd60278a69a5a3f361519c385c1f6704040082ca06548b1b0a3d9d15fce8561f6d5878d4bb3af16d528a48aee5caea6a1d53296311bdc336834c72c99978d7a09709f9e1bf66e9d3775659711a24f73b4d6ca00bdd07ee1028877a74bc2c1d408ec59cc46787bcf1d302c0c1c66045436e885d7f404ff94fa72581a3ae9864895f7ae8fd2a29a436a11206281db010954b8ebcdb2cc3a1040840c7387b9df2519904369d800f8315cad090b97e3f81190dfb17205ae094c7a23e6d6b4e1bcb53d4614ef6a963ec9c46bfba281f66665b0aacdced748cc1b42d6c74d8ee06f02c331b53102be16ee762e9a76033a4ff0a1ef329b5d6ca6afceb3839dec22efc9f0d98cd8d453cf7217ead7bfbcc295d5ec5d5984b1b331cb2020ca73355683001ae632fe4ae6091961044517194ea017e7f180b5527eab878a39ab23e9e598b72681f79eff3292774811addc49ba2b347115f09c9ecaa13d77c6f32d46de9a4cd4ff2a5b56c8c6eb3398acd4c11f4a8bf28f5161a00e1d319b53c30b5ba7f5c2ec77d83ec260f123898e1a87e2574b20e6133a4d3c95342a09bcd1ab186b05dc5c4c408eec733342994698bed7df4949aa18e8efef125d02f438f950a23b9d0c124ff02ccb047cd9817981b8a7da8fd6c97c1e1eb15254f6a369828b3a0d53b1f02cb20559b481fdf31f494872f556c30b5cae2bee4b42a3e761110828bafe3c14625db47c6576a4ac8544f9ccf561e88e3b7f173e9102f346352d5feb43a02b0eebfe4a8265b9564fb895a36c7beee37190acd4bf74e6cc2f786fcec22d92d5b2e36ada853751d10949afc636abbf23da0fd20aaabb0f2e4d8336f2ba2613b6b739af2db25f6be1146e53e1cd6c27cf5122f737450eb2c7dc077a2930471d7d7ce83ea321f8744a38743119a9e066dd27a0568183698195a12006554416f07c802cab91364375e02efbe82227d1a714575d2407957dd2d6fb47f135eb63f142144217b4926452d9d6223df74c17eaeec26789e094049bc8701170b5426d45c713397ffeaa1ab94f7d4180983a2ad5e46406c54d96a9190240f32d03aaae5e0ac96eede000b543c45766ab7c5608902cef410fccfe87db861ba8c02f84e56f4f81a18540e7a3803134fc9979ffce8cd245d2c095c0a70ec61fa9765e2456d9056d3b7c571b0c5f74bf73f3f9d364f70198746a5659c3d995be2564a9b032d058e1498dffe1d7dd5ac7d1f55c37db8efebeb4727b1d83e422e9dfcc2e592edfd9dc3f9bd2c78de276990c89a8afa08a05b112cfddb573eb2174c5f8fa31ae6823cb70e2b7b405a6231422d4c71e90a0b8d1214fd65f6c4d0e29f5206cdabe1cc7fda7e43fa899f9e9a201c1390dbeb9237e7dade9241f5214bb48690244da12e3cda138b4f388be2ff3bdf4b5813f4684a3e8ba2f52582ff1a0e0e546e9500d6470d240196b99134165bab2b8cef748c31d69abd5fc04672b5c8db55ce298701ad32d6165871a1b1287e1b2ab1ba1490c0d5d124c0fcf1be236ca8a889a6cdbe98908f0f1fe00372617472de7872c9dc7e4b8a12b132101eb52da56c460745ba5ae00596d84cf5f99eb13994ac91c77b8e1a72e326aee5b5c324eb286a5793637f910e19c5aa1a0b1b62d392b8a7c2c1a7cdcfe336d6793813b6448ac6ea247be8fa1ab3f1a6c2a0a9c3cc7966d8e5a3e3564e88b64e67c4d3c924eab8e427fd0e429c29ff0f13b888f94706dcfcde85be838272e5e43093a64fc6437cb40134abbb7629be48b3bb4a948713fdda000072309d5dec050e6a582e98951c47dbe521e2e23672ae302409fd8fd6299afab31bc14e3b772e67f2c45e10034782e59f71ec2dd2e5ad2e64b22e2a5349e726ac44e8008741501c42f26c7ff183a1e2e9c785ff689c5560f08afbc6aa54e5c6dc410169d9c6546dcd2f0bd99bb5e326fd916daf49c7796396f07d6d374a5b24a9ec05756298e524a1b438676bc029b6e74abef67d1b7beca7b3d75097461187d9204c69ec23ed5d96079803e278ba0adcaeeaae5e52b6cd1d6663d4446ace04abed57647eebd92cbaec5b4fe4b09924be734c73209b6a66f74760d8c4971b3c8d3e9c7c824bdd28b1c14c06e2ddd01665ba2c9225d57cd5daf94361fe9c1b1399a98cf9b652d24f141bbb86eb63db7bfb9c6598094f741381c3da2655c91dc51e7e205a9036037a79dcd14795510df0dd019efc912256c6a3cd3ab5d897c15199f4288aa2781eed1df442f30222e6adfded05c894b4f1297f7518f41286f16d06058625892a39ffd5896b5cdd556d28f3e0b6b083e9b07ad98a18dbd93034d0e797974bb19bcf8c5fb7c59402cc284242ec8e3cd10c376b96c06648b462ab185320b77ae76a14768fdb452a0bfb536786a02c67cbacb0268d18ef748c397555199c614f5823b3b5be633289cebcde1b97b4ceecc55edc3c81db913536634631313bd35bc96305b7c3fc0540c5257ad5c312791cfeb5634b4efa446086bce79f69bf914d775f51b50e7afa476155b2ed8fb7569dadca1f0374966e9e0556cebd8267eb4577a9914339ea96ab2a360b6dd15ec9f8e1f6b567d1bd9319f2d0ab59993b4f2c510c38cd9de560b4e8de365a8b440a809082c579b1efce438d4e43bb66e7ef634526055faeaa306d5a77a845d98439040bc809150b6be71f3d84da38493b710e4fd9b7a0c2beb4ac26aa74315647aacf266b3d685316ba04f94c2270161dc242487025fe18da0a41c86140fb31f4edd29ddf0980b3ac89587e103a1e21a6fd31471884e46e6aeb8924a9d0f5eccb5f8e870ffeab73fc3953a849fdb572d5d4bb132557eee575ebb98e17539b2fc0c72d3d15d21f0329f9145684fe7ff92616158f8adc9614bf361ac6087ac52a2253a164ccedeb3a34d49d30034051cd315c7bdb888bd129f02e526e8671daca9a0873081264df703845a8f11991ba0507f5261958382f5df0ef49d87490526c05aa14913c9f15cfad5ac32dca2ed508021ad5a75decdddf44406ec1177e63a892dda1b0f0303a15028fc41a29ada811223dcdcf8cb22b1ee0b1d314e68865205eef70226df1b623d15b40785a5be2627cc528f9497f5522ad10c8314d392c04df865274a8ce9f15051720563539eee4d84c488aefd9d0951035221738747658077cea7652076959df8470e8ee0d3e22ddde4458d82346395728c74280737fa17648ef713f28aed7797251e556da5e7061ea4c395a14d46ac9fbb4ca17851c9db839e3e31c99fce3278bc509ed7a8587ad97a9d53906d5b95c13b7ab7fa6517e65a56dc6d5245df84977f8b4be1163d059f1da7de01d809e3f09caf45bde7bf3053de6ed8c4abf020cd9ad87361dc0207a78bade346eaa26795a308b6bdbb745686a63185791ae055487548ce468aefc6266d6ef5168d64fe30ab2fb8ce1edc43c336dfe964b1dd22b4931f953da9b58d856f27eb5e334e75b5210313e5578eb987a24183d0f51a83b9ea1232f6e0a8fa44fb0a2f4be9a61ccbd9ae9961f0f7f5eea2aaa8ae634d377329671716bbf87725a099b959424062593cfc1383b7c82f45b9a0d12b1db28889cb2262f73c5c9cfc3ae78afe7c2a4f2ae11d48cb81a81a5860f347134e3d5ca3d3622e63642ff0ca261413e341dee9061350370b0bc16bfd55ee2b9e523413a336173132041015d4e558b1dc872ea98e5a875174cb4f233f7d2b35cd933117b1ac1d05f398ef7cf9d1d40745df29c491a01107f983d9accf3637860c2607cec3088fe7f45e52cc26411b6c6278c7bff138f422cd36a2c6a58d809309e2e7baa33ef9c1113466d3cdf035f2721950dce6b34881eb8149ba63fc56e9275a78676cc85af76228b25828611da1d341718a5e27541717a4f72691c4b8e76b4fad80aeeae04dbcddce74960171b06ac793b3f017c931faf38da4e4ca17b5b88c8896459fcb7166c86719ffff5ea5e8e550c7bd35d87614fd05846a9d9cd8696418b4a83c008aaf4a0de5b283438aaad39fadae38b67d09e0585b415f84b3246b45d1ffa5177c29dc64c4be0726f55890665dc450af73dc239a97c1050e03b9a8f2cdb61b7837c8c70a5ad3d8e23b462ef2c81e7e73a12f638ca23c5ce2060ff27fb60b22962060443a36a0968c42f6e29c80b14a48b699d740f659306e12774ae861dee271308c057e447334ace3a5b56d67e6ead42e9ebca44aad0c5e128d6a3c94e9c1cbfc73177fd46c432ef02f48422d3a6941a5a82fc2183195dbf21b03239145386cdb02d02cbf8402be962f0df4ba49a82b72f3e95e35b18fb568366aa4898a22610d3f746f94328dd3fd6ce75a4ef5812af560df6027c52a7be06e921df917341acee1bd411933f93dd8d36da18372e47d9823ec4467ec8963aaf1cc3f6918fc83b80bf46b011aa47ce43152313dc72e199b87fae293ce0cbb747916e617ece7dbdca28b6ea686602deb7a8fc260245fd524c5d4fe4634ac9d28a2196c7150831340cc55e6f0ad2b2f4416dbb7bd1ec823b23667b9b3e9665406f73c8fd09c5bdc24fd3fda01afa77ab568d493d8c10ec14be1a03f7ec83257f9861a990453ca47e66c0af492262d0bb6c6940e214a87145c7e6c4bd8645925ae92ff7f8382d14cc10a18dde89e65e9acb9c539f3e2be70a4a81e835fc7353cf26385517bce51f6d8f694976244e7b489743527ee0b60ca47b4a545c171275ecab92161bab15d55adff4335846200fff16b5316993717ffed29531b87e15d71d04325204178ac486331312dd5c8dc9271765e14aee851365eaf2f4f1c89c0aed835545c6211ff970f162bd7d40e4bb973ff6556eacd5defcc69f307b006e00a1bc215ceeed9d364e9f7de8665b93409fc958c2adf8ace5655fdbc6238462e760b9beb9ce09e57339c7d03bb3c006aa3a57f2bdb5a46e4bc888c4dd9df81be6edc9d11e41d8f82c72b5ad2a6559a5551f71110ddc22d2ffccc72feabef091e184719323289b5eadbaed9776e10eb1447d2d7c83f9631ef78a7c1f02e99114ae57d13eb18a60333551b7bbeeeb60f5c972715ae8922976383a8b6e8bac3d7d4b763f9b90d16c6e0c45c94b9bdd7aa54221741f00c2f71b74ef8de986af44f5a6a4f9bc6b286588b40c40faf41beee6c51ce7638","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
