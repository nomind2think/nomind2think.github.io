<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ed846b7a3ee219186045c0e9bae28a4cc2f91a11c7ab3841ef43b2bcafd80a84b91dea66f53fcba45caf3f1f4ec3bbf29ab41fbc81b0d996fd8f481716a86fc9d219cf9e39e6ca22c57ad991279b66bed345971bf057e650ec6ddde720913e6a3b012d7c22f06a0e9f8340de5580b1120e94fcdd4bd1a60f3e02960520d7a077fe8d46c9dd7712220620cb02b1cd107e8f7da9c69147c8dc4a0b47c7504130c2229cfae09b525f7206dc54eb61cb931eb01ab4a446c986dcbe7b7b1d5e6e01681801d9fb1128b7bccafaaedd693b7229abc42f0ca2bf5eedcffbb08830d5b3623c160fc0f82a0355241a6bba27278c4c01f91620733c0ff6607c6daf8cd5d56224828b9898384ce3a01751ed39bd65cf74d30a2551f95ce0a63fe03d349519b950e6ece4059bbba0aa5195ba39e9b5516bcae37570cdf43fd43ef8fec053b873ce077a0aa7a8c1dc2ce5950d8b7b8511d61aa596767ba6e7efc7603743954b43736f7a8c7c547a1e9266dabac4a689f9e4a17874afd9751e20a21398cf3afbf562b3131e50016004115570907d0455c7a6e51997349905b475a0b87b91e9ae085e88cf55998d0f6d294d1d5a76d99beddcdb52e57f384cddea05683f977eefb465a416f3660b283b66817d1df3efaae0c1afc202fcb09c9494801b90b4ff5cca3c922ca59cbfe17913a1c7041482a7cb0fb6b322e60b486f0898436606cccac8c100acccccf019104f056c8255bceb7de89d3eab411d10d8a58d970faea135e61737328464195fa457868b6c54c146fb21697863c507c47c5e9d08a475bdf2075d4a792b4502d34cf89cc30c1001a3fc6d99974ca3081001e7963a5c6a12881727e176b6f2bbad612a11d10980849e345be4eeda2230532b8f0b16b60c9d57b49aca095d5b8cf14d4a716b5a958291df6bc031cf9d8fe15b697586f3234236d07d8e2f917aa8c312a3067d555ed8d4f365ffd2c666d4a534a857b3b8bc00fa5012f3b31ed9cba15da59321b6f6e6273d5bc868bb4ef9616c848d862fe6efebc181930b2fbb49c62dca23da8ecd72c2326d8aa13a392d1ec757ea0a452b02b977b90f03c76dd57222da61dbbcf39d71c4a2747a394419008a0b2b9d99641dfb73564f0b00cfffbe10b3045d6a31b34e1b368abb1169e955702ff9af17227dd2d5a8975d174f454382233ea09288aaf02c30d18a9f18e62a4ff92933772fccb15960453add7290e7fbd75750da49c442873d2291fc0935976d6db55b4c114874d80da97e19054e2e6cb5b38fe76dabe9645b7f870e2a7a4719bdf3957a02fc973ab504c0bddea1be5a125cc973ddbfcc1101457e2e96e9ff4cfa6ccbf176440b468b7fdbb5ad0874851230e576352b4a078eb4000cc683c5b3ad9b1a834935400708efe6003cb84d925ed61784791ca99159af99936052546f2f7812df259639b0f1e0d847f41701208b0bf6dd5c9e334230a85c83b57bbbb5571c375a7e30fbd4808da62d563c182417291da8a374ee358d26dcbb3b1ca727de652e0b204189478f8f0bc27087fa2d612f24a877c93d455d1a2bc17d379d55f621e4058925f000524ff25c5026b388d7a4bc27ba700749610fe7b7088cffc1a1d8c802eea39ea0674fac3838642e9b097798fc0fca67d887a7f06d61d2d72a015579ae5b27df523c60b6a0bf155bf5cb394861d72a1976cbb5754f2219cd24811159e8625dfb79978929878c82320670edec8607746b32eb99f35b265c962cb560fa5c4fe168fd7b9c1b6ae74467ad28fe2311638ca85a293919056d17aebddb84b5bb6810c59541ffe37a7979fe47c05783ab5eece22b2968fc86d76b969b41245889bbc17b8331c0dffd13bb823ebd3a7c2c274120664292aec429ac1ded3c1954877a0de834ec0150d3c46cbad34a2e828090c6e42453b3ad59d2d449e3ce8151286b01d6a3f6bfd1b837a83ba171e81796c882a835efbf447e70fbf595027ae6e6eee744b6e69e6454105fc09bfe169050c4dacb116bb1eaf491b0e8f82423ddfbffb4e1828b1743daeb081e099f20594a83963f0234c6c42288d47889025affa60408976bce7125e460d354007b7aad5bc48b01fb710bd0ae692f4182986d96b9450aacca0505f969ce4dbb3723b4bbe690f2d460383100d028d15e9b9c623fceeb35217d5e9fafefa09d96cd70d002e5e120d44140bbd62ed9e8ba7dd9ec292d1a490c5ac5d4e732c96db37ef31f8dac0848401af7e1f281d1eca5f662c0059dfe550cdafcb6d08694dc190fa9d0b37214c5bc614628efdd7c4ec4f8a8f4bef8180608858e467f749273b3599a00ded41459da966170e39cade025fee9faec5c6965ad27918646f0607b6b03329f574bd774a0da0eca7f99f02ceed9cbf56a8a50269a19bcc7553b3725722ac8873d1d52623a150e6fda1565b06fa08d3f8895fcb0ff65a1f86778dbe180936d99beb0fe5db666b323348392091eb31db6f0b31447459690a043538d9d9e693215dc15653d8166cfa4cb559917d91eaf03920d0a5f5659e0bfe27ac2d270953686b9bd803fe8765b1cfc6971559d11dd5405aee206897c9e1871de37e7f85eef846485bb8629b3b3cd6874c833a3529b8311525c8caaf8a3fd39c21f727d5b6d9996bc58a68bd304357f49ddb73d15c807f84c9792c646db2b14eeb008ed9261a243a3c7a9909ea3499e096e4f038a66b169fef8bc6211511c719f923f3eec324995f64bd5c232d1e1f7859f904695790656eaf951fec170d6a5ee8c9fe5516887dfea674c0dab4e9b96f6b9a501e8ae16d4c9eb2855f0e3932758bce42c47ad3a989cc2f7be28571c9557d4f0875244bfa0aadf420a9ebf56f7ba8db4c57666615f5562782cbb810d8e67281bdba3a3189c544b47c2756f3442c2b6e3719fbb7b175e19a89541cd6dc8de1ff9dc3ec0247220b8c92398a0bf3e570d323de647e843f2188e195bbc4bf6768062e49b06e90d87238a05f3b80a574b15b40e7c40e71dc4ce34a0414c0ff22920e9fc05c0e7f569960120c28c3b548498196787d0d4412c7341be6e8e7afea8878160ae67f589ad21945d4df5b0860fbcbf27e22f5e4f55abf4e500ae0fbc86dec136085f772c00a06508759d65cf0388982f84b3cf49526c5522feecc85f3aa1d5476beb3ec4058077aa50c06dfecdae67cd0a90016e91540dd0eecc135b87105d1a6161f9212f4e89ced7aaf329fbe3be4d4d6a5a9540e0f255ca3fd426452e4bf0489a1c1dd33ebe94578add642dd09658bfae56ec134f6a28c74b0421a5199073e5d6c8e9ca20f00914de712f9e7d3d451a7535a439fb705c74ae182dc9647d0319508293e4a9aebf1e249773471ef5eabc7035965470dd74049ff8b2d6eb95f916d07ae69347966c3c155c3015e8bc3a42e58cd6c77699475cde81da59313271a3c83fabb566a3eab6e965118e4868297ac6048bfea5504e38a09b3b30b9aefe8089c0d1eb8da03bd05194c4266d9e240af86c2b5e220a89b54020642521815e0afe60f0eeafa81e899b41a77522f05beeea638c1b7509269d316e669233651f7fe07c1674f2c97871a71883363f926b719f0b631a2003990ca18271dda9f8e790ebda24f420559f75b5eb32470eefe514853fcc0d0a50cde103cbdfb6de14c41d18398695e3d29e346a68149105bee951ba758839d977174edd3edb281a21ec164f8d4fd0554e7a7f26afcaaddd408b620e29b821750010e358ac18cbe78d2d65fb6dd9e9e8013e03baf87ea3a11dd3def8745418db77263540f9b702b6b69aa5396ce900aa7bc1fed66b7e20f3853cc1708ba6f0fd8213a30a3ff0749cccca9aa62d3828d6fa5d50fa3a61a1878a6eba82b063af955257adad130dcc012638629dbeeafda04d5b24b53f3c7ccb59460dbb31d469e00a35b5faf3cd62b580245e881c95cf0978d9344bedace5276a9909fa532f3e56551774529209f0e268d3f9e4f49c463a6b91333f7aa3dbe7b6a8a2236a1e9cb4b2401550f407a5f2488c2b94c3081cc415dfdd6c77e14b967c70d2eca139dbefbb556414a915d8f25d8177a7a547dc4298b54839593f4b3f6d67319ee1384290c31d7905202eecea67e4754977a7377b15ba643add2299979a33d735934c1d064861037879695055592152ae1f5b61fba5750d2f3d931eca7ab86e85ff958f21cb252267ce24e2bdf15eb04df0fb8c4e870eea3e14e91003883eaaaa12f92b07aa525f23cf16ce8e0f0dfc10ac23ebb8cb3896986f6c25e89d36df5a82eba19769580555828ae6e1adef901de3e64a9c5cdc3f2d5a4aa36f245d82c57087950aaca92c3c5dc068da770eb231fb4a05462c62830d49063d5a30b9e582b04355447c7d063245584c53be7b5c179d14d5862f264db21b0b0ecd13863038b313002da40801d9505674da58607377cdd4576f001d0bdac0c819da41b2b61d03fa0f1f103f4c8c44c9de735481eea638cd7266ea8f9ea67610dbe22e7a9024c8e02125d429cf55d2fede2b001991e8a13184e7ec2b2164b5a5053f7ba3af684630e088c4349df0ee751f515fa4c8ed1fd7838bfc65ca3cce24a9f8246648ad42b81431f57cac88a8e76e3054d18541ec49fa704ec6aba08dfffeb0a184e826948592dfe35f71241d2335cfea525b6cd56ea382bf4f48822848d0b07901195d6f1917159bb24d84eb031544f34188d7b2e87b3981a43d951a1c1cec6057f36d70e37e08a6f084bdea58a8a3abbcf0400e638c5edb375422d4525b5202314557951e45def13f33d494aeb5258d189a48456e3bd83174970338b5ca826be53c2570d67fd8b65cd222d04f3b8ea2839b32472ee3369da5502ede2c8a92537a852b11bbb3455cb19c6b2169984107f64b766c11d9c2b82923ffe30002c86fbc69234056a5d53010e6d5f50fd175ba0306deaa155af21029d89269959cabe9859376c3bf25426d548277d79ab5caae0dc13911136c989451f9da44d030ef0e728386dba834b50cfd63572956a5de8bceba9a6b26d5a663d66a044db540ef8e86097a2f64026c62869e92528574250e4e429a760e640ab93b8db45218f1979891e0d085b15f95c899863c3fede975d38792d8e35585992fb8f34c561127779271f84b15372154a54091c55661fa3a41036079d08f30f43e59b50670cdee6ec37ebd315021cb2121168fc4b1555d04508b150007a96deebfcbb3974f878c64728491c0d0b3fd32ae2a2d7f57c0447a9a3b471090e95c760602052ee186bdda8e7b54510ca14de36e8a61a5c612357aa3977958b23efd1b45c72cc55f8646e95d597e32156b7c2e917723701a1e7de4eca90bf383772bee79ce27db9afa4daecbf0a45e63fbcfa4d1331412e7dae0d45b26e761bc59b7533f6d7f0f1f9aa86154bfc9647e4db05553611f33aca343e4f148ea730a11e6b7cabf32451932a0b58bd633e3cb5fd8bffa11ce3ec339ec6de98cf7982b4bc02dfc88c14b9cb769fc1ebdad5f8a2269cc0db822b11cbb2cec165b615bf707c8dd55ebf5cf3da608c05fefe83d17bfba9facfcecd0fd0520bf89545b81ed3f432a5d097933666463448afae88c32aeb0f5df430bb9ac4e8eae15ffc045a13c4f8a7e400fca09afe7ad219bebd6260f8a737c2172ef3f6cf906ed659bd8e3466e63e796d9321447ba03e65be6277ce8511c8275a6bca4e5267476d5ff1124d25a25ea5cbd09e6d96872b85a1a757aababd0ac104eb580623500bfb8b82b081fef1f6ba839cd91b1ea4b5214bd578350565578e7dace1569a3d52f16d27e89f7e6e0d9a6e5c3d7c7692120f4ee36b895c88a08acd9914283c8a5c66aab3f653bafc4f55dc050e2a22653994f942c6ff50f8befc78f9b18c6f6c468092bedf7e952fd0bd7110cb070ee115c35213eb2b542d12a38bff59abc5c059a9ed4c972703a7dd8c530c035136f968d1ba655ea1afb8edf0350bba8289a648979243d74fa856fb7947d39ceb6092c864b7e00cd9071a60613196f9b864e155d7cffba44ce377b91e1e1f4a2954cc0aafa0d19a9ecd51415bfc2a926cf5cf4c780d55394fd2611ef117d8e372d5b087332856df59c47f0e35b67b33e1b888d652dd31546a9f88777db5a4090d245fe5972c281687b2e855ff8191e95c4c9bf8d1c1038a2210fd181ffcd709757979608ee8698a6f72dec958511401fc0edf5166a432752eb32b1abec957ac11951a741d42b09ec56407d4f558e2a9ac63ada60e1c771dd658d3b12d96e94da6041a8c4eb23b2dff81e79974b4d7d602452690f29815893edb7f781578a28b97422c7039d8816e43ff7abd1ab1177c08596853aeb90e1130a8638a80315a56f0f5091f96c34325cf15edc325bed4235378283b2ac39651f8236753721ea83582687238841c1cb0528c3dc3cecf5370450edc2e3168dca0c1c416c40ecce5aba992cb8e433c54ab1343ad03f08514a7ff01194c9367a5d89359c69be6a38f238cde156e76c0da441e32fbc1ac865d486e6ed8fabfd3d986751d2ab22840f1334a47e4720ff668e97d289f81842eb1c5f6460f030368f3b65f3a1e6eac5431e0b83c3f75dd1e68b1d4807a9654bc10b37404ff7801fde374762ab76f6ec81ad0e2200b3e44fb53b2ce779d5b079c1c41708f2663787e4230bb10325d220ccfadaaa73427717d90daed1d0a1cb3a4c8dd58981a4cc35aebf1d35b4e21fd8aa9b5c853a3d6d113ba15d1d0d898cea3f67f6df9f2cd609da6b4407af0168ef4598b20e6e823c05dcdf5159901d7335c1211ebfa29084a84a659be77797b5d28181ca455c7c2f22f22b8ac6e06db822e174d7c905221da5343cd81a117e0769216252d34e6451ffb570eed629748589f361bc099bc42aaef7df4b687ac3d9fa6f3cb35d33408874d60d38e2d99c4c4839681834c4a8460f398df760aaa6bc35da62929e649fdf11a92d148a0c68ede910b0e89057e8849afe47599f5684a21c217bd7c0b37858723c0f33f40ecb5b35e8c76f206cc2f06c24125235f0673bcea694e57b80eed2948f1350f8ffc53ac9968679e7cea32e80572fcdde6fa13cb6f55b4b3569e57b5c9e5654e19c2250b089e5d607410347e08d60ec325f1a1dcd0c44daf3b07dc0617df5fd5cf61edaf49549c3ecf748c17c06869df3bb2c43375cc9445e90f47005c3033eba9faac9198832b71578d42c83fd0fcf1c021739cb80a99db0ba2aeb079d276b3d8785aed29fd118897911a5df3bb541c4858299063d640ed7300ca347f6f7e9c1ec66768ee90892f4ca8876bb6a8223607b88214efb8d10657f5fdf9b944a0a3fab1352e7b4228b40e48136a361a33d5570917ebf7d3cebae16294b2acb53713d703443618a6c5b9b214ef16547fc34bbd4ad8c51c1ba517b53634f7e483b4508e1ddc963d850531534bac10015c654c35896672ff8d7c19b177faec96b27c23198c4dd8f61ae76a9eb3172277010455d01c7bee09e33a8068712eec6923eca4cf5b3df900cbfb210bc39ac7543db4a20686174d157fea5362d5419d52b5d36db12e6e6e76f3905cc7f6402fd6cbaf973d95fd2e64f87d4cfcd834f75b764c4132539b866428c88301cf6b7159fe5fab964f36dd8a8fd60568e84f5b7151cc1e7331b0e64869ed76aa5898b33376e3407e5ab13ba15aa97340e3758c13c4b535d4cf3dc91c11647318a835687be1fff56f220fbe381edf67ab251815b8cc5d0ad167c2b3560f0027d6346d3781e062e0e930df75c7fe38aa9e7444ee029db3d521220d501c6dceea700a424d88ea2661b3a382cc9ce7fc186a780376399e0f5aa879334f43a6bf663aeb01ee73f00a2ad84d829d9e91366565a27f263defe5130a0b4e6f4b9d5a7a72c06c12df9857b7bd33e711d2bdb6600cb6ec19d5880774f90eda2856a80b545225533dd46105626e171be34cd4924f2174b5e8f3e1498c1d846f9c1a401c551b6c726666f35d8e20e7a0d39fd6e6e10b76b9f26243048b29d0930629a1674dd9a1eabe9ba64bbe462166cecd773b456d2c3687564366d9e7d44aec413f6d9f4613d9699e9abad42a0f2c198c866f1a351164e5ad112594678818ed91902591d45eed803c6bf05936df3c9df4a373854666d306b83cb974b0ec0cb9ec72bf8bf0c8ada2005921050285fdb03e145479cf2cdb161cce9d7ba1d550e7d0fd81c96607a883bf65db034e4becf9007cf83648ac93bda0dbb242c80dcfc3e191d8b3acd5c368151963b59f67b1ffa317551705ba1299e3190f04c2a4f320cf4873dcdfbad0900dfac0dcbdcd5f48544eed0d5bed54eab88b84482fccc5ae61827a8e6fe7b2b49c2be54bd8b03763d1a6133986bf7458c3d309cf25b1b680c078e468b633587d93c86008bde563833e70dddd58d23611990d98463c9587483ab844e67bc31db25625c17bca5be63ba60661f36f4e1b46db67cf3c657f1a5a9234f52ee354b4d89aadea782904b8a97495de1fc35c494c8e46fd6b67ef29f8dc20768b6189d6746dc58d6c0d0c3317446cb54e8c1e5e2df6b3a21c910d32f26f1d86f748f8259c7ca92c29e7a55f8e266cb690bd446011103081b93bc0eab1b9689fd365383059042494f32f4f447cab554dd13c1ba0525f32ccce357cb77529839005af594a8b07b492c47e9da7824bef5826c3a340b4bcd2071ede2a3d5fc619384317cd147a0292eadab1d04f0ee02fa76db13745f39b18309df317859711c9eefb20460b62156994fa88fff6cf10ad4465e6faa513d0a0c919b7086b9b8c6c65de4123913d583355c8090a3eef21f3444d4396711ed60cf6e6780260c72769f1f73c29579d0cfa8947ce469e1a6fb6587ba95d968de3ed2925e4ecf7ec8a9bc0dcdfa0e513ad398067bfc578319f86afaa2e2b3b85b88411499b4f8811471988099ebda9b5f2ea5ac1fbd5749c7aea6ef25032b4733336473081e303dd103640811a671f3b6e4bceaf5358e2d9bca763712e980a6acddea0a893cad6e221e4251a98ae3b475ccf9aaabec276d229e6439f11fed051541caf5ce23cb7d2afbee3b5d51cc1dce246b6803f3fc871fecce66550fb0c3dc84de0d47d7ee325174fad83bbd78571f8f5ec45e3ebdecf520fb4dbad0685ca245ae520334f0515ce6bb1ffb41ea77ed03ffdc0f3bed63d6d4c2741bf81240f8fa44017b297c5d369fe0da9287e8242eac4d176f190c237f5b73e8033453d403c3145a65988d4b5d5b0feec6c49065c1faef472a240b8eda473768dada9187ff682efaddd17f9654e46797fc5fe5ea3e3be56a83f75e9de1ef71fb84fa169f8a35eaa59caff347aa6d5f8197717bcda67d4ed9802d4ff692d49d89ef099d85b41cf2aeba1c4d7a8ba90c8adcbc3f6f574859bff21806854aca74a2875d8ff8d6df007d4db78101efd131ee55f6cfec29b7fd162ac31133792043d5535d694b471123704a1ba501cd773f8809257caad54615aa8a59adb21aa289b478718c5fa2eb1cc60072d57a551b01b893939896ac049c66c7ff00edb7cf2acd82ff86233643fe068c3bc0a16d29af8bf397d926251084551d076b33f43ec8519845511a97aed85fdabc1dad875c0a2393c8d98e76639ec78f8b1dfb2d64ba5a3877f1ca0bdaf00f133180e1efa43327765fc4b8f0ece9534beff55ebf91e3f854d5051e72d3b30653f48f122e201a564e25e933ba3b8f11a4368bc542b42e244a8119151f8a172cc1bf479714e55f48a366abc70f4b2ac80dcdb93ca7900399257e303aa2328d6c68b4f6285a989f7ef3e00e514d5639041d12e41cdbef45a6d97f179d6732516f1cd810b2c9a409be1b74e0b3c52db4fafb56f3727e3f443e891504707b69d2f5d60cf8ba33bdf7fd0a7a72fcc2878c17ae993432bbaf9f9c3f333aa55103caf84086e891ef87411447d24c7cecebc8b9359ee9504a7455c39a98b26acaedf0b00eb4b95759ba72a40b5fed88b7dc90eb5aeed1122c1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
