<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f08e59aaa5361d8f83146a691375ab3fdf4826a89bd378d02c977fe2c63dd5b92216182d2d493e940baae7832ecc89e79db2785962fcaeaf5aeeeb907792376bd95ed3cbe33b1e348570763658d5f37bf0eccb8dc23766a06d75192f56cbb32491bcc9e98d9131d6f6b8a9ce48495f0efcddcf160a743e55a092850a32d21ff78d6d46779ce8f8ebb3ca63f2dff829acc01bd140eb2a06b20441cb89f00dedf466e674285f91233db4fef13852a14a63337152e5401226f62c42857d8ba11ec2b5ea91203f0ce52d7e64053eaab368b41cde4f715a75878ac7991c594cc17f049c2d3697715dbb4b9e8f9622d038b2686a600d1adcd253701b76c9ffde92d6741571ddbc59b054395d516f70341eb648ccc06bd87e68439b18393fc942742a6b470e8f72da26bcbcb5ace0f3d758b1dc27abcb16036859e7a212d13fa8335d776e029f642701cb8af470fefa5b9586882e7478b0051355fed9c034e32f933d9a309a01257bd37b27ab3f059aecd6f4f0ca4786d5a3ef35b0add13231df45615cb2e39c67c6bf095d7e631d4c9643b52766a1027fcc5ab3d8a2c05019ad6be0313e0b844059a337a4d4deb23344df5296a61e8aa0e4b24901d4eef4f03062d914528fe3058c7f9f26482bba17e99624611c3443409384611db1112203c1a4efd36472be71409715ac5bfea1476c1eb68a19af231de7bf4c6fcfc15c2a1f4baafa6d776e1faf289b43a1bc04e17197cfac6472d84bcddae0935a2fd31fbdc341a797942c1339ae67cdfac5fb7ec50009b1c3073f5e089b6c7694665aa41c5ad9cd02fa751a1ef4cb3224fe6647e6164d32ba0d5c6be924c0cee6295e90ab90a358ece7fda846f0a00b484405518bfbfe53f840187913c10fd22dd4bc1fc2abcad68c878b446aeca9e4d1c5c58b569b63a3f990dd93969ce62988535b2aac72ee8ba05f4662055963ff27a84cf26b5a45321fd8a085c9d9d086120e6d01a13a5a15a88e43a62240e479832cd3338fda285a3b3f1d64d5ac80aca0c1da1add2bd8e7b038dfa41d35929e7ceb18057252a879f4150d0b8b6518aaa7741109a80f4f5ba9f493a65ed47daef5db1e74aa098e593140abca384ea66f3f0e4036815a71a2df510dc8b67600633abf665ff4f5c8f4885765df21518b5b75ad8967177add2457d4bc27ac9478ec7bb5ca9964c9807ba308ec24cdf30599cbf7ceafe0a2c1f749aff88b65a69e367ee8cdd87e85f442d7e1776c2ad443a1b21ac9107a89e2072f5327273efe5d4236a757a71cc83111ab08c525a055f4b1c81171b2b7f13fee761be51a0f6f4c172ce5b24bda85da78f2890dda1f7d6b4d579617a8331e04dc33783bc559472ae5c5f34f25a5bca1a0e5db31729354fdd7d9f52d5d6657de93756ce2330d33cfd1c3c2fd3d5f69628921ebf270a0cb2250b8827bd5acfc0bcd44e724b39d0408b2321069a334dea8ed324e2e112733d9e551b4c08e62d238aab2207f020b0a80546fdfbab917238fae27e3c71bf1cda2196eb69861f739a1dc04b4dad82f375870a8d70749381c057b9b8de6c0df9e139ad6f58b4e62619796a0fb1631b04f625814e45e09bbb09983c5bbc3769d3d87347497c493a7a7ed341d7b78aae3f98e4d2326302630730099be616a25e02ba6b2f9268ab5bfccf4ad9a68929a052cc95822b19f5af3ebc1d064467be4f7ecc0422747da88ee67b6b4c069fb44e66a2e5fc35840919f74bf8be8ecd1adf9fb75adaab991d33ff46a4db53dc9e44ecf45588f5ee6061c7f001f4875f47dbb2857b040549290fe0aa5c625e8770a307d310bb79b1c8de71fbc86e99502c221b15e19b3e72721e679fe751ac8c4245f9a690f9a515e77ad4d3b38631aab930abb0b7c9ec39dcc513bacb272dd4f6166d616d6710b8034dc0724d35910d7535b9723eca2af4fafc5e8152936fc85e4c49cd04f94b359ee5119060939929e5702806cc59f18a1340b245b474a662c79a05fa7b0b58c0d2c1edb3434ae39908d88eb105f3d13f7208f8ccbafdf26cb3d94f6c738dfce04b49df642224407a147eecec367162681544fcef697e687e423b70fa85c29e7c60cb23bbbe389948f0899d059e78634d406109c2603aabf65d81f4b150d4d00a059664cc43713bf2021f845156ebad4446960f42286b9f339871d911393786d1622ca863f8ec5c3a3d1291c6e2731b87271e12a3664c1145a2591b244da24127c9765066eea3d1ff4028bdd84fbb96ca4119f357e44d9c45c621832848da4d6ac8eced894421909142bc41341200120c129f0c08e8340635439d7db505c09bcc119c7fe00d0e90dadc73610232e6d55174ca0d78b2efdc6c1d162e310b9b536178552acb89e8021479e2ea6d5aea94433ce68a20a5205828c7f65f7cf75520dac97baf0f6bced72b67715725fb02b7ab4233bf97609da5945d803e0722d761a2d90e120c250129d96036a91e18fb1f8e279e0456ab521e816a2632477aa09b5e5064f15a52d9cadc20a6241d6ca271df8f34ab9d1bcb28b80089fedc6f52f61dcb01e352715eb0075e2fde332640ba451220b5ae029ced1e91d12ed2f736aeb0bd5f0eb1d1e13733259f673e89e6ee8d9bf23a1ad7d3f66ef2bd33ae15a1c79b55482e69aa5b4a52968b61cb2ae641a9693e51a7134f4fe984bf391ca15b648197b624ea16bdeeed48ea0d7761413de9597670789e850cf29af409005eb7ea4689bd6c80af9d291b378e8e719fb0348a76393e63ba54b6ec35f7d98de3806e78b27327ac75ce92cfe1db60d447721a3931e4759288df46023e60c6e3436b058cc9d84edae1cc4ce8aee43d8eeb1d3f6842ecb9de0f85872212da389d33fbfffc7c6ed363dbf24d8766c4291efdf44048540e5a963234e98ddd6aa04e303426991057c2b9a26730e3331a57b205bbbe3b874bb5f7044e2d310f682389001d51dfeebbb5feed897dfbe9024d6b705ee34c9d0abe646e939e837770fce7786f47feb41c1355fa1e8e1695abfed68b7c6d4ee0903d48e4611c3bf9197c27f047402540033b4c82591cb190d32a777740787e436bc341dfc1970feccf1b192a45329d1d78df9756e9520ea9e9c9e72197daaf6ccba90196945c8cea1a522723b27af5f1bf3c668326efd41b8bc95e7b34b8358717e90b5ca93fdf6834143f58cb073d1c4f7d703b5cff0804a39b634572b706f52a57771c31df6569ca31369ca9d7d7608779f18052f9de3d1c5d54b6beb67f3bb906fc37da3fa425686d1e37734b5ea411b253eefbac8140cda35d1368889531bda227e164f8f478f9f16242cd5b1d592afc462702f2187e3d1fa48b92a932a95d2c313413e1845f60e51be47418767ba3e646c52de45b9c41d8ab2403c87f0bf85192fb638601ce4cda75f818a5ba30223b1799412f3b8343b425b7f53ebdc2782c66935caf7768f49e194b138751991ca3338e386f4d72c0684382667633943037e9fac2daedf4502a380c759514cacc824ad411da8fb9e964c03e0eb2a0756fe3dd7028efe53d5470c77afa97c08e9a0791219f5941b65a4bcfde490371c8b3eff33a86e9f8e3ecce0379b48370a7504282ca49e245a655e691c37fabc5e5fc83952e73acbd47cf119f3e82086736d4c0fd18e73720b784e5d7ef4a2ca8b2335b60b1fe6bc7c2d5dcd9d69d0c70c832d7d29c9ed3ae76d27a8b38a20fb5749b86ef840f518c883090ca0c85fbd9a084fb24b86cd9eaa996c99f6fdef233232963c66ca8b30ac8f7e3f3199f85bd32bb59cd3ea43e4e60d345b8bfffbd4351eaa620459cb9bab4cb9c4d77b78285d5a373a27b1ca1b3efa7bebefe489548a0ff60d10d919958190617df7dec17d3f42b077fdc9736d910d09999c73fb3a1b1b0fbe1b2c4fd5c87777de752ffa41dea05977af4a1f53b0f6aef41311dfb091b174e1b3f5146d9b2fc07c3adc6d985adf243a70a1ef062d53ea0a4a90acf95a5b927de9a4130b22ccee2e01e90b81d7c9b1cece2379ed51fb57599740ec0ecd2df3d844b9a795b097ac8adc32dd946ca1935932d88dd9a0081bbd99cf5b680d65440d46d8df1185ceaddb7a3d660e6551fa439ee89a9d81bae0750a7cb389b09442c508a750a1cdbd4ea1385eddc427403fe4e7846a9aad215fc386304009f26e7f6c98bc30cb02c4b723b7d88f400a52b3d32c0e2051d16ce52cbce3aaea0a91642b747dc68943056d0d8eac2c56c7d5dc87ea828fe6fde2903ea27b633b7d48986e9789335817158dcbce2e40d6618ec7946625965add181c58969c6b301928cfeaae7e65e04ac298a6ce3076e0e49d515383c3883ccf75fa3f00f226c68acaab3c8a36df48ae695259c929a40ca8ddb8da3301a77affc4220f19f8bf326604be9aa18b7f8a4122694ff570a2f63dbe2725d15f0986f38e5ec291c846281befe3ada56aa950bcdfc71d4b13affe44476bc3eca058138f7544e4ed5639bba08c06f600929ff89c2fe43d8095021b0177e6bf4911d10633af849b64846bbaf4fdddcd991a95ce659b34d2307ff5336a0235ed8ebb7eae8a4ec5854fea0ba125b6076d97e3fcd7f0902999c8b4245a183768d5acc7626fa852dd95dac3475bad348514cc878821dd6232efbc341ed34b3c9dc8430cc1a8701363d512b0a3cd435d9c555e0fdc22f198d4182d9da5253ba4880a25b0962940902bec73760f5d7a1de009060bff91563d6726d0ef29445d740eb964e923b19f2cf5d5a27cc2f135a699747327aaa93be471dfba2e8d9cbaa7437a8c089915434f4b16d97ddb2a048f90ba43d5652928fa440099610d5b18379c7485c6657a6b325cc3ad9f6c084066f76c4421bffc64bcbccf6573fed0d5417927d7feb1c56741ed03a150311f5bce03ad3b898caaa3effb26d0c44b66ddc4623d9b8b30b103d4f156d9e555f16e761812d67c27d56ec1b2272d11218491d02c5e1c2c78f78cd44e23f409dea38d59cd7f44fce0252df87c8f2c2517a3dcb8433e81c7ea9ac4572b8d01436997897618d77d805d5afb152317a74475f165596f3d5798bd06b5d28e0e184b9237543834d68732f4dc5a042efe3349ad008d4646d42273675b834325b25976870686010055d022583e17ee27f9c80359f061a49659b43971dece2e2a8d96738de1e628b24f7f37115bf29e364d8e22c124af9cc624e724db5541cfe3a4664be6d96c15b45e0730e0cf2b14e2322f83d996cd84fa57085f3dbea1917c630aada4f0f15bc391ed0ad480838df203dc6b62517c1e97b982de57a0a1ce769cc05a5aaa1e9d597b70e8e04dfdbb0b81b891c0977cb666c78fedfdf414558911a590e5e5cbec949eab09b051b5a1d19f3778a4ac99e9a33df4f023d148d94a6848302b67bd2a2744185872467d0de706b7b56fbe8be0fc741a4f36f59b9e34328d68aa83da5f7bdbaeac026773de40d1d86da7d6e12e6556f8d4daff6ff5a6ef4423820f483e91b8c6a74277b65ec3f1ffbbdfe4a449d7a311ed19db78f2276e1f9e2d9fb6559fe2dc85a01fb34e514b8a3864861e69619087c844ed2a5c258028db5227c2546da39c00fae15775cd4797ea7fc5896d31b26910c02e97f5d5b94c09ea015b4732340a8f004531e0da3b5ea455d0901c73f49cc5d2e9b61115b95c9ee4717c46da1fef6a9a31998ddfc94ddc25cc8ba06562a1800fb011d30d10dc5866cfb4489cffed2e932cefc63f0c850c97157200795e6b4b9fa6d3d43693e74895bdea7603097ec999c40286e54782a3a8b5663311b15a6abb1467623433550f6ed879cf6ca79d7f72cdb8fc642cabbb37b4b5f8881cda7ebe505926bebdcd2db877d328da19b1140aca73bcfbd8a4ddbe10d8218a1eb21afe0ec49e785d19716b407e0481a0bad46e30cdbfbf5e667696871bcb7d48e2e0b0a7866e9e6da6c2c965c5d81a11c8eaac519790908704e76d032fb4fa0ed8ead5dbf042726cb77f89a000743a255ba19366fe756ee3621d71d2f00fff51673806ae202f47f0619dba510a7f6bc661af368f4444fbb5e5af21c0d64397d8aeeb9a0c787516e8ed60553a746391847777cceb27e05f5e5b9edf7f6d2ede26b1051b7af429c1a2d874f7b2084a0fbf52c60f344fd8c538c359145e85f348558ef8751b6055d897f0da0e5858a5667277b59f3ac6c0a0ac79464bfa8d35c9e031752323f88ea8418932297aa91256fd3bcc43825189f3960cab6c2518b2ba598bd68e5a0f3c1ee0626ae5411c89b1deefa0ccef1ecc2f957163b058834f342041a5f7c6dea22af5d7bee5b4ba657d35bb200be6ea2dd8103b7f4ba7e33216aa2d6c644aa31c6d2f9ffda7eeb326a60022d29be738be41605332b682e4d23e49dce34bd65ca3a440921b7fcf775da27f1e9cce591bfab3c434c474a9bb7a8aad9aab6cf4cc3f39ac486f79356a5afcebc2708dba8db0fd7a7e70b77925eeaee058025e3d8a94b1d92097bfc4a17ba65163a9956435a000ce9a25cd70aa0d7e43393579aaa177f6e763fbc3939b4cec58888f278d846b7db955a0cb95ab22d9dcf56c0c6da19da66ce288ba01ce1ed0ddb8ec9da3101a4612500adc4d36c40b56cc4fbce826c3bf67eb86dfebec9bea9abb198f72de989597bae2cb3963f4bdfcd6f9be21fb885b9a9c188696517a0e01f2f875cab72aad2657bdc33ac335bf9e1e21469d66e832d8b159683fb702f34c86733f3290f61fd932a71c1a70f3b21d7594755fc6842291c64bc0799d6d3a9f4ec3324122167aa6114c9612d2a052077c6ff2aaf032e1b7dcfe630dfee1ce4bfd3e0557d8f19bf744eb6b1b12bf6e2ba3004b2496144ed593a96f180563cedd0e5aecb1e325510127859821dd0bffaba664ecb09d6d767a242cdeb6a05326ec4524bb46ecc89e51d44d48c24a07107fdbd00e9df3ffae06059ebecea3170c187cc3cd1fae3fae0e9ebcc0259f0399d27eb6015e64d8019f94c011c24c4f6bb5b6d8be6c3fb825bfeb278623fe528d1d9f43ad77e7b91be4da5772d483814bead56ae0b2085a72237669e0cf72537bfb2aebcaed27305d3b8f80993bee0da88f8b4e2a770456a9363de12f8db89b35389f63a90b256441a5c9aaea2e0de41bda9725002841a0361a90e6a13dfec75eb5d55eb0f5fa45839ae4ec9db907f6e3a44618cd0db7d026825655227751650f642bee9406fbd39c5d62112a33a3c24e63ae9836ef3c02d2610719fd726926ca298b98e9ffa4386417e10455880251c0df26a3905e5030aff4831a226703486ee37f48f77b1c00cc01fb5eaba905a7d5af7bc3c3fa0273c7ff92870b0d47f64e6612bfb6711d876dafc5b22d5f8d5067db9f7677982c90d99cf1eec23c0e8038bcce59d4eb77a351db86a2c955e445be7da4c3b4c94266bb83332a3889a328e0d68c634655d48f20a68e23a38fe09e4443c44ea8a4af08033c88a175191e1948a83a28826fd97aea3265e1cc3d35aede6df4a7c49a1f9ba623e3b63e025412c0a507134928617409d7fa3c43691f43640c731566a8cd66c141c731c8a108680aafc431ed9173dfd67aeae43db041ffb93a419bddbf29d336caecfcdc100c2ddaad7b246a30d4bc45a9a5456eb1cfb5be7d97bf0e7677936ee632e2fdd419e8bb2059057bed8495fd51ca63d4a0d791cab5759f0af3724296f9414c747cf2af518481991714c604bdb2d1dcafcee892b461ae72a587ff2ec27e6b71eeb0206c164de2fb806e3dda338ddc4c4e47ced8ac697ecb2f666128770f8cc64efd3b2c25015a9ac1f1ef9e1c70de4b4adee402c5608f6f2435b01174107fc8fe5657b1cb72ce6786162a9c8e012cf9b5a268ecd04e3b9c2ad45fe8b03961f0d38c04788f5dbffed84941a2f5779a9bc14730b5a1def6b07db1ddabd86345dea093c89f1663b14287f5d2051e33a9350bd1f8960aede6ee4a292802bbba1de6e44fdefb5f481d1f3a7e30eeda7abc25056999572a26f6fb24e407b9e6746c2b3c9e155334b8cecf9321e5f6278c926049d2fb49998b3f6023c606c1680a25b66794cb01641e7b1ca04e46091cf2cb973901c5ab78c2b829c01d344f342983d732bdb116cfe3e1ac1dcda530c72557747a398bf9706468be0cab39742f140d7e9617589a8b06e8b054e13ad4d9e37969529b06ca8f39e95215803334f47330a56c22415ba0bc88166340a2223f845e74364f2f04c72d87d3cb8ad3521e7820e159ac57abe2825db36575b5c956b0ddf58a035abb2bd4adf8cce7e42025a11a913d1ebd5d394856a9d730ea7c3a7a4591ddefa96e2f800dc77a4252c05ab49e9b5de086064598a3f51fdd70737d55719dd42713162bc0b49fd8510a6f2e36fe0b0e13e51be8910b8376e35d16a7d8db9ac77a4eee4a10caf5575029e3467f8f53f1c326da0c5eb8aa9a75d1c82926480963c3f1901962aa627fbe87c5aa30412a1ddb29ac5a7eed4bab561fa9cd7f534ddfc314fa686f90b904acb6f57f8d929366c60adf3469fa2b5f6b904998da562bca00c1da07495601d47502716fc52e02aafc545f942224b93cb2ebf24540a54ae2a80735810ec8dbf05889597a3ce5e0fc8fa96a2426fdddae558448d61f5277922f903e55570539ee1d0bb5d9e500780d132e104e90604f6d7b9cfbd7cdc473118831e71633a7c89aeec27f4961b0e81aac132483fdddfbca8eb9b9d67c4cb52dc0e86664d894aad0613535b6ebb814b137398c8c859a42ff6803e20c37a6e3f003033d54e17931775acf30e8ee1ab62efb5aa3a48911c71e52e07b6a0bf5f9519a59f64c5d828694727f7cbdd707301217fed18ca7a6cbd21367d59db2542834449a17eb68fc77e6f4f575094d07a5e93ba57f1f007fb284cb963b7f5016c41b8794782fec8291177eed7aff6eb15797947b4f0686b8802649f09b23896730c2714fdfe414664a277d1cf99e5df0560b5e7d51af47f05be278bffe3e29c873c6a268bb4d383fd466728b6095a3cd581604492df1b1d593d6ed13efcbd7be215fd25697a683166fa8338409f90504d53d21e42691935f2c9e6ce18b1d18e8f97eed9e3fa23c4830ae4ce0c33ca0aa6d236931bf0cc244cd2a3a5ae804362b2903fe28d9b038206ff5c6d1d44ec77709d008739c07daba6fc49a8b95cce3dc1edddb769d47afd1ae2b0d159e8bfb9878477fc2f68af228dcb6e81cea74993ffdce9ba882a94423f1c5cfd52d1883c03892b07dd1f546e4717d55f630a404df40fa3ca28e868f977a800da1d9746ca8982f0f264374e3ad57feb8e695b3e17e836196ba75a881dc44d56204bba66f45828b5413fb142a39a05f5da6f1cf314d0d2367076f35561cc0f788fcef3eb0676d29cc5198acebc08b211900755be7417b6ed94f22900eb39c91203f130ec53df6e32dbfef08ec6ac391e19836326f6bd134303966a02741a55d226073146dbf81b85f19858ee6eed67153bdd7a30c117be56125ee94a77a80d7780569f3b93234f9186041665256588b15c40c8cbdd0b42b8162edfd6bb1e7a0b04969f290be67609da367c595481c868b1debc763b22e450bec9195f23f0cc0002e69c4ba4b151e78fa0b29e5e3b2fcee7d751a504a46d1f04c27daa4ef2ad7deb8949836d28538aa34c99d5c7c888efa79f780fa9a87d2835b42202b4acb2e2d72b6b255177803bf4eff4c4e3411a08a796afc08b48cd8a7b2df9b9010fa13f45f3d08e7441c33d1f920215974c14c35cbdca1604c9bc6572ce9409fbc98c4d769dfb71843a79cc4465849bf9cccc6a5f6c581273eb55fd948b6664a22017d426604abb62bd5393e6381e7392c788c3f836efe650beed90cf7768718cc2ef345f04664aa0ac65cb1974ce4080bb29b5e4a5046b6abc10008adf8d2a2a2441c2b59fe5166bdf6dc6a189de335010d434cab43f8d899d507991c6939ae1e7142cf09da351cbcaa7ee69fb71bd7dea1bd716df210eac530f91401be75226658484c304a6f04c975c0b6dd9a6393917d3fc9c8be5f0a2ffe883c8987cb77dac4a99b564e47b833cc15d466fde43b87672b4348581f897a6f867cefa3b7c3617d314388deb355295f75aa5bc7ab2081cf0e6b3ea36bccd4a65fe25d4ebeaf3758343c9ab8349e367aca53e390728e62993ca21ed5476b789412e0b66543f348180664dd3da96cc67a5323fe15420fb31d919c2ac3ab1afa82304bd0f50b865ebf0df5da088220a30f2b88225260f219a4ea34d31c82e99da35780c4460528aafba94561f915ff40274f94fc3df5aced4855d5d1c8989a25b0246efb1d80cf12ff84b504661b9288e091336162a2cd2989f7470771d707e40c18cd31ecf7ff409bf6f735877d6adad2764ae401d0217a36c928ac901ac0a9a606a20f0c7f599796306689d65108a59eb1363cb4eea67b85a69b83298387b8300417d5167463cd1db0c5d6bade9c4d52e0742ae54a864f19efe945b3e1beaafdff547869f336867edd7e9188d1c24c9e511383b358517d213dbd5c52e980992fc18b87cc41ef7e718c0aff35f4566eaf62ea67d71451884754241ffe2e3da9a61b75dca1ef92a934789e5cba7dc1ce2491ada51534ec35b18b6a98e72bc6c8eb0b923ffae6f4001cc6bb228268e7b77409454cf11eb9c53749adfd891c575263f00b7e75de122166aef192dfd6f25e10ceae457a1ea675b76336bfd61642591f47a9da9031e7eefe","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
