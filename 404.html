<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e97357d747fa1cd4c342cc46d8643278bc8445ea4d63038a7d569f3facd40fd59ccdb541700491d557c221498247de06d9df02063f0bd2d031c38557b78e3d8d8048a48db8abf911cdd311c9697ffff884d1505d2c7f19a2acc1d8dddc9b4617be35ca8f5c6994c7d4f66cd8da2c1a3d062200a9de09f146723d4f978b147611843da78e750cf3bbf71a53afec9b1aac75a5fc70fcd549ca3b8b4179adf490cf59513a83585112e66772b5dc61d163c574ca7c3ae1b5f91726e87b602682587e1183fab5b44d3ca351175bc3791814b5b5f70d519d449d05b680b0a9adfbf45093e892e7667e57ad087d840a2c45bd4c6b6d09ef907ae02d14d50a29833dcdd86d35eb39876242cc7500b4cc2e8a3dd4ca63cb183b702439458293c65c10bb6933f51a57190d5bd72dff6efa0f7d8a94437722b166697d859c531747edf4327b88ebf6b31a4175143851077fdcd18e1b6aa6274fa4d26dd2543a61c4125aa216ce59bf60a6320d284e08089a6ad7e4adce37da474cfc4979e98141cf52c0f5ab4a90a2f4d06c7191b05ffff082f4dde1536c6d98ee7233b0330783a39e74c29ee50905a42aa405ee21e1663a02978c0f3fa4dbe842d8b092d41a83f62263c35a332ed1c16c4c5faa0674b14aff02731c289426ac64ca658a7e53af8cfbc53e98b77f62ec6e51a5b7c7da2ec764fa66f2a91770d691e00485fea4f3509e30c1388e56192d2489cf305cbd33ec356ad47dd98470889180aeaecc94ff619fabd7a5cad45316c65a2471deabd6d433366029f511151cc1442206afccbdbc2ade86b4754a49975dca558fe800e30307ba37b5ef1c989f89f301451d07ca90441c044dd067fdea99a360076158fa1093dcc1655178a48435c5967cdc020c02387087090ee403859c8beac5669a005031e45dc8b1bb379f7161efa5e8005f77d954a4d03173ac001643a832309bfcc942bbd856588ca3e043acf5814dc8b244aa4b38c74478679050b1e578a5cf80588894fd7425d5ef57d2eb1bbbd91cfcf5623ca358776a9679eabbb014d776e3a458e9459e4def90fc3e61f99dbb5d246566fc846210b2cbed5b2f39ad862cc47cad63e208ac0595807481cbddca007720d3d2fb01af02acc5eb1d119838801f4eb7708557e39f05ecf2d8d20e12a9f1106c4e69f3d621b5924401a0b47958ca4e6213e990bf09ccf54fb5b24f4a9494058d269a71876026220db8df21fb8e99aa3dafed6e65d093681b9804af919f8928e59a3b4fa2d49f1a370e0af58391a3aed2127bfb2630b1924337257aee1f44110de9f8c982e1e1ef05c05373979e8fea387d89998f4061667f5088bb898f7c5fc1b0e747735a946224eb202a9a243cfec78937251d212e21723c22c08a6889124fbc19083cfbd95ccf2e87d8a9272dd307e0bf9744616d6b28a6a9587bfac600d920d10fde31916c739fc3e5839ea7ec52b308882187ed6535f0fd619ec56093064466755b45605308b7a9d4bc1da95015001d0d722fd4889fd247df6be79ed41a0d8378bb46c2014471489c09df912f53c0cddc74bcd60c17b919248cff3a4615d621be22c2e87af8e215c4a642403f9b70584842d8a4957a21a2f2dddd636c9c0e6ab7672b220a5f6ceec561502ff82256aee943ead8cb15868515afe94d3aca998123bafd31ad7d9e02aa2f2afa4bacf91e41d0ff04f11ba3362bec979529c363e44273cbb9048f7e79aac345eaf0313743667f21ff12a1550c77aedb3f0d01ec8268e49be63412d3b9f297e41fd8b9b3976a14709a926b28491e4dd4b6a3dba05bb4f3ff2d86ee02f28114f6d1635a72d794809d247c6bd76852992385fdce544938f64d0ecf8048a40cc3602a0dd2690ea6aae8085b22b80892c9699a6142ecec29362fb2c2c67a41b3bbd57840a33b7cad818b740900ef087f31f011052198c60e7d1b1ee29ac0e9d9977c2b0d824f47091d818d71cc0820323f64af37592a87e48a2ba41b4b5fe04ff220f89023cddbc3af9798a7a0aea2656f0151e8ca6853b562d32519d448db2ac7374fdfb133baabd8d315589a734785e12acdf25ebf05296fff721f1bfa812d4855f92f2669556c27999585097f6b3d94e15431b4ab59cdd5ac49541247a92ef9826f6e2f553f9f9d68896eb432bab58eeb2dbec96587b141b81a78893db080858a6cdd2ecf4e8c3c0d34f51d9ae45fc8aefc78deb7164fc7944935750a335e4f97a6409eeb223de01677e6bf177d20c3081042119d53af272159906457f826721628e7c785d659a252383256d1e06ad553c8ea24e2e791dd82b8b9f44fe83a4a0e72a23036c74835eb35ccb6a8e8efa16dda41ffe06a4f99c72eb760651abe9cb9da7e42cf45229a665205fa56e399471834364856a8e384d164ce5f05a4ca8f2f3a9defda9664a3a9208a1deb864c9890f59f54735304f35d3a6c28acccedb21946fe264918f73c970a346e81e19d9456f063dadf75f878208f057f42a5b2380b12ec6d68470f5bc687adcaacb5d2277adc3d978a75eba420799f9a0f6b314939ca73c8d8119757615adf58a3af5871019c497770168338db97a56ade8dfd021e98365fafebdb86094499fff7057f8b245c1499d1833d71ffd41c14a1f793e8a47e5c2f38c10856c1a5a9058158f921bae9367357fc349063ca2b37dd03d19f7a2cc6e57e45b3143d9461898fdce20944c7fd87932cf94d4dd8ed72890e5e818b7d1d1f2f9d77c9ba90b501a54d4a9d01cc7f98a583026ce87588c27398b49405901152a60c459d07bf82f1edd93cfe164a2cf910f07782fa4576acfbc9f1c89a08394015ec07a4b481fea32cd909093ae2a88e6898c56ef960fe0c1cccf59aedff813b3b61a10a65f7d8cb9e470c0c6ea113fe55bc5b37a73620c0ff50ab3d31e5641dc4cd5316824bb4e7af886545e76ae509355e4a5c87c9664a73a38019024e21fd3eba16aeaecc05c1ee3ebd051d84be1748aed0974cbcecf109c74acec5a3d36b7322312a4152ab9330c52cb895882a4494425fe4df49c7701f5da9ad717804f41435c5526036c43351b3bf8e153f9c2f6de28b0b96039ed8fdd824fb72f7c26561f1295756d6765a999d44334116f452cdc61b28c325a2b654adde79d231bb2ccacff0464e7648040793898f8e4747cc4e645a794c163b1178a7970067a3dff69e1c03cfc0e78c87096331931ae2934745448cec56628ff116b621be322c562f121839c82c596f0e4ddc1890c93c7effe46ea2fac16f687b10c1c35cfb9302f4e3d79259ef769749e063b7db2567c954405f3b218b68c8e6d19718da87ed7a997de333050acc69901c4d6a774e9e7bf14617125e3431c13452a45a30bda0871c59c5cafac3ce9d934c9c84d93d57fc1094c5f719f4486df9247514b3027d91fca5cb5373a580a2753af6be453db6d01f062a58a4a666a0611af9fb1c963d044959de605edeaf0a3b87dec2fe00d79af661696065b36cfe66ed1eb2deeb4774cfff4a76fde76b23d6268759e6d79248ef834cc8f9e6c01a25b76546e88653c80becfec490c2e6830c6099579d6c32639eba897fc82bc76b99353ab40d1ab6e7dba6ca93d31ebbd431c0a2563eba8e9a330090b05587fbef43f37d56fd182245d3debf77db68706d685a5fd623b7afece889796f6a0e0760316a554c000314bd8a5e5f68441a4b1aad14e819eb5021e48b39f207d0bed7275ddc2397400127404f9678f7c291915955d2c09e92e686d9685eb10059e0fdac9c66db85d3ea5ec33aeaff9c830382bbe841388fb32c1c840cd5d6813cd3224af3fef31f9a113441ac6b016ae6c385760127937f05ac9781407eabe8feda6faa9b31085f571f49d2b280a34284b64728a385f27feb07f4777cea51d299fdae9241608cf96947b8b551f66d3f489b533cf2db498e5432ef7e2d717d84615f861cc476dae4b028dd92a668285b7608ad5be69b628a67bc4d62ce785a990b825a25eeae4312ec1a56b5cdaff380bc86e9fef15215ff9ebff9cd25c7440f328041d95800b608b2cd80ddd6756dd0d6c9ed15b4a9610854c193f36364efff97cfa1a021fc516555c81e6b600cd042992d7cde6ddfbd4a683b460a8d621986038cee77da021fa9d11d93dff47b86ba44fd6abfcab1864d168c0e5711a57c32708c227fb4f6c67a9a6fd51a75bc42909219d4d7136cfb49ab945564401bbb692b649397e555df511ed5198a4061186dc9ae8c75fd5680ff240a2401ce16065e97aa63ccb2adaeede6d8d0f51a70a7a59b0adee708997faed2c25159fc27362dde95fb4bfa04a3e1be1d3752e591852fc9ab9e01ec4b9dbb3d05090153496ef7d1a4b76de099c64a92ffa315f0d264c3a68117734263a0481b720e1c23f1a4e2cc95cc4df84ffe5dd1b2062fe15abf4377980c308a2260f312019a7c7c84047917177b2289892dbab93d5b14c79527ff74ed8075f22322137a7ab15010aa1bcc1a4ed460ca8e1a5944841e73affc97b2d4390288b71009f4095a3405225122974c22820a102476856bb51576f551a684ae4f190ab7e09afe4900c86df1874eee2d0f779c864e65957f2dceded17ad9d249d329f7bfde642264a079b8cec796c6fc0cd018856ff0cba1c46b1f3c6eadb949a10ca7b29fc7da82288faeeb127a8ba3af858c09af038c95a433e196867445493c11f0f8733f38b86c7d5df5c83d2ec324614e1258d3bd8cd1380a0bcaa912c912bb243f68f28f508ac1dded21a2d209cb8c2b8c142b1ec2a5f5d5aa43cec08775312a5fc53d44bd428c56465aa43fd82605714afe0a395dd2fd26b697a673d9bfba1f597dbde699e031187702c227a45964d2be09a1e69a07981592a58d3931511ead029d2d0bba877f07035c3c05c4bda05b46b85f2549f14f27c90118a421f713f9e66a81a70f2521796c566a65e8efceb5982e5651fc0ccdb4e3496d46411d309c310cce86ff388af1c9acf4d69444f0dd05422cfa768d10a5e7f5ed1222b97c5111badd332b01504696d552606a76268a6498b15403c174ca63b0665e81c99210e0077cd95fb545113b80abca51a0785a2b535e3d3bcf7114c1af4a6cc9640f1ba8b76dd60be824714b1863826c4bfa7cc01f4700c6315b5f0267ce501480da91a99f44c948b81fa1c1d7eb1cbf72b67bc1ab0b446e0dda63327e9b34ca149539f54c8366ff9d550cf4976280e68c9d9191a38d4671cd6d93a3cc64e6d4cd3c8534a1e2b8a8d94d18cecd78506e4236606ee9281ac07e82e0df4d9420e6ae2182504426f4ad90f9a39d87a25c9839a9b0ca8b6f61b21baec1c5b93e35bc6d23b2f4f41919602778ab5cfbbd8b451e69675e590d429acd0018617033a40ccfebdab934d66f01db1a459a84f76bcb2bec98d3d498fcc55e6e360108a3f0c34b9a6421382ebfa391579e7545e02b8c13abe3aa95840b92d13d00acd441d205a7679516a4e8c0a4a881cd0945f08778a8f8f7fc49baaffc7b85102c0e640f7517ad70438e5e8e2c3a924b7bfed5143e80605836a67c67f1fa404969729ff6ef14a4b639c80628163df577d38ea7fb21ab7cb9f60588e0baad57d2b7019bf839c83d11292afba8651facd21129e48ca590e37b97c4993d107a6011b347b3b25b3fabf77e172211f4dd1721f47d31b2c6939e825479395fb2c2d5a9b98bd0d0ec91b3a600f8a8dc5f2fd47c822e1b7916af404bf28f5d9cfaa48ee883e01896f34a4c50ab593d45004ad2b67b1253b64f4b38efa6123b0a5df06050fa8baf2e7fa4ccb5d8a2c294747400f14fe042d72bdaf5c09d16f4f77ea8f50177870652cbdab4c676717678d76cee609aa2d64ab5b7048bb9de58ba470f225111d0ab473b835a9ce5f93757a13fa38d89bfc08b2b3e503ea93bee39207ebe140e1c546078cdbea078759e42ee6096cc6f7a2bdc33ad8832e60e7dd91121fd7271216e74057a6bc955dff5ebfe59c1f977692a7a4338effafd5ec8d113c3d8df187ea9b200ad8b5ec2920834803d9d8c5d16f6775b1273fc4b8485675ff889803d3d38d176606d34f2d2c37a32992a589c7e8a9c12f3cd7991ff12b81df8e3163bcb3e37751e4bab87c6feab26b48c0a2887974690bb29fe8ba536a40c50439975c6ae2a00b73fe737f2d88206fca399dd17364d15bb887157e4e855da7b2bc24d1247ef39956e0ceaef31fad7b50b074ece7662728735382e6d400fec0b187a8f594c465b911ad430a7c5b965f19d851e2e66badeb0c0c0fe0d08403a0baeae712b965a27acea51784f532b9bf42592644e04e920ac97e169067d0c8dfe46ca7d2012bdb6adfa5719f4a5887a55e01603db6525548555009ad6740ac84d84a26bd5f324ec9fe98602f7aab5d1a15ebbff48fa4869e24a89fd8bcb2dc130018228ccbeeb1fcb02cbd9a9749d42b9573f409dbf134f4a89cd5ff1ceb54b4513232e713d7393aafc1263ec64c502f3e67f7f9a89ca1a9bf950dc956774ae7f17354b66113e6a8c9de22ada0366975d05fdd9df379a84b13bebc5737ec731d8900f067ff538e322f515b9c8f41070d54935bf598f900b494488b5825a037c4684d1b2ba97974d3437b60d52ea2f459ab35800a762e9a2c52545a2514f4bc7fff974b82a1bbaa3f26cc5695f25c6814e885e4cd476d916c307628e6b70bef2c682e3ce6f5e8ebd9a97ee48773d70c087d04b86fe57e6f4c59000840ffd18811d9815a486bbe18dbf750e3ef3c64cdca70f140b0f1d51eaaea064e162afdfcf5b6d96e343165e13ef208f0ab6118b08674ee47c71ed63bfef641f24664f9d2f5e2d02825720eadd3a287c91bda1e0d4d93cb83126809e9803c8581ba59af9b48d48bdb22cf0578cdd6e8fcb195f39c63fa9445ed5ff746b7b0d9939066cbcdcb99add1bc63e462ce35d8cb6ee21147464e3993cbe0281e7fc17b30db3b5d93ac80a1c92a158ad4da82b3affe907b526d367a25e2a765bfc9ed7ee3746dc6a4b144cc539b180ff8f4d074318c37d723b0e343db6fc795fd8770f599e07579d10ccaca7f02a81fde74f7c85e8b584e7a99c8fe57c79daf13347095945ec5d03d0fd97a278c128f33072126ff5b84cc10ff77226ffebba87388572d463b8da178efec0c6a627ff72680779c07aedef28105c297115875afafd67a5942cd2e9441fa4dda7951e75963f160d71184a5254caa04c197bf0573d2d7907e9a29a78b5f82529da18436af8b060ab1b38841c5c4056e6f2fa912d604d0be56bdbc01a702f6fccfbc5913570ecc616bca1c57fc2b3207542d96951674c0baac5e947276887d87e4d13884b5be7c998f39dea39791658f8dbc8b9e437141addcfba700d80a3e35968dceb8215d3992801185b93ed59a85f2ce2b30e9bfcee2aabbf924359fb5aceaa9e259c720e9aa89fcdbcd3bd50e8dfd6de5b85c42711dccca74d631a5a320ef452ac12aad4e39ccbbd2e8deca145be7dcd9eb8c8a08531284c02cc2d04d50c70a4a2657b8e7d2850d9a8042b007e5ed1009df7ad8d19113d630cd67e55c186951da042768e10398779933087e9b2e4f93aecb68a5e9abc753d08a99ea32b2e4167b24b57c41c5827e9c3dd087aaf3b2613de2319e31e86acf5f2a26eff563d2f64d3015b654e38be97907b9fbcb6d41f37e89a9215ccddadb3b53ebd26def2292adb4ad1438c635994298ea2963ea8a045c16b4ab3f9e3e7393a604741381878e3bf246f9abbb188b9eb8def85b3f76a7c76d2e22b9576078fd785300506986560d42e7449281588d01bc738a3e8a61d009cf486260c6af6cb6f2d45ec2ab3fbbdd1d29f83f07617b974047f36349387ac221e9aadbb92f795e15d9787872d484e738ddd2c40497acd602b44cde1c4f6a11ba81fb1aa5d5b330aa96073d7ae9fbcb084230637d1de2b17bc1cf01f148d6a8e576a8f3c426f0f0ebe7beeb3681ea9e842cfc30dd8bf035d3c3026e4b18bb8cf227983c0b56623fbd288c3b364f6034400f81d4fee2386c53755548247e8fb87c936cb900a81ce1b6633d7b2977ef7cbd2ee5a0c5775b9ce5d179f8148892724b3d70f8e40e0f76bcbc6d9ef11d9f09bb0050c69d18a6c2fbd564826dd60c3181227464fa3c1b0bbf51afd131b328b1955462ba05202e5e4767d8a4675f5ffa0ab82e22b03ee335cdd6c305aef2db8941e80b9b9681b1292229c568c02ec3647b3dd84973def91910e28a5891e235284819dc79c7915071f0e5277c378bb034b1bf61977db16ab9c905b0111a67fa4fc46ed56dad0e331e682004cbdf5857bdfa5876999ee5325ab101fce94743e2cd36be0f477716666afa20d8f3cbd1f8fe26fee1467b35106488772c33d4cf09adfc7d4ecd47868cd51a089c47de402ef3eca5b42123f9e37c89b9bf17df69b4f8413286dc73e77137b8cfe7b892913ff154f30d276ef58455dd4b43667901c27f9d84144f492271bd39cdbb7641980d00656d36b9b3326db79436a7938bea1822bc21dcb59049e7787e65f4e69f595ada619847bd6d3d3e597bd34194f684ed39d26244fdccaa52f3a885c3a5e1b0156f92c103e4cb2499ded214069276ddfa360df639f356ec841579bd570d30b96f7e0cc3ad6f586d90d4a4b61c1e81b6f68a89022c9a1aa5e1fa00d00df1d63298eb7a6bc8dac58657cc501bee391d0a7b19c443e5a74518685bf8e64df1b7e9035c8de114254430d0a46232627ca4f952b6bf281f637c7988d3eaed3f14c86a6ca21b7a91ac0f959e2b743596bf312fcea20d1a9a20c87435a9cc2428cdb3b697880e3cf16fc2a9994020223a0dd5e9a81072f47905ec9bc2e42b7f4562bf2feff78b69ad1d1eb1465e7e2a655f768827e0443e1ddbc62a2aae289a39b6c7a3fc1f4fd483e233f630c3dfe5bdc6934057b308528f3c4d9a706cca0095bc09c5792eec0a7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
