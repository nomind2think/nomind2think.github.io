<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd15f50c67da7a98e82668554a2ad050eeda853a2270d676154d6f48ecc00c914f6f7c5c7087cf9defb5635d8ea86dae2aeb1d1633b2a4af9858ec54285bd7e28002f43d83948238d41290388c6285bc86bf2d962bc6857bdcac2020196044b1160d5a40f7c726a73afa43ea3a684a03a1f3ce497e0bbc9cc18c0452e53227004e671fee3fc2640ddca95a72a7941339de836cfcfb1777b1c3b90b198fb1ff997a80a4ebfabefd79cd598226e9c854fe03d3556118f62105339db00d007bb24c61ca7e7bc8bf2b7391eea36b07858a194d3ec8b69e587c90ffffa34821e22be45352c3d13dfe549ffe089b24f27d146b10f3f10803e6f4df78aa6c59ce92501db4f45d0f5aed8c7e1fe493ba15149aff29485c8c0592115436e3609a0fe3e087cd3e391c7a05286db3f48420fa3b2aec32ebd86d9a34cbc2d3fb8702b3cb7bf30325667a784fd201c09806ed63fddd675221a958be5b9282f15bbc03d029fd435ae367c9161d2167e3ceac72a2d29bb2fb1b87cb2c29812521fb71d4a3ad0e68d0fd6ec39fe3c2b08e40db8bab58585706a5bc076cbee3510aef868840dbb2974dacedb92290cd9771f400a1d67946b851b75658b8035d905c0151742cc899173cd63f2e12df64d7c1571cce99ad609b84138548151a9f1ff5b472a77249bfe2bfe74e3d15978e4eece90eafa59287d5fec62c3901ee005fbf6f85f396307a9722b85ad2bd37c9c40ba3932ad00adc0ded2c0022aef3176f676b3fd76aa154d02f8b739e7f0896812b606d45991c1ed4f36362879b31d23dc34d95603996fc8da56e359b3594dc764b568132dddf10f26eff2354a73d0d4992abffb4b6db75838c8e3c7f48be525012ccc4b28bec6c6e93a1bf8f06e9737f58a900eae3bb0549dbda584c4b049fa68f38beacd10fd178a3adc02ee53bc27e9e4d4a436d2be43c6b1dc1fd9e3db7ac6b1b871d8fe4e5f3ffa59087af3f4be770e0b1af15297ad621084edc9ab6f7ea3d13d3a241aed108484c70a5cb83516321b7cc15ded7b1c2b6ceaf0a69840dffc1f91e16f506c6b8579345e34c7a9bac80d727b2b38008647f80d53bbe73a57f26bec91e541827eb4e0e8ecb6888f9cea5b6636257dc9cd43bdb216134e9aa80251b9bad42f3671d002165d5b9c891627c8a66835170992e4ffde621e7d24f50c48503cefaaa45ca1b6395135b9807e3bba65be2c9bcccb5db5b930eb011ca53368bb749ba6e16279aa01688d90b82b9d3c0a67c69346467a9f12ab4a6b23583d8b0c28d24ae241a3323b820ff988929454b4fb582767c546488f2fb48781eefd0c068ab7d02d38e1535b7c7de0aad5608dc2dc3d2f7a8b101e16da888d9a85c742ee8850f0b078955f6ce8799dfa532460954cbf518b6b44957e3ef9037bcc975905f35a4af00848e6c78a7d94a88c6acac4e2bbb321910c0ae21caa8b55df6863cc3c4f379eb1c84fb73a0bd958b75f64c3f1ba379bbb0a34c5247c753506f3618b9f2bfc7c5a1ef219ca99ca6b1271b33e113a3573ecf16c59ba35e021a42df48b173411f1b5441f515c534b5c04990c0d0e519533ff48b0e41bed4538de09cfd390fcb786ea03995b2cca5d83e9463658d8efc15797e85dfcd856759b1cd697c01c881c12e3c0709caa6c97d0ee4c5fcaba1ea3f536af2fdc6aa5b61d34775819bd74cc0148cd44ca7eadd7ab9bce0de0d29dc798a9f81535120291a0db78d9b6ad0248f0c7eb516dfe8ee6f3d17472f2a5f2aab3e8ce61b7ac96349f369bd407ae2804c51e43d77f55d2196786e549c5ca8ea4c12f5218a85f58e97faa66a152541cb405fad8f21abbb706672b9a16f1dcf463d49f3ff2bbebcb5a517ff679c8fcdf7d233c5fe0de156ca29451e71a57b3bd9b585b4503bf5df84a496642ef3298177b0b5590f90ccdeb0a86b8bff1f310b5ba2b7da95fb16ea15968d6f4cf13f952985f20fa3c09a50fbf32389e76ef46cd8638b092ae323c085ae57667409aeb92e4aa56fa00e7070b8872982769615da6ffb4b2aaaafc1aecab0bfb667a5e9883dcca4e0e612f9e4ca810627eb1302512b72b802e1867ff8e59a9c9d30506240cc98f301d29345776fd3679417f2719fba8e7b4de0b936023a1755ea46b3af2b70838d8fa163c62ee41b79c91c4efdcb1ce7de5ad70f96fc1d509fc8a19c757ae26da6bd364ca7a6eb9c30fcee2cbe776507cb9636ddaf1f63bff22c3882f37178bf93c937346e3e1a3d8c20875304dc48b606146cef3b8d3936538a2c421004ce72f290dffc2dc5f05e6beb3c37f8b371412d09c3c7c7956daec4e26d4a1d1afe8e0f1923dc224042ec003f001f63259933ef0fff8f7bd064c66233a2d40e254a1cd7e5d30bab8b09db2e4be2a4d07cc8a9a6ba4374fcdd1ff319f0802645b98fa55e635483ee2aa15a85ed462cffd74ae413403415e48a5d4b1a45295baa339541d124757aac165470911d513b9f67b7be506761aca06aaa2022fe2e2beafaab544888ea507676f890b1e9d6294fe363bf5f4f871727900f7789f184bc967b4c1530527f80b0ec58637fa51ccce8e6dfb74023252ecc344a076dd49557ff32ca8680206b5f998ffd7e677fa63a770c4289fbdbd350d63986041aa34418e2f634103965c408e9e8a2cd7394de2e817ba11dae2ce83f634f34d62f7a31d6ef2e3d91fa0c22a29ea21f5f5b267b8691849d84484113a372691417bb141b0f6d6a848932df94fc6337e97fd24a6f6a68df8d0f9286b45bb0e81c1dcc22127a6f23c5808a6421c112b154b1223e0da2489222d400789bccff07b48e0ccab7497bd79223ff94601a01f76941886cbc6f6671be72769faedd2a53bf79a3dfedeb51dfb01d70d00395469bed11ccb8c1a5ef18d79e27f35ce362f619572672b6c9f958b6c1cf2ebaffc639a2aec975ad54f306526af040421b0eec2d61d5a6d586a46e478959aa7102bb270292733efca7bf54f08a40fef5ac45f08317e31735e9207dc44cd78b446ce6f2c0569628c3bed432dab796ea275d0261c45827117927d6679f8a1f77473fc6fb996ede59a7c91ec3827dd47ef4c7ef3c3ddc63bfe57e36621ebcb9dcc68fe4907f3170f4216281ff9b1c57845f21d9612bd0935d5819683fe061cf760ba7721b341c7847f531de588117c9aa701ddd887d9a17013e3e595a2030f692f835fad34337b1ab2c504ebf5b5c54d7cb1dc59c41b98f82ef7dbac661148797e43b12d21d8d629fd8f390bb9503e5beb462244b7d3eabb35844c5125122a7fb6929d22c0556d2649164028a72f107396b42eb48bcb4c93b85a9bd608a436072af54210bde6298bbddb0a700b003e100ecc42db00af727a9c1474edd28c5f763e9e3149a7c491d316bfe352550c769754ec77b6aafc9f6513aab5dec338dcad28b35d126b96545e5718acd56980c4d5ca023dd1ab7f8ab0feda29ffa1d8150a49b13842fb4cc4b9e32109c1bf6a7624ba48594fa44ad4cd5e87d7eb003cbf1e5f8a7b9f6a6add0a877bb20d09e403fa4637f4fced8ec36413353bbdbad87a3307fc1725542709c81e034acb1fd9abcf97ff13e3ed592b974c8c8cb43841a8cfe5631c92a42c5a37fa03044555ed841aa7682e92c8c8cf5ac8378d7ff25630509a2a578a07638848521d8c57366eb9dbd20d68c4df756c50302bea56f3d687f063d1290bf9d5ac2389d87e2c6b17b937e3cfb7c1af7258f03a7200d7adc26abb363664e77ba7cfa0f03ba711cfc632eba7ccee6f90236b398040d5f9643f9944986b3a4e84cd66ef5dde54582ef0acdec94a6735100ba8e440596e181ebccdb5950f0597775a32d0843d5f30de6980859f445ae41790166ecf5bf54e9d54cff681a6fcc9642a503585d74e304a1c57d59137ad692e7f9e61176a26c4c1367f2dbc52e49aee1d5e5451bcaee23695145f6001d0ef53bcc1298c69196bf4d9524b4c511137b4f2e6c5fbd4ff6b790e823eafff14cf7c568983681113b6c5de94a68974761aa89765ae525603ce00d9fe4549731b8c8327180f9a5ceb4dd81d27d373672e086130605d87ffed3b8f8b8eda82c68695811f56f9fc54ac4769fec3cd812c18a8696e4abd3612b52616484363d17b86240cb18800ae2918ec3c6f5941e92d4422814f2f1fb665ab19baffa50cf0fef0c6ad1f7c0d561aab1bace4997104a592fd310584e5299073b28f537a3ff660e995ae2c17d51015fdf10546838f0ae7eccd8ab144c1fab78f3c0a5281f850684b59c8993bc38b7e91866c43ca4dc3219803d9c011b7d801e8d159983e01b8cefa3e8128d31be70ce9bf9675862c6b8f11a66f7aaf62155e1f7b3420c5676c7bc4c37603e657966e8109948ea352cb6f7c4edeaa12c61ec8201ca97539fdea24f5dbad83dfdf5ed2acaf32eba64959207cf5bd03cc22638947c470fa0b833206d8b2a09ca87a011b7a33e5a57bbfde2f34f07ca3d7c79892fde44e1654eee3c8b778842e1b09c4cc814f473bd43ac973cd48a519790e9af33d7bc6e0211d825cc80c96621271a1b469f32e546d5f8c5b520d087d837a55c0de791eeca686858f54c0f57438e87c26d7a13143683c1f49b3df8e66f397ea3d589413228241dee0ec8f2522e66a282ec2bf3b3a46a8c1c3482c731388e342a4ae3a08233b85516bc0afac9048dba125bd7f6394686cbc09821e3e8d958cb0a51b855b83823dd3ec70249cfe0de4f5cc65fcbec73bf7ca9779f63cce2146a5a73c3ff6312a1226d23ffa64db0b56f819454f7a26df01e476228bfd115b7e94bb9ad5a377a6ea487dac5d838bdd5aa917a96932dca701b8de43096bf676bfa0b6d5b4a6bcb256e38de10da3c73a705901196d28ed97be2b58445e758a1a49143bebb2838ed6238afc6292a46460a5180430aab5f3e935dbec174ebe29dd689efb357b19073334c79e2f93510bf4e062221609c268faabc4db5c3f6159270cc48f36f5dcfb23ff19be7350720535819acb7bd43e57ffdaaeb04f9b2929123ca63a4a2e84dbbf314b293930dba01a914a8bae314f1626268e7852e738aa262fa2210d23e6b6d854fc32ff7e2e13a13a6c47630a683c08e9c3eafb9fe1252679653d12d5bfe15212d427c5ca93d43ffe43924e1ca61be59dc989ce170347ab55ca6bc163810f20df0ed4356dbbd0e51304aa94ae9e7ec1c70a6f766dc5af4b49fa3e8f149914f9ec5375689c75705c280a9941e05360fde6acffa8e513cf9a8e562b7819bb24ddc4252309db0cac5af07b7398c12536b7e59447ee08ee2f4bd94b213244860341f3015941886bddf08456f2eccde009f6a64c9b3523197888e61d51ae85189bf0fa12b424e0c08e7feb8b8bc1655983caeacd9ed86f3aca94e07ac8f05bd7b03092863bb9e69df076c67fb43e33fbc551622861b42dbcecff01e4aa0bac30f100594f4790de1e643d3b658a2ef30b4b584024b5ab1501c0c8029763a29fd7fa282cce79518f37e1d933ca675dc121168b10a084bb3536e1a0341d3d4690ec2d5a638df271b0589f77c8533baf9e6b8dad0a217c23848654115612f81d1c6f703e9d2c4ebf6b79c4277d7ac7482af76802e02048a14431f7237f9ca075723d6f50797e9d1bb287d3d8072cd074528498897e4828115cd8239bad5affdb156f5c2fa1319f5a7dae74799ebdc7198570a2d921447d29f2b0c094d2c3fc82a42921b2bc675f1a7aedda24e2e43fe8066167972ce3cac012177ecde31a30b909198a32782d2f9b2e0a44a1ec0d21775d59af398e4b8f8df2d8155bcf45a320037870ab94ab941c8123c0ea57c5a1a52f37c8937e9fbaaa829ca14a041f423f9fe4b09efa33955780efb89eb3240769cef1fd7db4672a8e44c65c540a5848ea07b5f821519609c05eb601c21a3a43032634d36b719a611cc840980b6d90b35f4d71db699492f0f45fb00f134c01ef68d933370af62f9042664c5c678b0c8cfb710b2ebc3e9096901032444c5203253ce027024c130bfacdc327ed36f19676c4ac81530a7fe2974fdb0e3963c1f2177d743feb42938a3e205d00063873ddb44587852c3770b6628ce324efbfea8662b427ab250f9b9a1b0b5b409c7256cfb8aee47e0d996c45a5058ee97272a77bac3553c5498caf4846ba99defde222e562d7329e9a1b027ea7db92f44eb5c606b85ef9ec539ff6512596e168fb84cfda2a9daa2dcb1f96ac825b4bf95c06e7bf77500ada4caa3f354190e6e3bff410785b32b2567c5b706354e7ba6a3e7add0f5d3dcc8484186860b67fc895de16579e4545b5819f442cd282d2eb8410e8a7986023ce7a91b991328e3474a7dfd1aa04ff9e41d6f61100446230a4a07b23c65e5c362dec05db395753067c8a1a41846d907b2c08a72943932c22b5f511d7b576e92439492e9d5a5e7064372ec571a366e70354c6eef7a69b7f337d2e8a377c024ab9524a994a91919bedcb521697aad3c70bc1891230019549efcc3804b809a9f5c57fd5b7307538346e0613ed4dba85cc6c88b2be6975709f1481887349517a324d9064781fa518e0af4d1cbbbaa40655f8f907059bcf604bab8016c4bafcd2e24e47daf4ae794f6a527a8f17b04bde26465ac516e9a772d50bac610d0dd86f8a7aac0f519a9862ac38238ab93479ada9c29f0ca6a249fd10a0af43b8940864c5838a7bf157c59e4060b9fa822fa7f26e897adb3c3fa9eae9c9b6b4336a6e0309f299a63320284e0e14dd2596eb093918d7c574978e064f1f89d3e15b1c74f8a71a38e9c4512f3c108a97eea4cc99e9523c6881d0d9bf1b94e88def97a5dec4fd01baa17f5dfd847632c6e62cb965220e54a67374b520abe2982f5a84bb18401e5c2d62a7a22e339b1537972ec23a2236be56a6cbb5fa5f2e9738c2483524179491f720e876e142ada577c0e33cf7200223d0c88b444f2295d6b4b318f5869311f6948648bb9fde7a225c6cc3d84b53cc07c21c340cfff1c5fb0688289f468bf3639dbde5c784499f53656e5cebec84ba208a36b3df67b744e1aaed28df7b03da8d073c08e0f209142417e9ef9e110db44013dc38f2112114bea118a5984e8bc92d7818802461f69834098a57d7d001a901374ac1b48b15752ec5e09a60988818dc0051d2809f3a848a09caf00620cbc3404d1c0b9fbaa0c4797a2f9c554f53ddea5074e682aaf9a025f0ef7b5a2368f306e82b784892db0023ddfc1280095a7ee90088eac9f873c92bfc3dbcdc9f6067fc5ad60e11a97d5ca469efb86861f77fc7dc5c1fa409d1a61f80ce1b29806bba4e250fdded7870d37be7adae4c524260a6ce5fe8d26fe63bf9c53b84d59161f05b59a0a9899b067c2b6b25892d4172cea30393f584ceb7c663356ad9c69fa5a43294158c591d42b2b0ea92660eea584de90e57c9801f4423f7eaaca202dfb8d10397e556cfcd9e9ecad6e20375ea2f1ec0dc60239b094741bc2208d5249ff74bee61b8c7f572eba2081b190be762b0714b9165c259fa106dfb33fa94a3dc8273bf1ce035c0eb32d23c7e4e2c50d351a2bc783c5f8dadf1a553eb6c06267c25ebf62b57c18008a82784c7cd549e179608fc10131bbed2d05054b29f09138717cc1b6f0edcc3c3269e9b87bad3b8570db87cd93637db7f6aaffdc7c8db50700efe2068d495fb14e900334a40c9558481a06747f4a4c37594def705ef80ec5a7b5645907274aec5c989ab7c5008457047996d5e1eb6b14eff23d501e4473585da90a0c8f8f2bf10a986e23c29d1680dc68fdeba55749f3d5f857183196cd6680100cf28236f529d6b74ff48c269b7f8412593b8a75126569d509243bb9cc92576356fc6241b787f08c7be660d93b3e7a23ad52c2f0e82a181b0b416f521f552f8d491f712cfcfc31e716ccd74a18aa97707697f1ab596feb59c9209524a8278538ed602ccb87a1bebfb264718ce3ab05e3f5305878c2e4d9aabe6a60604e90d5377180145367a795946fe421d24db282c9e9314199f6f532ff5625cb60d258cf3ce757a3492dffb6df5ccdbe15069189aa29a55f9d2ce79c84946961b2c91de2d8e9b0a951a1649c58ddbdab6c2a194770f64318b39da4c195d5efc0bc931a789fad1c0979574bdc19fd47a88effe3d0498471ea2bbf2b25e2d49f874755c6c4034dd05dad041cffc3c7b200e0097853f956daaa260ab303e86c011a013a89f38231223f6546d2fa18eb14fb2e50d8cdc1f214405b5ebb30f9e8a4333695b076e209000529c9cd8f56d4655b89034bf0b466cb6d623a2891ff895642b616b2f2db16b7cc49680205209cf2976d5cfcd2024d42ca8ea790f618ae4b8739a9967b6af3bbe7f470412b745f02a2f11bb1182d1873b27d1c2ee665db75bc174ff855f1b47e3d5ee1e326bdc734ec481658d482030aeb8e8498911658b2341443a103a7e3ebab917ce55593d52d8490b24bbf5ca2ab82f86e5a9ee3394e8d5785e5b7648e078914b2dd51221264e29a19b614069c8be8145b69f02f2a91d2cf1ebe3e5dd57b6f055aa5ab9849b8819f61e59e342ed19570a43bd2c9c78460adf871491d21651d448711e4d869ecc27d7d52bfe522407328f36009b8b629a406165e41eade948f8100a4410dcb49fceadc64dddd11e4fae72ed46c29f9ac0075dd07c9b6a661e8fd036c54cf6b491c6814708928e4e779695f186e1b590e150a8fed4bcbf8ba11ae2ab68d000938adce9fff6ce82d75d06353c86bc028401aead5653a25dcbf0ce7b423a9ada148874c3b20bb80ae97d1d4c4c66f45a6e5e203eb60b31b84b79a599a17231777aa06136a30f98e28de4436dbbd59d59285fa0c9f6609fe6738845e85c2839cb66e881b0399d850d462c5930c3d5ee8af8ea910bd058d9645041dc452f85f197e23060e2fd04f2cfd125e181013e215cca3724114d0a560c7f960c14beda5f36588a8f563d1414e7798af12af9da38acccdad6932cb6b22abc19b11555a172cbf760c6933cd98cd61839b6a31624a3625c79dc8863ee53dc775e4f2f5d9ff5a30fb9182fb5e3ea309bf62597c808da5f3312b0c2890be255709ba3612835743f0d7e4b3adbf92372ff747c561471537bb086210bd7261c1f5f6ca0c38ec9f54966b3178aa861715f4080c6fe4db88a0f32eabff8a917673d540b71c773251b360464062b27b1e1c15cb9e6d59587d0ba41035c8da1132695d63980880b8ea65a46ba524d05264ab8d9f6fd4fa8c080c82d13ea11937ad1fddee9bd807d0cf529701f49db2e5ac4fa95c3f771a1abf35ac704ac37c1360ece588e91383b9f78bf72fb27c4cb93b7545de236c92418d24737b6496b0cec5ad0e07a524d15c2c8fb4d1ffecddbd5c01ff697aef05eb00b266d1be82e579313299afd2518933a4b6ecc5e9bef30dc669e1ec4fb4a2d39f2eb14201497e129e75a1bd606e7cda452ec80d55eff7d2230dae0d40ae5529cf163354b15bd3df4c332cc79c2c4c89d28f16067e6562d2f28287e33ebb86f7870dd6814ca2edb8f657e194eec4268ca521f197137a5d2353bdd7b94a5416d52181a578eaf2509c0527103faf8974fe1b9d54c234ef81b6a59b504467284e000a57f35cde1c8cfc51a7db876df3e52bfc733521b32f2a73bcef47454095c7909d61fa2cc15ccad88897f563340c07f0e9f401582d87f4ef9b6be34f9c1d55bd4e4745d509b13ea7579f97b20383b2205c3fe53a43c17d33ead078f3c3de23f4436c8a79159840680e4c1062a590d51c31406a225a516696490c3098f3960ccc9789d7611d9292464e600c5c140f4a7f683410ca5715a5a28713670cb4518e5c42bee94ac33d9370b154b398d491ad47d31368bbec4e47594c42baff138c75f88e1030a16763ab0bec7ad7fbdc6e0dd7b150a2e70dc18e5e20eef721017c3e61811a81b0d27f5dfca8bcbc8f675ccb99b1a72e63f9a1ea947bc093992215dbe60bdaa3ed79d73b1225f0e9fd3840f29d9c076a7bd27dc9008103c05bc2380e27a0cd5aef96fa67d2a8feb1396e340168d4cf54ef4194d5c159daae02945ef1c03c2b55158eb7e17b70d99bad7c405baff08de23c369d0dff94852bb167f4f45f41cf479c73b9d0edf75bc7b4fa4b474e1981ba8a34d28407e267cc3cb4a7946c12638ff6c5d11a30228acdd4ce3d16a0018025297067a7596234a59a9e1a856510f3da5b108c0cdc38c79ff781d1ac8cf7b9edb4c3eb6db68c54b922e136f10295d7ca8d8f89db14e886c9f2bd3e7d7df3ff65995011eb1d6129779988fb86ec34393ca13579d900f3fb50d7d219113b0cb8712604ea924b0303b4fd3aca05a22a35dad1d1e2bc6f8d654ac120602b38164c0fc6b320a8b0eb1ca954d1e7fc003be392b74b770487104f4029fbbd33ecee483192b800907d9716a3018415265e480f2db82c3e9824dc758cb80d1e9ffdd57cbb0f0d719703841a3515a4242dc30d34ee4ed10fd4bc2ec83a9b3ccadf13c00d235f4fd82ae3b1a0c52c5c43fb006f6bd34de347da7ca77556f1aba4b2b79d061e27b95da8556f30103d40675ca65db0c8a5f9ec2b3b27b2de25fc7282b809cb79e60b4a414b2dfca8318aae6f0c0cf8e49e0d0a6de38ebddb0926ac6caaac81c50bffe546a287d13416c9853bb16446fa7da672833dba661bd6ed793e7cafe7d2336a1d697a286ddbe67b6d9e8b936422ddfd3fb401370b37c80f453a790c8bd7198af116db0a7032de4cd70c7dec6df51bcbab8eb9ed1c4f9e4a3d3afb085b4c4d3a90a7187450a45adbb4a1c44fdb5cfa145dd6dd278d29b94bbc471ee09d04505aec0fe2a2ddf8f7af40adc1e5686c1852944d104d3f5bd59947d63dceec70f139f41436dfbabdad70c1039af9f03555e369c8829220676dfcef0f201d9b1dcaa1d88482ba755e79a83b2604d8bc3c11b7026a13021b5728031fa58e0d4ed9200e5f4e97485a3176e114a74cd81a19dddc3ca07b52f67ed141307d862bdd383f15b77670e480c1e4bc4a83fdc9f5d0ce473babb43c2717d83d697fe9bd4aae3118b35cdf97cc282c7a72eb06e4cd6ccdcacae3919992ca06de32668944b6361d73ad68780d3194012bd4920bb767e02a419e6defb928e07725a0212c70b3bc5049662a404f3eee58ce7510e24d7e8adf42d69f47d05f2bdc5b91b6cead241267432897e055074438e217ce198a10ce0166c18c5a557460f774dc69def78b340245dc7a794a02a86527554bee4015e28369e999a3eb2f0bdc6228751f0fb04e17e6eb4a395755cefb747943802e250bf906806d4b781c9d38b15bffa4365fb4d66f408cdc1d875ec9c0f2b77f452518dd987e77fc89f791b9911801bc6d521a53378df532399d9edd078bfd4d8defd93b4f9f51f195b9e7536fe0d3ecca3346fd7b3b00127b78e3e2df7b39d97d7fbe41c3a70af759fefdec935551ef40792b2c913a87fffba3b7597ca78fae0732c69457b9c6c1978216d57dacc3fa7059b7746a73302884845ece0eefadc26b787e820c6263398bfffe5b985eba5fb78c0cc48ab4679f03f0bfd90e91e54fd0f8b268fb1a094c08f5e6b5d3670a3653f5e25c39787ce25d38d7acae1524e2650b85df684ed70f0aca94bc7168b8ef103adb7c6d66bb34216fe7ef683a84ed6a8b67a22b6b22086e81400b68873c1880a5e8b9af399b4ce42c1914ece6e03ba453c296fb90d3eb566cb710fcf2466349ac71851c0b32a84c522366ac697d7fc82f2479546786ef7b50f1695c79e2a3fe2978443f31afe130a73f28bbf0d82b83839caa4fd30bc2b0ef244665935aaf8d4eb4a166480226148ff14aa08d5e2962b45b9fab72de56961607ce265f137877f0d1898804668544429d7751ed3d8ae3d045d4979a2f4ef3cc9dc0543f05d73a07546dcc5418db1c2a1b8330be6d2439506527137fa139bc9533723c796de5c973645b41586064c8c9c45f289daee9ed2492c8df075ecbf6207ae9aa37df325ff86e2d9b02dd213b8ed80e0c444099d67ede29d9d48c5d08ee036f3190ebf5d149139694083349e48668bcab4d6b445c55f0a5c5c6085b5f5d54f7a46d6e258279ad3fa9c3a8bfaa10bb7d5db94496bc7900d1dc981e8ad80246df564bf3f7361f0df4f4b6c8a9cc1c7289b666a697e83562d25d2a3b0ab3f6e7a72a1e0f78dbc16752e8d2671b99c3d070d199c1ae02ecb3fd4211bf15cbe06c1663f19fb4636d41fc93cebad9be84d3ba1cca9d267605322a3ef33de5f8deb3a50c6fd2944d3ee190905e5ab9fd72663f732cf7a1baa591e76489b02aeb23184d66ef6077edd2d202fcb9bdc28bd69e5f63e2c533344b376cab559fcc1c3e275c1297d4b179c59d3fd96756513830dfe286484ec91b8f936ec53909d07efca6adb5af9c19a824e5335228bb6ef204aed00c281a24f3047da19a986aaead0360af98183f5eb20c67562c6128a9239bd94f74b34730e1d217d51f014b8618fae3d4f0e0de1259ca300ec83d99cfcbadf8187729f6dfd3f6bf08aea4bd28ca8078d5fd5f0a8342de8bcbc8ff59a9458f696f91438e6afd5bac193cc08ffa3df47f7c8d1d17dd1c48df779c0e57de0a111851bbfd8981a5bb3ceec30dbac08ce3b16c1a675bd585a396f4d9edd10dd5113417cf1cfe09472cbcf86a1add440550aa8ed0fa1a73de70ae7f820c4aa832553fb7472b766b2102a53a1339c6ed4106cd5d25d82c7b3837b52cad3c416d20e4b8116f666b8f70a66c23a8648f66798ff048fa38bd655fd2cddb54e3d6d556bf7fa4adab3cc8a26a0e1d62167dd7cf6cca7e6ec1c70f9d3162b85687191e45a8cdb54b0279c771731a9e1679c768fd5d45af9a5ca83eabc59c7b04f53117cf8ae212b03fceac322cdff240081d2f620eedbc892f373fd2bf980a0d2701bda1ce1faf14207a251596b641c08440742455019a02c22de764b85b791969195cbe64dfc7d1775d519fc8ac31035c5ac4831e53cc13a645a2c519b1e69621a250da0874e310dd551247669cb18912500ac4531027b9a03c715262f36d668e0fd555e7fa4004bc499994c9550ec9423ec5ec2800778a292c7d9e225f619cad594accc0f92a71d79cd7c4c24454a0ed4ce0e1849bcb5c9b8f869ce165b5959b20feeb06ae8625929f3a8b27bb34348fbaf09d59b6a12db135ce5bc327c9e794d9ad12618a84d232dd873bcdda947ea372f30700d1bab79ac33f9a982e5afc4aa290e50a58f6c7e0ef258224d81b706b75a318b8818ebfd41c19bee87aaf45a4c06033d6a7fb6de5418cb4acff5a42397ce4a66b4ef5e5aad11caf2f84b3ec0499bf6b8be44454f9128dd9168ed1a1d66b7dc0964aa7afe8e904a8030f0b6bc38e538cc3e5c66fec8fc2a37bceb65f8c9694416a977a75148578b5906bdca1dec4b27c23745707d66170ea569085199d0e6fe339e458113dab09ef76b1ad73f1d3cfd09b4ff4e632656bdbae0c705438df28dfad92e4de2f0a55d9f95474af05f9eca2592441cd9191b20020f156f2030d11378785dceed36f37ef8a27c586cc63d5e6957c8c1915164f8178dfce73c1f7aa4db18f077bf10aba828ae701bf6da62c090e15f7da081a58a2ef9f17ed520f7ddcdfb8c7f45e9c942729eead70ff6cb29aa8b3eaf600f5a33e668b641c974596e353c33903ed4366541e9dbb98a65acc88bd3896cd74aad75c8e4c375181c4315bb356fbcee7f23a47d2fded7238564b69fa2269176de47dcd8f0b76f2ffa0eef5f1d62dd8e0b6fdfe3e1b76db0d1272a78c072a700ed32d8f1e68bac08aa0e7ae691e2a403f2742f513382f4964db8b7b3df37ed8b1bcf5dabd3b58db150f49badd203fee88fc8332eb6f8505f51946336128f243aa54d52b9dee7207f0df781a5e130b6a9509688b450e7abc4b6677b2ade6721fdb5608f5394ab607c79e568cb2b8858a9addd893b5f15f451f0b42145cea5749565fefda46d25bf60ac8e205ab89f056c9dc343c6c713bdfad7b3607e73245b45d77c1fd12bf8f0a0e428050747c412f91f7aff12f803803eacd6ae7697429c342b2ae47070b80ef97466667e9c5738b4603442af59838168dd8527fbaf5eb1e1ef8a11154ce74860d938fe0582dd2b08856a117b1d503e9e8bf0a0fa8ed21febd076c3562b47f40da5d7dabc6a076bdc7af18afa6b303ed0fdbec7dac442d87c34e0a00243089184bf7b08fc06f744fc0e41c558c5b4ae57b41738f39635680d2ffea1da489e8a6c45d095803590bf5d0bb1772a5fe3a54810ab070fff2074bc4c520fc69e4cdff23b5308641655b397a1c83778cdd88c3a9a205ca28cc893321219491e474796c30b5503e5bb56ace882efb22fca48266d81ea8c0fb57bc26d81569282f6245ab04ba9dcf552326d9f6a18b64fa6c9e9c8e44c1f84e876441a0183f6740df149de5ec920a838120d41787c1bf0c65d81aed9059bc9c916c5fa34c6cab5ed7e3b91db16c660dbc4d7c4deedbab272bd083d7e488bc6dde6c9bf3a38f778a3ff79adaf70de55e2467aec3fa3175fa948d06ed324483ca9d3f59b47bfc6c9eea833f4bff76b1eb29ee65f0c3a0e690ac1e420ea68e35cfffaef0a19f5e2e58abe36e22491c1b4e01dddf21d276777aeccb33c8a7ebe45abdcda7c8db017c8623923c672b27d15878b4aede46a057394843d8b1bea6e7f1cba9656fc36f213a598569f7b877a64a418609a5a1414e65aee1df85d5c1368e78cee78f908cbef2af9d7aee2b7f0c1eba870bd9a6329ae45294aec5b45e14901f7c89b025382170c6a16267a87efdda0cd12dc6c24d48de5d2759506a1e7e2e07e0d5b40c6f31ace71b05a12cfbc12c5996456cc3e9b5461b872cef5132e4009468332fd34a21087ebf120ca3a045729f55eb3d4c088638b4f403801a46dbfa1d8af0ff61d325ac2f1c26b948f29a7568f9cb7aea5ea81e2df98bd5fd8dd9c1301e6bb829eba1c3e8745f14b573fda65017b516330d565c7448bcfdd9f2db72d09f087012ff28b3488194c3d7f88013cd63192c2be8915fe08432cb8d3ec45fc77ff9f4e335a21c6c3595d86df0fe16f07eee77830b89ac71aca7414df78424e37aaf7341473480bd40e9925c78a664521f9626eb2ea3f6070541756011275510f0696935102f0258d4111721f60f1bd1c1d66d7950a7f8c8f18948821342921e705e2a8e2238dc6a962ceb503e0c5e427738b1092cd67af752fdbf597e5f1f6ded5d59875b41498037966c7916b2115a8b2db0e7a1eb6c289649c077ea42a5f90d1b76faf47657746747f93753c9294b001a0abd04f5b946c1fc23a47424809a85f5b5d55f76e7223b70fa3cbb4db342d53de2502f97ed35c67661e7126ab52cbb059dd7ab42713a3919a3d40a5e1b7d08d7ed9f6c83b8fd9cd2d59ccb8ead628c755b68eba7d85030c32c625543b6623592e1130726f95887f4092591b4b7c51fec4cfb8e12f635069985fef7a6b6600c598e0211728ac194b82becf256e9a2396d3d66bea02d21e978e8b6443168f429b2e517cebfcfcfa4b16b8aa7b552889a00331b5c9bc2e819fb476d1b0f4df9996fd00c8ef0a84669d3aeb2186a5ff2a65dd56ea46811b7a608f42d70484b451bc43065a9216944a1f3786922453489b56ee5b963d6581d395e97039297044f506498d67d99c12f26fa78f14a73e9bf9f5c68ae34b4c95ed8c3a98b2b556d50ecff364da1dc96c9e972c6a8168d38709182b6f5b4b4059ca2dafac437b9ac6079df7431fd989028f1da2245cec4cef9a4fa7d404b4e00c5bd4092d2b76598ad565457ff5ed7b51885d95a61f4596f54e210cbf5c83a9a370590ca4fc8b2250be3c9344155c95f7499115fc812bc53a4049c8e5a9a052da48b83ffd510635e5e22d4260725c052904056083dc8f9dd2d29e81d18d50ece5019d79a8d28d67d3b8e5c88b8d8fed833a6dbe4c004d69ffc849dc00c45739444283b59d1a5adf5596d719798554a19a9faf03bff4018660948298d316f2c8bbc071e0f85327ac76bbcda4359cfe2907c3912b7d6a7e9798c3ade009735e4ea004a7aab2ab5e2b255770a38c4fa924a57f357a65ca0098104afb700128a7ca29815f8ccc93385558141c777f3c9787bddf12f4def463a4765257c646b31e5fdbb6d26310a2a7b70da2e9cbabd6c88a32914fc54ec0716edb059a029df01547a1d8f9bf3b156c9dec7a97e5b0943676171b6584c046494e29297f68871927221aa844b7391f2a23a04e19a15a878b56b3183fc44dafd164d517628e2e00ba0e6569063a28d8c322650d8d541bf30e369b57852fb18886f44601c0ac68c506be16420e6d14ef45711e0c620752b07cf25dcd429ac5eff9afd9f61629432e3142b0c0c921c025e8b26baf2805fdaabe02aa5cc2c8620b71efe6a70a18ff5e18f7ea7c37c14537706d7c4e2cd326031f6f259c87e927664097772f3471a51b271441155a3345832c87a98cca6491beb3b36dbbd58e002cfeac4deb99f814e8bf39660398ef9be2d813a0a9df1c448600370fb8456bec87767636a55b1e3eb46e92a8c81b97e9dab7bd15d6887a81beabf1e8c7d5fb2d1a16545bab2af2ebee437ca48158e7c54d57527cc775d278bb3b8bca6022cdc1f1012ab4a1fb0c95c21dc3df4c0ca087d431356c5381191e953440d6517f3ed14b533554c9a411f397cb28ad378398b81b7eef3863293ef384f1aabdc71f10c684b8da45f04f498c15d5a3a806eaa8c95a426cd30ecfbc7a6b93a4c700fa0bb7eae0167ce6fec3c2566973479e745885e24fbb8f3d9881b3df4b39682b3166dcbd77a9e3db5245697e5e7969456ea074ca98b629a86f361a65d39280a31f91d590e769fec2e6f1f39d7957b7e06fe29155b9f43f543074549b3156b10bfa183ba345c3bcba092a6400c6e9fc6640bf666e96e5252e00a44ee443db340f7c49cfd04c83a730da4c628203cc5e4c94d5ded3044f64139834db101e2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
