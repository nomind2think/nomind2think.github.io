<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3043fc99c34196b88770c35067bc4012132daaea6ba4355202d3dd6c8791d13a632cac808207f9b66d031334261dc771fd96a65a48c32081a1c0d811c4079e7f3cc23218c9f5e123410983ff8a81236377a611129c1727266871a511cf2a2999c55e2a243aef07a24efa82aa11991826ff4f2a5e3b492c599bcec95f92511f286168d19e370a9f25dd83e8ee6ef775e4841baa521c64358ef148ea2855edfea1b51569c3a62d73026fed75fe4d3d45409d3e583659eb069635f75397579d59147a299fe108d08b111b96f24a07e1aeb40bf8dbdaec6e3e01c9417c6e18fbf8e74621ef5ab2db6358c8ae08c67b31b7d3fff6223b6bcc8eb2a4890c431232d14fa0a77d66c6e3893be25a7d5dfc3aca8dc164ee99d409142a4c9b3faa753caab57f4d3cd8700a038ceda7b5ec56097c981385b809e562812799e63c515f9ffd38191fa3d5271588753756a58ffdab76722c24346685147c4465ae69c0637a99a1651225551d78d5fde2086df99c1b385f42a44d79e430604b915a97324fa9adeb8589b59e5e0d1a1c5e1a7ee49be35097bb40f4b3b87b5a9a7eb170d3d610bab8994acf75debedf21160959755346914679a8b339eb2a7736bd49c9cf6e6e8fabd6f71eeb719c19d0f6f43bcb0054073e082bfc9017ef0c8eeb9fb37c3443e67cc0323ba5873fcb35352a078d24f11e590fabfd39999f6f2309f8e4f98ce3d1ec3445d5581b2a3db3d2200a1f4776cad0f07fc04afd0d54e21b6d8c3cc2ed488b88e553ea1aedfc733d5c6cd0d68e20afde645d2259b6ab0cf03648fa53d67a0dccf78fe60a4c0ccc79c24c4617e76a8f8c2a84f31f76b317a936352e9b3ff392f95259e26b9beecd661565744b95789f2ca90c1a7f0c7cce0570bc8a25a26dfc1ccda1a05857c917c9d993cd1f932e785cd5c6e3cf64917ab4a151244d195bec9673b8b394d178a8112c288332e2812ddcb976a664fb93e2ac53cdc2a3c70d62dd1769fc7d2a84ffbdd8535df5547bd5a804126a51de48771886a4003d8d104fb36f14c3607a9517650b1ad704622ceda62e46c15853921adaa5959e642290202294e10587fd8928e9ab12d31f91fc6486fc23a95b63d2beb20959f339fb709e618e10f6ab03a9416518781c181fdccbb850f61ee4c6a258d4c431835083229cd16852f5f510a30314e9fc0d0bfe97d9f59f911c952a0f9965304bdd5a8bc58225bcbeea055143da48e6f375dd4f30d66f863efa7b161a06c88a6a45c89d31889f00ee8550b0fa77d80cae4d6741c2ec3db0fa962567fd7b3a7fbd008373cb0805cd2673de947107b19f651b63acf3aee9f568603ab6dc664d9427ec6108508f9f56c77644d83e272fc429869f1bc941a14847f379506d44f11390a1f0d56157de8263e924a1edfd5132d0793955c1240ac38ca0ff3f43e8eda9a027ee503b96161732c2f4edba171588b35b2a33042538ffc9f9f221602e87573b090ddee90adb1214ccbfb6a0bf1b4f3b1dfcd687050e31256558f91d375b1008c330ea96e5ab8667fc2f1dc113828ddb9b6d407c65d413c0b4001cf82da1e7b0f3e371e53193db7702a9c90f77eea535142cce2a6b537ea5db6c1e52c04f69bdec16adda189964bb3f15c7881eb291a724251e20e0715fa6898190b046e17a243fff1a359ce6838241e30c31647fd7d4affd23b0a1f9214fc66966618d213790c895f04743a4467423fd27511cea12bead426a734ce7d4c358a6d91a13984422899d8eea070d33757d58bc00120f92caa5276b28e40935c8eb1ca40bd5c3bbcc32064ea89f1b43441ff5bc1dbd9d1e9852efda58d6707f380b24ee174d145f503586a03a2eb2c8e5ac3016ac79ad4b5bfad307788596a1a39c5801df3e645771d33da90db87fed76511a4c3a8e15a9099b9718cb6debd367d3c27d8402fb6e62530f8016828aea025efea2c336da71e4e86c240e1b9140a7c56757e32c561a8a42fe5d2ea8646840e352a54e1929fd3b8d0d7721e05d8ec9370d6c3c7997c568d2607f2371b204205a825b7f1166990d9b12a72ec6a274a0cdffd32f88f91ec82d78c7ad4f9dbae774cd64159f011307ec17e36a2a2e8a52f7091e93797e0287bfeff57273c4dc0b3fd38038c57a836f5010bb9628fbc41db139d28875801dde14f5a56a96ee520e021e4e2599c5c60330ce65ef06632e6384f749b61c93019e3d0bca697e232d25eb55f3624c991390c52c3cd7605d6ea7cfc47224b1e419cb390bb062ca6a3e0073be0b43ba0d85b0ccce12f6831f3292a84e4b899d181e8d5ca67324b74c42b1f45693da788d22481b32c34a654b04df8332568fc77de3cfc92a629225bad7eab6ca08255794d886276f29c99102e9092872bbeec4eedf3ee41c0046fc47c7ef7b6c6db455aad670b29b9f91fa5393ee33cb2bbc154812aee1438269cfd2c9498d6692b10d2b83374fe44ade578020cfcea9e2c0389b408331102cdffc8ff68748cbea16ec55492f233e398768e7e0621ee304332d6d449a6d8987aae6c407a6a906b0abd56e83bc06475d73c45adddab4c055828d1913a4a25f1ba5f49dd5efddf225613001d19fa48f40c5c5dec711e2b941a78bc82938cd470bb5ae434880e8b4b8727ce462e17aa32641956c554143572e5948ff679e487f1ac0999d52e096d1c515c0f2fa82a5cacf3a4f28bc82f20ac1bb07d826655394157c31069228d75700bea4b22a33aa9b001a2d7de8951b0d3760c0a6ae313e5e883c2e8be0509e0970f4a5bbfe51a16338610c05a8cc9598ab55aaf5e31cc64f267451317e4c96a3b3fd28c79f655db8a3301122b94a8518304c106b0c5637b0a6bc0b8ccd533f5bd4a30112743080840fe9ca0365c512abebd70b1d77fac8e17444bb51677b12839b0e9a51242d2a5f3a804b260c046aab2feca2cb37cb614d666cebede57cf8983ce22d333f0d2467633ecd3cc4ee577e4d17b98078587cb2c7d181236018c9ccfd0b9e100a750cc6582d0fad686b096bd2fe41d10749e992a08a2957f8c8094232ec0c63579263b5f7c4b508e9994a7b0a24abac9dbca368146232b2f8aef70a8612c42ffa5e5cd4803db31b8418c8d2cb94a0705eb11313f903921116391b5ac541e86b405a1700585b569d72327a8ae27d1b3aa511cd4a8fbae3f0db856757e05ee905cdc9c879a1d29435b8714fbbc100bef42c7fc8622a6de5b34c952e2bd7b1802d5a5b96764f9e80aee9434c2090426a8af43a19e8c986f29c1a09842991b2db544fcafe40780cf8fb7ade4c8ec7e317317524e0244ceb3ee9260affba537463d6acea9346d1f4aaf5ec564749243f85d969abb5e12a4ee1627e6d5bab3f57d9b7fa936a7bb3fed89fb6c1666e941c12a4ab34be03525b119e6bc53c48fa638b8dc54a2499cb7093ba89490fdad0f8ac43c8490a51395ca0c0dfc56974b70e787f959ef98ff3d80530420026b7f4460492537453c8c0a068fa428bb7cf084b46123af1d4dd31ebfe144669a7b22defcdc3fcafbbfc720aea0cfe4cf9e0f3af810e7453b46350dceb52c90872964ef4eb620f9f3b728dcef43a4ae4e7655daa659b21f19efc60773e22d571173a9e48420c87a1019aeaf4a41ef33502bd48a40f9b8102d9a06c30ed8aa8099319388d4abb1f66cac3c8a373b251b596350eac5336d5328ff828eba493f9ccbb2b532c9a5399020f451d53be49c553ebbea8e6437cb0258ade35af6eb0ffc302b27cf6d5b959d5d95742aaa00e83abae6f7bba448b50714b0a4b503e7bfc31b93ce903ba792ecbbf2a1064e056d91eb467b2091e67577ad54e24800791aff6eaa02845f93e891160902280004324fadc8927c8d1d313edd59cfaf2b2e86cf7739f026dba6f1faedf1f912807ba64573e9bc57b2c0f7f8bea15ec6f3ba986c14b6c441a3e5d005840031a142ab5e6150d89a217934df0df636c753b3a88ab6ce53b2a7a3f16e1a838ff7ae04d0636b5f1e0adbf898524977e0714ecfc71f3d65eecd587c1b2e07bcb11160f4c4b2c73f10298826e1363358f66656d882cc9a2176782f777211b94848a4d6571f4423ce8bfd85b2965b53b70e44be92294f89b18666eb4dfaf8f823fc1f27b443e20b11830a4a9e5c9d921fe37f8e14e0bc548982201c72c942d7bf51da89afb018de4791cdeb3bbb8576f0f579726233e0ed035868ee9d85fdb4cd73b571417e482507f33ad567135346a15539cb9db4d7251bef1ed64117c3ccefa3a2aa13805320fe11e539c36aa13bd8479f05d0fe6f0888f97265538262e0e9c71fcca4061b388f8ddf2010dbce9045f926d02ae2d5b17d7d69886e9e4267cb8aaa8210bc4c3e11199be6dfb4e2c7993b0cb90b7fccb7cae39e0785b9f79246b1fd6f5e8478fb5861a024c4aafdab4ccdf9f2eac67be36680acaa5fefa2bb5d10b4c555106279ccc2ec3a357e4be0a1941ef5678c921fcde880869fae8b4f0fcf0666f567584baffdfaa94168fff44217fbbae5bde0e5213e868e631e0fa876f5c1fd8d4dc0459fa31cc00680662a47f0c25fd0ba79b18f8fe2102db5c75b4309faa4ef067b6c69741fff3905ec0d94805c74e38af647cbe0a4f6e37cd60f37695dbcd6eddfca4c783e090e0757342f1b51fc9793560b509c67accb5958bd22eb4941ab45917b17785d73c030df1d7a6d13ee13fefee216a466eabfce481dcfc8327b06aec859b20091703cc0dc055f17857443417af2fdbf9bf64afd81d8a3d6cb281166cb1c12eab20b31cf4849413675b308aa63a32676fd9c21900576e772924ab6e11a4347f33069a1d59f6991510d8c036fa5f1be9f4a0537702900a0eb18472ab81a9fa842763ebba4c5c8a1dc95c5732356264071a84b7406c02752659a53b4037930cdd6aebfed468691642ed91b6a52ea4473a661c6591af8d26d3b5e86a8a97a490be118e86f4c4bc1a9589f1261a952a19ef5d77ac6731f918c1259b6bcb8363fad858dac6635953dc256760d4b96605b33d12af63b10d89f2336c6a14cc5a27456145268c373de33ae7d8d7326e99d5854f26583adb537b7dbf63584928a5e18c0e7111ef3dd4339a3d6f60d0169cb7d02f73d7c531247013dd86b6c549a458092f4bb76d04db94b0592e7caae81cf69d12815ad34827513b72d0e616bc1e7964eb955fd7da94dea0258ee218e1743375c961bc510a7de52dbfe1d9e05cefc61b87d1043fafb4059ac6e10be0cf0e9d3014ca37fd8d005b4bfda4524b52dc015bd1d382262935c7f97d5208fa38b778fd1bb9848477bbb2c9e64e91cce0206a41c45a0b7237fd55570adaae2f6e6d384c10427d83bc0718681e0c148ff8d39aadb02dc6a521d13432cc7201c904c91dd475d73f2498fb458b39b1625249fea0e6aaae2da7974bb22704ecd6ceba63d3d80b944c7ebfaa5bb36556a980ae4802ce61d7c550e7c34b4cdf2be5fbc1ceee23ff3cd5b2b8173e82d8aebd1d443644d5f8bbce71c1f9278d7db7eb17e45f2613c3c3cf223c04b5d94e88bedc0cb3dcad29638fda2d5f750a45dfcef4fb9f81e73ff919d0fc4a4fab0de1f6e1a2ddc27102ba22b31a136b4486804f1d53691b2d726085b1291fdf0383dd2969b7cec4a03e4ead8964f2ddac49a963a40d29fa4166ab7c407202a4c83eaad1117546c71bc53a827925c3265e6e920bc2a05b7eee471178ccd86ca3326410c15d15dd66db3d0f756e016dc75fa2dd034def7db00dfca5b64e9d672ca68d112f68c8b8fa1cb89d2dd6e26406cdd088b796a4a01d388ca56e7bfda8028996edf361d0a4bf9aa9b9d8ebcfcf4c716ff55accda1d3d41e9b4606f451eb2cc995d49f7c7e0bd9af9918157c9ef229a4127884ee8291b82c8deae88499015fc58d34282f170fe661fd6b1dad8a4145bcd28c4d467793cbaaa16ac49ff04c514433a3d335be369e78f2b7e335c941ca41842d5edbf9762675aeca6e05d4d5efbf50778c820500b0b17aa58087fd0d91235fb4137ea272e36673ff45230c84b13f67b77bb8c8c2622ae16c102044524e292402b1a7b46b2ab206a60ecbd377fe9f34cd81ef5799d323b24d45ec70be458efb04c8f3b637ac8775c5c6648b97f59037ba0f40d94ff74912e2b9b79ddc63031bd0b1d432f181659346d35600cf7461b55e8400a337a9226a0ad43676b5a89f7ca74a8ad5564cb66b249bf45541173e4e456862869f1979ba1d1e1b48d5b7cf5d367560dfd1aaec1b4d558ae72b2a9bfa071dad4594f01545efb989e29445f2c5aa2c44afc858a8948d7a110a63b8a8ec7e57ef06c1c5c3367a784b30b47116024de6ff59d9cd50d7121ed8d5e14b94adaae7f7c2532853789af2f0476e892c5af57db211e5c62c70c3e029a05944e7e90b789cfc28e39754cec7f90333d08cf23b6293bc2e0e42b041d4a9d020ccddc537441f1eea9843953d1e69fddeabad8ef30ec649b89993cc1f36d8cde2770bf449fd29d1535dbf8b39dcab1d52eb4768b61893cb2a77aaafa7c2deae2be5b40043854fcbc0f3c6d4e44423c0e746aea912d41a62009dc05478dcc1d99dd240110ca6bdb5111a891e193ef11fe06a0e00a396ede3ce71c9fb23148e5eaae8002be0ed1187704cbc30cfea8492608a19e5f459398660a14edd742364fb0cbb69a425a07c9ffb4417010ad78deaf376f0f785678cb7ffae955601ece9901bbb543adaa38260cd83e68323d0b273e25e675b2019b80a11d101d9629a966a8f79e2a86e5d22a6e478156ae75b3b5fa040f806208fa249295e17b3e9f857281370e2a796c95c0c93cab2b7aab8a9a9bd15541b1d96ba05a1d8d27ab49b92af8d508f46bdd93597e95cab932c9dbf4005b5f6f72e09ed2ea8b6bf26d7b7dd305085bc180d26c48de039b70a63ff66b41ec98247e72c20e7d7f2699ee2267c863f0128a9ba5e992bb4978d9a50117c589fee556c3f6fa15bed704e0cb6dfac1b065543255bd547e7ca294e0e21ebb3215419b3acd54c9a27ce54428f75b6b241d8fb58ce395f51b2acd91beeb4320f93851fbb023ee628c2a57d3e8ae155aa24363adbbb82b5a17a2912b7415d600edeb3579ca9d4dba584bd7ea6e238918ac8f6ae8bddbec390160a14bd3c10f841c8e3cb8cc07d45d040e5148eb61c9d7e5b59333b17c1beed4778eb04ec94c94ca871f285be46f290b46d37a0e66035058b12b5f92b1b6990938d14b5a337e4f84a57522903f2d55779fce9860b336e4559c886e08c75be069aa2a15387e751d93e1f0bb421efb63c6dfa5adafd9a0774cc9c44db582df705585932c813738debcf4528745632c0008022d349995b24353518ec2fd5f72b9c554003803ed78d8ac40daf1d5da803b1d9ea2d71085870f8f739278b9fcae44bfef3d889317255857a449f746585513f1837c2c4e6b988429d58721a48bb5d00b1afe363196b3757804c81e954884cb4e68b137c36be700bb3453d036eab2d203f523fc71ba295aca0388cc90b7e45eec2bffe6daf4bc1a3988ec38f23cad817e6817a42d5c10b607a52d922f1d31b4374aae074444dd4c7375b5b6f5e8d4fd48ed2a8f6582917f592e1a5d3e01bab4371c384b38e4aabc8b0c15930a5a17f43b581f3f19e053a4f726ec8e864cbd8e7d3939a6b557cadcb33db9938eb7cc06eaf6569f255a0c0c0a7bbaeabee3785ca634302e21f0affbf39e34f41f9e8c251d012ae9464782af9a3244e92307c5ed41cfa0936f31a532feb4ce3b17fe7132308ee0ae777835c45b676c946f466771aae5568b40527697d187f168b6be4f7f3c5b0f04db6f3c4aa19205ec529a32aa28de8bc11a8c08419f7cb67273d9b2385b9cc1beb1d9e5ff65c75194217fc13335194d3510a80b9cc27b574580d756f9d6aba3b8204f9cb8f77d3271633667479e2f139d67515ded1fbe61f5c44c2fe60a045f23da5b474e4a9296de7c2a61442b7a9fb9db14004911f27a2ce20d7ba1dbeb34093982f85ab2bf4cec395da7c3cc634630d7c6782b2c9a6d2d9a2d2022e608db721e74882dd7cc2334abb81f31b757c94f59ebb6f89e41937dee8a4fca3bc9ece47ff50636ff7d32bb9666019af9b0111c4faeada4983d851d77e2f5373ec80a8c77486b272250f183b80212a47d2f433ff5510b948050231a8aed22c0819ffbe11594304cda49deed5d2783f578a86cc3231ac9207a39f7a98e7fae5aa37913c313bd6c96d8b34fa42c23dcc49d0e6e486e6dbdd9a2eeb99716bc8b657d396676ff3821998f74e08eccbee45ae38679ead1a847b6910a7f30239c35c060bb7e9c8a194a79b1aa4157fc5bfbcedc31faa05ca549d3df2a6cffc6dcb9470c37969f07406079d86ff43ce344ab45f982a12aa5ce1b5d19185c56086d02a13cfa4b77ec20bbaca0d1bbfb8c7f27c9199181699c9aaba65352448c984dfbecbe06c49c924ae77c95e3dd25a6f9062b2c97dcfef2eaf066a95c1f6247945aac4229b017904cbdaf676de5a0d1b36593cf27a73e8a4089496e07eb07d946082b810b5cff29cca0e4ef046e89b67857ae279d39e4658513fdc01f308d7054e06200bbb078be59b681cb3e3cc758976082c90ee6a9c765775c360307d3332af5eec689acf638e2c4da6afabd5e08eb962cb3d66d244e30bdba85703083a3764eb8310e5da9fb0d4b58c53e4f75bdacc027806f9a193b95b11eae160f6959fb2882ad2267b0ee2446b31ce044236032bf842e5410925ab32bc64b0ccdb181daa68fc371a3c5931293e1162423c4625179e720911898e2d7d64ed4d090a526ec9a59e4cae73a2981cbbab431ca79e8a3f7e402e6059536823dbf0eb65afb9dee434b136891244df980b3315520c21e38c66eb34285fa04287b43b822195955de43f4cc10d61a509164ba30ab507172ec2eb999a3b416fa05a2b96ac0d47f7c06c202cde0ef05e4bf22183086dca3a62d2ad40284e03160654f03c9b5dedb5cd534a7c6bd5ac9df45d6929422db618a8a6bd028347425978005bbfb423bc2753b6c3f6c286b9d5c9abf7242617c24c9342b52616a67474e5bae498ba35ad2526db01c763ff15fc37fa7979b8852c3b1cae08997c508b53d07b9f67585637cfd8e6742359159a1e6e0e1b8f5e38163f3ff980e90e26a9d598278eaf6cd5b1d4b1a02f163ead02b0195939996efe541b193087f6415194cf3be57e8b4e0b8ccd671d8488ea6dac42d7cb39dd5447f19e4e8d5be37d0c6169b6acea72f5bc9742456a2e5959470e355be2d72544900cf722caa3c63f7ed26c88c706d02997789226248b8cc2f61e82278c05d5f10c5f167c4571acdb3dddc1d0e5929aaff3afaaa1d50f5079d0cd5679b5f0cb7bda9bad293d9d12854f9c3ba9ce93f4c19b62c4f00088ea1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
