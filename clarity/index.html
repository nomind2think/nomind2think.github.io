<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8afcb91c74529dc182fefa76cd9f1f39e0f82cc00e16886369e36b4f51d94be4d2ea9bbf4f5a12231cd51c444a317f331b2a4b8eabb2b875b696cd50c63340245eb758593b30a27ce6e37900f5f2c0f98f08c05731d503313422bb5b006942a9dc9e4f797147bfb8e7961379accdf80d41dace4ed05e74d09ee3a51c9ebb86e6f83e7db60fe1d018f8e238913a22e54fac82246a1f308c8ab3d11c8b41276e7ed91a7b4d55933e47bb6c12dfc69379ea500f6a5f8a728a18a47ef9e13c7f4fc278cda1285f13506c164c2ac471506ea6ce6001d74a8e1bade402a2b68eb7e91fe5d35ee39cb51429c3450d46dd9e68a6f15856abf9e699be1b7bef174b51c40a591c0ed806803217535b57781bac41c5d351b9d0ce0d5c373fa0cda03dd2afc9ddb3cf9b38694b83f091ec4198891aaed7b2f01f79f023c9f6d71504b6da9fd492bef65268844c2d5189f3f5c828efe606f79c2849a332ccf7d7a785ec77d2a9a316a5bb9ef0801171dac290dde0725d300eaca3293ec57f255e7cf23e45dddecc68c2fd3f64d71bcfa1d903d12bdf0bb877b08c763b39bfbb40eef1b8b2e4bedc4d7f8e23e77ba381a96d0bfc788a21288729104d3fab98b7feb0c714eaa8bc1dbb548bb12dbf291f237a4b110b33675696e852ceb77ab72a5d2a9fee9320a009ac1cf5216f904b96fb9792c9d2d1599ef7825d1fa1ddb935fcfed1048f5e9f8581287f061e20a26cf8bca38a8134b6865a002377b4d50c25b3d5e259dc92ed868bdf3482c8390064f13ba40bfba0b81de89e35a09789c63a896e38dba992919c5d3053dde848ed6cf688fbf3ac883a862dec24fde7a65d6baf3a6f483981d13c7740e318fecc63c2434d9a90185e2fd6d186138f5c3560350958dc74ece69f9e1ea6c0a047f52617924365e0e1b19a601932183c2cfc842b6a032eebf1765122d1ec28604621c107949158743c0d7ecaf909bd89c697a66f5fc2f5380685038ef192dac982721ba727edbdefdf26a46f945e5d2eddb07b8f5df6169975575f037453b7f349576e0a7812705b69febc2e40d5c0a9a0fe559edbe7c928501567f269944dbbe71f0d580a69f4e7a577a3bd984ae641fb7cb5802a205e71f5d3bd5e73c2c49099eac88a35a03a1cb8fa58e9c17fcd66ec8d50096a93edcb89dae79fd93ff31691b66bf2a30b51cc07f5748e13053af51ee5d4724df46150d937f1ecf1a96e1599b0d011c45d7e661a07cfaa450fd77aab94a41391ffc9e3611baf435d8487e736b3cb80e5871da620beca0bc796581f7df8e7f71af4f412808cc730adb81c1ec2e1fe7011f70eb7b751fd2f726f7c0294e89d7c319257a89337858940bf4498a244013ce8aeb87302ead78c7595d81ea741d23fb6b057935036de90a949cfbcb72482d37e12e5152090264f3830275ea4c808ac62ce80061633e8d7ac3bb0ad8aca392ab3e6de48ce333739183f90299995ac484964284c080ac08e867e684cbeca1f069efb2205826427ae05cebd7156a2b14ac8557f9e9873eee4d1e68bb0913929b505448a2f1866df66415f3a443331069dd8347c846e6c6e2450e8127be19365c6e8dc6b50e5b4c857be996cc001148fe7b98aecdda2822f4ca6134d7f54b217c389578ffd5254e7de8ee9257c10e3da521d9f97a899104aa27f43dcd9f2541792153122b68cef523a2a40d26df86805b69b402b112496c6547f6c2b7d17b719b91d987677b5ada06a857f7083c2e38daaf179459b70e651c2cb049c6a623adab064ea3a75fc615c6ab8368e99a3ae01e1c1988c5f735257ff526167c027f16ae00623ef86c230fb25f64af91605a76cd7606576b5ea151120f5793c59717b26b9698867ab9f66e3d9005ac29672e446d8048ee30b2722bb0856d975d3db04732ebecb04049a3cf33bb488b3a6c540c9139b529e660641825c3a57a780a6788a3fe5c7ee84622559e4c88f22db6480ff40c8212847b1f9c0dfd64686034c6df2611e24579bd55f859d94ae1d6858a7996b4d5619823d3ddf17a833e4b6be6a9c5ead6ccf0c7f8266befec3ba7e24f7d3a16b768706981696bb4097973ea36f4d313972d28866a06b00e248c3cfc53aff07711529d9e886eafa029db6f0e3c045e7472fdf22ac014e4994434646b4e54ebc67b00186477e0e5186282273cbf4897db9f77dc3be41b4346363685f6b9c398f504bad98bc9ecd1f4bf44fe8e6d0c7f8a111cfa2cf7eee2375a2712495ec79cc30f70252688637c39dc852d766add4e29c08e6f7db26ad474625ba81b0ee3049421c720e1fee0cb988cc0081bbc39750ed3e88499b075209ebb4b85eb6385dec1a93aaebfd5939dd8f50442d43e95f969ac33012f62a1cea4d5934827b063b0211bc2f095833ca4803036ac52d1f38a448e6907f3575c146e9b98125ae00418d7aee6d3008218ad0e73a226e0e37c94a1b0cfffa2e1c8980d9f32c0714c4c8f84ae2e1db9bd7579fa0a16ca1c5bee4f55fc918be82ec6594de1ae0eb83b9c45382bae4367c52e091c86999ec275b28247254de74e77861a8d954495e1ebfc29b64e30a232d5d38db07b7070d0588ac54154f85b957fd334535bc516753cd21768ea7c5acee141a08eabaf51c486fa9e37a4c346c2b9471670affaedd6f8fdad09a0944b475aa55c7150ba500112fe7838f10d98a98b6d638da982b6602ce967d3891d5376c417a8a407912819becb9e9c6ae56c046fdde5d245ddedcd76f80ea9095aa256393dbf07ef040da5367dabf220f1fa1f7ee04113a83217f9d86db6a0e6de6802710a221d0c8c1ad78b2c2b1e6f23500a5ca50fc715afed90040aee4d3da87f21871cd94a7d22dbe66c9542816bb52bedfed367dc553ddabbd82479acf1d929b79a4c01040011a9219bfb526e0eb6be414acb727d5a9f3bde289b76af38c4c1c6bd6feb540e8988c87840e85ae2856bdfcec3bd741fc150d0f3999d560708140aa31a734f4f9b06153f86a3d2844aff24bc9cbc406d6be752badf2eb61f093440aef72c683b59cbc696ce55117e06e2cf2d99e8f06d6b544f985d9bc5640a5986d1b47838bd77a37e2c719acfbf7c5fbc62d07a8a45df7bc9749475980b024e75686bd0098a68ad7d97d54a1d7bd485d334c2ef8680dde1940c23ed5d3905451332ec26368c924fd56fd848ad83985791931b66f25865c7b0870ba5612eb822f4bf032fa40e17280c1914b1312f39ac2be8302c8b410e14e728e792afeb1b9e17bee0a33962f3e1a4d0c0cb56cf14e045e13c2c51cc39c0aeb6e50e62e18bae6c8959975847c4d4f25ff9700d6db95d48f33b08d24b24ea5896c7eb8fa036ff0fbd10cef02fe6836f24c7cb590b8edf2ab0ce9f6db09f39df99902b23da667c4e5b3479b835d9eb07d9fc5342ba1842dee0a1d28304af12ceac4414b235ce9043770cfbe413597912979c0933d491217f63cd98cfd63ce50612ffc879971373fe8e0fcf2bfeb54a658da70e1cf422d0b73fbd2b7940cbaba04cccdcd9b1276aa34270fdb06dae205616c5318b25f7550d20afa0efe18e522e4ca8134e64d8482fbb3e3fb9d13ad761240efdc9e4021efcdd0a2e70a94341575e0b7a68171c6df4c4b2839841c8f34d2fc52b7f4c9240e4877a98b44b35d8949329037c005250231ec5e06d79a2bef376548629730b68c004b5916dd5e5952adf1d7e45b86c19d066572bc0e9c19c8c72f4d6e83363876c7b230e5ff3dbf916b04b428f2bebbe6d4fbc2a6d04ab9e963c4fe3d7bced2f96cd2f960fb78ca48e20754b546f94b35511e1339b970948cda89c0f769c7944190c977a9196ea68d20a738370bd31e9b62e0124e5e2e98831d94f79e54f401eccf848de93978f400d44112d3ea44ea5709f805fefd9a6a76a9d1a8167da65eb17457a06370bc2014863d5b1762382ed20f83081b0223f5d7d02cd9dfb7c12ee85b08fde38ceffa14d9b053c29c64babdbcee5b4b304926ae494da53be1ff8ab617f1357b203321a89066689bb02d890022128793be6752c090839274fccce199edc206857c6dba89e48bce864c673de9764beb0cd77284fc4f6229d1fc7288b03dc26305b30e5ec5dc95eb236ffcc4b0f529d4488b186150ba5f4cb408de4fd845bcb5359c6f252d39ddaea86393b18f9aa5163cef5799ae5a5154d9411e157b9a3219aa3477c13151621fd63e78e62375f841b84a4bca4ebcfc7d724dd70711ef7e2818c0121c42f960534e19c9707fa24ef2e9149ad997aa76cb7957cfe5ad6de2f67ca6de5ad4cb039d80e705593e7516a02862339a85f0d3ed689ceedce365d9454927b0f18bf2b22569ab3a6e8602ec15ff2616f2a6e769788b717c6f6b4fd0edbfab1d87c373e661293c6db49728c8b55637ecf508c2e451a3957ece39cf2cfabf7f4d506e9314a3e21fb2ccd4de46ad21b3b47e150f4889de0086be6d67a3e2dda071d4c1c33f12c5eec81304b942e5d97a44d693aa9ae416d519f87c1a20e2530c8fc84a10e077ce8e8e4d4703936ead940cb30ccd45407bbcf5c9887b71833d025df0203e0ef0e52b2911fd8e450a1c6cb9b3b5aa6a24fb6b8716a314c6c2d2c202c93cd02fcfd0cd14169459d676615e80f37d316b55b4757d9bec70f85d337a43fba3bbeb9142d57b0f42f61826a7c31cedde328974922bececaff00e137e331b50d705170f94bc68fb78c4a366bf036442d353e2d7bfba604311a913e4e0a5e0d9080c6b17a078287f46d01f7d5c8ca8aa6abb0951cec92f2974e6dfb1bafa43b4f03037d4babd7c89356db35dc985da7a96de04bef6a6e9bd9f4ef26414e59d8e4e0c549307f802b8da5fe4ec93af9ead83b43def342a2fa60c6a79ae3cd77eba2256c2ad5b8b16113bdaf0acf7ca14b9e84b3e91a204a1f589581f75a32e9ce9ceec4a73ab4b6b1590a10e7bc857f0db809d9d1b4e2595b7e921b43e537564ca2a63d88ea9c6a3335ca8f6ea5de5ed36b299b59c59cdc98c92ee9d5de43e6ba83ded22e24898ab1bc4ad25ed8dbf6216ef6f2db0452f74051013a5fb13bf598d4b6ef28cb3a53bfd3c7d5e676313d7d3595ae2c1acf7c0b7b5f03a7617c45c3e7ad61fd0e66c4b4052033455b041219c382741198039e263634ccc4c5ef7a3610af9d055872d9ccbd056936345bd95cf19fe34af46b5e8e2aac1d669927fbe7bc7f70334e23f2faab584284ea529eddd606ba5e866c2ec4d6de4013a56e43876a9f331788099707fe4e33a9d9f7ebed6604910e8424571fd452a2fdda2a9a118cc862e1b044fc6b68c4c1c0fd0927b524983b9d7445f422e5659fa1e0762fd2b0e91f6984cc9caadf74db73663a4ee964ae715e5298f5971906911f57941f0d6023ed3d21e15385e48d53bf2031dc308cfbe6f84a9729075c1f3f2f4067ad9552065a49ba892acea28c54fb9d91e2401b79b71a5a75a7c12e37851251853a5d34b18fd063d9df4d844df678a7854f94f7a68fb61332b671e414dd38ee11f92ec9d021e6de3755b4f7162f44ce504ff5050d2e672b35c0291f034275ace89010b8f6438b0f7a84cb67557a9d42a541025719b4d26d781afbc61ba1340b78956aad30ca4567fb2e3e32c6c491b8e3e96d3cabd7a2a62157f0929ac721f9f8d397e4169b9218d7bbcd5f56b97e60ce3d878f9cabc3bf61475263e9aa113cd629924c1e175c48ec3b5334c7f642c6fa8e00f826803e0760b8083b86c34a7c3562b74500642610628f0ed8c4bec8ce597c4b3aa1f89071b8d87049631b8b561394cfab2b1c2539a26ffca6dbc3e8a2266569d38afa7bb353afedb0134cc47eead2c0370e3278beb73326421ada994278d42c4ca5c2ba00a5860c8567a203ae3b134705d40f6db6b313e05866c98559123d3be087309ca7c44426b85c622e49a2733e218aa13b595f4dc4e1b594a71dfb9972e425b0d8815480bc5462cbe9c8ae32f3df17fb306f2726c331cc3298c42ee14648a6605a6847f48a097da322cc25a45fde6e1a984ca54d17c7223efc67c5256623accc23f168af30c79e1ddbb7c00c598f2300b5dbeee2ebd0fd6cacf6db85b919b9aca6460feaa0b244d409dd7d9268c0eee75da528115ce41f87d6e689981056b8afe2a43983d968c03cfeb5752c8630868c99c7fc304f57d8ab1371151c90db3bebc93ca9192e9a5f2f64c3c0f9bd14f0d4acf83ccd81689f04560a493fef672ab2def1cbecbacb05f45b124e79a6a1c698b42028c97198a7a4c7ed3006de4f79d2d33b63ab498195aa1748c4fe985a7f6c235148bef17acd5f7f5ecb16736a96c12b2a85dd6d044db44dd0a5d3081056c83df2ff1919eb4d16d7cfae25f53ae24f89f1904addc89e2b5f2d640fd9e9911356cee95c24de79c3e2f4d19451d031124e5c942fa4fb034dea0fecf9a3ce768684534c1552cd2025e9858befe4210f8e2423b42f961c05718bf8d4ab9912551c3d8b1e419eddcb2d112aae64db5ef3d5cc502bdff4d565a1c2dabb15b24ffb618cf4013118cce92826932a13aa75403f4ce7c86ae116f08f715178654165bb9493a895fba3c0c7b936f7570db07e60fad6082e8060ec5a9491237595b7c79578f9a9d136469e0dba365bfcbfae357e52765126c0d043b5dc9a97ab5667842624c9c8ebe1edeac3b388d0d69d5e96f8a3cbf3abfc830459ab64d0079fb4aaa7c5fd582ca3d126a6ba2258191bd54b25486806193f61dec7f583100d06f92e2fe764d3cdea788fa0cdaeeb0f96d322400d979a5e24ef688232f8fcf3d8205c11f79f6a2a9b5495914f0d7e2da84d9525ec4d1c05784b076eb4c6ba2a6cb43a336281c482d56ccf0a7275eb86f2154c65e2991686c666d1efaa941aa06327f554d0543e3473643a16b541d146127a4c4b417ffe15483dc9a80c3311ff9f42fa1905c19801fef01c600f1c7d0e5d99b032a23ecb99f0e95e5596bcd1c895bf6f65777a4adf2b17930a3025e68aea56d761b4e9ecf00a5390523d67a0d453be696107c7853dbe8f489088be50902be2a883af10cd72d59bc802aeb956e2e5e8ef284dc9ceeaa403607bb287047ed2ed241a694a664e28249c148d6e17d08638130e65ee93cc9a89f20fe59f332480148605f581c2f681c650c69a9fd88a2738804e9d19f341213253eb94005d523301c38619bcdd78acffebf22f7270f071ec2139ad1b0a9220d282f5c64437efe9398e1189e913a17f2a7ebae6f80098dd298341e5e981f8dd766b8627bbbf9944e6fa8b30cdd84a94127e3cca98fa62927b6843211b81c8cf0e0ed5e2acd3220e7748df2bc3b37de68fe0468e13ed315f4ba7cfcd2a8867aca8353e2d4a77cf8feee73faa1a60829bb0007f0b46367f184fae47e64a3f805374765688d3d121b92044d0d308bfc8947b527047f176012aa168f8afe6fcfddb8a6baa93caf40aaa4b26dd11023acf0f6a92152a736d0f59053fede7f75c676d69f4fe2332980758cc9b28dfe503ffd81c3dc91627c6f869bc44ad53da2eee0b1ea8fbeed934504851c3270ae407be0558f08c31308bfbca15955768ba81d5f9bd0d208add3f01cae61f1a97a8e9c201c6c12a48022c91f1db29caee1a40b5c6a8caff11b231f10803a9ef38e32181e71a2514e9790d0493a5c35a40bdfb2ad0ac868b7f9c2e2d632393959c1ef5350dcf6a47333b96a41996d9c01bba1824dbcf09007262fe70e3ea1f89956f648838a15f3b0d62af36ae31cc2c9ba07ce0924ddef9dd3c1c1a500c30ca53ebbb3d25fbdc4a3857b38c5e21d63e06af05d00d6976849a4695c0f31eed3d69fa273ea1efc1a940e694fd4c8cbbbff16922d6a7d6d839a6080c13fff72ad4df4c8bb81871b4a7df78117dd2ddc044b84ac9be5546f42f22d3096bbada262cceba753fdc0971265b191139c2f42b6c5158feb4004a9eb69fee13851d57bbf8dd814e27ab37b40a7af78b50b9b0d58e84121179784b6d402b09b22b4f5b30725690a2adaeaadf649b1e3f6c8bc50a4385b17f7a225afad1bf57c6d5414f80e27a6fed28ca12040efe21296d69bc4c320b17cdf80b980961f292e035078260026d9eed681a99e13771d265eaee6987fe9d7d03eb8072e48aa7f05c877e6ebf8d66796241711e780cfceefbf2047b42961330d9dc72dd0432886163ef249519b9b150ebdf2db63c56e9091266b18ba06ddbc5192ee39928d8a0be2b8c3a7eccde1f209cdb21df96b085cfcc1559d620c2caec572d3d1ec0685b09fdcfb82cc44f2ce363450b740e397fb489a4095c76dd04ac68594c817e73db0a3b4c224a825416c9e9acdf400e3436f7a4583b61bf359c6e25b9298e104f5e1106d2d31e18314110f315d50b28cae4009fc432a7647b5afb3d0af6d6d179345415ba9b6dd2c4d89ba7623377afc9956051fcaea4094e42f8f3e60a38d8af27d5e14b65ec727ac0403795840c84f6cd30aedc2725914b6cb7e3427ff902d58581c9ff18a6c2bbb140726c825e11a435c060e4b065ed725078d550a751046048523e86c44f60180966356dbe8bcd83d3df9f365bf930f1d3ffd1ab98c34f9c125027a24b1f28ed8a4825a95cdba1d6d1410c40f349d397a4e5f0508f3aca0fa99f391e18bbbbd0f58e834a2c5af02302d56114655f164db91afd52f2824a84600878e290714b87993cf2ae8f4bb474b01d931749d4d22f5b26011d6e7362f5dc84d430268c33ff8038903c6b49b79d29090f09c404a214e6cb84e6ac05bf0b906e5ffd312a86b26e5fd155f68884f00eabfa277cb3542ad189e5b188b5b0fc6e898e7a4c48b7e9f92d9d8c7e7b57184108d2777062c9db8671cf2a9053d9c22a89eb3c6bac8f741ff0e8c541075187c290f4546a7fa8ab7bb0fd349515971108fa331c713204a3725d566394006e0b051453dc8457396836ae598a0e12d98a08d3959465bb2d4c633a11299375e3e2b16b2434697aa5f97b8b2f6a9d7d167db5603d6f2fd42384425c718ba1ec9e614324b91c991cf2403f69c46ff8bb542f4cc3723988ced71163082bead9a6f29632eeacd2fe9c44591159e9661da295bd8bb6e699ceaf13bde94abe1050be4ca65645bb8cffd828e4a8edea4e3c24d6ac9c1bad2dd93d50304d443f872d0a22ad8432b91f27730106f989b052a5ac26f33f298f10864fda26c877e4a18c4adb0171e285190382094475843ba2e13e7af3df820","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
