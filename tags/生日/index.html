<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b2c1665e8cc2d0645d20404687b1fa29896dce530fb6f51bc7cd91b1ba75f2104cd163bad08050f0e40cbcc86df3f426590660b999efb8adba4a817384fe1c37a0039ce268582e7900b349f3f10dbbf97d652ff6bf5e6cfb4230be49097cfff11d5dcba8939c2ccd8a0057927acad1ded7f62c2bace815b8f6f8c881745a19208d5c5e2f6aca107a477cd59c6bf68c68212e68313c28a2ca2f3e0d931f67d4e84c0b271909372d3596070d00a4b42acd534b03afe40dadc81671cc5519c55d1c562d7200ab5655ff440201870c038f554b1e0a3e3f9d48dd0b4e781011278b3b4692575fd68ddc54b1dd6a18d44b35a2012c9bf834e776eece2a47010040890c9319961fbdf608e1d0eac87be18a87e855f6c964cedc6c455e5d33a292142a26e4b1af56a2f36d874b6dc814902435d51fb62253167e69d625690c76a2b95c1566b4afb8aebf6bf7b099df051e97ab9d7a918b871e44151f17db0bdaa12c48f97035efdbe44527c20abb014314bc85efba77444d12ec341cf210ec883b131f685d4f611fb21915a7f342e71de74a5d999b2ed469b6327609fa35aecc081c290ac97f804f79709070a0ee38133a14ea20de38936c4a054c98bca0b4dcd6bfb10867bc456a17bde9831811ccbea12b15a85518715806ece299d220704b366312106480d1ae914a811a8ce8b4ec4961fd7e862762e51656bb1e6e2ac64a1a9d5ef577349b10794d0febfde01d43fbf916d16c73f05be8c0ec78de142674835a11d9db545c24657ead8f3c45eab6624fbc2cfb6fed9ac152cb42b25326ce885dbb4b0de3535cf748fb0a7672e14a8953f4cc5e3deea98c20132842abf15d8da0a8cd7464a466e9fd42735d1905d3ebdc2aac9a5ae55b2bcca8b0d655094affb2932af6938c648912e68452b16f2d3cf66892460c96571e93c7ec05282cb89c1a3af1c08f86fe4d3c5669fda6baff4e84ca64e8aa3abad3d7fc242ba589718be0f5f77f6a6cee7f3c8af74fbe7ebf46a111808f4d4bc8c7a3b60bb8da8b64bc83fe4b709a5b206984500a22cd1efb6e57609eb4df5c43f46b3fc61d7ee625cc3f424f79383f545b21ac364d5469f5e571e4864666edf5fb333ca1dcd449be6beb6a9cd0ed2901af3f3632eb98bc86cf8950282928369e6b0e8b0b1bc6d5d577fdcf650e321a8fed30d0ae6f5c48ab285b193b5770866d48c8882dae7a4d02d4adcd773f8295456711191e240d66b3a404bdad1b35cb646b0aa826a7e4b532f36782ed991ac50f7be6fdf2e1c2fd807a7f6f7aa6a4882afd7d62872e9ecac95bd021d62cdfcdefcb423a21d2de8598812fe9f211c3e1384355d04397debb94783fa13632ab8f7f4a7b3685007e1f80e865c6e5d320cb7e0ab898a131e17a5d25bde65dbff14695c82e3e73fe9a18cdf79a02616381bbfed8dfe44b0f1f65afbd21d10f9a6d25aacdc29166eca44c507d73dc0369b3bf5bfe14c9e5efcf92aea9e94b6c0ce1511ebb48e7990b400a4222071285fc20aa8ccaee2609943aeb4f623abd417760e25e7b30b6ae118befd799ae2739acc327c5da7d4b72fd642539cc8e52974c05c421620858e78b39cd205df949bb9ff247379a672d98c90b95b2496f12b79e57c578780b6c248e6a19239e1fa305d34ec63bdfb5b874655108e7bb8105496167482a7a37b8bb857047040b05840cc1914eba08844cd0a845e656786d7364660bd39711c3e82c3651c6ccb7c3a947fb6b04a560c7a5faccb103d97e96af9a130c723df8f643e8b89c761c47767bc1ae16df4b992a8647932e812536e29e553c0c285ee281c1ed44ce9b497843c0fe13bfd81e40885ebde53941dadef9084cfed8dd001f91386a852de180391d642a1a1746d44dcf1b533288ba9bd1b1d084e4f0a705c6befce6eddeec61ee4d8378bbfb601640ce69016f0a7a056fcb6a8b717745874cf5ac45c536231bf35b4586d7ba47e277efebd4d24f6591a28bdbcc4cf77a6780cfe93b02178f2d5f3c31773b66fd8ed2a6df9c605dbf7735a49c7d19e16a0990c618d299c845703006004d24e57495200ad80ff318a42ae438b0dde16a11cbe4f7201bddf00d9275446c1d2a8ffa3dc561166059d325de318a4c62b61e5924402d786d3093cd80e323780191f96824cd2e5784f8f67a4109f68214629c75d239d3296c5a9373578b0c14138cd2e1a730bc8b95c754844cf22c9a54b638d771bcafeac893c83b5b999d967b59f0d9d41a085180ca460c3da891f0385a2af753a335df11a160843d4aab459e0c10105139eec84dbadc62bde21f223a36cffc4ce3bc8acfd32dbcd9472890d5d3bfc9512f83766ffb88f85550e3940c7ed9b30500e91530439213949a88166ee46493dd58a58ad34a7e661b62c7fe0f9ee2e9ff528e9328ae8b0694679095011e9b7352ea64e57e8b5cec267624d4b77cc0230ed3a76dd4d946d3a53e22b8dc571fa70edd41efa6c0380c7d0bcd7b3ec0ae235f1f8dc539ca970ae3914fdb3c05a9d7f8fea8f4299f9e69113c7764d7c9b48757592720d01df1116c9a1c3246609db089a8fffdb19f5aa99014c9ec4af2c7856500f88da1a1636582f719ea9353f9f52ce48741b093a25622f4625bf84a6da04371b29f164a0c3929626007fb9ae2aa7a154c1d78c1bff626f41a8c5eb7c80e8fdd87995ee4beddd0cbcee9cabf34fff950c65cac184d96685396ea710b23368565561f6699d1a70732e0540cd6027d165f4b1ad11f9881db41fa7f5ef10ce82644aaf3cb6e31548785212f96589b18dc3efe26c34b644180cbdcdce5e2ae4e8fc36ef1482d5646cce7fb7f4d64963e550df08ffc53eae24e93640eabed508e6dc897c09aede41ba538c4f282dc25392bcc94bdfb9101f9756c19c9a80964e5c89b71606564f2ef81b5ff21ca619a46b57a7f97f6163b09ffb1eae66fe4e2feed8d740014c67127555c83e1efd2cf84dd0a664c9c2d0f58d8431d18b6f06be188ad253efffd32805b3636ece88cdf7aed570da007f5c50ad1d726f447e3853327fb1201389b304c252829685457c4b757fbb9614cc1fbf0759e06d4861efb11251955f549af36998bfaf62ac6b91a2b21ebbd03f5dfc907f5eca65d1abfddd99fd434571d3cfb598adcdfbdd9fbff210418c578aeb290f8bdd31d3ca2c1df0179102a96f2ac9787f66bcd6211aa3092f30aa2fd749b975ac1957a724cfdc30b846efed4e86b09bbc2695bf216b7569879687d73d6464ad4ae027e1e7e02515cee6c5ef923ebcfe593de31aa309218615b431fc96680dc07a3c604dd80c62a31fe3ab66d5e108f4ed41c3eb990b5adbe0888fddfcabc50923cead220eeabf81d8259e729cdd039c65b1338c798d9442f81da471970b857316d2ded7eec98bbd0eb6a9c50f2bbbeb923518d939b47a9980688e1877c61eda9448c1d3939dd252a386668ddf575498d94eb8324d91b831e29c66d3170bf8a9ac9e251d14d1aba512e628848df7102b1470245deb4631b93c2455e0783a6cabc2a79d24241a406ea13da48c4e33385b00356405f0d9696f3baf993e45d223f6f0d0a67e58abaf19f7786dd5b20ad6bbdd3967d9a251250af31608d400d6f5c189082f730d1d2dc4de0f88cf7773d64daae5e7ffdd09d4325b85faf2686998f0a372ff829571906867549d0572024ee5144b33c3472f75c07f9da7e83a912ec9343538d0024995469bbabb04b32e53717ea1ac5fa628a68b0d85c9a55e511b2db0ea292729b8c89bc23ab573326b79728abed5f07a7128f3d1e0ffc0fc8ef88a5bdaba9cdbdeedbf8daec64766a878506c66f39dd2c3f28d63ee5b7d0387d528fde4f67c4aa3980f20dab3fae0e5c803110f460619dcf9e73a71ba26582265372d1a219020c1ea4401f3386152b6bc2fc8bf381ecb300251767f2b414054227742abf720f980ef4dde976fd3d5c5d5356992af8adfbd6a2dd02c564e6dc89e103889b731ec83dfeed638326b814ec6041ebf2f1add741780b37cf02fd0619b8936bfcd73e247ac1e69f7bee0c574f228f9008295adfbcc439dcb35b9f3fdf215b7efdc6eb60dfb00aa0140cba96e83935391b6281867aca04523901d61adf264085b3a755de9f606a239cd76befdecab4b88d3ea288802c9fa049d7983b214d9b66ddd0078bb4cf65bee83ec51821f5c58717370f5198a11345380fc82dbf50b011ec48110feee7f16591c80d8d6beac7ea8728d74ff79b37baf2d54d5b713a3294ecf0ea202ad92d9bc2db5ec31a09b1aa03a65d5dd854afe8729e7100bb9a6e192db2efc791bd3c03a2c012738c41951123025c5a520cf7d00b37b783483ba7572da8ca7757e6fc25e15358f72219aae90fe37ca3c7891a0a922fce36684d153209eb3c25e2f8ec07457af27d90aa1ef46aa836768413e12e749bfad77525e78e60a2074e98b9484c8938c400e897c293d4f3a68c5c5a8aec6205502648d702c9ead379ee782f7185a7a1c33829960adf6cb1d7a2114f12cfeea9f5b50d0489960331578541a3f1165d027a4540f4bd87b22eac458f454def214f7bb3d5ada8c5148326df1ae45c08c93ec7148380bf5eb819a9899b1e58fa7ad9f5237d46760e4aff6b662a2d9d0c81c0d92390660600f024d0c36c3d7c9ceed0213f090433726e21b831107acd2b522deba701fab45c47d1855e95015b3f41a0669eb824ab8b8301352c39af8a7798e6be5bec68005b56ace69cc9a8cfe791539e85d97bf89487f4a28a807c35c81540e2c988d6ff9417acebb0fd280e06d6a6b96c443c90d1b9b14d3b0e92a64ba7d83ccaa361995a15fb8961b95f5775580d6d455ba40663bc74e69d11dd2e525d3ec07fe01348824095796c38059ec820806e45b2a4459258de4c3896cab508c53fafc52049ee9bbdb923f76f7f6896cbad624b987b2f1ff3f0ab323deddc07ecddec553473f092a65cf004d1114fcb4d611e4d3717fb6b19b7614c83fa09c2695eca593ffa1b0b71824bd875eb861d76e43cb58c12d3d2d9e2dfed73c3ecd69dba6e3d4b9bbe913e6babd1f30da2a2f715defc8d66f9731151bc39375e2548fc108ef9874d29fdb3c73d0181c0f66bd7bbd6f0bc37da48c7c9c256fe39c7715f19d68cad49ee8fc79d39bccccb3e1d0195b44e5f9ed14b7a38ec575362dd7313255e7c670375043511294fdfb0489b889671b3b04318ecc80d25c3c89a52510e47844fcf4ee59d807fd77a36014ed9c6be0295b734255c1fd5ae0941ed2575be9d934385c9619397464d918e84e4c3b89dcd8daeec7205b7fd97d605eb51f5b08ec58e3e9d5c96f9ea594e3395d94cda0c254fe6f388af7cb05e4b6598daefc8fef114738258fe116ec2ba216cfc6683eb04ea74f72c3ed99a85da96d5888fa3bf2431ca2d3bbfba88637d786446b3edb43f862415aa13701ed264e15eea950e08c8d1baac0be79c9fcc0d10a3cdddaf56f4ba6427926a015dcff6d9b9e655488c6ad38e2bb5e0cfc630ccdc34d87a1be631f3ac04447df8eb4b65de867fbcf0da122de0bbfea256ddb06cb18dfc1f8ae563c521eb9ae93cac1d2e8859efe6cb426536013c08cf916c23b6498e8eca2c6177d60f4ad708f3f0512049771cde9961eb00766622b57804e78ace22ed12fc23b350886720c757d467300c2a6c90ead5e5f96a31017b4e7122e9561c307c5c50fcfa1d3ef778c6ca94a24fb47de443fb3eefaa05d9fee003ccec23b9593a0408a5a3e09439874eb3facad1f625c5aa9fa9c8b2e26e773366542ab8a477942d0156829034d799a95e9fba7f39259e9d1b4541e1acc0baf61c33783a2f010927dfb49a356e778549fff8dcfecc311a40b0e859c77ae24966a8f1b52585624b9201a2343a371bdc5b8173193aa9f2f2cf7150a7bcbf4b266fcfd8bb0bdc36ca76525a04ccbe772509ab5e88a134bf3fde79a3fdd9832da32c52f05bdf21350325815317dcc6e86106fec2ed6d02ca4bfab419689627ebc6e9928f00b4b6badefecae610f8c3a42cf3a6a755bf94cfd190a0bf0d48738004e90e338ce74608edd7c2f6d33e695cb7e8b189027e44966dc183efc4d70838e134e96fe63bc8456c49347f7702b7ba6c7da468cff9f07045b9bf4598ae1466778edcfd4ccfc50563101277fd460d9aba401fa254ce9ec1a87451795c9fbd8d96e0168fb9eb147d5083ab208974908b6f32628ecc8f12687dd63f8f9c5d214a11861c91547da69cd5bb7a974a0b2c586c9a1bfc160c3a2c5e7c2e322c4cf2672b5a443d08033b0b435f567ce65569557e418f884d234e3e3c3d2579555a2eb93a6180c31a4a8c09509b007c99c9051d399747a9b2ffd11e1d47e783a19bc7f5963845f9380282302ec9c9fe19e068b5bbfb1bffa4e4f866344239c3bc874d1181e958ba7411afc7c5527a6b258254c34f065e49b402b8f304c72bcdb166cb575efb3fcb0ea0b2d1cee8bc3c74248c5833021b24671f3bad5b076b794cce0ae4e047bba2d3b7934ee3150985d26518a2e88442079e0a58417885f329494afc1b788ab7da3e5867b3fbd798ebf1fbad3af55ded8db8f63e5164130ce28ff3d625bffcba4fa34d0ea148a14c054bf68a0aa89e78bc1f64258cc42f59fbbf9fe8ee713e55cda2ac84466913287f2f1fda37a50676310790a19290e5a1249cbc56d4c69848d329ba93da0d5c6483c4336d02e741ed10d78404761bbb5f3a43859814ed75fbff77cb9e6bec55a302183b2601d8e9d0ae53917201cf6f697c4a41ce5d20781663ae79f81857bdae9582e8924a0f50bbb5a34b8ac9c9f410094bb30264487e99694acd39ba343c4f0c81458c009769cd7181c4e9ee192920a8e22074e2b23c872b9742f3b7b8365d341479311cfa39e70683305c724eefb9d8e9615b4710e00cbcfd7e0b7da0f5ff16df84330a505cfc2134c85d9987d5d4e0a714f7a153e50d5096188e8e8f46c7d5e0a5c52cd627f5d67dc8e1c11b2f77dc57b9b6dfab67e93104b245c1c1f897dd48f1fdb70a43df2af7a33afc9260820e041f2117f13cee4c992092b2f5540e4b3914881cabaf9c6f75e054fc510e7cd914f3fea456899bdb2bdd3eb928195420e3ceffd4f312f776a1961aa7f0c60da8953bd0cd28143ede1576b2e63384d70efae7f908e882f43635d4b29f6a85996dcf88251afc12e9decfbb1f02f19d0b3c9d57c8c168990f8614db5c86f1e655fb70a8bbea7138bf9630d802e418f6e1f580e604389767bef7993b3c171bf767ab1768f40df1822fe16df48bc26b3e7923b111e70a63958fb960bed1f243ecb7ab9ddba93c45065424e04f8279ed892de1f70a91e0e38644b90c4ab47efc75749d05897fde5eff67eefdd32c234ebb1322fe2d93b7db71f7c3780b93becf27c0b9af4e8a137b2b86d7bb64c1f88d2aaf50ad313e063efd6b61ad56c633031ed3663b8fcd1288c88b3dacfac722d558794f5273f4bdd15013a8680d0c2d0f2401c8b624cf032c46d3357fd2f67631938e0e2a4aa515cee4445770f74d75b214bfe33140e41f02884f142304f1083cbf0dc199c04fc148c84cdeeae0b406aac8a6dbf0a353d15dea310b05837ad68bfc9e7f14ca6f00272097b3741f221e62b67cc823b45577b4ec1101be6d540e5ded499b9020b93090351682cee6157e3ed4faa0fa2f78b778214fbee28488a66a2fa76404b20fcb147b435d1ee9579d23a039b58df336b49839795646e1a83a01aecc16c3dc769029dd23b8d2c73598398aeeff2362989337d323af92617c96cc43ea9fd7e7fc63d01f8c7c065fc0b7116557ba471c89cb052c01ad9068ddcd9abae28b296804344be87af1b9cbf07bb9492733bfbda85d501ef1d81ec0932aa7abfdfed46e8973b2ded52165768caf6cd35cff309b262e83b83f6a64d0a590c0d0d524a8495342b2681ba3af735de09ec4b07382d2c92c576fd69847179411bd74cbe4e213c8ed8c56cecb9b5b84afc7c2ba429256cd514cb2a5ded7c9efdcb1fcf88efd4f797fcc6e0e9d26baee53dba160d40c65e31a1c45ab25a3a88ff550f2cf26773dad7058bb002d98f059ed32503d12cee37c333c1e0b561b4781e07fab4edeff561fddbcdd7a161a29e24e0450700ea8d658210d56746ca5cb6ed376dccc700d632d8adfb9871026fcf0e11e321dbfbe73de03b536202089fbb07bdedf28b4b7760ce51efbc39991259cd0eec9d77bbb1bd653f843194844c7357e45eb36acd7767ade9032ff41c9b136e694033053a70103160917970561a6d3f3b1909a5aa4d94ef4ce887d283a67fcaa50fcd7a8a2b8d257e148c1400ee59e5591336bc5926ba4b72d6bac0d7f6a5ff0e783bfc88a33cd3d4eebba311a5284c4d0dfbfb5d6fa56b1bce3eafe6cbee78e907c38251e9770b177cfab4995fc19c8b6cec737d8ab6d90ba277cb284ec6ece2d77dbb1c8fac6b4c7f77c0bf72b0ef4a3752e0ab0616906cc6f9bd99fcc67c7113e98b4abce0a5227eec79db8d0c3982d7c218699fd8b046e55d87fffbc685f7bad61f3cb0a11a9190d3925a920b2e6d2f6cbcd438ea5befa4eba2042f8dfe2aa9a45fbc305c5f5a494c482836803924090659fddd62500d881125fbe2fd8eef4b5427be84144f4e61f42a8bf757d19d8492cfdaf1e64fb268b97870744a684bc3636cc261c845dabec38b92009c475e9a737f5f06308f064503bd4d0fb558b7de464873d73cbd6d31e9615ef00a3dd27b469d63a58c7df2e331ce6e763c34cb59a463a7029af4eb8486a2a70a1600e02203883205495368fe502a8b684c880bc0c435f4a17ca0a2d987aaf6d0825fd8525a8454717e5bd8f516ae4661be66e3e5bd5bf574af4ca8837330bfd181a700b119af1c38a6cca21f7763694f6cd7b96d681e5152a1998d30619e916a2f82d0896326ddd5997db0502a03f0e5ae4862f48dc41c334900a3781aea8e9eda22fffd6e96645530e95e7ce615437bf120e081215eb40e067931a87a0bfc2776f04b7f152cadda3d4b9f3a81695be68f4ab0f4d4e8438d683f69f100a84c2cb17396b4ddb2fef21f2c7e78bc02c389ae3e297872df259ee22d43296faacdb78ccb8cfb019cab7197591f932db8eb8d8ac1b64e6b674876fe75dea88e53a6f70d0d7cf66dde9e0db5992764f61a5f056a0b8787d1367ad56ceca641d230023efd9d5dd0435bc2aa9499d30324019b66a7f7c0248b2de72ab9350f80e1150d4e4c0be9dcf6401d901f2779013cceeea28ed22176c673e12226b322951275a47f80491f6b4d5c6f5b7c10b8f41aba12eccb4c1fc215785fab82e75bcabdf48f348e34a5bc960a0c9d0ab5d3e588177d5920b8ffc6028c704bb00e5ca59aeebcd7d51d19b38ebbbeeac033d3f8694e36a23a2e925bc6bd487a9e3312b8420179102d5e77ea129a65a1252cd7a59b1a228322823527de95abb3f4dda436f9047ab6813fe72050318b076a42751d615a4907809b7d47091f0396e7b2c3772597b14e88c8252f7a7698eb99fb62178974f86942ed65cdc9edfe013f12dff991b0ef056ff021e7bc960797be0dcdd38f7d6f1f011def32c97b5fe96999d266a94db22da1695ff95995666e346d926cd003720353a70efca706218072af5471ef5437253ae91d30a4716683c56037f383037fd1808e44a7946844aecc8e742a925c0ec729db6c579579af24e41abe7a473d738db8d003ef4ee0d7ccf156e12fdfe2903f422e772a930c61b51c989e9bf426aad2a867a733f27148fc75843d206fe39da739536883650f9c4d689fa16ad4e53a0e7ff8911b92ba50ff37cc77370993539d4a87669c9ebebf0be2fc191f623a204bb17aa2d6f1da94107d6a541ddfa87df67f13b9802b24ba6b4cc0041b2fc47356dcc9aa223d570fd9e45bc790a6b9d9d9ffa7025b125e4d49717baf0d6145edd00951b3f9dfef69557c01fdedbb208931678db7366d7d37e09ed09f9f173099935fa53d312fa1f48a2aafb14940b37f17654228ab66cd93e444c86c157f606848cdb4718f97fb4205b1d7f83fcdca8488ad7ba1c3b438f7bac3f22c198d5da0c9d24f004b2252e65d77c8b827a03f465158f1acf5adf357df79fde8d254cb066d9d360d2a0f875678ad82c39a02258650092b2492542e5188f7ea13ac6c79d3342a955b6b2a4978f34d9e1e9ac1700b54f6691659c7cf23450c8bb892b7fefb5e4c78c8aa1bf7d674bf55d466f96dec1cb817e4c99f56360e5b0e4d0becf87174d215d9fd95e1002767ce0b5e7e0f7c9a59aa934ee602ee9d863ba005a7c88910fe60fba42e7c3c576cb6ebfd45cc951d88b8855e2db5a2714e26fd6bc0a65c7c84da1faa2973c3ca136af26b6e4a211a1a7f4a6c62e03001c9fb21f100c53c9a8a7c74a16e81f5a097d22d1b47e5d0efbf0bb11a6f70a334a8ffeecb64d6ac555daade5205f9d1f34358ec8aef8215e15529c91c0bfdedb2e2226c5eb46efd274c86c140335d5404d0fb110121397db2260aadd9bf2f9050a3fbd9cf0e9a2d4905dc7bee85e13340236fb5010e53cef32a918002af92a1d325699e14401c862c06cb750cfb374b006861f8c3b27b56a652a32e5482ddb445d80e12bcf8633f28541348159bc9f7aa2e58fdbfd8601c46241bcd3d5324e266acd72080b518f317ab839dfdbb32ec933a406d68d6c5faa2a00745315b617208d2600346ceb2d836c132bd42482dfd924be8c745ad23aaf6de84fd5dd3447849568a0488e1d39e83ce8ba0e47281810d25c81c693fe0c05a671044dd20e936a0de50ed11aa492cff3740d62be5217f57a411653d130bb3631f7374f619f15a8a9d99e2197ce3888e4704752f77278a62207b411eaa491547c1945d00d22310286e0c4277a96016d8672f1ac1abc3b7386df0974b7f4e3c60595ff0c8d22fbfad1228b0f14acb1b1bdae42ce1710155ba41eb5293ba3f17a764e1ba194eb5efce625090ed7521891c5917c10f066cd2137f223cf4e4e431811fb2028ddec770aeb1f9b5a5ff0af15e40e48b2326f691c98b6c98643d92e74893740589661e9d038b9821896ac3f6f2eab061fc8f364ca9c0690667976b6b5709c76a077d45bd90aeb4ecf4b31399a47b2c0bed0f0d679ba835c6b1720b800e3daf0a8af4b5527764ef6109b8e7abfee97c0cf42ff0b4ccf48b5afbf7c9e974aae2fa1e9e73308dcd20ec2250fe3d78cd900ea6048c23f6c5c4dfa0b981b128eaaaef4f83f736f994d7193cc01179ab92b3b4a86462a09cbd30f1569349d71025ceb91e06cb64e7dd61e138932823cd015d5cdca26e24a1db21b529be50995df9e7d4996f33ed2680fb3ba15da963d3dfb188150f123a271eda846790ebe0f49f4206f8fe113c8879fcd759fa567b8845baa03af0c6d4a74b34a80690539483bca025d6250b4062106580227fa43d6ae8d82a33c3a6d66d408048f49254b306fdb702e9d1eaa2295328dcc75ae9c3e68c7b0aa316b5442529c2a3b61521a55d159a422f57a944a322538f09aff8d084fa3dc16cf4a3e311ed4a19d553bff69d53c118d739b2801191089608a55698e2a3dbc084524c53dc499a0fdd1142d7ef529b78cad26a82104f9fa22bcb68ffa80d869c3906674dc60acee2c8000b46ec9475ac8b8291bba27003ccd3269c56210c092d150251685d97b73b563028b9cc5916ad21297c96d3e317cd8927914509b727d5f7b674dd567b720fc36ef7c01d8c40b28775aa6444663571edec94a9869a89c0855b7782c2df73da044f9564b67cfffdbdc6359d54fb8b951123b4d8861e6377fcea54dbac3f615970c118bbacddf8f8f34e000cf95698cf1a4bb3572f9cc9b677b7571392e0d840e07ad145d68942955c84b168ecc9e1e245c42f9397879b981d5b30b767f417213ac8a0d583e060984db5f578368e3af774de0db0cc224bbef16a7ddbf83ede090ed6231897e479042d0470cf858dcad037ee4c7b840dc0b1f19392fc25d0e03df381f6d24faf61480fbaeff55e8224a8fa5b9e8a6645db49e49b881745c4a6d621901276c42da034f78055320328f04adf6335dacf5a25123f0798fc85d9c4cd25cfc5e6da006b60d519a9d93f6ad98ac28c9583d6ba45639afb61ff5dc05c5bfdd08556b98113da0d018b4f59885fc1018f951b9da5d63abf0414297ad252d065896734c0c6bc424319f4976ca3eb5f61d7d73a403787bfbbecd62d029bbb908f79be8dd9fe489ddc8be671255f10a12b98c3abab91ea70ba14b51604ce9d8a4d498e944103bf7f9b08e938853f257155a832fb61af18eb74ec5909a7891ecc79d6ad6e8eb5d2605c8bdf7b0196b67e2110ca22525088000b928dba46ca2a49e3366919cad9c06a420bdff3f833bab20e567c42eac05381551a73b102fab6ba1c0a6f15bd4f54bc5bdb60ccfe02a1a4e208fcc826e492b95c6566947b1d7fe0c37b96d0f0577730592061c5ce42c1ac49adefe2a1325ca8f48571328e1665b7189c3c7d7066a709f945be8d11ed1f9c4e8bccda99d343602f07f222261711b6906cd5a55c2026841181429a502bd183055c75568ae568f5967512c42289105de3163ce11397ccce88dd822aa1792608f38d3d75be73db8dcc6c7397ea6197cc630e3c5c3cd1d69cecd661516d80508723ac2dd54e6c47de84c1b8a0d4c57bf97be86ae7de27f415b5806c9bdaf848ddb9bfec9538a8882436001a122fffef8c9d84e8ac50068d444ede197357d00b923aab993f477c0fc26fc4e910154ecccd175fbe20d7c8caea8168f172d39e4ba66344339d9047d64a210f3582ed8886c47eec09bb146fcdb32ca9f392509b38f1a104449ce8cb5211dd1eedb700d75b30c73352261591910928bdf6667f49f5bbf44e4f4fc78e777af96fee975262c36ac04e7d09582278471af06f4e8c7668ac4005c7f09e3524f6432ed96bb5ea690a9e5e663fe29f8366be337c336ee74361d4bf2727ef85614f67aacc119d88a441a21721ab78029327bb94de350dbf41121dd96634f402cc7caa2b89682a7f9f53440a4080108df12e7eb8e282fd71c16c6160ee7dbf88343839141cbb794f976368c07c6ccd07f5cb4020433f5653b829cb4c13577779762ae95faf4d0f0c435edabda3c7a726a3faffca56602dab5933a30a1966e0641e9418d18a3599d250579aa88561fb76c9c9e9249d17ee01bf0bce1a61cf25039b6e56e2614704302a960e780ef08219edf93c23a7336cb2cae1d54c2bb70b60edfba6d277f6776182e7e651cf188b5f63b4998125f2c03aecc7c0c3a495d1b3119c55e4bcfd6fe45ba05c15936000204acf9331b08e5720aa4168d6f6a11fa8640d0fa084ec8244fbe2b02fdab79c9aff71e1202c4cf199f361a200beebb9790af46daa841bd67e18889623b8a79f4785ce99090fbcfaa5d0d81f00e09e4909481a7af12b9e9ca14558ef7bd4c36b7ee2de0bb6dc98cb8ef0e750d6f4584d109ed251c2ee6a870712af0d98c3570df83e1e94a094b752cde31bc91effb9bb0eb54f48160da4c2386d2ab407d5d46dd722887b16290e9468017bbff0a4d0abaa9f76ae1bdbae47599559df29136a51e2f2aea4740d110926d84b5117800d069bfead83e5a5ffd75c5c6db7c73226abdd7d77cc10e0bd2c7141488504b75bdac326f502edf7ffc07f4a133745c7ef00443f7cabf2681b68bbed22e67d7e752b6d5a8bd3394916dd2973174040c38cb34aea0ba46a3e6b9030d9b441b53a271ba897806ce8e642c275542f30d573e0077af69f0a476910ad6645feccf094d1becfc19ef2ac4ee4e4de653bc3db2cc76c38efee41f1ce5f0ecd7ac52d4b44e780832d70099a53cc173d3ac77febfec55326a1086fe3ee87f2245939dcd61c73dc099e378c1dfd22676b6db9800b32d06510888c85307f3659c41945fd0e42c5f337d73362901ccf7acd61d22283a57785df2569c251782e89aeb69545bc5216b4c9a25d6f6796bdb4948627e4fb93414af8420b0a9cadb2ec475e87355601662c1f65050cb305d572aa21249b9838c47f9edd0e63753872311df8a2f6e594c4c892385ced5004d300e715f03d5b4cee776f51f4f299bd8e24097f455dd14cdbc2bf6990633fd319557aabf6baf07e995eebaab549765da808fbbebc61a518ab6695be00e31fb3e0fe49482c7035e04619909d81029d6521b6003fc685a0e102a3186fd57ef9785c19609f249e766e2b28dab54169dc38849de2ffa2767190ad93237b55e8c3816799e87c0a660e3c7953e8889523789e414d98223d28f745dd1bf8f512028765e053b6c4edcbaf418496df4c85343bc4c5247be3f2e18e73b177910217caed7434abf9d40e539192e7f5fa1efa2d5d030f038752d02bf2c6ac4e17ec3326b032287cbaa1d8404c4a3ccf8dcb8b0d5967941e2ad2a2276743ee826a6eb8c541fe19b34a82ff6cf63a873f9432b87fe878c8405c7feb5c56468a3e9d8fe8f35b88f3f1e6584ebc9546757bbfa17f4af712359f6c9759daae9f9de6b11f59cbc788c603eea220bb8a584460284dedd448aaffb174897af81e8a27edaf59f7762fbfed8c3170ac350fc54d965040af388acbffd06efe9e2fe1c716d9098df5e5892a970cdd69832b8636f57a8a6cdf7841dd58755ea8e3863bf8cd60900b98faedd78999b9f11ae11a0cc5fff1ad55119ce4eeb17847ca48599e4690f081acc088627e9080eeab5db69390a62fd7f8b26e6a0db912dbee07f10cba7e8c7de00a82a7f79712977652d891fa2b5b1bf0817f193f0fe1ae8188b0a4f6c805cabce47e1a5e3d11cc206323234aa72ebb3afb2c1c89f0ea42bda6cf77b342a13cf80b95a72d93d19ce523f01b052e7747543411542b24298e5fb48e4e1824a6185340cb630a3ade31555a5f4366ebb0ac904179b3f7cf99716cd87d1f16d4f984d5fd02209d40154d414744cf650cf28a2733080d05d088922da71dad1ab9d25e7efa0584bbe0ba282b2ac1c4356cd7d82424a57f437e56c91275f94d82eb21b9838331446bb7fcfb296c679b5cdd35dfeb28f29a085cc847659e6de99dde36ec11eaea88131e94d039099bd2c107764e6a3de2872bcd38da095f3db4683adfe87876f19b5be55ebe6f06ed3e2e93abcb87cb365d6e1ab7b7212544b60bb490db05a39d5add4469b7f3a6e284a8a1b8e11a557827d76a9aa4a871f75b6ca5ef5b27a2af365dc09d1747a15aba50ec18dac5672bc97194f4e53d12a68d95ef66264e3e303a0f07c0be29df0e50bdb2a218d7968550715e0f7122d75216c6f27b2bc4480022699a8df842e5b75f8746dab9aa21c2d7744af8ae2bf88956f29704c8d9145dab6e0434bcddf944ba1982fa09772833bfbdf0ef268de2c696775ff59de190d9bb38fe2b8ab2a83e2e269a5600f28eccdd4b14c76d613ce1dbd7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
