<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81ee245fcf948229291a18539e96eb482d8c4086868eabd5ccd1c717a77c59993db6d154fa568e988d1d31fbc657228e7a93da5ca52a277e26ac90844673a51c319a4b4cbf6400993118d38e8c2cd33a45c0f465e209ed764acd32c2ff001684ccdc33c4a52ee464abdf3ebde1dd2d65aa5ad3faf0018cdfe2d59808e8cbc4aaad2d35a606db884fe04dfec97f2e788c40a9c46d216f654ccd3f97a74e6c4972d4e6bbfc0e5bc1891cee17af49c671ec6ef2f39f38729d9ee3fd9ec91e2eecb74e232f82ffd3b7db647bb6959666ee9dab278c8b96033d602876088a188828bb74231bf6caee08d4592b0105b2a18fc6bd3c549ff7fc6e098ed3477499cb52b903273977e1c5645988200bd613217097e264aeacb3da14c9d02cc7c72a683a689f5a86f897f768a23f0fd94ce205da1acbd64738149d30840301250d72ceba6b71d7e2661745fe2a972c01f0d0dd26bf4594a7b1190c52ff154f70c7fbe028247bdda9b467a96db3a4e2a11e0f2db727bd028f0e6a85c74ec43ef9f6a6565d143bd4f6287a1a22cefbf258d5659d6cb5f06f61acff5d065a095466ee0f205b18fca3d8f4fc3d611e4c0b8731a7f3974302125e0c8a75d128052bc891016e6e53f6889887bdc527f3915744351dc6ff8cc8634e789f730aa8eb7bed4906babeee5436bd23a7e261bd8669256b8c0ec422f23ab72d77d4884ec61951752ce9396016ed3527d67980cd1b953a657fa2cdf417207bad91461f1c26a4c10867609aa81cd595c969b77786dbf6ade7c9aa94c94957d83c8d33eaf2ee3041204f651c493cbac2e663afb23283214dc8fcfaf2a9e964dafe805d5e0f69634baec074acb1ebe31150f1dc20b454ad4bc9355a67a672a636b7b41fe9066efd4d9e86906d8900f1f21ceac4eba523062a7493cac85fafc43a6ee2e480ac7da2e528957f215602a8bd3efe12e5af980af3cf0ec65c386c27aa39ca1dee30bdc9fa126fe0dfcbe31f985e16b90a890da0cbd4f2dcac77436c7be9f447fdef455f7bed734c613424cc44fd2e1ef56fbaca466d8d6a6db5cf073e2de465cea1a0901fa4d2190636fc7672c759d41b97d8768fb353659974261654fbd13e4bf0705f7de592cd4ecaacd72fa243ed292ba70ffc5d5e986d25c96dcc77acb5a2d788a35db589ce73e2485416a5c7d22cd0dfa082b134b479e9e19bdaabadc290072785313e44c38ad6cdc1c162a5e2cf6e536220e5e4e13ee8f3862e6d8af85d36b60f524dcfdfe5f69281a46dfdbb030eb29b584ea18f3da919473b1779af8a8aa93810c59225a82c51c54050b35a1b0d3aaf71290c7702fd427097d33e9e15a14323aeab927c78d7ed769baa22df028a86fa306a245fac44397508104cb6662928849f2d72baad4f08a26d335008aacbe3397b3935426c84bebb6395c0f51ce93a0c09235e422cb96695429e0c6d2ed6a399430d6576596cced8526b2afc5fe3e3fb879d18626559d32ad2c1f03d21537ee94c0009c6a40db2d601c214d4ed19ed7ae999b60eafa65ea05e1802b472dc8ab543533ef7c03a616bc4b79cb66700783db27447c306d3811605a1b2a188a3b96772d78b3dc29d1cc312d6f61338689a75a2d950e96ef479ae62104d67c8e20ab96647b227d125c7799d826de259401d6e1363a2dc919354c8f28b79adc3c3ca05063274f8b16bc9000fb41e9251c6c809796956b8a6eaf47d16f123dd78dfcd0714f032c531a408c8a26e28c3158f22574031024858701ac05f87f619692ac794a8bbcf03720607a8827e9d65328b1708b8f08668573b059d8c512715fb6a5d471963c1919f67a79ff79d3626066441bf21e862693fdfee40c1bd9974988a89bf3994a2e3998896e680387e2e0c2a282d46d25ca076ff104b5ccec0385ab5047d42f03c42bdd9d315245a8475ccb7e8fe478cdb3589834c06e7367a370b1b6f19cd35c44d08dc3d16810af2b243193d8fef8fd4b539e49bea815c21165e0de3a0c123f15a0c414634421e85f894126018ba0e79f7eca357657947def72be1ecc11986f6e1d114cb3b9785be50979d4e423c8a06807c291dd6dd0ab556722c4e72e57bd46807db537db8ff5ceefb7f8f6fca2f52b38ef1d6d2b4d302dbea9e405f2cf3951a5ce0519baf310381351594871a1900ba3dc02c307b35bf16c2aae527076585cbc668d3123c495546881b25efad69e606e7faf21a88ff4d61d13b83d833be65fc3119fedaafa10b0e484d4a45a9a4febe03fbdb7a10530826c8db2df1fcdcf734567460bb28f3050102dc2c1ec5a9f42a67dac91b237d4be622ecc7ba04957f808e506db12ce2ddd4cf0a94cdae8de3c3af524b6bd202b6aabfbc9028ba2145c5c9b3428abfef3cde85ce3662e812d611c77ab3d54085d0a931a71588128ed1004018bc1d7050340a37f198a0f63f3286b2a8bf1876b971f92ca98f2191108ad47ea271fe4ba3fec71d44b5fb131ad56d86fda080a74791609d7e0f4e1c6363ed60679ddb3726b2bf057f192e77119c9e852115cfca77d8840d6e4a838f9c89e3dced0bda3a5355b5e8e0353f81d361e2d7c14f70530e21cd0145d4f06f5a1c8a3fd71ce8959250707f9cacff92467a17bf35e17aae92cf7dec567692e7dc5bd8a3514dc9847c301e0cd42700a0fdf8d72fa02e8e5d0b923dedb5c644e7e8cf7908959eb7c0196e5f51cd307c997614d9cebec620a6ae0687f55e5ff500b6ebefdfeeb6fce2c5b671769a9e960be47b997eb5fa937e52a8601ea3423683bd2e306e1a44c55d675f3879954da191c40284a065dc9bc3499cb5c1008afca859ccca109996d8cd93fc3101b2e2567e65f38c9b3f961e51c52c11a7969d05e2e4083d15ad5e35b8b2370b14aed786771dc51079ace91c76dccfbc383982bab2be6ae99f4e2ece9b54ec23d4c0f49d8f3ad83c3d6df8bd50287c29777c6b7e94fb8093a4999cb7a9478270e8ca0c0ab720218a49b18676988ca4d6bca5f885b8741a588517f36c83a2d4fdfa11088861ba8e06ce33bc629824ae3665ec55253c106fca7765987f0d525c445d9b1caa578185fc0f18998cf2b1530a289300604a29c75e67a65d1d84032d690e028ec90fe1c783b48567b149b842719ca41cab499f4121fda6c12708662df8f82e60db6c7471f7e664adea783ba3f59639878d80b5b66c3e7eacdd38e937cddf1b6c40cecf0df3d38d4cb3d553ca664890c8f74b911c9483d0cfd3f837957d9b8d7e58a41113feebda169cbbc9b5560e089f37c4f414720a198cd8e39b813da7f38542614178f7731a03bd68ba5aac79d3cfe0c0060d02f4610dab8161124546ccb18982a8ba8a676da3f7e592be3b2dd501eddd4a304096a680e7a9ff0b51592089ab22aa3116bfc3fb52a8991c2bf7435600c4c17c33869b18239cfb509a58d3fa4eae9a8396a271d950d0c8e9b00a03a730aeccb47137d6c662803a39549705af9321074627b20b79d0b929453898f332450547280f301fb3d64ffeeec1df57192e8574ab261fdee588f3b5aee32c1fac7228423071142a8c2aa2e89a7523c0a81997633c3df2cc01882ab9e392670fa30d294935f43da96b2548ffcf01224bb9e9a0174044483d4a474a3e515346ec55bec0a9528c296695ddc739d13a29e1e507e0033b71c3db9c09f0d1f68c43778f1f210f213870054797e21dbcf541e8d89957f472f8bef2885dd413bdcdb3b0101e0cfcbd60a035b3dc1507c3b3e70ce7928f965b78f2ea62971c770a955803bea5d0ee76018b079db091304d715f3e89fc2692f575bfe8d10e4c7a67a536f59c51f38dfc781712f6251d2919e922b66d29a06997e2f4a0bc630e8c40c457671c403212a8026998b56323c15d97549a2b5e7d43a603684f78a87731c3cdcaba9842825e77f61cac8786922af22049c79f2047130752eca149179e6f2e979621bec4b7ed8429eed6628576ad6da8802057ff746de6f224773cdfaff41c2a79684d199363fd2dec83539df48c981c2942d1b679664aa6fd570acf304e3afeed7a91635d288fd613d8648ad426c0e9ee10d72b5abcc5be3b0366032e906cd4c4b0c0baec357ea56196b0a9f69ba8190ff7327be794b79d66fc2ca41e99ba2f2f064e759f616488479ec4c4c8e1feac68918d0128c1df65eae514880479540c6393a9e570067916c65e9deba7bf8ced4d35b4f06e78fdec9e88cdcd7b0b83e192079cc15fe42c9462237e7b9d3a6ddd0c6ba4e9cc6f5dfbe3a23b735241dedc0447297344edf00dd41e7479e749eb07bcdcad023dae4394327c6f92a7e8346753226a03fdb6260e0e7da2adbe2cda4e33f3d2fb2814652ab5ff3aa8b1098eb0e0cb41bb2e814da0debdec45ef95a24bb60122ad5fdb15e7c40a9912d71737f926f77a9259795be2bad282de9bb655fd2415d5312c73fe3e0a0ada9a65c85eeb2fe07d5e7a11b24e1f8a0d345107fd3417a765e675fa324ca11259dada1a0114f532e39754edf9f9021e8759ea000ce934fd54c2dfe2d352e33ae3a27ef6cf5624302dfcb6d15a9b03c8a18f821df559c1304f4b24ea31472f14b1f7ac1e16ae286cf42b449334e1fb7d35861981b00daef9cbec1aada76461583368ec9aa353a5d148be7022f95d256ef57ca8423f383ee3c97b58cdae1138ab427cadee02a223157a3179811f89a4b3c8f7c62b772318aead09b5f5b3b8a36b0f05ffb75621b16219b1614a1d925176f9d5a73c27e0a68498a4671d4a1ca261d5570b2065453360edad4493f58de6724181cbdda576d9e118a2f7bcaee7100497afed21a32b11ae7312af75ecf1b9ce7d84053ec396f17cab394eda38f567bce7c514909819fc275ff2454f5f4b8520aa8aaa687c7f9eaf1cbe8d200e317fe14d6b35bcb1cc35d31a327a445b418eaf0c83430d9e96e2778c8b2082c7408d052843bc600be41381d507598542106675398aca0503a7d210a992877f531ca0c0b5d4a531c0d1949523da97fe11fb3df8254bd65e7fda3e08818128af4061dc0f6bd72bf2764d16ea797c8f5c1510490f976df26e0ab7b3beb1a59f8e65c5e1862fedd836f342633da93df7268d4b6bf80c4c93a648ec78c2b24fb954517273382e43ad8b3167fcbf0d2c1906c5a7865ba2e497d85ccc23b7ffe8fe429d5776175daabc72addc85457e23936bf2f61ab150286d0922633372fc03774c8d2aef2d5eb6fd8b855378e8e0d1c71f2bc1e351aab15e1429124492722c9128d6e761ee8820ce1cbae19115077e34e855ac6cc3c21a9b87612ed901f4efe226af7228f070c918e04e5d4f1c4a86b680ccac8bbbfec1c9863dcd57bafa747ab16a0c40037f8666721228260e15fed363c56543220b40b1830f305e0cf1719f7b6ed395c9a93408e934a6301f970ebc8528e30080d7d52dda11ca461e7450d11b55800d21ac339c145b0186ef6c2643ee075e22b41773b8f16d015825ff6ff9a6440e335bc215943279922817a48aecf3572604cd4571965e66bc0228658a908df08f9666f05140cf3ece1d4eac9d4bde1c2e7052b35a2a3a352e94ab4c03a3b984c6f7afea996369df9f23756f781dd18ed0ee63d5c61936613800a3b27d5413bd79ada3f23a814f205e6441bd54e4e1b2dba566cb1b67bd9d6cf3e05889f5245539121bf32837061d2c5b3302741e12f2944b9731a00941d08448ca3c23c635dc8dd37192efbc955a7036eab65873a5cdb72e3d4813648045d11e2a04dbf6fc48ce51e04c5c17d54a5e6da9064f51b1df382630df1db8ce1ee720994541e3c62070f56f456eb736dedd41f19e7d2513cf8627c070077d4719a20211c227df7993b4b0e0cf7d02f41b2771aa43892c82f9509be31c2e200d5ad943eacfda48ccb08f75c0d27eb3f6ab122dcfc5d801d701a9c8cc314e1d4776c2103d16bf7c52de3afe4c877f4b59c52cda290a721543ba97e5b6b2008645b9aab839970a6574c19f35dc9d9fe6933261373e531fc6263e042a3ccc331ebf8dbee9fbb75dc3048ddfeeea94a57c873ff07759bf61d4264a0f8af2eff220ae3bc25bb4f094cad9fe05dffb04e71d97d59d2889b46f41ee458d657e80b2e402466487b3034ab7a3a9970f9ba520fdb1571a03c14ad0f55d592cfdbadd01f30f045f19981e4ba5bfa722c10b5d67d082124b0d16658c86be9ed51ef5818e9a5eba10930eb3a026bf1531791a2a00dc1b5575b47b98b12ba5ef8461249dc4594cabfaa2e5687e60a09ae2d5f8a43bc3425a89a6298870cd745155f13a4859782939504e819463575409ad6c9d099aefd911d631841b09dee64349d8b732b3a3fb53e176e7af6dc1e2f2557dcb1ea2da259ca45ddae302d880f318c64804e6f19e4673c037bfd2fb45ead67fcfa775a4dc9a1f93aac1fbfdb5422938d30b462ebaf8baacf75b0e4c0c5920e608f8a587a085c384a5b8e4d57c6ac277698e80fe7def7bb67ba28264860abddc18a64bd16e5d903c95e3e518e60370a1d67fa6af236dfae7308397164d9e3374293a9968f13f2d56b2fe608a5be78b849d6b5550cf58a316e36f48efb5bb27a7792a2fe9f7bac6416a5bc196e90348fabb6d1bedfc95ba81983bf586fc5b460a3ce5081b1f4753f9f175b10dc44e64d3d49921b5caad15c6cf30b875835f86feb7a710629861e9497754905344c8e5eac1282588f8af56ab802e5de30d237d8370fcd8fdc42ea5e56b4b9181a5f6728c652c909950d18e8216969f862e1f6b5998fcd51faee0830678f21fb9ef0d98aa552521a5a50523eaabf5e0b9458667bdb3420d3d030acc3ef4a3ea61a2932b3d62b3474f82728292bd529ed1fdc8034c4d24573fb3319b0976eff35e88541ed72702cc424202907d05cd8d65a711ff974c27d43e1b528cd8e8b6177d35eb067e08a209b7f848a1212ecdbde8d107d67cbdbb50f1e80a22ca312b253b5db88b6ec22fe3f2ca2c9710f0f2765e575d02182cd5ba24adc3062d84d289c1a3e03687e9beadcf4147ba83abbe92be70179382152bf4554230d784ce568dc798ce0d1bffaa90351324e263ca2d5dfe137e46597a432b72515699c9541fc79b289229eddca9d58075ccf52c8c8be64e321c6de28fa0cdac2037b01d3aeff244dd4fe2f94db399c0e8b6c46484b7547a4c6ab7eda241323e84d5568b376e43e9fc3029967b2eb4562d61965ac08a9cbd77e117cb540b0e315fd6f39c71fb35c786dd67ebee8d6d486ef28f76ee3c76ee2340ce92b3ea0c5b014d9ba53abe8c23f144959c7dd32399bce226d03c5671be582fe503d26dcc82fffc91e7f2a6d54c76e450d61d259d9761611a172077062c883a6115aa4b7b8a9daf38eac197712eff4c4f9a683eb9627cc6d1ed59894046c96de81e7e7aa0ec56edfe0f4c203fa7154eae98dbe6fa38b17ef82c6a8d91c2643790ddda1a929f743810c9b3d2dcc6032ed079230843cf8420012780f1d3b798d91f8edcea18b833fe2f9a3929f5ee74a2799a24a1952bac7cce0b7d5a21e74b2a47a67c7239813c11c31b962f9d435ea3d90211cb1a33ac9ae081b8207abeb7f3882cd7bf99570bbadce6ccb5179231f6388406338404c66ea8b16c29ee33b678b66fe317b794af246873944803c454f81e13dd6ddd1d3a11ce11038f0f45c7ce86d6947a2fd8b4647480ef4b605e72380eaff635f156aa7fe87f501a970c08e0bba0a53e83c2a12325aea852d5c26a43beb40bfd263b1560006035002e24c0fb3b384d5ce8263bbc9f5d1150bbe6971df589dca62bb683d827626a960e06cbaf5bb5d48ee6290ab08531b924c85255ba7caf35a751dc83dfd67802dc4a1e1433e1b09f2e175698ee5a1859ce2dad31933e112e8b57a11b4995503bab21c2e6a50083ba2651aac389a86143517d99d9dafc22e1cb30421db39b995bdb2f4b389095a7c559d98b6afbb9dc582af214811354b2df0d6634ff4b361026a005895d06513c2dbae782487df02496aa5e1d8496af24a436524774b71c4664d9fd54b3c2b82dfd7c268aab96377baaa755a35c264d7fdfdf37ffb9c3c1c00e65ee435b79a1587bb419cc1b5e00a92cc84abccd38830a20867cb0a57495ac0597c7f516db86ced02d5ba27e4b56914bfbb82f1c040050d053db4b74097baf3c148d0a6d4bc04d53395178125b1c5be899a45c31530c3531eb1564719134b32aa67948366fd44bab8ceff2cfaff37dad27244ca2ffd918e444eb5c2a4cd67609f42bb496072380869a36e2e317f990d474dfd09d43381d4c489c82d1f3314083bc3b60a2754153d30f1dbf1e2a073de0bc4d3e3fddcc053b299ad03425c09d853bfd874151194cad24c6b86b69362a925c3ba6f89f94398e96093a767fded9f049dd0bce2d8117691478a1d90d569bb1d56a9ee0ac63349c41391a6a792afb07a8f78586f0c96c1ebbda54f7a4cb94247da65ee7d15e7ba604fca0d41f7adca350c0fa50742fece2f5ab8587ddc6ead86514acd5483d069fdeef1fc4439fcdadb6501c5bf5adee25087653738f5e199d331a121ff24dc5d93420e9c9230fe1b5cfd23e271f48b727eb3ebc60fa232a5a8db6565b46e84879b41e50d1f1a73a223cf79cbc448cc86b30254dd54725527991e24a71e3d94e75cc5836c5c9f9e207a30d951b4c11303fb8fc3fe6be15393a165e60bb63ff533faea84b3c0f5a37fa601e82aa80430eadd469421b526b1b6d8cf6092bf7dab55852d0119140b087c15b40c7f640278b0bc9d9e960af131fb8cf99337bd181cd4fdba150dafd6255e680c28cf532c8004c03cbf49f08e122c2e561c60148857216ceb2abed24a898999c45b6160e74b06360ff073404c348577b0f92f3ff7d6ca20ab0c89ebba31656a442d4987ad5334e96d3c52144d83322469d86b23d1d71e38504b1c3192a97219e4f79ebeb545caccfcff424306948e49454a4a4e85742e864eddbca107db2b3d2427dd30444a96e3240dccdf20e6a063d9943c6ee6aa62d2e087a8835397f774b45d06113f8725f23d2e0185d4b6df02646d2503fcdac9f5438067ebe3db86625c2424b2179c6ada2f0855bff6ef1c7d3e9bd7445dc6514e04928d279a46d971f215bc3e91a045b7e7abcec5138722f135545ff4d86d01d7882da006078920944b6de9144286f34bda339213058b97041f12e41100757c7f6dfbfc1e21533acb7566b86dabf21682fe96a2437b1dc2e90d9b1c4bb6890bd75ad8cab908339f47ffd7c12a5a2d898773d8bb753433348243887529cd60de8307628ecedb27390a7610b9a42132d8f62cf58f3db8d53d74215709b41bddeb04f5273b573ace2939702633bdb7c63599b7816acb85550319c21b0273afa5afde096f0c572ca29793eb7a36b0127baa1446552af1261247d759db472bea8212b5ea8ab27b6f83a1dbeaa374905a2f90ce0895068425312d74489e1dc1d094578e8b944ed245b2c00c0a9cf6d3d712cae540e25b5a5bed13398f2c939a83e5e74e1dd2a16a7abf8e9c5c0e8ecf350886c69678c7be114b000d89cfb681f36da5a1a69eb6cd592e2056cf673ed3090f6b08509d11a7e5de4cb64fd544ccff02cc66714ba12ce951e8f89567458b8108e63738a7b9fb89d4b21aee7a17694f516f4a94a3f9aad1fcfcea15302547e8a1738","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
