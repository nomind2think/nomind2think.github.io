<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b04c29854baad993cc07581d4142f97aa8d6c8aa6baa55c4400e90ee7293a8ffb18a6479a150e1107806040a2c3e5e39a28c0de2c355b32c3347c2e79cac5fbdf194e67d445ab79e696245addb4647cc52792982a26bb61ff80138fb4ca2cf2e4327168905b2fbdd99c7029b3b6c015453499746868a9eb4d8e9ae9858418b46f775f602b30fb44f82881ed9803da50fc049ef230ccee1628f5753954b877cfd46410959f4eb733e2b4a963eaf348884cd96e8342418b8f1b2ae67af638ff507a6f1966eb6b5f1c51de3a0627faa22c7ad9d4014fced99cf3de9587a3ebe2081e571cf09ac38fcece43384c9711073f342f6066c61e9232cd4d59f44584fdb661ace25cd3778ae3c922aa22ec600410262285bbc590d93436c8bbf2805b00bc7a4b9741ba0cff4c5cb7c44fbd3e29678f83aea5f41447adb3c67604c641e2eea65c18ebf856f83cec76193a5a287f5f10bcf09d2dd18e88f3007b274f9539f045e12eacd7b7197bcbaea6f24c00f4cf3329c803c8eacf7d6e8c8b0fc2c7732f7127d8ee0e297d7747081fa5850bc2d65e8c0cb75e8f9c06f9fb4a9c0fb9aff9dcf8c708fd59d83e1976e0161c83d35d9e364bf43c6d2a015810120946ab681728e116c9074b6ae05bb3749160d124f6cf0c6e694bf31f56184f64e275b77cfbc87fa454ed4f87a40519d50f96751ada3f75551cecca3116ebc61a550301e3aa9520381be4d91eff7dc19ede36d26b9acfdc591b35ff478f77820d4c3593851dc0fcae5311ac1c3f108d6155ae96905878cf1eb500793b2e853a5049247ddac5b3c79b8f93c680ab158ba4568c848fa67d88420f2329a08da90918b82e8572453d8fca3fae3a1c38c114ffbf538ae7a9d32d8cb4e9f24d8590a9d829cbc9f3fdb2d529827ef21a2676c861445ee58a102360fd952e848b81a10d9d4aaa9320394a31dddb3c3d891734d8c5cc4569eae40273cff7ce5e90ac1e1011690340bfa3a796e9c3173caff825194c6d702604f555f6cf8d65c73f8ef51e56419df96f0b4c85e9e991b8d2b6850b2e8fcd4a6393439fb95c6bf7b4bdfcf80bffc3637e4bedbfb957a05500e0f750e8d1f33441acc61855d8d9e6ad1ceceeed0fd197158049723c3d28b9618355547d030a107c496c071e8a9a7254638eba7da7df8ff0e73ac0cf3a88f16ffa36631995dc11eaa4533df506f98b0a6d9d02f7e029d51f4cef4f4bae40c933814a748968a9b7f45b476987e4cd3c4028708a80f068a9bf44838543e42077091f3bac7715ba6c67341057cb33ec0c1422274d6673d1492f63e204cefb495b454cf9ae322cd7a6789a6c7aa9900dcee3a94b124717fc5340600f2ebfb696b05e7df2fda6faf611d0101102f85b2eb8389edfe9b6e918eba3135b2d97dcd42de2ef5f690e5a7c18e6814a52dd1ff3e0bef00af6b83ac634e343b014b8342099d6de71fd00ecdaeed4cd830d61802d72dbdeeece4d21c1a337c87c13c029e3c54b6e87eb8258ad85d231b77d0c2f0fd4e43cf9481782716630af59b36477751c4adc33fbeef712044617bdae70ea504f56a5e9f9e951364c58d8614012a55bbf59bca560185597460a1da7f949f69560c3c9322f3dc11653315414c268adf11c135e03fc55a0b918297121cb74f818e4b9f0a0bd58693c079424aaf3cbacea182a14c9388bb1b930b5e98f62dae17781424afc5e53e3bbb0b9e2df2bffd69b7fea05d831710ac5d37f2cfe84588aa4519366b67a77fb2b5f0baa5a55062c17e6eebc327e39bd14cac740ecd80d42204897be9754172019c3acb164d410db5ec743f12bd7e93878228f95d2993c5bbaf582a0e235b262bcc6d5b07690808f9946c852227d5096009c5dce0509133baf3ad4ea4d10d8fb5cddb3d532ec83df6365c5813c89bf2237179b3c9fe6e6b229b8229a913f1fbbeb46e22036e8b74d69bd0fa28ef1c47933de14bb5941855aa43b2d724b560b1817f8f485157e5d9121a99244432e0d9249bb3e931710a98b0281fde0fe5f88ef60ec0d016b79eefd5b305ae54c040e0da32fcdd1006e00c640ea597bff7ea7239e138dd5c805d686dad37940c579b6c299d2f42e185961d04bf05994af5de0f5ddb7d7d87da542168d0ec43a37f7afe2f3d15dcb3507fea7bd37c15c4a3c60f294bd45ed1bdff06d5e9cad30f1a99947d854293a46f0297bba21de70995cc01faf5720767501b9098139f8872a84ad7356fc45b51fcef102eb5f4b24543933e1311dfbc02ceb49eb04afdc9abecb0738d3e7a3ed4d4c7733584270d6c0111e1e5a804ea6890a3457d542e82a9ded46d0325684f766db7e0e24a0fa00f4364988149b0430144fe76ca5c66ba95eae1a620b08559ecbf34d6a7e754ea400d6f9707799506050c3d8d1031b34790a19724961f5f05a515414816513d671d6848ba4836222d0022a596ec3c2435dee350ab2c0e8447bcfc1d59e5b40e298703cd50cf13fe3d4bbcec20e1024995080839095e65b4d5ada7e6bf143de0509507cd72862bb3ee558ff5789efe9c323eab99c76e92f6e272aa840a0ed3e1e8c1aa491eb57f1851fe7acd1af78f4a3605a9bcd7e22ff2effb97b580ce83020258c1f5dbe0b4bd12f7d34e6754e3511cf988d0d8a621582739c5b2c031adbb2124842e50e14bcbf84b9c1413ddffd07ff685f6c6ac54d11ec3694d6f459eed757de23e669f29bae6e9ce3b948ae450e669cc3fdad521869edee5573803bc49b69d05ce9daa9194422ee0b3009e3cb694d0b9c98286089d2df7c5abcc62113a4fb8c521da5bcf3a0be718083d5dceb146cc76b44cf47fbceb71a7217db39ba6bb4e97cd3a3c78701ef67f13e1abc7fef73f666841b02aa1c77eabfc7a59051c7a340f4d213ced3f42865a3f8fca2db1ebd302cf8d57df48ed238f02efdfae99adc5fbf69c87e537548dc56450f806f1de25b9ad21cdbace0950e1ea80e846370a5e4caf29789c27945edeb1541e45a53fd729edb7b74d0a76cf0d329dc028523089e848e23d8b040eb0aebf2b2b9444b8402f8933c41c7d4210f153e574731a188207a0babebf19358341e77b6c029f783a61c6fd53f90b2ac301e0ed70310dad484bdd298a415d2fb66e9055a411089ebb97d37b7e093da71550f2be09768f2396ba0be29b45e9d6bdfe292545f778130060bdcb62ce98494fc26640cd64893776af2f1cb49d39a71f3efa9eb3bf774932ac27f43b60ce54a2dcedbad75ef850bc2147fcdd12fdfda4227e594bdc245cd189883c42502d4843c4a85df3d7dcc8cf1357883e19463c347180961c860b62c6cc55074056f31ee1915108bf05f780761af4eccbae7b7945d430ac52fcfe5bc67f607b9ddc8c043e81f7789a65b19757854be4ba442f99920b13693a90b8952740d91cbfbb90e48110313e6b30107211cf93edff6720d026c68e06567b042abe7568e6bfba73460fefdea3ad4e89f278e403214557619463d902ade6d98fbe043b87f730a57602b88177e2816f67a977949b9de048ee824fde3b9c71f9a67890e834e8af62e4e51520d17a9be74075009ed367329b8b92ab20596f7fa12e70a8266a8954fee81688e3dcc1c464eb05a7d270542f72c6eaaeb8a3ac3b8eec15ab4668b9b9dc872d1794cb8825fee9e33179ea463207c0b0a2c559a713f646024704e992b6ab0e71ea789a92943b8d618789b0be5f480b6f85b4ac527b9f0382739d97b5d743d50e81d6d1c39acb0dd14b56dd2588a957cb5adc1bebc5fecbfeae60b49909c7cd3ee8e6edbd5898be8927ee93955b1c3765f599fc66a69e1be4bb01a45d7e01a2a2e91e07762e5b03ae6937f7a4fcdabc8e288805b5fb7458eb20e2775b37d14cee856ea11e971e59ac92c3c453ad811c316519289cf6365a8d1ddab8947fe3270f5a93b68490a91d60c5b344cc73a46d55d54e17e229f42df96822b767afcf3b8ecf48d1bf57440e4d2ec7253f67ebc1a70ae2e4f232ee091d076c4be8f696582c6bfae7629a2398342ecdcfa5c9ee9ff9f64b3e7d424a358d1cd3398b103b85b5ce32125e194ac9a4be7791fe26f52247a974f208a26d35e3aa30aab0952e5ef15c92f673ae1c18b92b029fcdd23083ab861907bd70b2eabaaa2b3ba49556164e0a5340ff06b00383592dea63b48c1e9486d069f5d465f41bfcb813e12d36f7a08dcf3a973ab025a211259bb6e40dab883cb53f087de91017fe4724abbaad28ee2201e99c673000b193eb91babf8af2e7ac25cc3b223aca25ac9a3ab3b3b5c11d9b88cd7c76dd3d009672a8bc2918e262ed81ef34147ac154843e6fdf343566070eae8d6ad8ae07ef32973f5b8e9d0170f36a0989af2e9e5cf5ed79cddccf11749f804506120da41ffd2a455e779b5e103645e3c847d039c62533bce8470a2acdb998c85cf3ae937cc2bc682b40288ef48092b40826d5ac7bbb9c209f4beda732ba1d574382e0fcb0bc680d0dad5e0b3d79973e026a8978fd89963137ac9b8e9fcb6db06780776705f0ad6a1a6fc72f7f9c47ff8f2050e044e262d93b0872f467625d92d7016963c8ce51bbeaf190f5eaed222466eac5dfd7127fec2adaa24123cedfbaf024c9cae495d5132f051468a38bb94967c5038a12cbda419291f9f3d1bc640d75dacef04808aa971457f357e24f32b3b33ddc093d559b200f032508d09002105db367431793168ff3cda78124f4b81f78afa74695f5dcd7cc86b676e26fe2c009c97c6979dc708d2b8bd0711127eaa171ab0e335f1ea0c21aa0965626dfd34b83fe6da2786bc1ef85521b03eae46bf9284194b239f09ae72fe8ea43d5224cd186302079fce5c2a498841c08d3d76a10bcd6e91aa8f6e0cfee58c70173061d8c428217c9df1fd65d8c4bfe536bcc6e307954889edcacd4162bbeb987b18a3cf615fbbb60057a3a7005c9c413f527e6d235f228a54543fbf355509ef03427eddb4eee69f940b673d9036e94ceca2c44632da4efaee4bc9c3f85177814952d38cb647a4f99edbb1464b1645498f79ef8c28caabdc5b04cfc8bffa7d7fae9c85328db418bcd044d7c53f6941c0334540ff9f512fc4fb464357b64b73a54d61dc4936051d6da1b999afc506971e4edc3625b18a83e5b8aa6e3ee9fcaa6fa7e1ea1aa58cfa6dc34b6633b4e629c5dc77744c940e268ec62c744985df45f2cdadca8cea6608bb12fdcc1e1713d7a774667dcd0e64af1f1bb13ea6e92368bc93e0a6d34825de30a96f55419d65630dca0819b96e522dcb5eba0854a973a939b6c10f8af3df048da3bd9a4eb455c5c37878fc5aaea24fafd2bd26e9ee65ef3c79c0ebb8fdc2e2fdffd05fee51e929de746752a3ed5825afe84083307ce2d3a135a022b5c7846b079d2e9373876496e665b3069dd0cb8e54639e57afcdd42f70350fa5b88d97b82096610b1db0aaefb90151de53f74e0810c231264f42551c9931b9d29b57641399a1c6b5be9e9e1f064a77eaa3491b8f1b2725e955e3ff6729a3e62369472b965278617181bb81836b932aaa0a7ff74fe35b6c4cb0ca06c3cb4a44abf27bc9fd96bac093ce00e758486f87944c76e1548c4afb5703449ad89c6cbc36124283daa385f754ff53709cee04051e87b9dfda6fff8913e6a3ad37e4e0c03732eda453f2f099e3cf9ae016f0c63d2b68096362e117c0aeb844eac4935258c3b044e6009d9f3f02e6d821e41658e706bbb37998f0f21a592058e41ed16adfad419c522557accead3e1324c8ae18be526c2fe69735b22bc869331c4b485779a50a95dc0cba891ba2971b35f3eb4f0dffd0de13b037349fc5bdd56c7212c287199a4c5ccc499315fc2378adb1e26fee7a66d8a35aa1c479861c1860f81077449d1553a50134c192592357769ef35f8faba140aaf4e2aed800516367d6b31f513fb22cdf9e0dd663df610fa0ff8a333adfa5734981386aaa1d205a06b9aa9899500a4cbdf20f41da0cbd88db6229d132ae646583a40b920bafe9a581ce5f568c95fd48818c0b9f486f0ed117dbfbe0d35e75c612ab37e21bfb61ccc9b1efbb109a0cfda27a24718706ed1727be536b8e945135f37476148e224aea428635497c9e276f59a1f42cdd07b09494ede1ebb14c3cdf6f2f4da2b0811eb409762f32b1c1a3a4cf41c0b435174e77fbbb4504b0a12b18b5f0558c81d22ed6b94641045877eb3927b0ff21ab8376e4cde83ebe03c5760e561f33f53ba64a3e4642cda3b1962e4171c937d15563b3a3b648465386c76031be7eecc593c314e21b3d399274168ee294d38a94214899afba7e4294f4c2c59db59179620f3fba5f84cf2862162a089f3f46ad914533e60abd19fa32f3297bb6cc8b3c4dd4603da039c7d20abca0ed30263cfeb9462bc2ac1113e5cbe0bc9ba2576dac690353c7998a5b637c1a9951955346c0f5f27ec2afbd2ec799e2bd6c9d65b44e352cfb3d83cb2ae351843afbdd13aa9ef21558c7fbe7fffe89c8f7daad83146a9ec9540c58f6918aa8d41666f2297fe2c6351da1e31fbb792f146d4be2e6a16c9dbb1faab819919881d277da09cc7992c43fa2ba123cff8d9f3d6633d6f3176403d23563a08e2718ea1c696394fb18b1b44efbd01afb8a5d2edfcf8c6cc7b805cdc1f5701300decbb9b4f0ac1904db45d99e9b13c20509378ea8e702abf50e87cac9375eb1b501b6da32c4e03aee3fdcf1a921957d9897fb53a181cf8dfbc3074eca5f7f62e195349a37de13998b213d4feebf71c770fd6936ce3fe53d97f836d52f52eb751a29f6d4cc13b61041499e3f3023d4d32cca4c2829d73ea374cdb62cc42bc974ea40e89039e90a72deb42ba5b7004373cd6cfcffd2538844da967436b934a63ca197c0188aa728918cb6d3687e569156fc7fc217904c097804fc2a4f03792414854b664f4a17549dafd5219bbd6277f4f6ffea93e60b950179cb2d3eb1ed4b5ea01a1c9fc34cd47541997024b879c583e74631825bb4d852811c82aadd09a06fcbce3bb8633c9a1846f7c68676f933bbfacecc447ed8eb30ac7daff5b2111ac563e5d3b383ad6ca6d93c6ea1076825bb314d984a7b201ccc89edcacc7f0307809596530e4de68b0b4bc0e88384e205e7d4b7fdd2a2aab66efe606960da9ab24bfa81b8d40499dc249e828d4af9ee89ca9b7ef04b2851f653322d1791cae6c7b325feb4193865676292dbe5e276e513e808e148f76b3749f6c1746119e2f41ec0a28ef937acde8fe62a73c2b26f2a4b1ba75e83ba31c2ad5217618050bc8e9283330e5ecc952da6f0f5a8cc9558006be49057fa44b34e455d4468d8caa344bd03f5ce105c37b743d593bb2a74f66f75db42c85f955e78ab2538fdfdbb905571d240ad4813585e8d97bf40505b21244ef57484f7f0ae739a74c46aca0b97c5b7f64c1953a1443dad5266bb3fe7cbbfe46711e0317c733bd60c5be1bd97b9289734b7dc2be1352fe67c0aee3f2aa986d150cdd84a76cd47e7656be23ce4d113fb446730409e39e6b05a29d70aeafdfb32345e180764052abd86a455702435a528b51c0210cd8689ddb1ef3f172e5f312f31eada4f1046e68a8664bda82cbc538710cead6215ebf7e1757a4d51a3b097157aed15b1f2ebd76e8c7f1943b935c3264e712b33b81f6c3d7e29e81d52e71f55e05ea2ba364dd5492cb9af3470547df6fea0ea8019a4ab3016240f71d65dd425b01128a36ff4bfad371df380d5646afaedbf904114f3c69457c9dbb574d5b0769b7bc2035da737349ddab76d5805957cd7418e2bc3e84ebe0f85d43863416a3486e7098339f4660f6a8086ab3bf8e3bfbc8845fc48542bf78113f06b044e59d95eb85e81c8861a25896affcabdca797d5381740f8ff4e08371cabb0dee72ffe514707638fba8867742a760a0f41ad5f521e6786dba4898f4f2935cffc68beab8f0086966c7175c356b5b64aac35f71df46fdc3b6a18cc4b87be38bdcdedbaf06797e2fa4198a9a32807e54344577e456e5840bfd40732057a5e35f99cf6a07a14c16b55b7317895202d90b973e2ea5fe96d0b62a7056986136865585a85f225ce5969f80fbcadd5bbbaa3cdc940bbbd57bd658c202f2bd62a6402c4b6460e5c26c1c09115f1171e816853e3f6d44b86dcbd49added66571d1eb9d58b1bf130c538451383e563c494a0c3c59408f6716cb48f4af5e1e1fe3c49f8bea54bb6333dda9bc67f6717ff6b3c7f36e52663b4f534d63c095a5cb86312dc2803b5e3d3c7e585fc8b7e40c97bfb96dbd890eef2a31f170e0bb58a8b19c7e39b65dcc57cfe00c24fd593dfe993cd556bc16550aef7bde590c8846297d3cc97139fb3d653db6628d5f505184750a23da5842172bbc7af69a08019de3b5a7b1f91c0cd1e2f7519e4feec5e5809f1db70bf0b9509d59363711865d5358ffada827c00269c6165adc591e28d27cc280cbc370d6e6a8f25c766ac598421f86b43da20c0ea97460ce58237b73d09ba98fdea9d2abcd3b161a0fe4b71e04728879ccf5b7f582bad88618aa53b3acb01aea902a51b6ad86bf2f43beb2c98a5a3fe5a22acab381ff09076774830fa83b6de8b4ca628c83485e3e01f86448cef08266ac163d29da9b1c7982e338c082cad59de72c78052454cc1c3648ebafc0116b6ccd71924857ea47cce86a8351f348ab91a3389172a1eb75c4dd5f091ac803b36107c7b7b2da4f9ba0d5e91b6832ba0481829f0ef46cab7c44ef36b0b31924a2f8d1546fe7ecf9c2cf746ed2edff02ad0b7be9b6f07a10133ace8399e620e5f464f4893ec13bb4057141f00dda2e53c34590ee7fd062e90ac2442fedaeebd93acf53dd92e7e479341fdd4dd9115d8768f93a6e457dd71ce7729db5f34ebb7ac133c500f615c25510bc5a3f12d7e98ec982d0a66dbca0c8cf108f765635c0110ddb1e77e1ddeecc2513c16be38ef4e79a26bf0eedc8926ab17fcff88e3176b72437bf292673ea7d2f172a727278a3a57d002b87a45e784e79063201363f6987b7a5e82a8fb8a938e6c3c4f780d5b0ee73409f21aa3a0b85159b394799f388d70c3b138ea01f9a248ccaa199ea2eae7620a7b06335378d3d3de91101d112b4428769b2362d7d3d0fd9f16ab361c3c54ebc2eab08ded44ccc2ef6da33f6b77be15542bebbd045d31563a9c5ba0d9ca489524083563927d4ebffd81789100edfb0067a57a47ffbdc69863296eacc024d571f5bc284d0e9f9558adbbc647bee43fb8947d3e9cfd1312f1c9cbb8c73d5e3aa47d88ce059f70ef038e61579be299cb9e57539e11fb277eccf026f748993a5c8f476fa7fcaeb43d7aa524d13a88d2163d4b16cd4470dfc3daea84d759fcad76d44d258ed904ad7042cde55588c810997d85bee64d25f3b8411b8cfd0f62c2f3404578393c1d13536b2449a2846b2e92772a9bb47ed64dfc309e79a766a79d1b93d6de24fa62bb4cd55f26a652746e3b3ccdc70a3a04ac01ace736f08fa42969940824c851f95340d17ebc8b4bee5e346e44a88273f7d91fec237b27387a0959b551f774929c3bbe0c23a77eb9c81d0555d996f567f686ba54c3b2d2f62ef94218f065a866a9c73af89ef58ddf38dfcebd879ec29e7c1b64154e8381790a1815601cf602c35c89979103fa21a65bfcceb85c719651550db3f22ef22004f1ab652504dd674eee487836142dada34d835db67df1ea8f6e10713dc3e0e93c7e95a5b1bf399780ce236be8c299df3e662a454531b6e1f7c610b89fa9572af22d1d58542e28499b9df711fc8448f6e7fbd92aae0d11b6906dd45473102e195149393a212ff568031bb92786e998f3f66c4afbc83cc9c090d9829c24236414d0b7df6c247fc5315e05d36ea946604bbcc94fc31c28001d96b6d84087f7f329f0beae9d0bd169a288a0ae7295a5ea21e40a3d18fa0adbfed643bdd4d44be02d3b6d61f6858c8ab6f532552175db49d4916522e5cbe54a7778a40102bfbc7bbf3fb905c0bb1eb662a9aa3238cbb3f52b59c382b1ad6873ac1bc2f67e6640a8e7cd7317a614ea7092e4cd1ba7edc74228e7e73d778d947f72ccb696a1096dede40ca42675bd757053f82c5980806cc5dc71ab20f892877e66079f29089f301c01ca83cd39a94349aecdb5387263dee2cc518c524010f059b25ad63d18b130790957f0a12828c6f5181c57dc175a4f48574a11bca58cf4c2c3213691f1b0bacafc535240292846507c1edeb41dcacbeb347f764a5e5637b47a6e31a778f340c785487a42bc0af1d8fa95fb925d4501d6e067fd51ae623b48ba71c2a1f9e5c10f89de62c59e8c18b1dcef4e0c8b8a5eb0930923f84e9fd005f58bcf10a9ccacc5d77d4cc4865378e7e6aeeda7ca18d52ac127e35b5cd69a147c090f776dcc147788b75e5bb1cfdf421a610663c187727ddf825e37ca1cb55dc4a153342fc815efc7a033ab2ace057f4140a7b2b6f893a9fdfb729c2a5a1ea4f6bc9574319cffdc33c4f61b9706d855c278625953dc91216040701ad712de47beb4f6fedbb8fa0c0833fd0094fbb5ca86dd05a3ee706b334d8552e5ceeededc1334db7082103f606a8d0afc1d0e2b0786498453caec59238d9f27b0966256401709f30abe65dcffbb57d95b37a21552ea6cab6d8cb2eb844f53cb5baf9fbc5e89221f241f163cf4eacd84cb980237c1270fa46a55c2bcbd7415e7a49be9170ad465ba7b98b3bd3653d9d49562f4ebe48d1538c61320322ce26ddc2c42577c24b1a6081a1027e1b14d63383504dbd243c42c5659d9ae296a85497314e84cc02c897e2c9f7342bd711652a90f84ddd9d72974ddb975daa602d425ebb08957673163d3b4ae83c934696e202b557998360641d0bf298a8ea2c6c5d4870e51f2463eacc59f6d01e749fbb387073dd4a0eee58cad484b174e85a76f59e4b90c495e97a7c976492203b53a32ab50b4c3e7ab058f21102bdc9437d9a51ab7ee1a4943e1a6e81ea4d97fa66852db550955ddf042393cd3799e0375f1302eda886d4e0566d6fa0e516d09d0b12ff0c6c8c8cb1041f246d580bd96b43f778140a12c16282712c09b84f4a315c186f3171ad03edac2dab584b77057e88e8a1ddb7c9ef11ee026cd7cd5ee848014c654a88428ecbb490bfe83c2d324f2af0ed3af7b831846ffb9337064c43136910657a0c22e7eb02692d1eed2a54920e6dbc59b8f1843d95f6ad778b1ab5c9d0c4bec7c655a8502034d1799324847a337df90bbe189069d4934b6066079de66c5c1291fe12027ae27302508b1e4383610acc90c8b1b9371d5ba75685cab72cc9b3ba615e9992280a11d9d86ba1a8b473efe67a53314f5725c81f5e781c453d589c2b63582fb4eae7c61ebd3c568174f6008f3fbf334a3bedbd284769a48257a3841522a09822447ba331cb202f6b72a44eccc442dbf5f8b78d8250ff6012d83bb902992a8d073603193b736ea08289d80c1e762cdc0e71ad9d1036acfa52a9173c119c3f77a3d640aa0858b79d6ca1200b12cc53a6829663d0f00f687c153e5778995ae91c7527255921da9d7da58a560bc03a03ffe00aedc7250bae271b514307fb7f21116b2a7abb61d57fd13959c246c5a8a8bc4d1ec97d888fb3ad28638f5ec10cba96f8ba47f58092861a32f52e3a03ba64644ed5fdc8d8b1375fcb2a32cb00296b297d69987968f96c67ccb572652b748a30ed507cf72dbd5b84b9aba7262457199d442849f3a3735ee2fcc33da8cbfb9f6c509fd8f4d0e938f5c9bd3450c07655ee5181a6fa8fcf76aa9487522177334ce769e8df44be387b4eef596bfcb6b86581940c06eb0669dcc1e9262208217b7616b1b4cce193549443f88a851f195cdd92c36e2593b19e01a314a95203a489d273bdcdb997b728eb2df307f5b6f381e7976de37a211fcacf1fa976ebeec23b93e08bbcaedbd8a739777b94d10615378d441f7fdc3c75bbeba1ea5c167e39d1afda6d1de931e6276df7edb34870c5f3f2a33024e1d75de277985cf39f95a07f59103254781f7cfdab390577153371ebed0e090c9fd31ddb45d792bc998063da60a545d7e86ba2db6a10c6462e40c0d12854a4b91e5e79ee3db2b7aca30c28813420a31efc8adc7e102874ece50d05b93cc94d0e0b30a7e7816afeaf43738dbd85bcb44cf890e0465a239b539d8631bc6ae290fc1d05034c34b7bd596afd0838865f583a40762f0847f363bb890dda8a0aab4e5a63084973357b48a22e12082e52494122f8999d27924862a2050d697cc6d9297bae146ce07fd2cb796334549b7d41ef505adbcfc44b585bcac9cc1d2aa0f7a47e3704ee4c28b2a9b3dc66bd1bcb1c961d644b9577dd179ed3b993b0fb78c899de36e496da763b1fcffd6501b50902c3abe26a98626502b6a75603834d62b3d4ad06c03d30a74f46203187627fb688926e70ce7ef18b77e549c94394cc8ca31b189935f3764b11161a338b9c7e9db6a440cb4688537e8c26568a3faf6fd5dbed699527b77b780c82fc1963214dd2d33bd7e53c474452db0c0dfc410e8b617514c6b818c0fd3ac6ac72efe6c1a579aab5a1dbc259c7a980df357ba32cc069afe081235200cbd9692494b8d3502253c1dcf4346a9851d5dcbc47d1d874db9ccfcdb5660139dfdb5516c6cf3f322f4af12ea2238b60cde154cc3d7299565e142f27fe274f56988832bab915ae0004799634aeee059165494a84405980d295ba889897fb7bbb149688a59bd0f3d5fea2f386d5a0ed237deeff64537aeecff8cbfe29cfe9e034e9309525bad57fa0066bc936b701bb46f692ba0c044c15d3b577150f9108c524ab33bcde4f073ccc4f6b02ebffd3c102d97a1fe728c77d377755e4cab44759ab21c04cf355f57d315267a2de6941b04d9109ba80bd0194be233ec6f8d9b7d8118b41b8a6b4906682f5715785f3e82ad80b7f1528c9fd80cd889c1086a03bb66964fc81c1cf6af7118587be90cf52a2a9ed04b94a46e10904fcdac81ec35c8025ec915a99e11e16e27217fc895ef38f19940c168d3f5977e7b85a70b7338dce9888846683dfe4ee5c645c797d8970f27dec7f0644fe1ca4d6a1149979b8a9e5b61f0c6d8e3a1e88f705a2e0b0d021177702de49583d38a5cb246552179b940031d483ba389396ba9161ff6b68127b77d7a423c556a4972d5fc2041976f15d5b436381a764d093402f520178fe6522ab27d2ee2713e23b890a5e2914bc4ee03444b5492e2d15439a798d4fe6583893639629e86a9185ef061d7e31197de2d8fb0faaa8fad6b0a6d25ccb9f42f228edb6336f68b6239403464bc085eca8cbd19edaa126a4c43869de27598bdd4f8a420cd7e2973c5f17e28491e4653adf19d867528f2ac30bc6ab20c81f495084ea3fdec8643f14e9f7abfd75e56569cc79bfe67417c29fc3ca1b633008dbddb996018f35b5996f249c8a027fabf6084ea9bcacad33bdc9522237484f89a251b6e8c26dba2c8b4103b6462e2cf2440ec3b8d3ef9c47dc2b3bfa68f6ca4f170000f950cbac77b9686031e805ccbafb012a94c891c9e578b4a10a382ae7a8231ee735b8750c8d301418f41f4fa432bf87a0aa46cece49990abfc25f1d041cfc50880eb4d4a490b82d60423d005fea20bc29ded7201679690928d96323902b255aede02f5d7cebc3d70865e831e18c30cf8a9910031f1e95d42cd1fe4989500f372e52f8374d43795e1011324b5361c631c4712d6aab6e9d8a0c898293c49e8f264572462909dfb72a252b663288edeaf9b82989f97ead30fa781e1968e27310390caff5c60aac7335a448f0c5e07f40cb3c44a2f2708c150249d656398f305e6eda12dda061f57513952042ce66cd80627b2b8788e23e350d1874360a7720f130831b875ab59da778b99db7411356da444892ad3ed62ff72176c5e4bc9c896e5298d0d5aa4b3a38759f39a83facf0d58ae6ad03b09b8098a14aa74d71e43b531e528826b2788afe04709a666ce89fb799437231bf7b7a3bd121fc28d535989e198eac30f4ddda8b63fa0040e5e55f40a3d47f9ed51121c40907f06760290efc512025bd020ae5646d42201373780c0df39444f039bef37dd0d75a0c7667ff90ef3dad3ed82892edb0f70e1eb48cb7b33893854cc76f6adc343499dc99a5bc5d60dfaa497b07291a4dc6a6b6dda3252fdaf8e669ab8c3bf5cf755f3b0f5229ede241d10c238c8acdc6d0bc18884a713258865da18b180680b16da822435ba519c132daf91afa7e81aaf75914abfa13a6197896870f6e84e0bdd1489371035fb4e8911002bca4f63b5b3d9bd498870b64110c3be5d2124ffebaa05a75781b085f020d0469e30c27c7abbe768cb655109a626108cc81184f68188a967a1196c4fe09bcf924060bc3a21139c58ccd2e46da36eed7e59e34857d9b7ffa5c4d08a85b9bc036f7b0bcdc3bc5b5884b74df2f681d52de6155596d356746666ef4f22a7815177e80c7152e3279eedae4f248f473077d2af18e0afb7fd275dea8c81b3f5806889be24f4c51057cc1bbe43e00d42d1090c4b8ec0a20e12906a0bc0daeafcdc4c814990c86721d298ca4c4bbdd73139f283b7b244445a916cf726109183ff09e5e90d9b8f6dc2137e0a20c712e9a4e4eaaeb62a370f6381ea07eeefa66b809ae439daf12345e89bc8d5c8eb3bb8bfe899a9d27d9ae4fda34a7d4fd6fbb5408a0e51dae22183315017383f4106942341e6630e8c5deab85fe5ede96594c1f4fa3747cf8a7c62fb8f8478baa2acd1da885a33bd01b8c13b50488f788a9ad067ae5a3178379ac714e98568018863312aa903f5b8f6cac3a371fdd48bdea1da28f4ab33ac258e1451aafa845d1e4de92d7cd1a9e6ac2d05eb072587b9b335e6ba9789d5899db2d9437dbfa1bb7392ca7458620caa71afdd0b7573f32533f48dcf8eef9a123ea425d83ec6ec4a70e09264130f22d6ea29cd9be28f89293b32fcf3e158a48ba1ef19dd51a103727b3e8a41fef546e79fdde7828b6c5351a46a6a2c8023f4031706caf7f2b0419853738a8532a7fa606188d1c09a51f9a6792999768ee9af66b7db337fb134900317c7c7c1dbf5d45b835e0cfb58b5c668534bdbbab172e3c607ff1b44e1eb32e5bef66426f47802b89b19b9a8fd9bc804e5f66ae4d397214a81c23ae207f02b29b9ee0842b09fd016b0fae4bf9a0b36a06869710cea2fc01cd61c5ec1336261f2ab45c536489146b510d187f32146a3e6e8ff051d623dd133fbdfb63203d162fd1e40cde4805c2f3468645ce47960db55775aebd25db252e9493cd663a2ab1343d3d0427284952e4d2bf93beb139cbd39af1059cfc73aaee790c25e3b0951e5c14d4b37003beed05e2edc8e766cb068171128e621f6b544c2c262ab27f2ef36d945b561e10c78f453514739834663e479e9651a7395bf0e7a6cc271f7e392e6431233c748de2f0ae402ca82bf069b3a014ad6a630e4140902fb18993f19efe8b0445ae83d20234dac72fde648881b20f35153057c775c940dd4818c695b4a861229447581ab6339c99104bae31f701d928f336122dfdf58d7d3ff7bc5013275c832b0917742e1f3352fff780a8418df737dd4f286e1b31630cc8919d1bd60ca8ce6fa0d75d689304a787081f0bb76a0e9f79218122c8c61badb836a23c81d8b761a2ce6302d00fc467dc9961a4458777346131a8b9c4c2b3197fd99577bbee816dcec016d635fd6e1465c3d850c79b2fa1a00c552d4073147b9fbbfbf6efed0de1a180db9ba687828efc2b3bd335e9cc1343809d372ed0ff70c94a30d8c552e13252a33e15771e486a3c88bf55e934ce3a06e16fd5dbb03249105df957f8323725cec0f45912f163d76d6069454764c359435c7468207952d70def941e87ba298fb0ea85982b81331da64ec162724d3cbaabd03adfb21b5ccaa134c0086dc51f03e51b81bed4d5164e41160d140153e7ab94cb1d0c24080779d00450f3073104118933ecf9d328e0876a874aaf7af043e102c8f5e17f25b9d0f43b622554ea32e5f78bdc12c0a713c8a6048081e6d2321aded7fe304a35c1022c5f1a43a156a1658776f3f98af4c8ed98f83a2c5179e971c7cd1009be47c3c28af4108fb80363ea77783b06088eb98b54939d97a2d1aaf8c913770cae2900d1f44eed627859088c4f6f79959eb13f8abe02437d4ed7ffb16dc622d9de29e22e8fcdff6915bb3c5b8e204b01301b1bf608c8744427fe5b707c40b6b5e7b992d096551542ae97d9b8acdae402910e225b23e185499343bd6254d370152c793aefab39e799fdd84c51a18eef226701b29802eb412feb8424de5e9afb323b52587e53db9bc919ae1164c8c30c00d0d31bc02836532c3dd46a6104aadc310f86f4fd9b9776fc557465664c9a2af87d2471274da2f4af7f69f06bef0c8d4df5bbeb6213f701fe50964cf0c906fa1a4836c4f4da0b749cca31f3bd8da4008dd4998be36a0b5ceff79586a582e442cb30b41b2702272be2805ba10680dc3d5ea16b25891969d217e111d65d983c97bc2593f5068c288c8b0f9b16f383538e66a32608ffb749551ba6a721e21f6c40deefac41e243cbbf1fe3cc735549e75562073ad4b722c480d7779cb89604d02f215ff618fc6c2318f456f8d3ec416d394df7a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
