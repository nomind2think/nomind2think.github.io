<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f96e8ddd102b33e4c41d77c2db5d57f7d53500eda0a6f30dfd19da713ba53d95bac8ed54ce8305a649994dd5c5d5053b33e8e376efe8fee50d933298ffbec4a81ecd7871844804114524e588eb87f3f5892ab96c6cbf631ab6d4816097d9efb318d71f7b1d87a98fe03a98b18c8a6bff3a360c56c6b7f479cc2163a57af6c95e4b7ead6e68d259a029335038d875d92f9b7be8e471c937a2b863e26ecad8a3aa04f9423f73c88300c569c42c322e2582ca2604bacdd2fe3455f17c7e2a604ad8b29dd96bf07f035ea35bb0843d318f70f649ceb3d63d41639402cfd8b8beb151a88cf15ba815f852c571a790c66f6951791509069ec20e6eafa7bc4ff119c8bdb0ebe5a006fd964f690b972ee45ba64e32ee9b7aaeaf9b29020fae6d375bea6bb2a0f4fd9547b074159b29a5d6a39148f66d99e091f10099a12f974e513988deeb56f638f080447eecf608bf93892ab891f77e350e1a349fba2da175bd4e71ed9764224700d0903283bb170f8d797fb034b1148ea4e5cf7bb1e8a6047dfda9231f8868b646bc8b6899dbe66145e4abfbe9796f873a393da241af5e6ab7f964b02938ac9c940cd83ad6ce42d36edf041eeb028431adaed44c0c0cde065e5487dc4037c7f1a11497a1ef1ce6b61360f4296ca2b1d12f54eb522ad6b83afcbcdc57a3f72a402bd5b539ad3a38ea9cfdf62ace0bf44cc497e25923b106af7870e6e3ad57facfdb891e0847ff315e6d9a4bf4a9f3ebf193f5ac6b96c9c4c3458e27b5ce6cf003d8075de23c6f96bf9e47aef3f3d66742f35e78c0076b7e8540fac148dc61b50c0bc641fd3c51500816d6bbc46a60689f7e42be88058203ea5a43a4f39f22bee4ed30865faf1aa5552091edc2dab87452eebed307b0e52e6ac20b70c776ee66d8c1cf8899731f695ab979793c48c9c7b5bef3871732454ed7e05e8f1ac6b6c82a20e0213418194a7da69dbcf247aa5027de7a1c3f9711ac90de81748caba893843990f38441cf50498d3cae88550bacddfb63bd79130d413f0b7dbc6f7cbaa5695476d6dab5312993bf17539c8d85d70f89506bf814cfbba9a230fca28a826e4216bafede4dc781367c1f8413dbaeef70ffc67f219158e866b484cc2696a3761511cb34557f7334db32e2788c6e8af6b2063fa86a25eb860a6c561a5dc2239a9ef13c025ec7ce8e198a1673cc8f5be196c56ae47563707b78b9c8fc86b133a53ded4a85140dc59c22d1f87f2d540c4655e23b4d0dca6aed5648b9aa4f2731f0b4b9ceab3f73e19a1b40e8446435b5a58a2239b720d086883ede99153a0d2ab036d1083a49de904890a7cd261a71151d04e847060cd402c3b530d2a241959eac9e5b9f044834dfa7ecbbaa3da8dd0618dfb180979ebf9fd46629aaff24eb5884a4336b2aba46f41be82c11a9bf12ee2eb523dbd0dd18f22677f8afb5c32c26b7957597cba45a700c28fbbdf8030f6e2988469ec5566bbc765c34eaf829d41ed48d26928f588255abc66ee99b68c3aacec27feafd55e787de39b105336a06236897901a63cb281b19fc98ceaac7ea95449c7c0c28c6a51cb3a113b4976230fcf0eee3380825798b7493cd8096af6de66843f8fbf11f1df0b5b11e14cfc47a2691406abb694793ec75336db374a30439636c12529d66a60bf70425c1dd36292ea348fdc9c2d136c7db5d8fba7f577620a608bae2c59ecb92c1e82ebe2f944e34e55978ae98f61f336a43d82918f9e33264d22b6d2a660cc86e77c2a5ff18db0dfc8ddaa248a7e4d41529083e80eab7e16fae79e159480b58e5ae310bf9e1e28a6ba0e4f334a279ac844b9348c5c5c390d7ba952074e759e30fd0baf291156a4790df41d8397c2f8a6960b42c80fb17237cee0b9aab879f2e34dae40eca87e620fdc2b9e33b051b0c405716cf808f3aa6ba1128de38a9f8351d5b6fcffe42dedf52b9ec6ce48e22e697dd878940b46bb978bae6305cb2330257722ecb31ca44f395da79a5f9b7f9653c575690f7bd15051608bc3d23c8b73e1742828d6cf7d4ab04ffd27f5e5d22453a8319f1a8572f198a3a4c1d99c90983f3e75f2a5c28fe7652e27ecf0fcbf4dd54eb3ac7a83fea65df300a3b1ec091b58f7fe0041507842e95bf790a421d7d809afa05bfb45ff49102deb1375d0e606bf2f9b49b148254d6c49f62884c0b261dffe680f0d8a45d367f438d684ade1048529f9f9a0e9497ecba511cf83d5539b93035d97912469ac041d6b473233f61c1cfa071eb58a187d48d1b4767d9e89fc710b11ee010953bdf54c800dfa7b16e6b736875464edd9af59b695198fcfd9c2017e8a70ec7530efc9cecb72ab5376e9e4900c22fed6a298141a4341b0e30351c8d92a1cf7f7d5b3be954792d3be59b1babe187fc2c1c5e3d17e551b18f142bca0b21ef0c04197515bd7773239aab83e33b57169cd83536eaee8e49794b071ee38fadc2e9fa45e1ae751a191810bfef1cdd7a2dcab98bf9b1bed8e6f68008df4afeddd4e52e0f3682e7c19f27be79b8092ff1a0dfef4f9dec27ae01da787ec38606b59f8c4d46de1935868a61e2e797689266019b6c4d34574de9fe0cde913cccbb2c0e184c6418eaafba5efb78edcff74847a50766e064290cc87b55e1a2535d80c6627ce1e4767e2af206d1c62f616fcb0ca2fc207e59c474049337f625ef2d1c0b202aa06326f134023b29b7d75f36b2c7c76699d3e657875cc6c1699d7d6538c8ab00dc3080e9dfd2e1d5bf71db53872b007340a06ec0e75169facd89b971d8f534e544282f54b4ba15e07cbc64980c22fbb7f60f71b200a2354aca1f3efc3ff07d78c5070d0fb7318669403ef07c36880b0d0ca3d0e0f0dac6d6c56922cb4e843a4b180a0aab3536fb83c573fe2bbc49e61407f9cb8a826d7dc6158d406bd403a0b216fc194ec41d6176de67840951c457bc13eef37bca8963852f62ec9a0340350c2a1d990bcf54a8b4e4a1c15efde6f9c4567b1cdeef113ad0fc7f92be334453a1261e777227dca9f27137506b2098fd7701f59ddc29492979de2465913eba17efaa73005e9a1d755d6f8ea81e9ba0c03957fb7d0b62162e7bf26f6227ac437c552e3e2f52b197504b286bea25e36524f1086775321ba5c7159a4598fb68030687abd17eb6a52afff234999e6fb46459fa0f635fef1d80b8cfac72b0e67ed7a3dd4b57a9990ed28257bff3f2b61972583c3e6be23bf6acda0ae83228ff805b31879f8824618da7b09f9ef2f7b97fa9764dd211e259facad6a3f05f8362b44c2540a4e8ad6c6cb77ba622121c781678564d759a21c4597cee305b0623d9361744592710100c95969224e196605c6e2ef108c285b4c91d4f9298211460fc7a4dbb35d2ecd769bafbdb75c8c58bceb8afc3d502a62c0ad3ac9c7a7ca52fe12e74c2a033c8d72d39e2d0ac3ea2ef6c41fe5e9f5f9bfc541f8ed6ecd25f3ed43e587cd7ae8c853a3dcb19dcc8cee6e52473514f1089787cda7187b8c726674e9df43ba5cd35f3853bb2eaf98daec2c36d1676d45c0a2e1b538f620fa0596698b4efad1c6d89ce7ae3d747ce352d0b373c30b94932ca21e0c882aa658bbc6875ba963a7167c942b5b60a673c23266b55c0ee74f922a8a508154649abfd6756a016dffbf3018b115c56e52d4f404ef4c967b6fc1ac807a10fc106ee153175f7428a07f8065d55d33224bef5add153bf3bbfa430322d2b4957aa32fb4ae6a0bf79dc9d07f985250012d5f4d99a37aa6b298cd16838d48abf49a35f44379939dc99a7f77f3229b90c649f6bb1776577cb06863765b80d77a6df5bc9146293cf26e0e48b04611ed813f57e6a32b17158ab4217d88a9a1cd384ecab90e4b85d452fa6429e1ca6447fe15a6988d8e3c53c0c98664fedbe5fbc007a1b3752c93150548792d85bee04d9f3d06ead854969c448e4e88a7d1e1661bca96ced7c765a6e441239bfb72d30a339bf61fb4d9037158334726de1d6675579e7f2287028d0b17331dfb0761cc78fa120b2320bf09438e2672913f7266362e9389266aae40dddbb69273680a1af378f8f41102a8fef3be2b6160e68194abd50b5a7445aa265e9024e2535a050b06320c9b5898e6944cb0ed681b670d0c68f2b8fc7e0eb482447df790fceeacb43ce9a2bf7b0607388b1018e318f52fc0ea3c65c9f4bd04587d1970881aa077cba817359b9277651e21cc86fea131fcb8b92276975f2b61480c33209effbb73c804e921bd16e70635839cad56ff55196b57b8de70b6e3855b6ff0b86e78f6f4b8d9acf6cdb55d6a517e8e75b312faff6f4b81da89315e89cb4a02df27bb115ee3c88c4359af08c96daa878494c741eb118f9aeace502d27c01da06bf0d336c5e6802f6ebc465ce539b4b4a518c548c49974653946ae1eb841d32e47cd2e2870d97641b0135a12fda7c4582c1f57653a9423baa2faef1f832468ce68799f373d260775f3a863585289f12a6381ee90dcdb0303dde5c23cccce190a0497e873c20528ae281f47dde5e725099d32a518f81a3dd32ffc45e888722d985c6e9e4473f3881086768b30c0ba6b49213ecb9f7173970db6fc57eca75e34cdd53133665fae69a699523ba9982006e0d4f02cf802e7892bd116e1b493a6e7961cf1c8d858a096aa224ffd8a3e4b6c93728e0179bfe2a9fc3e426b18413724af7cea56e82299c70d0febfa8cbed3a8d7e5d391e0759e6bfaa72a231db9f933c20d8f0a910be4a50ce3c50ac6fa6bf8641294208125cdbf9ac3a162077bfab366d014fba18c784fe08278b9dec6390a9ad1eac06af5f9d947403d7770e9a23c42642e3409695109a08aad1495b36d1472e7ae365a2a9458ac4c6a022be1104c9d2b94255ce55437348bf6b7ea29af919367f8d2394e85770dd17638ac99ba15b2c4d6499d2a284378734b5ccfa75abea4f0483a0246c0b697ed6e09ec9df26efe9f9992f300bfbd6c38d91d1e3763a7e94fe605be36e096c5eaf664cb4cc94fcc57d36994b913fa5676d2f2acd16bd47cf62ceba2fc41fe484758ac95dbc340b67e652cc605f14df5c40bb60bf810712934668f32b447da65aa93e8e235a82f0ebf9ab70dc54b159056f1001f97acb75a428f13830e72064ee6d30addb021f7d3f7e8e0822628bd1a0390c281a7867e5955b6b2f8adbcd5f10881639322ae676ed2128e38fff968de79a0c5b098a10a81af0777e4723fd8f1bc7f043476cc509335358a5f8af5cc9b4867766984ab89639e0ba253bd7f780d2ca387f354f19db1bc7164cef56948a0444925b2fa9e37c805f102dd0b24fa7db853d17c7d243abc5076d9b5dcf3e4ae9ff892a172c76cdb5447d898530c81eb5ecaffb69c293d66e72fdcf7fe3f2259d4be1e58e0813f1a110b0333e089fa18d96ac8e0203bfa9003dbb2346f0026f9baf5acb353d16e09db055ef3e7ab87a1b274ad2a4b5a1e1a3ebb9a295ef740e317d814d518fd8539f6b6b4b15eced6eaa283d8131e54cf05d489bba41263828b669115afe7ad6a60085a9bafe94dd301669ef5b2295730ba84bac344a9e6098a6878f1041985d0c8593b17f7107a9db8e94faa69b2c7a94d17690d6c0f787e9b18e3cb0da755dacbd08db611af23737d2014fe29067ce482e05957c8bfeeb6c6386c12cdee7554139256639024e3991caacd0cdcdba5d4fc3bc00866b42f06914b5ca05f978e4c8e9ea65eddef60cd911fd3c0992fa9ae3efaf4823ff96f336a0df6d20ed1961868bbbe25d61a6a9a7804e1c6297e16438a7d4790fabd844a2cbff07dbb8cc4d304f984d487af75dc834fdc67623ddcbd207171f47f71f1699a3f041072538a13f7ae79ff36b3d8c8764bf3d96fe2bf5e58f83c4ab82b8732cd431b4a330192ae3af3d94bfc96abf804bbf5d878cd1bc6379878fe77954ebc7e3a3e8eb62c56687ea828e1475469a41a6a0a6bb0c4d8b0976fa261998e6ccc5f2dadb52f4851d7acd1f42d7a421cf8f5464567c2d6ceb4fef48798417d49e54e7fad8a249bccf4762fe83c953255e122fb686bfd3f24a1b8a1d124bb63d7cae4b2a382aefbae6ffc1673a6a10341ed126e555235d5b5a0ec948c9188b322c2a1e51df520fa888bda0e8957b3396bcc9120218b93f23140c985ca7e4e52904dcd071803d9ee601fe99a1920349f261d01d452adecc88ace0973b14f2d7146169070bd92376409c6fc36193f6b73c4cebaa47af40a52c99e2b8f74b66e672b2b7b120bf1bb5931095db93642f2d3bebc107cc20be6bd6f4fa05539b2d5368c0820fc0ade44858b85f4d885b2a59e0c19d4002916bd86c90107632417bb0bff25a17ea557b91e4d98cec4a6636770f072da2745fdf5b748f27a4a8fc9e6d59d04907c88e6394fb8c9513e966bd7cabe056a35f3df0c2df520e12447d89642d6bfd7922d25cce9d5e8cf4c2817a4eed5e7509d823617f0a135dd0f0c5663814d7c20b9beea75c4baa7908af698ff8e8ed7f3fa7ef27fdca3bfc5e29c96d034bd620547b9de0cdfcc1e0f05da226e1edb2ebac5af54fced80f33f045839f76c9c1da4945e6e9401d54da0c3860f973376f3f7a58259b3b7223fd20af42316711297e476d0e8f9a4785c09d822d89cae7dcda5c95d07531b82092214720d7bc31b364db6ac322dd7423ded3bc99f99958abb79ce6d038a38527a40ec2006680dba8427cc2f26d700709f938bba7c3ad82b4f10612e89284a0e90e38fa87ac030392e95b9b8017f64ef0a7ff2858975291a1f4bc4084a1386c52e40a712cedd20855b54466380c1efd485a06118b54c63a16f7ca5a07f8960740c485171e0c27df8abe841f17566ec1193b57430b1dceccfad128e359a8be9d91a8f21728b6aee523dea179a85be73d6980c5b4ff38461d0fe19e21bc595b2a6cabd04d4267781fcd19a3c5c31f05138ee7296455221b11b5afa50ef7fa0d8078f93a9b2dab9d9d2b975c0cfa41d6e9b87833b5303eb3ac25830f3e0db275ffa362cb2b9b55595c2d7d0dff612b993744528e79ff2694bd63d844c05950f2c9e1dca5d9e3ff897edf283976f26d22bd2ce8125b894595fc22e13bd2bedbfd213c92b7591a7f1997814378a5effdbe9a81542db53b2203855691393576d5e39d0a71713091aa0dcb1bb0a642788da45e2868664551387bf205a2700efadeb8fd8e132144ac1894514edd6ddba4731d9b9cb9d332862522a412a25616122c99cbe33d1e464f8004a6b8a26704d130494e4022e2ef1501af470a5a9310a862fd39717c2b74f3aff33d5682dbdb7a3c38ad7ead4de715c35d3a755ec56012fac7d1d17c91aa2f7d85f19cced62a3cf99d8f416218eedfa7e6fda98b8a219bdd60ac0318f8281e018e728dd887027a1cbda2128bac6f3a45623cf5fa86dccbd7500c2f14b99d5b479d0a1820032732cb0d75206425e5b6f1cc3ba61e282ce8c326940f8a335d17c30bae21423e1cf6f09203be6bbe5015f960617af0d674a1cdd9f5c49c14c44dae050e2e507db62a0f4525afd96f7d518520195ce2364174056c4458c5fdcbb8f6651a7db4d27d2ee0e76a2f37ddc8fa0496c21150645312f41cb9bab9edc4d64cf19e91ea7196091f6655b4bbef70de7681b43f1045ed3f075dfc0a6bd51a63f447a0e1c8e9eedb534766cda02de4e5eef80b731be43d60195a117db273928c63caa7c708e72c1ef6268662a311ef97305fdf9a62c22e05d0ab489155765cb8d10f32082bae240cba765a7f155234a780c59068fe28e7792144519c0811258da601a5f8318d89bf3210bc21387ef3cc2b0921b4e923c1543e98e31c6b8d3d916ded557fc5a774914be3d6124cbceb51cacb4e20c160de78500f58e19c59f70f2122558b182dae21fc5db84aa6504f6197af6ac4a82feb4fe251fd4078b8ee21c7626fb5f6b7fa60fd300a75863adb66834022200c16f837f884d6b73ec308966b2ac1e3239eaa26b1ccd0bb433b0facb0ee3595d7d91eac5566e426170592dd7a8849c98c6a7b1f1ee9fda9476fc964264f4fe16ba8829e81b84f559adbfea490b29a3296cf536c13198ed795373cafdef37de1bd7a3af45cf0124c9ed88ef1a691076194030f6ac401f2d50c1dc1ca08a97931c9160d668f8def4fda0291c132232bab1c79ab3912c24b7755195606a81724b7433759ffd89aabe975767715d0ea0df9b6ee58ef9e8f8aff84ef1ce372cb5d5ab6533f1ccdf2cceabf66674a943aeea326b15337235c171964d021a5a4874fdd89a8c961de17345a7a7a9052aa68c8683e24958189793824391b14547ea14d02579d8762f54a293b856f6866beb81f60cc9a80b32cde9063130fa9d243972f4e456ad9459ee9d2fd1600b48f085edc4815b9cde4956042b4304ca5477d96f7b3aaecc53ed4b369c6ad57b03c68907cf352d37e0c3ae8d409220f3dcee620bd0abffef3c71908e91574c2f0829bf0fb1cf4d40c55c6ed9e0c012ec104abc2e2fe91373832f5b92049b95e743681a11dc6102788573273e195372670fd320dedb65ceb999d5c8a8039a71c3523a1c10266e94df63418c85ccc7dd5d05e6ab88d04bd3b983a575371b2c6b9402ea5df23192c2b4e9d82a17bb5d5d36aeb70be4fcb63e5ef198bd42cd410c077a6586f9a510a6c081165a3f3e13e283bd96cd18ae24d716e228c42a0f3d541ade6a2c09e04a4eba9ca31e5dc1978e4de9b3d4628366b7d0ef8fd93e5734dcdb9352ee11dba8e464851612ffd20d71b27e1d6bc1130e22cda8a0f41be581b801906283493e0755403b541049d6a0fef8312dee76336c023954539d5ff1e033153da1f48376142a8d13be25fa96f62006421f868f614c8c1b186ef25f5880a48d98746df91b467a3613e2b1b64fee060d847b26d9f13830609c151a769e69ebf915e6e4e8d2bd61be4dbf615e0d4eb5ec9e3a77a35b469984aa1d9615b43155f4d51070d3c20c222390eebd712586dfacd2dd0d68e74222d8b0af4972c139a7285f657cf97d23687301e266b0327a0911a5c2ec1a853b23693be4ef19c5c01b79977541e161ef43cb0cbf94a38a5f690bb808a06242d610a66c860d6d40d057c34837b11a56ced2daad300e3fe5efe6de95cded376332dd7a80ebc063bd7904d3fd142b807ad9528d2561d7ced1463ae44a7c488bbbc10a920dc1212a176144c806b36e27c6f864c3a6a05711785558e79642eeba660ef8fbfd93e3ec40830272cfd4f4bb514024347a68b561f8a74d78ec6cec5718859495ffe06370919517b43dfef8d0e0fed9c4f89f048a19de9983e16e4dc38950637665649634bfe2ad1a397b4f5995d6ab0bb178691d2684c7ed70731ea442aa3736f39978f7efd7c2b703d65d6227c9d47be797a7c58703d61b4b14975050f89aeaa1cbb56c9693626b4ca57771c90eb0bc1739cf19cc35952876323916f12ad95423ca5af44b4d27542d194ab5b6e6de72a1d85bb8095699da9067c8db313d8af8cdce79e8c9562bdb198394bdcb027550f99c22fecb6b708a2f01950f7aec17fb30a19402c8e43c65c63a882744451976e51ce30d3e7f8887fe113f770dc0a8936865ac20c87d5232087b05eb93aa2cb84ad23cb81b62e0d7fd632b110e5c911c72b81a7f1ed4a06789747c32dbbcbfab99f9c09a6ea22c5508d1b0f9554a267a7115379847f55bb9c6a022232805145224d49ffc95b58d98fdf790164a2bfc2bdd90d2caa0e1ddd53f00475d75fd80a72f383cba8861d12f908394b56388335b41921d19beca5658042387478c648177dfb13807302490709d4953ccbb5af4d5fcf45a33c3d5623ec2596bba3ec6b42283616bf3a5119e02dca58223a0238a8bdbf582076d9a93bc0ab315cb8d84480296eb13bfb04c8428301a09e40d1db631c11dc11859f54de029e1831f321906dcf11fcf17ef1bf2ed72f278a7440bd6d1afd59395c456447f3f594b73b8b7ae0d0b0d1ebdd3e8c705e79e18e2c06dfce2961ca89c291736f583fd97774bfaed7b743a03c5dd08f46053cbaf37a5a150383a7e4f03d821f20d1f02b096c9c2253bf730757b6b4bfbe60152e65fbf3fce2587aef5d4e1943d5290b7bede95a96a0ec97b422a7393b4b1f8cfd309abb992b076d1f5f662aabdbc4fe14e50e4eaa7c4c1474c5dff72b5e803e1ce77bff4de2bb65fd7b612ee4e30eec6390ca0343651c1600b4bc983b31eb8ccf02b369860137597f4d2b6cfc4558a9dc07fa0b8220fadd760ac52a4de33387853871c786fe0f78633c604d8745dc21b6b6872fa6293df4d64f95be31ab5a36b7bfea4b800601afd03a1d7b7131923868f5507d3f32df0d05cab89ff13ca916561def90cb40fa464d8dee29dccaafbd6f02cb81f1610115465d11c39d997be456be7a96e51db56dd0e5a8c536194f521a6de881acba7c0fe0c336768f41d3489f58bff65a1f6341d841dc90a2d5383a857f687575587fc12170f7b637ec36bf442d746f521216eecbad8f8cc7c7a2d882dcc943709d6795da67e76875d5820eaf4cfa588af94b9129c60e5a416a992f34063a6d8d1ffaf869404d7fa9e5625d80ac2fc73290ce7c7651cdf47e5d8458a778c3acf9a1ddb32824556c179d3f8b336b376547e898a2eb01393c9295ca740077fd704e8e2ab2a073a64c500b2ff9124cd66dc348ea8dec1b2d90449587b3e99ed223a6f855898c1c1c07cf7b480fe7ca8ccc74","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
