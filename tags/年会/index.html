<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c75103a7161c61ca302e63e824802d4e6c8912dd6bfad8ba34b9f7acea85513e3b71aff3c05f2e7c46a8ab5134c4503e9d225ad061c6561a34d18cb49e50db54d8490c43ee84d48d182a111f1a057f898f5d4ba149d9142db3aad966f431375b8118ec9402aac0e040837a1f462e86c0b144ddac4818aafc610a5eef757572f3e883198dd67b10c2baaf3cf19f7497e6ddffd7c2214ef19989f77be51aca24c40a491391eb424e24cd2f5f703d8d890710d1241d04f7e1e594f37c54ee0b076277d7f5ad4686a5344ac1524cb92a18042402e80c811b79e046af4fa225c46b2481c7aaa1ff36a5649968901d79cbc8d350b379e03a3b6f70071583f02b76fda246b4b91631a95fe71fbc53a6470335ddcfc4815f61b66d8720a3d5ddb0797a2f1eaf3597a15f47547c87efd828a82ba5e2dd2f0bbdc5377cefae6d9cb217651dd85ee187a9d445891d395fb210704620b1ec2bb9c085b1df9a1b5a1d775d69745b07529252fad4ed409ffb8db9881dc53c0631429c0a67e2077a4777adaa0f735208cf04e36241ed1d4478488b340e95d9d39d4db9d5c63b046fa7d1c9396c1386184c05bef9a67e33404175f343f32c1a2aa2fe476317305f761190a1d58e495da2283b3308affe914664a2c1bef2ff47f25d51166b5dec3ffd6680b386241cb95f825996dd4386c993bc1427e4e6c897dca1beef6f1c57e948b6e196e2873c7740ffedb606575fda1547c3f0c9ef31199918563b859098c11e0939c9939910e4a88f60ddfaf43360ea93999c376941ad398dad426a3ee37a6a5b6ff59df1894a7765c00f4d164434eb02248b00f35a4a68dd26c9be375c46ebb3c83d2b9b20efbe8a3a96a1c630583691b5fa6a5e4f5aca7c99a4cb933d0e705463d4a545efaf5c2e3491bb230603d5b0c0cf16c6c2d4c7a9cbef50904b5c5e79de4d0331285267210e84536ec830990b1d2356330a6dad86f2156e6c6a9af2ea809593f5dd3cd63c67e192319f075baf6233e612e57dc1a592ed9fad308e5ad274cb3efed90b259591094a7e859731f14bf0f4b5b93ecdb46cc9d9f4cfe0158c46d2f8f84b77a38f5e124e09af7d9134d4e581ef1c7547bf67eb8f65f619298b97b8bba7e680c9abb51e34fd2275402d23c9ffce8843b0a3c47b5a5ed8e882ee05e5513544177e19233990acdf751f392d2dba240ab2a87093e54729ae1711340bcf39b21e4f2c9d9fa50a922cfbcbd77ce4421abba4b3e1e4fbcad0116b29138a7eff0af6b49c1e54be295e7ac3efa3bca6f2999c1a44c19843ba79f547c41ffe829cb31ad1e733c0946f609291c0ff15015622464e9ce7439581eb5336a50f07fc834b1dff602de5270aecdbf01b273f1743c0e9ccb99090b16030223f529a0f894b759b44ef903a0a93ef78c96bc6e3410e5504df90fd5fb21e2b361a6a93ba13630bd45f08f7795607691597e0beb89eda1e7a7cdf2fd087d5eaef420d4e307cef262d89eb6a083f56e13091b68fa651a9a666d49baba289c272f7423385cc33c0ac106848bbb971fb9474a7d3684c297edbc8f28a3260302e21c62c125c5943d124675829046c505e3f40ed68d676ad253cb871a0c6e2225a1f8780bdfa52467d0fb4e3f876c637ca2e9fe525b2ad96edb905669ddbe268a30e0b8ba9401d64db2eae1aa852b1f36cca2b3c8df51f36f22f07f5158238553fc363ef25ff1d2bfd6875de0cb7476bd69bf4b167cc1a206abfe78c61fce22a3c2148a3f097772467674ecca472e7a057fa8f0aa9a12d682b967749958511be654c4da81b2a13ef444813ec12a8559677404e15e22ac0124b6ecb82f72ad0c8caf5cae7a361e7b2832c3cb513d47b40f27fce672ecb26216fc0483665b5e847aeeba7b52d9a241760177e56c399e3d77049c003ba834ba52f1450ba4f5875e86cd0c1856e66ac9ef4d9b5ea68ce4676600d226cee2321c4e5ddb30da4240baf92e7b676422d485a9c69f7a37773cbeb9e0a118c3fc2a25733f464b86efff7a5a5ffdc440e1e28d8289bd87e91e4d50fb1f7618d772baf5cbad8a085e5d29da8bc43171b5866fe3936bd80b4af5568134431377acb2980e5660025bce34ec7219f23896590d1f457fb18717a5764b25b83c3800f2a5e1603c8269ff12dd9e66af098de285012edd22d5014e5b7002a745a7023fc0933f4629f11f177821c860273bface14e079575c009353687d3e643bc63ef6bfc339a4e21906b93f11f088d8a8e822014a63ed0dbfd4016746d9680e2b1019b45fb083fa33be2cf9d701687e8f949ca1e7f5eb7522aad60ade6f96bdc42db41c4b389f9119a1f5ff54a3a76b6c7a0420ea2be62091f2a00452f1351ec1048ef6cd2f9e10a27154c4a7ac59658c16f0ae300746790ae49c1ef8b050a09d763bbda77c4ada566cce59c03746220f0d56958f920c52754eb62f86e0eccc3f25fac3885b7acd896f25a1bc15a2f279634ea83a28335cc52090e4b25f891e3d180a75513a0acdb5736bdcf85aae279bb733e6a030f6c913307ef9d7acdf045c6be8205e910ebf54bccca5b724c8c6f5a60d0b5b67961e6ee27f6f4cbadd972ad0dbc0b79a504c21fd62794a869681a5d71f016ca0d502319fdf565091322e4c9f073e879875dd28f4e8eaffb03299fd0958b9308be4075cb17d9c81b91ecf36f742f83f2e27610d8e997c528e98f8da489ab51c2b6638752983c542b6230e6b0e9b4417f2007f01e9ee161c5079480fbca551739d92868a619cb89ca0658b9ca3dcfa5d0e4b6f4f77f45911d04d9ade18aab16867782978b6cc4ca8126fa98fa8bb72f4c9d73e0de03338f907a440b0fb202e6d77f3859463b01d32f5b80ade709e736f285b62853e8c5f6cdc04cf86eef3949fc0c0e38d8283a4f2792f55bac2c305f17a773ddcc12cc0ad3daa6f8b5e47a05df5b08c4d8319fbc3955be7783eca44a2adfdb325d6c3cf875dc4708ac17b025ebe203b394e48a6ceb53f578ad8826f8fda311b62610f63d970c5658ad46bf58e71c2b43872c0a5815b9a15c3305f5d9f0463b5d66250d824f5d3b4681c23bf1ee0976a343f6e8ef7e1e6e6cde964b43e918ea706790ecd11e8f0a3b9664fd0aba8dfb9efa3b8d32d65ceecbb6c2da45cd14b552a60451401470e8e7584e49172319cc500af14a5d88c74c95751da04f9d81041c126e212dc8085f44030a56ce671a12d600bad7782be6b22f6fa180b064c156f4221a9e7ab95be109f695d343cd97e0841507aa40b35252a986d2c5587aa70a0450961ba8784d98ef8ac9f0f00564928c883d63269a137b61bf372e6e0f8479f37f55375ca28d21780c88bae079ebd1c3ba2f10e234e86da2bee416e90591fdab2faeae5842dc4b92029a12ef6b76fa31b7d271a1932e4ae057e67be062f37a2b61a30d245c382a7333e7a09720e9769513eebacf1444fa1bae550974d702922e2ad5be0c363bd0c1a8413f6bcf6fb7f6bc9a876de6940101f3f00bae072e427ae047a41e137b137c9d4bfc47b8c423255a391a66c49ef8ad6cf630ccc39356b747e863839c7dcf2765ae2aaf3cd9a016ac380a92725fcc9e403f7bc2089b9450370f232ffbdd86abf95f4fb220b9d6a6a7039b9036f59f57962f6323680d90fc77a86cf97d34bd837e3dd02a87a7f499a057f16066754ee3a1df5b3c49b9aefaacf14bb27e61b8df1c22d39db77a4359cddf5ae2e48ef53e165b559abfb9892f7bd64998a808030d93a9b63cfaa81e428fcfa9adf7c4e7357a358330448d721b93684774d06715baafd07dc0069393d3af00a5ce1b56e872c6219c6754f49096bbb543afa60d86730a40d36f69473a487467b22086d6c7539e21b62ca636e3c022851d6d9d86551a81d6188f958d3868f5bd02b1be81ed0b514c635ed267ee89dd39dceaddd8ec7d44ff04dd4ffcd3953be3cd7e2ea41ce6bedbd8720591d6fca7a1b96eb60efcbef23f64d33228e10bd3d99789800985a72fd6e2147fca9a16c4ac2fcfe0a2c9cfbcf4efff6eb8aad4ae18886f95063e28234ecd7ed821e113889d5206f1d19fd7d032c54031a427396493add9d39962daf8b79d1dafd0b67641645bfe56ae9ce74d79110f15d10b5ae0367c9da523bc6b0bab0e956d2e551f0d172fdb37957c3e2b9227306d9ea76f3293976be0dcc08c1402a7d2be204be03bb939a0678c42c13b6f8e2d256b117f8dc80877bc875b464e9169fb8709ec0202d84791ea55c8a744a1155dd811f1abd408ccdfcddace1073494b6a2fd125e9c9412ad4a8a6ead5d1a57f06188e84761d006aa99235c368510029748ca34dbeacf6565f4953f57ab33fb46c947e9526eb9a8c88c5173dfeeacb94ef7ba72d801f3d0097de723d42e23b7c19ac409d0f292026bd8f3f081e079cc80ccfc8f449544834229ba9ab1e1ad60c9876564c3d01ce71b9ee88dce3052ed2a2524ba2e9045dd07c92fca638719fa2c181bb443972718a77c1e66068377879a12e024588bd137a6394ae5b004f93c08d6badbd60484aed00d7aea6559250e94a944512aba0cf5cf1e245952d16d37b7ec906655ff4f37b329536503627684e071a6419330cff8dc395d5fd4c261329658d7ac4e0e253abab9ccfda2a90b9c12bd9f99dadb3f38ae30059d1dc17890ac070d6bac2ea0a373c76daee12099ee996b4a077d0b71ce67381c65a31cac1c143b6819a568effb3a7f61c498971374033bb633935956106fcc25c884f7beb142d395d143f8f2aab3a259b6a6c1a48d0bb6a5e7bcc9708ff5de832c1c3e9724bc5aaa03bcfd928024c749f76fd9d76a643951223e6fc30edb6ce5b4df368ab8f6f9beb1a9dabe8c83522bbbf425a39ac1d1027da96f48dcc6eceeb28a038d5ff6ef8d6fe957fe5543edf7d35d0d542edef608fe87dfbbba227162bbdbbd7bf9d8c687eb43b3130af2a3a3e5787339276a689cacbced450c3a8d1812717109badc1cf23c174995fb37dd562221b0d254c9d2392ea859ac276c3d27d580463d4b332be230df7bb31355c785e5aef602f0770cdd896487d68b27f8e68c8362717ecd88aad7115b27855f6f1b10af24ca2a96e702a7221dc39a49555bc1f08af2231d215ac58caaad16a7918c0788c08c7c08f7b31539e000d0048accc5d98f2247f74cd738ac61bfe35ee5ec250e48644b8a75bc066fa13174e671c59d85a0029454648b07b16df6398e6accfcf1e3674b1d54f5b69eecdf890b1273f8cc54b62878da11ad9cb8786b9fe2b04ad2f4bb22d444ecd6e31cf51c21cdecc09123b99cd020737cc9814cae38cee495f1703d59f88ab212dc09fa8f227c2100c7afda83f2735927e1240a42764392eea05655c50a01676e9b8ab07cc28845511810f7d9f6b51ebb76575bd381badf4a47c71a97eef0d9d14ea489a3ff5d38eb5a20425b3a3f21921e5c426e7277b72197aabc29b331f6815ba5f102a6483912b6497454a433a2a90a27a37d25a491185be083d798d9665c33751fd60b45437eff7e78822b0267441e0ab88641455db48a51a8029936e0643cddc3c8ae9db15a4f4c6d006f939bc5c623ca20bf74ca89ed788d8a945917da2dcd542b8a84869470d9f7ba041ab5f852ef98be92fcca2baf42254eb28f9d759438cb65bce8909e9f98a1219d097fd91db8344f91e8ab994a0a2d17c5113523402dd690aaf701dc750b5f66526e2437c81a43aa381f9cc9e47f2fd03753ce6c2c241df7de456fc99c0770ec359c905d854942268d53b0a3a1b53e683f0e8e06bcc59cbc9ffc192213dd9f32894bf23b30d4186aa4e702538fb68dff11fe260a9a494afbaf9af3b5889499e73a8445a9294b0d83026e1a3e05996e7e95ffd5ca66450aa6b65e5fefa712ec936344b78d5c9b3a6941e864f10dfcde3d10e01a9181717d4925f8eebbbac1c32d24f531255e4379557a60585f68825cbf6cc3356172d094d26a494d5f26e82ae82df5eddee33c06c4443f36238b11ff28a8e31d5353c2a769bf97440c94731d8bf89bf282a39b524b92f9689f038991eade9bf1e7b42d1cf644e51c6bd5e5b365747286796b600730525bc9437fba35579f1b1c75e1e462a2dd84a26dcd06bd2da71458837038b9a7ae740f3b65cd514721ba9db27ba30f4008d29c12d657a32393734edcc36de3f676785f08c130d654fb57c93d33beb7cc1254a6854ecebbb8b2a64897f8011055a36f87bd016f559d9b8ed1ca2db23446b7417bb7458691dd860b2e23c6fe944616cffdc2f44331bd3a77e7579f2d9d8f46613c464833b6acc6d30d3acad39346c1f5b18b475520ea3175c27dbc0d4398416cb0fe4c005ca8e7a68cc62f0de41723b24f7aabe7635dfdba5bf53ff52d3f21d9acd9224ac0a990deed17b3cb42bf358468caed38b09922e9e4a94fb9d72fcd169cbe71c484852b3e8e4877820f894368daeb3a9d3b93caa01d5f3cc4f6024b4cf517184fd6f32df495ed1a11d30fc88604867fe3c19d98700416a93cfea31db58cf3820f5de601a2e784d990ae8a4b8c68e5140364fa9f3831e694879420e4c120e7cdd12295666cd837ba37324d04761477da940865cb2a825dbb4faab6a4b04d56cd73015c5b10e188893ad9bfa53d0e197845cdb6719f5a98c1c5a734e8f1bdbf8a4714e4e31108e687511ae6cdd736bfa85d4333a8b0cdfeb5b0b6c285e54ebd0d9808726fabc16b853c201b5dc09deafc901e20284649200ace4d9580c4e9059c0c75f6c42c4398cec5e98b9d2e4d2897b089b35d1266190f6ff93ec1a9d2de42ab2ecc471d5cae6f8800ac4bc0ebe9b75d6742638d1358e5b2f9605c4f24c92a625a3a9ed030537e5f263d2823e788d8a1d89b29b5cd7b1c6f25cda8535a65a74e3e74823687fe2fb2cdf1495201645e3761f45c490486e91fe6f61f69d206d82e61fb6176b38e9ed3914570012b5c323babc67f653e0c9fd515d615012cdf7896db07763a31b406d3504056204a791c4d2b288def8240748607cd39f00c1a020788c53987cb0e13899fa608004cd8bbc627d5ddbf4692406eddd1171f8bb90e5a73cf8368d999031b8199c8900671ceaabaaed8c6ceaa92a30684ba4103d68512d2bbde41e06a4038b8f60176d9ca50ed8669d644f439d6b3e97f889fd8bde266d1dc00f2459111c388a78101c898257b0ee99289deeea529fdc6440154e858ccf0900b0ade1caf9c33f2e5454651d369cbdf7fbe06da13d94d8f000fae6114d7553bcf88fcb398a75d5c5122f2350949e9e374f0b631a93b32dd40c0fc80cef7ecb45f8090e92a51d9c699a5767a04d2271023058c015b17d7da7523ef0e336b573b6118abbdae8d0905621b0e0d1cd84023a1328158d20351b63d5ca67f8c2392863718f42e40a3a5b85c2c8db28d4f1e4ef324ed80f902b71295824040ce73984055eb9bb2c5fda7b5e8e69b15bb5da205454ee2b8beab8f798ce16f39eb933eaee77f0d09bd021bbd1b8f9b91ed6c066b12a78d0b3a80e10b2f4587f85c290748cfa4de0553af8e819c8bf42c94a5288921de6c8c49d27e7acdd8185916b649bf5159a8e138a5d2ef6f428fcbc7fc4d5e30985ab67c797bca7d4b78d6aa15ffe808f39454549d1f480dad60519d75af8243a256de0b19795fab9620d40c42bd8eb4656bd7ccfd27114c7c7edee3377b60964f941883e510dde58c2d3a3d1bd0164ea5d710526c6ec92d13f202578292236077f02a9587b7dd991d84f8339c3e6c24d2c92156d7af4a429b5f276aa6fa4e3b8219e5b32a19f322727e0f193df588fbecc005c96b461e9733297d93f4b2b499c20fcd78ec8f63c465ef8e0f1e567b8725e4affd8a880f9f74e5cf6221f50160a674b86cef0f2bfd5a03a2b7498629a76261e8a950f2eba069f1c018ae5f00f1c4cd91ce5bcf9b82b594c5ad16ce03b6c54de4426cce13b3d14e7675e8d5d3e4e0569e6a018043a63c57258f70bc9af9abfa88a6bc3b89ab40d320d35db237d0044b7239815353c2750ad2af3810d2893c4cfadfccce14fe7fce5cc4cd5f70319d35768700ccfb1052432594e3ba244d808fe762e40939f312ac25165c87daf26d981e7e7caa98ad743aaedfff82cdcc56d571beb1d1d580f37f10fcbe275bfc2f45ffa47163de656ec42ad2f3babec3061708b77d19a3da16de2b12350504f9ebf7054ab7673400435c6fe1cae350d5f0a001115a5976d355d21a28689d6a594e2741f4de955f37899708fdb670b0dd2c538405f262a8905db21cb8b4d835bc2f373e3738960104a8ceb3c38bae50ac04d5144c4f1d3b61a57c5840de6da0e8c1169ff3310cd169c4c635f394007b475866dba37ae7c905d12d3b07ce7b0c4efaf218dd6465ea41fcaec77fed1a087af13f790d0c8cfb3722e8d26e9c07d298846466f4a76f59653b0086705acc126e03845be6ad86251b4393bebb2d2a27fe1fb3807d254c5c31ae83b1445c63409513f28c1d9f618b4964ae0043a1207f9ae67651825b87731ffdc0ff320b65f64fdd6688310b7686342cdeeee55417b77249686bc4d93944796f67555e36be6fa84f2a38e8871b3c364dc2ba81c33e0e6df003cd195f16eeba9b3392f4d3ab46af7cba2af1db87a069f6f18504e6a85f87f7d1fb407478424dcf68b8e35e6dd39018ea23b60a0a50a0a9b76107ee3662250285aa9aa9991d8ed6f77ddc3bd1a34e6e0f7093393e6d4fc7945d5f08678f0922143b72058638608482e0e15fab729f688cbfe010607c25ce653b0ce3dd5ea8e79436e6296a20d84cdd097bb8427b0194963cbcdd85b4903a40f9d218b7609d022ac08cda083a9be5d885d32eacd8645bb7981ed8461d48f5c7c21ddb6944c8ae1d6f41d3ae8626b718a7f2b0d155fd843e8ca16605eed1e5da9c80d7868e610ab54294a96e7776865f829117860da244c9d58d934a0e3884e0bcdc8b2e2d1938cfeee57f7d7ad9a3d19a8bead9a9cde10367e7ee230cd13a9387b7eede2beec00a3adb9f66837365cbdbd108b5bd361bbb658c45290ab1059cd64079cbbf39751cd3026b7a58036ff8ab9703af1f685515563866f7ea7aa08fe6085f372625f0a6b98af2348dab6c7f13c5239075542aa825deda04798ed891b4cfa5aefb315e35acccda18aefc2b34daae60292e255dd0fe07a77226addc0b8ccdca6d61e0d26f61530f928e80ab1bbd3e63894d42884946e8c1a9aa5390d08b056b74584c7e58b36ceb64497d46f103efef185118bb50cd28f00ef0897f26915770e4a137481905bb0f45ffd6b38db53aa9a1310f4954b90a427975b0ed19abfd35fcd693ddeac83c0f60bbc58ab4424a1336b1a381e1b288478ca0de333eaed78126a6f0e605795fdff97231e0746ca18315c40ddc8df196a4b4eb6c609eaeca2b53723e5c8952e1ef7ff0bc47dc97ad9d1af07d881e4cb32351f5efa0061063b28e369a055f4548e66866bd000e0cdf66f7da7c5e56b3e04045882f6430c22799568e816ed9a1003796ab1afb3811e1a605729ce14ba6466057f2d17d7de16087694ac3278025ad50d85c2a71ed7b85a1d69826db616c0f18b1c692741ed97f552df25e021ded906d79b30ee21e1cd712843384bf0fda715bf2d97a6ac5d668d51f16f93386ebeea2b3fe71e6a365bcf0b1071ac408640541415cf47bf26c6a56e28e2d9de08a325c96b60701b3ff320185ba382539f0eaaa6e30098019cac6e5addc260f2fcc386e7eab4903e333f25a6ac7198d7d0d9ff504975e9e6480d8b3ba6c01c900612be664213658c5e49c017b17fd6844686565a7cd5a53b641b7a50a7bce004f29fd7a4c6618c563ebbf9ff1dd79179b3266666e4a6e28bdc254dc6c1ad0fccf9541a36ad794d8c8c8d29aa4ea7fbd60e47a8a583dcff6a12f9e1b6b1508bc14c6ac7ae9a4b4903ef704b4a65a4a9f019c72071fcfd3617771bad12c965c03b9a4041947f46cf9b82780d35af8501d7d798957dcf7d479f0378de132d545f6b9cce2367f726b3b0a674e113a733be232948e7b9425414eb0afb9837c9f34252a13b38f614de0edd342dcc63a09bdb93d933a02737eadb6d80e9b524aa6647a6cf663a248d711ecaa37f8065fffd467c911fa450a538d4f1ed96109cfcbaa850eef3e664e3e17789831feb71f17b8acca30121513f0c26417e46dbe4730374d0fc17b031f4d7f6a5827c1670545f1475c5fac7719b7d3d9ed5bdb178ec4746338d8c734d81e576fe593c4f6baa17fca2a2b4c630b62bcdaea9774e461e9383381eeb290137145d8dd578d59f7df56386c94d0e840addf7de785962b3467b2d59acf6cc757ead2e16ee4cd4697532b86ad7da462143","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
