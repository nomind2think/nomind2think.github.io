<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a09eb9160306cca66036a0ebb1135013eb1b87f082d3a43af252cb9f2c4b6a44b3cb527b7b6c40eb2b9df927be82051ca2188ce417ff40a2d240cf72d5d53ebbbd52bdbc131c11a061ba2603c668cfbb588e058c76bb5c3900bceacecd9093f793c83d42df8dc141e51788d37665b3f09625cb22ba8c1f029d9fab81c6bbe335fad78446a6147568536d85eda97fdd0183b6fb22e4a6b5904cddeb16e684508bba0ffb027a2f2f440ffc4e4bdee59f05843514adc5a24f285ec4b95bbbcd4de19a821647e409405004491e828c8269d1b39fc48b54d940269d693568ece06aa21aa161a88d14b4beb9edc48f254e8f7c18b3ac3a2b7cdf16c894b9e3342751fddf24d73030fa546386464e0042c084bbe422243e8e24ebb197a1a0e41f3d95550911dc54e5272f00e4e7039e9c9bce9ed709533e8cf788e9ebe5e65a52fbf8593292ce4c216425d81562224ba91174435c195cf9b544a13d3ceb765d1967d7e6681fe1e8c801f33e7aeba0291ebf64130b00149d57c12b874b1898d1515805b5ec8c4327064a9d4fc5c34998a6c269c75f4821ae71e6755c1f256e2e6007546db65ad1c2d07c40021b5c5d73ff6694d9be0faf614f5b0405d8cb3c0e2730c7dd561c2be28e4b572b4dbbd2bf900a80ec9dbd523595d62d47e2ff1cb8bf861e8e5b0f95cd602829563d5f774895628174f06f5e3660ee5b8a15e159e191511a7874248950024180289d798177d8e7cb9999d61088df51ca4afdefb744d0f8321f3446fd931c2f699713a6b4ef8cdcd5f9ed8fed43e4b3cd6ac16c609f2ea476981ee6a287ea32a61fa97135785457c98591de42b9211af4bf76a54a809a64af9049bb57bcffdfa12b41832e6c31fc1dcb22171f73f57d6dfc5b1cd64396c6ecbdf1482dbdc7435782e6f3c885505a8012bd81685edb5deb1c90c189188787332158f30c03fcc6fcf5467db64c2b929fe1aaa2bbcc32e68629a69c322ca55e86ff59badff7bacab59aa36ba033730037b422fcf954835f711a7ebc4f1c3bc70a97105374dd4c07c6ec02fb8a80ff13746e8d8bb8d85c82a11b5971e29de2c10ec2a4d302f75209ab4315737d446dedab174c224b73d64579307b442a23de484e48a524967f171e678dfc30a82dfa9cca1af8e85b51878f913842f7635c7bb74ac32a157e710cdb9087638e205ad06d4f0c058a6c7299143aaf39ab8dd2f080cf7b38ea25536a3d711f622524ee2fe248a3d4bf616e7e99021ba4ff0ddd523f520348b57e545f0ad6f6ad42a5db5e1cd3478c6294af115708e1f55eb9affbd020a1f3966478e10be52abab21f39947b3a1d91b17c76c4daad996d7960478150bafd20d75fb38ce3b5cd6da1a87c28eb728e020d5a2a109dd26754e0625ca4bb71cdc76da420903f13821b2881d51b17be18de885fb9c43b4280ba3d8849d26085d1250ef2e6262f6cb33404d4b5165b9dc402399f9bfc15c9aed73bb8e9234881d6fd7673a5b3d76d7ce7fa5216d5d859f7e78e04d2445ac8d37b5c82dcc6ff7eeb0a5a00108493e185bbdf625f9a44d5d0d0510e3d8f4a4057ea7abd50f91084e02c55a644f0bfaa49868e4de1f9d550daa74c881d48a91be80bd1df5a044fe8bf8b61513d017ee3c34af64c7267fffdce708f8bcf9c00d60b2e3957f01523909948f264564257783db88f475264a9ab188270f827190b36ee0fa03e071ceeb599c956077b0092dc8fbd38ca225ebdd5b8c488c90ad8d7efbdf8db8069689e591392806b3c9fb81bd310b1e4fd510cdca0b25117cd4cae04c114f030cf4e5d0de5fc6966cee86f902c2043dcc4be809533b78a7b051229739cc25b9dcd2c9f003a1275f4d080624a137e439ffc8c8146f5cd2a5f40420da0d4f48a17923b7c07d333a2ab029d529ab15b5af60b3c3ea78b4bca2f388541df19bf662bacf30cf5997adbea8d261c3b61583f1be62e3e5583729a86cddc1045005787c44c606c8e41d5b33b1fba3729e19c1c887aab566417c0543419954b60c4ba7a2413796256863e6bb19944e15a60a69db62669e7b4ea4d32f6531dcbd0dabda08226613d9c60e985ee4f9aff7c174a75fa9804a4e68ad0ab5fe307f19bd1343bf146af82b175e0e422154c965a7a55e1be4192ebfd7ebce2b5ba3c796572216498b9a698948c4d1798bd715122da7407f5fe2ba21dc3d444551f347bca3ab9a8cb17ce928bb619d4614c748167055c6199d2a2572a76dd07c96ae20e6f73e32a768a93a0753429b05b81373d9b37e660adfd9e9ffffc4a078b0f22c36c1ecc624f0a6ef69b7e68312954a30525ef4ea9887b77ab9325e2fcc5af6af3aa5237876b9fcb372679dc3a7ea91a6e79f80e18bd9f574493943ccfcaf08a76f85264a2ee033a84bf132644e9ecd84fa8541f61cc3e199063eb8e06de2fdab7df1aad35c9abdca750e559a3f92860cc864209efe642770dcfa3c6d39e3a5657e8ccd9b5a238bbff8b694e850924cbd69ff7ae9bf56b4189243b4da4f10534de3a313c1d43e532afcc0e7824e83d57b5257dbe2785fe75ee8c4921861612836a17b99328578170fc885b8a6832bbfc6365edded425924cf5b98e52ffa29d17fd8e2471891496d25c4639b08544f47e75124e47cb4498337b4c950d9bafb73855d3fdfc4f5e6fdc12c19f83cbbdb4949b0cd8809fa88faae88f1aa207cf2b6833c034633348387875771e06f876d1cd7cc7206f76f22ca54b4ee410bcb811c3556ea9535b144a5d14d6393f6b0ebb45f2e9b4afbdf11b211040dbd98137198925fbd93676904e3a1688dc30ce4cb20d0333728324b40cc4c631001014652487f14105621a396358dfae86c7508ba6e595dfe51bf78dd4b1befca9f5c03c41d67fdab9fe1dc1d26df66ac98b945b6c501acc3cdaa9964cd16c837ccfe2aafa0ed0716c8a50200990ab2c956ae12391de98b96ab4cfc01160e28a5108192303425156f41e066a392d9e7e768bb63d850a69f514fca9ebef13e7b2039694a7938746268cb20bebc429f0d5d7694326b7463a100666c83b95010c8af04d5b18ba80439285b619d7750a7204fe6d4381f6ea54bc3496c82a8223f8558f4568555f92ce667c21d53edc63c54c2fb3ebd46f6ee1ae2eef539e4a0918e144592696c3a2e3cfa6997657f3abdb4a0d1dae317e8fa3ce1b362b94d828024622b551c60c6d7b1f307f5731fd0dba6eccb33fa4d29c97b2207a23330265c068ba37bfbf26b9211a0bf7b4eeb53d7f4def0dd29f516b6742ce708c286061f11bccec5353617ddfd9cb8bce3f14a18995fdb4c7938a3e3e96c350a021eba4d2b0d1cec33859bc184ef604e6bee3afa8786183bfe782f1d42cdbc18544c6191dbf40530eabb8cae82740820ae12d6e4b98fdc31ca69c90dfa7a7655be0b9c4f77198a373d74a49a717598561c6ba40128084a48a5528bbcc0b9d692b0f3366dc51f9dea819c5c085ec51412c345d159e81b21777c773a314b10ca54b051d052b27751f6b2c8e162a09fab2a0e56511c4a6d70bf5f876e1ea04d0a0ab7ae18f86f01bfea0b17791a381122d1368c113111d7cef5533785121987b9b9d7282daa2e457432f1f2d8101ddc2f6b77b30017b93783959abf8f9aa437ac76fdb742feb8529829703fb3319f8b743534ce9571cf3594aefa1a2ddd826483f30a986428d94d124bb9b56382b7430d181d381aac7525e48defad6e0ca0f3f9d471d759a4f8e46d833c6bdbbcd4a186a99febab5aeaa607be4069e6c636659ab2a14912a94002351b47293d4d5f607102439f1d80227d9ba0d2739e527cb82105af3c6552fb0ee093bf17315feb8fe9159fc1255cba8c5b05cf1b68ef3cfac6610e4a2ef20af93e28e29e6b5dbdc4b80864bec32871d12640e7ef5dda80d4429be48f219bb788728d4906357940a13097cb1e338a9889643d7b0156d471556dcf86b980bb739200509e9a2ff76c41eb7fc987168c2010b46b9892b61a657f9ecbd5fe5d2b0a08c5f50de1e6bbf87a407c3cd0720ace96867acd22d3a543a374f180c873b2249b47021fdafcbe04710ae21cbffb39a67761b526c82857cc7932b1ca17ac405c399e2dbf28b11e5f9f459aafd9fe3b1e96e3eb2f8599aa89f135e1b3439703ba2dccbc47c44632a274bdb6635e4c9aba3f7795548c820f3bbe2e82e5bb5e5302525b7ab69458bededddd5f5b4b16930dbf06a8db27eea90cfcf0a99957aa95a40b5a0593b7e9ea695b6c254238902294bc6d0de63daadb14428e00091c48e4f78a0e4678014b478851ab3fad59e8e061dc01dd1e0242ff89e1296fc37457e8fe7700d705647bade6efd6982195ecf63548cca401ddb90fa2b4944fd8ff3d72985dedbb5c05a7ee56570352bb14fbbf9f0849698db4c90e490de9c60a7dab4c2638d64535bf0513a1da82d49c58464f95a147e57c64ef1f493a1658c568cf21e9f69a66a38c8eb68dd662bd3665353b33d97b2dc1c2c2c54d526aa59463dba0851a762682d8651d48ff3ef5670ccd9379b76a607df806f7da15d49d6923dfa2865a5de01aa9e48b95d1fdae4c40e09db7d1b13d0af27d34ea1fea6ecf4064c41ad1d6724679b7ba768708954d381595dfe36c290072ffced43450b983e204b32cfd6c80d4539285c3a75b81e07b89b69d5166618ae06a3bef9b47ec22056dc2b53c33084b3be761fb48aab093db61f8427088afdfa6d910a9daf2fa16094819c35913fc6b9badc1a6672420eae2141a795b03932322f6502b41286f1aead0e4f8c4b73f17864c3ea2edf105d6167d85b24b3d699d07bb83c32f24d26795c6e71f8961964293a220bea0a0cc58d1b3fa1b60f4208ee56737455b70f3c695e6d1f168804d2053ddb58845b7130c1aa5c3e01ab6361a2cf1f333a1c5e8cde19af95f98e29ede3a97ea1b9f53367a0ff6b83612a917176a9e85cf04a77b1b6bb8756b600dc27b89aaa298648d266db7bcec75ef0c8440d6b19ddbd4b2836226da14ed4eec4eb98ac7356c20ed45b24389ce262ed1fafe7fbf4408de98885662f565ae997ccc215be2f41b29490f1157cae3bcee1b07c25df026effb3d0c45763f3c8a558c7649305d5d53873d6678bb798180f003d686c2b2da53b612611b0e58ff8bdb34dbe0ed2c55b999aaab1fdd1682a380f0e7901cb2052816eace3cfed4036f5a2026fccf366e2797428d50c694b95e74b22fed681c74d50921469b330c4305c9cc0e3179646929c4aa81d30cda343ccc72b1d9dd9d7c4be29f755266cff756676513959dc2ef68cebe78453f4ec61f20950ab08dbf76dc632319e1a1f786f7bafa187d5e659d95d858b242c7a1565187c50b6974cafd36d405ea0032c89e808ea3a3333b3e3186269f7aa3cecc05dbd7941f9aa5c27ee273b8a481afc7428cd86ceddc12a67100037df129a35bf2404ae1d5621546633154c382c6a20e8e7d242a81ac1edf6fcd54eae0829755dee58cd2f7099d6e7710ff2f37ead28accaba111fc5a29cf29c9845e254139cadaf774b83809f0595d0f604a63ebec2df8f72de559623644897b4e02c3fa3740cef7b70459526b147f4a79a61f17a4ff44c53f5af63c31ed221b50883e5b6b14f363a6ab46830bc8d55caa153ee82f47de7127a99bad09a2a0441040160400fbcdb41daa97b6b5ca15010adeed273f3c17c557aafd2c51558a0efe35ac0a7d04e0f10b6c198cf5aa0c07d1961a6ba8f41fe028b9452936552f4cf15289fa9ea23a18a606ed1fe4140146d968494a0bf4fad240d9a3ea2210f88379aad592228aa6a79cbd3a81e1d3e1fdfbbaea0f0e3267077f52e84f967983b0487202fb47a48d2fa4a036dbdbb311e27ef5f7dfd36d9096dd43d32e1fe4de2d6140f2816cf1d55c37d97102bc336d05821ad76c8026d9e5a5c8b8750ddd8b18faa7c9686d373c0131dd0ddd0c81847bb8bc85787b92102f210fca5333f8fa4f935434db998df616c1f32f7d9d9f32ec3b45dedcb02ef8b5fc766dd86b9b56f4bbf1ae02267902e137666e3e556a93d5411b9d351289bdb50524258c8b07abc9eed3f37052b0b8011116fbcd4009062b52e8caf7db369f87bb55e24534440c7f36d107131a2acce88ec59421bdac478b1a1160cd4fdf65138ab2a31ccc81b9f00cefdcc2176b427e638ebb5507ab2c21c55aac1e621a3a03b72fda5a2ed337d695126531607cf841f7bbcecc4920c640ecc1579ceabed687e11157c33999a8ee8d2831118308dca07c35ee7bd39dc447541d6971b1479e8058fb06225a82c50869b296a3889641f1db40cf20293eb9f9e6fed204da24f39ec023030c6ed6cc89202c7e3de61a697e6c6f62ec5ff8bd836d7b6cda6005c569a2b5734390de89df8e5ccb527437b68ce368a4c06238114da2bb8fdb8cc23d7112476b7dd567846c32902767dc276d4164e7f700df6a6b96376f510bc0ffd13ed64cc0d48fd471b3caf335ab398a41db02c1ead06c8323190487794c4fc5e251df93b1272fa9d851070bbcd35358b68ec15f38c6faedbd78e346c711bdda5adc14175b29c9eac587f87581e813c4c69e9de32847f4dc47a8d7fc4fd9908b407fc84cb551d3c4225d9986cfce6eccc8e982c808b36521d30e6b322da211897ac2faccd44be33a0acdf324d70ba7f19357969baf159cfe83091291333abe84cdeaa9b6544754681ed97a01323fb77406fa2b11dd11d87eb93ef561153ef212d9f1b661691592c6f7d46c27a06382d58c5f386b9b7568f5027fac4c37fd3a184fd8005aad0551c7897e383a07408efee54f1ee2c1ca66d1d17eca8c03cec3e7b2fac33ea590c232f8c4731eccc46628a5a921caaa0ae1e587a0a77c6a13b44d8b6f4c56e7c8b5e13840a3f26744d29a09a18330972dcbe859753bc9f047a3ae00e19da9c944640c01841a74d67081cb6dc77fb4b001aec6f7114c8191d0b69fb529231ff371a50886a52431d2414a04c36408cc957890ffcc4186a87a16425afb4811be3da2231f6a39008b38d34dc240c585b6c3ac7e57e2f97f856604d1e46ffc81b1410133c3c1f8c85390fc434e9a889a39566d60556e5dbde4fa17b94d1e62676c8bcb987f0755fcb35b96f41204b41e18726e2836fd7a5e735db2514db9393ebd5cad8fb07c9018c975e50e85eb41bfdc5d3f8c1c38cf4e5ef67c23e59d93167859069b97972f2ecd132701c1336188fa21c8baf337d6f93746f76722609738220e8e7ec7a437b988692706d42abe005ef20c689af5d083cf36fbe985ec7f89b0b74d5592e2720cc1f624a8ab19af4e2688d3c8937c3b8b84ff07d328344f46aa3427357d1d1f0bf81b359e2ddfb1e5a48ee4012985be70a7310e12db0f47425161dc80d4b7fbf3ee4e9638c880e8490aea1b468ccc22230c342ad129b0b68519f90a3af0e6c386583dffae7e92e78542027e3f6c1f9ad21616b9b8deaaf040509dcd5243d9ddda0c905b35a32ca98b3e41025b39757c9512be353181ac162a7130d119825854f63e864ce0841c4bacc01a15a4bcfce69f08bbc0d9a34f64cf1534e5da3ce6c3009c6816496a53c4ee2c23cd2eae2d61fb2c572efebc01ec0c688848771ab6572759a1f02875f07f3b7254c2a4c13aa851f49772ef911fae1a57a2f8b0b1b923ada785bbdd97aced46b56a9a9ec400064d296e95cc770102beee695306529a69dc65adf23430803ae7c455ca8d5937dd085d84e9f6eab4bbb1a49b057014ec6cb42e480ec24a0662126ce5ac1e4ce0cf6dcf35aa24aaf6ef77255a6d780a83b2c9a2005efcf442aa41910a37e6d80a91494686d8b098c1be010d7c25980cf30db21ad3139f3a2815bf8a0f5ecd2bfeb7788efe9ca4c3fcda08c753d8342ca9fb307f56a0edae46a014cbca9cf212b039c6dcffc9e8ec0cf2314b481e7b8a04b6f6bbd6be3e6f90872cac189cc2a316f1e49b3ceae4b936220a1db4e4b1c5f15e700cde59f50657c52d5d35fa6d96336e987a1a78a0455dff34a756661eacf32bda079ff33e1fe430db225c7f9f9bd474262965944363db171e58933ed78a20e364bf01900834b7656a24f90df1e106e741cecda1118f13b34f1464086fef36313b49fef0f91d93e076c1ccbbdea62c4fe7eb3173f3e441c459928c3d5bea766c65a31a2befee03ecc8d24a0da5a4c97418c145acfd2c45657c01095e388062a712e3b4b2d29b2cc0745a6cbe5980cd8fc5ab2b464c38c58fea698307a1b6ee5dc5e612eb1da1ab05cfa7101dee23dc46286c516a0992ba5bf707b6b5354db7f21f632708cbf969c103d04dedc059cd3137b17115b8ee13a2e0f9d3c262de104f52b970dc8cbeb6f68e6a312e561e9038f7b54016f9ef848ecca5d30d00c859018e3512bcf40c1b4317ce93af5575892d1da8ece620ab64998e206a5052b6fa183b73f457ab16a5629e1c7c65aa54aab631688bf36ffa6b9aeaf2e62febd0e70d1ab767c96eaa31443579fef405d43f20644cc61c5638f67af97173752e73ac2ca6bd207c04746b7282ba971fe9118ed06a63e736bf8a614f3f78fcbea9822191c67983aa84118fc40512f577e984b5a8350b9160d0170d78dc0e5c0803f5d2d5331cab49576e3d29f4fbc3e9cdaf972c119d3bb87fd13ac64a68278e1bd65e1d1bfe18539b750e6201198ed4cbd991af25b4760064ce24599ff584b42c70bf0fd570d38806e858d4f06f2ead3be3e2403518a00c82d651f98d5e48c99c8ef4b3f2e86846d3049ba694966f9d97d0199cfe34faf7652bfd66997e029051fea61f295d8f85cbe623d901c790d126766d67e47796cd17c3ba67db166234306882e96ab7e42a669a7f8643ca551049f8a63bbf45cd7da86044564b95edf6f6d343adc767fbf1a8cc8873d2ac814f3e482ab2f29f460bc3a1b97abbd57309b4c4132e5dcc11eff37f2852d7b73105ab9537b415ef1cf64047933a926fab0f379109c3d9476f294d3306f815e22a8082ac891bc24ecae0b983410b3adbc86f7ea46be38740e741592eeb4e246ee240e250bb641e56bcf5c5524da04855f3485e23385c77d4a62b4982d90e8f9a58a05af11a7d8c97b1e62636c3d9dea7fdc30f1f287c079d3e286082a6323dcbed54613799efa3cb9691ff8316f6927439a4f9b7a5eb35292b3a3732d47d628c31827df0f8377b889d0c34bfee9b250","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
