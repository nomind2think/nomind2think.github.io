<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c098e2c15cff5d2129e8c0a7d5071bfb61a1dbcd05fa812d0b468516dfc7b3ba4654befe477f750e20b0e48d4afba63f37b6028d80b18ffc7150b9b90db84dfd01f7e25427d6ff06ab00b4263aefedfb4bc8da69d2c309ca3c7126b43329db2a60b7ee31f544001523b143c59718a9bfde8caf0e220bd55101faea8f9b4b286d79c7436fe9f57daaa633abccfdd2e28ced10610ecf971ab1bd586540767b5a87c7f48d8ea4b7e1fd907ffbdaf0bff1c0eb9dc63701f0fa9c475b867885dc83784640f0b16eac252317b275e55870b1af6d58befa55351ebaf0022e64f7e799d9cefccd31e16792a70dbe609f6a34ae5d9c1cce5d4d2bdd40a89ce0fc79d1d9a85d66525ddff9b275d69c6feb310437aa8100124f2338451f39fc929151432ed884db2d5e59b7aee3325a139dbbac30dc0c57d78094e44322c59fb257012b3381ce648142422f97278098fee3084cc333d41f4e693741ed98bd87c40bc386c03826e7d619adf4cddf4d886e33b0cecb75787d64032422dd24cd30c1eb19dea12490d30412df711b91e40241057d14edd5c5a889f8b313bd3dd8b82b83e980df34940396c8f6a3d0949da4d04f68ae33e343fa380f9ee0f2670c715692a83d109f94d30e45b64ff8e0d5bc184de41f03a69ab82dabf1189feb4f1531dc7272094e82477917d32c377f373c8cb8262a83fa48e2476dda0b1137cbe7703f5a74218f7d535898cea37153c64b603430d8b22f76fed8bb18ca7d5e7208be47c8aef273bf34d9d19b9773152ed77e8fb141e67cc1d3369f815ccdf847f7a42146d840963f712613f79f2e5ad1a71c1ccd9f8a6a9e5b7c38720ad88000cbd1d197786802cc1548f11a1ad44aeac6e164721e45c85df59a22a30701ef267776151e9592c16803e8d254d09dc01947003c1eebce3b2b84b7bf2fd72a8fd86f285f745e90e4ed4b1a352783f8791e77d11b586271e342b2e9bcd1e360007c9fd51d4919e145e9be54469a029d45610b50ff6e7bb176f7cdea56e30a4b548ee466da9704835a63d25a8388a8b7b966cc54520f01be15afa0a2cc431ac62a93b6c3148b8dad41a4d8732e2cc8a654ecff5c117d1bd68a92202143ff270edfc79760583d10d0e0e4a2af1bf1ca9ef10c9eb1efc9c95e9b54072b41448617d28d0b4316db6b63e0d5d00c7b925489624bd764f0fc02f4e103a3b86caa6d7b8a74cbe7257980d92980c185ceecba2f20fef0aca013f804841c90f9a1c23c7e367f868866f31bea7411c4596e762b5c932dc53b6085f3c3f202dbd1abc674d3767964df201b4670be9db24e5f37b6589ab8b17b5d5e8db9b7d9af3c482071d651fcaf68f5ec61bd4b1d3cfe2600acc9c5e3e49445c84a63b8a08c6e5acb845722255fb145f98eec70d6d9893ccec2ada08652d7d4f88cf0d7dcb1419c5be46a6e9c4cacc5711c73adfed961c3f9f457f4d6971813b361b77cfacb261119f662cf00eb59c3cdbdbe7b0de319a0bee1b90ca3c3ed09959ba898c62fb61db3335b49b5b604118317f28c7b673a281cfb5ffcd25551f93867e73ad8130d0772bb8ed2b41ad90177520aa647b6a41326471da611acc9493ebb002e4659b0788645afa36dd23c2c21b59514a03c1fa18028fb06244342cbefb64b64ca076349c4cd83efbebe94b96fb1d5c32bd7f338be5aa34920c316b513f39e1819b9d171868346f59b129916727cc6d805d02efe2acddb188dd3f4595b20fb464b445ca957e8731c4f04cce011d354559390467c5e757f777ce08a03bed93160769fb30fe6706437a58cebba5a57e11f20046cae73cdd5d32d4396d4fca03299719703842c5cf3df9a57b379cec3f008157aae917997702c7c0edf6c7f40e0a3214e626f85d62ecbf3cfea4c070de64209d74fbf02ddb0dd5622037d4442c87956d01b2dc5a66ef54fa7e792b016a4d090d6ff11b1b4a56b392093835aa96a4107c7cad5f09f2389b2540f94e720fa610bde3db837ad109612d817b449825301904303dfe464e189b96004a812ff59486c579cb4eb177329e7223fe1cdc6076acf13602dd12c4b266b6367e7295135325c544e588475a55e0e3c4469bbd65ed9448a209f291cd4d7b89030df39c5cf024cd1f04b30194ecba37fb6f1f14cfb2eeec1590c45a3a61d41dcc43f00c131c2f32c346792bf5f12a63820e9de61126ace0a383f2484d63ed34b77a00c3af0a93ab822c07d94e0b2673dd66715c09c11541f38ced6a3e2d10e124c5d42ecfb1afaf5bf954ce1436e48d17f8b32f15040a6c81dd8e0a90ed2f4dfb81721bbafb7d40b6a087ea33af3db172abb4f7f38ed2a783cffa8736491e7088bdb80bc3cc61c0242bfcac4eda24723af9f7d21639b983ef6c164861a5a318271590bc259fe92d0302f7a76b3241730a0866b31099dcc4448c14031eadcdfef020105409d5b0328e5dec27a78acd3c61a694ab0581244439fe2bb7e7cea6b4c0b99e733504ffcf2bbc15fce10a73eedac8f1b5ddf86eeea083617ce4d082532f7f099195b7058018374ac0052a31b677991782e228fe7f3e08bde1d2c6667a06335fe7455620778db9a0b0d9ada46fdd66045021c848a95554d346eb12a029d43555bc0139cb60b6c134fdd835e7bb7fc0396636130a87acd1dccb082c3add3a482d5616a3905efb33a3438f7aa4aa6e8e0222015964f53a901b9e586ca74ba025663c5acf2dade683ac316935bca45ca93adff4c033bb206780a88f397193cb3c48ea7cfaea6c29706056c65a0ab989cb32cbb57a805c9b99001402f0e86e262ac1f6fd3d7a85bba3755ce6e9d5d542b81c8528304d0c2592206722190061995137020c57d66c20f510afcc227825d7c4081fef989fe155bdaf92544c5a58278bc4a645618d17be800b1aa631cd7d216a2e7c9d984ce5a03444ba613f12b81caa27d0a8cbed7673ae649b8738747591fea19ac5af1802d1d28b11bb7f045446acfd48b29f7f28d4a0055d662bbdfd04dfbb593c8d1b0576f8ce94a7b9bc08a53817c9a2e505c3695ebc32b4a37e28906c8c9322e21abf966288dd40e43b748b5ea4f599f636572b157faf7a1fcf0bc6f73077d2ddc520aa5d94c64f519629b32c5793ed06034e6e553836a3f2dd2a1d09c09dfbcc9f93237003098935573c141b7b53a2fbf6477ed1faa81a7f48b803148ba266311988e8ff0930bbc47c0d930d2a132b87fc0766054313d42b40ba38cb737f2af0049a7eccb6ad546d08c06e28290957ca72a4ecf880ea7b390a7412fc54f94adccd4b4263a43e8b1855002c7bbe5e7f64c73f5af0de6a9424abc2fea8b960e68f373cb24bad0bc72fb621de18bc7584a8af622c60c1dd60d38129d7ae88c8d3c4b45b89b1f8f568766f5383cfed2411d6e63d6e8218079a8dea9ee0d11231529308ce5fb2c093f86bb828e0411f76bf7569cfe6749d255536953b85f90db341bcd1115c02ef52c0c9d304030850d4a48432ca4d0c987e79768d0650e594495971db290ea4e76b4c87d954baaeef94e19bb9cc0a624cf5c6546ca6cbe83ac034b97a18d969961dec508d05fbf935ccac9a5c73e52f544a61323e4d9bd746ea4a6e148891c1aa8ede3a7c312f4501974a72d009fdf447adc0ccc6b9cc313d1612ae8770f925577075912b9c91f9fba5e3a8f4f11884b08962f4dfa2c4d279d881c82cd10b2f63cf0bfe8a72c22a3fe70150d900f4ed2e7428247c3f236a302aa7ddd9045ee03b31e56bf2b7f64b1512389f58e7ff17272fabff3cc97e14d4133286bde4cb436dc29587cc5961757e38f357b20d80c474a179da8ad71515ed525ee28b0d1418dadb71b0d7d663d93d3cee7471678a259046a98ab803bbfc761b5f9914eee3e9de72111a5282bc2803159b5bea1c7677255b209b5f682b2870f2d9d9d207bc513b4dca1d8861e9ca9caafb06c9bd67ad2a76889ecbe18a1988c3ef8b7d8323357907b82195525cc39482a34ded3ffed66989e518022e4beb114c62f20e7522791d4069c46a9e424ab2cf10c827ac955b16341d50ba4fa84fd7252894b47367f85fa5ccf657211a3b8a37a4ded084bdfd0b95c81330c29eca62826135b3ac88971d16bd58886ce5ea21fb6f5ac24aa6fa808215a2bb772ce07d94239ca73940c96a6b865388cb78283b8ee8a54a4e793b6fd034a5cbb6c9a78ec399d42927a1f3349959ba276a1c28e9bc68b7aa656b7dd625343cd207cec792b76374ddd4e40b2a74d166dac946f98537b6a26223bbe73d0906ab3578e1f3698934d9ccea8e264f73e47204ddd8d530482ff78564c2916af2800d15f53049b6bbf4c26bf65919eaf24afc74b9722e5778d58526691237a0efb7c25aa9b7ec6f9d5f8239c198f9fd74c11ece1edd731aa1744c83941a52c0a4046f80036c3d207960279418787d60c9d5a1e79f4bdc6d3301ab53e4bd9cbe886ee9175f9234875b89d7ef86f5dc272032d97e5995fdc6d006a3f5b9a4156463652e49b8a4697e6a0f6f47e36f6a2db19e4d3e89482faf6fa1cd1e05fa100408d49e35818bb49241c08222ae84b1b450380bcfb05d0b74a5c9e3377629687afc1e7ba2b9ea792ef4749ba9b449c4c5f9cb5ac87fbb2698d8aedde8295bd4f0ad686da1db873d8c89a83b6ea1595049e1f7ba35c3b34139ebf2d98a195c451f7c8f50bb94611d41fbca07260d791c3ea3620ec1e01ad9eeb865bc92cada5d69785e3236a74f1790a68871f6a184fca8f53c5e1331f6cb5680690b479468ff3d9a45d130d8ece1e437d2c038eeb0738bf68aac28eae48724a6ad1fff1419b550656da5286e7e24068754d4c5afb24fe399998c32b28e539164786168349b1b9364089a60d4041ec3674cc432c0df20ecaf42985b05a699e218a710035c4dd6122ade7ff375c780143debdb5b192899b6c9e72a61c6488e1ee66c402b9e177b6f4721a5fe7d6db7bc732b2198902f1636d46213c880cd5ac34426ef028ea41416967d4a3a0d33d74618f10b7aee6a7a9f28be29d03be42f2f257d0946c67afa35fa98cb9b25138600263f510bc72e2ea799d669637382842c78548fd2d2958232ad2ab4a1a3d360d0cfee1769122083360625246f70d7aa303e92b94235dcf4cb3d102b60c99da7774f5b7361ac00ce7ff12df82f5152809fbc940b34a436a01e4829a9ad8dee55e8d58a251ce29fd75b691d74bf99051742936fd8c1671d904922f8fab022b5faadf4c7501c37c0a5a300debe55b5553cf875a3a8dc2f806ed90eca9a16015e4116f893283f06e22b660e651a3370a0e6752c641d3ec72a11cf663ebb6001a111e1f6772f41e1294ffc1872030d4d4732280e1c1e4cd8e385610eeefe6cd665ad8ccdedee291212209c98aac3d9bcdfd3141aeeca202aa330f4bd9c5da9eaf417b3706fdb41253f39cc3432915920e4bd600eb6580d648f5318fb0b55ea4efabeb303ec2127fd6640dec22e26150002e8da7dd1031e97fb4445d6e0a205c5ef5951685a5c85566d28d46f403b83deb95a7b340cb7b1541bae12a6f3ba9623e0ccf189bd72f0c1db59920927d3b4d877ad536a5b5f6d6074efa54f8b0e20cc61bd72cc50ca0895a242629a63f2ac42ea81ba65cd6f1b6df7423eb2277bc516be5fe568dbf07f284945f12438885c3e3c63275dbd2dc5eac6eeb335d9b2b425974cc2292dbc12612fc8555ee4bcc2e62bb6052b61e2089b9291e678a593cc5cff302504681a7463bf6276bff1bf20894483abf803e39fdccf47b77f84817be44e52b0f66fd7b956bc6a3b68d1c0e881add6de2e7f8881577358da3014b699512dca08056946c6484db02722c8fde7d208f38a3090e9ac1657d681e1ca2f6a81d1368d34e03bd51d0509d4cbc419aab83f2f495e93822047e219f570458df85d74a665ed148eb1d9b474fbfa92689f17787f5dadb5dafbcd954fac2a36b3313a5699f7b61f55cafab8484485f0f9ce332625b607f9e16dbb60c0348ff3000183bc64037513f62bb8ac0b7e277fc5b52024ef8ac4ed9d92b0f1ba27db14ca343e3706b22663c95283ac315b8e1231feb38e12e0186473ab1fabc7620d363b1972b6378ac14ed387a5854cb2b8575f78bfc06f5509afd0796871ea88ac7b0e555506b0e909d1ceb3e77dbee15a88c2967696f1b664955017f30b5c1d1e32d332aabc6614a7c39f96f42a5167805a62dcc9eab94f2e8913d04d1b0c1afd4ff61a2770f2f5c4528e089b13239aa63d56a55d416c2b420ee77633b67e6ecfecbbd3e841e9867e427c24280987a1fd2535d0183c7abcd4b34395def8a3ca6450cf52cb362af94c583fe2e55a268f38794b3140982d616230eb4bbef517ac241bcab1b5f68142f595d3e045f4bd919c8c2b02ada5cf678ab1dbd412e40cf0fb10f8ff28e4399885589b43bcd2fab57b0f89472161874ed1dd3913bee9a35f38d698ce55c958402e5f98cf126a4fed5b989fa8985cab1fb4be50548f8f1dcff2114efabeaaef87b022142d9ce5b6da5d1166eec67783bd9f875259459130665f683f6055ac76bf2fc7e809c1443acab00bed27ea82dd0f236a8468377097db455eab11152429785e6513332701d248e6a21ee63e2849fad5b6ba1b651f48369c18326f51db5256b3038816bea26041e0ce1df99ed5082fc3795a7c4437e454a1e247ac70aaf94fef73c65e5c9c4104654adaaeab1ee920cd4548e86556d056089a82856c53e326250e6e6923ff6280c7f227dccb13a7d6f72cbfaa89ae2c1329a83110f1373aaca6b74b1979ea9ebcdd9cc00b95a9ed09669a7ae4ba81d9898d51fb4bdf0aaf0a1e8fdd1fccf01b5e53a61ebd3ce47ce61e05237c11e5d691044f789138436a1dbb0a28a8d2bc4fce614584100e7efa3eae92461fa029430c77584de63effed4d36b90ee40000f456e580e6fa01dbbf79b96617eb6f8978bd6ef46b211d8867117e218a122a914db897334154e170c5f6ab94a6d486b40094342dc1b3bd75d98ffae37235d8b223e6f75be205a6eafc024438d959d1af30e7e7e954c1c44dab65c55f461dde3103d81198ff33cb71253522614d41e4f6712ebe7d73ea5f48929881174f5e846b94381e717f26b0bd09de324d3bb682a6f86d9ed144a896997e3cfde60edbc615cdf1eaa62157e69a87f6a3841147ef5175a79f127ccaf1fe5d66db0295e9900af8713de71b7035cb4618fdb79deccf86a1c1b57c1a64fb9feb4cb62fae8a09c59daa82663df6c11397ac5418d3016d85fccea69c2a1ca247f86037f7e27f9a629d48a5016129bba72c9c0dec371720b8710d85b53fea8e9691392fb84396abfa0a5de1cf221451cc15df0daaf2ed0e95caedc5eb1485bdfb09590e8ec712e299a9c55721477e94a28b5cf68c9ade3c941a2ce6d2e605fa4eb5653f88c4f942671fac7f28ecc2d50bdb483c1fa5f1661bfe5a7e390148dea409910712783ddedb5bcbb7dd0ea9a6ca8d5d18f93377a0f38b7a45e61c0eb8a1ffe2018442f65848cf0b428314d1a094bbfd407785f38e49653e3b521b5e424d114355889cb830481b4e71e6ffb01b292e9335a50aa3cdd3f062c5b31ba3f314f7e4dc8cd6f22f232e62fb331ec1dcd6217ccc4e581b58c456167f0c3644b317694ccb4aa4c2157dacace17b326547e676dc3bec4c6c0c45c059042654e2e78d828886fe8bec3f3031f7cbed879ab81f9b67a901a02309e5ef7afb01b3a6d2afc5f9f03fd7e168fc9648585d6611b5976fd31dec7903c6aee0f350502f0bfc5c7c91a6c4631d1fec5ed04305881fcefbe3ff213e59657d08478d65e3cd864f12dc61247897a75357ffc8ba0eed537903cf2e8372f4b5c6fe3d3335b4629c82d822b1aef2b87a39c52fdde0749959ee9e544ca16a178ca9486de38929faad7a473876846bbaf4064e3d5895927a4bef5d8b52b5ade28c1d3a78d2c9a00fbf906208b7ade881d233caf772f23785d6e418db56f8388f6c9061f2130a8f4f44d2ba9f59e78e1e1d64a371232be392b7e53458d2926b6cc3c861f3040f4d343098d4bfee046255d770c568a00110497eafd7969b06d638be20f2cf0715190001aa466eec2c4b926e229bf10e860a61d759ab9353c00f896137dc8b1a666e1edd73bb3549479a4461059b243f673e1c9eda7bbcb16b21b29c79e68eca72984157ba3abd72d3707a65772e93455313b134e6b923fcaf73446aff64300b1dd3468a9a85dd78d374d4edfc498ea52ca7e75aadcea46cc49220c83e93f4882ee68356506d89502493718a4c83db66b67934cee58f81685f5a4120d4154ec68fbf2f2b2f2892d4a72b554f6c34597a4d600a56f632f09744b94b352ff19cee8894545d6e00932a37dcd7421c995486afcbe2abbed0e03707738345b163b4072ea6b4cad1fc71b9a2750b21b322f7e64ccc619ad92489b5f926108ea2d942f5f7eb663133d406fd331e8de0313f7040df19548debe967e5b483b249801394ba21c992dbafddb65c396df7dc8619c811ae24abdeefd2af6259c13a518a31cdece85d559e1e56bd55bb76c82c067b306621c8efa662aec7b18fd1b6f2c2f3649fd4314e46f11190c858bca20a7443c5863b8a945c9dd2cd91d8659da1acdb126c8afa5cb97de4c6792978dcd378030f6ca93ccdeb77399cd198c4339bbd3aad9ea0c52029543ce90f817a2d9a18ecc6a397f8a17fa861ca3514273f422ba7bc666df564bf77216565816347d068fd7c77b105f9a51aa715fca0334ab4fd3b33ff4bc61a184112530676430d64290d3c583352147469d3497a493288878d0dcd4483378b47fc5b36c8bdeae7af47cb523d9424b5a8c04f8ac4140732ca9a0f00a06ac760b957fa2438dc594f83ebe925ce577d2312b72afac41cb6dbb6ed12d4e06bcb2ca3ae27d3efa10a3dff80d13f5b6c653ef6b42a9bbe13c6b1d7f6ef90acb16796ccac2d9b73f36bc3676f265b5502b99e916b60e637a74ebd5b8173ae6a3fb7b30e9de96eca129017a919d3b13c5c922d5f04ffbe5aae4b17bcc9e459cee191de69ab97f23529cb7eafaad2a4a216bc0df626f4e2b93f04aeb473dcf799087407ce26b7a6fa5138c5bec5becd8f33d88435de809fe15023431d40a551582c5d82485f2fcde5ca0b9919cd3829b0186bbdded26f76a513991f1c17e0b95bac8b50e223f884a1d214619963e51ca910c46957cf98074c3cc295cbe3107d18af746353f322d78d79b9fb43de6476a2fb7538107eb1e500489c3b0cbcd9ef399a814afe2dd0152ac291bd2fbd7405b286cf13804ade9db253acad8f6c874b102db04822d93d08f32769807ea3aa89dab6e8ecbf02284d05245467c9999529bed6a4f06cc45bf3aff5c29e6d8a5ef6008bf0168ded8476a3c534db434cb33fb1590a87666fe9177a86ec6102fbc4e8c74a87923e9d6359783dc9905f0646f25ca280b5c081c51f55aa84519a0bedbe12fc9bc8266e0ad2ce7a1bf6a3260e39ccd5d6e2352ecf0a5b2b779d1ebd10b4d6ed7531a12bf7516a529c1c9f6845a23c2cf86696bc53b7bbb530d602255223929d0dc6126c59769b4e3018962da485179e962909f178cc7e6c6b7873132ca3efe2a00a4bf22be08be1198dd0ffed8be0d439552bf593adbad89fcdb71fbd41ecc9af4163ea555e66ae38d08c6653b9e4864ea7b9803396c9e8406a39981d2e480f93dd01902cbd0c045a603f4b50fe541b510a093cd87602089f7764d20cda0af8feb3e811eb8eb5ac3cceb878fb31ce42757451e176e79c804d17ec5c87987f2f2d9fb81baee020f6cc17d03c0e4c9b4a6693851e7c09bbe7388fe5496b9516bc98252deddbe5b8f9be3ed8b278d009c60b5d8c25e994da75319ea2678f8b38e95780e63e0d95c2cf9e7362c83a984590cbea3e8273590ff709e9e98be7dda6fb4bcd954d78999b55c7c9c672455ce89ce921bc987c3a9124466521898b8435a16f82fcb3a8eba574d778b86efcfe5f16ac0252aa6d1205e5e390544fafc14118c25c4e8c861a12720985dfc05e1be7999fc65e7d6fe52920e199889b2044582508fbed86878d1fd1cd7a97e986d6c7e1627253e40458fdc0174fdeac4012e97145f310f7e3073191b709448886ac6ae53d9ce3449aa966e04a9c2f02f5885d358b6e33e26652e2f1e4a58804644890571bfff419b509c0cf9ecd8ddb266796f47fcaa8b834c5ed2c2b5d4fd3d9700dfa2df0369d77d2a8387a8c651f17b7dc8417577c62e00486874a6d360ac72168998c158c2f561a7bbbdbf78ba2809afe1b98576c19a46e20220fd13c6155b2c5437cc2c518c426f61c9097305f9c12b685d3ea78ae7f2a1c5615015bf2c06d19a2b542b81b7da7a6913eccba1e93d27363a612244c7a8e53618b5b49466e7ecf09328b6324f454369e987782023d3667e8bdb3f57e4e7c4eba0c27c300ed3d351bdca854d4321a4d60917e4df54bff5829d587972c36fb405cae45bb154fb336e4b367bb43ee0ff5f160f26f7e54037571dd8a9c5fa24c3bfd669930cfc1d0134f079883bee9bd1f1c81dc79f5bb238e03fe2d70b4e62f9f119f57760c8b0da7d8a1ba0570e4b2e5552c76ca07825f5ac4e510878e5affcd4bcfdb67250b582e97e22ea28f605120226b86ae4043c112fbdc33956a24affa5254339281f091a3c88ae272635f20b9c91a3077d9e42224761dd1f789789c48c4b1d78672e854bac9bfd4eb8fdf2aa45cd241e5f50184681fe7628ea0a5a3e177e419","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
