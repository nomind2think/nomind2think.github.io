<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e2db2dedce4c3156b0b254d088540647e53e434a6881ff4eaad36b0b2fb5c08544654e16cd73091539d588a2eacfcfb211b40ca65e3d55c58e5fad90d538dcfd29a5fcd494180e48879006551f583e8b5571f88186859912e07c416e3f0ba3d1cd28e506feb8a208cfd1049c4ae210421851b7a8c135bded8096d1f953ccfdafea516d0ccc7106674e039bec63426dd43eef6cfc0832c69797b4c4165493ca8c5cb6cad662e9705ad929420cdde7fa36c8782dda652350db1a68dab8969d1d8468ff49776694a6c9de25294282a555fb5a9bf2cb85767d259d3174ebe4191bdd4b17154bda3b595ad18ce0cd5ad0db03a6b00cf417add8151ef4a8cdc77cc5a00a9d9cca833fec252a7f22164c2152cacd87c2b4b6e9361fc3c10f51f80c5356c8981a4a9cf33b0f4617d30c7b04f43125759515af443a650696a1b333a040b9e6440ee665e2011d8720f027637f380d7c6521074947ca3af6b78c022f7cf01f50c65b2734aa151cd1e7fdf89e22a7a0dcac49609d264773b27b5d6eb0650b7be76cfdf125c1b08db8164f1ccf4ab908651df5c9d1e373b4fec420f1efc44cae337d38b1d01b7d4ea8358212609198ba8bb2f4734f5d4c0ee931446276b2c3460ebe5caf4a207515b6e6e10e487600af92a585f59b699ad310e882d03993ca717bd3442f3f9145a0eda9cce6a943d9759bfdea67406c20791dcfc8d088bb98e1000347836845fa2145ffd9b7f1f8f6e8d0d8a5b586d7c4439e70baf52309040adca3c9c86549f97ab08a083cd4cae2532c12b48c7a0f8d2330df6c7d96cc88dfe0a52c8194cff2d7eaf1d8595c4c81120783a2e7a647e81bd96c58ed3bf0978de720de03e5e8d0e39440d699379871d4aacb61fbf9c8c343d7f52bac25257f697b49702bed7f88322749aad9e960a005c01dafb54bc25f5e30a6f013d0282da5e804a3f5116b0f04ac80f754d7367aa9fbde24072f4f306b070d48464df4e7de475ffeec0223310d17c8dd3a68bede42555cdc2496f65f5b3d8dccc436f653f214eb1fa434c4084d4a33e6dc6f8f65465c21efa08c9c10badf47e4a9ebd61ea732792b326b14ecd6ddaf042a4721f5ecf6164c8193d832633e432fb2bfc13ad0aa371aed406456ccad0c794ee9ccfacb69e1ac4879f92b84d54ca056898e62dd8b831586f93e0b9d72369078e212dbdcb517d6ae045ad55a42162859d68810150886564b227d917079f0a3feb3cafcb5e0986d2d4b8e70b9d67fd1dfc72d084ff10f4a3a7ebaba4fef9605013fb6b503f29416c56a987166c71cd1eeb186208f05db6d1048479197a67c5dbfb1aafcc4f582492c7c82af8c774cc0f94ac3111628554e49203b79b58bab4783cf4a0ff61f05e343171de97f3bc9adcaf7f0a590b9268e59ccc10acad56c72edc6f522253ae12c3f3101d02bd00d22682f1fbe4e59826d34334e0c99608c9c39bfd8b1a6fcb0debe5ad083e6e96a23b57b65ad94f487a3d69233ac9a36b14b85f3f5a89980629848015c3c267d136c06c1221642d121373837223f58715c3a353d98cbd0a0ea9b9f49cde58cdcd489af34baf8669e529be0815f032789e1d887a830f73044e58410c72f1bee1f1b460cda24c4e7684c69826f08139fd3cf76aaaae9cd440a7b1d9cfc4f74c2681c1690e202542ab724dde9157d1ae46f69d803cfdf2a63a56ed03cd12d14e546dd279607e8905fde52a1456d185df3ef550c13c49df730b3295c0ccdce8b933423fa0d532e275fc26162723747dddf2f3b7bff409ac02180133ec8e7c16d333c1379cab872be2c3f146a1d0825bd77dd5102e2a24197b300ee472659bb663861127002b09d59b1b0867b67f4464deeff7435181fa9b5df2ee7c9f832ebf41166e7d1890007adb62c0afbc8b38f12f431a4290f03e9c9bb54be00b500ca4dfe2979613440e8a08b713ce06bc65909e26b8a995dd624632915885706e063dabd3f3fbd2ccf34c8585bfdf6bee642c76ee3c50bbb4c9f9b8402c63323c65f171eef05d4ad1a460d76264d16c16d6a32053e72f4844a6d07f09a2e1e8c86dd1b48a3adcb21eb4dbe7d963d414f034bf8742df8d909133d89b5a83052c2fa7b773287dcfc44d1ea4462127233c782ba403ab02aa4b1b743576468eb6ce3037c9f9c72fc3ac7bc85aa71890961e755560e8deb868c1de8e6899466d98bb7d6aee96a47e7638ef37556dc4e7efc52e72c3b5269ab77ba5308b44d2316a83412d7960914cf63fc54788bfda7daa0e7d827396485445a16318534055d0174c74cc269cc83539b3ba85d3f4a043c772ce0815eb5923ae006eea4273926f2608042743645c46dd4d14e0c8f4c51469dca53aceaac5fd125c1962ac63597f3e1a645fd77b350f3fe952993a66100b5a3407b3e924f8e191fa3f04f6af733c5d857cd67809f6ce601dae000833a028bf5c381e70ac6e19ace7c63e476dc53cfc88b7b6491080c3d907c89608eebffc7d602c342007a83b30c52049c5aafc6b2c6659bf8b1513cbbcc91cc30dcad1e9d52c8242e281e106a52daceaa99ee5a72a5265ceb24249467bd2120ab097d54e855c1aa929f55efd2088d730d6b2a8772a9af3aa175b2ed874fd02d2d7101e48858607df7f302ae01a608cab9e3f5652285aa7b085f888dea20dd484de86389eeffd4f5720c3f572c12bbd977fa45162b1b0a051941ac2f1f27079d54f501603b275ba581baef58efa5e9f4a47c9991e4cbad7890373db2e70c934b02cd8a18f74fbd0eeeee80395d88e7b513319ecaa8a08333fa4ab706744c073c8e5584347650bd54b5de5cb9195376ac96d77efa4156c1fa06a061f1bdb7cfe35c27b31e65fa50efbfd75e881e8bac6fa3256dfebf3da660ac990132194c7f186d711eb2146ecdf95a08686236976d897b7b7091600df1b75e479a4be1726faed69f472efeb5e1604c8a754864682ed43b791fd22fddb18ed9b0dbfd2e32b8b81fd60f7316d9e515a4b0098503d54f49dbc002875cc3eab340ff003ee3d145b61cd74c6a68190fcf8455fe5e8dad21e475caf1a4fc99a90549a890acf2f591f387655d8521c5675caa38dad11e47a085195e2a237cb7e880c6fde5d4c54d1926362b78b90e4cb5f031151c6488864ec14da55b1336130e88ca1e21bdfc48281afe0a5e912d089c6138058da0a77fc3e1f27c64c5b3de3152295aa17a013d205bea04e8af2bbd11c0b6cec3aee6c3c65628b28f0b73092f79762bd99a7e890b4d906dc8c5216551f219ed66e105941d44f8a076029f7483a499b0d6f34339e9d951aa1cdcd7674884eff285f667f1b4cfd656d3fd961a176dc232000c4501e952a5465f0073b86e2d78c418cc5b8ea53145c37dba9af35862e42f0a27b28dbabc8e26bbed6f1cdbb18913d90e354f6f89705e796180095ae453619362a3c629088bfdbc636c0464ed4d3740f2a26da4c2379720cafd1667d41af54d7241ecadff1510907781f9740b1eb43d31600166e7798555e7973bf0d08404ff9a9c0e1774d6f3f7ad334de30ee86f78a956cc081a3b2f4294a7e609a32257aaf6d9de72a3742fadc45349eb59eaf02fcdc4be849c208789536e26f434b0baf1ab12109087ec5181d130b820dca13d17f6e13b97ba5209015b57dbfb49711b35977e531c7d712f1d2e7f37440dcdf7fa59b5fd600634f01e747cd4bea198ad5d76cdb018d994f4a77a6300eb4ea4fca3596d3df5da47f4e332d6f334e69132692b43c1f97212966645e2a46d8ab0d6884e9eb089ea59a720e056902359ee04f83c880c78eb0356550a417c9de123e8cbdd72aaa4b83cb815c342813c8e71e8123adae41cb52ca4c763315ffab3fd0ee9829796635e60ec2512c6faea62dd2923d1fd65879930aa48eaca51c0d1a1ddd1f1ffc02747ab06f8f43a3f9a52a98a113a7066df93afef900718d9a313745451e84bc19cbc95d601d763a555f898ddbe10ae25a4a36314d8ac8dfc6ccbd5fb9fc2690ab2b96e8c952e5939414e966964e1ce410fed6c2c103d928be9899dc51006dfdb651688b56a96ac78fa08a62614322be5dd1ed4a3ba235cf7c8bfca00f20c159024c69dfcbebf02359eb715ff513e9a504f29cdeb08f1b7ce806aecb635701d2b39a89d9686cbd424a902af25f8c3c753d5f0e4ea47530cef00a4c582c39f64f97acb1be20cc373c693d5b1c537210c12f03f55a1a9c9b8c02f744ae41e43e3283b73711690dbe75d91640cf8e557317ffdcd8ff221a178185d938a2488ecf6e6cfc9ee8714c226a9eb1c9606e35d210c1a31e1202799a53b1cffbec0cda74e6083ec3815dabe34f01ef30a556fa32849eba32d62ba153f913f7434aaeb70f1cb884cb38c6cd724f4498c4e9730e1337376fb5adefaf9e2ce205a6f6dd068889b1c07ad4d3425cd7ec1ca167b2c33fdd2f7de13e74892936094f6004f61377edd9eba51e2061ba7a447e4dd2e0189949a449d91efd6d93524525eb274e0861a8761fc275ef676436753db9c2c94831f4f5fb8ce03c5a99e16c0e89187e82287bf179b7e009c4a59308cfdd3af0e72cfd14d064bc2c9f6a858ac11f6ecfd97ea5e2de099ca579933aed34a7dd191f30c3a0939c99060c0fa9508f5d137501f9a5750efe35338af68df200014d9b7b61f523e369fd5535e30f82fc3e5effd6085511057fd44d5cf28297410a14eaa514fdf7be9ad9ce51fc53bf60a3c4b31969293b2dbf7a1cfe840899939682d5416019365e03b6fda52a3bf685f2ed664646bcadeffa061d7983a94dd7eae6e4fc278686e5a38a0f204994e666a57fdcb12447f54338241964a65183bff32f89c1ffd4f5ff798a1bf78be2d07cade0395b72dbbfa2e9c1759c6e21ae96037f55aba426790214065eb161f8e8e2ab0a7936cd3c7f483666f6576e4db1b9a65315f672ec6b54c83eca2a178deaebf86bb46db08ce765b80870f1a33dec65eddfcf175e8392facec1cc4f0dc4e0706c1ab4c9b0b583309667a363aba51eab7c7f5f76739f71f13fe97ef376dc8963c54b9758d5b285cd3ba1c48f6c4fdedea7b814605cdc4341ac2ea87147d2854afb3cb2b472c00f7051aa2bdb2fb5b18ac721521e14d72033983125656b14263919850f4728a56e124cf706d8de03c0977eae55f6d3ddf508e0a2f306bd8d4227c435ad68a4c56dd2cebf2a289685a13d27eae4ad2f9458d1c3a020b257eb90b15558b4237967e9a84007fbac612b121d110cb56a5b61290232a8e69273f346ad96f40e1a59facef550e33857fb91982117e0c400cfbfd0f62d75b0ac9248c3b03521c58b034aeeae2d6491eaeb328572a2e52c81758ddacb45e1a4966ca7c8751f4e230d169ae1bd8a986246a88f43cb9c99dfdb7272cb361257d5df08d071e4002cb7f89800acbde181392b3137ef4f13801878a57e4cf66df73b7c49d339a460bd33fd492176b732c3bb52f42de575f605542fead6367cb9a32c297cd209555cae37a0168f0af450a8aed416c16d89d901a98e448d262e89febf293ae33aee454a1e8b2d4ad6672c18994a399feb5f432c7b2332d4d1d04d4d91dcb2819e3ec0f911c01f80dff75256029812b89cb436dd9c339d57b1d945499f2c85fff60031b8d91310caae5690b565d8d5bbce4499f06e9f0d0ead0a7c3154b05434084db7777c355524922ef7a27f976ace77ce619646e35765b5e878ba23018bf8ff186fbe6fb5956edbd593bed119754009d8c6ffc8b57bab7d87ad8a6d680f91c7b839d23435fef21f801d2ebdfc41a65c1cd8a08d4179b3bbcadcfd296b527be9abd1ca2dae63bb18777e3203e3e1dd0e4c390e9807fcbd8daf404bf837ef8d50b85a04d09eb14b13eaa0b96c88b3727b761afbf68c86fbc4f46afcd43ae2b3cf6d9f9fc2f71d9e164b28197ea813f62b72a8109def5c15b16e9cc938236bbfc8de5a04571032c8674d10da25226008f2f665b3640ea5bd3bc1573074fa96875e1ccf352f56e59bd131ea6f84bc27bb3077a7a4bd4660c39819a669ad8836e7e9bc2f3b42fff25cc8231a3097f1c1c0c918f91b5553b05817d3924b130d6f9d86318e470c3e6b3778936f12c5d216e3f210744ef87abdcfa427dfde07812cc1dc61c887ab60b56158f990ca6d91f7e679c4d38411b491012fc6c7badd05249250793e3ec65bb39952f958286992084482bdac6195c226033965180a27a3b11c943368657963802c79cf0ec967e3bfd10895cbd94741593e2580a979d8ebf15544418cadc3cfdf5339336f5210dea669b569774a8583c785139522dff8012696dba93c4b09206bfdc8288e222f1543da993c6347d13d06867e15d664ff12bb590c61b32f2aead73df193def4cfda9444e6a70f93ec0f384fe73d82ec23a1a28ca369e53bb1e493993391960c1b179108a27add7186fbc7b4d88b01eaab4790f97a5a2b0fcb5aaa92751f97c2b53fc4dfe665d54949a52e412e641aa6bb3d735c4bbe881458f8b5472080d17845d3480ff03b60bfa5129e4735d01634090b8aa9a0847a4b0572ce0a7a87bdea99c811ff711cdb3435b37c83906ed950efa64a53a1e39e1bd491133a7cb7e1d2c6b1c10da86d83b227d659fa2ef92775356ebcf76da509c739427b8a1b980d0f2a1ae87056b3959eca6d342549cf276318d8013f75e7c00692721d5056745199fd5f745ccbbe83d0d040ee466febb53723d5ea8a90a11f6d5b789626f861a89995941a5455071f039c0825d4a7c7df765c1f3b3dd69b38b5ae48bd646df6eb4e3235fc36646ed8c80270ee98e91ba6ac822dc4755478195e59db9a7a23aa208a0f88ff9adbbf36d41ceab1379fdd23d015deb255e7ee538b3babdb4d9f8183593dcc138e2f5002a53283867b956bcf0aaac2fc9c4a7ad39a95df0d124d919cf4246084094ec84d3e0d42fe6d0e9920d22d2e3def61a1c97c71512326c0c3b1752834ebad703d42b301387177a63b4adb65dc2e47c25fc2208c66799161495f519d80e5219f07399181096f0583d98c7c2d9e03a7e7fc172681ea402e7db38bd9655766893b97c09a367c957c67b5fa1d46446a29097d0f2de4ebc48fd988ce526515953dd1d30e4ae82cbea8cbc69554784eeea26cd2812021f6b9d3dc0e60c59e325e4f77893616d7d2f41394dfe30372d39e6fb70eafb45a26d94d59f59c28e4c4fd497f1fef9527a5327b082437fb11923d31226a2b04bb0b2699b6ace2ba3c220a588b5b0d2ff58adad9d16988b8e934b7286860d4b6638ed29ef0ae111d697e269ed5304cf0652b99814ecd26205f0b9d3a40368e9d1858cc9aaa6a968439f8372aebfd771c5db5f85ccff42e445b8f020b51610b730c15c4f245d27e7d51ef5604eb54034d5fab6ffec9b684102677adcf0ea17df1d5484765d3f48522bbd5e8373f099d064328c60f8b94336e9af6e80969d27ac874c3a1dcd145de19b0f5e11be632520dff392fe76e307768137ac45eed8eb0acf7ec4dee3f4f8f0948096f1522f7f56eda8160eb5decb58672f8d0b961a7057fdee4804e24ec93a71955eb39478808aaec99f08a58d18ede9f8e3e5638d3e06f1878e270815fb6e3d07440eb97bf260283183b5e94cf62b9aaf0b56ce29b0c6c7111a7de0336e604075bc83a0fd351426d165cb862cbb047c5f63f47b4dea1ef8c16e331ca54e3bec282b8f2f4549cd18a007f6357f691e2a9e860c0e26fffced2a67073dbf362dcaca31cec73d1b8147f70d39636340ba0bfaf4daa580c45d4bcc1acd7ca245771ae9898770ec7a3e471c05118b914d3a92b3339da47dba20385d3f3d80336f3a5ef96bae06a894cb0f8d4c00f8d85fde6b72d52e830d4fdb4676098d666a353b76c2be9df946ca637f5969bd114cc6023d3bcf45e4dc23ee7bb8272498c7b07258ea56c0d6e9da3d30fae5125580ec416b184faeb51b2a7579a0b8eda7271460a8716337e8688c9bb2cc078d0865718a67be9ae3cd9976ee80cfd4f789cc7ed30e022e1605cb6ddaf4d2b662456c9018726a8b5a8c68ab2eed5c27eece56a74b80b8bb4738d329b1881d297f99ba4766ef30d4a469bb4e8faa449580d7a4b146105952049650cdc633e5a8f40b7a0fdc622b44da528be74014cc839ab3324af87f2cf6b8d86a97f774fe9d5c5f92851ea48a0549eb75fb5e7fc0a95fdd59bf1721049ae070f4b5a1e4f3476e070444b2849fb55e3ad2d101617966b38c6d61e7afe2baf9bbf1ea79627337bbad19565a01332bf4a1eec6115df45b4b5c348b656510b32a5b5e3663cf1c5a4dacceb5863a46398ed5ef19f1649001fa2e0992694272ad284934434074f644bd41550be0c23c14a89eb243ea0644c636575c5f096b0aeb5a5497eeeb08b3f19ce7a22656589b7577f2f093f902961e730600475cf2d698fa5bafdcecf81ed9a2621b9be89e814e7e22b77260f1cdffd2956fabb1892dbd26c75eeb205d0ce65e9b533ef527797bfc5ae333d602a5d7271344a2dde2a8125208c92adae4984537a3362caa88868a6bf8c4e8dabc747456fe163d9735fe27cbb29d43823602a7b0dd92012c8b5ad02bff7e8c49878c37fbb781b89e7ed3bb121652fa27ff39f3d91330c4224f31366dcc6de128bb86f482a9b7c5de2f0a7b4e5a756754c4c8c8c84d0f02398c4872f626b802140c8a627606499a9f6e330903225d97113219fad432355b390dde76ba4ac6d03f4672d7bdb491a9e69f2baf140c0668559a88e8c1a80c832084afba0390b5b76eba9d1f3d2a1a60abbd27ab87f13dd4ca63fad4a278c33f9432a73a82365d5082a3d10e0630d2b5bef400412dddc0a6753911f06d370c64fbb439e01a62ca8b34b5fdbfb31f688a57177bb28ec8f4332ea56d6988f44845a5149afe03a8e9f35e29ae7e14cd8ef6e9f7ab5af8a1df01c83e57a44b1d5d1c85dc42be511d925948af9cc39abeec3e3046dbc571b9009517ab7c8dcaec6d02a6dfef694487a04fe37c8c5c0f7e632f282859894766280c65d044faba391b8b7960f0ca7abbe5125867852ccfc36849763ad9f8afb9bf1ca460bcfd096ebe5b0b414934dae280f78f721a46b0474cd1d712c1f543dd90f9104d2b0d1d6efa388765654565ecf8595db0a6fd69cdf7ad66a4a025082a764ac68c65d95a3b51445735ff599a6e0107e0bbcd3ab448d77cef4c09570a57b4ebeb2ebdd6b4383ff13c6f68a39c4e21f431bba4aaa0046dbe45981c6f27951a79a0c3446a6119bb6cebd749a0f1687518043474d74b110064fc5343ba99c4fdbf0ec4e24bc2a635593e88912de135f9ce782241a320a9ebd6cb8212a1fe28f45f7b9dc0cb99b8c45d99d60c8f69132bb6251792099edafcb001d2d1ed42aa67bd6d2a78f77d8ef5c6d5198a7e2bc5f3b48f12910f11e8443072f92681711f9572f9f39828c9f6e6628987ae363a16a55d32fb31dfb6120a4469a4fbb59851599cc6ae7303254160b2804365e113d16094a4c5f85a1a628026e2286254e7122d9125144e4ba4ee8fd42ee4fcc0b2402776e99bba99d4975b67b7007fad58c8c72c61ad9f790d8e49bd3f0a30c357044e705b97a4f3604b5d4838811019b7535c7d20741905ecb91449df7ea6d8683e3eeb1dea9ba2394fdd6b94cc91eba815c74c5a9ba863dbb5ef84c5a358f25629cbaaa5416ec1eb2738d40cb8c0692a8456df383461b763efd1c86effb1e0aaf4c87a6f8f2a9b64a2143d723827ddf8649f8c62170a8bede004abc778449fd9e1d7014bbc1e7b2ddbdda135d407bf6af8f2e8cd6755cb222d8fd686e9ece2715371ac0b832c3bac7c104b591fcd5395ca6f94b072b4b6b3452011e112d87fd4876efadf8062644e51d3ae41e9c8a35ed80fb71fc28be91713414df3108dce45de727e9366f1e53f6c2e83956b6dfc780b37f29a705dc029b22390076f14530a2da7141ea3564f86d9424cc7abff0da0e2d0fdc726ef26b705b14b6db7e63deb33ce2488317d61b008f7424bd500ff8c9aaefa75c600bd7c95b92f23132be5c774a32ca3669d64d2c0ea791ecf236c5f5e70f21dc52c68ff4339f24baaafc79d26aef5e27b937844ace9ba574b805e3ddd34c51dbdf19767a1ccffdaf16e041fae4fbef91f21fab8ecfc8b286dd019cb2df47668fab48b6718fe07373b6b68735eb6818d0e0db6ce161c9e4a921270e55cbb8f311df7e6de9b461b8359e2ce5509248dd7f714771b6e5c12eb9f4f5fbc14f14a6f16b62fbe04cf7371b6a0edb6a0d270793df6cbb7953fdb5b5b6c3b0927994acdba4889930afa8889c93d5ee2691cc86a240919c3e50df7491afb4118f7d0f047ec2f67a64509b0ff8ce06b934ab4c1acfa09d9c35996264b2c94e784f759047af4038da8a613f38e0fb49bcecbcac6422e340ece074254d7c206552c470564812cbba0b8f5a7f58fbaf36ccc1c80e0067cd7b5e36f1baaeb2e95ac89fbb51e09be0fcf8f64d1e3a1b942aec731297c3157f5b404179ffd1e13aaec595eb051f90f92e470b8a8f3cae3126a70b527bc391ffc8136f1539901c0206ef9f3519135368991bf5e6866ebfea19e70bbb4d2e5806bc427338403c95d3f5b9f19277a42408a957b474e97f0f526caace20b7b916c8fd97b36ff3eefb77f8977ad0976afdbc1b7f3c93ead2c5cdc941337bbe62f05cc3916497df40c73643ca8c335bd2760e1a2b506d7f4580e594d5a926d8e44e7e3ce8040a377ec54792e5e6426bd23841d73b47762a82fbff84ebf9442f61ef6aadb9b905f7c1cffd2af34d0a8576beff541bf4d71d3e600e2a1b2fcaf4a5ee4ce607e843e85f8b6f0614c20a300256363567e6c7a31de5491e1367ed4342947493461fea33d3993266cca14b8cb34c8d83a814d3aaa96877d3da570446417b19dc697ace7b685c3ca205be300d6442730d7166f5576f6f3afcf1a88dc1cc7888a639a5dc7701464b46788a388cab23c48405735aa2d3b3c8e5e902f05e7a07393ea015d0eaf655d649d01a0dd36a15e07daba0cdc2c7f60d2ef3ce7e61e27bbf8c283fe8a0d3584cf1b124c6052cc0f1d09fa7b7ab8807a6a2918908fcdd899e60caab2284d212d0aa9e6afd0e0a78fe564ad43f7107537cc9c20f8e0cc833c90b275a3900bb54c695b3f889adbe515cee36a5dc498755b0c8a5ff5276031439c9d229eacd01e3fed8f50d358db71d1a5a266a2152e691691c5762e2af7f7cf0d1f7cb7d5c30fb29e9b0b7275c9789db2b65894702ef7dfa9c3e7acec606e9a61709328e59d2b3bce109253e7cc23878541856303366b56927d0b76ef6496e939f7a85fd5868e74eeee0b93a8e03879887a33caa9e469d94aa0a6623357df5f41d8aee361fca7a53f6f39e578dc53a6590dc9091189a3c81b92916c9089049bb095435fef0329c17cd00d61cf1e11ab22536f1e23401a95f4865ff5e0d4bbb79ce96082d149bbc62057c621c90c2e7432c0c77e426c29182e28815cfa63a2c62f31d7f9c0cabd3dc73cd3813227a3c0fa835e9c7f91997664e431cbc4d88a1e3609c01b44207b2183ae29650f4c1a87d9caea5b452dbebe9b09e3c54e71f7a3c0429a5ced3ac013473fb5703dc65d5a0982e959ac215626cc3fda3a1e15c1df601c85e6d53d0b1cc8d12d647d1c504c5f33a6d0be98be0a5c0b0a9111a24649b869afecd8e1fefdf1a3cc1fe2f849cf281f2c266c44bb7a65654760dfdf769c61584922f6dd3b92d3b1f8c5106a4cd5fb3015ccd6327e9cb9df8f1d85c554e5b19823ede82c13cd45518fba609dfcb81f2de80dc444b143c88b740a8433d5b5efcddf5b1c7b8f9eabbe9fff56f1a66c2a7b6ff7ee696f7a58880c02172ea1def814ee29030461a311f96ce923443b6355a9c2768844da6d2554eeb51083597c91766bf6b7e3e079e668862e20e724d3bda05315531304b08695415f5359ac415579e47136295b371603286a7ed7691f0043fb30b42a204173e01ddecf3a2687ec6646b15de3fddc2e205e709cc402901e3eebf13d0766ea18e0369d7b799cdcfee7257ed7b93c7ff47955cf275084d45d5c334e4349268b88535e25918a40e488955299f455bc64f371ac485acb6819638f07ac3cd6d30f38015be17419c930664b6392c969bf71381baa21c072c7f9b89d2d6e656ed1d33026a723538a1d32952d1d7b37275a3c1420be2f5056748a1f57115979fd8fe6a5700f2705b60c22c61b263f4c3b0228f170f387adc4f5d37f260c71c2b1c8b0015843371c54c72f7e83b0d7f44e25c96ed8a5b3321de0c1927ab66d1c1a1511723927440aed1be43d884328f96654ff53e5053a2e07d787d5f18b13c2043e629b942ef11fc5ea8e1473792c4161baab6b7c09eba20092185a44a38623388d45033a39579ea755f09a29a5027c066cb52b39103f979906663c171fcaa52d191379b9d81a3f80d0e2b7bf1b05e72e69fb4262acf8b05a9cf4bb1ea7fb75b70100a72c13edd1c2da3c2201b9d7aecb5de149663abf584fe2b92b51d4e21775c44e3f8db1dbd36b062a1e0dcfaa6af271dc014eab6cb5f48fbcb9045b3758d5521cbf3c0aea02c93f7d7b9b79729ecf85c86eed597d5bf70ebb6d4022fd13f6093eb2fb9c1b1971cc481b5238a97b8e582f06c2a1a65ea668be28bf51bf83b6d324c2bbabc7abe2c271b1ab45892408ab8634b0b1fdc1fd61da2f4721f16bb10a38d90d2dabfe08f6efa2fb256ec0ae509fe40b93f039ccb162afb40c496e64e5b55867f70b2a72f4d144f2c2d7d03dfc30ce1a9e5af5d878f431bf1031d8acbf19fc644324478a363eaccb1ff488de740d60d166006fa5db0abd071a9daa622c8dd4e17083ed1619e31b2ec2a98f0997db91abe1b848f3e587225214e9269bd39728c242b75931d6695d60d2ddeca92ec6a25f45ce628422980d8ef2636db896ea0d7a81c0003264060586f450236874e56b77e58f8f4fa05892c5a25d3b99e215724c32a5065fc08e2d5382f5484cfba24d6fe77a58b2110748817b32ec632ac8435422522e7ed7998c0e3c458b5d729740cc06fa934804ed7a823d9befd0437b32acb9caa71bca063b17950fc0d06b812d401f707b19ce7e8f5d86f87fc5fac0cb87fb88a5ab6e4f6e050dd23ed5ab85b3e53bdc119af2f0c129b13d29033781329e92faa78fbba40c9f8ca617216a45b1fc8a5be8d35cc6ffb92edc24e922aaf2b2370cc6b4ab4fbe2d036b3532e6e8555d77c87ef9d667d508a22cbdbe5dbb228f32af9c40f8ec6a232513fe84b0dcb49120c0861c7834fb669875a3313877c3df10d38278eb3457fe757c72cd2a90a6885a270516defcd994aba84b84329daf45987896ad61992ec71b1dca1020f7cc5760dc2b6f3b090e771f7ea716fc68d5fee25c3f4a94295ef5e9e20eccd1a0681d33da4ef678533de9bcf4276bae912f2e43618197e0333f4c53e6b3112bbf5ed250ee7eca338d6818db9ef1d02fc05c66d7c0b3f796e768f827695dcf69cd4a17686a206beeae8032414535e708805aacd1e8785df113df57785f416a08ee37abbcf06e034dc496cb01e83614a1132a03837bfa68269bab6f5495c7a24b51b3b29122b128752b3d05244c0d43e10b08f2a762ad39aa9eebf1e6c74e91b2e963386abfaa615e7ea8c26df08a3933260bf5beea462807e275801e6e240f73589caf4e6bf1dd85698318bae8f49c1fb5de554471322f69ee065a66386f1b292b9ccefb21b0d93176c78473867d13220a675b44267f7a38d5842748483617a2df683eb68a81b10bacbbffa349b9aaa79b83ce2a30618b9c3739a13ed643f4d9c9fc696b4f23fa1e33f3abc993b106d1c96157ade5acecc1176c00bc7b9f5b8168045f7f75a2e4c7d24d925b80e0f0a60f48867bd2da12eaa49f818c2fa6f6b975c3d320cb3342f95d37e8cae613ba5df16c6947ee04d4ab3ff13dae99191afdc345871b6ac351173c1b7af8b0fb4ce436a32415be9784464ca03f947b90648a8100bcd96ef92acccfa7f9efb58aa7e697cfe574ba72255658f4a1c02a1aeaa801b867bb688f3961b27586c1a9e01cfcd125f37e7317079b164b9e91f4e5116626b16c3cdc89ff13287d29693934531dbbeb28a897b15063a6e2ef1cf6ff10b577ffb600d1d9e0ae997c7e1a40f5d9b4a8211b1cec2450161e512630e0ff4988d828916be7f6b3993f3c6f45f87b6d41684dc66ef21e29a8ce73c0f9d01a59cb25ddc8b352de92e7e988b6ccfe51786d8117d789bebe387a5966c0efeb40b57f808f74d112c78b70391d5c874d2b5abf0dfb745553746e1f95cab47e782013b160db91711a090233adaf70821d64bb60467c5890bbc6f6301b4259426a3e16a2227e8d814b293f7b2f212ef589a12b898a58e08b76e44cd19662f6e815168e70463caad44854c5c4f0a0914cd45e481b0b0ff9b892e8a236b71203e0a80cce39c4f2e8da05067b06b82bc53352b2800fb76d0813ae67722a95a758f0834fe69c892f2a414b5ed2702467b31645c1c2451656c7d24319a8e07fb0c4d0d791a2dc821e4bcc711c98d306ae5fa3c0b8c6a53d79c4afdcb837cc914b944378f21f0a7b9f5a82722992ff5cd3cd0b80d174ad889e4f6c04589d22f90c3c59a8f3214e03ecdc4be62e3b356b1f2b86293313f1f36337db0ef9469dd33fff6e197fbdd17bec40eaa25d521ced22e77dc9489bdde3209b41c2a6fc61fb3ab5aa57448dfaa4e709af883a05d0eab051b37141364a28a319b10ae7a4923e0ce9be4330633386a067b28426020eacc88c5977038928151ea46849b6f5ee2a3e627718cb66dd31c8b71cdf798840b36b9d5b345343b9a7c41a896d17783ec129385d501eb44a34d374c6af62c34086a319659222bc5f6e638b2df68038bcae6cd2bf706a4d4f3ad8c36769a1ca2d98b054e04de3061671c58add655f4dbcbb30d0b13ea50400a67297aa389273f72d9b0630fc97ae97e3a3bec8a48ea341aa98cee051d4f6c08cdd4eaf1a080283ecdb12cc80f6d5beb714eac01ceb86c909647867b93d1c6cab23e1a94d5bab9c12a6d854de9bb23d8a10aa0a301cf0fa80e3a12ec9625f3eeb489724c466b47ef4015fbd6793618a27ed1f530fcd11e76507b4153013132920345c1344d56e98fb01a8731ceb91d279a45baf912dd85238270c49a6a8fb32267a3bd15ef79300a9db5d12a4ee489f2575ce4e557ca63e2f5ee7f3826dc5a521a15244ea0a61a60ae1a515c07814c3acce7168b25960a14f15768a18068a71fa1a56851ea4118fb90a555a015506e553c619dbd62b23abb3bfd2d6dbc7f012bfc86f22ec54ff44918b3fc98e5eb8f97b0a4553867519d31095b0960f5f01f25690f5275ca0114e3ca023846cd3b5d4c5eb36f4340168d6fb825250253b5ba8442215bfed0818fb30d5445a8001a60eab9de87c322abffe47bebe5ea786404168753255bcdfef67edf1797dcba4a2a810e43dc74ca6ffb36eb870e4adff9d74d8da9c9fab80f5e3a588fdaf933ae0ac91a6e0fd2433de53c9af284ffc2184988f433fa022ab6fb276a4cb1db5eddcb312b39c6d8905e93543c48cd2f2e4d3b1974f9b829958a602e23d4d475d5c0a50bbb0abbb99cfc32955de04e4933c3d5d00b75c1df36f61f1e7bb809391458f5eb4d269cdf58fc0e19788e587076ff77c11293266387f45dbac9d91a1c8a6a168199cda9965c49a214a040df0883ae3a79fb8ba37acce4fb705dc70787bcef9923b46a513cd5e4ea82c09bfdbb303036660f8c35c1a3f0fa13e49fe30a10c056ff4ab234f992d052aeedd0a616e6a848f266bcf917d4cec859e19fd0744d74d740633b17774dd42f2aba9576a55620ba3483d6fdf30e3e41e5d0ef37db43c72df5034523171304d632e6eb94d3e6fdd45a2c177a2b8853b22050489948235bc6fee0b48880cd005bcddb27ad613a6eda5c4012d7e20d5b616d052439ed3d84c16a55cf86b559366b58cc26c676355a06d71cdc3a4c6b1a576f263a8ecb894a57eb723c76f4e2444a58969629a4007899938f5d5dd5fd0d8a5a27668276e52483e12809f1af15f38293163c5858616ef31361bbcd5c71ea49b03fb4da09dd1695217114ee93bbc86f5e8f93c4c5689de45c872280e1facc582331e027de5b0baa24feae832243dda9ff53f19b054612fc2b205ee35632001cad2af531a8bf05e760c882cd06411fc8db011d38793c1a81bd9c72740c788cb2a35e89f1ab5fe31944c546d45c3392d3a9d02284f262ed2aa2bc67b60c11d8150d406aa2b7530010ec1965ba6b0d41eea7177bc43d8e8927508ff15946080223855194369b13cc104fc26aeb0d1de54d8659cbda36a9fc393f98dbab8637a75de762f5bb59bb11cb8215982e8a2f1da911827c2396c192611520a26c4f30540d72882bf7ed4d46b89e2eaf7e27ffe011baa7b9856a50eb5936972f61f98df9176a5c9a158d218191faa11767e03cea0c131f83ab0afef3dd339957064f2fc98ea7e801e0afa25eeea008ad479eb0f678808ac5ed6147c3e6c5996cad0c10e4bdddea007aca8e3175a877ff13f84df012d307cc0f437ecd79d19fce39d16a9ed8a8fc22300aa04615dca9c075bff9e11c74521360be98744cadeb7fc690ef555ed0320cb040507f4e59860a3fa1d85f485ec7c8eac6839207cc5fa031ee9b30fe35cce5e59714657ef8baec4750a55f90bd8d7f8c9af9ebe950868efd733ae5e8815b5c0ff73f359507c35e2d03c68ff309b45f3b4f55f5e696b02f14dbc217dc01821cff1e3b86ed594b272725aeee6cd0a735928fa8224c19c6c7422d349181fb525f006fe782b9942907d918c8b4f4bc58a592ab70485839a751a2fd7585a90458e82f3ee7341e1daf15b0aa5ee3bbe829fc875b6b883144ee96d463729c2a13f164139a0230237c064fdeed07e337d3746e0bcb210aad00094b226712073805116cdd1dbad1dd7d7d443d4c2178a8ba060ae70d191e15d42b7aef0bdb3cc8a2ec9845368b5c240693dfe5fbac8d2d0a35a4b350612133eb12eb5e2632d8a6efc7d2e8c6848cfe3da5c1f108818442f8a233a827775366755ec804fb6810adc1d1a462a6c780c17024320bcb909ef641612f7d3caf7ca84c7744be8f9e6ee2cb4fb301619fccb0984fd4df085d3125c9bbdc45099b2f6af00a7ba7356274c5adbbd2f07bb481ba32e8609bd7d07aa1b4bfefd182851d01cbfe308510ba6570c629c44f067c555bec0a5f0f4e0e3c215b5b3b32e5f20b38216844a05a58a9df65dc1a029b75f425186513ebed4a880c6a58d240e156954c3afa51215666e9099540d7c80695609a23a48eae1db2862faf082a80c4d40206f65af2412b79a6f8432ff5029f1ff95c58efe084a75b3c4b474483184a965a6c598efe604b1c8b8ae302ba4cd68f4c1185a457e3d79abc23dabe971deedebd42ff66d1b5c7f701ea59ed6adba730a2dcde6f14bccfc058c7b63fc7aff6b7ae92b9ab048b6766a50b95211f29ac65273536e3484f77f1cee27be223fdaceb449915f160a0da7421096efe1172981932fcc75bae76e16d42691895e4ddee6f43cfd34b01b94087d39b6c2b7d314ea25058212dd2307f7171cdc73446dbfaf345e3f65e1823e10f7549c044aab808c4be9a2f961","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
