<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a04d26ec44f0ea1f2ec2483d79c5a7be8a844382ee73cac3b2c5c64e8450aed5ae891d2d6aec2b90d9428351035747bb67d9e18509a4f57077c46ef55e694cd19b5579985090ef892676c7df9e89a743433b6d3f8cfa261bee557836e4f05b01c31e1709498f936cf8d20debe344c01f74722ee588cbea507898c0f249447af41f9c0c3629d724a0c8423fda1b08d9198d48c1b772af48e3ac28a8455c4f8af9193808f7231468cc7af045b189a67f3f3b9aafeebee8c5276768d4a5235bf37b33564613b79a859f08b5717342306af67c508b4fb5dea210605664a122b39612b6e95d6b87e29f16c79fb255b5974a986cb4b199c3f7e9750d41487e2f5894b0d2b8473ef27c153349030874d744adb97fe1e09f9e6f0716659fe063e2888ab914971bc7e12f999bccde46383a062e4333c433d8c1d1d2b581128e0c44790a080bce9e885e82cc3d86ddde142b0ed7c0494808f57b529685d1930f3969b5b9839c6621035237dd33e898785a2b375cfb11680fa71fedc08463593c78bbacca1011bffd2b48194a72ddbc17cbd7209bd465e900411d8798b76c96de7623680ed64e35cf4b1f74afe2511cd96c9b10cf345f85a3edf0f33c4cdccc61eab45b86d4406728bee094fb095f36af1d239ef9177e0e9dc9a68fe3c32c0628cdf9167567fccea3b6bddc09a38198922bdda8149df155a24703dea5652442048b47f62b9ade904eba8598a998e0e68edb10c202f5c1ca263ff7a08a6d70384ca6a77143e41d6147f241e28255716396646a028054e0e29e8dc81a0332d194ae893274acad2b0050ce8d1d699b9c03813b2b998bd6dc34ad98e2d9b8e9bb64166eb4324d6280b7e1ac5f5d4829efb896066aea9d1e9fde62390b4ec689c4cf5e8f4b911dadc54e1767ec939b88ec8ddd751da7fb06f0c203a8eea0c14a80af88b097209246ff02294b0d6345267c814ad62a4ad8a76fff3174b51fb2d1aa3adeedeea0f54696e49b790e700359b38e55db5d91967a515f0b769c08a670e6e6597f3355dd09e54112bf20339995f00fab5dc18337fd1477612d8ab6295829093fd00f6d35e144a735cf61ecfeb9d66b2616bde6ea9bbcf1d562f7e6f17c756c638c8c700f256df0dfffdc264d3d95969cda16512cc1e7b1696be6c51b74b7971cfae4a93c3217a34a4aec89dc5e4580751d4e26b88e9252091a5002556f010c92979e4af384f6e64c78648b8086280d31882c8534cd10f355cff78ff09a1f97fb6a07137d3e45d5e0657a4a180729023450309c21927ee1253d0f875d7db265ff4408e1c433debca255bf175dc73be52e2489a7437cd4ba4e10fc76561e374bf433aac9b46616fcbc33752e385bd542d5f1609ae24464e05efc5b80176ce749597cc8803fcdd3bb5ee26bc6e20665bc45e06445e9dbcfb3ad7ed39b646054e32f7914870ab42d44c467bea811ca68785fd841ddd059f8b34ea450f874de4a3e0cd7311e8dacad22acd6549187d6a68bbde2e05e516260fd6ab696872e1039a86368653a238e119f3725b966afb8fa18cc7ef9fb976d0ae1f921f07b74cecb0179de9c8f02522772951947f4a7f83b1003547480ea5911abeab9ce37a37bf3ee7374499457aa03a0bd54fe09a57158e1f1c803a49c5b06324cae92946401156d0e2cbe357f3d4902bda35ccc5ac9cc0ca49bf22a23384a4eca94d64c123606c438a9d28a67afcc733dc5c20e223f0aa98ae4bdf997b0a28943a7d0c018c4d3bcdefc5b3b1edc2496e8cf8228bca2057625428d942bd49772d27c34253b187262c68d07bf97cdc65a6c25ac609cbd01852a6d3401c0c2c05973b9c852a6a5d8b69eb6ffc870579d4f28e0dd100e59307c06ee43f4acf9cd846112fdaa470698e40cbf58133dac4c12adb3c9a742d689c7110ea480191c538ca2e5b881d0a338178b8ba5b045f84a3be140810abb4ff3443c64772cf109b1dcf8c4c1ef8027e7654b4b9cafe8df44ef90b8d05feafb7575efadf80e7c45cdecd26cffb860876866682c146b90922b40300d5bd111ec11df277e38d4aebd5eedb2cadaf97912f304fae1ed76f73762cdaafc82604153fa9cc083b7fba14da34d0bacfe771ac4ce64a28959304b7939e78aa7f6a378ba03a3c664dae693090f2e9c771223840c39ff9df971f75958b0cfc808f3b91fd99a283464f774aad70c5931a34a0e6a79d0e7082d037ea359dda3087c1fc0a655930f55982b0c252f605e876fb737124c2c7f42297b15cfdf9ad40c71070cba70599338867f0bbdc3dfb0f2750ffb292974427aeddc5c75df3f448013b8b64b3fe8f654402ab69b901fdb30fabcdc625a8346d925448b9085087ddccbe7eba2d4801ffd77a3f1b555fbd2f6661c3871cd560ce794e8429443a689b0cadc675dfe7e26de22bc2cf49863f86e71841ae1cad3f7173b19980321a6c22839cbeab5c730f871e3742f8da9c1d4f38b1c1616b78c9282bc7f4c0c568577e56eda882b7499662edf29612a98e76d04686a675a3c99d3464fdb99d38690ce9ae212177457cfb8b5cf57a6fca1b45040269886c54726d4be7441797715a02e1086d18e03e281ed1fb960d5bb4042f723186807b5e761d98ac541482268d7a99eb6cd65a76f210d837da41a01b7c5d24e01f27962912b62762ae184221e3434a55f1e160044eb1ab489ec253cfd1d6bdf59ff8cb1ccd22c590561b567dc84110fd4355352a173d4a0b7c4c9569c9f1abf93ae7eeade88bd9f4c0ac92727eda61ff390ae8f7c4f425b2da0cf8d525efbf36e58b40032a048dac73715ac2fc9c6ebb14978cbb5da0ef08f134030a0e4d094cca986f14ade2ecc7aa331357c9c83dcf25ea7ba8f27f0c2f357099382820613abf4aa4e364a6ed6ffef895468301500d921527c9467d8f1850bb8cbef98ae74505ec3a4dfb5cac6fa7f84f06ca7118e8f8f0475fd21a58877fc52f484c9b25e4413bde10d090417efb63e2c2a5874d82783a812cc47380fc2d64b168047f7f46822bb93acd4b17d1d307133dcc46cd6789413356c417f8a468702ea5280229a8a9fe2c9a5f6e3427bbc3197b6b05a28e7e9533bc468ef99ce7b4832ffea1774c02722f1fdec848a46ccc5ebd545905d21e9a789dd8c6c7b43cf270e8d4e58d5b7c87dd00a289304e017aba1dac492a093a0d324c7767ccd9ffb8718c4f689bdab7fd8c5b3b5483fc4c02059cdd1046ad18287cde3209e43efc58155d8fe7a477db15875ae3a039c5e5e72f00a66429bb6e103d313fbbcf631dcceeb4d77207c23428808673a643430d94a8bd42010ca56a22dd3964c8cad573be051ae25ecea6075db69c04644709730e85d69256d4443018ce63ebdd05b40566caf3afe30482c2b8ca9f5427dd3c57a113d6c22311f4e6dfcac5e8a3a070277ad4362486ecf7d007882c734d63d11f6baa5408dec9df2e96cfaa5a79ebc1dc0f8e0b1c766909d255df13db86a68478b1815f408f7c1151366451ced66c356d2ce1db30b77c332b27103ba58eda3d63eeb830765ec7e99fb1b7a1c12a3ff3548d62419a38691e7695fe062ddc9555cb96b930780e1827dc09ba699d10b15fc0b58b7d903e8fa654344fa5d35eb9329f42e066aedcce368cd35794212a5d380615f891fa60e40fa9c2619d487422316c59132019b022c54c688b24be0c70705711043e9d55de7d185f6bbca367ad20485fd4c3fe3e2e57add4ce66f4e307fc5e44311668f6f3ee4a8d1755aab09e99fcb9dc3080731fee1e11d0d4343ecea7c2ea83d3a6956110e4993ae3f91385cb3adce7e145f576ad04f1ab4e430800506e18a3c391221c84b33bbd16afe15204bc044482e580b6904551656ebc381782d362a88353107ae751f884207f142403722a77727d4f1ea062442c8c23ba81f81799f885643d1456dfccabaa850d70c2c59aac7acf48ac2cecf5398fabc376c5bcb4af9c7f62dcc6ef36a263f75da67d2b7c8f6e8f8286a7d4e54d50be96a0f7c059b4bb1c23ec3d8fd27fc33b2ece4343c0dc360b2e178632bc4f8ecbe6f13e91d244a6cf0fa18a46b3ba41cab97a264ebe90d143bfb6cffd5214f6a3024c75c72f6bbb43239ae44d8d04f93ab089e255f6ab1be220292e24019df9c71a78950ced99fb86422abde7f255ce6e8870a5fa0127afb14b4b92f592b6d8c071d77c42c58451f0816838d12f73310a38562e68649dff6a73080d6ccdea5901195686c8f1e35faac6a97d78f93c5b88b49a4752a53454d0a54d2e670cbcdafc5ecfa2c84a5e2063256b286f37108a9944bda6ea921202dcbdcedc5fdc6d9e61b603454f8d889624f194740c9e7d7cfb71a600ac27fcae1fcf9f0840ec671fab4e1bef0067f95e5ef1d366f4b40a0fc6abd5199971065778bd27ad5cfa054a8086a4a0336fec23cbdd7e5a3b9dcdc66eb0a2562971dfe1b40a4b17c052b1295f860f8be052150e5cac0a9f9c41524d4437f98a6bb8055ffaa8752c229ecc4673deaabc8fbfe444cdbe1d165ef8bc150401996debc4840eb45ae8f18ec35802c9dce6196260de085cf47f4a7da529a3b6fc71ddff9bad07fffdb820d6f9ceb6543668fb2178bacb3c7900c9878be0aaaa7a0eafd643d8249fb9716a581ade8f48a71bd98b3b8f243b1f609a282cea5aa7453a68b7fb6822a11d3ecae83673806ea7a34ce7155f30ceead84fe0a872b1f68e59414d53045b4942d8239b12a7a3e6ba22554764506a16a40c03a2086e5abdc2258408c368dfc7289e1de3160277a65c204a9c2fe26427c2cb7be4ca3d0f3490e8f464c3f2e15791dc44de5766c9f8758e12772d270feb1cf0e383260c6f80a67552e4f7f377329ba40be1d1ab0a6c0f0f3835122a367cca157cde158ca99c00b3b60e98e83daf0c90e45c40b4509bb6e0a646dfc58d71027cea5bf59cff23ab2909e76daf2bf25a9c30979e57b985f69fca8f70f9094cc564cb0d58e13a5437d72fa1bb19843b60bfe4ba4a2435e511ea8c78982cf4e201d401f0ae0c8ceae8e5942b29dd0bc5ecf76dd1aea15f2e12ae2ad5f3da73e342750f799f363d772d4ec958e7a524fffb7affbe7242c776be56e0ac8f247a4b033957dd9c7b5f6abfd18f1a915a33267a35a01ac528d1038d1101c0bfef8c52856432446113d7d040f23ee1d8b2059afaf4e3fc43e3e21e6c16640c6737d84a7d5e8ffc5d481c4e03e7b2d8855e4b1f98d9b54b16e6db1c4bb84ec3559e9524da776fc4a038f4c8351505d70e33055302e752d9b932a7864cc85431f472148b1c549942cf4699424eea44905dfb0549512efe4dc7a340987f8738a75edaaf2df3c8c89cfd07db54e6a6b175c112befc7dd634839d4c994cade314941a9f843ec4d03d9f086513f5833ed5da6a9f2c3b84ad9c499d43756612d1e62dce6dc918040a679f7087ad8a9411bf92cc7417cf5fce4f918b6df98d5ab33ba9d2daa54443510ed1b88c934d93ab81c02d11a307caf364cde07dab7e105e20715af7f21e4410f13695e8b8a89b85495e52e0cc65542e5ea4f1cea2a5350441c2cc130d7fb2dfbc547946f45d1bc67bb4f99210d445f67cf6c174e9a79a4f3324cf8fc713385de1e7d1f4df082a9fc6e8a14237adbf6f5511a980a4d654ec28160a469f437bd3c578823518f7972727cbed800697d6b6b06bdb90bb29f81323b2da9aca13364ac5419bf3c0eb10e97a7f3a6446075f40e9936b6107e0eaff951aa3459f0431fcc31ce8b46dec34abd0b1ed8719d9fa458022e8ab36735cc47f2755ac040c1bc77d0bc02fead96857278ec398c05ea78da7144339c1428240b9e7389cdc001b3da082a1e447befb358f028e9de323663fc36499a65e27d6afaabd593a3f580d3f580abc05e8e4ed1913eb2e67847227d2eb61c6c6b804d9616828b9b57bcd996eae5cf56f6f2df6450a384a437c965af1e84eafa7510ecf0ddd100b27031fc88723939ad7c93a0e6d5acc4c77829b4eb08a27e1942b0f973bec72af984eb4f174265a136f68b79d571f0ef62565e1f0c9c17f321b6a3a2534c886d02eb2bb184064c7112d018e76ba58a983f007575f391c340bf2349a269a1fc48d936173a3f5c4a6204148832f8ac8cdc7432b711ecae4d292bb0e0b3a00fb6d9c1705c9f354a76b8617a5562d29d14ac52e361d73e6615ca330c287e3cbe98bafa84768a78b98956d3abc2e6575e7f1bacebfb27ebac177ec81d8c0b5e9f269f3ccb735fd8ad1a8e7fe4ae4605cb2f14e01bc1625e80a821ca3a463f91d77e099e87d56387e62be6b96bd9d1d1275044d172e88aca8858df5f0388eda8854af5f0d2c06c05b0a780d6ff407e0adc5721c09449297c81486df5be1985a6cf95a54e042cd816c7a55d1f1cfd908055c11822fe2809c2153131c30a857db9959b5a8c82093eba193b304fe54a9c8c2295ace5e4cad2dfe8f46aa8dc559146c8ed0841dccea024405a5cbbd2f8b814f65f7186bf5bdca3c48ea304cfb1409b34cac9e72c49296879df94ec6654998cd2e5751cbbf4b7c8e48e95b990bc5263a0f27de1f0fdba7237f607cb56cae90e4508ab517f479e50d22aaa914cdd82815c66a1f6ead150571587e7137c7d32528d9de5d7ae21b68ebfffc38a2f00aae463c697de5cbfe66bb46e73d8c7c7067051662fe654929a088ded76521d424bb7a7527d5125c427103945af5fdf07ba4a1857c4433ad22edf416732d0873a0d875c7e66b5c5feb8c37e4b8e9aa2355b5e5439cd64db38d041f30d0eaa5e1543e7aa3a1997b85bb86c6c4d1ea3cbc951437ffa8bc37a0339f4a3591c00750a0e68d811582f4229d4419a2913e3b2ac70b06c43c3e1dbb1e05e794c97a4e3a3b83be316b9a9c2ac334942e1ff099ebe55eaec103ff880967aa3dc00699da86a0b91b557c547906d83e0c44000b33dbaaef9c654835e3ac55bccfecf213b285890a761eb943084a4c525a9040583e3721b0dbb0d81c07e661f2081d749813953f60dd0354387cc2ab7c3032c990a1114b83ca04a89fab3f35d06d8d4b1d3dcd2cf2f0d7b7c8ef2320f614a71697a5d81be0f13403746b36cefb12fd53839c57724eece835b8f4264e4fe9fb91cd82feeace3b3b4c3571a144c8fd840bdff4d3569a5f4f483bf0f4f3ddacfb26d9f6e9f39c28bd47b7e92761ab8acd3f452da89a10baaa105b5933697a54cc87cf0f61d923cd829b264e9b3c3f0c2404fbb57a4ddb9331d8079ac6867a24b4341381fbeca6f2df9027856d9b14c03af0767b99df46f5c1f46d6d604cc39b0b2599da0602c90306ba80e24f528ef8ea3a5d0620a9bba5d506df9d219014564f62a12988d466fb9053e5be856f389ce81d24e1f0053fd98792ca1b58b97920ae83b13c619f12edaa5b0cfcd1cf9b66f73b3d5d43834380a94e0b116ecd0e6b1f22048ed56ea55510053bbb68d140c3b7a817ca7c56a739c8a8f1f1fa9e07fdf0fb877ab11c90742e3de48cc505db4bd9c0a85fb0180d229148b4bafd4ae15ed76cbd217db9e784170d38240af03d8290731d9cec9ec069e50d7c1ffc0b6b867fb2e88859a6bab3782656d7b9683275db9bf0411af13bca738423907178f66d4f423e2738b237835da2ef1eeaf505b022dcb6a93a6dc9f0c1c9d71bcce08cfb4853d42e622c5abda54b9d48ba30cc63b2088968ffc4d4c5b41f826bfa968434e39d97d437ffb123aeef1c73d5e6d21327b4b39640a4e3c1e78349122edcb79210df46a3d9bd5f26c2b3e6416dde67088593559124a6e31f4e62d9bc911b2e4fe0fb1a6d397ebeca6229ead2f8e83c8acf87b0fdbd783a089903ef907464e7df0c8b62854777f59dd4175d1ff1b983d698c02133b328b96da4b3f6045943591d9344ab40d874484cf5cec69a5b9ba5d57188ae26bfac4a52c56addc51f30eaa0a9f73e27cec521bba602936f7c0a62b167dd0643b44bf382538650aca0f3550754dadab34f7bf54c3765bdf293af9305d708d3411873055eefd591ed95722d7210131e7db90b7742b8faddcfe2b49442fb0477d5d04e73c00e936ddbb8b4073c385aa07eab72c13eb41a33664ec2084ea67936a4c04261fb73add3bf3bcf03b7db55848d6aba63d37c321ad2d5217a4b5c63d1df549117a10ffebb52ee5c9a742204177be4100a4ab0f5eeabf19fa10399b2d849a35b6ad6caf5c5695b01cd7101a163862e8ec16d96a43ad108de9360184df6c62f052ae482fadb397bd900d53090857c7ca7f8ac60bc62875eb5a99ee448480844ceb4e2d86981be83915383db8c24678e4b4bc0ac66c99ca1140440b88c03d48cca599d4af2e5ce0fdbe308c6853bb5627c293a23be35fd57a2dddff24003a2b1841b4e54113b977fef948e2fdc062893a5a14eba6fcb20faeb90c3e2aa6540adc88b022c8d0669f1f5cbfda21a2f30441c7fd449dd223fed5b0a735ed64f1088389d1e4aa055d897863430162bdfa74189ff17935dcdd183f958b8358df2c4a8524fa3a3417ccf25a6f6c235968d3d81424b7ffdedf149aad3b22593d935a9b3a6d27ea0e339336467135c9fec328d0c10f1f22733bd219f76ded7ac12869fbeec8b734896fbb4c9821986aafcff6c57df00cd65c73dd415370feff307d2df1a07e13029463102fbd10a824a823ae594a2549806509552cfb6d799d3046ecf9b9f5ed93351934a264bf5463e8053eb597f22c9fdb0b69ee4a471746a6ee83e1f4bcbdf2fdb5cbeb25e173e1e763948704ed7d5e7fcdddac8370afe92004fcafd65d3de9e8303608b52e189c2eb8d6f7a4bfbbe9dd8969a64d5157d2fa1242a3e069e01af471673a3ae609616ba69993aa4b58f2b8b028a5ff9cc72bd8030a169369f1b2ebbce6f8603d1e0d8b78f049e73e65d0356eb6bd294d3f6cffdcc371a10bfb0e25a39ed00aab3f65b8eabe4125e4bf3c48241a087360944d855066e0b53fbe80abe091a58ced86d32cf91efa4bd7ad35a8c2ca4bda7691b60df70bb666bd42c71cb57d7b0151ab4d1f65b1caf32b0e90a6a99f1f355be283387eda7cd05e77996f00ac8b9e0213b73a8028415b55817c09fca8a66ae222930ca10ac798e294e29804117ce8706aafa84772003b78203a7785560ab65c5ddba373f37a2eaa9f008f3eeafd7c23e85caacf5f7d0a9e5053e0560407e9381262a082eb97f3226959c18326b27f36a97c6137e0b853aee73b6e95cf659ed24208ace0c7bced02e12e759597ec2a9b02c595d3ac3e172dce633d91ae1f50fbd4fc384c1e10e83548b6957fa16012","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
