<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd47f8c2e0553b9e5069145a83e77118348de5e7876569deaec1bf305dfcee2325401e2bf2267c2896d6ccdb0e2b28fbae731933f1c3e05067cbac9eea9c7ccabcb3ec1950fa9113b915b01b2cccaf98003a8de3c5c6a51f5e5243223b389290253fbf31d3d2aef4ceab0a429754f617de2c28de5650f7417ca6113efb046d43e968c28c2d86853133dcd27d8bbd9574ad2bea6e3680c599b0fa567723085a6de273f8b04aacf2556daf7d5a8e3bce4bd0a2def1c2a63d7d1b9bef417f85e3b7ab6cf091b37db5fd73da0f670f83f7ec63c0a60740cb4554cbd61242b70f83aca09b0c13926cd0b9ad388a4481d4bbedfb5ecf25aea1da8af537dd521c46766ee580b08bad1dc1c6c79b7cf47790646de1d39cf582e77a7eb7804a376b5134261c2cbc2b719609b3cb780ba3a3f7a82310a3682d624cab94bc167ab181162ed6d20eee08189790d9009da2a98a7915f806b750e653c877c2ec3a2512d1f7710a86a619f0ef88c39eeca154abb3231dab9a4e2327908fbbc5c18a26977f00f256670bf4bf73881f34e98be23347c92ac5515268669d45b41531a3c4edd7f7978f81bc2c6ccce1e388936af5a3ff7dc8c916248e663e5c33ab3882e574402eec27ad2e36bd01a453c863c5e2719102f8853bff003aece76d112446b73b1e21c29c9c8dbd2c348faf2ba76e954fb635b2e5b0d15cafed49fbdf751699c7fad6b8eb0902704563357f1c848bb92c91a56536494f16dcb292366f176bf86db5f98a0cbae46a5d26adda0b9d38f181510e02be31facfa2eab2361e4e32d5508a66992a365772e5686ae8de2f1d9179ce7e528b4acb6b1f4ef6f6f38299741cc1777df7d4f242b12b07134c3fb1947c1b1c044dab0efad3c4f059405533e8c0e5dffb3c0701edd93114e67cbdddcc6262fe82621211db9c4f3f01421a52f147f7636a8ae695bb1f0b46d9b89abaa7f43096a2af4f5e1852d0f1adf60f4dc49a4fecf732832b43b816d163d2f2d32dcacc6721fd89c0f8bc01b0e291ad42f50a82b9d34c754e32a1e9b493b409704e0d9d5cfd6ed18302746214a8b2acea6a2eed4de59c69cc493b51171f43645673fd168b2227795fb2d64edcbb85655a6fa229f16a427187f7828a2bbb1a75f096de221b934381593d0ef69c4c4dbd56dda012f5cfb31cc404ddbc925782564daf229f990f547ce60976ceaad75cfbecfa3d20637458bf71302532efd6a7d5f6ab1c145313462712293c2aa63adfc46995d33ccc4bda24827375d6db9cc1b31bc1c271fcb96db5bb2cf3a1b1793f0e1fdc80921c2c9e2c358734e60cd7082a4af87be911d917906af228048c825125ddb659c4f4c66883a245ddce1b30842c790eea53b3209c79403a1610b58b65e21f6d71fb83e3a9b6c200aafc4f8bc9683a36b7561299ca55ecb2856af6115544102a92e0803be5deb0f2ed091e81d01bf53d4c5158b8dfd72ce2b7babcae503d6aa057c1a53f9722c73aaa85404df89032d8d8a7a2cb4bc01465b6cb37aef029b20d09780b83a12dfb7b92a382a1d58177d3bff24b72e6c47c8b50d3d14072239f821c621692e6a38072aefa69c799b33af2595003f7f0c5bfcacbc8561615fecb3c7360f323ec7192fbb2dcec36c74b4468d38d0afa92bc8682e7ecc0852be2f1c4d0f6a5524742f58238e859c110f70dc658cd62de5c2fbc4ab4002e0581311dd463d2183660f5f2ea7806c066c6793501dfa35474e2daab4d857c2b392ad67d50207b7ac92658169444f967fb58f23ac9fcffd47c1c8d6bfce45f54af59e437bb679c52590ab92dbbf5257efb2dd8a50f2ddf04802b2dff04dc50b0d2393832670fdd8c96ce75b155a3913a1bfc01628d578874bd8cf8ce1086a4b079b84057537c594af29ff537da1d8c650105217d49ad02e3fe46bdff87bd58f5e5a56852d23e31114b18e8ff5b18620b5ee2d14db7c24752e112eedd26e93bc02b780d2d399008ae4de909097ec09bc47efa081564db69a146732ae08f58be8378b6b53802ad84f33332979284a09d76da0098e0b38499b590a4d8197dcfc93ccd03f6455419a17836e0cef86d8e272606cb60b4b0650d9b91520615d85b50836c483ac11c176ef9214b94d613798cbd3a4b571570e1d38315a86c3e578e3c31e37bc8b2afaacad6ad446d50a838287db6d72ebc616e5cf58508354f798ae89f2a660f21c48f36958023e02eef6a1668ee53297ef1f11f30606c3250046ef752709cd951f3dc900e2c8b320e5d846096596dc272a9ece27d2d5fafb7e977e32dcae45e88732598b4cffb198624a786f07fe0bb2032edc4953b75eaf774465a422ab8343052c94e8d90e0e9d9ccd9aa4cd82bfde68e6a5e6d95be31dfa242f9d1ac29a330ac2f1e0e4f61eb4a7a3eb4e2fe9918fee4c051f0e37531783030780e1ec0a7403da96c8c7bb38747523958285b8a3089d05861184669bde5308306c02857c3382385bfa7a4166dccbb02c603845abeacd0d501ca3787ea621c211f9062985e7942dda65b8ac44c44186ab2b5f53d53ac4ec39578e01484c91414ab73d2e60c3b770c2ac287253aa1c8f2a1fc292094224e1ae37bd42ed99ac42419114fdf86b61cc2563eb31891848ce6b10db0f2615f193ac0c40866d609da7e5a9aecc43f9b638aed398b2e6d1723c6ad3c7f5f49fc2bef74db3137f970a3360d3dd0d790192076345b32d8bd871df42aa222ae0becaed1893e1f6b28024dd614bd4e0297b2edccb56329d1c7d9b1bce358c560db7d1d22f1372a84ef618e2233f51f281c75b5398db70cacf8dc2dce97d8955f576dafa30fdb3346466e0ef7e62a1f2eab84b0350115fd89aece2331c93ad75f41c9df6a2e33752a357c0198e7fe90dc5ade00b72c145a0133035cf8d822646cec1997c51388dd34a208ce83d984141b7d74d0aa7beeb5749c310c34b92536cf93ab14d8ed37bba0a6cbd49b4c1315ee8a70bcd7eb4198816cb87dacd2e2c81aaaa03743bba8e13a399d628b132115a7fbe3186168b6416abb9d2a6b1651bbd994d1faf15d53451b4cd4e05fc76bbdb4fce20a774dd072bd2a1de20fd75da6574087caf6c37d872388aa020d0d167230d1380ec97a182b32648868ba92ca5ec459577fabc9e1abc079eef6fb09d475235c0ecd50341910b64497248e15c44cbd8e58a29482b50f656bd88aa81abbc8f47c9f1f6a0979f62942f18d8a50ef395563dd51c217d3e3925dcea7b78ff599b381dc529ee3c59f39488b59f71b4f7d1b943175d5db368a0376aebcdd9b66f3a50ddfb933291e283b1fa257139d73096bab47a2ce97e84f4f87b13dedc318c79dcbcf5e61fdcdeb93e2700dfc476324a7a2d6754e35949f0348e8e08a36b3997bd095ba6d4321ed8d18838e59071bc8f1f36646ccda39e14c14813c0825e6e08df2a581c5dd1b7fff5fa6a1f4425030ce804cf68813a5771b7fcfaabf9655d45142f9b032b526e690ebf47c15726255a13789504086361518fcd3e54ef1accba209785cc47257a352888db44166192c9666fbd7dedc14aabd42db079d349318b692052d632208353e8f45559287b0950fc97411ea9b2bc8baa57d581d443b89033d425286d5d8f1c2c0668e22115eacf6cb79d85041eb8baf3eae25c6e00e190ad3db9ac34150f07a48493a85411f8b2f07b05e36694f88c8d7d3601e6014f9d13f422776ed2d7eb1ad984a24abac9750e6353b1a28027a68d60eff3fa7791264699c04cff6712322f8ff624cf767124a1c55d0170917fb92170bac834c2100d86cabf6a291909a6b5a9f52da4946cf9b59165c9dadb4ddbd363d455c417a573f72dc212c4c012bfab405aa57aad6cb34caf01422587aea4d98afb36e196b9b8df726822c541e98cbcdae1eba658b50116176cc2878232136da879dca05fa7626160c657dd80487a3538f582c0f2ec51f7479240fa423575068df756f2ee435e46ac14164f06481354032599867fb9628a96a15bd0c93dd48d2c74c6cc6b33814633be573b854e5be084959ac255a3e5cc53ed77a85430c21a44bf0963fa61d06ed99b4cdc8e103c389e7e4b0e3af73e30455e581fa0d791a965fbb9cc17f7d4d4faa4f4057a0b4b35eeb5123d94fca067886de993ed562eb41f5c61a5739f7b3b4efba371da34229139c82a28b2bb40e9482195ebeb7d84173543e30a69dde43125dd07e3049f1473c84fc9470ffce862fd187dcea3892708e673525f7b4f0d59d4821e0ac61457f5d851b2f800e47ffa4db38ff28a16e208582e1a86c4ef7c6d4f05b546bee0a5d21ff0dd55066997a432c864fb285d9944b5f6be00ddf526ddcce437cc1a0a09f21428d1a90c869d6fb3fd0f709672f3a2f95404a150d0079c0085199b8d5e7be0fae2675eb92b86ac50d445225d0e01e481643670914d5384cf14de5046d665f2ab95f9f2539ae1005bb06b7dd848f1d1523cf2ccff674d7c3c8fc6f7a4cce62f168a649092fb110b0b752b5a91bf1a34ebe8fb14c57fb8c96bfb5dfe9d132e0c7bbead6268da8fd36843bb3ab086c3ae6e14e8ba32416b4c2528598aad2dbb03e3b9df782f5db79369f785dc8f7125084134180521a05851010dad10a4ebb099c2b302128059b90058ecfd2a2961f8dfb52ddf9aea62dbbd41915c85f4d850cd0d3aec137eba04a8c66fedc7d9149a5a173eef29b736b93d370955c07b12c8ee94133ab3803d0dd0730e0a1c382c4d3a9bed23a04c1073b9e9c917400d087f8eb14aac03263250d8042813067a10123a7110f382576e84ee14f4fd9b8b3a2cfe17718294897f46deb4a5eecf4e459d59780f33521973a855b6c9612a427e37f1f63528840cf022aabe6e9daf782efcec0125fa7af1ec1b6e4ff0a013af4b4cdb9e7a9764eb5c3af0a36b9a5ff132dbd0678477fd60944001b21763645f6bec63394cb467d9695e40a7cc563c0ea5803be8f76f1f8a79b2a70c8de0186f3e6f874db95e6ec45670f8447f4c11dad17e24c253bbd94d8a59f58eba6f6c35b9e6b941ec0dba313bed8c61cd95faf995b328a5283e7f39a841ec5d70e7161d7110ecb084f6a850fcd6989f9c549fbf5d42f221eb0a3b049eb0bcf0d4dfb090ca676c314841b4683ba3e81f5aced2b71d9a5749d5eec61eed9b3816f8b7dcd57560f83197831d6c0e1d3d0b22027433f5b94eb7522d26e0cc62bf53984abd10f6104c00e03c64e4361dfdc3fef028b1a6ff15318fd7a6b410a24a762ed0fcf7b5c634f42a8767f191118665d84cb62fbeeda5ae8b11a4d817e7a07113df95ee7a850f962f372462125f07db76addd3d15516b2733bd806ce1c5d46232bab04ac985a1afbc650a0577dcf2a0689f6c40e79102ee58bcf8f6c514342e3298e039886d18f0316089066811600ed9202c5c1b2f710d2b794ffdc6244a77d1d8dd3fd425a89dee7453e5c53ecbdef399f3395756d0a1d980c1e9e0eeb53ec0ed7465900477683d80b97b44d706643ca99467f157de894056b00acc8378ea8703eaeeb3ec5dc115c2e7c0b42c54889093c817f748685bb5e1cdc6bf2ad8dac1dbcea5bc476301542f94aac86c002fbcf52aa5ae899c2ecc1a0225daf6a1d1c9e998a9206325427df3258e48efea9d7f447a4f6fac8c6bdc3631d4f7210b74b6bb7b5a8392a035b972a5b248fa2945bb812b575f6308491ebce4f7d6db73f99d859a23dbbb3d8bc9a993f20409e5b5d6d716095f311a87b3c2963f6eeb6791eee9391cc69484f03b02f3722c216e5056a11b63f6fff942b3d12c9a840bab13d882e2d085a1d2f74b70c38cf2b502c1452a003c4f777c94aab050919dcbb68570b56e4b5bf99d0ab19d617f52cb468c27ccbeadc9296af9501849076ab3c5d0fb0effa0e9d4e9f01a288dc3baeb9618367d3c68643b620d14ed26d09a2b0a8449671db1fecf9c10f212cff4f7bdc6ed9a4d0b5a88aa089d4d5ad5442f17ea137e2585eb3b276a0838df015242d512c8837037f8fbb9de256bed6fa0997fe657e87a88dc755d70c81e783cfc656ceef0daf22abdc351cd19d2404d17296a52b4f7ce28bb2e9df7cd94b511c849f0912fe207eb59fad0598afe6521c7f90610937b2e3e2f9fba836479ebff53208e3a94f522cc70daff34ccad49e1479f49720eb17dc6c0c375c083ea34a4c2ce618063b6c363caae96eafd32642dd766b02a5647031d41c364e913949498f34b8cf1304abba7212d5e46105efab10b4100322e1e044b861e8ccd9d34c3d69f38918b0187f6363d9a33b611ac945133ce5b5d5393759d46fc9c7b3557172c6ea6d0c6fd311099405cb69e529da68ffc35e7db8c3da34e8d396593f46dbbcbeadb1c19f41eec35dbc806646a625fedb61a5c348173101c8cffdbc2c71d633ca3d3bee01327103a99b8b926843cc39e4cab4c6a5d6330bdc567b1e738cb8779b40012dbd6ad34e551c15bf4dfe8cf57a0da84e085478f93bfa9457545305dd9991b3d585c2731d765d207f5f6deae4048fac42bd760115fa25f6fe18e1e5a08c1fec4bfd0aa46628ae1946bb31a3e4214f7ffe1a4464b9c805e4a84430f21979b3556e1bc1b9f2d47487e5a9cade7412feedbdd2d6be5f56ccc3bd07b6759e5b1da2b2054fba31bb2ce5c0303947d6e3b5e175e8100f62582c4e8a6bdb5213e83660bc9fa5d0755523c7fa4954aee46ee2a3eba6243892aa321af7e5186d45c613505c092de469bf9048a1e21326a26c38a47058e042c44e1c941be842205694ea3863e0bd94212ab3a1cd2855a38e17cb7b9e39ab389dce12cf0f67c4c41403785457adf78be3557be4391caee181304f4db25822e726fdea7d4f2fad1e1966f595a9b18fecc1561ee14fdf7ebc695a12167d1c73b95d81b7ec16c75bbe9cd2846cb3778b5c1df549558513467086b56f5b9ad16b7ad661e7091b58644819c58afd0e7009cab890389b03a27cbe08d2386551e2d5ef71f701ecdac21e689960ed8938d95102004c73bc715a3ed208467a25c62577449dc40976b92428ecb17b673c9930b6aca37a924768e02aa7e50e9222f37f871db8ee5755bda3d5ba0d1cb083ad31ec599ff5bf8ef14d7e2945674ee1ca915c392e211a388dd90301c1bc54b174c9816a92ecc845185a2abc785719c1a13bed1b8207be2f7b31b4d749c81f385f06aac18d85f054d40559ffba34186bdb8a017b8fb16ca76d206c6ffe0c20bfec1e9d4b92ca69be3f2ac20a6d0e05f8d832dad0e0247be8ceabe0fcb1db8999e12a6a9cae123562a2154d094a344617c88974644a3f6dba870751df9363b58f8e2739d35d126583fd90bc22b482a94bd76890122c04a35bc81fb7417bba855e0b2fe1d64396300535c8a3de220a773610e8c31f6a6daebd61e5fc6cfa74251abc015b56c27523808e2b99d12ab02327dafebff520a4e04de119eb0822c39fab0f35874b3898af2bd55da61a32fa909c0bf62000e749333d1edbd11d2158dbbd5dde707acb2c63201dc74ac53d5c3ba3474d89b13665282c9230f0450bfea88d4a5ce358d3792be96c6b04a08cd520cdefd3d01684fc9fca8db70f82be4fd66ef7e6e2cff58e9cf2e4f2d741f0b35d31ecf44147a56301a057fb4caca898836bd3cc994c7565f831d7e3907d5550e5ad56460126605a902d25141ce8f2ee2082ef0090a3fe37f7597d050013570ddf0836d88bfbd1d7ae2e8c5c42fc0a384c09ce29abec5ad00b239136cce9c3faf70fb1c6e05868fc03508982c257698e2ab4383bece24fb891119f945958038f782ac9b95368bbbe9417bfffe582e341bd16582fbf250bd617fc9d5b9aafe519be334fce24b8a6544177430473900510a12b62f1f70063b3f18870d21f16c0ded913a9ae61606ecd320c863ef8a3ffab9912816ba285e87aeea22968df4b2a3074ce4368819df87ff951561179696483053687f90e34734963fecf8b02e6bfb4a6f72dff50340d8f5612e9cc6200eb9976c1d44d974bcff8f18b25a94832e6d0107dd1d0e758326606ccfb91e80ea1cbfdf7d8b246ade3c51d5b0d73d379e99550fb9622c4ec414d42a8b28024ebd583dfb62211099451965e8c916dd1ac4924096dedd13fd31b5a7ea8d735eee8954642e4e8a83fa1b4bdca4e8bb4974d68c9765d0d3a57d08b7ccb1c59bbcaab3327b839f5195620d8a2ecf0da718bb8f05426274028d7f54a70ba2812c6c577e766b764e8f7bed3236b4147925108d60b6376d67733f28e002fd8ab41a4ce100967d8bf546087e366949091770f357f8ff275ef03758eeffdf46faaa0bf715e0898166deb5051ecfde2b7afd6546720c994b50e533fb6d81bc76a0faa0f868a5b4c80dbda467a6da162a6088de67191d416e319385e4f2d361a21d457a0e11c078e4ec8d6f3ace2555ddfd6a1d7f2eee8c92ee223f0436b3db7566063db3be0b76641fc9a80bda5985f98711dc6b12636b03e37956fa9fa22b2059af4f0863eca23317c1b1a8ecf6a644620b650c2dff92c9f27fca1f81fdd480865a3052174bdf5a50a53ccbb0e692ca5d0546b454d83898a7a587c87c4b608335a2b863e50016a22e90ff6f5c8a53dfd7e974ce7b4d918a6c35f522f8b249298079582619a82f6cc565495885051a073bee5c6dfe2d6ddefee788325f1bdc4bc54054e4ad2931aeb259a16667b1c42d66613690d7fdab300cd028a49b7073c220f29182edef454fee87186eca18e54a77898afec3d3ae4cbd5c97272fa3f80384b2b79af310a207ee5ba0670188778add65d978c50848371aea24bd330eb551019c757415fb37f37d0fa84dd40c54626b9508e5c820960cc86328f65a6aaee5b2c5e4bcfc2f84593fb9ec8af14540698a690f2fdd698c372c6178d1a593fb6e4411762e1840037f3d9c6fbe12d82151ab42379d72fd33f77ca01b45be582908586c2a3db868ed14af559a79edd2111f539c8773d458280f3d32828fe310c5757ac5ae617a2265874c98ffdb197c2f0ce87d5ce7183e676dd1b96d9e9c4552399a1ed34c227d68f371fc7d0a853a905005a7c86f4b8384ac110569a6603aa2f1652873d1941ff8f13c701b6af961fd3bdc9381ca6cab7ab6fe8da383bc5c43fe15bd7a6d6e29a49d3df9e5a681e6c7a54f400b919944d9f1f872de438152ead6fdbc0c1f67ad504f12e084a617ea231f11eec7e58adbece1a75eafa9dea1e6f613380031b2447ac3ec25cca9138fe0b980cc4507a2ed6a2cb6557e4adb394a63a702a6d7b40b83d439d3d356e715033990a1662accb1c47c4ef9b23fef095b36910528f35e1be3fe89f3308b8829cfe3a4c4706978acbb96085fb6759ea1373e99539299b2413a7298c6e88858284f437889bb242e9539b846d445525b5efe4a4a2d8aeb19fb465a8d40dbbb9dd845fc3733aa643726f480209894fee92082b67c7e8eb8cab5c6426d689f93544cdd9a85dfda67f5de630c6f8625bf0e620feffe8e017d3f5ce602b88e8511315678374049e26dfbaa0387866d8697ace1a9a92e8aeecb8302ba14cd4255ba66ec9a9708d633492f0ff2e542f1ca69692775fa87c1e72ca96073053e0fda00b0dbb9c45887b0f8844f0aea81c927b5a1b20694f884d6dce819cb52fba3afb941d619ce27c64544b18463ead2e62693fc158064f1d0e5c6f096dfc020f835d229087310a2b43787cace47a2342197a16e2e16da7cc9c1aebc4df9158f8b52936294b25a0039f763a0dbe9ab81b0b19a2d764f2411d9c8fdd9eeb72b49c92d897786b3377e2c54b42d0cbf06596cc2c999334f6690ab54ecea14c946e00e6d27ceffba9520ec0728228a4dba441ba84f095e20cb2ec426c13299b7ae9e89cfd5223d3de007e7e5d26853f878cfbed0046784559be4e749b0284be6e4bcbac17d1f44d87e2437b4808f3ead8d4c6efb0eb8ec3682079eb8dc4685e7ce3c339564b4422dbd2b6346775a3c2e01915d3a2be0860f2797fd104722e8c0dabad8ab837afa318457a004f1159083defdbce5a90ff88a98726c699a4bc95ddef9397a29c819749e3adda450518410e559342d6a2b7b5734fe36f36e9c6aff24ca001115d76e12baaab53753b4409244039da290dd490d8fdb75b0cf82e19906039091cbdba76bd535e61c96f463ca16da3741fe1bb2117560478c9be7b9ceb041c44a33cf91e796c3b2f290fc33b02fdd305952e8085e01c94c93426d593bb22ea31aae5713bb1676103b02ef4d147b16eff1fdfcf21b2137aa7f785518b3206b2db5567f83a7d387c134e89757b49f7d39ed2835c8b9b805e904a1324d2c824736e8aa8e07e0cd6c03573f5214e56b72e6858fb36f0ea06bc4f8270dcec003034d4d93216a095181758ded2d927ede4dc2ed614c4d3d2325d31fda8883ce55745915ce9a4d0503a1d70fee7cea0f1b18a2f8c0939b6b2def4fba179a20d8329c9a336152452529bd891bc74217572dda0470180dda2528591924663a4577fd0d62a03b2d6917928411ed6575e5105b4d371b54122c0c289b4030a12aedcd95084334254f0c03105f6665372d53b30d02d83d383bb4cc61739166f94ee600f5d241defd6648666f0aa61b0f523da8ea5336f82a3e02a937658ef38faa26f3593ef628d08be808da757bc4c4cfcf9e3be527e04049b64e4fb0f3defc994db92a47df8aa6b68e59c06b1ad8f3898ef11ad3eb2d9b5dd94e459f81f20fedb3eeac12c92ef11b0938cd38c48722562335357ce19f7dfbad3ba5d07d4d200490e6885d9602645ef86dedb6507cff7a04848fa9010118892feb853c64902969a10dde4f4b0af01caec7fcf3f3ed5cfb7c223b73b95b93632e1de2de288113f9283c5daa2f4efc46adf88a55ae4090b5a18fff089476b626e9300bb9fc3d7b755166b1d15d72b433908ec7bc3762ee6dc341c1642c40e2d1578d321e1b7536c0dc0cff8fce3fd2883495d8ea13f56ebd4e93e82c28f2063e921285ee2d78bb81761bf1beeff1dbafb98501896d89e8f492dce6596b73287b9a9cb192d8f906726e633b73108d576b6102316506ab31dcd51ad97c67565dcb7f041198ba050fef81dd6ab0c01fe5b3c0c4caee3e15dcc0d0dcdeffb4adbf9f6ce21e887ca0c281f38e33dcf68162a3a2982fe1588f4cfedec5f9b24d417ca468bfa98722531c621c13ee72569e2a9edb5c47efac78aa2aeb52704660fa52c2717cc81f4a5093838f588aef6f852c82464ed905c26d12e008b47d054a0850bf55250b897b5560267437f743ae9ac2f0808f44641b63eb667ce853048bda56300390d200640ebab5d700cdaa9addde602f442c121411380b66f864ff74f7bd1c8268d18ee922b5295b31a4b57085de967d81656a595c5d9b2be5b4fc6e099a9dffe16e486053171207d45ea48cdf0eaec3b88fc8b01ae860025940b286a639f589cb7360ad45cbcfa5cd7edb50f2cc9078ca94ac08308e623e68b094c2bae604f0d3451823ce5d76197153b87faa660db5e4b42b5ac96db5ee61713382f2310a7965ebd14b405012282e7134eda8b26b05cecbe4d03e73a027c94a6b44fe64016049c095f0712c552aaf0cbaf83645645886cebe7c53e0964c6a36f408f31d2109259429ec43fbe237d0bfbfddb34748e41ee5dc18f66ba5cb63965f4c534ab8e732ccb4c11c895a5376cc6c7584ba9470118c727dc34bccfcb17aab3f423d080f8e459e8cb522d06a66dfdc5fc15a9145f503a1e5b7e1a2a3a9400ea7122a00c75a01222fb580e35425db207ea504aa6ef382cd93819c8983e7822d9c320f4933238c65664decbbc345a18358bb767aa098e868a46705ca07417e4a0f1d592fe0f7ed9fa4ebe0f2fcd6fd6ceec7e86d3862747a9605ba517dbd1f39d831f691e587d8e1bb5866a5f921b531ed477ab16a46f8f1b53f932557e4112006b8f09048ba9df9b9f8df2835d5cb48e13967f70af5d218cd8ccc1a53ae895fcdd02a7edd571eb192f21bf0c017b515e452717dbaa4cb31b45e5e58b9762f04313bf54eaca29c39d4bb73f9653229bc069982e56eedd91619f4e8f304ca6b6d7b61fe90acf63604bc369435c41781c2f06f2175500b387abb2141a6e0df82d87bdf2a96aeca1bbc5e8f9dcc4512ad79010ae43f2775323e702d1bad1ae019e0d518b555bbcf86d8e6315154effe02157d58d692971d80c1cc581dd53ef5553058c9c29cecac68c11b191b0b918cd7c3f8fd44df041bd82f21ed50d901e07d578daf2250f9ee0142770b46cb21a9d9692b1aaf627518275b11c15c72c3fa031fe2259bbbd686d86968718bdbca270303b3b24b2d4abe9746ad292b3db554d3d1da0186b46820c4eb43be7ff8e0d0b82f7c676ba974d49767cd514f6b17000d07e4ed8104086391a31427f0cc668577ad5dabc7d43540dcb08cec8ded1e89b36a7ccb736850e5c54a6b3854303a79d8769c28a1f757b7d812af8a0b8e9f9c8804531e1b115977cd086782455f0055f4736696b504d227d26a683da99fb64bcee71f916726599ce027c4c069a4a4b9e7691fdb49ad382a06bb9de5f34ec71165fdaee8e2e15a1947525e9be9c3004dd3d9bcc54257acfddfe290a0ca5528bea568e2269dbac57f769daed15cc284ed35fc16e6de0a44f237a616396c9ec9c76619f69763b616f16615833adbd330b497842a285587ef999b282e1043e06e9a869e3eb0e5e175866cca79f7187ba3316c3db692aac73fecbcbaaa4abbca79ca85a44debb96633e1ac240f8bdd6d7ed63e61e0be9cda16074d04ec114636d4082f8f709154607621ecbc59b830c5862453c93776826b3602e118521b40ed9b76e548d952ad2be341534be9e6318d41bc0514d410159f51c4421ce20e31e3964101e104a1cb3a23d8bc6aa551325db131319a82df34c1630d68cd6859eadc55b8794a92c692cbc39bd723e171550c2ba49f7b37f8d320a047dad3f38e92c77101edc4bd3830230b3503e18ad5eceda359144a2c3a8d9afc1f7180102604ed5090a6c05856cac84b4af5bf412f96fc3a67f9804cf29989f302530e62f4ae5775ad868026ff9d9498b2a0955eda8eee1a00c38d74d43ce5a8370439daed0ae172ac7ddde7bc8d90c32b9d7adfffeb4f14b0da0150d5cf15fd7a090b3baae7c0691af082de9250e7f4e696bde3f6cac112780b2e65aad6d0d1222045d2723fe4351fceb919290727ca5a6ba9bdc06d87a3dab88f52228133838f66fcd20fe15d155825bb3dac3d6626c4f66c2a3a004530f5ee4bf1722e1420e12c6c4ed5bb92ce86e38af7064f92f1fe34e161a4428d9a3dd6a49a880fb4705b9547a843553cf70db6cfbb42b44b83d0694a8e53379cfa170f5bb6fb44cf2535bcaa4033d3c0c3065eccdf8e5533d8983707a3e2eee4e7cc24b137c0a884a2e1aea0fc7f1a82ded73fdc7093e3d4a88b640f430bcb9fcc182f41fa942db2ba37d636cc08f0512d63ce4689fcc7c2b53e38d9e7dcfb72b1612c2766797b3ba3fb59e326c97f89ae6a3660cc6a1996e192e946d19791aa9f1bac54f2cb29c10decc1a11517a4bb79165a4f19cc2191cf41196ec8f8bfc40763936c7609cef5e2a29df6e8f6d54825facf37601215449e490b975dfc4fee3ebf2a5fc325f0b4d2190d6d9b6ac85835337e42f9cc396cb1549708e9e12a015b7c037ea85165185e7ef60672c699b7e66a5d687bfc6d1ed52fc5efa97a6cabb19980c39be65541c498c4703f09c200ced1ae940ebced6053c1e14a70d5bdc49372ef540707929a32443aa811713e8711fe14c9e8af2ebda0b8c64060ac1d1db32287734560bd2ed466f1fd5d12305a18fc3632005ce3ef3214c6999f1e5281247248bf67b40865ec521aa244414c98179c374982ccbd52b33b2ac39e58cf7aa0162cec2401eb5715c8984503e69692cbc9baa0b9a0d7fee293c7fceb350a2f4797d7fc0f185732d8bd0e0b12c3485c49de142841b48205a0c1e12d1aff16cf9f26c24363c1c24877971e07c3f63b493e74a4524328ec167556b466f7f70f88ffbd1b00b2a399e2b4827b83b69314bfd83bd2d50ddaf4110bbac6a38f629a5f869c38052791284fc9c6c03d3433a7d035d1402971e7cbdb636b71e5f2829449320733c7199001b3460ed0957677e0c0d54252d749d8f1094f301e1feb5fe0d1b72a4ccf706994182266bce9435cac80e2fa359ce2579d7ffb5de759a67f90a9d965e1d45d1a9f03f96662b7ed08c93c13ac85b393ccd0d2e0f408562bc48ba6e282c1db48650b08913d545b1e8dc183e02a089cf2d39f70c32eb14612473a62d8b0dbc1a7fec7f7cb424fda72f662c99825eb33b0b32cc0b80a57d84adb842da981b77dcbd2d683925d5a677aed5389b9602624ff1abe1dfdc309e956976615af837e27786d5a097c62bd94a8801028941555940963004a98db745aa9ac6792671667470732b7a0c93142f42caf6ee7d92618f3c23b45e364219f556ee8fa024d5b4ce9291677a13304654bb9e55e97f28b1e2e9fca99f41e132142b2764017a4bb35d3bc784344759a7f14db946a30d8b53d1eb8b3c02264bbc2a08d677af9bf33760ac5cc3b497ac05364cc13589baa13899f54191af40bae5a1d265948ffa25380ea6102703028ebd66af52abcfbefa771156bfaf2b76ef7caddae6773c5cfc5c45f32cd33a73cd3f2df3339e9eaaf20da9a5087f7e6a2116e3555912cd5a86081be10fda49d707b6bf42d858aa1d486dbb400d339d475a13e646a4dccf839f38e1bf83a3c67a0eb6ca85325245498b72db3cdbfa5e84941228e87eafdde4f390f3b64118fb9e97bc12b6c8da92a0c2335b11ca86b460167dafac421fc1d9a5ef4206978ca34477fb21b547f9f76bb9c3540c9e20312497a4ac4779087b8083d9b7e608a4e4ae72bed8a3944250c7d774ca51d9c7f204a385bd758c5c4e8b43a3a39d051eecb54d45615d86648f49ae71a70748b13082ead2eb1689db09bef24cb6e70b6e2cce7d477986bfd5f046844a774fb4dcad87a6053d966d94297f552873a5e31cbcbdccf1d4f10362d91686f3e5a3ca6965946100d3ffa17e9dcf0d079b16d2196d99436253954553673a4cb4466a8f10ca3b1e996c3e9d5884f08b204f77d91ee89d0db2949525f78d3718650ea5d66eef8d03e2581051f589c301533b2c87879208dd6d22b34c9b9c6e37eeca81feb91cceacfb536f4c7241d5dde03b34658900e6ea7cbdf6e2809940499b8f86122ca3eefabdf583ba25d9e5d9890438c06a4a9f246123bfe8e514d0cb46e9f770bfa3e71f5b2cf7aac97e36716b1517d8e6513fe34c44dcfad6905359b00ba123e864aff1d704109da53260a04ae0cbf29642ca15d242cd5763ae301af9d16bb47ebde2b33aff105b6fc9027cce65c9104e69f262108918faad36f3e0085ec44571e64da9783ed2ad1291f8e57b4d880c4c69797a5b0858c6972b37be9448896a02f6214c8417549808f9d8613de349b30697e9be2c43b8356dd0a75f7ae342a1d42261f9d1f3d63bfb660fd66d80254956de6b9832fef8a05f1c1a5a1ba8a213ee3c33d23cd0c625c23f4780ec59417f52e6b53f86e2eb3945d692c6c0c5be388439e19aafb0803d317bf89a5f09263b6a3beb7a5bfa86f7908b43ebba16148e2af266243bb0dcddf1aa75dd8ccda8b149ec6d0a88179f33075680dac3cce70324d59e6cfc67ddb19d09ae2d3bd3534db85b4a57948da36fbaadb9c5f5c6bf37f82cab60c4a893bd2ef1776145cb85fbf8c66692e6e97c649e64b2c92cac4c5f8f024678e1ca9cd0416ee56bb6cf106b77ce652b495cf7c2d8a389a65bd83d6be160ae402158507b35cff9b4d7c4bd5df5a9f17b8f847a697050552c927d4f026b6a2d0bd53187dccb0b4c0e86ba922f87c0e0b9b6839ec6dd490e06bdc80ba2e34bb04c66d720d6617c3625e39c830c33a2a3342e1e093cffee5b1853941a956bd5ff3eb055c7b4eec9ed3e13106a40078d7b8b50a4e2d5d65cc0bba2d240daf0f1a2b17a90cf8151174a3f7b304a3052b05a5bd6eaa3a8fbd9a4851f91b3d1a4fd1d5d15b13a79cea5d8f0f22880cc950ce51fd23e8c7f6bd3c7e48de4f85ead9b7dab81c7c8a5d1e6c01b94430747e3b6f1d7f2a9bb0e5f2500ee8671a1f3604174213d3f899a23f73a716808b06d2843e5a620a6c904b5061951fe3ff171159203e102bfd41ae91545354fa7965ba47d174a1bd942def4b5da196890dfb6d27906d31dabd1fd9d9157711472be4b0811e8adaaaebb425c82aa2da0a49fe324dea1270664da82e95f520c7d22304cd301ee76d4fedf2d99b5b0891ed96ccfc1ddd09358ba7be837b2905c399335e14a89b00225bec9fa0d4908108ec3c8fa7980390c53c1cec268bf1c075d57d9d4b18eced38d63a0aa42b35baacce35f8a13f4ef4c1ede1e587ac81a0dfa49a3f3d8f273ff0cf2167153f2ffc28e7a66ad8c3206550f535e9a83f08792ebe3b614a1536df21ab32c8ffa47539f22df0a747a516ba3ec21ca6d84eb3efa9d5d323a70feb50e48a773ede7e90ecda1bcb91a7ed0ae0441c4559b9ff81945a3b9b57eaf3bdc13835c9bad9d8816e070585eae4e9b50286be0705e04e179af126a8c43c52256afa364e8c9a57a4231e906dff8fa9fbf444ecd673b41806307a9c2d0534ef392a590039ab3d5e6befdd62724968d6beb3089960c970011de4359dfdb1083fb5962b031ea69b372d91d98d2cfc94c3a76009d7775e70e0d0500688f2861c275f3fb20e08b7a849a56d2826217e420d420e3970f01aa6f33de0c999b1cf95d193c78eafa70bdc3ed21195f53e6b9f839a1f9f249e24766d0b9232975f0888b3f7e61fa79ec2c518f82caebbf72e4050173137c0b736e4e55c8e1af8bd38aacd985a1cdf4039172e29cffc07609253bfb36306912b4b8e4c1ba9d9e61f43b3c2dc3beee568cd5607ca8d46ebe0daac74767ec76bc77df","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
