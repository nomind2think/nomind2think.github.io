<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"12754b61ffa818cfcb3f039a6db6f4aeba34334044e718bede65092be33c3ebc6002f1a50cceec7d95031e6935d6e228d6c11451ae23bb6b034474bde7bda4003ff02fe7f1ae8535be06de261b87b8152b9484de48c99856490f6ffc510a366783eac016dce61b5ba57e0b6d6a5fcd10dcb906c6997bbb953e03bb31590af768010f676105040cc2e2fc85c77f99839f41140f6ccb520abb8e892679ffda85bbcec6a6a099fc38f27c971e169315bc97f982defeb118b37531e0f4389ee841c9de8011bca3e22c207279e8cf6badf6280bcd60fd1cf591ddd64aca6820d66c3a4e5540f1a9001475aeb6093124acdcd4bb182d35cd5c1d1a83bf6cf246d10aa086a1986ddd66b7f396f7e19aaa853bb9070a275e5346e77cd9ac58fc21a11d2aae78de0c8e48b9b199947243c92ab52e8124afbfd69d6322b8aded33c9d7db7287f08a4c864216de8a6eaa00c552b93a6031e2dff8df4c70914661549b15050975abcbb3b6bf870e5fe879fb2410399c736f75d33e27a7ce3ea28362b1aa3d030fd43327131f884afa302546f2a827e148297f37e68a3fd8b219591878297888071a0b6803ba845fc5bc6a68111a8915987b9980a2c88788dcb565ecf9fb403eba3695c5e31c697602e1595bdb5b6696b51b4350f95b93402b621f69c3bf36a3a5790f9d2a196fca40acf8fb5da7d3082989eeee7fd8a213575d41d34d90385b25584b02acd2fbf62a789d9ed0d2d058ec4b86772e1709d082d02896b2ea6a738ed4534585f50c8ad6488ca6baea1a071fd280f12a0ce1898cbb272d1f38f0f2805a48ddfe96b8e25ba8ab48b739bfbb1b39a9243819fd1a2df44cc18ca63c07d8061d1db64263b09e2da983922c664018f2dbd931a5328f83bf2221c33dd29949197fc880a6ee7ff9c7197d7c09e7418ed1584d5e33c1992903dbee5a437fe19f336e91ca5afbb9d2c22b02cfde7b6de1e457bacf06e1f2531bb777be552aae78d6958c9425888fab86c9ccff904e304e9781b7471f2354e5f7feecb38d110f423271e737ce0fa9d57e215664b287e87884c5a3cae140a25cef3c49a0a1681d30d31ed3c2e8a17369382bd565e216657c8e0da29f8852ce639bc415511d96a0c22fd03816666c20984ae41dd547abf7f40bf6f5b1dafa53abe86ffec3e498df7061c4937069015e2549d86d4bbc9d40bd9f649fbbe9a1d6c9f17eb8b446af9f20144029d8fbbe3bc39324ee8ae18850bb931a5cd8d3b17897ba26bc3a24149f9fe7274b71a4f74592950e3a7c085b97a4e013aace208703f23b67aae36e7f2dc0c93ebe8286d94d9effef843a43a51cd952d2b3d4bbc5911f65dd5baa9de36638be9c13e6a8f2e34a213420ff03b606a1a1ee24e643a45e8cd8412a2842ebe93ccfd9a32822a0547d141f7d77a2c06e596cc80921cd1a71cbaa6cf783c31565388879e8d7aa271fb7ca0fd1c547ccc628ba394c908f5edf838d77a91be66077cae1a175acfe933c660e0715686208f1980b96bd105dba240e615aa85ac98bd50302457f2ab2ea91388a09c951763d87d86b09c7a3318db9c49f40c110319f1a8d310f00c4313ff28c5d089d09cfbc6230ec97413dad271cb3be04593a2963335a1dfd69a26f4dee1578640c937eaa1917b3f07869ad3d6e5ed5aea396405436fcf6b6b283ebd1e0e42c5e27a66fcb875312121db8ec255f9dfeab22001c93996ddc504188f842e207e678429701e159373d79a4d2c2e8897212320c4631b779c91bde252b64693f88c9d5d44c8546d8851aae1d91b6446f549a30b66f9de659dfa099d60bc9dec12fb78665fbd7ead446cf85bf984c2cba515fa6b7f064972c40c880db223abed0f95edfbbf99bb83e78f26f8db1882e012ccdff89882888dd013d4cd2d3c60d03de660bec20c2da0f80c0776a5ae498e6006c1121c405bc3fe85841eb9fcd74ead9a63d1ff4a5dcc6c20a8c07c7e2b738b6c4c17f1864d3ec06bd86c04a0c880d94a3d35df33aa71a421221bce306bc4ac23b958e7ea3a1ceb495ea8e8b18176740b0f94c7cae00202b2f05a88c60f11e9749436a46229e9b88da160ec3205f57b6cfa46e1ff23e40f933500d115d624eba7b93af9c20c7d96df5f8c2cec0e334f44e288c6fc142b82c575c210367292274ffbc2edbded2fa8d85c42630ca247c8bad668226af834cec7d0143d17ef383c4df4b1092b4a75261fbdeb91888e211bfb95f9092224da661e0ab9afc110b00e5f9c0efd6462312a19f5cd81de8aaf6c59c73e577e929904b78430920556c2b140bc7f6bc2dd7c9fd9f8713753d8a0090eb23bcc113a9570043a0c91bf28d4bf332b028a0d69efac12ea1563bd6bd2faf31a2ea27d3081bfc0cecb91103b841f892d853acf12badc75cca1b42507d30ebaf3a3dc7f2784f430bdd54a0f18dc76ce8e60a2c3ddfaf8887f2e24b8ce33106287a4c672ce1113dd2b9656ce6932c6eef260b8b45adee7621167c45e1ff75967f0c08c41922b303b7cd828e5ca50834e1a9379424656f24ca53fa3c0820aac73c07d1cd2eb3aea81dee1ac6277988a75fed94b88c15c3bd141805089052ef91c4909474d4be60ca9dbfbe793ca4bd746df0fae5dff6a98274c769f7694ff71e67ee3804cd145852a15421a800a154d86dcd9c6bca1235e7ee700893d0fe418217ddd2034b60dfa1425baf28808d5bb7e59ce4f92a27e4422fca03d32de8fb44b3bd915f4eceda7221b4b3500d14c8877b19a9826aec727f258fcf4dcc7ce732c10b1241b546823f596af3b2364f0e54f4496515fe13e869dfb67c36a8ee4a02301d075c85dc90f61feebe06e1c972d0dbfd0a169658766f129658f4f40fe84d0b6271cb92418bb96e86fe6353d88d248cb0735174b81a8e4c15f4e7982896bb92d8b9e5df38ff2badcfd670f95f07b359716c5cb0de2e00b3cfe1f920623bfb54874ea65c21db3559e4a0826586a9ce230f8e7fcc56102fabb6723890f66c2513b0fe0356073d7ebc944f6ce81518a71422d2e5c70108b27c47f08f425f6c5cea3497be68f52e4167ec4576b6cc38ac4169d941f4e5ae796d05eb7b4b7371a4c5aa433e0ebcec880dfa358292415a5232d38e51fb5fe178c4b21796565918139a3ee9fe6d4f65dd6f3c852505b75bdefa356e8573367b10d8a530d0b204b889bfee00cb43debfaadc2af2275ee097249a5acaa2fd111648e9a02839e96dd0caaf7e51f45c87686e5b6a7736f5c8cba8e7d1243111ad044ac89013cc1aea0ab133c90e9509bcccd3111f33a0bba7a229890e742a4ddb32fbdd26af5cd57ebddf2288aaace228c556489a1ac669e11e93cc8e39d94ed13738089d41f182d9d33fd487bc33782c3949505f297eb17f3eac5f04f5b4407a16cded2023eb8ec7a2f6391caf614c360cdd059fc8b94c395a3258d7f25bed9bfac99abd65cbd6e82e8300889266ce68241ac608ba5997428553a90b7944c11d80f8e2b43fc8aa69b28136002a26b5d7159ece12205b879d695851d96221b22080c241832ce20090a09b20d177b584b5b8e11ee56bc2aa72833ed8bc3a8c0c59b05bf1dae51e677b884ef625c2aa09269706282e8170c702d42fd698b17570990cf35e3a628ec74bebb3d87bd7ac2b0158350bf064623ea0bfd17fd69713f0e8b47b87f25cff557e59a6a3d457ee1a8af91857a896c6c3448bf59edaa4d37ed547f015d36a901e63585cddfeb9ba6d01de4e2f684662db164519064f51b925226195319e3bec8d488c938844de8b12afbc4df2f6a1d507dfb0bb310360a8ce658ce11da6916a4df6aae3048fee0e641e629fe4e0dfb1d95f41cc73ae8aacc69cd99ac577d8a2cc1069c2862091582f8ec9276c1ba3345a5009b81990cdd387bae8e7052186a6bb737373e73b70785ea6648429f908477ca3897c656df038c5c65785e5e25e6e8a2dd1a8d958e6410e3872457f52db8e412f8a1a25932f5dfd2ccef1fa41ca615fcfb3fad6a9364f50c87f6db72d9315d8fa0d8f73ecc89fce67e1ed037428286451fe4ba5aa776786204bf3580ab995da912b0849db63922a38a0718eb1db718bfaf0e717b675f895bd4d821ee64fbabf45cdf97ac623f473e5a973415a60e69a14915d235f38f1f8c859008acaa2ab4dca5022fa6514fee53f92d4f13b4da2fe801d39b381f133bb5d8f92d68c1e448e4aabd06347c794c6afbf114c44d62fb441affb8d1b868d9927e220391294d7418d650f00fc66baae2a5ae2b3da0d97069e7f3e0789ab695d0c6c7834c33eb39935daed5b5749123dae0947ea70c3917f67b434d49d6f89c2305115f50e5b0a049adec008f0493555f6f7ccf897de2875ebdeab4c3a8e9ff44d14adc90a55ccb9e1b8e98705db138fee446ab6cc94369baccc940284baa7c397fb2095bcdab5731769e71d2e1d93a8055024ef229de71d714c29f78a3dd0fdc467d4d5c484cb614f794f27d1f9cf2829434e531e5817835bbec317b158c23871994124e40bc9cad86c52dfe4052544d2ee9fb1b64c4f2a668bb20d3cdf5ad9b02ed136132b5a3a785a1ba550460050153c64c1bc7bbb0f5982ea661d700be568d1cf2abfa35c1f1eba7f032535f067d7827e22996b068f03fc92d358651cf3d8e495f4d7b844848f82a6330e736427f7aa8969b3cf1455284e40083a86150c9210f54bf7cb78978a22ed50bb83bfd9ae1f9c0bef26c86e8df9bda1620f4b7f6d7a5799dc994a3cb27a57847b1221caadb2e98a2c2b30fec8a24dce4c2389bd38f0c1dff5392c1c2037a62eb84ead3d9a3b48f1c831debc2e3ccaf574a2791c3225e12a1a0ae1f77bc446dbc64b2eabd15e3681d1ba9b0810e244762df302bf526544141b0ade3d549ee0ae5bfefa12d48386393c3cbc8d28b052bcadd7b3d23cf11edeb457e7bb11c9d931d5cf073fb2537a4f89cdb71ec348f8d22242c5954de5491a097f731889aa1fe0f889a331b81290a1e2a2d8c93060d586a935c0e9a8cb385a0f55023476650f838b33c3f85551d441ff70195532700a6d58a5b20325a8f791e35b88738dc78b716755572932b11ce86cedd77a87512d171c24ac7580ab63e7ca2e748b64a7474e433b89aaa8178a275358d1cc48bb3ae8ac216d6372468e9940a6d00daf946052e4379ad2c30b10ec686cf33f9a311785bb5d90dfb7107cea318ae2c5b58137a376debce5adc13474d0e0553265fd456addcd7c8f83677f46add468733ef2abc9786ab8d5215efc15e871a1246e6693f60de921e14eb4036d14d5c2f6d1844ac2e24312ccda247b78571955abfcebabaabe8166bb4e8a3ff94dfb77e525409a4b052803c521eb5c0b66f00849bf7381b9f11e982cad46c2a38fbaa09d5ce432f0d4b75cf43739bf4b21dcb8781a09837a40e1ced6d38035aab3894cce4cc77acb21d3e97f17581971b0d76a29fd562e542d5fb88e8de621933dad207037199b4049850416b63f6de70190504e46d8464f7e7b7e43646fda451d82fa96cce630aebfe277e3bbe9a0bbb0a384bfb2e10c622d56465099a95721a5c6bbce934ab0f387853ee9d31d2ada4278ddfb7d7533171d96f985f8ef66fe8ee05bb5a915fd8f36f122f6521862528b3a466d2e28fb35b075ff75507df0911cd36c0521c1b8d92a671492badab29590851bd62f2fe068d9875df7bc6a9f9ee350603703327a6cfdc1841cd4ec0d59bf5f6473314b67811dc7e93aab49ec028c2788fa119383162b27c6156ac5b4831784a59d6da76c013448d81c9ee8b1133787b461731e4ef25ba8be9dedba0387be5f117de5fcea9aed8f315cae52069f1caab343a8af205a4a89fa26d945d7cdbc6102b20a7d03494dcf8454e565768a2a5aa31cfa6c4814d8aefe871a66a7f5b10a10264168bce05dd5f805aaed455549251de9d21736077209f646b4cecb21fd963a0f6dfccf5e7e36da4a97ca1cefad19818d36a44dfe533b0344bbbf15730e2153f88bf7b4fca47e1aa7c791c6b215f574a5ac4ed940270b97da3de9fc804e14055fc036623e119e5db14e6e614504408779d5a6f01a3576fd9f30c4fcdee23d900635a7889fdd65bffdc88c5a696a8c16d9c2ccaf4686c4b4d71e99f67035fbdb79140df3747b889f3f1465e62e6807dd5301524752e1b88126f2d4e4b623e0b4c79cf3e83ca93533610b91d85e7824b84d976d17b1036948ee03f0a0677a67727423a97a90b0be4d8be0b735498f605529cae3a5875c680bdb04dc26875cc7456309de6b722813426dded45c24def6cdef7995fd2f6c9c9f119a7393f72e9660a4c37af04e1da1ead9b7cdc437dd7a4f21ab5ebecc51e5ac13aaeca0eb2ec8ba9400ceaf5bccebf3e90201aaaaebc26403d0f9edee8e603c2036dd067c698878a4e3980a4bb1dc03202985ed10e17bc214ba7f11a5b5b23bb9671fce80739d416b330280948c8b7d4ef764678f609d4df20ca418c77f46aa2d01659a276982e9e25d5a906228a4441bfb304366c04a41be1edcbb9c37a1562c427523ec2970bddb75058c81b6c03d5c75fd313a2baf1d4ecd5f6a45a70eaddce33a34eceb4945f128fe565883ce6823431ed5cdb8aae7a2903eb7b0325493fcb011259b38780446aeb414ee7e9f4e50ebe463299262e3d3efb48711e9fd617794905afb3a30e0b15b59f18e612f31228c36aac6106f7d94baa77a52548ee27851048e011320b2338deef52535e51a924a5d08c19dd59039d25eaec7caab1c9c0a062606c62d5805caf4418653b31a4fda83d49f6d6640f57e38c1ad3ed150dcdfbae12fb62263668ba8d4001ec78abc54d1bf97e5e30479f7390462fb1a5f2518038db9d55ef26aa1480245d22945246e5e3aa38619e4616e9db317fb54ee91df6d4b2080eeb4b4287d4006b80b65d81590a98aec080a5301e0c1759661a9dc03738689fb7394182825eace05557065e1d4fb61afba7a45cc0d2bf326feb639280264edfa624b46fa3d3f88042546dfdae5266a1162e97a1669539dcf53280dabd0942759a70e56a65b1127df0d0b3f863da7e9fd9cf520b12ce107ea95441c89502530df5846f88d2d8caf197e7d0ad353fe309b80014738e3ad3f182aab79646dfb85a4f6bf4bf3ad26142649f24439242d520611a2ec133ee1bdcbc7dfa01a0012a2861d62f362e7eec40e51a1bec93f2244f8f8840ce8496a3245d10951f88371c6840e7419a0df2831eabf016248468344ce82e474221b4dd8dc660780cfbfada42d41b3e793d56f6efbf683b70632456597d0ee993ba28aecba3c31b212dc501ff9f6ae6be380fc873b7d6c742e930a8408cd226f717ecde657eaa06f5462c57790bade9745515bb47730c78524f58686b82435fd1b63ac6108ae733482577d5f3dfde6438c266711de1d0bc916fe15596de1f1b63a0c1ca720d365fdf498a3a5ba4006a5853a39ef84f6563697a97c3f43c3a496ba0bd3f7124666123ccb07720ab4943cf70631cc83d976994cd5a3e75769d34df167df00e80bebcfcb7c413e22e378036afefe15cc34343e7e6a90aec1773b6dbc803b0e00afdf95687cd15d84e41d8ffbdfbc0ff3a6d13be833abc10668d1bfe6ffe3b29376a126f429e53d6abc3744fec289d784fc5a7aec84313406d66ab3e7ea4d557b6239d93c8ec714c4cdd9476efe1b2044ad0dd352fe22d44e5d3967e393ec2d303dbcb301cf16c384a1d009e67a2b01a7158780d462d25e0ad06e259c86ab2a54dd5861b892e2e76a9b655516233f9d21ce9e87504037a3c73ca9e39742b4f79de6c868f1622092e9f5647364e284f298946c62b604d50a1116fea8bac4ea280abb2ef1f6d5ab0d5d4f4e8f5d67d947e50d5b8147a96543856a65d3b6d84dbee7e27b35bb1ba4078e7fc980a98af5f5b1ba60407156156cb5a8275c151ed81a05734812fa27d8ef7846c11a08a505cd157a7da5974d9b74c583cf609e37ac3afa63aabdb2f87de7c9ed4a9eaba9c6fe1c56034b06408b8b8a032fc1496605c03a48734536dc25ed2c2525530b5db727cd3a4ec758749f94a391826d8787877b8ef681d2545ba2a124a458df33ed6d1179a7a2b7b6ca8085457c9ca0f2d17124c7a63b754830402430cf9fca8adb7e81ea4077238c196b25cd9de4e9823b66250405bc30114f66e781bd8eb375430bb80471f200c6ac3b42de9bed27bd378f96a787041ad8cac8d331ee87a1c7dc347e74972b8e26edf6cd9470b09437bd97b6df09d97be204c81f2a247fc7a00e3290c57b95eaddd37f524e55f553281f3cfcef6a5cc264fc4027d5252fa59e9bf3e0ad9ec2995172f2db0c243b20f99b75de90c7a01284318d22ff526f744844b0765267ab35c233f7e9a96cd2bc8798d30f778677f8ed4135657464d21bc1009a9cd8a9a698c1bf15aa46bc6ed25dd10611d909f60c7638dfd24fdab3e54ce76a7a4c8deb3e5f9891d115396352604b58eea5404807679c05dd942c4d4a0c91de1dd4219e67c9a3c2ed2fac43779ee88be0c6b6d114888907a3fe2205b7f85d0f6955ed6935b9bfff24cad9e18ebd4e8baab38402ebcfc12a3d91fce96eed28319811144d9c670325e5bf9b9029b1ccc50558f776acf85bc516a634dc8de8bda7a14e16219cb6411fcc326e7536762a5de7dac3fc529b0109f6a86a0cfd9cd2bdf24ee2a2b65fa832af04a7bb7ff42793cf65503bcc3170d4a541bf9281ca647f73583e4b2760c4c11464597a7a0fdb156399d7339b01f079d33a5ca40c5adf638e554df3a80bb89ed6e3cb61d3dc262152223cec7951317286c168e42bb63afee38f09ad5842e893c55f672deb3ea5ef81b028d06788b9dd0e7b295d92445520eb6f77b4872252cd13bcf3b6f14ec08b9276db7f109deb983496b8c4fa3074eb4202614836fd2117f04fe2c9d47fa7d38420f23b68cfd85803921113ccbee899778a611b774090348bdea371805a621b0f0a8e629933225fdbca4225e101520d2b756ef8e1c82806c4be69d448ca80b25df6d85c30428ebbc808059f958b641a0d6858e89ad631ca4fad92e39efc61548d8e5328a0d3aa7ceb5e2a0cfac325ed1870f5fc47392f38cb16826cc1b9002c6d72719750abb210895da755a3782edb258b4e74437a86a8e24daf06a4bd11b7257ec0b256ca4ec295e1135a4a3f5e9b2b76de865cfd2c93dc6cab1969d26d88b787b4f6442674eeb7bb03117cea0cdb195630c20baee8511dfcb938567fb1955a5133b4406661b83b8fa085784a519671ba1f8f878acf72e6ec2e1b9801d60169aec6a7b55715f405b122509110ebfef85ad0edb0b0682ca7f15f0aef9f873748bc5644f99011656bc54e41a93146a4ac5b347b58dba46926f24e883f61483392c9fa5207374106412b3bafa18b9703ef2119003f23d57b20633bbbaf078af16493c469cc666f08d98acf3ed85c275f1fa18a7b9cc69deb54a57dfc142e5312c51a98615c6e2ac4022df8bc7dffe41cf5e8ce0246d356cfd20439f24dd548fd51f4877b14f04b5895523865af748e54face6f4a4cca402d0d5d21da7dbbeb99f3bfa80a7cb2b27aeab0ade10473eefffb57a351d225c380cf424d82ada2e5bde0494b50fa4ee61c2b1d101ed2572830c59392ad3d2009f5b03b5c57f49693a9a9da147be2dc4779f315efdbc2f765c2885098dc63ece3efc4808906c697db9069666113aa9d627ad1e33e7542a7cd7fe2e81776720373752578bb77accf6cb02d888fe97595bba7eedf96233ae4023a665c0dd0c357b207466c5996447c1ab5b5c1462a6df752e6d7062c0b259723fdf7ef091cacc97614c4f4f85932c36efb124563cd6b27e176df1c071f749854958f8eeb802e977ead4809bd6e4382daa4565e0f9c748f8d7f98e5d2fecb2b916d064e2b566082838f5b3b2696dbe40407615ebca0e8437a97aa281d0cd961149d9b6f53bdcde9f0fe302cc6784d0de99e07c0ad94621bcb6a2743edf929d0258f83e1659802a988292ac5fca273af31794b7c2f4f3d6122c3b185b2483c2c13a1cf0a572f48eba0f75059a8fc7285267a285a74db127eded354a5919787e52814f5456358aa16e6f66a99500904e3985b0de368fd267a530e267bb5c56b48c4888825c83944db416c5d40a700ae869ee7729675451c406eedf55655ea872c3d2f5d0dd53d61ee7e21b132c202a0d1b3276e4448b14703f299a09c07c3ee2e73dec74c4172ec9f0bb44fb495bf8230eb6ad2535d8f3876a020671391c3d7380aa5fb842608998f028681d28748884faf2436babef02fbcaa0ff3bf8a41479f7a972007c0be35fcc23bdfc32f35c1d52b2bef8c39f530b05eb92228f995822a9a3c61cf5e898368695131f0a6d47275598716709100376ecd352d17b4950eccd378344c336e8b56f5f79b256ceaa67d4afe24e6df06d3e0a1ee994e70e80c39f9c9f1746106970bcfa51b845b8c5d75d11055b28386c60e3bc4c8105823ee99d4d1c03eb85894e3f34dbdbad51da2fcd1bb5e288fcd84bfa3db90c379a2d91501d6ebe12bd16b1006de2f542057b17078aaef932a970a2d9de6e9b9660d3256f225073c14fad399b576fc4224614e4a256c68ac8f81025ed64f33be430e97bbcd826d83983e12521ab1edfe25196f53aa2c5e24e9c237341d8ffd45f8ed84b073b14944d490cacc35fe811ca4eb7d803224b87a9ee2065075a19b8e0954010a06cb10c9f6e383a25905eee55dd948530d3850291e716f5ad95f8260eee8b1a012d614490dd3f61242d79a367ade7a3328dec40f5bfb1d79ba0a9acf222104813163cdb584e6f7684e3aeea3fe2ac03459729cd80e45df190a6c4d73c45f7e0c0e3a2a912c932834d46a9cc7839829451a8b0c57ff36ff3bcfa907afb823efdbae7569e08b417ed75df377f915c655f19f8b21e6ef135336cb6d6fd9ddb8fae592e887c4587ff6d6f983486893c0bb69278c283d57cb599a6b675989b30da3b1075860afdadf262899cbd8d1890cd658d3f41cfaba75b46f4a627a30423a51e167a44bd6bece05ef68d1bc22b89839103146ed274df4741e67e12838c312eddc60a79b8031784c8daec34b565bf067ad05a65293b26aa875ee5e5f90f8afc6a7e0626dfa8cf2d5746d606186f42954c2a6232793f07170f4b37a0596b223ca464adc467d7f8f337052eb8ada12167a463ab7be61f1896e243f82b3008839ef880bb779875313d6e7be86925d79756cbe9fa9ce66181449942b4d9f4be3de7cc40d0b03f59a48c5d3ed1c274fc000c63e1564be0367b8933e8778f19e27e85971de18e1fc71a5f0648473741e7ef9de1d0abd3937a964647c4b2cd3f1788305105324017a0388828b490b64ee294dac481e2770a38cc3f14196c737109f3dd007ee59c59ad408e9c0b6b42aad7cb9eafb41f272e9583726b27ad40dc6a75ebb847724b3c1183215bb3c37ecb3a0e0431e908c557f86436720dffb8f48d435400088ead18caf6e38bc06c4529088a5aeb9f4fdec960b87df7d725b9d17f844bf54109231b137eab919ab6fed89b5e1a966bf4a450d16b6fba73261040432f506463961b502ef21fd349f71596f68b20597e95cde2dcf3a2542363d5028e333defb7f4fab48a712d33fe79f7a8fad73fd2be0eff061392805cbf4004f79e2c11f77965f752840d371ca66c4b712feed0c8bd935f2f3a9862d67d977c747a3f68e46d3668b2a635f2a74667792c17d2e0c819e94fdc3f1febf297c6f866232a75bb66ebcd673a0a249dfb9bc2e10345c2c034874f1b71256c305d4606172afbfde62cf72784b267b05a060c0bf81125b3b1f6cdffa9e37952687c5fedf7a42e341e37a014993b6cfaf2231a6600e013585b6297e48e675d0a651a52cc9285aab53b67b1176c93b5adfce6606928f79fe965450d14c78a6e524ce62bf846b067b1552c57d2c28e0101e642bfd35bc9d7f087b9879761d6d7753d2da8d9af8ab468b7725171a92d7246e96f0907cb5a50a6ec3d622fb91832e8024c47a8d5282b57c12c8e6b8be62f936c4c9471429811659fa4eefb9e4c15adfcac0442c6ea9ef6e878a1641cd53751429e8d69feba8d754f96bda14b2bd007e45fdd454a2d69ccc142284db668e90a1c3f12f7baaf79d6071d17b163603dfade7c336adaaf71b4a4ac1ba7f14e110bde9a6242168dded007e27697affb7636d5da967beebd2c53130c784f1826fdd8d6e6757dd2d60675e51719da7d4b8f085f0f9f5e72700cdef9555aed7b03238931fe2168e3aad783d3a06aca75defd790d8bccc86bafcac2f15d88dcfe12a3c611703335458875591c717bdcffbc6497b8ba215dc5ab758d1a0e5c9a5e161cf27a2b8053ea39323528303af709ea516e3d76398137e557617f0aa223f09eae321cc62b218ba491ae8d7c38d88fed3d2c6fb53e84bfbd03a35c087068912ea8ad7071b43ea03d006a1164904b20e164dbb6534aa2aed534fa7f4000cd0a5eb5968d9f7d2b3713b1b3cfb9f5495000cf70b4d14439a3af6ddf42202ac4dbceac2259809547001845fde9b2d66751c8fb4cfdf7d4924836b2b6b6da24eec563df71d35b214c140ad259745e4b5366188ae601b076f2d6f8956f38891c1ba04bb1fc863a8f3ea4205737607a9226e4212916309ee6e3cef8df83967b24e521f95028a96c777eaef4530c42b5007067ecaa208288be5f4d4f29f85a30e9c5407b330f03eea9ee161341103de47b632be20323b552ec256a73274f83a31fa76b29ea7031f7a49bb31182c386b9618abd94cbc67cd0b7f0ff8b6fdb0472bedff0c250bf2ab525941e489bccaaf72f9044dbc8b434a0dd56d32d99543bccb2b25584199b52576b4cc0d367213bf9f27ac6cfef74e784cd4c9296a039779b4ec6d441067bb22bdf08c7fd4ecdd62686729b5b2ade47f416dba3ac36061bcd15cd0f96636d7f0e13bf6defcc7c66829a54d876cddcd073bbb0578b2662d140f37180a43d4478cbeb9111387da0fcf91cc9adeb55574d51303725f235ae89d1108266032da8e501d90fa2fc7c39a9aaa3c25722eb34e463b9623f1daf6f82d95cc34946ee6000322b25a4e26e63c5184291496eca1ec4f4abd1a6e0ce2cc0aca092a0181841722e9780344f07d76c9920d0d1635c992adff62750e1c551ad47324d01379f9c73d24110d48946a3e7d7d27c0d031a873f05d27631b86ec7591b0c873d1bbc55558475efabe994df2059403224c51c4cbaaf393d3c97d5e621fefdabe386b8788dc8416c4100573ac3131e29f020f3c20aa2361651ea632f5c4c882fc1bd55ee614f0de1f875a545c8e8964a95c295912399afca316304624f593f72c1dfdf566bb5145076463039a20865e65cb07eddccd810be96be5f2d75c713b6aac5d4e1c4e619a93c7ee7894860018911598e0f002c6d75bae9c1951b027af3dec602f35359a92f48b8ddd0935434fb7848963fe4cf702e989aa4f1e119e33228d05847f3cddf75736fb76a41d19ee254a0afb1bdadccc44aba5f3fcdf087ce03f97febe2f77304180f645c98fa224c62386a0ad64fc5f4768f26d7f6a38d053d3cf14d7337f92e23a147ba2761ef6fb336546076354cd217b1575a2cb2355a4aa06bb93eb7e8232c5f13315ad6f87bb4a1e7f7c2e2dc27891cc8c3501e78819eb36415a0684f9a2946adf8b36831ed7ae4b57b300af11a5020801c4a167b8dea03673abb3f3103cbf788402e42e5e42c3110e6f3ad935cbaf0709beade30fdd554371deb0bff14f170d4ba53e26088c9a4435ddd116d00b1196a07d3787303c0238b2fe7a31d7dee921fab0f2675b9d8f3e8cc7cfa18d9d09614f631c03d9aaa1a1dbd0ac0db57a55c4621d8d8af41b0303b918a0978c2096064ee6894f70095c5ce2c217e5abfbca1042e537e4b944c6ebd1cfee809209fadf0775d38b788c6b82993b278422a07016537e688a7c1bb262d742a0555c07bedcdbc2e2aab4b101bfddb726a1c9c8d0464ff58a83da6686f982370d17709bf504d8d3710fb8b32fea443016761aa9874267e22a975d12ed22274068ca17c1a865c40980a9c1f3f2e446f445633a2d3f57ef1c1afc633cd5e31cf280ed107a4f6c981a5940349e4437a46a479243cb7674089356d23981b92fc365571773d6bfaf49ad43cdaee648b1eeb446e83562fb64e1b8a71c47bf8adc3ee92f6b77d767f0e5bbc6dda437cab0811d479956e0808aeb5e2ec52582ddb9c875904f352c2fcda0861a26345339cbf2660407ea0f68be7b68420ccd930af517bce7a25ef0140daad61785d8a475a2baa2d2e7fccaacadf007f914ea2df5619699495edaf187b22ab68854bae88cb0531f6064da94429cb5da1e726dcc17d0a3c8173be52d9973143dd610c860cd0a785b4360d8f5f5fc5a995da36c9c551ab04f8cd4368de895536bf9c94069c6cd1f5f97aa536518a281d5f4ac45cb2cd3114e90075f78b4e6cf67afa62ef559be4981f27d9a75cbdd1e6aef546dc592dc682626b092659bb1a6c63aa0cb0ebc73d6b499a6d110eb4aca57ac8f8220a582cab8613fa15994c91f505a9e80579fb45a4efbd8d0ddd4c34998242c88cd0523653e6874679ac0be1c04f231359710bd087b5c6eaeea375c8b277d6287d4d5077a8a4672bb21b6a9dc6514380a2529607dc2d1602a740949609f85bdabd8d4d0d24f85821e9cb26f43b1c45dfd7a7f1c181a0db5fcbfdd4696175d19f59bb6936774afe70747d80ab0d0b792106cf1a1f77dad5ab3a77bc8ff0a7e84ad60ab0333d0992491243837358b938c1eeba3c34482f38555eb20bab9b8eaf4ad3fbf4811035473bd92bbe19f02a8dc91c12bcf689fb6df111f268a40b7e2d1cebaa6691bc8f06b6a3078f0b6ad7158686eb6049e33826c57faa47a0d452dcc27e256e511a197152b2bc75e8fe3979dbc9ce7a096c3210eee0b014547f50d6dbe788e810764dda7b82b31403b5a6ad267b837d4e5ba56e51d549faf87ba2a840d2e4e09f1a2a0463c439da86ed2d994ec7faa871bb68a4a2ecad6fbb293773ba45114acdc97b94e7f14ef85b4917d8868f1e95cb52e7b500116d2e4c96991eb1ec93d4d670f890fa63c48f45ea8ab00bd7e6ea456a212aabb1c14877efa2d3998236b5bb3bef7ba4b140237f1246f6cff3ab77777d3056d301f4141de2c9d65bbc7a9a57dacda3387f8ec82afcbb18ef7079e84814069aade0050d21a9def3b4eb98e038381c6f851b8427aed14af160679a55222e25f4c9a73e2c8a7923221f9581ce9a1a171081ad8d388ddb8b1c740f8cbacb5b63358e260fbae3b9d52caecba0352484b69a436326ee6aa40117626d965286574e814ef1dc5118d34eca6735f7498913ecb726994549355cb9a1ba4d95165430f15a5bd382ed0d3075137983b08df1b65b3dc8d4f49a6713b22b69691e95b866916891334168d3ddcf365723246af920569c88b355bb27fa2ab3237410226902af6fea28020bad3edaaacaf543049d8035c5579248fed3898ccdc63447713b02ac65fc3e2e3f8ceca2059272441c4e63c95b5acce2d30527439168413eac579dd9280ea17b7e4c66cb39234b04050025d4f6eb326d66fe7df2c050282c9a37550a108bd6d15f02e7297caabae4fde1b28cf4a7fee0d19f369ae7269a2904081ff25eb23aff776ae49f16b8a7328690a591c9cf1cb97e0bb0228e1637ba55a76680ea3030c0d05c62edaf7f5401fb9b70c7571ad32141b4f01ccae9179a22fa9a6f304351639e41908fd1eff47c83a3fb111611f02ff059a780bb244f7c7e82f0113c7399d4876885f0f82ef24d2a464945f311985208613cda2c37bd654eb9466267360b565751031a48881f069260d1c17fa9a961da062a29590c6a0847a81be25d276d4f50a3aa8ee40710d3a749bd76751fba354cab9b1bfdd366789fdb64797403dc89824c060e9bcad5d394686f4c2951ec00ceaee60ee93ee1cf172a325e3709ae7c4f8dc402281f995b1871e484609f58206c5a0fe6664975beb48c19684df33adb413f8c9e1b61eb528945dc98aa382dee1c6ad4ef06cb8d8a12f00fdc8a93e4d2ecb8e6fb60743261128b2e781c464c2c1e235172e4aa4924d1d182a6a542c853f85d1280823c87f6a91c88bdb8ce43431e618abec57a176eed9030e5d19af54076044f05174e9f608da5a04f802c9d86b1048f10831f69a7c61e655dec54e7bde3ea63bc22785798e9973448fb8a683bfadd4b005f539e67d0d40fe03c59f57a7cc4a1c42aefff92d5aa07e7536c93f45e0a8123ece6a5756eb2778f248cd5fec89717b85382f5ab25931942f29751370b924cc289f0b39d9beb330be36dbc5c14e428af6db82a03700d0a3848998daef46d62f1c1afc8240a4f79695ccdc531d719d95066f57809dcb9e29cb531ec7d43a4d1ae83956288c86bc7fa8abe26850bdb4ba719d3fc9319acececa174f3bb73381d4949b15c52bc434a0d12e65148c6d41b9478ae9fb35ba4eb2ddddbb29c7103969aa8c2c48b8955e551c8ca57cb4d21fb85071503108177729d6fe79a9b362d66a6f4026a0db75af3b47b72364d97fe50d4896c49a3c984a9dc09f9e60afa70c905467df3a695da32a5acf011593acb33b0a7fd2c2ae7501bf9ab67076db2dff69f561fb7b63729432222a9a24c1fccd5dc9e99cff4eb58aa9c132f9a75b3992e2ecb6ea16cef4ca62fb8c959db486a13163f460c829fd701d8f3cf300fa7191b8d3bcf856ace540afbcd6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
