<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b5b9e5010053caa9e5ad15cd10371cca7b97dcde77d5a201b8a644beacd06e7d4053232d2583a371a014a38d287caf14a42c88e7e8a00aedd07084f8536c765b3ff95f1ccc21aa1479dbeb77b7fca5e5ffbb88b9e3236e996e55ba153029015ed08113894ed4479906d77ebbe4e25b816507a9ab298cd092e92d2b12dd3eb9b18e3bee8250895cf4fb6077453884bb53cd814d06f48f9a2814d82721142ba30f2901ceac9ef1314c4cd53e6996c418361df1b39d2d58e06f12e26a28ed2ad714ce6ccfed692a0f48326ce336046efb99669f8a52efdd6f88726fc28c2d76528a9cb2d4e2776a0f440528b536a3e1ee0bd91d3454ede7a605d5b7a485ee5cd9e28b6c823f08b83202a4d1aff2aa87e352a0534b165e9fca658abcd93f6a4ebaef4c53ea5a5dd7f55540dbe8e8566c5768b9e363f1a72aebea73ca0b0f33284837785204df628de22e7f9d1eef52daa2c4a64269030abbffed6d2e6c70c9f0293ec87fa1a7d770136bc4aff22083b631ad7f01879e464de38267b33d258b74a92b755b1b6ac4836409fad8d6f4d4004c7c0c9fc671116a15752e31021c2a0cda1fc41b3802bbef59181056254e8d92fbe65a59a7fd9d85be39dc3f8e18fb7461fe64214e1b84078ed4ff3e9dcf8c6318482d026e7e63b30285518e9e1b5397e9c4ebfb223cbffa81b2afa02ba89d459cf9ebaff74a4fd5c51ed5c2435e12550eaef64cc18678ac307d42ce3505be47ccb2b3c72774e02dc6e4103811c28b4f7509051de5e796871bc0778c73048327c34db162abd2fd797ab4fccfeb1d8c07cd2f744bc539ab68f78b7510b62baf40c67f027dcd654e540400da7d9348236ba45914ff971ad63cb851b66652f9f7f0b91e2e80d2b95f11188027a0f87f7b3955d122437ba4fc77b2c8fd5039c4a1a600646e63b9549be9d551d2f6986bf298a25245eb7f0e110e194392c1aa5cd8c8e8ba9f3b966b0c122da41927d61f1072e0375d88932c6802940090479aead42565089cc3c717a60f5db3a310b5ea25e7c2939e488b2fe9838ec731541e4b7ecf40c2f831f5f8958ad1e66dd7163048d82a2d2b2a4578a34b1eb2e816ef038b7a8be2bd8f0324b25e5db48f98b2cf1e03c9f9968c0fd9ab9fad92a0b0a9c5e763d29c43c94fd365ff8bd961972aa812d02678245b326da7491a8ca9f9883ed9503ff051c64032c209d32a8a4a554eb90202352d3c47f55dbea67e4ddc7a09e86c1ba7b00daae004fa651402df70ec97d203f3bcc61233358160f24e702fbcbffc186e429c4166528aa8b9b79b411e69db2ad8223caf2d8b317e69f029c103e269e423aca8df7fcc63d3b23b81af3c895bd98882482e87625b83a8a9164eb05efaa7031487744bb5070fc158123261638e9efe6a06571b6d40c20026c97a5a382efe7b1e8a367de0d6501c1663eb6b02057b8801e9a009dbf2dae46f4c9c1756047b8a13879ac000447be191a145603f24c078eb2f7255f57e8bec49eecdbee0c6c7f3e1c12fc75482827104a29d300e602c070ea66402b46b04e8e04ce5ee690bfd8f199dbcda95689fb33187a8483acec6cbfc2936750745fb8ee211abfe23ddeceaecea4ea60b3df01c92e32603d018e2febcb0f0fb75127be31285ff83ba0f68b4d853de0cfeddb524ba8d452520fba22c433e0da1bb4ef8d2518a87081f6b267679c15f6878b287b1d1274c474c7fa4686b4efd69122a4b3757a7a97e600b1b167b2fc53868fb28cf409192b8b0d731f802e18e14924c38a4c4cb891d1d9d171ff78718b2d5bbaae3096e833c103fe61d65741594512cfd63328ae9410f4e0e6662838c152f41b20f1a6a0ecfa49a6fbb0921f4be3a9fa4ffed34260b9dfdf4e777c512db529b12520f49dbc84d57f49496bb692a91659045f2f1d5a80ac4e56fe4849d23543b3126cd24845556b2a4fee2304cb6bef7047996f070f05ac814e3a54fe677e43e7cd0094692ad9945d3a28c22f3c0c6214b9fab4c616577de4098897a11fcb4d10333ed28cc6d6740d762f34b08edd91a2dab27537a9f1a181c074d02233ed9b814280ef7f6b63d8f89ca77a648acfb5d5e858af21481bbcf848883de958371b1f08b3448260fa8d2a7448025d3b046cf804298da566f2f26b43d507cf4bd2984a4a93840326cbb93b9336aa5910a6ad84289b0e0821ce8e315a0ea7e5efac85b6d073ce3cf5da1a4aed4251670aeabb4909f66eda51b3e725968f73a0822c3481eca30fa55b8c530710e830d0c2c26f3a4d08231f593a6f31107294896b9941b81bcfed199f1519bcf78b30ac22db6bb28e35fbd8432332047145cd82ee9207e9f7f5a3abdae3781a4b15140a62743e84c6e3ac5961a615e5ce06c554cea4bf4254f2a19f4d90322dcc0e8bdb4feccdfb0fb7f9d09a41cb2c4cad9cd2b9f7f3283dcfc9ef9799638140bfdf7fd7bb0f70e79fc0ab334795a6b3bd102ce8a3977a49e57c32b48b52489cc296c32881c412f8a1f6a028f3da8d1e782fb3b1505a1b2f80f2c93c42f4097671306fa30e524a4826023bee9e620736c85cbe8755f502b27c4fade02535799beec1a178bafedb030ee546eadfda1a8f500fe2edf15fd4b4a0761f00cc49788506de77470629fca01f971b2ea0ff049d36c06dbb4522d86b14fe62694a61f51085ace4ab22f4cf36d0d8dc56c3e972b16675cbe9554cd6b2ba0033ad3cc3318f3c564dcd7d153e50f84d1ec49066e1d7e3dcffd79bd8b93cf94bc1dd7527c59cf2111033748ccefd1df2fb5b34a95a3f7a20d47037d17a0984a7e8f87f16302d87566d71f4ff67e93d4e6845729c56c7b913efc69b1fd5bcc8dcc824a0bfc8b05641e46c89f1aa3d0c845d13053ec020ce5ad533583065a00f3c679156ac9c9cd1edb13f130c7ff84b9c5990a6c0a98fd2458f2676728bea8e6734027fc39507a8793c1f84fda6fb4f521cd8625c0af0c4e459ce681418926e8e9a12d67c308ec4e7101d01297f0e2a788619c721513349feb9e62832133f2a8a2d9f93e1e59436f450e5a4e9f13cb8e23470f18b26db50b4da105345f6561c48506c6a6ba8183bf5490650aef85ab56991348bef25c48ef7dd9b6ac89c4a5a9f9ac0715a8a8e560df19a405309684cb6f74f07030c7b35aff396aed2177e6c4e35aeb8e0d35e0b1a5ffb492e16af7eb67de3a4962b758396a92d7f2cd136c949379110b2a167ea1098c484c113f8ef310628b9a50e161934d5f9936482b2e14e3995376199ac203c9e23108f419090867c5c99c34f699006c91d2e3d9bb033b14a1c7880733ff2c0346548b2d61eda633cd93c26e0c6fbcc5055e778daa05cbfda19244acd85dc47d86781f1f76666c066e4404b450735367d70968a410f5a9a5ec76e9bd1a89465b24012b1fe372dbbff8fbbb1a81f566508b70131f9211daa7671013b4fdc62af1cb2bb3f06ea6ab1e4917743308b173408db18b976474bcde3282a98420a3ec56ef2d8964f65b0eeff830474887b11f49e44b37a33d2eba2fc331725a1a9eda80b0fef18711ae221c011cece954f4ad6630922b15c9eb34c41cce67608d35f30c04bb76a6cdaed009093c2057b7663babf93a25b6a430b3f340930c1f273585aeba81ce3327d8e092cb51520c490450c9eff8907da1d6e524a21a19826827c87dec1ba4ef36a4d3f5c4693f3066ecf93a0a3e955ae7fc0be41860346aa1cd41fbf7983832502d229af6b41b5c67bed76ef8a016f713243abf44f35f361e059f6b3d82a5cef9ac15fb33809206092dc597620ea3143626fbf5e47af6e7692d4bbb422ca62ccf71f871b3d032b6e141ea516f8c21ca5f745b4644bf37e57de48595c179c08e8939ca4ee8683d0eec37c80228693ffbe9f4012c7e40667bc61063d326c03d9c5f755b7032004d932fb9d80be7be82ce5b172cb8d7c37263a7d880954d2700363ae5aa3a870751e87e1afa3d2e15518972d7b9ac592e8679069b7aeb7e5ed28b7ca4cbebec185127c34939a8133f06c9bddb678065e152ae082f820af87af54e4f31774fd70bb136b05e99b50008544a1c7198bda0f80448cf9df40dd240bc534dc91ca61ce7042e0db5f7e4e7cb0fad67bb5450511eb361929af97908b35e5dfdad9f94161a2010b40b4a6a19ce6d52db8a13f7977641b8581c335a0df1a7e85e17503631fd0bdd2c6f6d8465e5956ac784f20d4b8c11ebb28a21a461a25659d686a1d739e10ce33a0e2f3f07127689aebe69896bf2973b85094403e87d14764affcbfba96a3cf3f4c7f7d91ae167689cfb4afe413b72dc0d93200e3dafe6e3d6c1fa1ed4d8c8aa691ba9f8e2d8cfd2051f97aa451120786716093c66a9292e309281909fee18f5482026cbd579de10c1ce39a734269766db706bab2334364cab8ec046cd87130051d055fe42f351e83eb4acc5a8de48eb7f5ef5777d31baa1ea65c8b5bbf7cf7f12c1d362f057a7106e6024a0dcfea0f2e6b7db6286b99c890ce2043601c54442d597028e3c0a46ea0d2c0931c2680dc34653067e94d5fb47aef350f2888fd6d7b06136a6f90a6c24925249ebaed8a538b953b4bd243bd7ade6acb481b298b1469331242cf0936a740c387fa75c93556c34ab598ade8bb2d80e3d9b60724d93c093eb628da966bae2ddec48e510afc795fa96785299ca7165e38a266a4dc3dae79050d38dff5b881bbabe14d83e0e061793dfba8e380f4d5b90b8b997c32587931997c44d219c7bbe0b894e97fa22db16f07db91f565b45685bfe0606259a4b224ca33bff0944ab7b4b3d10836568c30ebb2529142ba5f32a41533a859fee04867c5a58edc861105419fe6c0327d588d44ee5a37e11c9e3cdc592ca6a6100009c472f9689a6a55c226ab3d41b6360f246329b97eac4c7caaed72a815ee7fc442b950bf40ef46ecfaa33d5fe7df18f818b660a2ae43e1c9a2f6f7824603b4409862477a628f04a55dbb9b0213234b7a895792c9d4470534a9647fc822b0da431fd7ec996b4a6b5e1ba3b012c1dc4a5437cc264540feaf3914fb0f7179f8c5432f876e276cc310414cfb1b7a63b03f94eaa35c492d18f84979df3c47fd4cca538de01775afd5d90c5a3343dc4152ee8b5e1d0a458dfe3f8962ce66edeed5ae957fad8346544f804e3b58e584ddd40237d626ad0eb18dd9e66cafd5009f84ed50d97310b067729d013949f2e8738affb9cba6cfb14b02d58c301c41f9c4bb68b200266278942fd05bab5aba86fcd042f89ffebbf5bef1b1dabf8e4fa1be88765535b02f91703e5cf6ce3262bc5b086b2e7193f08a67c740790d9bcedd0b473471865f427bbad369a84b8178474844a4355585593282360d37777d88e07c326b40764d084c95c0e2aff1ea9ed6e07d5c5920e7df61a30a44bd531c7e814e1608f23c93332cebc39a4fe4c490bb02dae695620eb0aebea0265e253fd24603cd5be2d0aaa474922f861d9c930d2ca864034431cdf72091e8f031499d7655324195f97ad6ae7149cafac3d0becdf8cca7f03a79bf26f99f04fe7932172f49c74bfb3740a4dd12b186480e6facbf798ddfabcea8b464dc3b757dad25820f0fa2f7fa751033119976a14946f9fa21b8c5f0331cebb0e9313516f130b5cc7e7829a48070f2adfbc3492bbc4f90455e80b4d333baa013daabec7a8af3d90581d8db69da2c2ad02f15ef20d8d17d9bbe0bcfe489ec8d1a59c6b41e10f3c3edc35d595b3f4d37d1d84a11dfeb28ede816b130523a7e6c3e96017667ad8fb1dfad17f4ac1f18c2f6351b401c3f7f02753af8c53885358332ed984ce72fc8e4eca0c50f92f9f6919e77972857a66e0348114e8791cb397935efc8a3bef9d0c769d7d84d528f70d85d904fabd320b355f2285d1186be8af444812d8d098867ef9ab6e5e713bce02efcf1dfeebffeb33ba7d0198da1da277c9ffa8c69cd15229034fef87cd6fbf9ab9c8a7051309c1df52ff42efed0c6b0f24130f03b60d36b10aeafd5afb36e45146f00932889f3608ba7e02f2f77e566eaa290799495edceff2c1bc2a665754f433ecceb5405adf20b6c3681a04317dfadabf8d9c71c541aa584df92d391e2a8089d0efce181943b186078e46e360b790dae008181d9e366ae28388d7907878f322960c8aa1c358bfd0e9e632333ec0c82a2d1220b3455a91422a077e5b4caba197fd08c090f8a65da0c3c341fd3086850434d9c96fae8b17429d56470beb5c140c628c1a179003b4726bf7761995c9a54750bc9ca91babbc85c16185ec7e5e6c248d991c025ff7c3228fc38e352c25588978edd1014dd4cae89958ea418ca53136210802d8bd0ab3fcff2d72395397f7cb3b8e0e90a21a15b109229c56172c00612d587355f25cb2296323adccd585a26184e95f8e8f707d33d063daed9e1019436b7c8b1e063e5a2794689a0e310e973dcc1fbfb63c56bf6b842a4e02aed4c12a9d2126b9011814307cb3deff23f8daa8e671bde0108c4680872255ef2e95e02430800de390cf6d57b144b6e2c2db9b652ec558b2fee34b92c024ba24b1c2c304c4d5eb5c8b049763d4b997f2d42f87e6a67a3a4a9fac7f45e1722c71e6c72713298f4bbacf9387648f0c7a64ea711c3eb58cb492d6aa42583829a63b2cba3b1b7755371914b947528ad8a5a308789b68424c360770de637ef5502867930d95419c63321f31e0600b747ea8d5534ad0125a34ac07e5d4b57470ed892b73212c428d0dd4c127afb42580640235d23cb2b6308cf6517be705cbcb7073f98f3005474174e0ebd8272ccd18adc8d24188f9d4b4744fab67a178fe3cb81ddd62529637055dfcbe97fe3947d4fd1da5ea0fbc4269562dcb590244b647aec4370d932470e276027c902282198777879148a5da66174bf387342a169c568370d0fe5f17096686182ead5e6095e19a01a6b55ce5c0fb74c9ea1b46e7fe47a5d8606cdf83cdff4b40c219eb4f10b8ab1888ad62510e3f883c6ba0a26026205c50487da8c3b6b33d5f387e44650235ec434cdf37ce2bbda286aeb782362ed8489299628146359c1ee50921e52383aa9291bca45674c8f662b0fcb74c14b66840a5fca1129161bf69422bfe29ed02c085ffef38e4e24c06a2c9a63bb45fad66164573deb142e317cc1059b34718ef6ed7a31dd813fe4e40564ac379c48f6960584b5ae4e42e864f8a3f8338176649195c786b8a2d9b162150981f74bcf78fa2abb845eedba2cd399f6ae76893b8e4fd1a108d4ac4b1a56192ca2262f1c5ec35087db9b9be8a37aa565c7f7278713770135cd1d32f73d4e41ead4cfcf523619fdee3a7c8b98876a6c70f67683ecf0ad933e1a7137a20ef342af9c4cc1264e31957dd6af522682946a4ab6091991048ff61b3ebb4739b73536ba6f6b0af6cdcba6219f3d2b3c577e295cd76b38967393b2dd7401b03492ad7f27b33d526917d664920197d1cba97842992e591b19acf8aaff77af64207b0c0f006e1c594fac6353e7761305be1d18e759689d4c34fcaf5f9f036e2f045bb8f44c2f064c52cdfd0bf08cb9055f8338ae77fa7deefc7e9ff4934bc749add64ee586d207f2a64d5083245dc37d25105a81c0ff5154def2c72363245b39be88b48f84a82ec2af955b2c0e82a55a89e54ef17e1cdff10a287d45ef813515162e64b591a17ffcf425d37c8cf281f62cb64c41a78a75d3b7292714e1de1d16f3776fe930add63f6a5913b66f691adb5c2e11548351e05af2f6599b775433c2f5a093f448d2cc49ba29e04bbbfe9f781760e9a58c099854d4e93e1a4d3231786886865338d83be98f567ecf9d93b4627414dcc1e99527125ac2d56c26ea66020ee5e719e75b7cd36d9c2b3d514d6d07122381e9b6c6acdbbe20c1df30a22b3ac1c925a48a5242bc61cd4b0548ee86e98121672d1fb26ff5eef248ee4291a7cdb1106a9e528cbbf59408478ad00ecaa39de437c1a7db31ddc0c8935bbde2e698981b335571ac4073aa27847466bd1c97bb9d23c43078439b9289ecd8f969902c110b2e9637573685ec6ef17595b028480c777a1b0c1045266bc8925ec0c2959d06d30abd3051911b5fcc80def7a2ad9471cecb917ae0e6b807f40e93725ec57fc9942043d8e3ac60b531b5286abfef698eac86e71693490eb2a20624fdedf3579632d0f6f81bf37b71c59630d0f417114c2a9053fb64bcc73d6049f3faceede11402dd595d75e9e1539da8532e8b3905675cfa805bf19b9a3c16fa88664632786d382b89e138ce311597dccf8859661abab0643022d6d674201dfdf5f9d9d527f57cd35a9d2b3a8022553c0525e18df4dc2f15f13d87204809ded519288fa8599a0d45ae60e07e3aae93b6d27880fabb89cf83d50867c70b34759bfc8b6722107ecdafd43343af3a4a479273f2feb65bbc5cf809c4967b097e37bdad663ebc885348e910fe415a7b4eaba03837f561494ba1d6b8559cca2de259f6c93d895e81b783bb06aee6a1e7f08589fe8f498e2a3b5a28644eeb318386c9b642f93e3c7a0aa059851e5baefe75cc8feee363378181d1c12c8e6cb2fc0b8a44f91a4d519d8c491f625dd059bab7a5f78dffcbd157319351d357ad430c89e5723c5c006702f216ffd27f9ea12360f034d9efc0470f3a5595a151367483d76bad4bd5cd1c9faafbfaa824c2abf93020820d360e05d909f1f322a2901ab544d4db8157b07070cef8d512dbe641569c1b0ad477223145d2c94e9af6e5e92ae5b05203247e8750ad2b222e8e48feb0a5a323fbad065334c85a43b2c8c92489e1edc34adf7ca5f4884e46d277462ec277168c745a555ecd12a58f8cbdb9c35b868f6f56fa9ef69d72a9d37c43956ee639ccc317d203540ac351d2025750a132697b3981b2068df85ebb08dd05ca29b8341a978005e590e0624be22eb922185358947a8ee53a4b9b4d78190f1e541d9d9ddbcc3fdd704081f0803c844bfc291613015abf6e145b9283ca3fa54fdce7d9dbb8e9e557d2a8e8d35a56410795c711f6ac1e4490ede86c7fcb697ab9dadc77f29714ad02e4abf1d19a856ebebb784314bceaf4d2898b91c4931563d8e06df468e662a6094fcb9d52c37ff60513b3388d7537e01e22ea1400199ffb4030117535d0ec626046de55f6b409a562ce2331e90e2c6ccf5dda39a2a5197079a9704761a51bce8558015d9205bfbc4ab3a8888c1d6915350d260480666d07b351aa5611d715f6e378b6c0b9233343fb9495b10a2c5b8dbd23868f9113d627dacc4e61d79f7003b3d04de74e9ceafc2a68772bdc19521e7ef4155e1f1f154182fabcf72379bf636a3dc35e61ab193d32a6922e7d2bb417b04f4c49ccc6a3a69a288d3b5adb605e4ce7e8bc6f8efefcc62c6f8cdd6ffcb887ab0fc2745780e0ca628f3ad444c671e4db386cdcca115a47cf81427f991a5e04890448eb07a790919c3e2bcfb05ad12750f9b4487810348499e66bf6227091da8f6cf264c88d897a9a991299575749e694888eaf518e424c6a4c072e9b3e8f2423dc95b05b16f7a7b36bc02be6fa09826c8fde06dd40d78ee4ca80bea6e8dbc50b7a2f85dbac180be0cf6d5137f2599b002baed5e9e85e7faf1bc9b1d98344be0738d55f0ecfd8b936b746c83b301e510c5e8d78d8f7845d66e0b807b5bce7e06586fc7147f2e27e29f6ce018f2d7a2f47187f3ac51d82e284e313e588c5967d79407e35849efe2cedcea044bb40e3af05a97d0c6107eddab42e8d0b8ade9b2b1dadbdd049d4914673ed9406e9b2f997cbe8a528254106705e1452e3508712d39b4f5d3e1450d164e7d3becc21998e02022995fb09ecd7f97517beedd4f967037445a4901be75a397a22a9bee5d032d9633c23482b12993ae28c499f854273ad0ed67fd2d8adfc15ba66de8e8bb3dda082c7076799d2288c957cf825cb7861dbaf389490c948adff08c2910efcc491281695b9984a14b53894605b2327920f6e57042eb93f3c143e7b725562e19832b8aab1b2d3eb96e4150fe44ae7370c2c9d8a94abccd4d7a6a41788787071ea4ca33f3fa17f03a49b4427bf36d839c30af9d67c32facd94b53075ba8135fc050c8cf29cde92db2a6dc7dfb157a48753bd8722eb029e6bcc7ee1ddce7545bc12849775436e3cd8ddf91f8e36259944beb6717b07b4f4908c308f443bbd02318441f05668744ca4762dc62379174bf1350f3e3890bcec2f59cd9709adbabc884da0d7403f067e309b20be44d72c27c2742f362d3c8dd794e7c84a1e4e80008b45b16cee02442df38d0cdb22d819a9e9e17cc7b3ac3a12fa2d35d1c153c8bc4d4040e0674324f1291c81a5106f5a4a62f2aef6cbcdf546e341ce2b9858e548ee54ec341d5e15010fc798709d3b2f15de09f8c3cd601547a28a74951aa86583079df55f063b1d610118176003cd404f3c140f6c56a450aef9df3ed7fb6917476885be52612afe914e6264085bfd41ccc6bfe974add483f1ec3a3db62752756d31254e1eed9ea6a41aedc7d736d53f2a6a8b1312ee3bfebcc055d0b4bef7fd65ed2af4483d5f278a413a3ee5af39845632211a3ff1f1303658331e7e4337a3379d8a942c722658d2f0973237c0bb28f776792bd14b8a14ae31ba32dde809c9119024de9295dbea606681f222260bf008a68b3e72ffefbc48975f5991a9cf0a6fe47ce9e4272a3485efe9565b0495e9a36047e14025fcdeced2d755cd34962bfc56d84ddb7430fa7f74da350f4532deba1d732683656ef94c7e7b3ac","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
