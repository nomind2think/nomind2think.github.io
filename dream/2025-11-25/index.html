<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"991e025976410a11067e2639f8206853c8ad5b60cb203559646e6e0270c24c5a1db21ba5a0c11eba9d9e36add358cc62c1867b947175ae7fccdc3e8cd8e3c63bb9361a5330e7a85852df15a11f30994abffa1e04127c5e3ecb896aceb0e74b5381ef1959ec02a4e49d1c5839e2b52b4b26be0856af5a65741c0e24d04d4cc164d6bd236c637b72185229d72848301c3289af5228bd7ba81e6510f0e0252183f7159330796740a1ed2481c3007a651267b18f7d1dbe49662146f2e6c435832fd68442d215bfdfbc449cc3c09456d87932dd1215eaf2be7e5f88694078593901e3a483dd68911d1b36ffcf0288121426651fc8555a6ea5a4e002a9973ff7eb5b47aff7c3e4b34effc450057816899894ad9b441c2378ad892684f720a25cb7040cbc96994670079f65202d7deb93a2dd0a1319fc1b786f7178bb2a3d9048c40ee51a7275b849950e7aeb7db561aa600e4533a4a698b609daba4e6ff813900a47bec7c754afa22ec1cb0a3020edda047850791fe4f692f98f87dc3a33fcddc3732a618b60c4430a22d02e2492fa5782e3482b973c049ef456d893b493b37ea6af8640bd8230fe7e4c1e2b88db7368380ded7df538546c01e908bf4781ca14257ba2bd2d9f5e7fd0ab53b20f08c181c6b579d449448a0d882b7914d67e851b81e6177408954040a194686a964d4a21d190c0ec9e3e5fe5d30d5d8d3a503bb5fd9a5e74ef396400c2b28516389d4b40c80d31ebb7d60e290b417906505a66174532edcca9550f40970adfbd20f0667a58667a1b39fc171c2a3f8fadbae66fffc6e535042e84d493900313d3a56fd002a2320f494bcd7b5f165217c8f96729149ec86e75294db1d58dd3f09c7fb3b66d6ba96e79bda5b1c011cc5022ab6beced2390970dfc7f746b17bc65642412f179e0eabebde1058586d50cab9b62d8206dc19261f064bf54788eae2c39db6496a204d93015732d05d0ada597865e19cb401cee169310c038b62ba79515868292d16fa241cbdfbbc29c9bb3161434124c71c7d2ea0c261ec439edc4991c0780d4f02058e9fbf14e17e37168eb2f318f85fd08e691735da025ebebcccfa45be373fd04e82f777cf99afbfb09e08c43542f20a1641694be4dcfdec5619a725f122ee66ae97a8213d274a58f2320a41bd2952219ca895b8a2ba3504207a06e4cfb67e7ae7edb99d579a16da471ef61486f1bf3b691862600001646f922868eef506a528dc5c8aad1813c19b7ab67915c2ebba05ec3e4ad18cabbaaa6b18f4815f8a3ed6a8a38d5c9bf226c9566eb753f6867c8338ccce35160db44ce9188749c3e8991e53d9791c21c219fc3c11a0cc82fbd579c0c1b23ca399a9c51f8698e4948da92b57ba5acdf43040dd693fbc70b4480480fbbef4861e65d6a4ffdf12fd73149176c46ddf9983a6455a5ba4851293503b28cbb8120b8eced0ec216e931eacf06b5dbdf947f9cd67e2dd9147480410132f1849a3058dd3f33c55a80a6758795d788e4c6f046ada1853af2db9dcff30d5b2835453f51ecd30ad4d82f327fb9d7d00c9e898385c77988b5738617d77a5eba10822a24214309c372c7ac0c7bc1358afc3373a7d47121ed5e3879202e12d31b5f9e1cedb7b0d7f20680a7f4efc5d08f238a6f7db69625e706e09cfd7dfde5822a192d93bb711715e2a532a31a572246bee80ae8af7cfbb776dff0a9bd8142410f17262d0ec6a8088ecceb3cb34b210dbd8c531cc4101142b143fd7e8c1bf0db7903e8d102ce28e47140f9d0abd21129e63121bb7994e1c4c6e9787156028f8d9ceb37482be4d835941db76a5046ac7ec039d766b8116112821965c5dab02a4e4806fd02ef21726e2c88db8b8b23adbb0b1064cca75e0a4c98605c1616e0115175c28a60c9dc0f4872ad89626466d06c65142420c3e661873d866750bdcdac8795cd445f9bcff169e1339b7777ec69de6b70c0da8865e5f2392e46149caa1ea635ecad4820a00308c5a3fbcbf65772a08d56b2d1fc8f9f8490f5ae560820f98321e24f4fd2204e6d9566a50d06f90d19e050e37043749b911ad2261c09764a9ccae7085a9151944c7cde1e60cd928ba877f86ce153668ec8becfa6d0ddde4aa4f6b105c3b2924d1b43b634d5a954c32ca2d324b398e11989d0da75a906128653e4cf4f6761468964a31e8562927fd03df1a617afa5886a1715ece4729dbb99f7ee7cf2e6d224a805b9e1b156351c06ed7e14f94166d16d99ab1f06705c427074ba0d7bec578b5a07fa624c855bc5dbe738ab0a2574c8f7f72027d084e01084504ebfd5907dc4f9ba7e91618739409743186df551c5527f4211a6f70a53002fa4f37fa03d5e9013589404df2221b641a0f9981794bba0744cd601798533b17dcf39773c5fb1624507d514bbda680e21d59affe7d8f294272a8393bfbe5e0539a831a501a0c72a03e1703fd938f82c39afd3234ce42017f331bb61d090f964aad42d0174f1a7aeac740b72f24a832465cc16049962af3fb4cc6f8785c41f41ef33d7149cb47874a11d810d2ed08587e32b36a348f49104966f98f7e333e70796e35d1703b0dcba7d3f5d836e401a83e676a4c18b90d32e8f037528d64c05ac0118c11c43b4038192857ea229e8503b3ee71b78749dd8f042d5a2d57f7f9d5fe1d77feee85eeb63c24034a79990006a0b90b36fb01fdf64cb83da148e45b3a07eb671fbb3b53e1a71e3db88825f0e771e133b6f7569ae4bec9e06e32dee9b9231f4d48e5f555ed5b0a4cb07180098639f8cde806ab89817c2e084e6bea10bea374349a573b8ac69db298176118c4c436ccbb042c5a711caa83ae243c068142b2d3ce9e32571b6c5d3dcb4b260b5eda4916e79136249c96f62fdb555eea80e653e32ace573c4715c0d2acab842823d73cad46aed2a2ae0479fced2b1e63bbec3ea96f86f6c020ca7eeca217266d20a7498050c021cee1f37ec2b2fead42cfbe59ed0dc150b0bb24a754148afc1685158041d08d240fd2aaf4ed03baee77c6ff8206709a3395aa014c9f86d3a1ec7952db4bf7aa20cfb5e4b790d14d2918aae2be51af0d09621c9fd7ba738f8cb2d3e317aa9adc4d5354a9a2713d0216e510faa8d800cb66eb7f8921c9e7dc0e0330de2f1f14748c6b734e0df3ea5b1b0e19d564dc37d5aa0cf73981810130a5384a026fb6cbd8b988e66f6b3f816f7be8f43d6ce27d9aff3d988c71857d7549f34f4d501655d8423bc7fe15ea2cf2a61457087c97041998d1e3c3ff7376705ddb0e65294f0949dd3bd33d3932a8c92ef7ad53690d098cbeeac5feaa3844f48c8f29b3e84f7b341fcbbbb8291f52c16ad279e66275a36ba00ad2f094a0110640902c28fc92f7e97c5f866b06aeee87b523518d169bc287cd52ccfa2be9a0c313aaebb9ac4bb385024d078efaf5462dd13985e7caccba84933258b07a0e7cd68b75ba452bdb0e141d80ddeb93dadbb3b61157e9e05c2feb32c194f658d2fce24ef9fc0798d01e789e2ff391a0eae6a8152f5c07cf4f10d1d564e0077c2dd5656aa5d5ac9402d5ea170400d10b8ed63e3732ab092c281d6cc89ef21cf797061fe48903f66556e1b1f9462224afca2348a0543174c004190f37c8f2a8c39f1aba72c976b7b06163c5c1373d93d1b5ee62412cb8c059b324a00a057b40824fd9d7664d4dd78abce1beb2405db8ba571da9669c51847f526dbb9505902e95c8d33cf1109cd0adc208fbd432924d7194e3b9fe88255b7c602d15770446bebd0bd5380b502c5c24e96bd67e8d37a7c7475baaecd0d21a8c64ef9d4143288ff514c0aa03c9e055b0e73e40d833afb870589737f3db92fcdc078c7ae8f2d5bdc5ca5f6f1d2e1c55494bd45c7615848584e73fd496c0642ad163b3716dbfe61df916ad4fbac9b6dcbc6a66426ba4fda06f0999c877fedd379e32bd725437c53eeed9fc8e36f4feaf7a99341a73d6504af383cee0bceb8c1b42d18a193f9c85ce775b9a7bf40c27adaa641dc1fea35405d4b47bb075a7adba73496d77bfd882e71503b75b8877492e3009b191ad610655f4b5f8b890a41438edaf01266ad7bf2c3ab660ae0dc675b58d9cbda4e037b7e567bce2f235e4477307f9bc14ba56ff5cef59203c3787fc9ad95a9e026d74a09529982532bd290c7d1efe7e218d4932a6b7db4ea1ac0a7dbdd7e53867b33a863ce343f37b1ffd4fe85aa41b09f0cf39b076ddacda0cd031e7d002edfc4ca4473818eea271627b23283ea88f5e59c49e29d292ff43caefb4319e249d346185756eb7f501ec51f96aeec4bbb710e5f3ba0171da6d665201252b5b43d3961d48d25f1ab775d752522b47c6bd3928d4f4c7ff97094fc0c2e91ba96ec76b84c3501213fbe2ffbc9f491687113bde3dfda183f7d461cccd371e9b2b6f1f98e15123b96f59772c85fddf73c87f419f55b75ea4904d0722390397f04837444a32e5f833954017d89e1003dc54df021505bdb14446712693cea07de964f760df2f5c080f580b19d8e6650fde68944f481236472f91eab1d4f053a17af138c76eb337b8d81a68261a5553b03cb22938389d90b3e74ccf7dfdc7edd454b592e5b8317bea0c2d36ee21fcf64d298293d5e4267785752d26ff63e0d63a50aa0ad640bc4cb39fdbf1b68fd94e1dc18e95ab527ed8f48882ab11a28714b001fd0b9b9f5d29dcdd19ad85cb18f3e3d18b7989a8249eb8c13cacdd77c2ee312c1b729bbc6539561edf717cad862cf5c590e0354d8e82d6cd6f5e788e6d843e497f9417ab0570d45fec19d0c8b4cc29c91be794be047d4404104db70fe9d0492995f9afde78b27d80f6b5b5d1c8ff9aeb9666657b521e728fe3b3f08d3dddb1953767e43b72b4347aaa10008ec1d3faa4a3f9f03cbc358ae2c156b287de22bcce4856dc2092fc2d86d381cd049b6e92396c422e3d23bd48c89d596abcf6a42cf6dec7e9a04977b6ecaa33bad3d47cbc6d3b5d3fd0fd0bbe74f6f8c31dca0d58547afc029163e11e569d44145d08266736ad889fb8e2e31556f441f253e41f84c8961603ec1c6d6ed60c48a9346764a4aedccff78d136ff114d39e5f4efee4cc22e5dcb7ba753d485b206078433589670b41a1b4b3c24f2665509296fe5d87d8becd714c99c70da6510ddbbcdaffc17c852db4a9e8462deaabd8cfac1600b6c294ae0b12c79e13985a919b0b186eecaaa7fa87960ace8723777ccfa784127c4da9b9ca2dd38ddfcaeea8096066d787543db37dbafd096b47c7e647265fb21e8a52458774a594d1d4f68628713cae309425a58db0364462fd1dc5eeb388e4c9ee100a7dadb5294cbbf0d3c61fcbe581493c7de668d9ec8164f66a24cfb1193c6a08d196f465c42b9d7aac244f590a7383ede716e38881c297c28aa1edb5282982055bc31145cecdabd021f347b9dae12678f50c0d4f6e1718042847a01fcc9d1e01749b19f63b8cd8e2949c849651fae45d6cfdb2921ffe6c31b296d396bb0d7155ccc382b40232082f7402810db66cd4fe323e6ceaf1cfca0abcbccca5cefe45ae86475bb30f791468a54893973b1950fe1f84aa14fd97dae0b58cf765a093a1dcb557c4c2e86bd3b5a343c26ec52bf6c13cb2c7f53a1ec15d40c34f901dad88b29be0ce632c6d4e640d571bf565cbb8231a8745ee8d24c6de31aa842248774822daeeb9ee824f19e50b070f5b8c8df772930f512da0c99e9ac7a4565d738a973f1db8bf0e056d3c79ecdbd1a3b34909016e503fdabf143388b5a2d64d2ee175b654a463de7b6e2f197f1d08325725516770c7c408bfff1852970a7458785d491b72c1933e87fbc8127b9f66f5f2ebb354adb93789883397a68ec0352aa8663afae0235413085e299d193e5c20d6fa71b575c9ae1f4436847830716d5b4659331ef64f6d393b9ae799a71bf8b55b8b7597fd9bd83cdbc3cc068f07d362dedeb653ad48a2019d38a725528bc28cb871406e78508f4ff8390c03836dbf4c22f289cfcfbf686d393a9f2b5314c2886db5256e34c79d16e60bd537ca0ba46c5986d893ee11d5367034eafbeaaff211d696b5aa385e029238424ad51d07c377e7589c9fc51f24c2c94cf1242222f8b5d66e9ce2127c099c198db2844ec83fbb3bbf1087d231445d3251cd86b23bdee19f6a35bcdc38d50ce765e88fa1681d89a516165d43e3279586901e7b6c705e9a89d11931d25927ff8901ae37cbd7b3940b783d6da32d21d286b6112cb2166c44dd34718edc52c98ce58511099f3fb0f47bcdd035a91c7f822b3707426809b15ec11a30cbb3b33eaac7147fdfcd5f1a62d348ae7eb25adb9f3237d17ec8b7ab3d6df20f748b642130608b6b2de49a3d4a9ade7535d1480d1a73a712489df9659b5297d8f2b8e52eadcca8597a00c1b2a3ffcbdbd193687450f0f992da62eb015a3213e8f1c32504c1cb1729a660fe7c4962e9a5d141756b6af2eaf89b4c8e1567fe7dc8319b395aaf85695df4fe0e4c49c35a14e9b4153222b34bea49f67ca6e2d1e4a3e4eb28ea7fde1196d29b55d0fc77018cdd0868a2fca1b633b3c389bb980ab5fd6a54c4b6a16ae0d8c31ae6a885f0fa0e4594a7aab17f485ac760a07e4a7e4055f611d4723924c1e9e27a554a5ed0923a8a44dfc774df16058b8b587d97470278bafd466470de003c7ee0ad7cb332ab6012ee4efe2755d7b55243e1fbc9252219bd108677d4627b8aaec282a903694b0bf99fc25e74a689d789adcbcc7f580237ebec80489e1468b261200e8cd3500381ad58d5df240041164153387b9c8b941a6236b5e082b67e029d05f5c948e08ba42629225d5abb3cadb5bdfaaf14e99351ccf42a83d71a46011b6c2a77f3474c9d1849ce67a46d95f42ef2286ba20e2ad6eef76e882d7c5a6abdde713eaf93b4223fdbb20cc38b017da164f672613fc195da32004358cbf0275d8a217bec0458c45edf0b1b632eda23bbcebb8b6d15792c1d2616cdbb522a41406928c1527e0f61dfbc3ad6d1a3b39a16e755fcbe40e409f6670ca2a33e9fcf5abcfde5d5902b792e12b7c0dcb2dacc27dd704e51476aa9b471bf7870a8eea37638e41fe5a954d833584a5497f875f016fd87bc141fa90325ca03550d91e7f0e34b438514017444efa8c87c531501a9c74041b07e823f7605b9db487316606e2940f789edc3716c97b2a2d50d0c6e5ebb7928b8fc2dfe8910960144ede4089fcc082547dc987f94657c55eaef7d1e974ccf88650f866a91f65251dbdca3edd4eccd574ed693cda6fbced6eee990505cbabfd2760356bc5bd91f139b0070302c0b8473e4aa196a71541db435071c11445729f7138b2164ea1a6a675c9ad27c9d9f73355c26c94114d593eb45a9e4015fd1239b765aa8d67a99aec1dc0d1e8e373f333a9f98d06dc884b6232c13fca74e42c90f615c4d65d48a445646e5b6c88286331127e66e94f7328aa09fb721cfd8be81801c4bbbba1c4363f474354da5fbedbba262096f28f6c8238b616d00184d6913e1588d5b5c3f2ba3b220227ecc0abfefc58c26512e5c29551b29c689a7ced7ba3dbc4b145e456a00b0b33622dd996a6cb5bcf0f4863155911f4d1fe61239f2b179c380e1adb9bd4c852b4f5a48e9b4a995742286b1cb9c8b6aa93944e581e23809f4a28bdabccb54d1b75b872fd3a6848cf8742db12d1130418c069760ad6f50fe9cb9e3b0c8afd9d620e0717720352ecdc431d7fab3c425f458c740b7598f74ec5173c7413d9203b1189019e587d616447a0fdcca33858772af9a919e30910c04057d559c36d63c5e42e7e60a165ff4252f9aaf2d7ccc0d8ab0568a3204715bdb72613e6df8ef9d2a1befc2ceba2414eda5c8d76e7a9c770b1922fae6ef3a22aad1127f6a31a3264918353635060e8359c410a9690ddd4ccf90cf45ff74052517fe980ebea694d8b4fbded031b927d4726c7b19dc248f4f081d78583cabaff2960cee945f6b95e10b0f5d22ef2552dce5273030f193b10cad3f4d3543c2ae7934e7f2f4995f86000a8b2b7f9a8fb7ed321661b82f59b5d597680e72690b7bffaf3bb4b379a6226ed93f6078b8a52b373a37cb19029fc48f3a5d996f5ed108a8162131d1c5ab9380b0e7e1d1b5baf9137df2a58efde92145b1d49038169d1f496e9e74183fd9bb62da11e203f8bb1d1cf8de269d7b8a69f6f9135fa1802c86e6a0e9a4d104b40485c1ebe09267c4486f6c7d76b2b236191c4cf7fb6bb69d70c7702b1db9248e87b8f9d10af45ee4e8942a7417a87d951c33326370992e75b4d4b37997b6cbf8d12f0af4a07528c3ad2561fc86b95b011b01a960b4ad7c71961f0576dcbae32b1449814e9475aaeb9ab94e2c46848043b261d365ed97045a87beb9f351ec587dd954c60d0133255033ad0634a81edf5acfb47456c277d187ec42d720fc9a0f536305991dcd4e3488ead42cc89b7d85f2e04e6f2c2657a6f3084b02dbdae2d1295044510baba7e3ab0e7ac1764a6f932553d3bc2db8d609c661211c67a3371ce0b29b8c6a84df9e9c16946c8b35e32e64624d848b3d5e0df81cc6dff2aaa6b27ed19b90104d3117aa2418ca5b5a7c48e2287a67e5112d763761280a13b3bc0ec0781244873ee0f17986acf2cf9afe637885a86665e54d3437dcd003d2cb426037e72bf6f7ddff18608e99faa8de0430a7a31df8ba312ae980fb4f6b37c2879b48a20ff14b7bd119aa93fc787f8f4e35157477365485e78fdbbfc04e710de39911426b26231dec26293824700a4e16984460c0cd551d7443b392db3767c566b361b6e15f6b841610a25ecf0b5ffb6e1f12a4dd1e39c78624e278166afcf45b7bed2129ec819cec41ba9645ada7efa98622fe8bb26473d130c1610cfa62c08332aeef567fc9fc6f2cb7a1fd1846efa7cd2892d7f28bcf095cf2efa0b528be24e90e7fcc9fed9f1121c52b31139a04894e766b8b02d53370e0ebf188b1c619077acb96c43a588ae8124845fe3e314391b03c6a21ecb6b04905c1394510fbbf2a2c39f95ea736d499d0b0526268525775518d7cb26d807a367064957a87e13c1bdc0503f283456720c91565ea5c78b223490246d6795a99296fa741856ce0a307d4f6c6a20ad632f3b5c06dd5268fb76095b76ea8837ea301e3babab0dbe39f9cb4bd549d0417ba4762b4b4911a49e4adfc0c19cb6e79c6eb98db383cd696377713ac354b9521ea586099d277721249c025a1a6a324779376f830e562e41cabdf5d54ce6579f8060e21858414add55f73daf95761dfbd23085bdd324cc4802fef20707a96c9eff16694f949fb67057313ccb0bcf7d684117c2c20eb80e2118fad548f3be413bbaa618b5cd49b1b2c74f2957e9073fc3304e2f831ea6774c20a735c34fdcf33f3e347dbed6f091da74006827cf504f94561f74b381ca45732f20769b95a18cfd9c71f23ad2f9016ccd7d23f15bcefcbfeda7923339c814cde3b6d3f7464c1e13c0e2a41c08806a85d04f1d1d047be75b9347293ca5cb3de8643b019f96d563313e8348dc1ec4fb703d3f6ea5679900cbf52e2a9b954bdb15f40118051bbf7fe23169d28b8538300356543dff0f6edb44ab8da886f80297f32d10d27799b4d4b690240b5e247c26175d053ddf6d8a736379ecf27c18f5c775c3d91d34f1fa60a9164e05a4acdfcc162f2fba16dd1c1d74ddd29eef1d76ded6620aa10c8d31dd0fcb68010621f6c3b41a7de70e5f65ff0c0fe5b63087db0911405976e6d0cef11d3f60abf04476b7d60f34cfa5cbe8d79248ed1265f8c008f19429a5a1500a7c2a9c3b82c474beefbfb6dae39c33e227a72f6ed6bea1988264fbfe00031abcff3ede2fd9f98024d591a4772ac54cf46def582c38cb8da24a1afde6ce40f0e674f021f0d5a6b986b3925e1742be0be989f04bffd9c1715b551017bf1d657ad3892ced489cc45f1662f31fe81c5c7b61283b06bec8615378920012e0aaae53b28e157bc0571a82502d46ad72e54be1f411d388ffc3e1eba43b4f5c7fceec1972b9718ab53719390d136511ca220cb90f5711c12be7cc6e2faa100a6dac5c3ee7782cd55b2dfc8b31adf2f34bfa9bce67e9973e753898c90e500dc3801936d1034335870d88f29baf5fad95345c61d23ccf96d604a9b40dd506e061241aca9144e61ffe62d52cf8a714e42b9181ac9106550d639a9b65b8c07b89e73ddfca7ed60091b5851dc24d0b09958efd52cecc57851dcec1c27b3dbec66ac5ffe2625c02c8d43d1783efc1f63d2d97a2b404ae425f6f08e2928ef33a9e090b2abc5d1e9c706d8e8a30bdb8ed9ff0b126a17fadf2146f94b29a02566ba11050e998a4ea10847059a0436c51493a28cdc7d4a1f1afe9c775478e3fbb5125246c407bbf44138d0ae4fc63812ae6ca638d8531642c0272dc2ef25c2806c167a3572cdd925bea6a44ed7e4dbf3d0074dfcf942d1c8477d97126cbb637b7d42fec80efbdf637161d4ec35af4cfb90ae8b8dc7d9e20066caeb0931ebbe99c44e2f12d8f0d6ee37d177999b08ea89f260321a02ca444bb526719b9de36878a19bcfc5f47f19122153887d110fa9fbde26f1e2e8a7c83fc0bb714759889026b2759e4edc95742e980b9a674a4b253e6039f05567cd4927bcb4d63ee2ab816148eb04ae33bd903fb426a9787ef9eac1387e3cb50dbd11023f7d9a7445b5797e6fd0096fde9c1faaa38813efb461d9292a1ac458b7ac4978be7acb92e80cd3ba3d72d02014a3ac4e0ff7d261c382fd9bf7dec9fbfaf2af5ce46e908358391e81030b774e93dac40066458a6d9299b797e52dbe24212c334d5fac16c82c273284f40b65ff28f1d9704ed1ac072366b472a0f904c44fd3bf57e0b11a0424631c7f71ae9bddc20cb7f123f40adecd87828361352d50cd8c408e2145d821331631f6da5a84f03aedc23a90fb5954ade9e24470cc4a842bad297ac44ef8a68321438d73ed1e3d29123c24d251212448a4dd46119f9c4c341698a5094c3b3fa1769c560cee0ae0cea685a0e62ba80768e33dd306c76a64763258720e77b6e541295d05abb765956fd191f8dad0412f5540ba5fd027939ab73f53d2109e6fe1f26a0def241a48d8cdaa11c5d4c895ca26ff16b85b40ab2f54bebeb03a73a5c5d17bd7c330229f66a6d7eda0e03428d69e6fe9c2d1b9ea5af3592db884feb19d26df8d0b68a119e2f6500c01baf8b3422b08d0112afaa70f1858a29313b1ab0246d77d94de2233af8c07d6c4a2a387e1dcd45d4f3a24d751640bf1c18c57bfdb4ebdb386ea7a1dd70784fa949668cdbdf305840053f98d11b4d9a1a88b8fd0c5a317a94650a8bcb0f9947f11991849e1e658b0615a5da8830ac565b4747333b011aee5f2d836f3e0b4d2ca2017712a7f0ff3d948d340a583abbdedb77d896871e409a625dd1ff3652327e15f5659e0ee5296a49527e6a8439182a51441554f2b17b6ef410fa3107444e4b9931590d00986be2008a4cc169f0898defb23977e12f13694bee536635103ed47b8f518b4758ea8e3e895885aaa146db7fb990841223180c824af7c50c745dae708278fe043f298471e229ee66af87afc12395fdab7828fa58dca72d051277702349463c3b1f2ecde1392641c6575889268f38ce8bd6deac49f9aa3a23d7b38aecd0949396e4f18a5df4c82e15a8d2b585adadb864ec0d42c830d8ed53011c30a4bc8bb9b752f44e636d83316641cf758ccba5c0b98e51c1ee8dcb1a93fb1c04fea1963b0fbec05ce17f79a970b99855b1afca1c6c9e9083cc3d0af9b78c52c2eba336b0a4adf832e979e8c54b7a0457218d9be081fda27acb6394b7743e7d51b720fe9497ee09eeba70be79d00f9e0e64169e051daa25852f71f5f3c2afa97c034099aefda70dd15e8f4ff594d3e199c203fa20ac0567e9ecb14880ac2e537f76ab218829f30f55bd6da2a47938ae40f8f873c9ceb689260f836d87c565fa6e1dbc8a25837c22f260b3b273030bbd3c7a0a82a813aafbef157d0a352ac44855a18891871a424399aa00f67ea8d12de61c35d36cd5d27175e7dbc9a2db54e202012ec55f31d34fe9516de5f2b7a8b1f591635c0f16f0496d63c346c07084592e99e6e001d25e848492cc74a734058396c383866b53c7e28d1442d5995fe0db2318b53e54070dff5b66868bc67771b71a71b8ce90a406770a1b4c01d10fe254b95c07e605fefca5225860a9f4dc52269483cdfc80a264884c570594c64c8104c0abb73167e238e2234492161cc10263a8d5e05971616efcba49caafd0ad4c819dae357197518dfe401037e71ba2ef64ba1178eced06c3668fe75045f36c9fb2010100130e5d22613e043a87ac62a2d06f1880a1e1a6e510847e07754de0b83f5b2f5ca8e0af5e11dffe7a2fc20943e2036052cb3ace53abc1d1102cedce5f6c74decd17f155ca2106fb76f11b7bc91b6c333ec890161f517ce77476c5d663305e63c00c8b9bcba008b4fbfbd838e52e98413bdbc2bafba3f74f4ef61c2031f504ea43366e48f4789d6d94a006b202b9b701bc5cae0e16c0d4600dce99747a115c1658cd4af3c9e15cb69506cdf62466f647056f9c20ac134e342b1790ee5a1c38d1aca3e662b4ac38abe6f7053f40da8b51225be72e762f9132f1e18c3de0c1ead8a496b604e822c89765bdca6752f791ccf94fe4ad9bcf8263c736f51423209e510cbc7ca0ca121114345d91648c4425816a931b70bc13483490cb9ef260f773c97a6fc275e69ad6d7df9e1fcb7f1dac4e0d036e9c6590f631a93e251110cfa50025471c0fee28f41c28234a6dcda4dbd3163a96c1336e8f4dfeeb4450aae9813be97ebc1ab1e31e3a853cb3352012191370f6b7e97b718db15733d8ecb2429e898570317b88d9d8488a308f9e5a862dd95d17b16a6cb311c521f7c92df166bc100dd57773f3f3421256a470e33a4e0e353ca20284b351da480f6916e39b8e2574da470ab1545388682c36fdb8d79b147c30c916aba5c99f3caff9ebc0a7b6ace2f66d722a373a77ec23af89de6d2b46ed8e8175beb13034323a4b8c8c8dcac6011ba8742b8cd794e1483a6113ae5c4e12512098aa72f3b48f846962ac5eca2a7ec6d24af8d1228ed34d46e99c5bc34fe082ea4ae736f72b46206e31aa8d72ef0771f2778af66f275dedd1647db9bf79b874e457b852f799b425abca434b4db5ee50c5c8364ccc7ecc24ffd2a72567dd91a831a07e07fc9a14171f75294bcb97f442f71bb4c59f027f1faac411486322a801fa1fae02b5eab9463123f5259cddc4af22f429607d2897eef7740b96e7d6e2a12e3783a994de77af8941be08642e0ff21b4761b7b98470cc4ea305b0ac42a57c1cf96ce2c5331fbb804f728f1b6425e042bf1af6e9480c74c95656514a6e2490d1d23b0e7342ac6a566790d209d3dfe78d160475c27c3a1e0eee1fef435df1afaeb45fa5711f9515c469c066499502b9dae7f2dc9774bd7424377bc94451f8094c5689130768131162b8e0a16785cddb7614d0e5c92f54d6c710d68f7954387cd6810b521df091a21ced9a44f2847fb81caf2d9cfca06becdd5b7fdaf08f6590f608b4e1283c91d77b3f343101403fd9e666eb860d6b30d3ad46020c00f9e42258d166c010541149973c43237be889e930845ca8f98cc7fea5482a7e3b1013e476f678074c2a67df37f3c56474d031d946521a99b51df175cb3fecafd932a01f15d6ce959c4f79ed8f00f6ea7e4bba660862ed818ec0b67ed4016ff3ca5a31533fc41d472b7cd9ae7116d1f657c2ca84c585a6ef5a7d9ec1c7effdc18597a6d78045ee01de7e098b2af2a6ba5dffdeef2361326863233b2577ddad62662338126273e206cbc30db9935278163b8727f2ce65dae4247b5f0a7f81a2cb219ba1f5c551baf1c5306653efb3409c1593116dd0a2ac35fb608fa18f6512c89ba8c7bb651042746db508e3647b82b37135fa86da2c3073352014ea6843432f23666fc06128a2e02cd6c4224eff059b9ead8b44d93610095ac3ccf5779b8943ba734b8ccc27e6171ab2eac4f33b6b56c9a5961db76b20dfb9d015207507ffbb17fdba804613c85007c8a673963950ac9932b5fc3db11c20c4c287262ce9814f9905c5b81c6d11acfc76265fbd33035654ecd0bb444577ec77ece52a00bdde539a93d383d4109eea44f841cbf21faf7b099c46f03a77482d277b9b5b5c1ff50714f2160d24ca11938e97cf442294d03a393f14ad4c54b1c7fcba1414d43e625ca0c3f576bc537c39d83d9c1522f64d3f43b3541952180985370fa90cd5ad843cafa76614f7a3c83f6804ec53185a200493f11518da7b73d90ae9e36991e8305c8b7d29feda4a5e0b13eb954f44c7da5468627feb5bfe8cf63b64aad2e14f10b7ab114c0282182dd61325abe8ee47cc34b169531db3412e53449d994474614c86eef8eec15e4908cbeea0042bde705b14b9c791d1855feb8f5c93337d31d20d2c5e5b3a6bdecdd32d8c23fbe779110627ece4d30624009745a09129b5fa30de62ba23cee8e50c78fef9e4e60b5740c036b94a7a85aac3bccfddc7afe13f4cb50899ff71bdf34683f9fa9567f97979096fc128d0c0b10fec8dd6861e7fff53655206f6a0575549e728fa51283a3e09c67b58a614964169509567b046427429f89b02cd0529bedf0106532b35c9e5f08335baac68d77ae4d0f224deb6c2683b63bbf4a00097e17ff075c80a6d7d7bb65b21faca48c2e6b4b117fcdbe210df10bdfed160c029f6689bb20ceed5060e219d0acc0bd7ab1f420798c132703e072df535de6da39ac1f9a2e42b6bd003df3b3bdcdaa06c0f85b82103cd35af74de6bbac5c1f7bff8aff9a85bd65ddea3b4588bc3a8e0101b0c135bb272138f84b14c7d28b45f1caef79cc0ea8572b8d79e00610b71da5f3933e283a1146d6e070ad175d30a62eca9680c6658ebd6c71682710e762875b80938141cee65056515785689447fb6f4315cca899de8731438fd0952cb89d203bb51f8341ec3648ec238076c4859e828d94c75244787b637bf7bdd23ce206e9d037d877f50eb15110f63e18af7ee25fb6d3c90e4f97c538fd5d29fce5d5ee92877671b6fe74f04fd724fd6e0db3100d571ba14c0e9728aecfe4166dc5ed8817c372eaef0395f51c866066bc6a3cdf307793c7c62860420d64d8960a237fea98e9c1a40470ead5683c7403df62be41b9465a20db05f1a3d39a28d280f10ca1331ada4c2c1b5101d09b9fd83797154ddde1fe9bc38d12c91109cf0701fd79b3893a2877ad5bc911e16ade302ba0c3df7bfb117a505233babdba121d6399e338ac4a6e5c4dedaf8c14e7762112893641bf967b858d6e23f68c0bd9617ad87e6206af328fd733da30522a97e434b7151d8d353e2494d6e5054f627a416c420570db531ba8b19637f840797f790f408fc6cd06558b0b4bf902d946e613d0f3ba3f3a2daad5d6ec6fc2ded4c148eb9b06cfc28915c9a916bf1ebc49983551e6745284989bbe6694e933d2eb3ee840cb4f6ddd6bd683cfdc4372755a40468132f0b78a012c90367ab06fafa4a55421241302bede7bca2f0df2f9d0e10479d1ba63b718fd721cacc9221c547b0742c45a0c46b1c3326bc5ea301c9caad215c4472a7379fc0890b7588c7e14ee846f556e04e3af21b0e0062dc5f89521ae674af6fbab0e7f04a60f8da7ae3c536917b79a37ddcb19c025742e29c6e707e85db9f7fce09fdef87fa09f38a4a1b6d5dbfa0e491e133182d2cb1a74bb52318aa739c0af990495a418d34065fa99fe297427a60c5a7f6f7f7e0bd05dba5b377c4b22c8749f5a4820cfa860d5bfd514bd34cf7a6343f34453f6bacdc75dd1f5719104d420f52c3f736a0b243dd26d8e1d7d71d21ee16d4450e3c39984f7b3b2b46ecc0a67db93fccfde7a59f1785051c8283edd3fb1b1cda96cc875a89c41fed49f8dd4804e82713dfae549d2157f6c2943c752569e95d9c51886c9abaa71031e54d2af65d69c83d89dabb29c21c38392e8b3d5774d59d6169e91be81839dbbdbb4212182438d586ab7517f6fbb209950eadb37c98821b896bd73b05c5d17e8fec88957e35a42c181fe20671b94008f9a25282082c88fa6d1a55571d0d2696520514bf4354185d72dc1c34b3c3bf1ac80dc1de6ca3ac4d425407a3cbb93397412a8fbcee5c5ab769c720f64de3c1bcf9e80dbb55b25714e5f4f4f42a2bdc870e5f962a6c566a48290d4bcb9828db055d5e10d39cbe9b4047e9739c77a965edae0d98ec67a8eb9a1f1b1385a2f63cf069936fa90569594c24d55f05ee07979011d967d5fd0496d21c37beff73a1d51bfa01e9edba1bbd61b6427fb30b8581b28dd4d1ee3dd8c5d179dba375dc7f8c1b3c825c8fec4b9a93568519de0642672805df4a91b2c31d2f2f2f6e6883b2875959058569391f88ce36c63619a4f1378df213b327dd9ee0f6228e51a29d15da74f7c63219a1018950bdb40f43702682d4c014cbc57974a131fac1b1740f833111ea8fe5fc70b336a8dfdd4bcb3be42f3184070ea66707ffacb403b7b404e24ce8be403d60996e591fc22445de629c2d37c048287e11f04bca554fb272fe8dce7d6a15ffaa52373ae3cf9a8ec14038a501becf610c78edac600a57d22245e33a7ad9873fc09641a58d3a41cce054d723eebf3af8a49a888ae91766beb16ba11be8da919085f2d742b7e3ab5371e1b6de0a7186533d5209b47640e81908c1765e0400fd1a41d291f3a2c483679d67d2a8421ef12eaf784952894df87374f3be4a5f0eaef177c87145f18719b1c29ca2efa9f22bd252c3367d289a1af8ea36b90d09798824a9b2b20c09e39be10390a6ec74375302df6cc6c897ab7e5bc74066621cb2d2d86b2acf21771a0a515874c2e7c716f6f9128c84feba9297f7491e3a311b231322fc96745071d91821934fe65243aacf7419ff1e94fd945c42705e6101a1378e93d5450f65d0a112bdaf95c3451cf472e910a67db2468bb6d4197876cd8d5d9984bef62e6c19a89904681eb781e7e410bd62e4428f92422d3908634d735942d0e12792d43e1619c9ae4362e23e7e03df30e1139555b162a0cc09827439cf768105f52cebcf6e9961c7f4d7a64e5d229ce73f9836498d43adbcb8c91c16e84f158619d88a6140754fb99b427736358371cd6f933428a66909e60c40e7ef39f362914cc8783a4f53840af771ab86b76f2f1a7ceb40322f320394ed2bb71ff705e3d2e996338331cb439ee5db1cb85d09731941ff53f57f8c298e9de1954aa11d4215ab3b618f34d654472ad1ff550ad0efa203334d0e30f3e8487e6046c96aad8eea4c7fd716c884e5df6c98a725d71d19b807e713a18e1711aaf6e4989526eea34015f4d2f5c61fa8e33e7af072f6b171f6400174883ecf427b2f60031ef28495cc67d5128880ed70a2b544cfcebb41cdf682f377ba50638c3174acaec6b8cf6f4861495783d014eebaffd7eb0ab7b122ac1f8140fdebdd8a4b4be84cc506e298cc976f7752684910acca0a31aead9d185e9581ddd4d4e0304ea4897ab62e31373c27ced4292071638d6df6016fd39daa40d0f24ebd554b11465378b001cac4bf8a49d53a8988d03fc7e8a488aa7a3fea2a556d27e72ae4830333bc768650246149ffdfbd9ad6b85d2a0adff40e665ce376bf6479b745f5e843659fb68136b7ccc1a41b0bdfc434e8f9f03ba0070b5c76a226665251e331783916bbd30ca896d04f15bb8d7066f0ee1afae3a2f3ace343a5500593fb7925edfa6f3a76c0c27e406ca083adfc970b78b129789315bac8b7a29aee8cc1c82411dcfeb41d65c0b6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
