<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96d7eb3b4f01cf319074dfca461bae9244cc2eab188bee90d7ea00d362b9dfbe95fa22b989e94f03bb848f34f4535bf3d421202676700bff22d6554cde5606943d65dbe2ab71bb44c945a856745ac37afd4b1e86bdd5b71d0be137fe5f753cd97e579750a5ed59777fd7efd67d82fe8af070be483e0208f150d016aaaf072375ec0ff13af3e540cea665b935abf867f2c14431cbd15131b477e277108d87d131de201944ccb31765b9d646858b6ec7c8401c3290ec9cf96d91549cf46138d06e028469badea4bfe00f026dda730f7845a36546f5f47620e930a3c7bc7109e0fdcc70839da19de45aaa96b5db8a3faf16dac6f0d5be610497a9953385438eca677430be36017c227bc7f7feaffabfb6df0e1da81d01b9cbf00e145d7c6b64e58d2621570082c0b13f0664a89a9ded450002c547ae36d21228fb0a03e848d4a54fdcae689dbb1baf63cef4788b5885e6b8375e5f0c4966a6400cb0d65dcf3ce67894ac04ef4621015b375c60d240d90ef88b14ad366e26e1d9a6f0ed2e73af2d931216d32deb94d6e93c2928a4a6e664e9a448600ca2e8e416953dd0404232c4b6e9d2c18cbd36e5b22e7c2f16ff6254f5e657d2fc1ff518f2c859d3291f6092f6a59e435b6168d5ec9c60cabb2d0530b4e5a4bfe42018b47ea8680ae2d68348d148823c71f4938686ed32628f4b260aaa2b252ea27d131e4e46d48d33733287407dd486674a1ac64f27c996d99eb711dfbcdc534f4b858aaddf1609ed0370869364d9ff38aefc31fb1c12da241c1a33a9ae2dd9b53840b4b7052f9bb2b13a8e3aa3868be07dbbdfe03d4ea5e2164473c3db55ace2239b90f43968597309fdc8971d464b23f5d098c385f8739e8dc311b6729a3ac69eff424a53b30dbb0e64068b1f12869d1c27d7956c03ee5a6fbf7e7624fed521dc29c4a9633a7ae8cfa5b6be9c794a3c1f738e482f56dcc1f26b937a74d7ec15ae407d6948fe7963669677a259494c7a78af010d42f6ff66a3f25c3852487b4bfa9ecdb0b15909bffb91027cbb9746532f324460ad3308205a99b22754462aedd758392f70c0504cd4617c0efd52646c8ed841957621b7fe2d7518c6badabdc23517caabdd7ed752371b6160a036ef650e403d0fa85dfe2cd1c44c0ee24e77aac41a295ee5aa3e5a1478f33b782223c540b117e4b4504661998ce861c2e1d09ed4857eaa8f20d774614fca49ba768ac937177a2b134079f4864f2d402b9692e0d5dadddb3142e219dfeb17d657523960809c5f6a6a38a231f08782d77ce1dd13035949ea80df835515670456980013f035d3f8ba7ac89117cf06d24536fd8a25a5297042dd52db86700914b03a82c5b92cbf51c4cc9b46641ef0916f5af7d5290faeade990421e942d5812db9fecefb7236cda9de888b361174bb315e4be445137bc7631564185f7c917b32c23b10a7a9fa29550169e28d5960ad1b033282471f8219f00897309b9bfd925cbd575d59d6f8ebca3bc7edb704601947117ea5166ccfba51d85a5d5db33eb9f592a1e7139108291e67452f33dcb331e094e2648293d7ba642d74a8280d787b60c70c5f213e21e44e7bc7efd52863e2f808db5cc277cb3c0feddc58375019af00c8802d2973e1a0bc7e8518e3845e565274603f6639c9623da8dc73734654c06e3c2fafdaa0ab30deb537ce9884dce4ee3c0e23e225076d334f4124cbd672b70bc5a46330803dd060ea32a5ffa42a04ca22ef481bd20862ec6174985d71aa155cd2906e5c3a24db96dc533e5d51cac96c8ebcd1f632a03c051a41d479e6e412f5fb13d10a1715dc6ac110ec89bba92d34fb9af2df9ca2832035ed50ccf30d895c7baa23a1eef4456ac64b7f1951521304052ebd022acdb879fa3334c901de893b5efc378a901c0b12ead9220ec853edf18ce9b5ce3743432aa78ec09cbdd884affddfa613d9353effd0555232ad1d40d12d951535910ea848019d48245e647487c124e2821263464d8a65c9a2d04a0c7bfe62fdcb0c0c0837dd37627194a0b2854ef4e0424273acd25bb37df71a5099a12769fb462a383f1cb85a2478adfb4ba6117ddff61011826d7ec1bb9474d56de1354e84ed47826eebdff9ec292aed742bbeb7b476d97cca0736bf9c2325e273cf6b9f189fe8420e4d6ee94cacb8bf84154a71376b7cfa3de0dd2da1b9a4a14c1433400fa183a9d7a7cded90bda0b9c16223363cd97ae1036c5a57418aa11391b6019e5c6e77971a340e5f53111e0253b1782b6bfc1d549845a8bb9f7bc34be4c3ddf2821251597440335c60da71671e64f9942622bdbcd4cfb5c397a2d035182bf1bd8c8a7ad41a7c55a0c4b86e5daf706608bb25e951ff5501155a97cd2d7377bdc158c1be059991a0bd6cd643f68bd1b1198373e679edc4405320ee507916be7666178bc46f4a81c20d07925edde64755f3b7dbb9e673af2263d0ba34a90a2fb03be453ba26284b5703a58d834b473a6376e9757b89791b29dec683d518a453a08d3baf4110b48f22cefeb750176e9a4cc9bf1ecabe5a2edd30d81bd0fd3905aeb82cc778591de579eddf561e80594f8f6d6d602793bc09d449ab4b61b4429d3b3deebc5cccc76261fff28e00d53d254727e7e2328a0a83a520f4cb47bd53a01beb4d701d4181630e7d0e12a71be23406669f5dd7593190feff92ddd6ffad209f63973d920da63a336c360570b74435653d67c041ab673fc812c04e309209d5cc6314d6583fce9735f1e7f5b81fdc9f16b4db0b6eeee4eb7ea76b66b3a7d23ae030722b9cb5971e004364f8898efa49d62ed48c9a120449858015bcff563da94918deb828cb15c8bf26807e76f1a6ed266e3a4210f229da40a4039d11eee1962195d15ea2a7f12b42d363a633e4298352f504f557367e5c9a508124bc8ce98d959973bfb44cc05b9b5846b1bd722ae4f0e76bba54b42beb33786e40c018f1480422299846c25d4923f444a48d1d9e3473b3b0fac3550785cacec3d9f0a0dc09912a2164d7f1d73f81cd8ce1aadcadc9fa1f53d084a2d800b94eb913cdfe98903248af6e4f091cb746c61b3b3f1b99f5660f04038591facb6ffa8f139f503a210c595d9b99fa4730664c3fab2e151d3b44a789491931392880efcadc4c6e03357bfa01eb22e85bf880efeb39bc931d38759df8f4e0b5e068fb1241062ed65bd5114f756c782170f250d0e3afcbd94e62ca735cd6deb736cc2c79e65bcfaf4338b2bbff3a79e6c1f1fcfc38964b2018788c4ce9abf47a30fbc88cf4dfb207c5cf0306c4906dd6cb861f2e55edfbb95a2e4c607040ea7ca9c7a9eec34686aa67b3363d1a0c7080a7358bb707c4439b81355843c3e25ac996cc844f56e871898229849d150ca8290d1f6a82fb941eee27fb03fc82a2216240278309124d8e7f54dbb7e06d298199349e6e138b5c06f77823e73ca01656ed944fa408274f9aac3e6e84a10ce4e3be17fe4ebd5f61c15c84b3f00c3667af41367963f8929b6357ba939e05c085e4a4edb0e2121f97b20ba54d80402e73a6d0aac6b0c580af9a19b887205620a279e7de66e076fbaa5bddbc0564c98738e95fb944093abbd2861c4de005a7d2c7e508543ff5205e29abdd4e6f6bca6cc54a3986362656c2c2c205832884a0ab1ad23c6ab499fcae4bfc86c95d2ff79f344c903be4db13903d8b2b0f3104535d48be3c3c43032fc5d1a741f05c0a9731a3dcf4fe745f1756b30ac304242bdd371038f01f8daacd79c49f6961fa4d9554466bde716dd465d3e36e787bdd0ac65800624dff942c43f990e53d2f0002c3e08240d2caabb96aefbd0f983d397a93511954740aa2296e690045b7ce41eb9989c6f350ac7fc6e720e87b96456ad5e6020930b1c6be576ef358458260d55f4027f3701567c730d402c8fb4c9da7570d2bd39c1af1499a1474188b0733bc05292dee8c2522ec7aa81b1c7bbd4bafeddc30e43c5e853d802e9ae5df628d215fb97cedda1808e49af8099851d026d3f8e7cf7deba29c53e7aef1058615ba5f82979c32f60ec069b09aa4e2fa62a8b0e834a4858363f874781e098c73fd554517095c54c061e017e3442c757b6af186be6c8efe920515b9d6b715f6db8908590ce6a90ef554a821aacd19d013d8a8bd9f233a90f505d5bfd45f9c0317e0db8030bd9408563762680eaf2796f5b2280046fff3f44d9310fe3e210b766ef8a72fa20b3efc87f28e67a7ba607c59149b1d254690e33ba0f992e401e646f861e5d3dba7a38273e85108550ef6d2c318f4621b135cce190cd4656056555c6e4318112e1584a958b593b0e03fcb57870d99d270a5b60838ee752cd44b221e08c4fa30622d2550b40f20178bf0a43731ff713f823d0ba238a85d063ab86b871beec5b9e031256291d99dda75d264ab82e69534812473e9587026419ec74a10d0bc16d59d43b52f59a208a372b5ce3cde86a0da75f1ad71c6f66d0357a67d9db677ed416cda448ce86d936dcfe6d7f21e70e5372c7d4a345b99604555f5f8b19f70df57856839bc85d541289767e6b04f32902b1ed19fff1a2d0a31dcc9101e8dc97b9f12f73e556bb686b0c7c1ba433705b246faf8e8992f8e23ab7d0a238da4c91349d45e1e3b95266be5c4e82d4b80376996ea5a6e485855c7c74483893ec9b1c7a9dfe4643c80dd2d803026c301921e8584dfc87b1086b9e4ab9186a7d528ff2db35383b9046720019750ed77379190f110352bdd1e37ddc2511c4d753943a20da10f60b3226f6d9442a504ef8d20b5e90bdb3a09c07c76a24fd918164febe18ec5b1de89b69aab2d23f8f3bde5aa4540f1492ba9822622be3c5f30d0d49ad368ebb2671e148df55d1f85ccf74cb095a59686a7ec5e09ba3da98d84407fb689d2955209a5b888497b46161f9213f12c86e8d46ab59171f9a651486430c5d680e4bdef01a2eb3553d9e0a1a4a93619334a8b245739e0717d02e65447b6682f04d556225d7efb2acaca555516a41bdee1bfa36ed217b78d3b8384dbdc3cf69e6849d6db4c25a190021d7afe9c410098866d3df6f6b2865bf43dcfda1807fc62c0b9f66208d92373779ce8768d3f2bd4012ea804108eb52439e3ee4f70645d6b346ccf6551ac795a5688874b02e051fcbada2e2c85e015961acaee99756b965bbe8f4d810ad95414a2c13b516188cd94973ff361746f69facf7a7fb12363834e1c8284e723f7379349297dad8c9dce3cb658271520770a22a72a4262f39e7692279be1f4c78ab47da87a6a59706edffae9275fc09ec328978aa421cf47dac57ed9157a9f0538a03e16212dba87bbafc5b1274c703732be97590717f98ba7973b5cab9f95ba8e23a6455500fa296c444c329468e57ca17948b4b1754aea803bad809688308be2e769ccb1bd38693077bc21cbc6b0bfb90165652f33b4878cd51429b2fa32571c3e100dc0ac4fc81f4cfcca1a1568e32a8feea05bab41c004cae89b118393179811e8ca2514378868ab4987f6111fa73936f78769796d46aafc52f460c32eebac9c79bd80d6c35c56af0da9a2beef30f6735504fecf12609e1855eff687fe0f203bc14b2d0df7c28ea98c81c707a44872c5da8aeef81b994efed478ee827c4ac95d488862e0cc6f391d716af1b35a0e870d6508b2416aeefcdc6a36a9367432c0177f8213ccde1fbfe4629cfca4ac3a26a9c2d0c1d553d35c0a186a642c60c24534f06c218443c7d0afea62c5284107abf4a885a32961aae01efbd8b554beb9b17c51fc9cf48ad74f5f98fafad609963fd74483f462b6187edb12d5e2a0486d09d93db3d2bf11775d0f0a07be5c3a2a3dfad364cbd699c52febb5e27b066309df6fc37b49f878f85c003dbd1eda3d14ecffdc09d0373827e780035799b9fb0b09ce45501d45a95472a4d6c962b04be2a3994e0bc0f5bd18a2528b1fa99c8d3f537d767bdc304b3462c507d67c9f8988cbac08bcd2f5f1d022d40e90e5762de5104e48bc9ee18c79666185d259001d3401351e568a118c6b3f95e5c86893ff449dcad1844cf17207917b5925e99254ff024e84de50efdd4b71a6ffb77dc60a9be11fdf2937a1e27410a423097770d188bc133e30438d0c7768e906ffcb4d5a14bfb1de2a0aa05f8edaa390ef0e1c1a63da7c866374eaff42e1754c6cb3c80ba12e64cf8a7fd43e0f363e79e20de4d801a32df9ae03cb0af9621312747c4688cc641683733bf04fb3c44a4368d56f33420a9fa54828d506fa4a2bb70870b453b8cc56b298779afd8f7b547e076b68b7372858e61dcfb421a965acfa24d9ae9706c7ffef51ea5dabb055d9301fe9afc7d33644e89d51a01a6c30efe5a0f4080b522a9f74f9bf193203ec119c32069ceec24b29bfe3c614e7caf95d01f4f27ac54c7a43961427dd002fcfc27e923b61811600100291d58afb9870fda897d2c212a236829fdff44a5487afd7e22723b3aaf051f670897cc6e5bba188e3c43d4d52a90450c085a8207aecf87a2ea7cd138b969838275d67147b605b0accf0c7f74033fc365f8bdfcae09867622f9ebc378bb5b75df873bdc33bbd9aaa9061acdabf303adfa31773c455afbec13d8be96da2e3be0ecc5f21fc78aa7293c9efd9b7384b4c2602ba76b1988b31c82cf5ec5ab1b641e5dd5dbd2cc0c311c75ef83b82314558844b0112d76d4f46ed63ec74ed4295dac9389222780a03a0525a43c981ff0f415a174f9d18634f8a79c7e20548c22f62290025a4a3da40ca46e51ac1e2f533606ce44ab02e3d7ed2b1873d5613d06a3c7d1d72ff89e59d79a432017d36e84b20773c15b0742b27437eb48a0e33197f0811938a84f4048faa36687ebae36f46f19054b2bc73176cd7ba4ba1f90ba9ead11f789ae855063f60ad440bba35ba37288ab864cd9995e5f5cbe47746861a8c666d1767e17190a32104f7995c3bbe2baf06238ad641d95fbd8eb5d6bb1d10c20fe5b0d92ab2f8ca1ead1f8e8f24982b92a82a8a6ed9f07e3f7b1d823b7a021cb24d0b37e3342d3c5c0a2d9c992ea7daa281f294cc2b8fd925035f936d94d229d0548ebd5dd7d63553e4516230f4aab51dae8d28bb6250ab033d797c3bb46bc7ee2438fcf0c030fc9e2b3f241293d6ef7a12550ed4163591457072cdfe2af53eb316ffd2d927290240e4c79d7210ef7a3e55a040ac5ce058d21f1f5aa7241881255203a605c659e6fba91c56503d51a7ebd65cf6458340cb9582f2402690a435cb41255fa0aa332aedbbc6dd7480ca8549a3bc2a632162f39514f8563e1e214f8666892701bf82c4483027c91e971d0e11a4184b2f1c86dd81c19f4ead2b6399707cf2a9e4336752050e01b3642ad1f3d0485f5694f4e321a983ff09d005dc734c9e2d7ad81fac4297e1bdbf890bb70c15d7e4a9d576db042b05fcce50ff33f1893502edca8ac2e29b3e6e62c514628cd68a9ed2faf7683aadef2a9728ced4b3d7001397d8ea5e65f53d1d80b9ae0bf21d6f75ce1aa015fe11ffca438f32bdb67af7817e88dafd317c51ae4b7915d718aa2b9f30af317d7f169f55dd2f9b5881379be7dc52160c846da1f800ee3f89d8018f6d8445c4a9fc94d53b93111122d8fad0f857989975ea80b305973a6830927af8203cfdbd31a625892e1214d503023cfa5adb211ce73fe94306c6e111dee20cdcc341800713a6cbdac3091cc3db6f23299e963328da246cb1dbfc2beaac6860270bb8d490db58fd7140e7bd70613e3a60a3e320ddcacf2ab89100b65c80e9bfb9a9d48b2bfac87387137d162f4bb213fbcd117af433e28fa6644fe547ad269d7bf5b1b4affae4ea8028a2fa42da7c03d14ddbddd71bed0dd46e60350d95b1d46b1d88d0608febe9746c0139b5f4851d7d80e7b659a143dbf63ba2bc214c68b025ae8032a6037040f6988212b921c5bbe86c1ed3c179e2098dcb9e061217afb95be33ff3c39ea2a03a53d1bedfe16f01622367c8fa028ec73d43d5bbb14c8658bd0d204bae7a6295c78ba66f6069501ba454cd1f0df44e8a58f68be5edf5acb22dccb28a98b518e5ef816b6822259680e0819e0657901076c4d0f0d9d23d7ee4886c5d44177e4889de735b8dfcc979eceac113bf5aa5d8a4f1bef0975f925b8d3a1664b9566eb1f0dd612e645980919c326f40ca271d61688d2e35a37cc0ed906438680b16b0e90b9ca77ce69549b3697fe9e957f7feeb8eb0dfe71b2726fe5d40f175a45489cdb1a7a8f5c7a0a5bd3166a7c11a0375fbf12ecd48dbc99ba642b718c813193d94032fec5afe136447d0ee7feacfede7978de52ab4170e94cf4f93c17244893112249c61fea946a480127dab0a31318b29827b3a4f8c9e832d3a9ff0fb3791e4e7c78834c073ed255e1ad4ac5c162772ac6ea5903cb7b5266b20fd3910f6b5ccee809628814aae4ea5c5c090fb77a0f27233bc5aa9e5ab7989db48ed0d4bf0c8a0f8e0b19d5fe59043b82c8d6369251f3b1ab1d43d02d4b6060b7f6ba345548a24f47f4e12752ed92ecb80b495420fb10734a2df2c8ddb1a2288514bc124bb04e8d7ce542cfd951eab124d980983d22bc35779f50173042d4b9fe27a41fb019c3aa15db035d6ac1f091d9389551111387f865358adf258db5bfe6e7a30e9bbc3276bfa94a8c3ea94d3a5723c3e40724561d4bfeb12090e06bdd8f50f771e5c4126a72e04b1dd69576eef146ef14b58ef3e8ef6ba0c9a0b3ed5a35c66da77ee935a0d73f89c44fbbc2727609dfec8bb733a24291012ff9559ee6fd940f4d2cb0bcdb66a973ebfa8c34f65b3fdb0d1e37cc08ff49209ac700b7ad68414762734c3d2944cb589e33a4398f4883204ab2d965546077f27a31e1599e88cdb68f53777b2545c5c84d6e71cc7361754b5db2091712a8cc92ba20a752bee4d941b44c2121aa33a78e4fbffd7b2d5b6e99edd677a14cbdd5929be5a8df53c9ead803bb99d26bfce5bea48cb13ca7616904d4903f85c1f2a152f90cd84864a36460c07de2a9a4db448b166e93108cec0f800df41081e0b1b5d76404115ea566c0550b3502aaf44839592cfa97d6fee796d737565a983d04b6213a655d90d1720afada467ba65d005370168e858516d75b9ac0a286bd3ce7f777677e38f4d4da594ecbeee40d0ada2f52e4c24671e5d68d29a1cd8c0e37dfb52ca7230a6b968bf556161e4260b30b92330978b8c078c586c2830c46019ef409fe1b96abb84d4cbd736c28262ecceeef533e4c9f2f3e7f837d617d8d98489ef1ef5e77e5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
