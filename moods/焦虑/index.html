<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52743be03296e1e7bbc9009dddfea464e68064c60d942333daf4750c4f40371e3208801dd4c9b897017e85906dc8c1f8b28a581d853370251e3085dcfd9ea5a24ce7f6c5815845f9c218d989c87dd8d4f84ddf8d525cfa33c2385e591842bb03e1af1ae0892992e11ecc9b485cc933292726f52458068720d302334fe414993e33b010d13d4ffecd071b48c2883382933afe868a155c61e162c28369af8c5a0283a570ea49cce97f69d25255bd0478001ce039472c0e4b3e813cc7797c38977cd5f346685278153f1aa0e899401a0ae01626b4f43029c28e869370665f39f5bf23979e61b669f66a92f360353213105578f5826ccd6c7579f2c785b182441c558eb5d487e371c4be35c4d659d6ef6842bd150fb23eec2473d1a27fccccddcab39c546ad3e4aa82cc085895c224882c339982b12c7baf100d88a05c76d042d9881d131ec61f074404c8e24711b92289250cc46cfef61391f0222ac1bddf006138a8c049815042532ce8e45df4a55459903a8f53835f15a117cc86c7dce22e211bbf3617e45a27f83ef4192fd0fe27eae9339be2c879cb31a8ce4c0c163d78f3c5c7ca9faeb82fc7b49b92c60d392b1e5234bf1dfbe3b1715f7c6bc37b65884942134380a39ac629ca2da5be2083d6f78f8db0bce21579886cd2b0c5fe5d3d44385b2aa8506045d6ff6f68339a95ecca6a8782e16331c3d91b8e8d1872f047aa37c2bd7c2aa1c23524a4392fa055c6a4c10e3d35ca681490745d1d870ff181c362b3f2c31775e19a93a583fb2f5025f9834b687656143a1cf609ff0f7ed7b472752aab3f74de44a8bdf547c42fd82afae16ed34e4828aa5edced890b7dd08b7157578da822b7577c4edb34bd4acc9dda4b3c61e64fff6de3de955ef46b3dcc83c98e9ed759653779276f6332e27ae81229a18b10560c80b5448a02a02b1fda7889124eeda2c9b6d42e34961babef6e3a1f7677ae2e3eba76a32e1c6285b68d6d15a2f76d2bf6314163dd1fbd71a74fffb90be8a69dbe750926284c3a03790db7ff04c5659d51df398eaeec0684bd1564365a3a1fa0e40ae3daac2590caafe0d2790ee120b1cbe6dc5063a419fd8fee36815eab39bc03e1bdf7c72af18f6cd6debf3c5569ab758d29b17af006ac47266e3c072824e74f44ca84d6da0b667de6001050561b81bac3061511a5ab0d5abea397136deca0ce9afaae911469a8f1c9667b1085410e49fc880084357134f06ce15f15528fa28a85910f6f6df8415d9da9772e814b5b01d10335352cd0fea43054ffa8b16404bd85f0dcae5d10ce12be7f7823f7bd76d31dba12a9f379d2e9f679ccf9893621f4642fed2e77793b5759084370f6fb77932f545827dc45294a836c5ebd6cc5550251bc9992bd9119d0d84d8d173270892ac41b6f6d762f96af8991ada9f69aad62a429651591c5a6da4b2169535ca9f4a1a886dfe4b56285a15489e29f836da933be4dd4a5706d3112ca6deb7c12b93c2be7b68d529c9872624df0db1668a1c7637848bfb8a3b84b560695876eda4e1ef60b0dba1fa0b229ccdfc52a8f1b03f430ee827cce39c2a5d8c5498a9b0cae8efc7992af09c6ba04ba1ffc1c75274fe3832d1438bee1c3d7992e1d8a771b32e1e6b7abdaada70aab4e69621fcb40728dfae5feb1fe7a520100f0724f45c26269d86fe15727d4d24fb9618c22f78178bf7c3cb7a73dd719ee813a46c2688a175248fc777818c1205259d9be356e350dbf50e1320075329b5a290e66c97fdacc2335b43427559a6697df3bc8d7851b3399d3140a6623f297e1c60d15c81a39d74f4ca6f3e9f117eae5d8cfcfef6308c73ed3fcc9f83061be7c6b286a2c36225616b7c1aecd301194ccc9e059754867f7adf1058fc17fbaaf4cba90c6d777c2cf40a2949ee60a59b0b62bf34dca1b8413ec9518f238fd7031778c9d2a38a96d4a3b07d4798edd47e2e2534e3aed3e56f49183fb2d8a5c2770b5c26d86d867f00d0422ac3dddefc6a1c21721f932d486923ab24f45e4971717a58e519765c629e1492c41357f253196070eae4a7de18405a9c6ef0ee3ea15c28ec934b9a6ac901a97d2a8c7fcaf9671e43ff8d1df3bc9a0285cdfd6c5a6058ab813d7302e554137089b6a634f2b85a5341497bb6038b12c5a9844ab5991d7673f9c95ee9942a2dd60f3bf12d223eb225317cfaed444bbcb98fbfcca73909ea7a616d0d4b70e6e82403fd9c18e1b4ce94f3c86706b143963f019b90db089344df1edb12c008920cdaefcf10a9262817389d3872e65ec25592da43bac904efe834ebeb8fc2515b6971f55bfd86375ebefdb2a3910d83181122a65b9a9131a7af6fa095f45eaf128d51170b87f25373a01986359a113cebd811c4dea76863010355644ed82640f1f95cdb11b14b93ee43d6659e53e336bc210d3c015692aca20b4cdc30bc5fdb1c8fd768934d9094cdef0fd6c25eecdbeed946e4d9933681638be1bc5a045e8c40a2d39c612e7344b42a0cf8676df8a2ba49c0bd08b43cb16cbf0272592deb70d405218202eed9d38557edc506910bb7ebcb75fc2b1c4f10db9333f3c12f33c738b897ac1d5db9a68eb7857e11bcc722036c14c0104191f97e3d9d28734239de0c7ed200fdb2af4d1569f15c1f4b092ff13c57fea44fe42642e19faa6a525e53704e0b2a8996e8b8e9bab1cdafdcf7be10fffd96b8f908c12d26e87160c40a0abb4b11098dcb8517b6f75bf649746d38405f32bfb3156c04c9857396f6d9231e7d127dc45db6a448b446bfdcae4394349c72a8b1fe762f9fc0f6888bef8efaf96337efb44b66b3371d0d4c63db6240cc70c414297a02f030c0106355627e32045f168a66c32e326fa7158b92a7a54e43d16e86aa86a6073f2c830912fdc5b85cdc088093e999f77f8188dbea95013983fc967ea63a29ee94ff5988caa9bc3ac427518e09013b057fb3b449f069429292dc7c2a746f48b993cba66c04961c9be777846b7bf544ec7c64dc5d673618f3a3331b2bf1199100f7b3af46c5012f58bddb9957a3b6e54657fa28d0b10c332dcf212f14ec205dd754fa96f77bbee89c5dd6f9a9b5916d3384713f6f54a404aa365acb32f35d9eaa7a2ca65af95143f55e30d67fad88ee81739ca0ba90db47d511153762ce7c924818ec24b9248638cd54e89b15d6707fb698d2765f01c2c97e2291017fea5cc9d43287f930e44841a358d689dd4f0e0ed82fbffd4b751652420038d80b7769c5fd41184e996153c953c9d5534b5e05915c37afa89effbebed6b91b04dc49cc69b9d6f0e92c8977ab42ef8fc38ed53601167c3dd4ff08c4f096dea85f43b4af3a5e5852b31b415896356737ef16e58da07227556d04e5da6f9c1c74658bcf8b2911988d14fffd3105c29c136ec0713295157ca7f8bf731ff0771779c17d330059d49564093056d80306dc2b47f0fc5f18922d6e8eb9f6e78dba2918241195d73e200da6e6092f8580dcfaa4c64018df3b5b3ca1e6aab4e91e356e33003f25d48da6cdc064c9aa20cb7b2451aba0f463b1e37a7266ee043018845d32c2b44fea46e3334d5991b11b7d539eb796b690bef92312c65c7c52685127940d2b603e4720f264411290331e2e4e5cbc254a818eb5420b8ad2ce42b15bec150fd3ce183b9943ad4c1da3894f6a656a8df0e4ff012fdb9820373fb17307458caaf2d234d434e77d58c67e5b0593ad314a184d693acde32bdaf907bdb8b6dfd1675615d8fd8b655bb2ec8ad12493809d8fa69c8d31dead1da415697aceb881c6879bde41a490159d7631064721e1dc1e459ad77bca9e6d914840ce6ac85b9f6f03848b40d726da8afcd64df9789e41b32f79fc715c237f14902f3ca9e2599eefe459a35661baaebefa8cd56006554b17c207646bce2f2dbfbf57bf9e1b8ec8d9ce7bf4c8d93f5a2bb0dc414c36e8f1a4a597efc6542e15b2a0fc5d70863b8f49c78666c7d0b13a8d285e82870a5018139b60b303347072dd1bf45871cb133f298b30dd4c9a0cab70c70a80538a3f22d33a6ec6536c4b4394f2f7e3880d8c37b7e03b2901cdc3ed0b040878e05abefee0f6b6bc62c560862c66c49452e3d4b28aa945f7ad7ca9a8fbb4b9f3271f959a94f404651ef40f882f3b5fa7794c99c332f4aabc6c027d68622566a11e9d1691bd8c9fac96abb62574dbcbe5708656f4712d8b2f454df8e69a15d4a501a9dbede14d8ac6f3db084c70d3ab4f7f5bd86825ef4a90d8d8a1379a914a854f98764004c4f8a0bfbaf8c9d440b66ce9be9b753a3b9cb2a6165bf0cebd3b3093fce7790db5119955777bc3154ebb51124fdc2c346c58c375a87da7de10373934190df0804bdcce0c489872a4253ba49f0d02ca4b469b6eeb8df261121a6e97680583a1b9c7ffe79414233193638b6c9ab61930617e345578c7626c576dcd65b06c2f62332d23a42a59816744438b23c9592a58bb131c3c6d32880bb506c8168654796388a60e672a768d1afcb54949103e48eb2a91cf69861b420602e531db445934abf0cf8d67f3140e32cec4e1d65ff2fc07ece07c7ab44ffa4b124a150b7c96750e891aa11efab91c7b99acc2d37e8b55836491e8e1054513f52a2ae80cb32fa37338226fbad0762fc34bd7fcfc4f1aa62c4639dd53180041afbbd21b2e0bc16f8e630a7580004fc39b5bfabc3349563407d509b43633dd91144fe7d665bd2a3128d462dd51f34a265404b37d6c831df0ee9b831ce5970daef9e80aba3d2823dcc7b630766df563fe88a999db1dd5afb164593bb9f51d8157e08d013433c510ee3943bc9b08c4fcf9f61f3ba9a377353420fec4f63049da2f4488add284fefd78480df62ea8a0da7c6d4da037fc5691b3c908f3e6baff78294e2c8ef299f68d390f2751897cf259089733eb47d35761681bf601f3b3e3500b7d1ccb8c123e7f70b02266a80e8ba789a46edc32b5233221e62fd12d8032407c46d61463a5642500f1b606a5a5ad14ff0429c7a85abd7a08c238caaabfe9865cd37882116e62a83f894e8a7e460ca138346a80aed35d60a6378901cfd26f3b8d5ed26799ec77509cddbfe129d261c7f2d8184b50f507d95cca4028da93af63970d0fa5333b1bb62fda29d48c6dbdbe10ba7d42c12e4ba820def5f54ac7a7c996777a70a3f99beead7f88e83bae34c7eae71c679144e5216f78269ffe67515bc07fd725033703ec4a2c9c6690609f4ff4dcbb83d4014297362b0070b84803044462c0c02ac29191e13b570348db7021f8e03e083b9fa6ae3fe33524a8bf45144f0a9525e3744da5bcf7a98515c56407e50e998663eecc4293af64afc40f9ba6a10bbb78ab520b27ea76df7447f9db3f2a7c051020f89039477d1efb9e94f41030474dc972e66d43de2c4a674caa039fd3306777d52c9bcd96ce3aa1a6b501c9205cd933a435dada0a5618910cd9e2884ddce287b71929d2fdd0dca6dfc3459486145c6f22694ff9c1cc54d50db0b9cdc3ecc0e3d6f56e1d2e13a1d6472921fbd6e87694af09606f2937a543c34a7d4422ec7065209e1c5c2ff5ece1500fc53819e89f3ef4304307766396aec8975134403afe62e43b659927f8890d9520291ac90f59f1135fcbdf13ce56e542f820d3e0945004b4637fc847e63fcbc0b7731cf5173d2925cff50dde151dcc58c5ad90148cfbbbc7fa771b9af8a22d98d08c27170a39d1f79b37dfd0a018cb51e76ad44b6547b616a054d13f8e758c7b1a3f2c43b02bb698a44d2aef262ae0c5a02a7db4bf751395aa587551a8fca3434005b8b440a138b12f974c5602e83be9575ad025b86bc46028f720afd50dbafd6fce74fbf148e76944a00be79f8b3d31ccddf3aaaeae5d7d55471d238581aea777e686562ccc8729fb630a100ed9fd6fb09865357d9c12435437a6f9757d2a6d13622a7cd9874fdc1aedd80a6cd36fc2313dab60c7ae0e04ce81fb50210013d349bdd63b9a146bb9e30401eb25c1c04f583dab9cc7ed5bdc98b7cc94b764ecc657f3ca0f63e4d187cc4b26bc089e6ce014fc1f4e7d4a4ba68cdb912fecb58ec5fbe18ffeefcddac07269d678f07fa0c29df7e091d1e86dfc419d2f9a1c652f8f166744ad8f8cf2e2db6149a62cb8ef6e705a3cdb95ea340ff2b224f3a991c703f5c89496323ec02203eba53725b15729a9a6e3459e35d1ef05fb91cc58cccab1cc4c7990e5ae2a97351ecb58025fda9879c59decf07a20df95f4d3ef373badfd2fc602bf58287a5486450c4288993d04f07caebbcf92e7c0c082fa70b73e8efbf1f887e9216c1fe2b78cb938c32ec368bd35fbe2fe44fd98d4d61719fe10017162ed7f256d09946cb4a15263334de9dc4fbc193c87b4ceb7384c367eb7290ee53d7c0605c2d1c1087d30a703d14a80232a894781408d21aee4004bc9894576c1604f051971be5517917ba40d7287eca9b7f9c3738b127fa5141080d0498f6d37fa392c3297fe5c0d0c5a22e079c4d4f0f54f9be14a65ddad1bdf535b08036f709f425967ca027c0c6aa2c96331a974b643362fa4fc7b137277aef2eadd81864144d80d3851dd2c315a054561c89de1404a381fcfedf7bd999c303af83484c70364f9302e44b1d6bd0e1914597a6b9b3298a2ca4d8ffa0170dc4c47efb58a3276cfb94db20dd6893fc08c6136bded07002feb378bde3965aff4ce9ef9937531602b27d7a8595c60fc5d8411fa29841b303d1e6f4de115cfeb3ce67bfa3a31fc12a3ac00a6eed6543ecdb7ed3f7ad5e5e4509196e8770a9176f19312ffda06d6648c05f58a9f91b1634a7ea5c0889d607021aec6fee52d9b9b3b58925f0d347f120cb67b610a16c673a53242c8d6fc1090c8d13445f439510044ab159a8502a45294111897cfafb4f80cc2d474140ff40518b41935487b2b9577a97d833c91f31d4766dbf9f3019d3d93cdc217002d741f2aac3f576d96fe2a98421364a56b04e577c4cc69dbdc568b9855ff21e061095ae5c6e9bd284b3781b417576a6521240138a71a9da1a7b8237777d847660a454cd6c395585fe3dd01196c619a9699469dfef7a50936c3ff68d0a5e006196890ef07a74f5424c8b408482fcfe8e2621d4a4a8c3807635f7e3e0e2a833a809008f946f62c9e4f9cf9dc776e3b82dbe67bf3586901073b38bd9f3b0f9c05bb20735aeb41e54f2b8db7b045ae139fa6b3319ac0bf7b8f3b7f8b90519d0fae4f922d20bc83a971736aac79b2095825ad8c75187ef6976bfb0672dd8660d70ab37175b9628669c2e11b20a4747f545c264b16e0850f1f8b9c2537d3404f3ed99073ce95da544199840c42f7fba3c50609fb821e3523734958aa8057b0b5687c1b1e10efc71f88c4e0927fa0eaa2736bbef734b06b90c2c9788da5f5333826b2d58e4d5eb0efb17c5fab04e93f92f62cfd1258c3ef37ed171abb86845049e2000652fb23c9a1bbdb96f02f96be028a0c0bdfa1fb63615ba0f4a0307ae310042b6893cbab551954660ef9129bf007301cf6d536165381f2f08a9489972b41ee0805b0823f31c83debc029b599c75432447caaf9556eadf974737cd0ff46efad93319c41e2f6bd8c6cc5ddba3dfd393ae02fd8816c4b5bb40f4beb4738d90af47eb092c087221fc3e9293b8ff9cc60b79103c8059192e3a5576376322aaabac0e5aaf31d7d27d2fe558b355ea6e2a26e4373f902ab28a9b610e58c3bce4efe5fbe8ed59b6245677b892eecd38bf1a9d4f62fd1eb279656fad1ff66ef2fc70ed64fc2c51b6eeafcd0c7d3b008b50cccafae7f8eee8b6fe768e9009944d255efc312e4a3597d4a99f34cfd96b94daf24787969f6bca8531a958a0b94c04b9da18da37b899c372cade02dac37e6a2c58c8ac22d8682e7965709ab2de9f5ce6b81e21465fc4fb735f9947fb87700744e34c714760a98c0f1d6da60237f1ea784c248f8dab253c614c1baeb98b4b9ae94a44d0a8f5c972e1e143868785338e3630cf0a91eb88606b13902c8a9791c32e005b683f9f56a3ec5d3b38fdcd6c4bc0f92c5fe12187b37bceffda84424066ece4358d3806000eadaebad09bf41361428dca5d88a70c3c79f4a518d3759d1b2cd8c8e0b9cfdfc3393ff3c3c57411435ba810a8927f5b9b0a244705d876824100abdbb5ce8481a81daf2e8b18d0b63811d02e0e72fb430c4a99fce2d7c1e865256013e4f1f7ed1be1bb79ba446a0d36910c67e5be2292dcbb591e5073a5f1e0477ad3753efd56f295b2d6c47a388e4eebeba73e87765b064d73cacd84ee2aabe91cd93891402ffcb571582c0d9ca25fcc20cdf50c589a5dc6e9f69cb50c689f63707d4193198b3e35e6dfc08b9f1a22de4a8ba77f0bbbc46cc436c7a6ef044b1bd891f30eee8048c37ff2953e3b708fe55f1630d9ead3a00d2f995508f0e47b2ae47569740cf68bc5027014c4c1439a5985096fe3b0c85c2d761668d0608ab3a12807b0f4cc8cf924120879c3912afea8e81ae9049c25f9f9ef0e037db23a785679a19c956a206dc451d6e9198fc45577ba09201ffb5ef49a1f71d83a82db96039bc5003bb9f8a2fde209a29a2c7ae964191399b036a82386af81e980bc73645532aa24ec10a20a2718ff0b89243f4ac3277d2e0eb289f4d203975322d7e7f0763c2ff2a570f6815831ed1be75fc3fbe4d14265be7da9f10a6fcfcfff1652f69bfda929953b56f439985c01b9c9f9ae92beb95f51ed1cada2a0c63e83a0641a66f83a787e814ebc4576011710926c81273b025c128981a83c66bd31ba7b69f134885fe44fc20da9948ea1b07c1249d158dbd7e754440b29119d9682a9bcd68b5949162b84be393614ef6ff2549bc26ef72df1a3f14a1aeae824a1218bf1a4ef762c808727f2f807a5b89788c7ad086d54a2cde506e063de6342ca7f3250468d401a6db8636574f26e95cd13c174374354f204906b7432da58ed3e04162d9988a3ac4a1857b238588bac6f02f5e48aa08f16cfcb1f225efabfb367f2eb6c8a468cdaf2513034cf6fd4f210619018da51c0195af1a5d0bb9b416d0b51ba5e670552f6409b2ebc97a26192a24c189a83a76d7f7635e3a08ebb426c1b05984ff06664a7b504be99ec3e5011bf143e46976c1a2fa417609f95bcbd9fafe64f45153f74c717e8fec718e62c75f76b87fd28795b420b091b83f562eaee0f52ca732305199e0d147d83728d6089b695daa43339c860e84906c932c7d7a06f64de9c90ba90462343b48ed192170514e918b86777d66f6da28f7de10d22c8560f69f299faa1f088425ab091e734c944fb4f8d1823409b2d5e3ce2b3bcdab0248c487677a8960bbd18cc9f8c0c9969a3be1d2eac8610d23f0bdacce178e7c5db8849b6e5c4130a7dfd41f943f723f6dea4cbc22daedf14bd261d7a81d6f49432373e4ddf79095ef45dc800a23b5e85d99de42c119bcbbf964b21aab6d99a4e22964ebb78b7974ee948f2885bfb765060261ae4f3bfefb71dc86126d05d666419897bb6bb69b3e99bfbad63756d1cf434d66143092b94a712f9238f114cef101160642d73f9c1de1fa721cd00f768a18cc280da50f3ed2f0b15363d12c1e53d04cfb1a69884474a0dfc1c1ef4deac3002e6c2a00de76cba4ac67765b0e1d8706ab51058a8710617f35f0cfe0625aac6d80e9aed70f32910531d242857c503a5b505307e8e18844e48ae7dd58ee75483fcb566da19608ad50d7600ccf3144d5b3d9366b6b53225ec8becfdead4c5181764aca509135103ed5fd29971495d1935679ffd12c87908bbeb69fe1910013d6b969d5e193ebb9b58f0e321f5b2432b457ceea25b1874e127cfd96bb18a902ac33c579f8a65ff36b75d5ddbbf0cc83503d22f91b6ae10052e86e843b8e8c63f16efd360e182c3812414c31cbcbd5e3a8566bb68734ef89fd2a003b5c39831e1ef6f6d6dbf19dc9bcb93fdff2815b84d472ef59051849760e2d3a410db6cf50956d37928ae89ab859efccaf092e7b896b7ea61f80d368774a6769d619a283bfb5e491abfd21556e7c3e3c0d914bf24cb49b310bdedd99d8a8480eb13bf0126d32c1766ad0dfedf892259a616ec9d2b047952498f3edccd115307f7ad5359dd975d223f3535321c62082bef744d155e6f595370d6fb98020b253264f2d215f53d2a4a59a8b80e82b0ec357fdbd2b550545f53f7d2a466547d07954fa993120f1ae309b58401c32d73510f6773ff9ce5dfd1e0e6df76d056ee5f8090ea41dde046a698e5d32c781bb7a266e51c4b256433bd661918c4c31c8e7acc147ae08e00590eb8fe3238581524b6c1c54ff4a368bc68bf926d2ae04daa095c1bc555bb11c1b19f80c06e173fb82640b25bc58e7c673460874a608b21cc9d727ede8dd2fadac423ecaa7de3841edd8b7bd50329afd1ad51817a11165c485e606825ce90002cdb926973c665d917e5316bf755801f08923352074d4863e64496948023c0e4a927b7a7c315e6659346901addd450087bd130e150def71143bde511155a4ce8638d2735a1cdc44815d366ac8e0617f9b5040257d33f29bd9b3664b0c86909a9b540c0a919bcfbdef086e70b788a4aa1ad9438848492812130f19dcd28ef9a26a04902dadef6c3ff995af63886b73fad642cf25d5c03f464d85e254affb8f8738fd88b6079648f7d2802220586db3e7aee8a4df1ff596d9cf6351d7d33cb0214c962225409a070985059b61b149495b50474885c00da6580976d9cee878263e37d46c2cc07b9aedc4a33ffcd521ed894e0863a23f2208e18b8fafc008c8a54ce7ebf866946aa254fcb65987d2abc92e8f1a74295e8be79e9c6975fcd29a52675825d044eaebfd940e0c470891f9768ebdf84507d58eb64ce5e68392ee1875d212a602ab516cb7416cd1225e028e6b058f0948e9341730a77b92653bdbfde978201ba664e1292a252adb2c13d1ce5be44ef89fa3c51264dc233032b777206fade580ffd7ee2f39fe0b64f65e15e8ae0dd53c4195524fdeb0b503b4990020fc9d59604a9a0a73c6fcad9c2ac120dbfbac5f633772bb28971c8f958c12ffe18b04af789f9eba9b67a98576678453e6f7cb9aeba63714d06dcfd6d86cb51a93e4429e130f426b49219ede306810862cdebbab1d9c08898152fe18c9ec0302615defc2a53637c4809405a05891dfcbd274ec257c5f5037a46549e98290fc3192cd41a5e7963953243e4546aff3a56df8682afeedc36001180ccb634cf3b96327cd9b506d77632ac8593e3c9402f937544106d2b90c71c691bdcc3d369f05dd1bdf5c4ed0f4c3f036f943b8fd1419c03c7c0c40f4bd18f9cfe159e8c64adb26ef829f15b61d9e8729b1efdc5e1e6f3a627fe5177084e159796c00611af802d71580543f6ebd18df79362d34e62ce2f515405d1d9a40268d4d0bf32299e6d66184d7588fb5f958219d7b5d1e48bb8b85e69b83ad35741f0568e320198c96577750b19cde8859b4c2f52124da083c9f94a281f391b5dcd39ad4fe7d39c0050ea2477b189a88d1d944a90c91956bdf64ccfb4d9d4e262863e521ce7dc6ff729911fcf2e1aefe29175e02f47d1bafb2f263213f5ff8e45177a87df0c176c469fee2712cff1766486fb15a4a9e950859da41c986e8e88036592d1d9452a04cc205c3399e39cff7d4e8d6bda5901c13c41fe5d769e0ba7a8270b3246b865e5def0b52a112d17ef8d48efcb721a364dbd9ac7cf038fe03094ed398c67aa22a5e7e1f483fb7db039c677be5104257522aecd20ca3396c3533cd5fc71d90e6533dc3f7a631addbd6df752833eef34d008b0573bc269cec73f6ce16a336d789af09745c2a59bd708f60861bd13fc891e2f0a60c53575b720afae677d367277426bacfa44be753628e948e715905c33c8d02c813f4c3ab8d4e19fd800331e0eda6a6b05c4f5ddc54cbbc14c75cafdc60f30b27991bff6b9ad4e2710fde193ba3dc2e8c328aa8fab35503ebd456616de94f0c24a52e677eb79c67e76290d891e6fdbb299108160a0f328f03fe2d45de51aa6299a427d98af1d0287cd55dc434c2d87131f0b68047ef5a1388afba1d0d780940d3260a21f1b2c44a68d12438915c8831108a6894f6b6e53c4786ee48c53b89d27957f75281979e8267a47d2aa8e2e0b00eb9d9c8e8b72f12d78d80607bd3161db51123725ae4d61d1d02c8a41244342a47ec7ffbe0e91b33daf69adb3b6fd40b76e9701af4db9d68fa38b3c499f230e979e52e28a7e55bba215794356e5f9c7e9a52e763dfbbf85de36b07a43b7b6d66d2706a9a97059807d4a496a4ade5c99e75a0d4e55e1268cc587343350fb5cacd42fafdbaf516967ad5ac72f31a7af636d58898f57ec05be4496c0c9f97e1eda70bcf07beef2648ea80620bfdcf1b1984453dc311f8a5beb6f934e04acf58ab6d3df0b08dbfca39e256cedc1d6350f075a646b813c9dc42becb8643d83ca447f8f7ad0b7c04d0c871b3d7bf316a73fbc32d30edcd59f0c831b87c081b221285faabd891f6bb4537fa0f4881577cbb34c01133985177519769808746404858431eed9126c88a29e7af17a92a694c893ecdf0b0c1dea5d598accd5dfbc9e289556451879459b6c84405212f90b959fedd49d4eb6e71cd4faa44b5fc0e524bb02fe6ab2c81a1bb9fa31e8c384da15ddcba1a29feff289b05ea1375dd698e520d9b2492d6863602afbe02c60fbc426726638bb1c491d1634f7c30416755b2ae3256c177083fb7b7510436b6cbf0136a35c8404d8627a9c439864a029e17bab912923478f28a86d64ae8fec5820af895ad59e6b3aa6acd9b17d85affb05f100be0ce6d8c5f1b022ab0744f83b6d64decc76ec42f65a542ae734feb30ebe4b6c5c585ed78934da82178a0520df9e7f7a81194e97514337fe620da9d5afa8591f418b2e854483df8434e89370102ab1f30495964158e12373494e7f043c1c0133df6d7abd8b9547a6e67a410a78d8c9e94f099080daf4e0cee8b4560eddb2cc0208c4e6d5ad6e8133c1c56e8b4248bb5e761e7fdefc838e84443c7f6c610caa2a564f388d363694a6615de08b12171f26cef4696ca760844b946b7a8557de21acae598e7fd80ac1298a84168e022cab8396d2b9b958956488efa0b993c54c1481b49cf31f824243e5e8390090711d8c6f2cc4bc0b39a3c0115f7490390777ba7d41e711ebde949197f82d671e7c39e5f072ea4b6490f063685bfa45098d7bc2c4168613702c03279b344e81cf88469182da0fb19ad1b6dc6ad7854dfa0e0ba71bda2f4179bbef13e113614927a231ba8db063093692d939738866bc3e56897790bc3c4caeb277b2e92164220b2e31397a45087aeff591529c2308d7d3ba99deca4cf1484ac5f133191229c83ee1ad768f12108b7fafdc0adb9830e5f49944752fc95392931cc8f5852c3dbb7ad29c2bc78af59aabcb0be149725b19833cb332bd8c1e4dccff8ecbd220fff1b6029908361db355ad0eff9e7c25a8a72c8aa0c2847498668342d54ae3d27ead22bf03874a90a98e15ad92998de7ef1d1352e218d2d0181340b97c000b5d8824bb9e4fcbbe528aa55957723f4e0f5273ec9ca7a92e52f7f569123ffec22a6da395385501d2defcd290483d0f22c3fb5dfddf4c6d1614dd77d23c800654177d4376e32748d5e486da3651fb7ed3cf3720cdb1562974b007fb075f76f687e7886da24ac5e14632812f89c44c478a9c04f1ef2f3caaffc68ba364872042684cde68279f5d8118b164e7facc58154db7ef042303bdfcb4c663537b403c5c979a4233e44ba4fb4997fabd2bf855ca28e0c8d015c2ada68ad0177568d70a8e82b7779cc3bd2399023538e298f14602de5449a22b48cb5ad1348de07830b107c988e88e23b2cfdb1fcdd557af8f7dc4921f9e9cbafbcedba36eab0493163df1be879769ef884ad57a5bf98f256fed4fcd85cfd1e0d69a5b5e69e879a9d9537fa67820b2a56d529a22e7e7b7a49cb495aa2e67aea8ba2ad08376a1b20ec5d314dda9eb3320f69d1237f453a7da9cd98fab7e97dc040278e5700ac7b8727acef5b3e64008aaa75ce1e00d455f8c1216db1151a42e3b564400568b1f56a06ef26d74d114dc88edb579d77722bd7d69c10ab97f0d21546a913436f7b6c042859dd9118c333bd5e237a1a8e31749c4629dc62e5996409d1bf4953acaea1b0b05d8e7cd294cf1ada9afcffcc25908b2a6f851eb0c8a223a2cfd2365054013bb13ad595314c8042025cd728615b2c68e646c26316e20c0632b0396e23ae0ede8415071c08a2e6c2186af79baadb61882c7294b3f186c77de6df0ba69472dfbe0b959d34a58c44d2871859f496e42e90e6099fda5bc6519d17750823bbd864e29985247bcebb897101d4dc9164b60367691b4ac984c5059a326f8562b3a777e9ff96d19a113219033689f5d29e55246461dbd94af2babfeba95c5ae1d671d8d6121ee68706fbc1ad812dddb692851175f8753c3a16582a486c18177415c77139dbc3b6c27b2bc0084c41956b4c69480b54e9b22468fb4170d2fa190424329a904d61147340ee1b2131f3fbbd087a5d16b32baed7bfa8b29728dce11af96d25092c5cdd331f90344042f6a5ffc3acf16761962d456532192f3c250022d8188a7472354841238a8d9630b8d05f021278735336d2d4b1f86308e3067c32fd0cbd80cce522c29f6083d1d1822e1cbc7105c0823a40537595e89886e8c8c07154200ff87a10faf74e22cec0d5d4599c70a3eee149b40b54b63f9ead1cea77317c610fb72a41307c07ba67ea3472ab6987130ddeb75378ab81ae7856d5c953a4887836fa0be937daef6592e17c924125364e26b087859f4931975ab10d1a163a6e09d8b046158caefa2de7e0e434647fcf4630caccf8a362676fba31e7ebd52e21deda45b995af38e3160d0892e514987e4e333cb16067eb9c2408f5962bda5398f8f791fe1b2f44b7ddf23c9e94e262d235f62f7b9eaf0bce2f361cd9fb36aeead1d716d5ebe1d965177c751b3c4ee9f5242b6b90e28ffcefaff5a15b71f4b95dd02632b28527b32f306a02bb0dd11686cfbc768b4cf7eb88c716b4fff471caa420ecefa0f172a4b66ddb1665370faf70369ebfa7587c8d992ea4eb17fefa561e8a9bb67da02d9824b73347f6edd343d61438ca5da9698f652ec20c9922f42afd6d49c942800466c3e3b52ac94adfbd2ec8f023fe093150996616aab56aaa7dd989d287fb21fe61686cee9aaa05d7e120143ac5fffb0f40982d4c2163afc898aa5af192d0b3bec3719d1ab8f6915f8efe2e51da01598134c814396ed81eb83351fdf3638b0eb3ee4485d29720d000e40dd4892923e589774f4f89bfe1321747df1504a35e0b031e7672c668880dbfdb7eae18570e23375ef208cd5f80ac60f945428028b41004405bb63996703c23410d64f2b4d5d1571b393d76fb21851ab8323d4df24775df2221d30ea08927a06b49b6fa09d93326405d2bcbd14fb923dfda281a1d50b810fa23938d81f6a16a4901ef0af29d1e5ef5f84480161e89fc5fe865ec95c9fa5176b8a785ecc4a7953abc306b021b5d21b7c474ea56a9104889a8595c9f2102acc9c2c1918c7ace62e615d1dc817c05533d3fe94ec3b647fdf99c170e2c9d767ec5d8763b8bea84bea0d65484531f8a61339f7f05a8064f5d54e23dff7c0ca1d56","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
