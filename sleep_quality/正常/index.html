<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e3981465956fee2483458087e0852c750b455747f7a31a0e44aa524b68ee6442e0100a4633723f8c20b2edd8af48857e88d54b5a469988b46e3744a623475dfa3b1eaf918a99cf7149506e37ef0c763e215267a21104b77c7e331976eeaf19c4982daa426e26ea0ea101965008820e3f60abecea136e7b7f0c9d72873fb2e2051fbf8cbf526219ff2fa4a81459b92c62bfaf07c06fd4e3f84d80a7a221e4d444ac3147ab971465a1edcb24a76ed1e46b528849c092dd8200a9e247d754073599bc0b950623cf634028b1b38a33534d64296d593ce98539855769f42a48ef5cdfaacff9dcb289b02b931c4a790443c769b39ffcfd6cb792aeb99813444f41b672329bd3cb445173c814af95098a556e338a75d9d18b21d82bb853e74d96513a4e08127fbac7c4864d6528b03375b08a5d5510586b1b53951261bde4930d413cd6b1cc54903f6a79df57accd8e79afa5b7283f50e770a29aee112f96fda9915071f9f344983f160259690fa49d4497d2bb0271be6bd68ba7f36ea2366dc1090449e627be1986bc8863ec878eb78c3ba862e5e964ffeec89f7219a6f4e8aa29d9fad6dff7f90d651f97b6dfab36c0997f1d8a9e2ca2b52edd0179776b8dc18a604ae2e213c894abc5f4999a77869200226c9bb3a1cf82b32d7178cfccf236effa657e482d46400d187642879661bcc75686b4c739d8298fd85d1d8a9d8f317bd946d5fe9e693366e2aff0fb3e7f3a0cc88eca7cbbd2f32aac264cd392e57f1efa0b2f92946188ed77f849b54975bc8ae5a66397a2e9d1cb8a2bf27f809329d3aa50f8ea5a62e385952b05b9b6775644d20d7262c8f75e1b4a9d5ff2ca935c09084b94e8d9b1da7ed72be0074dd771bbac703450390957ad672d3788a5bb9c0683ca19572ccecedba21ec745cfb4608b8fe2aebd704dd48b6a65fde467c93cfd3b82b3307cd12ccb93c9d4448f6813cb06666579892fad3a2713a65abf52bd6a8bb2f2e54fa9c26e45b24af170c87f27af0d2a6743f08d1b057f91e1c8a80c36069a461271c3054502bb004baa4f57e02904479b593e674a6879cc43f293bbc9c2277510265eeec689b5e9731404946d189c84848a02f7ed29402697c5c80666dc3eb55171fedbc1a5404ce29e0a36e9db8601248ad91ab1e7a9cf4f04ebb43afa97e03735c66a60ac1a35d04afe89b705888730b9abf1458c843db9f9cab8eed965d2b1ad438a62cdd814ca08e0303c562bec5a44c86c05893a95f7d527d9f5675113b68ceebb91486ad0c032c4cfac8f7450f488057194d8e09174c4b9c4f8aef63b0344bf492fe5fc9839d5efd1f753c7132247ff79750665e88ab17c3e0f322fa02dcec641cdcdc087f1d8090c4b54e8c033c8dacf349127c7c040c047acc1607be3a097f05902118ae172afd5914733d36e098a6375289eaf7132a6000c41a6994f68bd51ab70809f6fd1b1a654ed727d86064d748a53a1a03ddbaa76c556cffa0e6cbf3dc8d4966adbd974ac2359e829c2062d0bb93abd9b69cdbd12397d97a08d6790219a50593f6dac41995e5dfc750ff2f91f7f17b8ac21f44d5927d9e1ca944cabb2ddf7f6866a2d75abeb6975c60c7c8e124bd0b760413a8854425deaa1afa462e8da0254ef40d16aa3f821b8c99374474524d597177c5c072512d7c69b36e110305bec8c664dba3824076a818d2400e62801069440a8be1f95a2ac1c575d2e84f0df8baf311dae8396cf15e3acf8e27abcd0cbae72f5ca8649ac5d78be33a3815e4a71c3f936a46282748b892269de55ac85e8fbddcc04297e02bb50187ef2e9c3520df77c1aa6802964356dc259b0b640e82107f4fb0555c72f3551ccd904c5e01d7058cb4b9cf62987add90b60f8b0be31d5b7ed36eae98aee5a13b5385265f5cbdf89a23d214dc273d53687cf293df093faed4bfeef1adf941edff106fbf3afc5b3b5621c6c6ec274def101a0e0c30180772f394eab1601f6c91f8cd45e395849a640f2a1535223c623ddd04232b75498e322b287bf6a1c23b9fd0d748b7dddd8885e807b5cfbde2c0031ac2a5a01eac7da17948879dba52a9eac0f84e62550b7ca39b22698fa475c5e7964b9fe08fb524a827c8e4aefca1632be99f4bae5393d6f5826ec4c91a75404236471935de5a85ed56a9aee785257a475f8f6ff16c238172e030f9b0d3c3c8ccf88118b3535b35b26ec0f94c29a98fece3743dea22f4185c9375aa96b13991b24f728262dc8dcde87d46140c977daa2d9345b19a69ca280e4fee4c218b727313af189fe154580f17f7cb9ff75f5eb940ca003cc59db67110e67f198dea4cb4cb99cd6d9df93b1e2fe31d3e050ad0db928de22aa15ce5d6de34a9a8278b157579c1ba5f826ab4db9b74fa17530f854a0eecb52b80d51ace209cd97f377e320cd33cf99134e0700ae1574f82dd9d413283c07a6baf3f21fa9b738758d3f5d7b7991f16c27ad36b0c00f21d0544974de6033e0a495f6272f8ad40a48b1fa474df40ef71de6114b355c1e706cd6dbff24719011dfb6013d87aebd76efc957542e9863e1b0250be4f9ebcacdad5f536d8c3f975752b33f2766fe2c7e2c0782448ee823335e69e1a92c2049cf607e46f83d07c562c0d084b3d53c1aff23a58a6d114356e6dea9572991ca1bd9e61559370648d0a8eac161ffa4ab2a9dbb551ff2044e30fc483baa57b552a24e044056e350b0bf1200542563b29afe30af06df59cb2b88915a229a578f6203236f33946582660ffdf527724fb1b268e5d398a4792a8045ba11abaa514517495a04a5ca5a602d5d4dbe028f056ca572ab2dcb231058c2654231efc68a30605f692ea90357cb5d110f554a6ec96d4b7fe5cb018487bcaf20ea3f933027d68ef5fc683b45824867820dfcf903b81879faa6d20b1196f2a6e458ba1ebb43c96d048d1dffcbf92a0cb9891299880b2c1b696a61189fad6a77b8426bc515049ad93b45d7cc4257aec276c9a75115ae2ba4d08fe806306547e27dd18fe3cd93d9e8db65ffa8638439f8baa130864408fefe66541b9e8230edf86b5f8cc6cfbc4bbacb4fb1406ad896b97e9f296cb2fce801a9d53ea7cd51bdc759b4d84c002d97e860ecf825ca60440db126ff0ae0d705f9b8f3687137578a300c23d6863cfee8af36526a6eae582f8d21bf0251b910f1c5c0b337c6d4a0bdf3bbb322a694e63c58b474ffbdc986ea20a52f6f2674464501f78cd66374526ea971a3096d123b643788eee371e07a2d487521256e2b3ef0354d054e7c88c449f9890dd6064f37cdc1802981f41f468756ca8f06811c537c9389a5821702024bc8d8d63f1d64cedc93ee44fb5a0de9917daa8b5a0c748304b72583bfb586b0348a42adb6e18acc7af861676b9d6204af592370c553ce1c94c6017c16423f281a0c923119fc6c8b00186740424678035e2a3448659a88c614b152b8572ae02d4f46111a443aa907f90295bb1efd9c36e4c33789d980b623ac2457b45fcaa3d46ab25d54704a81ddfb90b7b7ec04ca6f27649217a2d5a4e90d24f5d1eb5b046b5e4d84da7d5cdc8cdd14bb4a671e8ede5f9d90debef1cca60ee0915f622ed9231ee226f8dacef4fec72b1dcdd3f28d9bf74cff491494611f4c95d1edb918e8a2cea3b387bbb7620b40099a6b27b32d06cbc74be8f1dd739c3436bf54ed3b80ed080f388c27e20c043e7457f48570781cf1284a5116ff64ea57acf1e28ef72055203804a590204fefea2bc17129b64f5624991f40880e2b62fef74238c2201f19946510de74c3be608df19a077977cb9df84387ee951faadf2116add92f1616f4740b94b5897a9036470cdf47ce85f8c509ca99f23f105beaca963b6d59568a75bdd8918fab80b7f1bc3833c7e9779221b5fc0bed0faad309b24e73da12d39f196b4d1f8ef2c93f79e9009a1a148662f484aaca826b9683830aab7196c3414398b03c02427cf16eedf974e8d1be550393305d88fe35b68d17d2a8c76cdccd018964e7799471cbc5db5d9a39e836978e007cef5d5d49075be15b3aa12ade73ac4ea0ebf6a2f4a31080c332378e3a33b26f9cebf0164aeddffff2953a223a0c12f591913701823411047088a6893bde41e42eff5d2994f20d2a1720167181167ff533c699f3e35c41c47dcf80711346ac764562e3e54822804ffdcb73a231f9d455bbb15a8c10327d480fb6c3f9ebf892f23dd6d31378fc2a5663991972ab48e86ba68fdaef9af9a37af4a4c40cb6f7d8f1f6e0770963c0481831b448f6cc7c809a9819ad8f2e2ba7790fecb3aa1a0587d6413458591754b952f8ab01f9b6a580854be4bbbb00203a8a233a7c99c7b67e0421802f01d6df0a2fe37f95ee4df9ece65484be7087695333e25d79e6292d3a0a7baa78ab4b4ca362fc7d0c4428d87081ccc09f3586cd917bde70d6393d9cff8e92073cdb983c3e7adb6c2f877d58166854dc1440e1e56bfac9dda901c320f802d190e773720ceb05435c437ba94cdca08c138352aade1417d788c5234a3fc1ff3be36b79680bd99d00519111cebce187463ea5f9d6ed81303b65a59d76ebb2a486bbbb1d1f100255e93495f39dd6bacebe3afd8372077d6e1b5f243954b4222e8b2e7e354f707a8b9bd753c381c63105c9d7b2b7bbc31eef7ec2c90793470d9cbdba473c827ed07df81a7e013baf0b5feddf6cef70463a1f572d322a8a6d2a73a0ed71c21fc790ffd70aa192ba101c1d5c0520ec1dff26aefbab2500b0343b63df02ac7e827354c2eec6ae637eab2fa98add0f9ebccf68b7d89f9a33d2e9ed85a96ad5a53180cfc5a0da154a78ffd81550efbb4762143b563902b99d7a8762358df63135e2c97f1cec53dfb53052bb2df1b32b1a03b5ce6773bc9323115e7a45517d6ba9c0ea6363ad3f21db85e7fdda47b15f155c7cdc3e2cf17f659ba0c2c1380255e30704a10c6e3fb81abf87642cfa7624ecd20460250d0b69bbaa7e0bde3d10ea0b1d27885e64c4c67e57368f32bfbd0511b56908320c7b24a38555851acfe2444b18576bc64df1e17e2e0703ae77cc5d4b863764f1a177625007850de279d5719a438ac05bec5130e9764f85dcdbd6fdbebcc78dc4cd8742a1416bdd343b90337c00c906a974de42515745ce61e4552786dcfd73669d2258e8e17b61e4f53f4b7f1d16e12ef85544c2f9297e9910f57bfdb4d977109513088ef3bd2e36c857603a619323d77162713360ec2b27b05eb8e8ad2ec272080197dd6e215a05c76e850228604a1c6fc7bd12ed79a454e551e7fd21b3bac6a124f1ae601c7f3d180d8792dffb7c2bb5260c42a957ca393a848107f47d7f9c67084c2282b69bf5380a4f5aa5fbbc83befd7aec8f368cf251f3d86a2564ae95ac6b923792b68416db9d35bda2b06ee8b4bd8ed7a6109d81adc7f008920701b1f3c0252fc4624b53ed4164bc05a5d4831c4bcf8699ff2d35de3f6a531f6cf35df15935c3434d37a0f43c23136643066d21772c96c8b6bbe274500cc1efad04fbe800de4f932c8eb9414b1f10c2167ae7b87ea1e014ba730e6d492086d84d5120d8de03e22cac227426b4dc577862576dd52cc59cf51a80572e6835c8fb2e99d481f5351f5792b3768c1b75643a274fe9eb2b8e8a2559c5767c5277079632d9264c5dedad80d9148dd0aa220a98aa69e7d64cdeb1ca8b030d7a3e7c712eaf516c1329639c60c94c9d2eb7e0cb671a97ae28b53abba84f9d9585fc857765bcaff2598fa3cb3d49b6f933694ea998b02a5543211016f24ea897c89892f1947fb29b53796fe9c1dde0bf8925def2bb558ed5cc77ecdac69d44dcdbd615fa941298ea676fc78cf6be4c6fa10c181b12a534daacfcc520ecd2464fde402dec861ba9ccab7223450f0cfbf7bbe9c9d98b297a26c99a9b9b8fee2492e3d2371e1970a87a4dada2e7f228d0da5787c44dc28c6c4de16a6e0d9594b75591975a3f57602f1322219c1b0ee4e4d4a6650c0e11fd05f57e266f5634cfed23bd9351a17b0e8d8b7c4e372b421511926173b605f9bc2e4f92fe5a652fa5378b526290d1f45d5915d41a3333749a1f7be0bc256da987f1f76ffbba288f8b774f2188145675f32092aeccda84c0bcf98a93ff4309ae3de1a88ea054e7cba5ca9e9c5dcae819e15b62db66c9a5ba7829761e5c181af48afbbc0e7f1de2cfa76ebab0be62f8d0184f342b65e28be63a29ccd93253999d934ab82ca0318adecbefd4c0c6237e9c9f3da5df0934284fc02ef086fd3ce5ae8bc33bc7c4dd0b9d31f7a77f2e587fbfe0dd8906396e9ff29dd24baccc5b19438dea3f49be246f549b31fc29088062239999ef6aa4f6b65410ec3212e9ceb84b450da0459ca0d6573f9f6417d77c2ce123053e65fa47c95f5b30df3ca1a4043adf2f757fea6abbcc518d64dcdd6bcacc3e5a487a40b17be62fd38ce5c12eb573d9c424c9c1d5e0eb5c954e3dedefb370d80a1342b627b11ccea5d36bcd8b18f9b8b481054ce9af95036ad35c548b599b16d9871d5d8b8f4c30ac252422bb7d16157e41a49cb124d2542c0d19b5bafd5d414dcdf74030db13c3352838b57484674ac1cf1346d882b945711b322143c956245100f795fd220977fa04e5a7e86447dab5adf914751f3dc510d7810f0ce23c381a6d34c5ad628d3792a6226618364e5a73ce36d39b2b0a67c18c36f0dd13f4f4469b0940bdc47093e4f2a51f1080a034101ab02978d712d72f8fb45b1135f190a75f2e2996b83610588364c354aaed925ffaebfd8c0c5b72df6c215052a56bf60c4c313f0013fe7e88c1d323456bc2c1378984a890773832bf85d09cfe406cc006d4cb52a6bc02cd80ef78c0beba48ac0643afb8abdeadedb0bc500cd085cea85d3adba3b4c9c224d32359c48f52d38b88a183eba7b1be288981b720bcc2fc0880370c7d28ba68d3fef2a7fdb114c9705d4f6f8cc7d96eef5befbd7d2a275a2d9f8a6e4a2a4f5544cb7e4e7389592b1a7dce823e03422530134ac5e9bd619723a594e698702c9b7baf455fc4a3b25987e269fde62be748d5d004b950a39d2a10732d4b1b0c5a65b945f5f77206ed9a76f17d23937c8ebed02f71546e313a15f3a94012dd4e910534fb79bdf01947ad226dd064fa5a7fd556f7ef1cd20d516a52739dc512cf8d6aec9b52245519c39bdf96254735041859c58b7a06fe51ad036c83c7f32fb7b4f5586059f1efcde83a096ea23fc48161d088395ba7a33afb45f2fb83ab928aae9f397cf251f48458fc294518b5ded3904923fecc7f42e675103b3be18d76fe25571cda5aad949be15088052df6b38a164ec0ebe5cbc5ab6fda359ea94c76e1c6e53640a6e5e32a7c413945f85c2ebf478b5aed0560b6ca82d01b13ed5af91bf15018a134c58988adabbfe4cd7f50a91ccd0e95c9d459c44df67427965d41c95dfa5094842fdabec367098e802edc5219f44130968af34a237ebc75ac90af79d0b1d41b5a3dec12f42b1a59328d66cf51fa1b68bcb249b721b78700243780b5929168757baff082c2de0b46a465b928fdd4f6d684ef5d7bd1351aaaf262628f1304fac3c6ac259f0254e46139eb22e18f0fce7554b39a73359269e1cd4691cf3381e5bd88667c10b267ff6cc55ae8572b86d82051e1c00ffbc83164688709d6dac2c792ab49468d403ce9733eef514a9118401979807f26662215d5506d695d847d48e1e876f4c986d198c92cecd6493de2b9fd0d90e263d1f5604a3365f4845548e3be1f52b444ac92567be91b6ae5de16530e313f079aef7bb15ab854ff163cad9f0a88441ff634ef8b09aebebd2655899a265ac922799a6a25b9ee182714ed2ab44fea925bb1912ed66d8ee25cb9363769a9250ed241a9834ba78b35516079ed08b7853cdca935161d04540d97292f95b0c9a659ac1a8f9bf1aa729e1cdbddadb8bb87197c323f2a29d687bfd9d04d8d19d823f2df562a3f7524a10b6a6f5a2972c43ae7bedf8366e0e8d6d3cfe92e9377ab426208f185d3645b8ab3e8d3d7f1274c984c1e39c3ba351def588614a9a08d3c1489e9256d48fbd612c0201bad2ee12417b876273a0baff53ceede154c77900ec98144b2f2dac9953840948c47b0c0b274ad0882408e7d10f009f9d822554645db8b0fdcedde144b2aef39c2d277e5618b6550b72e92f4d0c3bb30a58bcf0ddc4826d96d1e1b0934bebf317ec5e851bb7e0914ea23d9e31d9fa2871ec0c4210ab8daa9af751a3bbf50338fd4d0ec2608d5b025a53003b73485e3a2adb45fa7a39605dafcea1e5d1c58170cf9e8d169fe96ca3f25f219250fb452dc4c506ae3275b6ec9677815579324845ca5f369cf1c0f13310e203e14afc92507193c2e2012f4e39c3d6c234b731b40e3add40cd39b3c7cfb9a2023356a28b7bd672374e1aa43ff2d485e64f019d2d6deac37027f06ef568d703f9090f7c0da772dffaf3937dee90c825ad79d5d220c300d2537b1cbc4992291217cee5989f91e3a1689f72293e2c57dd4c7bfb9be61d98abad32d9ddd273d0d20a4aaff600469120d3a8ffaa1b9ad54bb6438ce76d891043378500bf0c5e3c82a0e3dfce93e123c0e27a3ac42df7723f477db2eeb3fb5534d0618aefe71d2dc24ff4aa0db5028353f524642140a0131309a422c431f0289b977588335af7c3a4c81b41e5bfc74a10b66c30ffeb608d7537c38ad7b0f9b7c6e32c44fe2798d3260421746c9d9212f1ea071ad657a5a01db05ca82f30895afcc3cf908889e737add24be89f305dd43f8171b65534588e8bc3a0d83af06a0a203073f63014f7d17ede20dd804baeee04ff78f630ae056af8a383c04c58706492619d13df484b64af33a1e62480b0b458dea9e1aaa1742b0916f461ac6bbe7b76e43232d7814ef9f3f8d0c42d106ae8be7419aaa6b8e2e262ea7bd371281f7e898447f869acb6779f488e0cefafc2d3274a9b5159e49e32f362f9211d1ca2c70ff2d02fd9f5ff063b0d493e37db344b3a1d1130f22a35cffa7c4c16c6ecadd3e93192803f81b22a311f03f226417416cf4c13e0c685ee864820a32b11eafc99003dfac762ec4c0b254da43c62123de7b8d87687aed6842d2e53eb63db14c619e2128cb61f22d8f206e2e87ece1be14305ea3356d9a19995a2097a07687710be670fe037e1da8931ae3189e56aee72ea10b8da183f5205a0b3db989e4a7afc63428ba197e5dc035bc78c927233272d25fa64e2789e7f3fe335207f8013011504996dee31ab49c8e45160a5369e5ba141711f558dbeaef9c4c5749d7a98700fc3e8321805e31ccbb5abb6032e35350237e5ef90013252b799df935eec561113b43c19f033a10eb8fdc90d62c3130a351d3485635e103e8d725953c71577114baeb4bb7db0a9d39a0b290e0c1e422728315a7961b2ea7c69f94fd067af23622d6d3363a249e55be61b1eaeea9c988a82ca8bc4cd2928511bdc8b1f276efd3fdc4b1ea5af8dd37817e9178112d54768fb3ec18a432ebc7ad3d9ccae35e4e67b2468434bc3f893c32173ac6faf435a9a56bac287496f7bd07a44f80849b27a8365b14b56cc242933b119f441b1589fdc6dc43d39b4f102d63ff99d145dfb996144ade034ce5cc0a59b76b085f4a3bc6c9d9acff3f7b9fe7c482b09a42599c274a2883f8bfa16bb5e4a6ccc194975434d83e15643422ae3d511ec9b4af7aaf4d3bd63d7511dad9a7dae4d257fd7a3da135a15af026b00fcad1ba20993fe352c962cfd1a737b128256ea60f0d8f22116a738d9bb58c640444ef007def00b5dbcb2091b1522e96b842dbf049e0e174df4f41c96fd2864875124a1414d44be11c37c8fe05c4c10fc4ab47a59e8a490c10bfbd86288b40151942765dfb29317ddc265938638899bfdf0cbe5dfe477f2ce54bfcfad95bb5d5e749152f6f0e7191fbf0b7115dd5d92db1ce176c08fa156fb180fa7dff8ac5760295babe9db2c7149d3d7605fb5d52641044aa165a6ab0f960ccdf2c2c56a1b7855ad69b9e73f65da8fb96aa87b85b0d9d7191250ae570397266517f841ab5c9e356ec3fc03cfb2d882a894047cc3c08baa3dc9aff1dba664b4c796f5925fc96284f2558ffeb719e362503bbe3a75755fd393f3699a42d5a99b364e1bef855f1317c80ba73bbe1b54062de8503e2cc64f906247a2a186d08e87b3147a4651dc36e14452d1437aa7cb457d44c94289eaf720b0b9148c9b5abf242bd7aaa8784a3bcc13cbe0e43f009ccedb9f5d92643be81de47b94cb034dc88fc62825a9dd47400697cef2a854c9aba3327095f6c0bc8bc567a40f3c3cc30d50987839e976318d4bdf27e19875a939b0208c156549803600417389d2739232ec5ce20dc16b82db8c72f3f03c9b2a97ac0364aa699002b6c1d7b523218ca2ff3605826569550026cd5f523fdacbf1b96f3d7e9cc71a47d8ad3d6572283806d53088f97c2e83fb32d747fe2d755f19093ef2e490e79e7f80aee8ee65653d450f2ac2431aaebac1bed842eb007467446a2b2667585b515f9a7132b058a3a4e457db9f0b441b0a918df0f75fe16091d9502ca7c0bace341fe9d5a6fff1dfd3dcbc74dde5855ce0462236c9a3c5a7a3e381819b1fef7fc460f0641d6b0d9c36e3ff8876bd01732f365e3f23c5659b09f9a4df5f11eafd6995de73dc7a422a4daea95b377a3255341a19e58f2986079a922e41f18c98e76f77cd2e4b152a9ab36cbb0a0b69256b5ef3a52c4faae2e1cb85056f21d6e6c3298083278e810ad8997833398da032b63ddeb1602ec883d3e0ac49c8276410745b4755dfa408d96b53b5d0d401624d9f50aedbd9324b6d41de50b0cab097a0d27d1a77a1a369bac","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
