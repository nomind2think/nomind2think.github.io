<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f316eb7927ad7687d42d38b896e2daf663e1489e8bcf6407e784d9a27141aeb11e56f574b720414c88b36f95f174db5c80efc6ec79459e9d53b393148446c1bf12fd9df5d720cd09af463c3484fc21c5cf359d1a390e4a6d8ae223afb540294a8d83a1c5cea05f15f0fff70098471f4fc15c97e35e42f75fd3cba9a96d833ec08423cdf0549ac4707fd6041d56119e124ea32a905304cc0a8f59e2301b4b7f4479881a0fbc06d44973140469ffcb8f4b01d0d8636cb1d2d43e42b72e525498ef45a925601095f86a3cafb46bab447949998c138287464f8d2fe642092b810efd6c7dac0aa138adeefebaa2c2819528b2c3ac9f959603ccd7d84f0acfc8a4ac2d3d2f1a285b1ccb372abaf8399202937ecb2361eddc132f64bbeab1f37fbb85597f5793536bb0a812edd28c008733da098bbe9ded5edc3ddf4e720561ffe385d6aa4aa4f63a6db02afaddb0b2608b20afc568bf804c2fdedf7e1e30fccdebc783e6309cbe685cb2c94942f587b43bd7ec48804ef4f4a0a7c507ea48e1c0eeb43bfd889e90b0deda74bfd212f84534194bf423bf6a5a77dd58aceb7b1e301bb361604d4531668b9f587b50d15e88a7cc5814c86654fd72debde638b6356274eb4d422719144c54f0ff42d4fbdc37c6b1146430fc68f0eeb9f75cb3ad372ea6672d1f0dc3e8ea7fc63d54cae22c08d6121249847fa5616d4f933b7facb0c6709ffd7b4935dc50c80fb54d8ba05caeecab9a832dc7a1c0cb5887cf9e16267597e8b22750cb8cec106ebe0f6fe7b6d5f297e0ce4acfcc38d5067d0bd97fccd33b283eb072786840ec0a6ec07c2901e09d51e0808b93dc0dfb7569ff357739d398e9bce2798f674430fb2e6d24d3590e6de2e38b1dbbc8d7e440e2ea3d15ef83e78fc1040bf429a266a6e27fdc82384e21f85a96f90b1dea2bbcf78cd16eeffdd5ffeec268bb48fcc839ddd769d7ac0555f7941e10ff583b601a8c777f4f21b68805ed5b358dc58c0f3f1654a10799a193095b0cb0ced564422745c4ff5c0be1d109029914b9c1f8dcee508a74cd4e16afc8b0dd82ba15b16b83ad1cd6b4834c6e29c70d09d5cd434bbbb4349c9d76689c94b8ec3c514ba837cb1896fea5bd9c07c0ea3d8cf081820e72a3b25eb1d05f781bf216be7080ad0ef7aabff2204079832cef4320ed0b0c4ca8b9eb6572d23620177d0af7ce97c10767145b618d6d59edc53f58d327c01a171df2389e41f700d592f5d25089ce92dc994aeb985dfa2df5ea479bceb59c69c67b002c09e4d9eb29673d7d26f8d3debd05eb692eefcc1996ef7dec00fbedc6d1b8f99139fe79c44bfc8a545a40aaf5d54efbec70f3f5a3cbf6b2a19602ee31ffcd50bb39aa55ca61df8618896fa3cbaba7b56bc33062194933f3967ff26800e55b3880340e590a057bd04706baaa994b3052f2842acd1aea636ea02b5acfc17cf89f509b80e8797e5520ad6fb7c693c29808b7a5cd7c8cea304627d459dbd68896492c35c5d52efe7f14946ca8978d10622e43336ef93b403fa7b835863e9d497167b5a9541df228d2b8983b044d7d11b11efc266146c20156ec0f549fe4a0f4beac3346221330aa81a368fa10312b9c0ac168997f59a3daea6f44f92d1ba900a0bc70d45cb372b7fc8b5908fdf3f8659d75fbdc07225018f31c8a4d89eade167bcb884c0a4f5d1dc78a841ad61e99fbd2349dba5ca44b66244003bdc9df62449c75512429d7986798356fdb2419e393d5ba7fb02d47457179546d160c7b38fb67404f2c6fe4b6e30ee935cc3a9b6ac3c82026f1f8b983652852e2363fcb8fe181028f102fffdb24a89b5f4523e8f714eac2d0f0a095bc72999e73eb8ae2c2a383b841e826d0d9dd193ca0583e1d537ccae072a73958d8d837dcb4e5f86915635803080654c9f5d4bdc534615f5b783dc10036ca006801ed12afb6eb8e35e8c2d7f7606d0d98dcc9df86df4b9be573e6bfd6c1a14815f8bde790bc691676c75a7488b89fcc66f18a9ba6ec170776a0270f76908970cafb229d4699dc118048de24e5537cc875d47a05cd7c9010d91d6961353d2e7839459a9663b285ad15b16609467001d086b3fecd282f588a7693d730082c691dada4440506e4fb9e5c40eebad1dc3acd8c3e93350a96aba8eac13e40e5af4efdcb6057535c9c201b213422960b51ddedad716025ca20a9d9e7a8825c686a4909f7a92e7bf9578999eec1195995034948f633f9e50bf32ee1350a21c3d92c2e013525e01bdce18e722fbde933d27af13eca681f14596056e09f529b10ec174a94ac5e473ac8c12e6fc126389800e876ca790d9563486a358a220445be80603caeefc63763cba4b722e4a2f129f69ae4d2c2c1115d19b397060983f9bb8fbd3bed71bd90bf4eeeeffa84c62896a88a899b9941907d87570cff0e472c330292db15f06e28799cc615cf187fadbcc6be900f68dd008a11147f0a0dad531a382f5eaa285082554e260dc882f8cf5f50c9d4ea5bc492a17d12876c6b14d375dceeb53c634eb8a60794dfc51790b63c948b3e80cb33ef0b09f541013e846ff170a888d8f18a6ef241a8186f02eda32f422a7f23a330cef28003ce7dfcb8a2c85bd8516468b6f451e288f98b7f59bcbd9f2268ff614d4c6e6ef3b3c9a2ed6c773cd770c651f011ca3696d12c5374e183e29bcb816e133149a213fba3e7aff092e5df1a3a5e044c773dd34e5ab523d75342d2f6d35a21582bd0ac6958a31b373acb5770fc77ec354b8e313d0bd05a19beedee830eb3062195d20458c089f0bb6d4a35f426ea2252a792ae5ab160e882ddb32640947448a6a4832504014e75477879c95f595b5e8576608a95dddb60d36783ba552d44c98d2b93936ff50b33b3d9164c8ac089547944805680441301ff684539f92237078c8fb770492700d9a9e6438eff4dc8ef0e27053a5a561892bd04792cede5d2b394d855ab6bc4d2e0a4b5a94c3471ff3b7d34aa66bb9c01b6366123b902c5c5cc9e04ef852f067696f7390bb2c58bc47560ca0535e65bf259f4f7819c90d2b31d59f8c7b2f217782d5e25e169a70794edcd065b7cc519437a27adc71aaaf544c697db2c195941c96545b0a8f2bcc78b3ac8131a49793e30f3de2ba503cc0492e4ddab2b577f264ade6f059773eac69c14bd4e90b729efb865bb0d3d2cfdcbe0744bda2aaa8e4dc2ba2fcb81feb516612fcd77101d74f2f2ac3be00884f22594449c9cdb70c54a1e3fa31c066989e59506b801ec682b07df246011fb715bc41228f938a4e5f745c74a27156c382f288c810c262ba9c60ce33871a67d9d600f9fd043e9e1025b979f0b8be35d3b506018b6c15b15ec09b3cbe3d3a46ba39946113c8e402c45f70969b1951e3df7415facbfd6bd0c00345b32a35e9efb179dbd75bdd0ac0e819deeb96ef1568cde6c172edea3c8dbbedfa4cb3faf7727d9162575e8c1fa448f8a03c11c3fbae58835769d2c4464d8d4f3e35bf3223303974c5e419abf2b90ee1d7053665b9bbd808756642c8befb283cecd7ba25c4577ffe9c0aac4d7eaf3ee04899840e62839c2792829fbda0e4f8586497cb981131f8a95e3498760cc5ae04c85e874982169136fa479c7a6066ae692525aaeb1b95c7df500d997f1ca2e97d93feb6ed1fe6027aba4e4998530c0444f38d5c74fb3481e7f2d7f0dbfdbce8de7445e1cc8e5d7b1b511113d22e48b919fd952f087f0535d6545f7dd742589ab9c46ce6dd39700daa623fbc87bbc1515f1e4cf66d22a0cdeaad1cf63fa4473b31b764921d6325bf7bb3d53cb85ad006eea5ac6493d32f400a51b0104f6ebbb58631a4f395c87822b307cd5701311c78d7c2d90c95a3a770d16b4b92beebd41aa64407f895ea101f0b313defa4893b72e7ed1ed40e145358356a7600ca05015c5b1250d9934c0e09030abbba95020b57c9484e8f24879ac186eebc614ac4bbdd5e39d3d19956556eac5f5b1eee0d0ce681412af99ef1a72f1fd16faf9c8e7f1e3e11d561774dfc976dd6a8cd32b2792659f4970d8eb76baf6e614bc30c9a31dceeb6257c950b29c3d796463ef2202e25cf2cfcd94f011066e711ab63a3a676aaaa76c8c2ee6a4a58d9488eb0b0e6afffba06fafda48ae7c95dfe97a3a8e00043b9a2260f9add1ebc7e44c5c8f046ee613f281e01205fe53bbfc38d87aa4a7875c7ec3a1f1ee3fadeb6db6e8685bb1c8e2666d946f462eaaf7271040f27f32b361db359ecec48c7f51cb0171b583b1f54258cfb2a41a41f2b925bee18bb6ee6f6b6c36579cc5a9c716654806509f7ff80d02076f1e2d508544dc469e41cd0df1ba738e54ad21057c1b13be5daf54ce10e1fc478e728946620766e2c6f5989eb7e5429c2634f7553bda515ecfa2792d213bd050effd2f3e6d8ff7149cc8947a6d61a76ce238be533f6d12c6ddd3f93e1d2b9630d29af2e173ca8fd3a4f42ad5c465e6c5618a72e9edaa797cd5e0023fde7b1f4e10c55c2acf040015aee6bfbd449d9487f2e7433135061214b55569fa86fe3121dba158f32fc99f2f08774569387e9db576dcbb9ef6ff2c3ace2299f2b9a763ea47e575076094266a4b926273a4d112f24d01a1aedcb5c96f7b97c68914910bdb6c028bb17ffd34ac5201019db40114479cb994e85bb2cda7d7a487660c2b5a54651f55354e8967cc2f3ba4818343a6ad1452585f6b2110a04529ea518f20467e2412d172c0ab78cc3a05ac3c7b292dc7f3871c4e446f8f6455501984e812b2898926a40abb2c92a81b129ddb512fcb3d138224272e4d16e7cfa133a1eb078736e7b9ef47189d780bde2caa63b34f39855d73939c9bf530c50e9c81054d8de736f12de752de3951274a2ec7ac10528553719fe41514e0d075e5d26080fefeb3790ba5ea0845038727d510a293cb4431874fa0aa764295d77325579f27dd030bf3c94729ff08d10bf76be2fe5d8d6740e6cf599b9a88519b79b875b2908b8a4a4859e54cb15d8ed0fdef8a06411f397833c4af62d0afa634d443e1574567ec7b7eb6ddc52222c3c06427f90f9e116e5281ed1b31b452389c39932a83a6a70e0603fc6eb98b80c1da05dded520e7f3a889952919ddbe532c22c4e723552b365e7d36fadfa20d77bb1d9f3dd6c74b6997f213d1a98262f938ce52178d675d264439d6a45a38cb22dc36c02a8e9c15de5d2e187d3028101fc5eb244c622b7782168608bb86f6c0666c89743b7e3f5c590be7c8442c9f3e60b1c71e95d5c03fbf9829df3406f34fb3320e7f45ce7d4db47b3d8349586c03d8963c9c83205437d3f1b6a03f0535518ac9eb53d5d62d81f042f52b9a7e12e1f804c5302a0e9c4836ef3f75de07b5b100b57ea451b3f4b344b20d84bb42e653fc02bf97100d3de008231278777cdfcc1e48fb8bdec3c01b8f1e205b3ceb6430639d41eb13b7dcd9b17d1d0bd78b79be4c471eab4556d07c0674056c022da44dc69f0d1027559ae48571b363ce69607eb67fdec77b3363719e885ecb621d2a79ccf61233e85a78e34e1e148eaa52b0648980a2f6f61f07a26fd2962f0852f8aa1dc99568bab3de99ec1a143b9d2b6eb35bab19c4a37126ed10d9634daa4d4919c8ff7d5386bd464e1e58a4129da47e008847d87cb0fc9e69b3dd6fcf6889d665fb0a341db36825f605f94836fbc43e76febf1b3a39c7ed0dbd106f75ef79e65791046d58e3681fea3ba5e09e9f14af585fa6cfb4bacd1de9bdc806178bda3d45f88563a44b0adeb46a786cf784c64f81659f87e2edcf4639e1f7bb6a3e412120e81ef4941362442b11d411e10d9d734234476dcbe5859f3e1b9440e372fb6b8e8fbff344ce99e6ad9f4d7416aa31fecfb5c5f46f3e977d8b703beb4c87229a2afdf11535a29bd06ba3b85bc7c38f198923f35ae9e6041212c7f4fbd7ccef130f3ea62dcf021659e7f7fcdb8a733bbecf60e0049b052424b6c562475c1afb17da5e990b4ffc439abd25f3c4e831824acd9fd20f02a4d34bf76816ef6b75cedb7b5850b4f0ff76b26011896581e4dcf0f1ec7f7481d1a245dc1c400a15262dd9e7be2d5cd38d671420b54cbb64162b34f5dfab365f9fdd50675555c916cf20b33b81c50781fd06485f7f90c5fa7bb01a9bee19371292dbef7a6155ba2396cfe6cd9ad6b4ddaeb62f4c458cd330e94488d688e6e08866306eb005a5e2403297f8018835faf95f0cbb8e88a0462ef5cba5bb4a79367cd5238902dcfced4be007d9e8d71d0204153ea24ef907219541172c7f7155c49b02afcdc635a715c0a3f2493c09020ad8a94f8055b2c580ccca35257a77262bb0abc9b98b4650731dd10cbb1138333c38caf5f8f73ccded04bf33352f137672a207b0b9d37e8dfb800c469e8bc4cb96d390a9c336b0f51be7b3a2352b124d87328459e6599ddbe439ff56d6cd7d7d303e6eaaf800d72b7286e0022335414e9b2c45fe64b8512fae04c7d856cb27ef04209dc1bc90777398ccef805a0240135356516c9d91baefb34fb19f5eb1151e607f83070ae8fce0b77972db5c609f0d88b9413c7f55a9578c4d889796e896b4918c5fc8f239d1b8fe6b28c7a509852f1e1cc7b6078e311ab012b3224a8dcde329426514a3ba3eaf7e63c448464ba12df59346f03b4dc69818d40ac881677844cafed8cd193b9427039a30bf6bf1c644a11dc5d6c51ec6b19c79a4921c94fd57688735f3bfe812b087f884a1d80766278d26170f5278e7cda536b172c18d86358d9b6bd6c364fec4c7c95232cf2549637432c4b21f09cc042540a8260342045bdb00b7c960ab9f5d9f7fb33810be03828f79d1d831e1c1550262cf121b1c60d63db1b5457d31e2e03d9cea050a80e96ad50b8779ea9d0c1bbdde30dab78e4071dc12f483c777c00ecafbe77564cd326ee88b43805cf2ae227d7735885486c17f2243e3289ae7a61e49d90133bc5bd702241fc2244e50fd5a48d9950aa3a6bd2cac68259c5f113af433079bfeeb777a9bedd281d7951296e80610fbd14522906239dd573d5494a4ae8ea874603c02cbed3b2f20f5aac60c7f1ec3f15a53ba7b269b1386982776d8f899f13ad80c312a1c49840f65ba129a76dc6c03fce78b9100c3c5e653708de6234b7749f9b03774c7ee22f7cd6ceb9ee2e7507b30d83c99fb752073f39e5654e2c2edb88e562f96b6227f79a141da9e70c1e0364e937204487ba4584566542f00f4a9c9cf25be77937deeb3dd77908e43ef1a92b2c5f66d35000b7e7993090ac8b30d16b88b31b0abf172e35674770b898b6011c351639a9d2d2d6e65f30040d44c887e721e08963488acacdc885416630aaadeee537270b7db4e9d04d7ff70cd10c1672fff071e71cf0b43d3e6f14de1f866201d2e1e96768fa97381e4db1ba92c290171f2b0f3e8c50f1c237fdc4205dab5e69d7530f3e584b493ea4e037265990274522b212384875f8ab9cf5f8b23b4a9106940cab47706a8b55c4efdf165bba10971a7de73132aba142cc958328f5d34d9a3bd72dd3842e2054b9029f19ec9a6197f892ece9e70fc0a8bdec276936706612c69e11ea33601e229b0349aba6ef48f14855c416736d783d678030ac708392247cee145a4241bc58911cb192d142dc9be8a0f136c25387c651a4f46d2c39ebce8c31ce5f93ee323755286f7f71e28b0c269cea4f52a2dd9e39795155cc8ad23c9328a8d0483ce655f4ac6d792228deeacae98f4b8e8be72461285e1982fcb91d2e0bdff49bb667222de662f9759c916a98164bd0860290946f0bc21e9892b218db1c07a60c6eaf8720a57e5c6bb9067bb70e5a7b3a60776815645d1b2706abfc1a71b0cf122e5cd1b22eb39210c3cbb1b7160c052218da429170ef4e6985741658af6c29504813996460daec9a7635a58bdb2dff502573fba33e1ab6b2cedebe6358851219d2303f3685ceffa12bcddf185965945823bd2818c4ba6853cf6c215b224979b36ccd99f1146427f00ff4e240b20fb75e34bd238fd9cc896b94bb7dd31a6e2db8ec3a280118be04a719600d9ecaaed19682336559114c550cd4a693f72d2af45bbd6be447081e756177c644ff32c33a1f37eb1ac095df3466243cf17f13c23ceadcfa58f86e7908d0c3698e2fa3d602d3f131c335637041f5cb51891d3042d6e5a58ff1616b5e10c00a961880655afef5aa23b93a945699180d213ec3a8f8ebc7eec82a5782ae91c1afb3e6394f016ca7c8b9c377a1d1ba5a0b8804d5c52fe4ce8ee708d82952e7521d3d027beffc80fb1eb1ad68f5c0a7ae8c76966195f054234eacf329d469ba49d846fbab4f8b09831d5d0ef4a1dc02de31207b19d1034258a07df433ad00015421ac3b6eef41a7f3e1e71f1a7155f989b5c7820b3c079c70ab11feac338e8fc2b849c26658476a5a3f65256cb7a4525e0c8ab24825cccb3f0a3cf561d8821a2e5166b53545f72b7d94b1543e5b286564ccb298cf50919c807c5e310c48b6966f77a60c574d739d6fe951480a8956fb8af088c229dd7e50aca9e778504bb2501d516a02b95e0338068486f629d19420a92503f22e8868aa54e38cd04031d2fd4c12c9900fb92dbcd81bfc9d89bab769299e9224c19012461e17c9b947d7035e3d1b2e92d7d6e056a490ea3253b80a5fe2e292776833c57ca299e34fd09a5cd3603ab38366ee2ac0685b691c71cebe4eaa5329f25e51d3eea20e9e6bca5d1310c327ff1d02e8599277ed02d4dc415d7108e9502f30ea69a60c82e24ba5a85304d2f345496be431b17db3643325dbd062c8940298d17e01a93402d84a84db5131d187dc6e1eae0e8e4b38ca824c0c02bb596afd08ca8134b56745813c4ab2953b57fa4a40048d820bf00de71fde89a97e55dc54b92acb4c187904ae99eb38db5214793f6373cccfa408822f99987cf52bf0ad22bd1affe72ab887a6a12eb1e3a65fd5a7631a274c548c436562d551a6a6c78671f353e30268fcfa227ec8fd8eadaa639e5fd9fed608b842d740ea33c3f1351a131906890e1f87c318905e67a825609c8c1737428b856dd59076f16e0a70bf16a64ff2a25dc81e1824ca9f79fa25d03dd42f4632ce1ee78c17fdeb51d1cceebbb3d21ab3740f8f95b4fece9875bf757070c00d6bc206fba0c64feac479f6a32b4a5291b7160f497d6e38899ebad4b72dec2145848d8d72a7a56ab458864f4ffbea24fdee3b8e27e3c5c1b3319adc5bd1d21cb9308042b5009d381622c1957082827865fb703ff634761d4438f347c728ab35271b0104fa81108f4d3b5b7de41be478bdb4e2859169cc0ef521f02b1667587b166954efd403beaeb3d25a6736e72f3d3aff0810ebe27f02a263a202d3eabc374b43b7f6d032cc6a4a2ffbe6fcabf7ec2c2bf8e4231f8b241638423ff80137f6f88c867db542d2a8feff496ba1b2286e0d4f3f5ffa1341638f96e2a272e4d70edb20a8b02ff726b33dcb91221261d95db87895ce34aca837aa6de91d7dc5d8605debf4e9fb2412ff4aa3c74e75d19780599f5601f69252ab6cf55f7638b84032296ee5338e39b4acd8b87e92d32eeaef2aadea01b4b3a3282e78fcc9b7c1f83b4c6292907469c20f54da236687fbfff368c987acb99004203384ea1fcdd580bb9c5f33ec7f76f9d88cd68461ac80dcb6666c54401aacf38faed6b6542f5390728bc7389229e4671197d8715855042e10e9f9e7ff33683c843e355796c5c20718894c1f2650cf10b49edac713c20c59fe392dfc1ffe72d244dc7371125f0c5cb8c8379ec877d7e2c3f85af58a49220ff1a1e9067ab91be37c5b53b8943c3cd5e097055f5a781e7b81ffe977f27de137d2d7c80030fd768f40f312ddbc2177efbb69ea1b65a1b6917b9bdf1900506f80788ec605171e2b98b64cf9f46e0f60063e7804c413d73dc3f1e5675436edb27949cb72b4a29a2f21e5b172e4c1cdf261eaa7314726084c96af955197d7917317e40e9b6c4b85860cf31221b1eb6f8a90f6bd0cf62c71f5fea704602de5c9676449ed5103b33fcf4429993144ca13ece5b8f102b28f160875f3daab35a2ffb169d52131ad4a34fb695bc54ff5c1e76f49b602768869b8836b2b0833a83a56fa7a0be5064ae62d6ec98220e7143e4e9931de6630263607099e9f35b15272377cd23e060a4a0b5be468202fa08776a05d14a85bfa01114da5b97bb701d9ef5e66c75bd863bb194be2da733d907bfc916451df3214d33a2ef874629c8e627c7ffc24631ae130fd837706f5b972dd51708f5c9905f7d8bc704ac1a5953d93f935a7bb6c1e0d667596f06c0d47ccacf5ff2e751e436be514bc48d761df6dbcb0381ef8eafc98da4f0a272f4ecfb48b17ec4e0c52b6ad1bcbc7ccc207237458f583396c77bf6498de67371dd6fa1d44e66182c7d3fa101fdcd56da71140e08d37057c999e35138d77a98b18f4bf28592c8a6c9f1cbb6e90298d7de50c7e179498b3db597468bdef92070a615c03289faaa5b5f496937c25da9749ef1e200cf3771564ec01c0973ef4b999a5aedf689743c0a7da8ff62ca481d4770e824b11a0653f9ac63fe00ac4f25292294c4a25aab53541883ede5b156904c7a2da84571984550e75716b8bff45c0897fc37bd8b376d4a36883dc82d2eb323d1d389af14b6f8bd92780c9321e091820d72e10b0cb5e118ef26bc97359abf0cb22767d82ea72a8c5a11a423ff79e4e8f8fabed3eec12c4a2b0811cdce2d9d87f2e69e740bc68617e07be600aefba5f43e3821221f8a33af99fd228d931abdd6df84a9f49b495064223735661e2adcd5e372523a15643a72568ee7b379d436daa3014a316323d6640be03fa29e9df755f536799130225a2e88cc3584adecbfd09cc42913834b609bb51e386f39c0ba8e1d6b64994b8827bedae275540950dbd170991c0f54624c199fa6fe225f46683b9d0e396581c247f9724a88f2053ed8ce816335fed429c99fdb0ac4a9e05228f2a31f07f8575344dd784fad2bfc32d84d91e241bd4b2f68503f1fcd42d79d501af1df446ff63ae6541523091a14d543761b4ff9a6c48621a2371e3806c0727bbf17b3081588c335b9e7c709aea41b34774cd0b4cdcc71d8981ee923161b178ba4a901826db05fdb05191073dfeb7dfa92bd59cae7de7107e3d8f9b20e47a50e29b1ecca16f0067be01fb7dbb7404228bd29770af6e0533375f614f6eb5e20f07107827821c7b328b29cf242a6e560c323ce8ac4909a4775e5fb5f3ea5de5731f33869d285095230e3b44c24b51510b6e70e29764a335de64ef5d81c38bc0bcfa934aab245e27d9b0096bb74929830c07a355e0a6309bc47b8d00d45eef3ab19e7193afa7fc4e4baed524f1a6f094ab6e9e4c8be08f2f32f2d163c25ef35d21ee34c993a9844eea950633bea58082fa9c4db2106914f39769e6a438e276a1160a53dc95585b322dc35332b9d37afcb5cf8f36ed6b1cc41266ecbf2c98ac8a2eaa3ed874206631ed172cf93b7b0a39f162415b820ca0e2e57df0d304e687694f6bb73bf41e4c639ccee772e03396c24541bfc62f250a49478cbf4b8c7a1de9dd4c60031d4ebe2b0e6eaa4530a4e29ad5fc2c8dde36bc3435dead65d136c0c83786b3aa78d81e631fe6ece8fa67f51b878f5a553a86876c24701dddb53f46447bee1483b293fd61ef77edf150432ce966c37101bdef2ec11ec648d75a91ed10b4cb35116d072dcc0b3b14d503b1ae1bdf2e5331cc4282652aab848e4327b3dd8f0c720f09b8e53beeed2357c201d6c0e7eb839b96fb51265bb2b9f674c03158ca6f03e3be8c145b6f1af6f9894e2cf7a505a2034ad85da7a344b64a472bd460b31e50dd1217589a58adf11f94bd46b6ec740c2706b263811839bae122b45c59402de026e468c3a17b5e81d8223a6d276dc30f4d033dd8880da9389ea6210c3d3cdb7cee5adc38ec07d3231f4563a40b66921dc8a12b3c265c3693a1c6cb21db8f3b8f3beb106d553436300a784d42df6591b25f9653085a17a1c8f1898ffc6559bcd594074d7e6e076c3950288dc83d78d538f3da83f4adbcb6066340b6a3673443db9a68031d52d3e57f29e585600952353078602589e676d946edd73e315aa0b0caabd4da2999ef8992df86812b6c717d9e4bb1eeae0be770cfa19736960c2787c2056496639b4a7d084efee51ea6fdf0e1b37cf6f8621a70ecd5753bb956e7c3a2a8ff8402266f52abcd33f2fd7fb80bb5c44ff3f31da10a5194f2248d92d809c5da2fe76b5a4a1d779d314af8fcf46eb65855299385f74d2736b21e9077a7565c94d8290eca9d21c7f86eda8fd259f2022503b86b86521565e3d8ee68e38ee247d525caca28672776bd09196d879d6a57c961e18655a3a7557496cec05bc73553cd7cd11cd209066dfc2496746b49540655a26059e2d1fde247c2aace4b99bdb661a479dcb808df66e78ffcecb95602ce3e0fe20d1b846c8bbc6af8d2ab485a71da37b9751148ba06a63b06b433e512d6d29c9174203e8f43e6285f832a981d98575a1912555e6f5423344ec9eddf7d845c6c83efe63928929e7d43124a745e4ab0c40e2cc6367e6ea9e7782a921c179195d7aea50a492f6bda6986b7abd82a698b15be275a191bebf7044f379fb2b2518eaa83ace73836ec746fca0f43cdb6877e03bfd15579843fccd069c5012113d5e889eb2507bdb031286512fa9ff85f5e508dd0076bf9900a43f199a4c66e48d603a8ca1e98aec4937f1cf2d54ec4fd331e526ec0d8de050dde90798dcfb2d9963984db6ae08405d10481dd9d2585080eeb887a9cbfdd4ee62a1d5ab2bab73cb35b1c7ddbd9f60d17949e2ce7ddcae33f626f85afdc1f7bc4bb97512622aed8809e1f8d85ddce297394874fda6bdc029b31304e960f5385809c28b43794bfe7353bc5a8c98419b57c66c7cfd9c0cc31bfa7a5c7a0ca34431d4050734b096b215550703c548588188bffb41983b589131179feb85abfcc8541929d47e467d4cb14fcb384c99c9464bdce6d5d74c324efd7c6298c21340103815e64e3e031a29c35736fb929c634d2ebac08995951846467d6c63c671e912d6ab63855857bbecc677ef1517a15efbb454e165705489fcc642f070bd0df0edbb9fc74728e2a9a3c1014c728fa87a290c12b2d699fb3868309b64beb6f8958a5a618a32563a40b22b048bd6c2ee9276be1804ace2b348c106050bc89cbec197dd72fb1258714542c7ee0c1a8232e96eaf7afed85b9363c3587fa65bd8100696e05591bbc145051546f1b8d62a357786e862bde6db7f1ed0d3891fb5ffb6af29ff20bb35f2ee72515882fc8b44b42a5e673f89f27997623b09b90c1f04b637e1bb5c416bd1bdd6e4b67c0b73d23e09adeb9530e2b1d6ea7e99782b900104ecc515cb7c7dea5efc8c28ca8f1bde2ba19943ac647b82795e03b385077c608f48d1b28d971ff39469dd91287bc30d88c2153c82da3e01a6b9a4e6c2b8033720180146d44d68760be6a51a99124a9d6bdc555edb2a8c8a030178be005f3d7fa100a8a335e0f0c1a1f8e61b40f0eda23076c67141811e816d42c0b4ebdf014b7271300d12be087ef121d3e9fb7824eea83161688b36e07629592767042b145dd98c895e4ad1ca03bbdeefa98752044b6186049369f9429a923ff7b18fbd0cf65fd2337604ac2fb5c3ffa10cd60bb997bd654656ec906e10a9e626dfcc439faa1a68255c758bab4e6e6dac4560b9e4dfc17f75273d662fa7bf2060fa29639b5af2b60909708cbfbe6c9d443643f5857ff1de016430b46115554ea9be3e43d5b507b2d18d7a09f5095ac9c17510db175d66f65581dc882aaf8964e5b6bfb1c000a7014132aaa5eb34f90050989c3b14d48916c6fc9a725df1501c3f1b1bf0667b51dd2dd66c6dcaacf837beee2373c2373711ead178301f3a5ec476cc38a6bd3e391d4dbc7d8e7c9d2ef7bc08c9b7928612745873cde25ae9a21f4449941a0a3af83976b8ecdac7d79be80619da6776c2c31a92c775fd560551588a7a952162bab08f1695e9bd236b003d608d2a26e0b7e6266bde2b38dc0b97ecad65c626bffcc84fe18257831388c74390de6c5e60d45b4313278d24d13c9d9c49be384d0ca9912e823a340e25c88856e167ebbf1ae05bfacc00ce0a24c31f918416bebf1ab96660165ede852e688f6d7e65c6b9bf2d7d342c3486d288c9415e31643e6a0ceaf1b17caca1202fb850a218a2b1bc917a10caff49d493eb803daaf395dba6736572f1f84dd0688dfa510e8d14d713dba5158564745209792d6d0b2a38ade3185723becc1cf0dab5ea83550f44445cda696cd47d1592a2f2e0ed17c53734ce5f899a5315f883a315cfa3d303f60c22acdb99fdc4cd7574e7dd02cc0d0b2427bf18fea810009b0de229d7890bd6b1e5826ffc80acab2ed0e0e98ab9c1751460d944a1f63191b9326d642a2446b93785bce20bb20d35634f428ed79f99645626f969cd18d735fa803c9d6412793ca2577bdcc100d824120ed65083c02f19d0e46605195b45432578eecc5c2e6a4f3545c2458d82d66c8f0bbb10d83903843ee1a9a70486c561a8bd20570060801ab6efe4fd4de19582862423bc125a6a69b40c1bd8dfa4cd369cf8e1f34f378b445c924025334be5b39e7bfbcf13b2b30e5bfda4a4caee077366a41fbeb558c48d244d7ba52434aae2261e61b07e1529f3cb48eda3675ac5323a26010d1e9668ecc6593b8d6a7d3907d182537976e6f9c15c0ebf5af1366182a5e7a5f6ebed782acf051bb6ba0e3da72a2f622780c8e513654bf86fc9049dc047abc689c4b143fc1b8711e6a174f63ad2fe089226b981cae20ace207f6cc73cf893fc0d1cc86e5de63acecdc7d346a46a0a1373f10418522c88d509407c568f2d388b79b43a865c80fa65a895ad78a32b968970e7bf3647df85010557f550b23e5656bcd0d0fba65298df5b3ecc79f0a61f2dcc569de59c9c6ae0b9c5451b4ac09651845540271d951fd0c0a4a7bf480af2f8a6ff13465e99f3782ea7756f94252be54adda3d10b7c9e01e4a915c469e9d9481be21a1060702c8cc6ddd778bbd26416d1935778466f79958ecb27204b46a30859d00a13c405971786be0666f8045e57e1544c9d1b9743d4fb2d208e993dedbf7f90ca29b65f6436f87f77a07680435ae910bc0fca7efe2afe21b26fd72ddb2f32536edffedd2fb8fa8b0df6fd03f2197ba0889012fd30be4ea824126b6a1b334e1164c8209b1764033a4cf741b5375374af43d0704a39b8eef8491234501173d04766acdcc98c21a1ceb12aa3b7dcc4f42c4d1ed21ccd891ebfad22924d12ff7c4f2d656795796c13d864657e1a094d15702792f0cd949f7b537b18e1bafbbed4d8854a4c379b296e3fcc578e955d0430923c1236688a7c0a71b975f83fb6a6b133c876f2bcb459463011dade55db29ea6a74397d72440088edc6dc307019eabc911f61abe2b1e5697995f167737387a0a5f02c19a2af5558b5e7d3f61af2534c77fa9904b480969b7b171d851b83b5c335f1bf7357fb2b819fe0bf533f9c8c63b9420981446abc1456939e6128215203ffabab6d4bdd6b138d5cf3c790281775014593ce59ebd850f1275b9805a6f89efcb2f04d466fe81cbbca29a80f814e518e0d5a2fd326883be56a36c1b25ad8dd1c2c876b3190bf7a1ea5482cc3678cc30bdba8f4e133df6b6be6a437e174800c46c8a5a2b0a7fc31c6cfda4210d87bf311270dda4237c1b84ee8fb9e89908d93cd945b60159f36f8e46709b9040cab5f73ac2bef4120b982ba5491ec79a5834d52bbbf251c0dfca4d05d8bb32b2ca87f913173a9f83586a675669761c2285f3425e4f3318b3482c9144f9a52e3bb6f6912cba31e72ebfea55793f1b3cdb53a06b46af0f1ed7f522d1989852da518d6f6ba8ce69c0358b7833a65573bdb4ff57a21f0cb7131e2c76b2c564c3c7723244c2cf9ad0768af3a5f44cd01cb3df4c0291c12996202f7642f0fdcc422b9824cc858abd28585dcaada3c4ad9b691e10a6363a5ed4ca32c7cb1578d3ba4b5aba95faa5429579f169779e8ea51bdac5ea838bb8eda8a4e19c7760dd1454aa22dfede72c6efc2a2a20eccf0ec39447a26a85266510a37a865f7227120b885b30f7123c405638f958653a98ef8470bc3bac9ad6fd8ffb132a07621ff596ebcfbd5078a48adc38ca9b6e9e482151cdf67f01306d5fbff43e1766fffe1543bf77ca740ba445a31d79dae8f59b5fe64b2b4a9acfb62141f8d773d253ccd48d4a5bc5709d2c8b276d2707b8d49ba808df460dd0654472f00851b034f4b758a0cf503edc2dbe5b368f0420c11d1237d777ae5161aff1b8bc44314ccb232589daf73b5c36193dec8c71e7793e87a08538f1205908c6a0f2c745f15c14ff3e3cc151815775c21f95fe988b213d4636ed86441a5ed9f1c36dcdd083fbb964ead54e078601efd51328f3b9c5de3539b2248ffe20a4e80c329b5d358dc5b8e66dc23b4ac1fc765f20d867f956b0b100e6925ac316538d7d31b6e98f4ff21021b735069d609947d7e876e6ae4365c651974163ff7a6720a1f18b29b65ea6b7101be278ca0f49c5846acd31d72f651dd551ed90b01010c18ca82605290e90c23754421f572df2a09884c997ba0d4f85b42af2408135e1a353ff753c3218da6d9015d243393f4f0927235061d258430606339ab87adec96dc572dc8535e2c666c489d70cae71432ed1c61cc6e927f14bdd1f92404cf66989918faf97eaad80828687f764cbb3fdce01266e535a129f068cef9c94f5aa5a1dd620a9f9efedd4dfff382bea9ba145fed685b01dfd338921edf2dd9af2bf6978bce21b85186c9bfc72264bbe72c0a62da8db375f1b167f86594bd4fd307307cffd41e36abbb9f8c7ff985a0227577d135340810fb0ce35529c4d086ace6b0cc14c4e37a0c69984fa9648b495ed73e35c0ea73a0cdaa84f367973ee","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
