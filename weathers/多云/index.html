<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5996dd27e3185c45bf9e6a7e2439bb33f56c62a5d4189ec337ea5c446c45eaaf195f47034cdfb4610e828cd109aa2bb5acff8c65bc311579466e581594727f02cb17d2e328a26dad9d4f7f12b1b917858c97b73074620c8b93b16a3b4cb7c010b0e00afe0cfa9a15936b9ca5e9343df8562b7a6df9046040a700b5b419c1806af773886e59a8b295a42e5594264f0ee58a6a1cad4b607a59523948af98ddbddaf32170eb3d3b4002aa388ba1dc3485e362b515ba24241abac8871dc0301bfe183121ea0ce15e47e65f635640abb26a8ba18629e4eab6a02af2756ade9a7866f43945d21c2c77c70e2ae3ec66b0a873c0821b92a935b2b23aa73d61c73c7db1357834951656b65003b5aae6c0a55fefd86a2ba933a659e6ba73f033c43a5469a40ed2411cdcb2c61157d924808602cfae56210468d02e97c5a3af8a56285400f6bd6b740d4c14d67c38581a9c5ffc538f17f84065d874674608b5677d02a2dc7277b2ef0cc47c84d5b9db5c9c5a31a63df3416bdb978794db9a7ccb44e7929b8b3bbdc72886cbc5e82521ad273ec0f4de59367d0d9af07623e0e2dabc979fe23bec0aaddb6c63f30a7eb7fee263b9f67167116e2fa1abcbb599d8ca451cdb89781c57ed3bd38e9812a7397b08b05084762268fd76c38e2368a4209fbf1abd7c2e6b172e7dce861058768d842d55a7ad7e5c2a118a06ded1dd434cae6e9e331d19dd0ddab89bdb6f1f33a1f2f07ed5935a40d5ba8fe3fdf6a2e27563dbedbf752942f1a971a47420ff7e48a0a80d2f4b44cdeb57321951f09c5dcac5ed0f4ae50f75e8ed53c2b589a860ace9d632dbc6baeec2d720635a161eaece179c0e3b5a1669352396f8f995bd5d3e0d8e329458f25fb546e0dd850aa729e990f5aa52ba56edeba12dea85c82ed5ebc879376654b74371d429642d183808d71a0249e2e516b7dd0168d85d2de561a5875132edfc8393eaf3dcdec0bf17edf2c2db5b46788fdad30222baa7ea4ce045ada0f044ac0a670052f7a726beb7c1c1dae0794e14cb469f67ca6d0c1b635caea63e57c183a80adbc2f57a6844209f3a5db06712c4c692e36791c8d84dc7fa0211f1dbcdecd7a7b73e1c2a851983fd2aaf43fe898c75f479c63ea187d55ff212399d2c75c76847aa12ac36bdff2ecb20ebcd2579a57c3448b4ce8b70150470d591a26cd194be04fc0eaa69f93e4749e4ab498d2459285ecf1f697f68ac23e8b5a8add1005c60b4b39b0d24828636e9431b36b58cbe100b76b44f82144adf900d36c78eab6b8ed3385209edec0b71fdf1a49d274f8f85c0147a279971edb16d791215993122937ba43498ef47ffdab00c0b8cee17ea43bd3b2f6938d09cbed3aeb945c1d2dc4f109d91e7caf7c741dd5711ce9648f5b74d96d9766deee38307d0d8f2afff7f06222486f5daf464b6f8e42587f8a17dd018070bf553ebc724f6f8d7556d8bc0a2db49cb9761e10adda0e2b7d4ffbcf29112c5b5a3403150f5658fc1f9f7873c10dee21043af4910babb88b861927ce265d3029030771e8691eca73a04dd8031b69216f6a810fe8948ca62defa5ab57bdd998699345f0216d026753a96fc2146bea0e5612fdfa4317cb6e2792c39b80cba486b2777ce916e241b19d002afc0a2606b1df557aebdda199dbb4be3d89b8e30549532a04577296ef9975c0c596d117b02b3356f59cac9ed751741ec0cd0750d980e331619b8530d6ed5732aa9e5474defce0de33200d45d2a36e9d7d4a76016a9fe22f4336c4e46316601d750099ea8b565e4ee95b42506679650d7af2412039d900303f52e2ad8762b422314894b830ead4c88c333a8078546a770d58182ba5f1130d95d893fd4509b235b0ed19d7a2da9c31361f1a6076c99eaaf6f0d49d9a35bb306f750cbfd86774ca5a73650e98168a055367526b0b18e2dc9e1028217576a788b663e6af5ceb808a280d88d64817fe5ca2437ecf65728261cfa0237c728659f5f0fd85d0fdd39c626662cbe3eb7ba18560669f1d4a4c4e2fde39a1d8625602460268740921c9b01409918982d690595362f8b6cd9a09f545a3917095be25ed896d0e66cb368824e97e3abb0e8f5d60d1c66d8add3bfddf1309060cf18131556035829df84eb3eca66f05fe8c46e14cfc961070de80572c986b45502ac1991a748bce4a6edbe1b66dfe9d3804afb3d17429106e818317baea2741e6b7b710465d7fedf893dbc3db559f3aac73e7a4f14240feba905fad0eeb6cfa38361716a616b63e18d1744649f5414c7f66616608270ef66988e78dbc7ff27817f995563ae32854dd8f4240f4c0366b742576520b888eb6bccc946522b3c85ba628bb5e4dcd2147d4c086b626ef5c303187d11d00ab0c3507e83520d2817ea9442025848cc5046e2b498fd8eeddcab11a1f180d578193d0eb9833b49028c5f958f340ee90c3cbc4f036ddfc2a2c0538bf39e6ca17a0562890bfa51a0fe909c96aa036eb3f03f485a30ad1a28129c9000f8f6b1476c2e5abc3d8d2eec1467be1762a23a7305e98ea561a9517e2f2165aea8e8d51b127d1f129bf92731dcc7dfac3dfca37ffc4ccd688d65be398aaedf1d495603d0f994d50e28c070a37deac992043538dc750546b40762c486fe090c729378bfc925df444052a99ed3f0d2fabbc15393af98a624ea23f7f0eeac13184ec12c596e39b18a761ed29ac51023946343acf18dba56c56b0b26390ae6ddc627405925225b6a24c88ae2f0b38c5ae9cf1402e606cc496ca8f1cb12bfdf3286f6363a73df10496072e9a5390afb7b65da8ebe944b875621abad39f7f1d1b1cc3cdcff2f6130fe100bb08e6f86f5fbba2c1375dc8ce448515f879e3095581bd1a51fa04da613bec95697d33b670470d897c113dba031121b73218edc9872d6049e9cf1c0c374ebe4cd5892d1b6561f9b5fae3ad75a0522bdbe1e01311afd4a6a38b1f522068541f4d3bf744975461d5f120802700c651ed94c9547f60a74e8d64af051755abcb16477ac8828082f257cd10419472cb3486959f50ecfd3c02b0ac8773d92e2214d8e2ebcbc2fe1a1f072a1c2557f0726a224a8fadfc98a1666bae28871ac44beec698029d7c68ac8bf7831d544e5c7598fb51a6c267532793043e1acb32306bf3ce6e067341893f961d396e74581eb0ce258e2e762df775b0dda08b2b70c52555e987c6535c5f4b030037598dd436b291f5d14e644aa3f1c134eb152a4aae5ff4244bf0bf8d9bca8fb8d8b7e1be00324f29ab9709097e189a7bfc85ab4fd6b458531331c65550eac5e4e72c5dd31031d567058eb7501b616889c40d32e05bd5ce56c48a804c7588192c0a0a6124e3bab508b822482fa02ffe4761d968b13a1fe739ebde2be408ad3b69273bad98b000ef3c608b5cd32620d862e899bc1037e503a86b3252f1ac3875c7e768c074415de92fff6cca51a79058d8d47be57b911031571f95efaea8687d0cdf21804f0b56c9161ca02ca74306b93587c4bf40a20a92b7a5bc00d1b7adf0c1fd865bad66ef19668b620f6891e6da7aba276d1b60d16c8913b656d8abcdf2d75cacfa57b57b44a9bbedab6401c3680b00d0e27e76596007001fdf6957a374d419d938f86c67c76d27fc959a93a0251ee1403202b183457a63b6c28db51b00cecaedd42e5d8e6bce850d0f73797950441686a92141deea40dac62e10ba4a3dbd075c3fe634e01fb50fa32009b4852d83ba51170ac5740cd83011a2bc56e3f00c86fe679d05fa50a57328a997d0b72eb6e5f3d5b0efae1cbeb3086b51dcf9981d10bcc86dce4eb5e2c1eb64ce14fea3276839a9d929ec015978ee096df65eb3ee24556724b54455630804a108a6cbd57cfee4874f96c5b6f951aa14288eab430db17acb0953ed84690040c602da73dc7fa39e06cfd4de3aa9e433a0e697c6555c96f08df829af87d8d9eb4056cf587c079e0d7d96c45721a843c1cb99a4491e9f853bed47bdba8138819ed11ddebeb6d1ae896ce035e52ae9f0cc61b30bcf97e5c73ec8e6c759cf659f7b7dfb1793c23674b32f5f276a7cfe1ec0e4eba9b13777fd76b1eee5409ac1b9b2e07930a4b8fd9620627436e00c44df584612a18c6a0f13671b621daf6c73812bcad46c2286b64e160f99c5839e968da8ede0067fa52419f8f227780ba76378ad03956cb2bbfa7492184a37ae243071fc1bc2ee7a428a9f9d1bbbbe55dff4c23501f1560e85b016fee13bdc10d9a30782c380b1b8aafb44f14c44e7a62e14aadaba518ea0188c5e4d59462163f9f3fe96dee0fd35f78c3992d8d0c32653a482c19e72e1ed9f76032722ac617d01f71339959ac47fc8044c91867972187537e4d7b6ed889a4653b4ef3b82deb1d221a0103cae61b51999758e2e7b89a1908f5d4d897164a638316eadeb0c970f71c3c115a359694255f066a86c14c72f7635e7da0e894b4bd6c80006d83113893a0c088b4a6c5ef38b924eff056d7051fdabbeb402c4592d3a3fee96a59e821e82768d80ecaed1baa1a188dd03376f7b365f91639661a9f6e593417017009bcdd34207352ea6201e263fc96e4cee89b6d0608e1547231b71b14683c4275fa3c9beb5aeeee4748a2e7008861fd1b10fcffc28b1de973c1121ab76f9143bbd80dda7c256bb5aeb03c90c1474802f29919d7c57f2b5c9d4530647bea754ec46c9a6075f5a031c587673c0229d87da980ad128c3f9d110ccc9043851aeb2e5b8e679e4d223b6ea5a80d52d2ba57bd48705e2dd558a0a746b869fbe293fe3ea3830642362769611878dce485db04a7e48d449b5ed7af441b8ac0e02c74c0f952736c68e10ebac429861a4c3050f1c324d7022db7356db8c451b8ea85da20281e658bfd62ed5434d23f85032294547d1f9255abbee10b206e349491f2850838b142d8d20772652c9b55c09c5861beea5c136479ad0e18c6fbd76ea78fc89f198a5aa24fbd90bcaf5a2474061da80884bb1378461f59f3bc9d5b2146f59c2cd3aba822e67786b8ff455079ef400cfad3a28552b33ad4310ab65d52d87fc05a47af02ab9c92a9e15d14733d8a66c1cdf607191f1a0cc0cdcf78ebcaac3659afb150bc0b9b1cdcd178e4c1a3c0d9e428e7575010e1b02931354b7b91b95d95d70d9553794c4ec7b2870ac10de20518df7d8aff7acbdb10375ddba1d152815d8628e5fdde3a5fc557f3c3fe75bd1468a7c06a06438588cba1f738a3e6c93fd7f5257f15d4b1aa0f8ceed8c8ce31a31ec14b945560d65bbf9fdfd1626e834fc2ba4d39cd464e9e89ea96641a8102bc231b2bfe02ead17b64495592f3bf04f8b793a8935da337823a1a7602536eb4ad8527dfb1ad48cf67499f0c2e1d8d443ca80df23b3b8d8d24df02808373d4f49b7bbd9d55c24da230d78c471358839d8f6816cf9f08a869f1790af1f51f813f239e5c297b84c9fff589ecd49e91b2f8a4512773ff568a6e93fa96b05b615c28b5e0dc8fdffa51350264eaee26fc23d3addf41db06d5f50937da5b869108efcb5b92beff68c793c18ec6604f00a4cd0eca7e623c69d9a6e6450a3f8c3ab0445f8e9b1b91d0ee00c315e566ce02c7d49d5288396fb8d2f54eb009447cb720e37a3d159dbc3174973718397f9c9e7700d26cb43ffd432e2fe7680cb14acd062bf0a53600d05d0185de70317434f6558e038b99fc14e731ec8123a03c95d3be3be3efcbb2cb1968e6cd34bd1bee8619c38c4fce5b0ef982de46fa390a9581e8977fd4fc9bec53d51493120e0ef48579dc6d9c2445626b3a4d344870fc9a5b42b9ccd602e983611338d7a5a40f7e2212bd7b6cc3c783c80b42981a38fab845acc93f6971c89c279990aa845f3c764f4376e49d9a03d327e9ec71fa6d7785e361e7480383e4805440e97ea4626e166c23ec631cabc0da9086b6b1708e83d40b42403c36ab0f9c6b9f827b51a1c8d47311c3cb0e566eaa50edaf4b84f59acf672939d37857a358a7b4e41e19b08e9293447899b07e431e40ad64f34bf64d4a4dccba47980f3e5e5b56ded3e4f373db9278104beadfddcf22d56deb335277c17a5a37236f6443ca54972da572cd32af999029cbfeecf10b8665d565e05e4faae7f70c50bfc7be113f89c40c3eb5f9820224157a66c02189913dd52d88d34702deecebedb0efdaa64f4610759c31c0ef394d44e6ac37eedb6e416866dcf1f22ee2715ea2e77c30fd8662ee5a375dd2155b527a5271012cad768139cc0b0d393e158f1b8c86e290bc784d67fb7fa8ad5183b544c5c255386105510cc3d4e399af7f0e52cc4a547bff8d228771cbf67daa9b617682898a4a06af6dbda9a9c6262db7ab072617b6159fee63eca0e4b8945e0158ae890e721f43dcd8be73c9b4fc1306e14959e9b4a090c5d7f717cc4e518dcda1fbc4e70e93e92a5b39374ce1ec518a8586b01aa73e502da14dac782c87da32521bfbddc2ea219253e45600bd018321de2371c2cddf586deeff2790354ab1e5bd5709d81059dcbb0c854d2c1942b48b814ab093c9c9501ddec60e28218305857083896e1b1379f1748856acc19ab4d61e0bf1add74d23f6c8e350f81bae3949258d0c64ca4a88322363e4ca4598f94f3f7aabf5580703eb2ed8997f4b6719311249de2f3f353ece0924315ed587d26eafbf7aabbcd8c363b0dc3d81f1ea10131e92668909305c0a881beb5a979d7358192665f4a3c4509b27daca4ad00914360261cb5cc6b4294c82cb22bcb1bda61dbf4360238986af8b465c2a444187aae75f31cc3130db6b690d1b1ad615fc3cf0eafb32d20910973473a05196e6388c10b73fc1070c6cb51e7e0da2ace3fea43b2c9837da210eea05328ee46623c73a866722afba3b730420690d9e6509bbf133be3fb5d959f6cef4f09c298031528754c76bee32526769729781b984b6f0971e73261d23e81d9000f1570462b5a67bb8c849cc127c12eb910718c4196c97fdeb70c640deddd3118b40726b912dcb0d82c690bb13ef5d13b385034a90765ab274fcde1a9d5808b482e2d5fbd0f4020e3a6620ddf7c59586db89dfa214c44556ddb74712ca895b33372c4ab983dbf1a00632ce39952f3608d44fe90b83bcbffc2298844e370a2e622737f19ee13d5ad6a9b44e70e866ce2ea5866162ae77f294ba7848313eba779f1a04cbef797666b7bcb823e5f6a6e917c4e4a235d6c9b06a1acfa2585353d2ab86e40b26c3959d5cc8b75e898e61fecfbec95d5ee6d535006e495e089b9c2df9ed8649ef96aa11f968e006ca77aba3d7bc6b12724555bf9f43b48f3fcbeb6d9a5d70b22da636126b67f7f6d23856708f128e8cbafb4903964024c69cb5dc0d806d3b3244439251a8f6721a064428f11dcd073018dd26c93be0cc2539efa09a8acb6e8eca382b9ba810018448af7d555c028a743baecf956952dbb92170fa44eb99ca3f353cefbdc4cd1184836bcf797c56096a348a24d1b49ec7b50eb14a9bdc0c3c59ff2656bf99e65943c939f5092b402a8ecc96087498ea66cdbfaea7f6cf83db57994c1d0525c66edc441e911d554f86e24bf7d287eef5fba26b99590a57660310bd93898c46271ff748eecedd7e4dbaf1b0cdc9199deafafb0969f03f989a8a6a0f38ab62fe00e3f33d9f1ada6c3f7bfc3bf7162fcc0170043fb7c7c3623f7b99644524cc7d74eb29c67a7334c7cbcba87941b38ea9145d09d48c3bee80dceb7f68c3ba8900268db653da40a744716326668cbf83e7a5bd7fe833c6aa6e2211716df560c96efbba54732de78990401e4ccc0a53f5df14ed4e948860392d4ca3ac46916a541aec41c2bd4648388fab3ba68311ae74e22f645a7690758770334e0337fc1d8bc9763c4d803d2c5b15828941156cca549ac97b0a300e1e828d93882c2a977f23ab4bee1995d52342a1f5c675b5a8e29198d565facafd951804000c9150153cee7c85c42ea67daf8b7eeb19d2be2a24cd5cfa9d6d85f04130af5f5d1a5ad29e43e85343a08be57be1338a051868e6eda00c1d03cbd88f416560c644df860b1114a95d8737399fa68f0b04495a896c554789438a2c96e7352e616ddd88eb94a9e981da7089aef6d00a330832fa00f10284ec8ce302e46515fb2d1209fe173730db25c57a2e3f8d3d1ab8133851d13b2373e22cf4e9aa6259d8e97fad036b0e39cf002a7009ffea7c5f847fcb718a5fff7856c4b7a04498ac1b43f3584e74e6a89cb371cb6f51b796fa7bcffb95474dfa929bfb322365979ef59c4f09d838488d22ba816ceabd8f03917226e243bc6531b30545eed17779ca4fb75b17508ca4e49c79626ce7dfb9a2d827961139ab7375b9685ebf70b2b74e1d8ccdd73e8ee949b35c79c78a189456ee2ff11d37fb0b0796950bab6c77e69997948355250f0c6f00202af7e6580d46b54a2ee66b5926fbbb4650008dc89f6d6d12224730072e9aa308378e5cad0c75b61ccf87abf94fee77b1ddb0aee71ad8485b28effd135540ded8830353bb83d7aa8c50fb0ed5c46c2c64dca51d9831c4f75eaede9d8c7fcb6868b7af8c4bef9fdf77ff3dec8ad4ca5008084eca8963d2f4cee437b8b3d9591b8e097cd68a59085c49df10c148300837c6237cb1d55c312924b60cbff10300e71fa606575a63101ff726a1da5faf458cc2cf30224323946b3d4230c304d0dc0062890cdff872185fac4bee4cfa1df939b325d6ffddbc303ac026182dd79daee377473e8f4c04e03dd57bd25e365934bba7ae86f729b9c5e15cfc3c7a19fe1ff93da493ec96257e53e847a60b849927e0a68f0cefa5ac0b580c7248a6bd1ae6c47cc33d9dd40a15d11876d78a9066e3e6a8cf4a716ff3de1744e0c68c6dfe0593ecc07bc17870d38e4c9db32e12d15e759a40bac58297b1945c1e0198a5f744c4943cfa09364c36f2334aac799aeae92b3c666a668b753042f465530edccda95ba92d3ad531841d66d359eaf6a283b03966ed123ea8dabb3fda20c963e12f3f4f710dca5bcd960a7bf3cf088358332e9252a9164bfdd77ae37b6bb1e4c742f93bf164f5b08f203dd8a344eb2c627318aeac0e40a117be55f06e349c063b9d61d361f2633a8b44a20f1907ed197dc1070c3df7287319dfba690933538b2b1b47592724f1bf6a1d6a931f6537bc17a1e1f6b877d296ec5d82fb663ed7bfff79047eaf0b9cb39066453ab998553b7f07a92eb1060639c03ba1ccfc01d91249696a320f9233969325deaeb5a1c360557aacf8a026d674c809308f23ae4998dc5c0d088cc27047d4f6e9927a32178ea41880a63e1d8956e64a0f3d9ab3aacee49d36d81a189a8e8f238a71d0c3b81d3cf03dd0d0b9093d6fc4f559c9e1d389a046880abda59e2ebab40b9d4abdf1afbb6c846fcde6bb3a93cff8e5d2aea23b738714104bb66847ce43399217ce21fdea329bc0f60109a505f47a71e98fc39e0d308ee6545f5bef4e5ab3a4ea2e1753919612294e1707f0a3080ff0a0f8f7d94f59c3b8e896bed25972a63e88cc3cfb04a179420f99fcc5539206f315c308c02d19f4aa2a200d9fb44c195c2b445a3aae79b28142c50e2a985c1dd19f52f108fe8747b60d6c8fe4805d6eae1e12bcc7bb3b2f51f675add639514be93fc4002110f0f7c2bf984051e164c6dd0d28711785ffb44f55ee80e0ee33f70a37985f2e4eb64f888148f3890c88c9a0a76260559bc969da4bc231a494d06b4b492b6e9a21225547dd96d1c120de938f7026fa3d75109da4c8ccfb411a2974b693160eeb7afb4973650f08b11e0285035ada016c96b9187ae6b08770fb53e8ab4ca3cf2a6157f9ff0a83adc4d37022fa3c9e488cf284e1e1eb0671b9fb652c3b565773999417139735649610e9a416e9a37c176763134df3fb2be1f84cf74d59a9aaaea65fcf4b51b00e4585ed1e12511dd3f712c8c6f0c50ada4f0bdfe5d5fa8db8245f2c160f006c7786189da7ed997d31b89d7ffbcd256b6cfb2b1f7748112cf029a1c44a425a0cd6a8e174a91781f3b2800ea842f2ef1fcc7c178f4c9942bc29af33e41f23c00e525f9b34ee95e846501a3afb69f0b545d94a1a88e0e8bfd76eea650e30f3f355bb5e183a45afd231c1010c1931369db23fceb2e7d08baaa32bfe1132f19f54755e283a3e1c9475fc117c72779d56d659549f5eaa266ced2873f2e80c7720b2b6146a74756f54c1d77801e8ab1a061ef713c0bd2645d04202e3b1bd0dde296228db5a552ac0126786aa708c0544844aed9b38aebd3508ac8e85cf417cdb6d229e8c6c1e4547064c33bc714de4a792df047c00d1cada9491c2f755b4e5a138b2c0138a1dbda745d7273fbfe599100f39313c286fc45a22717bee52e2b96ce37d686b6ec66342b9e0ed279d9df5c5fd5fc8a51b1a5d5ae182fc307c7cf88fe4c904bb77662f5f32a00b9d21b3a7361894bf63501796d20cf39fcc5c794adf1d9ebd2a58e0c0fed3793cf5cf1fac6085fd69c6d4fdab5b0e222432a5190ba5a5633d96e98362a0dda351d82cff6256964aa5a3670a137f81c3abbf06d06a7ded6efaff2f25df7dd84e45de97fe2b96e39f37bd43bd7f692dc88edaa90b860de417ae2fa929a5a932d47a13775e2158326fac1725275bfcf5ca445b318130aa2082b43641f6f254ac2642ddc9047716c2904acab3755fc03590643675382c2868a438d4ba894706e750fe145bd0a954ef9416aafcef12463b99acd610fe0929a537a28005f4bb5f265b281c70731fafd8e5d5bdc8b4d34f85977190a478eb34c426cc06df6140ccbf45195bebce1e7194ff6c34dea0b5b0297b4762afb69c335cecf9e217f591f20eee36634ff57ca0369b601cf34dd0a7f2ab3e0b0bad710fd3e8e3673863f9b3dd10f3daf5dfd5415acf8a6b259cc5f2644647dc1ce3231ef41dfcbb95dacdf6e71d3c3cf251e0ec16d71a389d6eb7a6ffabf3d8b003a1b244321e6931223358d83a35c2ad79d167f6815a9923578795e2ae57e652b782fe4171ae9fff79d770b38bd46d5b216da26c3195d4d5af919249d5c8b8a4414c045af777c2ae5f01d1433b0ea19ef3ecd3903c74f413445b33ae5266444f5c083f01c0b5b11269280ca052e0b3a26ecad99a2c0d912db2c662e8632f12ece75fbc3dbdf1e05ccfb8060c4a259bfede3e73865f896724c4d5975e5c15510d6eefceedbed568fdf58c4e131a72ae804b1bdece24d75b41efabae2a43b3faf0018b600dc30a5978b67e22412859a05c530bad3232db5283343718a9489c969e7b564e10993886be1c734e540255dcb0d68e311d55e61bc11536c462a1950bcc7d0ca6a3f2d96e12bede1929d45fc84b0e9a34da5ce65b64da6ed0b4e74c6697303369cd5f34ecb9ccda43d80ffd616797efc2d90c79b829b70589171deadaa0a761ab6e405abfcdc87bdc8dcece409095c35e71fe6c68dd566cef0364274933d9f546f88d6d7f66b85256ce1f8a5b3bfc0fc892d8382cef1c6e03755afb8db4d5457717e7e99ddb59ce4c4f76d8374db9fadff3fe12e8f45831e2b34f19f28d05fdb36f1de3f46f0150502a0b27e63bd75ba16f2bf71b6aeaff1e390360a0f25973bda3fcf99f4d5560de17f3f66ec4e8ba9db13fa898aaf1a5f159900c8a41c7f91e373efb8d71b04a1ebe2da7f0a6337d65ce368e599c77a1bc7b7dd6c73bb101f3aef8ea84b5cb57f653569359d91489b9797cc316aedfeacb85a2a9c26cc9a84fec78cbcf9f5c4eeba8c5f78b3768d076666911685d0b67ca83653be4eb0c73a7073f60d178e3be396ffe5c9ccb3f9345eac60a37b1c03b237cfd58446eca3a3572cdd7f6e52323b8512a77a7b1ff2e65768ef96e9bdb484e234cb2108b36806cb42f84cb99c8aa37a2d01e6ce1813be659438bbe591707d1aab8c94f30077e859cd0e04f4a686b419485f07a1811e1303acb247dff33fe4d1992cacbd71e572f6d6a59e840b1a62caa7f6be98d7708b8bc1738431c5792de257f149d7e5da3e348f22f413b6ee6fc96028e57603a42cb7d6eaae6aa2120f413b62c41443b93f59bbe7cc5550407ba7f101c52e458f6d8ed6fdaa615b34457b7c5fe732939a8fa9a43ef9563df7943045079952a7be5bd44d7d56db98c7653703f120d6d4a24e05117e591be9f46a252713714692dadd6b27629df9206599155f9ce2588ce4d71d2ac9d28d63a05eb15cbe4acebfacb39d7b5716f3dd485b47ac1d155e8bf032a6fade746d5f106a37d1c1a84ccf7bb2a4cb07a647cf200170656388b0136bfa2e1aa03bdc77fd95d17cd2ad3ed1c0cd74dcd72504e39db2eb6928f996a21b0dab215337b0e81386be9bf3f2cc0e7ad06d3d2b85d5b912bda3862392698df684ada004026d092eea13a8cd39f102287383be0743c9789f044ae64af4da287c75c37e89c5e0bbc5074c0670ddf0436b996a117f94110e5122dcde44153cf1e80ad742dd060b7f819daae1d5ed20011680af1a7c3d84da01df15d44e60b04248a9e3b98df5eed677c9849558f96e4cb6e94cd266a4bf9d9195d1f6e645077546eb3868e52f29e3c502fa742303fe819cdf3dab0ac0906dce63aa4125030d58553503890f586eb81426048be71047604480626a3036d3cf27fc6271e6901a5d0a99c79fb75d4612372f43794199f3e0c370debe1ca84e3cbe804ca9afd525c7992b89465e25d582d69ab5729ec66be92d59b34e6ee44d8578a41770c59529e8651329d826f3c74d65babed47726219689429b5d26c98266e87408b1f25d7a6fa55ec36718afd171ef0fd426c8a04733ff97f3a55a2d1c808dee8f266cb6574d7cb8db2342e66232057087db6f92f1d97e5f43652357b49e8b4bdd5b7cf652aa881f2dd4ae615753a3b4cc119991caceb441bcacd9714ff122d3109a2b333665c2329d02c38d5b3f0bf20328ec8f50b5f1f155a7c40c9fb81dd47b139085b4ef28bfb28c63de77b26e70a2e326d32d5002894f96b49c51c501117b7f978cd403e2f115d28e5ddf5587b364102f1221f21ab30434c3214d80503e4b34020cd422435076d90883d194b41ab2280576b6ee67cfd4b61316cecafdeb769d725f554f65ba74337efe9959cdf8f097f3a837d327006c4e6de0997d38d76f3dd8184dd917dd668486484f7f2e324441ee35028976c309fb55daa982bd82abc832527eee1a0be5e2df6284455c253cace0e8506fc29ead08b29c6531d2b61e7067ee7ab988c88d8aa445cbfe5d817615bf0a826764aedfc47b76f0d8ff4d61b75fa5bee1de800b2d21256a8d3a5489f03370907045634cb4846898ba7931e140f4c324bef60954fd64cbeeefbd15e32c73876446132d62218357ab1729a8aff21614c2dbd8c4e392a7f8f82ab1676e84fa4bdb6a65f76255b22ba96c70b5b0c1cc76ac9f744e92d3cd650aeb1510ad935bf639e5ea5091dc9d1a66060cfdc7924c226960bc7c4d35d94acf1f1bec27990e07cac21b80d8078a7f9418db6ed7018724a7da30f1e416376006e3baca7aefd14bd245aac80b6b5ee1fce51219633bf47230e8c72eb7836ae8814d42cce5cdeb992bca169ae958681c6fd148c029766fb08bafc36b6dff3170e2834c7376b5283d0d09da3c9cb3fbd8378d2bd4c9067fe22d1d6867ba01dea7db28988952a17ce0f85e22e96143102a873618e8f8279b786a625a91deaf07de9a8a8aa22dd95580a9e77095ed71489a100fc9c5b183ce4777e9e1da87de73721247444811205d488f28fe48cec28a6050b4e22610071022f9c5bf78efc43e05ea3713ca85a56d79a12c9bd3208990ef5e00d2e1e61d092df29f77620615a8fe3044f0b1489a04967498b928315b283b8680885129f08b0e839f14a025f7374805f234660fb4b67da5c3662aa4fa1330a0e4b01510f3fa5048f5027c22aec53475677b0e46d625277fa3b2454187ceb6bea12f7b8c576c91de63c4e4f6ec2a1c8931e205f53ea2477de7865803d6491d0d2175e64c37a5311735cf16d91936b1aac4b2500f6aaf790c15a52afe7cf95def2fe9c9a35b118232c441f4d0074b959bc33d91636861d86000f49fc10394ba6ecfeb4d78977ac7c8b8059021f64a1527f6612de0e4c4f36e65fde8a2605b124b1dadec47fe7dbd3ea7549978eeb8dbcbc750a75aeb57c45970a0b9037433a020400d6d2080ec8582fbcbb3286feaddf657125201ca3795c82459c861d66f0a4bb127449830213f7a68f730d0f1662fc77945288e95ec2f5159ea79b044797fce2e7fe4ef010aa15a50ee44fdb8a561c955f843af0f6a8308bc7f4f5cbfd149211ceb00303d1374bdf3e29b94e7635f2e2e4f17fdf839d685105add08d5579665d41f18ef3a7157904554c63d3ed56b90bc7ecc5e2df98eaca27e8279fd076673ccea48b24963aa3c419ae64ef0421a056aeb1b6c8f6dfce7f4478e6636e2e03146297bb80242b21ace4e2af645d6439d647ff635bfd30c37e88253668c21a47d7d51237001993396741b66a9ca626c09c707e0249719cac9fbc47604991bbee9c8b80f1fd140df07c06a1421d3e2bdf98758c828243eee0c07d7aa3a1c346051c78a4cf19f2f4c668592e72d7755d39d42691723590e967a45fa3863a4f695f74fbc095e412d0d80ab4de8d13e9f686dafbdccb3963d053e6bf4279e3c11d1aa8c1417b2ea4e3e16dff403f4d8fd25b25c95301236470cb9be9fcc4d474940cc1212cb7b342eea499b8faa8ea123d56ddf312939c8f4866901e3571cc3bc18ba2a716c31c3ba04fc25dd7ec3c2d07e220f8a5a4a9214d7368637ead54a039f7da10e4fc5959725ed3d4aeb4ad511d9610fbf9bddba82fd991def6a6f981cde195a5a512f13527b919d09c5b282c5dd45533950f1e7e7e2cd1bed76b19234caf96bce8f7d31620f0f06ba1ec0c4498c3be0023bf2dc6e3662e9be3f242debaeb2daa38c98c6db3cc7358565e87827450054a87803d2821658443a5cdc2442c5f026e223407bb245ded4eeab42eec8d5304e642000b5939a63f879a489e4b5ea22dd9bb13f7a0cac5e7b11af885fa71310ca7e8a9d556f7a57e891e786e4fe2926080dfb29810738445214b9bb8ef41f620febd84da0ff56e80662d0a93c0db1291d5e0b7613b52686714aa719fc4eccab046b2e3901878134ec477023375a8f8f79fcfd29df8ea0125f287a674dc877b5a4ea36dd82d808600e1e06504cc8da121573944a7623186804ee9f487eaf2baed0e3d82c3b7253eb9b7c3cf47974742cc43840d2a9c5755d67c62650578dcfdc074ceddd41670af141f3fe915b0192fb79e1fc9671cf9faaccff71880e70012c5c83da66d217d47de903c04772874a4c09744adc84950476b7dbeb93386cc6d9bc79373b3840ec34cb61f04b613792cfb3b878a33ef0d6c9c3dd6fa1877b2e4a8b967e3b8144388a44405e202db0623fbe1570d3c3ea85fa3d345716e67c82bc625301996c0cc8f131d480ce895458d903d6f44e8185c20d1f0cb2874c544c593fdb9104dbbae61998c3abf6fba271598252bfdbc353a23df24765bf18cb3b12621ebee279957b5f9b8f0094bfef388d6d126474b82911f6ca3391fbf2bf2d92f4782c3bdc730dc788f9f0f764823368e2bed4043bc73aee4fbf8c95bac4cc02d33590f0ca9d58cb16b194a8ab2acc27964e9126a7654221ec7d7e93bf3f5c44268ec2cafa7fee0b729cc0676c56dde3556a7a77587afebaa838497a9fdfb817087e937e50e1d6139fc98b2881f362ec6806a0ff602fe4c77c668329ece35bcd5b501c5b9de21c02801813c563a91db306680482cd16ff523b46367cb7cd55a0d9f37d8797f1d12ae13e2f5fc9888780c03af83fe2f69071c052b0abfe7cee31476e84e38f106a6bd8d2ccb6e2582419b7935eb8d4d1398e01eef8dc5266e2040d6b34bb4ca9d1f7a4a6d591d480441dc12f81de13e10ba774f90b191afad050d9bc31a500073b3ac1ff51dd3f28263e1f934febf56be5e5c75f69e09209043c4f305839677e949f322b65e0ee3c2c70fbd599122505fef949e710257bae27aca458405a500f756d92d8642c4509c538ee3eec088516e8276ba9ac393469033bc3747223299985dbf1fd6040824c0b2d56dce4f721f6a22b3a28189918c0b494d3517fb9cac6b3632722cb0fdbc5f793dbf1f88995bfe93176408da3403b1aee1d5d5a51d4f05c546f393ac4d87c78df390f858a9b79cdf7b9e396cf1420661d66c60bbdb447fde61f81ddb3ebaef5ad1f31652626fbc03f9657784672ea5f0c00401285d9637d802963b462ffcfcbde330fee702cf33c330af2b6f63d4f23330a80c0ca29766012eeb837c3700e09b0bcd5b3bf4d503f2695e1ea74e5e190ac7ccf3491b48d5681b2d0a18c8ef008d9c93c6c1400e0f401be9ed9770a5cee80733a8afe909a3c9421c9245b2d01c3e35391a982ae80317bd758e7472f5c864480525410472bb2720b379362d710b64a3a7a03ca46fe936a38c5dbd154f05a7c7e44000f043a261dee7787170275c866c87f4779d32022fc9337f1e84a2af64c63ad168d42a2720c9516713dcc0d5fba7201549b4975099cf9e7ab2226a371854e22e6c053d9df146c13f84a037a8bc99d4e1b504a253dd7ccfc44f5278232da30db859ba401b71e5bf6620ea49ef79c0dcad5a495dd51f52f5e3432f6b43e2399bcaaca10649cc2ff0ce0c005c3a5c7306eac3be10962bdf88033d3946c48ea581cbde5e6cd82aca2bf6a34809830a2837e09655d59e5d2d99bd42ecb6f1af2ac824dd96b22bf2915675b8b2fc8c35fd3472f065443ed0c9c6485fa603418ad20b342bb1f3ab8b10c55b4ef73034498006f4e6570b86c057dfc1f0b7a11722760b6644f3f4afb30c6ce7eea47975a9d3e0ecfeb2ba6cf6bb852f9fcfcccc7b6d6d85c1c16b42a6b65de0730cdd5981472595d021ce14e34afcdf663cd6b048601616fbf607c2a27fb37d9094cc5991d05d4ae4f1803c87611aa649a9ba897d7d8df196b150d62eb67ae78ff75b5cb436af950e20df81184f146039aa097f8d338254a437551438acfc5bb8c9571410fd47de343ef49f0927753848f76e6000dfc965a17cf7dacb1ae8b1f0ca9a290924986d71c08ccdbcdd4d2188ca4a1012058d256cbea3ebd96470728554e6c10fbca1d0fda49c0ba3c2ceb91e01835979c6955cab581c691ecb46977488feb6ff3248d13aa1813624608b302324e6629d3a11ee6d223e56847577f2684cf08e0a919c6c7498bf92f270128b068f967621c58512e92310b6ac6ba9fb90714f4ab9dfeadb2d75badf79d8a96d0cb4b042f4d49575005f0c0996e08eeff3ba0476451a758f913088a136d1d7aebeefe3a392d8e8241843f437c3673a59735687a0201a11c3c68c914703eff5f584bea43ca168a043691591126d6d6eb64997192c960b70ed30877cf439efe40858725cf0ca7d73d78167083ae76a62b0a789204c19aa804bb41f9d0aac5df0584718e51dc6ebc72516fa40f184efd7ca0f8f991e4067130c14d97dc7e0fb4a053c7bd7108b2a86b30f909b5e5401c6b40d0c8acff2c0c8c9ee2e7bce17c013122624519d82ce4eb796151840b34bd95fe6490616b70d001384437087046c306549e8f72737a49db77b0551149dfab172748a961a705bdbd70eb379c422e15537fdd72f302ec8a8fa6da487658f4435155a76482cc483308ce328e16e901ca65a035423f3ace4b39f51e2c3b92a1f216241cc745cccfc8882a2ea5890de0c933cc66bf0f75d86bdac712047e8e7852f589db94c347f4933a5f2e757834e00e1765dfe9b568f07cf7f100e8eef52ad1fdb0353793d26880071f8af098a93f094be5e2bf1d2b1ad787d8ce5bb2b88a283258b76a613c6ea6453eff4511db5a2124f37bfc2e0a515064fd26734d44b7eece0e96e2430399ba62041caebca8500d896c6adabd5e018c95e99aa86040d92762bcfa29180eb068c194329c9ad585fef793548e099e9c135224e337b989e0f7827142ee0fcf11f1b8445bbc6dac227b9ece2c5a5470025cdf6fa3b11d71566a7227f747c8bff7e1b55da50deacde","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
