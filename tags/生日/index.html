<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6c6926a47c85459100b4d97a47b602478b815a433081b3041f6daf35b8e227d62573fea741b2052dda054744f1dff5d32dbd4574d5529cf53d25d8edbfb33fc0477e96f4090cd724fa3111e1c7709e4a1e3076e3aa4d7bf2e356e186f1ca68fed0c7762fde5172cb4229ae11589d38a3aad3de569465dd385c3522def9bbb0ff05cf0d1a6666f4affef190a9dbb9d2d642d097de46e7feb607e4b73c98857ab2b1699e68cca3607e9c50b0119756f2774c324898deada74369e00058a66139622d6c0dccc89671db097b3613e8331b2b65091c1ad31a0d6349ea3e648d6a4da9b673b51045df60083ba8435983ee658404aafeb9c8a43aba77e45d3bf048b09ed1c441af00bee59eb344802d2a5a8dd949e50a39b9407ee7e210191fd39c78e5a0ec362dd37c9db92f08c64cc8094ef8ebdc22752d455415b61f6a0da4607cd146e31f833e294ddf23ccfb17c22c9539c5e28a9012c9ee3c1d10b95c8b6601eb75d3da242a0bd5e819496532d4968849d168708151efd4c1839c97a1a623bc32cdc34c1a9738e562b90c343b6b859a096802bdbb136c8d69946dd25fe5ea89efff111136319e82803aa8fba3eb28639ac3ccc64c798c548d75778ac0d4a28d6551c4f81f95a6231ff37d21443f4c052ce514827ae9d6d32375cd39d4017c07c7e87ce66685731472e1cdd5461f1452e54464d45ad84b92935dcba95ae1a534c941f53636f4fcc59202f370f53525ec66acb3403919b892e1d7399da90de378e0b7372920208676740a618cbd38541778b7d7562e9f89bd09d5faca03a83fb2a8e28226a6ee99a6c2ccbb344c28a061348df467987a997fefd144b35cee41547387f41adad5ee628beb1ff035a27c8a3b2cee55bd108f824f62d549835274194770b372bc3e1cecaf60a8f03a472c5262b6517104a4f23b0f5e109ee95d9f731bbfd87ccbd7a0823059871fdd1340cdf570e2ab7facf91d5f37af07940bbf4a3c06cf4bb1bc9fd6f14e09ea71dd360de84fcefa119e1b844b7bf24145ee9d3532e0bd434988acb88d8129230cc94b6ded396dc5b5e9d0d86496672ebc4968b29d14d7c19f1e2847191aa9d9ea85e019b40fa0dfa66ed94ed36cb0b9ec92b7bf1f8f87554d08c064fd3c95df4ffa373de1f57e122d833eedccab6379e4add887cd50491597b995aa6ffc3d7a295f904703ed55a792b1ff022a49cb10eaf6677a2645058ee7cf8be4f3ea88b9418d10cbffeae3e7adfc7b51dff67e4a964fd4376fb67b9cdccb4cb4f4af3d0c20bfdeacdf9461a3d1cad0a17ff686bbb62fafe191be6649b9d1638bfdff042d442d4596e5af2492591f9754fac6bfa5a73566201e5d8fdcb1c03f4080f28a61380c32942131def2b2627f624a90c551eae3d3261710735e2c9cbe057b75fabfde3319e1c2f70ca2ace42d09b8a8f7613be35ea06416cf43ec89c999af71447b388bc5f91c70301b3ade5b7bf56eafa1a2c4f73402450f4ec6338ab16800575eb18ef6b13b2c7a1d3dd613da8a13125aa04f50094f1dfe772c6ffd8ea36f70e15b5fa8b62c58a057a9b33ba59d468026b5fc2bf001841097c0bcb045eb6d1d7ce4a7878f294f6ced7ac07214fab082c53a32704d5249372565969a3eb0a005f74bfae5325ad46dd29000bb475d6ec8bdc51aa068aef3c8921aca5138fd9f117ee0e176542759595df8e804d0981bbac0636494d1196454565485bc4a2038c1b417a65631854473e493891ff4d73729e37668034ee594383a493f46f8935b9dae7d69f87a12ba257655be523f3b67e48541456d25041e406729cc26a25f0a25714d4dc83c09096d09e22c2441bee09a9508afde70cc08b58777e498eca840e76eb866175a3985203935dddf0d7487db26831a9c7dd1f8a4ffbf9521dd63c73ef4ab09ba121df53e61ac07f10c98ca64eb9cb0bfce4bfa7f0f94bd651a3027613f5f5f909ce35d1f66d5d28994fa9da43dc4605f477bf4e63471cbf52bcbb944e83159fa6e110b8f02a02090caea76f5c8ba838b497b44494dc609220751c0560c5635b408b53e4efea9e2d826b3ab9899fffc25a3bef2c8f17b953a1aeaa85448316cd8def2825611d85f3e41b68f03039b8d6db6679800e6f8dbc4a49635f63ffceeb5c8fb9b383bcd4564e45c62555cab3f5b6777f7d785cfeba9dc09d5f98102198cd37f0eb8589c754af376c50e298c62c5eb06851985b9c8ff6baf0f62590a30c0c9d06408aae249f56c8808e32cd3b702664a38b9a1bc1250a9a96e3ef7dc5bd7aef573fd4afb4c2332377976a54bfcb5efa769406ab55ce157605e024a556fde845922120d9130c4076f36aa4f81bc083f620c59850515a29523b991de7ebdb02c0aaa2038959796d2f06be2156a7bf55d1f2542af5eb5728dbbf3fef67fec73c87fcdc57397e5696e152d0eaa34187fc99bd8e1725c73889a71af5852cebecadfa4454e21346d3f10b01313c7a57237f5ac3b62dbdc2a1aeba36bd55c9e2f2479d7fa2097e358d9d946efeb7a874b6e75e4dcf8d8ce393efb1a6cac1e40a47e8e00ddbe98b7b3a975ed21cbad3be3d969c1c41c2a456d0384aad8b19e36eac9f09437210338905027aefafe3f0c1b782bd661a1621fcb6f205e68612e1ff49bea111dbf84d2d53d5e09678bfb3eb72240d90c2284e5666cda0c975dd5e8bd9fa6158f68cbc342066c46879970e1df49730643195e69014c9d857478f75e215efdb202cf829ad67867dd1d4fa7707b2cfdee19405f34e0f9d43e23d1751cd54256b999c974be5e9b38e0deff147ade316641dd62d36d5191ccfd26bc39f02cf06fb5fe802d95401092ffa07bedadf65bacbe7caec483f6407234128c5b792611a291556dd4a6758d7d553f238c529f14b3223ab6899bd63d9d71401e1d34561d93171a7b3f3db8c6daa8dec5c6ab46facf3447ed87d4272e59179d83ef4e7cc94b4fb3eba3db81e354fa0cda47267f48f2c827ee15205f900e86927b0a840856e6b2bb466c14d662d9bac6563af3c2a6620623788e4c69bd6ead8e61b490ca269d2fa0f7b6d625e58132a4cb618c0d40d8ccd6baa8ef81e0bbe862f26f2ef7d136221d4695daa57c0549e8c3fb1d092c0229868c9f53daac664b8d05369794f301bcc3b241838d8dc233a0dd8854860916a9526ea0e5dd0e5df5be1304d0ba5889cd3b8dce1c0bbb9576b037bc305ff55aaeb4c572c07787ddb292d2f4eb823b48c9bcd03959a9d3ad2a10219830df0e99e1b605fcafe4eb482b595b78f39f5ed8e7ec82453f888404c1a0cbd99e7e04a27af2bc526229802fd217fe58b390ce72be0352f82b3e8a9d0306be856966333bcafeb2026ec67f9be3f6a6b0f5094a04594fbecc11d6386ce34bafa0f86314b76db92b9a0482f13601306fb161bb3bef44f842061500afe0e29224be588bc20db65f6d6f263a005ef0e1cf17a4e3efbff3669c58e49a0d20f0a31b404ccb24a0804e0b1010f12b4340b5c8aa3feb00747c73657a9102d162340fd1a394028d4038336ca6a9534127dd9cb6616a8c7119b401857091742ee0333792f98a92bd257656f2986fbca17f53177ce713aa4d85249719f1ba32ad846564c6b13863ed301109dc9562628895d86aa76c87b7ac35d6ebfc5f10ee323a228fcf46508fe4a64f6f30ac3ca16d853fd3cab0f669ee9ad23f63dc8c5b96d06649cf5d0d4e78b3c48001c93a2cfea7a0debe0e63430f659be073cdd968d56188b70db01d19ab66b157797751112def87a26818edba801b7900a5864660b87d7e7d0d88f2710a91244bc249f66308095a075adf4b8cc68a96df2d1f8bbdc9262b9768eb9eb473b1ae3d5b7f278eedf52c8b39412465f382a4404889df69a94d93bb90f389521c7578769253103e5ad67df3caf41a041df71492e9b67ee580c272cfe0a7eaceb70a8a5897a905e03ffde2453e109b4c13d4c9222a4c4e555d779dca4334170f0eca56271913a56c4633e12a8d5f176ea243670933eafd316084e7736971c0d2e72e85db6daa2a5f86a1233dcdd8559813f3949dc551f9d7c1a9d0a80ea9401510d2a4d0956ef6bba0927104850ef02d8d85312f731526123f0cc1e2fb73dd276459c0137dd6d894f7d3a514686034144132781ea120cfb13830334f3db8e9c69a11dccfcf3e976b89065304c9f4f11e9c75bf1c2f1a37670c984c43c9fb698c5f546cf3a65b1657a20c701a57517d4ef0b2fe75a5c22b7c53dd636456175a2df097ff7ba4d31297f1327ff24bda8ac400d4b61c7962cce8860574baae326ec8602245b73eea9c445f9419eeff713cddc02ab9d15d7a54bda52ac44407ea63122dd1c51322017cf66b9379e43f53c4eac939fb964311fcd52972f2b20fc41573cd36611b8a59bbabec9c7f3173cf413528acdd6762f32e013ff36ac617598901174412b46b5e2d4ea25258f667ba02e8bd613439caeba857e4492f83a7f35e835bc36247d6625ee428caa80a6e37b5cb38efa5034a92e047b8b2dd84fdf964da038d6c59451eccada43d36670f12ab01a45ac424decf7ab9ed8aac48036785d38d37513e1b6f7258cd7e259e716429392f0cd408031e42e4f75d5dd9aff2cabea9cb8d4a99850d5d033684f318b2655dab257acf2945bd9447736b97635484017f32aecc9789091d30d149ccad14c56fb0ab4b4f35a43cd63ddadd57b1642d91f7545263b7f0d4ef8e71630aa197c982369f3132ff42226d225ce8b54a7c795264974c35b790d5e9bbba53849cc5115ff27ed10d94fdc819780fb6484aca1c2dba283e9c78f30e441781ec3aabd9ae783ef266ea77b3d9b70dd1fe3746454c366eabc8a7219a4299e6cfda2fd3cc604a35be3a86bf48a1626d7e372c5de7839889e4dc8a37dd7fab6a97d216044a332271ac09a1ebd680fbf45d9cf7cf5919ce5eeca405570b730595713b14a83a7217ffd227504cb5fbaf034ef72065a75d4d9134357f83eb888b357bb975e8ccc406d284df3126bdf9bcdbdaf52ee6bb1c27da6062a2f4225edf42f64c3ca53859249478385642f0bc53af35081d02f148ec0eb2d07fedea2a86b673770ad3b33b3805729ff43bd715c69a920d7118e82e7c5ab5ffc1265f78503936210442d86407cec1859d20819b3008e154c2063ab73e1573a0a52ad86dd3bdaf2a723ad1bd2eb4ec582ca165661d54ad73856b601c9b3c82f20a59eea52f4d098fc5e0bdff7cef5916740470807b9359ad826df92b8783a4d6cc65dd968ca4ccdb5d87511e47d8f0276d7c530410497bdb34fa61191cb1ae1307274cd25ae9ddb0640bba61e61a37c94929c384da2294b9c3db19b1b5f9c3349a6e0606f8f57f44bd24497b42652e1782996b19d5b1d31afa450384cdf7e849d6f806240d9ce539e809088aea285c3f9972ddc56b0df3782dda08d7c8995db424c3a787484a3c8a7c6b4be0247472aec6750fbe8a8f8b6b2a3c461f4d28d07557e903946773daa61f83493df54580ebdbe18b4a1c44625208c4afd11b589308e208495f7a1711fbe8d49bd153c5f0ca8d8cf821ec9c26d6c09fb143847d7893b401dd6f3c31c26499b08d54c2045e37ac6544130aabc3bd469eb6e3e81d69d3847a11c116bed2821b05a323c0df0bbfaca7c4a614a5e2f16eea5f3c798d1fd48b54569ed55c8dd888a6a094391b03f536b644a353dbeb85edf1475e3ce49b8326aed55741df6c4eafb396ba3eedfc82d9b30db089a7907069fd659247b7bb49c282a7579c61282c4e69ee2bb0b74d9d8d2f7522c729144f8a7715bde5f3f7c9bf2002f07983f2cf2c587e63037aeb2c92135760b80527fc34333db0feb53b91f1c94ff096ddb66870c4d7ff4408b87884dc6f18fefc1fbea539a1a83248288e1ebd892d43f7add31c27c84d24784f80c5b6c46d92d18e06749aa45fbcf5cae30e3ebcfc9c0ae8a21670f563e5d98310e6cde29f287de23977d07824ec6e3e0d35635cb45e0c01a25a6d0d94af62e08b963ad5a781ece7e7165b37b1ea6d522c511bf91a0465db4b68e808ab70f4b10409325e37bf33b6aba00c974584920995b5cc03327217416fda7bc1b70211e5fb9c333eba7386c641d982acc5b31dab869cc50d72df7fff4378b2cca3e6045e832f7465960de08bcc43d87e701363c50143028c15008bd834ceff15b58deb1c96b1c887cf9124232494019eb4aeb7833d36d1c0823fc218fd7340a980a4e2fafee96728499f5b19447c7c66a849f961e86e786bafc24a22f677f762d0d8b8ce52ad3b00b915359da25672b348769185c085a61c34b993d2dd3d08ce1c0610f7f241c683f7b1fc4628a8cc6cfead0419c4f2cf6633e3192ffb03601dafff54dbcbb65c968f7b4f1b3dc85dbacd6c711995ee425f7a39ef96df9f743997a6e3f92ff9d594b437e2f46f12451722a5c023e078e9e3694e1e241ebc0e694fbdfa59ccfd065682b62999d0b6e7550847aec9b7fe4b2c394e6f75a3ecf631f74a998ec7ebfe6b28de103f03a7c1c5f72164864e560777de5baf2f3db853ce0606e16cb28f929891a2d22b181dc37f99e3b19d243c62135de43b37d9c6a6ed4d55606bfca4dd53732c102c473f83b9fa6b23653e43e08331ffa6311888e4544f43dbcc1f8b4eb9a8dcf9876a6d858824488280715dff7217d9082d662ffc235c78b43174da54819c91e1262c45900c452ea9cde9ddc932b81e886f64246ce577ce852bd93433452abd1b1df49d5a7071344aae13cd01d14892208d7b75df6672363cf81bab8037e034d901aa140ca3a9f160a1e1544e3aebec80ddd8e7e6c7b0b391da945195ff3e9f7380a493ab1cdfcaa465e41fba29b625e4a95e06b186619cf480d3447f64f23aa6a330760da26ac93962b8fe25e746036dbd4cde21f26535c969bec6d61670bff24542a14536a7fd6a6f64c45e8703e0d3300e7e448042e4f5bd01f1795f01ce5665aacd0b5e5a74e256429cc3e74b2fc02dfbf453634054224f07acb4029687e9d32ec303f6877a9ef4693c7860bdd69930bb5cfdf27cd46582296bbab3eb0e49aeac00fdc26354b05a1d578b3999954257eb8bf8777f61623b9fda89a75c8907cbb3c5c9e8affb5cb15fbda50b1a3f39b0e4f78ff3fec9e1b14e028dcae6384411889338a3efb0ef27282e8ae5742178fe47f476cd19e6956fad34fbda914bfff1a2382b706895702e9812a7667f8b15f8a47d5c3529aadab1926d87bf8561b25741513e9445fd858c8fd1bd10b9343f3bdc01e63fd8132ae974c374e593f884dee39a81457d979ce646ec2ccf2dc3f8f392db0bd65eff14afff04fe66d79090657625c5f84ac0fbf222f07ba8a01a9ace824fbd28833aa4b1c156734032f434c94217290e22056b073bcf90200e76a5581b6262156f4ca906c9d0dd7a147909836c4680e466f4606294e94c39b0a8af1dfe2f89253f8cc14f77edafb561654c3923b13bef985e6a59baaf68c33b03165cc334e1536a20b9783a84458fa80c7cb8a3dac7942f7e74619ad10db24a72cff3cd5a3e710b048df92a01830dcb048ac9d5eec7714f94bbf46cb7348783d2014f9e688fe27664dca821fd83e7f89f7a661cb7cee51d6bd829f8183606f573973eec84f34643befece3b279aaf8e759c255765490c2b5d38449f967d9d4f12fe8c16f21500a2e9d3475b80f282e921d0c621b2e9759e38a41d5cf652880e4b93f9c681b2da212b16cb992e536fe4fe62c26354e5d55d8b0f05bf7ddc762f89aaa7655f7c9f73144ec2a5db5e92b56bc7a721fc68daec4b4e7883d6cd60b64e9b1d0cc108aa56a3bf4f423deb63f618937c4b35e4664eddc1e14d81183aba82b34ef793c68443205de90c7827aaf86b312ade74eecb12f895db5d6fca4ee7bcf72ac246357b78b2d242ec8f551b4ebda75b2e1629b8c5880b76f1d598345112335468a3253614dda602690b077b68bd275cf527f567f72283239e7a7001806b2efb44bdc046be96f6f859fda1ae98858988683690de56395b4ab3e794cedd19c8b38f0152cfa6f71f0dee33e5ffd119e9f27d36df8c5199639b5094f5d56f3d4bcbb525f592f4a1b3d6e9afd252b976bbf03285c8fe4534ed90f2f5e692661ca5a5fa672209d658df0be3346051a2b38fe8a53a1e85cfa27a49a344984c4b415c50cf7e2d92869752b8f0afbd5e0eb0eb5c113b17a8a81ec67b414c26dfe9a7b7c23cec1ad7601c62bccc757d373398710f083925523eeb66b1fc81ee1e03db9e9feeef8e52852db15ec3e525273cfb8bbf044ba2f671d50a4766af23a3d5103bfe344edfa0d19ad8acc3b026437d11293688bad1c1d063450f5f1e0682d610365040e5a64a5b607d2b845e8cbeb7af0ee9112ca82a9219323690a4e991008b6493d13702b97ff8a5bc2250d0c5b6cd040a0f678a3ab6f669c4cc436b96ffa42cd9420a86fdf6683a9fb24f0e3d4839f73abb4dfc18f2974a425fc89e93381f0551ffa1f6b4549c8bc6a83bba642c4c7f2dd2ea1f66b43c04f7341864b2bd545910c87225b058fd8e1547bd8baef44bd2693eef2b218fe6bd47709d158356581e0445e28b597d7244c861a596119f6f9e93b50bf481530d108c9edbdff29c2fc05e9c90f04a69c673b3e8cdedaa2acdf7955e4ad3655d6e40fb7491527781c2d4a368d73c159dde578818b7819c5628212288f7bbc76b35891bd6caa93b6e510c3bed5c146b9bc7b3062a0aec28b20af456fa56932c5ee0dc3bf90da96a6d85f421b0d0eba55552aed121302286acd8128c52d878607f899e83ca3be612b8835375662ba819fd1a594d9ed0752ab6e34b51ca1ae2e29524b0ab3ddcd3daa75fb224fe4ce43c14b609974e9e0c3f759bbfc3dbee9dfd1bf246735f95c3ada39ca32da9d743b098b2ba5a8de6eed2934cbc5ad3a99526be63ce1f1453ca735387b9d1544df7e2e957d3dfc13dab18c39129c58a8a40eec75b34d057548da1547e1c14e7f3c7ff8a932e799b12bf90ab4bf6675a9974569dcf9f16f60883edfe98d0ff5b6c7d156fbcc4d26f02958b0c07de6bf9a94fa845a3ee9d820291e13b6319823ef859175f0af223df35c7a26c22d03dcbff6a5dd2d82b955f7c7a8e3545f42b8fee127ddf03cc2c47f74cb3fcceda5be16bf45372b2604af9e07848845c1ce71ec11bbaaaa152aa8c14cbe5de0b0e602d907f740757973b4cd68e744d52125f0b51c8f72776f7f1377f07f48dbad26012af62a32adc4c08c0f2f56098a374add806363b53568ce5c45797838f9670c73a5cfa253a8b5aa554ade4908b90180fc0d2a3a141c9f4809c1eed4a57dcd39623f620c0e325e87bb11c48933ebfda39a735164409153e3c745f2d94483bd4d2203329df75111da0dd10c3f03bb438e295c778066b457183e7b3cc0455dae6e69d68c04cfc69ea1afbaa705ed5382a55290a30022be2bf8a60d3d15b178eac2f8fc99d7efd94a6a3bd8eecddfe533705620b102a0602d0e9f944e15be3964d75ad21a8cfdc6ab63a333f253cb73775b206411f810fcc52746849e13a2a1a6d120cc9333bb5da387878b3b49207f01993218b8d373d9be95f80e4a80bfa1f4c00f501da40087a09cc2a2b43697d8afaf60519e1e7f2f2fad0fe545930b3cf8392990efc11b0eac36b5146bda0aec2f79d2a47876599a7c91a06c9d128b4fe3bbb71537d17d8b547248234bcb0276d942fb5d506850c6d5c9e1f9aedb54c2b3c02c8cf88ff8acf24da7ab4ce2f1d314d65d7f8ef83e05e01f7012962cc19a7018c9134e21b6f2b1605afc6bae644f7b69ede289ddd20d4a630c85578e4bf8590591d97ba210e95282c2562fd1007c02259563c44c12964f6f07f0f6f03103b154c55e13d9ce1834cf08eb0910ec85c1599cda8c697c65d0ffd9402ffc1b91dc84ff71636cdf165f1ddd2b7009e108f0022f1afac270bd5d694c72394ef66ab4d562fc520a576f6e263ffae86c26262bc6358142fbe5c07771d8e968a8632734674ce8f50f4387c2a97e12bb521e566a9ec4207dae2ada6b2b0851bf01cd48d5366eafc772849b89a1364cd73d8931033e878094d995060e3dfedcb5f9a719b780fab737f264221ad548d3bf70517c7f345620b37c7434d0c08d4284497f7deca71857a5776a982db35970ba791f769e8253cb495552537d5b906dd399c15d6b0177090e2005b8c1a9d78444b0de2f71ed696501ea43d89562d2b121f92847ec475218a891f7bf88df488bb3dd3ae984a3385061c48ba78c316a9da5bceb423da162cd2885641b1a1142e1f35e0dc46b03cc1af78a7eab5729077e6f6b0b8a25dbe1b64f67f810e43c966765444f58ba43c81f8c62501d292a735af805b9bdd41e07ef985efed037314e8ecb6866cb7c34121dea6be9680c4bbd45332518490bb384f35dbb6e26b3783d4441e5f2b3cd9305140894549f9effd49eaaae5a2ab998d14760db2a8b8c0f088f0878cad56b0804085faa6686e8d09cec94d3f931c7c047e36458bad69e1ae473fc460ea793cb581bd73d87ffad54dbf71f68328af089b949933a288f7ae9a7ac9e8deb3bdd9eb82410ab8e8bafd7f9ba97c81191a05f90db65be5b6737ead5c8219997e649d3388b3b33a01a2c355a833d73e11caf75f724da8815cbe1e63e2ef328c015e31448b245e96fca35f8152c33c7ef412a8eae1a352c3ee652b37a337f64d2c37410ca7183a985e5dec3ce36b5f7dbce0f203f36ec19d407fd1c131e7aaa63c159b54132ebbc5514d7110ca9ab1f54a23e2297afeabba0e32ee81d67c219a3fc9a7f80fbfd22a32c528c36f1b46a8faa33dafbeb7c557913f5f1947f775408c7bbb313193052a91429f7e249ddc32eb8ff9c167830ddc5352767b4ee4ba662b47f92d5c759e519fe3c0c599a22691bbef948aaad7df35612cc98e1fcf02ff4cf9214652915dba4482653b34cd17f6114b05f17276b4f6505837967810e92c24506e8da0eb1ef1159327fb3547275dcce0fd17f5bd9316e2d0776c79df53f29f6149d4e3e7f35bdcea9316b66e1fa553ae417f7f624f9b5dc2e330f3d3f96d8e5c2e4be32c4208070ed7fab2519e838d2c419fcd302607c870e7a80327dae50ef737f1dad0ff3fd2f42cfc2897962f06dfac8d069953a4f4ac6728a91322031695faa9a8f50d61ab285d213021ee575dfa75a7329ab1f497548f763fc8d717b21c522e62b9f4c62c57959084cbbe87d460ac5fec1e2bb29a679023520a0281932bb61ed8d736ccab89045021f78dad77399630dd4b835fc6efd7378d4190f0d8fd4f71af738603d35f08bd0221da1d6ad96526010ead44f3e63a1d5e7857c278ac430e3a0a89f058be57166d71ea5de7daaf8fb6614b82043343e411a336820cf6c5a12d11593c5e6dcd9e85740b4f2e7efa381b8b637cff9b7656182e30f1a8385bf244fffe3287e020f614bca5ddd8636e0f651d8389032c4f5d25728b1be013a215b14ed77a4427473736140a10b9d1345dec37f7794e5e606850e683146513aadd158937dfd9fa28aae54cfe35f63674a0636e069c6dc578ba93a7a1c7f46c5ead7e0f3f5d9c2d1e7b7d8da6513aecc6a65f000b23e793e89c739cb199e364b96224a47cee1ad4dc0a4a56375cde4a0a1458ab78e8b913e99a826080e82028c9cfaf290ed1095b0a3364768ff1dc0d5555a764c0f3649d0442ecd2e1b585ff1992b5772dcded68f86d93abb2d7f805de6e99db62ac81acdca484ca39ae661aad8e441971dbb30cf520e32d2958054ab03f89dd5bcec835ada629c04389c8dfe99ca3ee13bc689ada0663301793322fc235164089e01a99659ac1841baa2b6e53357fc9945fcdb510b65c9bda5bb3246550ec8918343f81e961ffe1f6dafff8e594311e851d9f94d4fcfec7d8e23bbeb77b363193ae22aa6c70ad3cfa8ed866a207d9dc1890c47dc3c6e4dafedef9cd174d4abed1d30611dd172a4bf8fffc51e4bce70e83a80a33bac3a02cc215b38b3ce57959854e7e407344aeb0a54e65fc76a331073f6271263c085351696497b6b7c9df214e1331b6de7de9e439275487e56d222a0b82d3ae742bdbbc544836c08d227f01d4197c354b4fc0cc3e79e7395f2030e9a1b9782830da6debb33e1b7cc8cc674af050104bc93359b47cd8a0b618d08739ad40c4cc732db4e1f640866c3fcb70b9e64a5ad8d2bc01c16364e32e996e399fc9d7b1edfc5628abdef9a8f098a7aac8a7930e775a607e09c951d0c727255cad08c254cdf1d768118d68c0d99fd2458e33133c8459769c046ecb401005b028521ec5ba7b31b431092f6cab8e4c4c42359e9e17440fac3332dc163ba03a937ca2739560f6194a642002f945f1ef5cd1a2b78925b67fa8d581c36510a3b20a022adcdc4813fb0a893bedf0fb8565c8ba98a6269542da0d2c74f45807127ff2741257100d9314874b21caa1c5caa20b440be581fea66f3cfb2933314332dc3711d4ef4826055443d663456a4ab5da718073277196e3bbc3c30d68ff0b857a38ec653419cc1399249ab6790d08f623982b72c9a3121d2f0bcb350e914de92ce2314a2ef14417b167888c25c3caa5b8137700cb948377b12b3ffd1923ada68687e97baf0ccf2cf205418ff6d7d8182c47f689b21318e22e9420a2ed3f919eecbec778d0cb2642a42dc860fb1d872b02f579424c5f8d53de1dc3ef421095c571a370d1c7cf836e9d81e70f6532f7230fc4163577b0ab92fd91c9aa0fda1bba8f37c2704cd0397e63b9b3cf2116fb8046bb05196e7d67919e9318a2affb17ba5c4fdb2e909925e526fc5700f13b2beddee6cbbe9e76a88c2b718fc2f0812b0ade0a8d96e8c8533a30ac0f56b652fb8948b73fcf16e982dfd2bb9377e57a2aec79eedc49ba7d04666cef88fb07101390348a7817946cbac91df84abc5d207688698618785aa0da10392ff5201920d5befc1a91cf499bb5d11b06663c48cbb63ca2969d1331bf0eb196a00d850d9bf99473efde3dde1ddf9ebd791ce83327d9f9891f01ff8902c5bf3e60f742de9b4ea3b2cf421ea95fca0432f4ffc8070649afcad424e41e746ccdfb6784346359f059a8b405acd1dfe4352356445de279c49028bf4f170552fac12149c70c2ba1d7dacb3e372114eb56667a8a01b706197df2d7abb69ecad715f3bf48e50f70e933262f3c5a2635b9a833d97a6a4fad36eec44f83ef829df592ad3927e422ac781c8ec61d8d7c3646ea8df2bcb3ecc3224275fa414170693fd86ef7edf33d38bb0dfb1fa2030f241d07a7bdb3248012a4fbc529dfed1853cf72196e18a468629dfaddb793194b3259ae1464f0d3c6a42ddf5ca7e379bcde9fea7c3db928e74e3e71edcb2a67c703b64eb35237f5375cd94e3d949bdc173cadecb6d09a10e27454df378f6bd64502b7481e76cca4538358797ab33eb6d73fa703446ccf20a108d4d615b6c4daf2577fce3e2e3ad8682243916f12b92c528734f957aaa34cbe10c00433e29280ad583f7b683f94ecdc12b42a8c7caf07a5014c9b49a1764b025e0ae26fe6eb67636ad9fbc2512482c2e8313090e3be55e3e0ec030a790597c618daea454d06e57c9e02cbcb73b5b54c9ab716605e8f18ae1efa591ca236d7e42ed86bdf41cd13a1055f64b8cfa03cf98c48a432b7bd1bce42a454afb91f530ad8d1f10a6621fd59402fef8e5526a9cbae66bd18b66efe03fb7d311edd694ce22c0e0ca1bb9b5e95d57244b175252051843d8ece34ef442ee6a2068fb6e91a75e0deab34ddc4b7a9c8c7f0dbb2f9078639941cfdb78d74866078b1bd35a4c367f59ac4b98db26e76fc4332e873fd5772999961b713dde26120ef183f6a8db9f5c5cdf71b067b0bedbcc94cde756e27e23eb2221540df3e5fdc04d16e1141e5d29037626693c1630e00b84b50eb4884e258d8894058a8995b18ba5c8c3de38d8141305ce4be1c99c3230316b45c825b10b030344b4fd6829c0bfb65ac5a8789e17cafdd89aacf12498616eef27d7192d06b41fdcb4a523b3f35efab5f9397197656cbaae3ccedd7ebde21ecbf94cb4ef5bc211eedcc0c56000945b9fed7ce4f7dc7f3b60c9c97e3a8de16250a4a127fb61c02844a3dc6b838586448986e7d94e84c0e8fc890ee17eb8acc2f937d9b0e7cf870d638013ddb88b3f1af6cad52ff90b94606b3dff9996c062d364256f579c89cb78b228a36167d2dcbabcd2758399eccb46d4e9eed791689bbfe227ea34878f3c24d71751b423e6b3031cc7af4ebae7a614e589c2f62872bebe2efc77d07f968ec2623c900e3a719b841f2b1b9b3e82cc2e517bd2785118f60f3db47b4d21c7cdcdbbf0006d2ee8fd804e3f1a2077a3972934aa059d7219cfb6682a25cb36f71258954f77716edf67dc5f3c78ea2f5c5d776ac058d39c143507475eb8ef57e0aba0bb86c89779b5196d324990dc9a14ad42e1960b4ce78b1798e113ee5719674da7c3e9a014e19c35e0fc6401d98951cd25f3ae911a9d05b5bcb0140f5341e67678aa43cbbe5a22e30862606f25b0837c0f4074592c978754fd50281ea900bc22ad42aeecb3a48c00fcafd7f6cbbade263d088de70493be1bfe424c6d808c259480c1abad30c2db19bb0ea7c5a891a413c06ab8ba1a02e0098d37291e7c1397196731c980a2ed5e447b2909b643b66e8952e842547ec7c924964383e700f0da8e11b1d9917f0923c70a33a4bcece0f319222c569ec309cbbe57379b28aa468e5ce9337e6c7df688826ad0c11dc0158f1c4c053cb030d99e7e90a1b666de24c7a300c866d306b8aada602c6ae7a4f82c06e815866d19254c4b9f27e65a8244d6995ea9176ca1881eb615122dfd4312ebc24d497590e7132d533d9e0f8ec24d38b2fffd62864e9ec3e5c4ad7c01a4d551e54f6af437aef88fd40e67c6efda0faeb72bfc6e6a42e1de262a07702e7ad96f3e4871784184bb91353655139b1a523216925de4239c872c9e444397c5284f5be884d2e5fa22915a90a55eeee9c0824732d786351b17b1f14f04ae4e330d0e6dd0c1a24221d7536145f1d6c8a2ee49a9691e1cf3345d02e0c95167914c7cab46175e872a73fbbaa552675dde8196bff6ee63e29b4922c4646f7913ca5686b258f86c199b67f84f75bb9ea3a5f0858ac2f806acf0ed764b5f29cd19abaa181e1915e34cd74de5ff272c8416209707395d288579df0af265dd26b4ca57c2ee181528a791fcbc2bb536759c0fb12806983e9e0be2b1ca26797ef66571d49e58578ed6e4f5fbeaaba02d01b6779ab485ac5e0e7253763f51eebdc4d9498a1cfa894c13b0e70346bfe09b5c7ec52d07a1e22a81738864a007086a629ba6b2d6e947179a2d6ab03a8718f1efd6e3aa222690c34948e01819af43e244100715e7eff07b1b81dc7553e31168796bc3db70e6e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
