<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ec22f49469a08b938c716e748837d9c4e3f9e1233874c299e6193ecdb57cd19eae4d5092993699a3db678fa426b0fd44f749b17cf8129953574b3981b35fe5b37f9f8fb9a6e908b107b2a28535532cfca9f1e9c769bf7a56303dd40134ad3b56699acbbc725ed8257d934b8c63fe1447077c9014e2c97e8ddf1b4a611615a6bb333d9f1f090bc4477b9cd893df78ef708c531dfedc44b769f33a15cf8109e4001992d1e05449e3ad82b11fc8eee6462efe348df15eb34a31abb88f889bb67be524da237d61a3160cf775a53cdbfd2b3d22a35e7738fa5b0fe5a2c081b7974605fbbb887919c6bec0a47830ffaddd0f9587a17d01d43efb599752de194861a8951f7ee12357461b90ae221bb15353771137e8e8115fc81f9725489fe8586a02fef8f44f8c0ee8914c5795ad56747183a5a034604a04c73b19453d7458357a7bf8ad236ca124fd023a233adaeec9a9e4345e4825a20a5c8f0baa57f1dc8adc7db6c7012a0dc295bd0758c99ea0b06c4f3542a87127928365ad7b2dca50f3fbb50d86c83062adae24c4bd044a7745b168d7e3411677fc092d42864fee7421aed8247ed6d7ad09f97c5ea9fefdbb4deaa288b2b5cd182ac38b62c6f8422e33195eb44a45670cf14ed7aa9325d192f18c867ecd18ebc88942d23264440824c43eac6e548f0ba5dd6d9ea50c794d5f46ee6747925ddd982c06a77281d0220be4b6bb58e4b902c2c46805c9ec53a1debba947b0d168566f1b9013fbfa8d267648620014e0903a2651ef2ae33b84811f18c22ce844f1a605ffe1c6056166faf6115cc5fd6e71a3c43f5568bb7db8614f44e4b73e6a9934cb129a7ad4875baf53f9c1e57cfb8a11d8be76464516d5f85455e75d2f4a86e96460a0c1b59b8d7010528f9b7c028cba9e601fa6de9175618e17d5448ef0e271f0bcaa8c3d404d7a91b785d13599ecf60c58833faf10b11d56341d925d15176cefac2d334c19a681c4ab4f2352f2959b1600e83b275eb21e9f68052f2be73373db9be92755e430aaa54104cea6276d73bbc76ce5365c9b5672a4b984d5910dd7590cffc9fc3aefc1e3c61fd5da8314530287cd844fabbc2dfa48a6867ed2a21006f73a470561cc10f505946e562397ebe2c4eebdf8c38facf17262250be2d7ed519879f56b7c49409d3455ba5db896c15a690b2660995a55b4917102ca69d442d459e9e643613a804de413b592bace0bcf23be68d8cd96aa375f43fc4c1c515480a428be28e3da7a9c4ac818383ade5382d44591cdb823db9339e95a34eaae006806717557cb545e70f9b5bb09d20a655f4b8c51e93f2ce5b0a5907920a57e536405a55d5ce6590081b158ee9c07ca15fb8da54d487acbceb8d3fda836afa5b111c5b580db38720c45b21461c7faeb1d27d8b506d5d201a3d909c0590507f013f98c361ade893469c6bcbbeed0566dc6080932ba114d737ffe31b24704ef604b5819d3bd366ff20a4608052773d5bfd4817dccf1d162e863dfbfe9945cc67778cb4551b9755009376f7e3c0fcfb35764aca02e5aa5b854097fe42ceb451b69d7179d3032e50e8b93114dce16c69eb7b2ba691b3f712290afa67dc9b46a98ba191b9061660dde8f56a4152e1a3563794a09e764045ebc0452b2f536efa64d2f15c4dc336416eef6653a5b165c720a498202562e2e911172a8afcb2021daecdfcea3e14a29f84d04b28823756817fe21c05277ab69079053045b2ca81d33c139b674ca051cb733aef1c47436bafed4325f33614dc11553aa9c67bdd3c9b1d7a0d080836678510605690779389a3a63698b65949b399e026b7f1cab4be309a3a10e9e2fc6d8dc5fff4e628e437cbb6dddee90dd0f9eef399dcab66361153ae6cd7fdd5b700c8cbd0081cd8d9b5a094d92668e507876e4b73f350075a408cef3c0ea580cd3f53fd1f55df2de4f7e4ab3cf9a866ef301460f891756c57ebef38f77be090997fb7c2a2092434752ad78ba8acf86e1a17708bbd93311e75b240689a3ad110ae39a533d5003c21583919bf5d94c2201fe6c309b8839279e52d09c102393cf0b43227c0828975bf6d89a10e3e6c2eef38ccecb1734d97278bc35f3125434a30ad552384699dd66788366742bfa6951fa754ecb28d012fcd424e57d09fabf23be20b42ffd5d14c330a7f42dfacf580d95379662cbc9e039ce2ff8c4d1a12d1f11449816d4fa770628c793345e088d643492533bffccd5e138dbd3814d0224be64366204fd5141e28447082266540c5e7cb4a955b2d877a77dd64c66c120ad41659efd34349d3454450a55d9a841c4493ce6d91898c2141e28098cf067fe88ec47d004199d596665fb3c63c10edbf42c01a24e84da51d3b70223120903981d71de34ae575ff3c92edcbf2820443dff8002164774359d857afec7e06880062e67ae9ee2b17c9d875bc11c6308b9d0961ff0fc52a2d643802c93248349dd985a342044ce3855bd49b5004a339d3cc9ee7ceaa721b586bd7ded5543f85e0469da0400aa05aedbad6a4e4bdc14a8de343e0858ab6c37fa4228671f2e269d82a2e489bc091bdb018bd5ef7985312fedb7e57153baf873f2743328fdee1e595accd58803c86a582752bbbe93b28361bae22b2ab53c813841b3d7afcf6d4dc576f4ad3fe8e16cf3de4131c6414fd64cc981aba5974ad2a7a856ab9dbddf54cceaa36f2764bc2681b97e283bb40462e0647a70c950f67624b4bed52fca8288937710c1a162315c99d564e5418ba37725b576e3412f8f8c968d35233bebb9c5b33c624c54bf88aeb9947d407a77e7cceccf7425b71f0b5ae943367ea4427bbcf4c8307dfdc966a76cd2f8cca67ffcc845c51c02a3636ef818ab7dfd731f617ef2f393ddda47db6eef7e992f4b68665a27b2ed4e48ba3e94800bed27393cfa9aa15328a763930e1b01314cfc3915bbebf489c31d635f7d15bb0177be7053370f9d64af2b7263875cbf9885f054aef547644130fc5790344efd8fa0cfd333795f25e1571b9dd68e0f47814e0e045419bd319d675f3770a9723ccd7b7662ed20001b5952f496b0799894dbc901a9ca314d9faf82adfd45cc1e4cc732b712bcb422a63df9466b528e0d63950bea1199b1b6d57796c93bf0138678132b4cda17dd39aba1c1e74124bcf69f2316b94fca634cb695080db5e86dc0720f1554ca4847c9f3af89d453ed32b1c1158eabade739145b445dfe56f753e373b8b814dbd50b67997a81d7b706281a29357a4fabfea4dd413710206bf0a58dd18bab35bb5beb3415efe680eb57e97c3a27f1675aea5e8154e9ead0ade7086e40fd89a3aa633f51358faf9376d13b94f94bed47796c5d9d3df719a4733f811f36c726ce4ff2be49a2443f95464269ad67a656fa098304eba6f70d836099325b3827055b06799198ea0cd67343dbf420358e41f71af33ca0f9eb9bb0c00aa9a0a40fab38e39efaa7c0a3a7a2dcdd897991479702373d9e52733a06b5588b66625fcc8cb126f6ade5dc3f1089003299b50f51fb30a47a875bf63fa1eabe33ef076861d8a1747d7630b38e4b2c81b8fde72157cae530e4a2cf1e8a5e89ed5288827757a26408f687760c18701c8d7afc83c9b904dc172954e7ca0bc95ea0742bcf2759ca1bb6ba0de6fc7c66c029691bf136a805c7501e26014ca1b003b04488bc0995f948b75ab40ce41b1e9153d3bd2278df944f740fefe59a1b5d85c077eafecb976e031a20565a1d5b122148ff7aa02663c0841f4807a49eb3cbcac7c301d2bb88fe55f4a9f5324a4ca952fa563b7c53c5b5cea032c216b60f15b429b07bf2d3b03ae78619628cf51b778c9888d536c19f1226df4472053e3c8d083f533b59c04a2d4f1d23c40ea5ffbd343f20bdf65b74da6e290a8af34e22bcc5d758a3043aa5ab6871230cc27591746b0aa61faa62f19b50cc4a3afe14578127a774cc7537c2f9c47ed96acbc1b7505ebb38d5121b9e7ce6bce6311def3c1d18d3c92f9bc74f84f10b20dc3582368abd46c2a16326c155ef215a19b5b2e9ece7335bee0d13573c2a279d031d1115a231cce80eee5f70667b4ee4caa4728378d07e22e865b75e4e687f9cb82f983d5b6892f0c145bc86fa134c022d0d073c248e9eff4474113e2eff1a156fa91daaef39c118027656b7ee73b0fe76e7448f7fd8c2ac042584c3c42170bc0b922ef996e409e85fc6ad1e15692eb820c018aa90061c0fe28fe7c63dc505d9df708ff451073915a79e7e3101f463f83d1e8e45a35b10c6672c55d8f45b0da181c2c952868bf18c3784fa31f7859a7f5e80c20ae0fbe266de85d3a5502d381638b358ddeec77b67880324a7b00709bf94c46a7f82498e57db03dba7eb1550214443d95fc67d7174c3f69bb7974d49b5c73248fb32c62e29d6f5c59d2b7d31f449b9bd4eb29dd8f691b9647eeef7f7e70449c94fb81392e3766c03a117a7ff8dc159a9d11d3fd85974c82aac649e6e44f16ba77261276f41185e1504a444600934a6fb3b36eb224359e46669dedaaf871624c6de605e32cf06f8674d933ec3247b6f413d782bb0fb597047144ebe061a6a0d61a02defa5e79369587dee1c045caa6c1dc35ecd0a262c3bad3d9a2a251a2a07031b4046c9d197da9cd6f2149b3859baf2d288d3c9e17285b1460bd09f6d7d207392628369dc98c5967c06136a543c516415cb75e7ad3a21bb12944cc69604d9689dc1d7f0615a2b4293fb58504847611b168952dcccd601af67bb4926492cad9ae0eb74f78ae8aaad89d1bc12e2b0f3b05b15df4acb1d8c9cff02184dbf1c8f75cc5fa0b194af79339a06cb2ab98f7e0dd79414fe3d3d0c98601e32aab4e8c62fae4f8e39c2919f530b2e063820ff8e74ae8a73dcd8f694d6bf6db97522554e1838db07dbd9fa4181bba7559064344330694fdc5797bae4ee978b821479a86f0f9d712999be3f23ec20547ed19f5ecc15ca48148327233bcc4ef177f2eb7218d31f7b8713bd2dc4d65d24428b4957e77fd63bcf0162f238baf33aa16d75d13866dbc886ed92684b90193ec68d9947e1380433ddf7bc74ce4a1adfc4e2d562db8d7feb6b6287f7c43c42798a0deead926067e9468072ef55cbf62b8d37c03db3a844f141c5f415486761d2b8a5d1a80259ad319afc6be273f4756ba835a3f72b1af9d8b11f4f432dc0b38c999fe8365cfac7fa1deb1378b0b94f7a35ea711b9198117916939e444b6af30f7360cc51e97bacd76559d52f521299081c4729d1e0eb85fc844c140254ef22eec48caa63b79b2005286fcde43c880c0810ac7555f9f7410844bbdcdc7ee33f79a7f740fe67c10532b5ee8e020377ee0d98d80bce3983794783a7bf3f21cc2c5091a791e227912855fee758ead4d5e5ffee0d4f657c71fa5ebc71ab28db19d0802e0799ff5fcb12be43c666a183baa302fd7de3ac09409f7b2276e96f86ad745383103a5c9f088d9de13b942bed631bdee4af1ed6a68d0173085b35c479aa325f10a07f5b380e22d612a02fd808905c363989fa52ece2b1e322277f6b3a76edfa743b05480ffa855a80d7fd96c44843dfb712a15c21965386148dbcbde85683a882b143c2884c86b8f7bc5aefcab8aa20471e200fcb0cb4aa5f3fb510287ab140035b0054a30bd6bf3e950571689e68826225366309842bd6fae1eb4f0547f66aa4a21a67413560255d83ff69fa0f51bf2c3164f8459c531fa2f3cca7d405a1e01c02b87d04df64200541fb88e11d8da0b317c9c4df0083a5a397157eede2e6eb15d189b9e838b6dbea2a8ec001d87c2dfe801a49627bcbeaa2ac6865a90f04db19701a50bf9694dd46924cde1ce7ef5248d0be6787c13bf60cea6e0c4b7367fd8e60388be813ae8c7a912bbca6c088b67d04b216eec058883a9a21c4bae8d23a0a0f42eace3f2168792407e2dff2234ca182e97b9e08c22ad5c6bb0cc32c14f46ba2bae8c7d971e97e1f2514b7df0a2934133d489529465caab22aaa1a7fa0fcd8b9a9f872c8bd883a4bee35fb87948852f3030dd7e579af04c7f8fab21fbca67843fa10f364630a008fc11fcff261c2be034073260644b4168b32e615d5185437490b849de11b998163576cf0fc618c0c30b9e7fdb68fc9fa89165addfa5afa45532d96ca9280cdd9b97f0b17b4057c841bad89e3b6e74b6e670c427e34b1363e7846481d8fd55dd954b1e93b240cf51ec299020a613e4128c908b170fa89385f65a101337c9d66975b6e3ca804ee3b648c658f636a27dc5a7c397e04cbf5937d830cffad9576dcda7462f5fb1026599fb7f8f8699701d1b5993a7e30f8923c836620b1682d0046f01a2ada7d73820941a3c94c54caf229ac8dbabe5a026abf4edd2fecd1b514c495bee369711233d5bc9626a063a26e94f10d005d50dab093f4fefe61152c0c3485ab8d88d6e6d4e6325e61ad8f087c5df1584f56abd08c572666b0317b86806d41817d65147c0a9cc5188c4db9e1b167609c948ab8a4d4f883dcd862e7d6f572d691278305b7590fbedcd7b23bb38b7089cf182f862c05b915961b3e0382dab2b5b21b68a3a24452d08ce9ba205141a905b3b29d01dc4ebf077b2262cf4f3b3955f027fb4ad1f87d5c0c50f9983338a163a399c600ac678de4073a2243e0cf9cf3061d1ee26dfb8975fedb767fc82e087ab5c4d38864024d174322eae62e8c62e143d86d01d2bfed47bd5af8c0536efc01c240681ea3be50c3888e9039bd8d289cda99a30c844bbd92dd3ad4f44957a44adf0d45b7347d8dd3c2a3ccbc4544a6e9ca88c4413c1b72192442cd85caadf1dbb0c7337a40923d4a0d397dca915387db9c4be4a7ffb280540416c84b428e4ae4682ce2ae1a6ba63efb3de7303e444a77e32a6f53145aedbc72c23969eb7ad4be5e0378fe7d8d78fed0fa8f4c7edcaa1d9a93c160b723560b30bc72f574eb5471e739b6a3c867733657017f1bf6018d38d794c3aa62827d860c83ece944d7f61078d03745fd2b17538589f6be2edcfd65b6c01667dcec3f33f9f6d26f5d38baae44dc09f376e7f49e98d10895bb6846a5e7dca58d4ef818f63eb3389367c172898eec5cdea95b8ca9a1b7b16126d6fcf02beeb7fe4190c26d16426260db10eb8bddb7fed640428331363ca7c350b86d8f6a00d887b3fa61939521bc8f6cdd77c929e950c5bef585441658b45abb28cbad6a986cc2869f186687326297e813afc08723b18be458c4cc3816ba490aa08eac0822a5adab7cfd82b28bbb5465856b50f7be991ca366558a775baffeeace7cde585b88d570287a5db983e6fc119aa987f2a7316fba93889821561f450a1dbb0a9ddf09b593fcfbcc87f0095f958802813d60cae47bdd78bb3b85ebe34d9a4d989df44fdfc8f9574c88479369c35abdafa447cea1d283c9abc893af2f1ed919c4d5780bd4fb9f629d0080da8a607dc2993a678b415b2396fbc5a641a07f0ba5eb57ea1a1f6e088f6e9b42fcbb333558dc929d2d1871b8524a4787ea0a23ac60238fe30a30da7b5032d4cee2d1b399adb5ac10e3fedc48a71f99f32c98ec13e3c41d68bf1c71e7538781bd3fdd274a216236c4ae7bdb373f24fb2fd49963508774b6c2d6dcfdfca8d830a6d6f7f05fadb8801d6af3079ee96ab5a0590d46c741f86e2b17961cd4a6a53baae27824b4db52db3e646e5e17376269252a901c00232f9da5cb76566a98bcb51e8d7cf53688eb7bbf3353f23295075d3a42e2284e92a7c44f0a77688e84bf51f130827f0734742648b6f1631925fc91a3208ad9c2b0628b8f79d5c868ab8883c5d256af21b449164434409f3977f35d9657d93791526025f2f7b67a87dabbcd83d6762df5079601ac5acf80d50f2d9d7419369d3e83680e5fd52280bcaffb8237494a1cbbb4065eb9e2bd227bf2a671c717616014757e45c29b8380057078243cce75ac3b0f15cd83712aa3107d50f217385cc94a22e82180ff9c9184a5ea4b2620bb84933261c7a7a4cd5f7382a9eb70f578509419a9815332bee59dfde1284c871c54cb4bfdb3b019df26f8a3aa40729f3bc26fb2c22efe32ba3d0a3380f65006081e7001160b5d73a70cffb1d61d6084c364a8bc0e6fb755e986406bf7ccb1562867deadabbb53aa13f699554feb6c4cc85d8d464239300be5609be71cf986040848c4638eae3838d931315b9c328e47d27e330fccdcbdf9fe663302c3f408da6dd7855517818c932f8ae2b8d7e7c905d23b4669417e52a0b2af6c70b0dc09f8e5a7fe6691f5955a3dc0259f1e728f917abdfe451655b5b5f193144659846cb6b16d0d370ca9a6a3c46e893359aa4be256ee2f581e8f2591b75e6a2be5f98704778050ebd8437af2633a94b60e64a51d9eba48d97a1593fed7862afd2c86c8f6afd08d6049086b9baeef95fb443bd6452c2cd5fa870aab917a7694942f8dbecc33d71d91c1c53e2dba50557a13cfb7d16022703b069ba5ee3ab4fd0c698b849bf5d1f25cff712222cd0db6d5e405017df2e5e7d3b5426b154318617fb0eef6ece3e1435efc4725c6f91a5fc3632a3be56413458382df1eba6eb170b8c8308f17885f4c703e31d7c5d083c5f08a772c018d191dc65d614bb132d0d5991cc4a53cb08d8882a47c45da89ad87f0ab8a1e5f87fd37577f7906a8c4e09af5ae5cdb840918b69eaf2c4784a0f0ce8a330de8b6df2db23e8f2fdd7fea81d356682b83acd0370df65098be265422ed16a78cdccfcdbfb82b1d8a985359b8d00a29d60d684f17306ae1fc558f5cdf5df65857d1a70a09a6b702c410471e4d2ecf170c08baed24e45e4dac9380f6bc67313d910194f4955f3e2c52deb724ea989c69452d3c33560e8e21bd60ab603a5afe47baafebfa7f23c6be6e0256c91e5dde81d48f0a6df3891ec71834521bdc12974b37d0d3e91841c2494fc0ce55ad93065abf666ea091e51789363e751fb209d472c4f6c2b14929eff92ac17fc44c93515cd139022c659314953e34d6eb7c38e5cbc38058990328222243d39d21d11a398bade56e35d965b76e1146c3754e9cd28c9de84ef2758c32838935cc9e39c83ba559735907976e5ed8876864c476df2fdc7bbc64edefa37ca0341b40ccb28ac507da3752e8cc89893058e582b99e59c2f1c65dcb86284e0fd2428aa3edcfeffd347700146deef71c01e6377b760051b634369314354bb7359b7977d2122082726fcc754eede92bd99a9cd9591935617d90f169efa96c00fc4c7c8a870576583653df74a617b186a10032428da04fb2ff478d08bfcb216f90f7bd137e1c5f7b3def4035e5dd1bc68a5c5656a21573c3aa378945593ad58752d67f20d69a05b4ec2136de8f3c9a14b9e67e2ae7e8b0431a124457229bfc309000181fbd2ecb999b2728bfd7fe1f54ee64f4b974e0761da40cdbc1058d3abf6836290ddd4b5782117f6780ae9af97f244f015b91634d94b0850082006d6d3be9691d1b0ea7977def0bb3f82667bae8beaea4a8ace697636589af53d70b713127f517315a4ea6ce5a7cbf22be09eb50ba944d78cbeb3f678df6149b4e902d8c2184aa7474e9992ad4111813d1132bd7c9a9586a2d0b68392694b881a28acc9732cbeb103d98fb0f61beb56a4d741db5fccc83b6f8b4b530eb554d7ef66720f476d060f2768f9b277f011896f1850fb2a33f4aed9a75af7fbd2283e7414c6a257d9e4f2fdcc602974d3f4ee484e2d22974270cd53a50a5971c89c65554880b860e8ed0e7780c06a697b8a41233392947a3e88b675f75a0168d70a1b2de46a89eda2d50f507c95aaa4754b8b3f9e5f98f3013c27202a4db5b85828c8f4047dd0cb1c19f4df241f2a9f0c1f9b39d5c3bcf4c0de7d6dff93100fe678363b2ca3945910de628168f16763c359463c343bad3561c05f57c7448eadf069af96f6b883a0518f51107ffd1e3109ba4fd70d5c6390204c07685721a3960b05c95819c519397a565bf8636211b4cfa38668ad9b7c5866663abaa74a7c3d4ac17dec1908d4b6ac360c196a8c68c0c971bfd79dc4a737b3e2c20e9f5f646edfb1f824440e0d5c7d58c76d17fc9cb0cbcac19537523c34021ae117a2931935657c6e0a8ee4b25474318c17c2e369fcf46c815d9fffe59a832d2c01bd33d3c0c99b77a7af1658f7fbb4ec39fb9703d325b9efb8e532811787fda2f1faefc90a66450c1355f30f9dbe056365ea21581ff7718d29370627046619999ad93c476a7bafeecda5e9956b7069377b0373313354a18d79cdb36417251564334389aae8f913f97cb01f20243fcf212b72b76bbf1de6ec70f5285c5d1b89aa132e56dab5726a079b06e4b0b28dbeebbf64f28e09a386c320e14faed744e5f69acf9b5d3d2fd6e72fbffdcce32cef43ff7478c28c277634abc829ebbf3ee1bcb954d610e205a84bb50f4de0fa067a1a960ecb60621d0e2c0d26a240750a93b36f5f063e95f87a095f368fc13c7aaea1215e66c9d088fdbd536b166c0fd87b5715948db3e89a5470f041d6bcdd492f114eae784ecc3e50f0ff0a754d06221a3c39c3b3ae56c0058d5a5aaaec420c1e0fe15e21e3f2549b75c92c408854ecb924dacb3b5f961a21405cd189c04d590c2998ee2f8fb1f26ea27da7d74b555077bdbf82fc1e2d2b29478d3f89b9aa94cbf569f629e9e672827fec68ecc7c961ba3e48ef93af111d8b0d20a4fb13690f96587f4017465906a576ec052de65094fbc6db154fb0a3ac52b07ac224e7e5e909250dbe8eb6fd785bacfd7541","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
