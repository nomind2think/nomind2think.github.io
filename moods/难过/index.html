<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fac3e21ef53aa53ab924d29c52f2e4807be5b7348ff8d466dbbafae9e49f07caa064a4e7fc2d2ff0f4619db13398882610443c2ff8529043356a61bac28f7e8b3f5f4373eba5340fce75b4bc10a98b763dcc238c7ee33e6b7f982fb84948f6f65fd5b49c7875e4a83986b21b3f672d04d5d04cc861923df7e28081cd89e13ce78e372de68a8c6f4c4ba405e4b2f6e999dc3c7a7bde1692f71e9fe47b4ddcf5ddd8761b4eb51c9d7cd46a7065268afced137059ef20f9b945a3db80bd40110eb89e21c43cee0c9540c8b70d22279dfd3e2253eb5e238a2227a625dbc9eda1109923f24ec60bca38d0f88ca88ed5b555f9241e6ce1af460dd58b6134602d0431224029adce0d63bd157c32acd715f354ebcff6c06d8ce43bcf056464a89ff06403175156632a9fa34e9a107897ce8ce53e757e72de81c5e872423a3f7818b6978614e48076840c3dca970d80dcc27fd8510626208e2337dc8e5e31fea2091f3f58909bb2bb9f1f17eafccf867382cfbae0a47fc686cc6d91260d0aea3080388388adafa7d5720c77bbba159fe5280bb3b27f3e293b36c9a292ad9e2721f7f57332e524f68cfb84863b98474ba636665c1d68bab2e8e500ccfbe612b39add72d7153caa6590020c8bad7abf9be5eb1f29122abe391283a58f2f6bd72d8251fee37d80403cb75ae00248f5e88e60edb1c8789df16d7ec9938f1babba2ec084b0d512f921660fe1851e0c26b840a6859add269abd29d35a4ef26d39f06f63a6517fcd5d7ab7b79f59336a03aeab2cc779613a152744a745b8271d8cc06b5a6454377b71d348a9791c4ac1b4a17796d6d91282679de085fee45baf352b2db986cc9a0f886b8e821be983ebf64af1de8d09846b01044fad86b9da0fae0c0b244bf3509a14c5d825f6c7259535ea885f8d2ab623798f77eb5990b71967bb72037ee928e9a67449682c4937ee8c67cf2c8d0673026afa4f0c46b07c4c70793149a1412b3cbc5b822c7b4f9dce34a106bd556297b78d216996814fb0191ff992b8f0e7b15aa918fe39f93a175da8c500f3ecc0549fd0bc1d264e0dcd07f5228d7ad05245394d269876f5187255848689670928a31f1d43260bf0fa86ad6407f53c82a91ce3e46339b1a3bd4170f7b37a15443458fc84924135b8e6651a4499c1e992136f5502211e2c657922e8c6396f861ae2851e8ae75610289741ed17b98368024fb3219cd3ebd94f41bd0f830e7178a2743bd0774af2500d8c22ae8e08fcfe87eecf09fa30727e7f323f9e2bb82fd5a61b4e29a8173cb32e2ffb1c745394df2d6e0c554926164c5b5823c95b6b6ac77df83909403d7beb1a6c6c287adfef0fd1bdc9a1cc2f7ff598ed9e6f2b5e7f23a2d1cc68d8f754690c9de1d21ff32751c298c499dd3e4e8c9008b177dbecb130a78e8ed5e6eff3f5d35397e4a73b7958514300dfc818bcdf2a0b852c28ffab674e2f57399b4958d02a692ae4d514da709ad304dd0e562a00b4b6ed5bb9bdebc5027cbb2f31ff9cfb20bb90d5668e9fec21448da06aa03a5d8d30e41bfb94c427f942b4c305937461ece2a83532abafa9406ea9f93c67487b7a34191586e5c4abc391c2838f034224fd82b9299f6997f64aed2645c384385c1ffc522c3a976bc6c768b55ffe93fc6fa429ba015d97dfc9c5bf97336430581821b5253fc6cf1db13a3fcadcb4f178d14e98963c283ee2da0733c187084913fd557271a89d602d494f8f0fa23aca9a1ca82799b260ed6a48686dfd744af6b210beb6d44a21730ca81ea9563f3c1920af7cc48107183f4c17bcde3ca35cc00b59821e64973ac3d8ea2fe0ec1f877102e76d11a27f9430dedd96ce0b109ee9438ba8e82372eb7f7c4194d92f1453bf377729c892dccea8fd8477a4cb26fa31d78730a97fe8eb7cd422be27909c7cea3a491dd27af710dd98b47ec30f9b2474c5449c5e73ff32250e0490968ca9bc32035ff1741a4de408c47a0775e8f4aa395842fd74707434e133c9d27e921eb65d0450f24374910479c426e65bb7123be72bddfec5c8404a87a54af5b493e5cc47e97a608e8ca9419b63f1aa8e69ab2e787966f299154a937b1dfd8c5da76ae1186d6f9ab581c013972ff89a0ec51b97269eb8f03892c7117d72b1aea14f6000a60f4724e9c5321cd9d5b17f0fc89a9f96112b03f97a0af15701dc7f25f6c06f59c28e46035361f2b8054b78f5a11ed91e9015263dc8595a0e6a9e9c10a4abffb115a43cb4a7c7f4feb69b2fe507dd431bd1b8a3ddf06947aab52c995f78823e6dec56bb2c694773f0d48f47026b12bb4804af3e3d1402369f7e18313e002b75ba67457bd47bfc52f7efa63e44bf93b7f5da35f95a48606f3be515658ff8f136b173e1885bf80b38ca37ffa16e6d2d9f8f95df6bedc85191cd9e2ac93a748230ca0d0ea94c7c5f86f917efc7aab2e0a8cdff4df0ad2798bd01cdaab4bb0499f7db9fec27e53ef5ad865dec4a05d8c49467193746eec275971905eef5ebc6f268ce7abc1e8cb20b2d6ee640d879ae1b4a854b2d3dfa259715ada39db96c868fcb04d5198cfd27a16f014d3009fe9dc1b23f553737855ef9f01b824994900a22d2bea5ca09e71422cb72126d1ae1cdaedb298686d1845d48865a1ffd635185000cfe0aa2b481d66a63b76b3427352f1b0984be2fb1908dfe2fcbe62d97c4c8b0ec18344700bb9a19a05b791d882b505f9cc72d98510d07a244e0b09073b8c0860c6aa998cf95b847a916a54c0b0f34ff7a695cd318a6f9ad71ce1c4da8998ddf729b34f31bab868ef149265a2b67b5f77e6743f7c259d773ce4ce7aee39b85b55413b740029e59c4c52355b5f224332c10c9a1d1290357a41c0ab455b36747d4735c0576a05b73c88747c4c261436e6d197ee0baa275d4481d5119969576142d4e73b0c26cf3b93c2835d5c454716fff4a7f996db852e57edb1a96e1953005a05416b19179d53509f249988eb853cb7aa8254fa4e4aa6ff51e5170d31e24db6dd07fcbd1cf06cb9d47fd78f8befd916bb5186fc7a32d15718bf357803f46197b4a57c930e757ad43ad9806fba4f46a50bd5c96d6ed5ece568c643572ea3eba92643e8b3af7cb6f129c3a8a0156a92b6e516e788d95b0fdb6f21ede8adf5fa8a82bc71aa4f0daf94b153552156fcffe4820b2651f3ff7861d6c5da2550755ec5d6db1d6cc5c60f95e21d5867b24a90bd78dc1fc098ce84adbb76ae44a142a9d7e6942a3a7ac97dc19fff646102128ce1ee8fbba0dd3606a4f87e917319477f1e09f58fa57c94f32e3fcda475b7cad34a780f1a4f5bc22ec0a4e3d613aca7caf115851a24273fb11187e0d3f65332362d88892b92a08fb4d12072bd269fd82c85bf96e452da3a6897428c7d0a1abd4b87e55c42ef840b4604b8d37cfa1c31611832e20e3a86c1a67b8e1be4fcf67f7548b5f348cf978800c08688ef988c9d37952a00d35b55a43c9688ef40f4c25e31dfe305223876122321fe7395e93ddc68e04c617e569eee2a209516b1fe6f188c13943b4659e8c2cbf1001f4a05328ac0d2844f5b2558e7b4540834e232cb645405a92d04e059437add954d0280a11249c10f174f8e8543c56eb9de0de7f0a09a464b40e0cb85f315c0ec6891ec5239ece7e633e3b52866a381fe8c41e62337985f2fb6fe748d7fb5234e86602b73e7245e1ea5091196e46cc554fab75bd1ef86803aff6d55d4810d7e549e9583b09cb8b1dc34012cbc425f67cbb30adde5823636b5fb7c361e64cb1ff7921c56c7754290be972ee87bcbb811017640337892a6b797dafc739f145ff6c0268db70589afd1f752eb1f2c26265ef4d5e5b4bc370f62fbff7cf88124a78c0554c4c44de169681846beeb6b7659ee140ee3f43cc7dad12f5e6fbced0714d54858bee6112ab1ffb564140ae7cb517885b09f117b7ada4533f6085e087ab0d3c26e6cd9a0d6335e6f5752cd9e41693b06d9cf063b3afc2c91abee7b5a894ca141619a981ba39d3d58e2b789b25215b847123d8d9250a3ab6966460105758f4431731c0fa417537e1335d211aa004f041b41e7558ac0677bb8d159be4871fe6483bc8a6da4a13d641705dc6f33162fc662e0dace8078d0d11f635feec22fb797a7871f5681b4858e9c22ff172cfb3e7ad4ca896abc40607e7e2f7ac07018f21bc40846cd4eadfbb2bb18f3c026f05dfde9ef186a956c67ab5196e7eb30933b8ecebab094bccb9e46af681565474aea00fc9c7e1b17250cafa9f629365ab43a8722d0b700cc18f78fb5e3036f299f99b06025c5e3d55d5cef7ec99c02fd48cd36afab533ec3ab3d12271eb5fb0b697fd72fbf4ee6791be645da74189ff45003426159620c9d6082c64a52c343010a44233ad97647af1449eee477a68c7ecd86cbe4d7eb3e334518a8d702395ded50053d641736dd989cef7797df342550f9050c242a517a59444a9d7b7a061fad6d7bdc61aabdf66eb65f7d213ee16515d64a8fb9026554667043b6f2c6006e9770eb0e501414875027c431f18046d3aea329317419d87dbb86d0da6fd8601b1bc6e902ab4b75b9ae3d939b1966e383d0f956c81a131c6e81092139031563d497d3d2a65f909be5ecf9296a2a22a729383c7ec1153b188d25aba602b4a0e7961dcf36198b7e00b1151ee7a9c9223818af5a54035b06b4fc3f3599a1ba5c796d1804b3ddb800a74d4d4db00dea129e75c0bc193ac01588209f8378077448c3f7ef240bd535c4611fcb0d051ce50f98d9fecf7e432bcbc0898757083552331bb96c91320a63e1a53bf3ac42cddb172998e824aa93ac03c44f002cf26df3d2f6461462e5b68ac197d8f78d17cf28b899c33aac408078388b8a3e7b53aa914ae8b4689de6fb74d927d1441d719e4528793d024cc3c3386376592fda29c3c17d6dd9134a9127f6a7ee8873f454d9acfff66130841f82f7661e8ccba53f399803eae86e78d9697167632d5c8909d43f6ce420a803b8ffef50444567e39ee00964ec990f2ef0fc62913072d9a08ee3be6fc89964a6b8ac458a17f04ee2cc9024c4fea09c1667a31ad1a463223d4386c28b8491c826af387d70095c721fd3ac3d53188329b2cb8a9028a1ad1135d76269c24a5f48f78845bda7b3e610502ff523361423292f6d8b75aa38a5a77170e989809b95046b1598938c7c1203f1eb9c3cd9b4b4f13fbaeb15610e7adfd834b54b13db1ea99be44bbacbbef110f459bf25b80d59847857fbb7b4844b8310754e2f8ef73884f89cdf8357904e4ac44e452be01c2740f627f17271fc2934dec57403343399176543d2b54bda8f4c88e8d61cd8ae8a8eb569cbba7c34dc52e36067fef2b6598a34e66a814784fabe7a4d50b3cf49c0ba145142beb3f8ff8f82f8599930de72233ac2bd819cdaef12473568f56c72207dbdfa3366d7b5c9981686cb24b852248e3679896341fa700d36b72cd425a84b770e9177aecd1982151a6c209c1023bcbf773fa262b231fe3aac0eeb15abe5d3e9507f85e99cf497b331950ff0468aefed453ae31d8f4911c14482d02cab0d0f76e064f592c2c8328c28e7aa9e059eb242b023fe5e7e432840c68c7161b6e4d99d925c1a563cac48acd07324e73563333e3269f1f2a5411a81901bfeb32f13edaa21df019f38f288894619fea2246370380441cec6e10d79adbe57bbcecab77759ee4908296caabb2ca60182f7c245849729ce3b4660e7fa55594d7aab6fe4b447427a70e08d042fc4a784b380f8b48767b8674a221252decb9c38e7c99d5f02ac43b5e3bd533b89b0ff606417f9e9d7edd750cd66d9a9224777900a404c1bb8da7df37b7f8db14355d30ab54a62eed796185a7d0f6d3fad0f1cc871590d4cd3dae9162af6d8c74526c9a8d4e5bfe76ae268bf37f23e4af8acae632dfaa2fee748a3c3dd7e07c784b756c552745b3f22505574d2fa18417162c22180d0f70b686085dadb1968fdf71fc2a114fa79e1fd2df95898db6ea44f5c5532a7140c7999ca642dad046601ca301435a835852820f26f42a1ed72641f812690bad3a9cdfedccdd697a0305d0c12e79ec1b14de71f48e5a3087bfd481c872d06a4f480282397fab85509dec18d2ead9e5050ce942e099499c3e5bc13cef151fc1cd5457d1af0ed1a3bc747e5b2c44cec857a44273748af73418922aa0e95f0011d6837783156c774258617173e0c8f17c6c7bad6fe80fe4b03755e952ab3a121ec93ee135ebccf62ee4eda0ed2ff4f5d4d8ea1df596024fba307c30ef8b8316910873faeb39d4e01fcd6f6ce73e43824b3de00bd5326afd63a76175ea1883db4dd315fdd563dfeff84a7c95127722c5a6a2a1be7c4d60d05e4073c7d308aa249ba6e23e28355b652a592a29cb9fa2148261615c9f61c704bb37047312bceed0dfa7cf96a3f2e0e695d1112b0edc57a86ab88308c3f309925d9345852f0b7fd632ac9d5d62f3346e3ed05704a53e62a3c272208b97ba2bbf332517bfbfb301c8563147bdb97f95fd86644c9650c173175d5d5edba49416f000edc32cbb5958785866ba2916abd475b3a62499bc9f8df3048895483175f7ee66330828d5579a14c824c4c075073d59628a44a74d95376444273fb02041a41952074253cf1bc1a6caf0248c22d9bdc00bf96e18e7e9bfffffb3d6e14bdba5dbf42a9eedf8329eb098b2b51cc2f7b8dfab1b61e7033abf5dfdcbe07b63184d5a219d4aab1015ee0b002d9d2c75fb133ab245586e95f683defe3f916ff28685e06302512e8200ef24a30018b1a02ef1ad4c6bfe7c41e6fcac7e1c271853d02089424d5239b3a334d0dd991ff90ce4689a2a57c5da1744e1cfb40eb8dd6038d95bc5ed6b4cc90b649448f8ecc375bb65f23ed33db026b69fac1451b5993d483522b7275d39dde4c775251af98e5a8468e129d48acdc7b4667ec2bf0e3fd338d2937835202cc9804bd6361c2dd1db1f8dd2e073228643f05741f8e038168f6243319f9818a1f48244406a9e7953b8e25dd0d450db9be07afc65109760ee51a9bb16fb97d77ad148c9d3504cc431cb89fae798bcb90f3181a45211d58c08f1a6c217d97a6493838018cfa8f198a0a78c6808a1b1ab0eae5190f6ba0c0cf9757be74c39f1d5f7f28ead9f68644b589588e8def590ef75525c72afb53a494a75f025e3d862f4ca8c67c9906bccb4fd59805eb0b6fa4a90361decf1e2d3849561fc7860e1a87f2e404792c2612601d5f3b63ed75bc0bde5e5973f7ea1f111f1cfd08ec9602c431ce0c5abb9015b2f4467dba1572762d3a91365570f9f6fa419b82972bc90e818a2c718d67b685a47f6c2126d15e9a90413f0821282be48c75a6717b784ba90f2fbce2cc12093c168e20cccd414041091b4cde9696fe4d8b078bb392b0192dbf0fadf7ebbc85c320f7242f2ad801599c9c22f6ea5165afe43244ce437394a22205b4185790201fce9e73da11e21fc9a14ea4cb59181a03cb56f6cc048fee944bd86af0e6a68549b95a09f6ebde13dd86b2edab548cae9f482e6a40f10f930b9754fc0f8a8d94acdaa01ca71232f4948cffa1565ce013572594b006c2c6d2de05ef20209a0fd6678507d07d183eacedaddbbce0aa6cc714408828b1e94feef59fe9d1fb497fc72f02298bdc100cf4f8abe11b6841435f97e1c600e3e0f5e91dd2b130bc632a14df2460399669e83737b1f51c6e9f21abdba837094c768660a24db61d46e5412a67815229a2ee2833fb54b3a8a8e7997bbccb95a1970ad1a448cfa2ba334582242d9db7930b1877d553101db188ed042039a2c96aaecb052cc8f45197e6eed04b26f931086c20ff3c3b389c04fed0df1f2d40007977c91fb16149c4133cf084b477d9dd13ab2eab53366ac1f683fe1d0f4d6a09586b18046fcaec72e0ef55a1fc5c0ff174899bd627f6cb308d0bd9a353238dc9ecf164d6f02ffd28b6537213a64b44c93050dd716bafc332fd5ce62285bf54547bd647482da7c7ae2c9e268ed6d93415804cca4d8385db1ce83a7b6ffc138684b10b3b30a37bdddc4faebd3319a1a8fda1d13b4acef114aedc8741326d23d7dff4f1fb19cb913eb9c49facecfb00a39662f1fa02402a607e2c89a04d36e6e58af99d5f9e488b73714c6143bcd5b99de55cf0d9e2606f734236673b98bffaa83c56ef0b94bf43e72c813ab0e810d67a8506855548e6b3bd3eba013247f028010de9f8965e42241a90f9a33966f4c8046bc0705b53ef25373eccb36feff860203a54d46d6499bbb36463be0c80db536d82aff59f4f8a543e67193db4dfcb9b6dfb51ea4a7b8f5905510cbbd7eaa90288d5c495b4720158f43ea59db08a61c5a09d141993f2d438eb489544e65373799845d74d3ca9cc504cb31789ba51115e9239260bfe1b68c4d79e72513f97f50448d6a14f153eb525cf8ce2d551c31379e689c194f5b33b409dcda881d771d9c151e0f80e898f84d0a8b07338cd953b1d48eafc4a74a1ca7fd52556038b1c3578a273bb298af01289f104be8692a4ea8e981e86713fd5854183f7ff4372b49da3fbd65e778d1f5fd76d8f8083aadbf3547364d91379fa94c7bab562788f812425236792dc4b23327cce823d96360837789a65c4ff1b10bc974c5d7d277c71b32283c6fffdfb655f04202f16baeafa3ed7f2f9ad00ef56075386091156a02a014f44eee3b489d9c0107720a9a58990997ce7fe3b52470af77e57c3c6419fc0b130d17b0bbb6a1301fbea254c05f60e50dcfc78b6087f3cc17e99a5bf18c1d6c3085011877724b41fee2fdd67ea4b733a96010fb68eab0eed7014fe27ee0eda8c796bf6be014c20b2f23e2dc963bc42e15f09999b5db7bc4663876a510c6e9ff52350d695b0c678625133e450eaab6837324d5c58aebc9a1f1bc5b1134669e1a1648887d5667ae41ecd6a726d7adf10da61ff8d42640bc3ef747e4d9178d1846c4d136e210866a7e24138473565537690e9029a5a48612c17f368f1183cf98e6822ec051603edf1660e09f78dbaa652b81caf56d02aa3bdab89ecba95cbc511cfe76064296f9eaff26edcee10c2a4fa792469e3237fadf6f431c43f27f278d0ffa979e94d693419bc1cf5f849f8c5c1d07f8f55b48ad64f439d10a420397fc6f9e73cf533bfe2992840e92c3f091d822a630dfc8e6cc29f386b79c2a3545130f55ad0645f3585b5b5c0c55cedbdd216962a4123fe1eed41be8f0110b7a059489cd8d74e2b2248ef7d5c941344b5d5eeacc50844f64f0b30d5d62db951a4e52f1375ae64dc9bf311f3e800745ab138902a46d1377793cdeb65fc82e2d1827df792bd079cbfc23c1dea13d02414f419ae911053ac5891b349b7ca1c683932efbe63bf1f0efe798fd3245881c014c80e02345a68e1ff684c966aa647b0bcc9bf1f63c43657dd7615250e09bd9ac99ce5e3b3050dfe1dbe7820dae76611e56da83075bd1d6735abb1772e05f1b8c40c56fbef9b08cde2ef838bb637a1fd31aa708ca2875a2363548002573beab8b3b361a03c8055de000323ed10842cf10a04f05908505b8a16d9535323f574b8605e8d481bca4a81d361be1277dea768c3b07ff269d0ae5da7fe7614ff84b1405fb780842c917c7333ec6068ef68b2f147c3f58e8069dbf158ccafed448380f477030306daec7c6bdd930bd7a81321bf81ff5d8b73ee041e38f0be88374790466505b10572b104267ec76edf071b3be510dfa91dc7c418b7f05729c1aaf2657a75f1f27c338864a3e5f153a0876a929d520e3f666cd3131478ba6e514f1fed233ce16e4592f26ac93bbdac224da6135256d9b93c49232b9caa094bc6dd3b02bf4d2e2718e93e2e3a11c6d7d29ab8d92870b934e1568ec097e03da9f1daffdb00db3893a9e5fba0bc6f4fe3897dfafda7f39b2eb65366c89ba7428a889de24aaf82e5e5e73d2fd0b65c0c16a898e16239ce87f75063da4a791a0f41e62913ef2f469c576df244eb5c59db79595cc9937fe862dab36a31f96ec1ff95eacd79f47edaeb5c25f617f41774fee76fef32bbcd3f4ec0ba1ac08a71c21966d89506651a36af1b38d79be96f82415f1f9679ebee7921877ba18d27368317238c49f1412c10452d1add95a7f6435656d3308b03f4637dc820d11bf1b9134cf5d7d3df3d4aac39c3f091f45afa7bacbe1e36eb0cb0f7664505731b685d29262bcb57337a0d4968db722f31ae59ebb20801e0159142437266ea295404466e3935ad7a71cdf53227d6876e20715e7973f26abef2c9c9bb961987b657b5917d0ad9ccc245c30b836585913a68346df5df9436d7f8384ffe14bc8386c689daf3d1f797f66765e919eeaeb49c5a63caaceb4501700de182b3885c0b60476e2f2583b75f4cce26ee4f0d7ae63f7e8a95cdaa2c160f0fb90f6cecb3813bdff4bf460410cd806a23381354147f6da3b28ef3389dc16fb0ee303eb0b9b3293ab598b4cb904a3e51d4d351592a20e42834c93f6ec022c328507b1632647287657a99d3c3c1e8c278906685e4765054cc181dddd5750d2519bfe3eb80603ae2a3f18830d629888e39bd2ff1ebb1cfea921bc00a33440f53db7ad7af866dcd99dfcf6ede406b179eee99c5db13dd814f42cbdcb7cb1055325dc3463594a6ad5bdffb811689ea639a7a496c341c7e130ac8bde911f2e38ccbcf21b844b9ae0341eb5597d6ecc9fcb9f3ea186f3f600586f38c45261d1206b808bc94ed8e97a5e8b9a543f563e248c27ba37ec1a4dda78265176643c68d5d4e965985d07653caf962589e7bce1969f0bf358d8e0921768ee9268701eac7269c8c2a5c6b29ca73909a4bdf2f53a51124185f9b78219a661a7b544184dd3daecd901b13a807259c6e8fa24be2d5d43a90924d65ff0c89ffed6a51c72fb353a1f641501b0911beb7d6b1a76844062e459014e2caef9c59caae624fe5b3eb6aa4577df528987bc08955c160462d48ed9aa40feb0759b3586fe564a83711491b3a2dc142c389cb9ae052e992a308bf481f299d4b7110ab8b1dc283f6bcc6e73e73c7414067a322d011478fcf56fa9a5aad3f685ff3bdfb1710d1fe3bcb5957f8dfd884f1532b963c8cba18b2c99ac9596fd224c94f4cd9006592f8541dc50a4724a66bfaf049b17aa9668fff990a8fe9b19f048e4b9021880d44cbde74796959ba24acd05773879b4a5a76ddaa543dc31d01961c26cfbfdf577c9cf1ae7f346394223859c1cb9b190943d9ca495385b3176227e8e509ec402081d2ddc09d7bb75b404bbbed2ce05d03cfb754feeed7ccc9cb3c6702626d5eb52ebd891970d3efe68de42325d0015c8b0f6738aded58ee5e4e1370f535e294f221e6244e377d74753473f995565d012d6357ff8db34a5085418cf0ee302b57c37660f8dd3330a3db71b02ff93cb0f7bdf453e684ef8cb940c56a886bfa2a9425f7e09b201b09aa4a271c374ce8b06d140756d893f02b20533395f83cf0ef8aee4a8d8292de7a8844fc99b555e852d1e02ecb3286d3148c9c2915b49fac5e5498dfc8a9194a027c60f13e458810ad66d39f07d4e50affc517c728daa22b912e1b47669faad16cce7412556045227bc9d3d2ed13def2ca92f1c7be814a237f6187a64e7e322d23bd670f26a57e953420af625e4a402af96b88c7ee2dac12498fdd634f80551aa1b30cb03cfad66617461fbd62c21acce21bc71f8c15ade0584a6904e1d8fdda7aded46f19fce15f6dd52eefdba8c1423cb4385d942d666634272c55f23a770652f52a42a3ed9bae1dbb6f9a4302a65405e6b10e51cd2f188859ad003b62ca671a8206419990db3be38290d7eafd11b4119b8ab17ee3bf66efd33b3dcd3071a631296df6f99a58b13bdc996471ce0cae20731fb901a57b320f6fa073558758e7343a33ed929a6ce9c503474e439d943a3dee38d07cb25c2047c49bd643e447ccd88996b523c28de0b6aea91242224cfe15ebf479a72c7f080b759c051ba78b80d42883d4c52964a893ed0310bc298e43c099126ec4a130632944292bc63512c71e172f5564feda56981978382e56e21555e1755e401708bc92f30bfca3c4c8180de5442f26bac65f9ee637e0436151ce8ed02b7a94064bf3fea4be55124a7ecff6503ba1ca02d957fb467fa04017de9c33d2de954015b205edc809fd9eaa12fea34a7cc0fde623a849039c5246b0742c5bbe881bfb6c68408b2b0d612b0c05880087dc07feeb590af4f6b6c56d38c6118207185b43073bacea5b97da3ee46744fc98c5d1ea18036e23ebafb98efdc79533dbb8b68522c727bd9c494cdf514ada5e4f5c3d33287f31519bee185f738095b54dce4b1c4bc5b34e32d8a1ce3aa6c942b94e9a48484d9162bb9af14ffe4cf84e14e1f9815ac0e3a4ffcd579d97d34746e8211362f71d494a7e5716fb04dc2d6e23a75a104fbf95c488807b87714b5242c799e5925db50a8ca2f9d123c2f067b9a0f041c82742bddc57f3d8305f0b96f7b5182c070a0276ae45ca9d1ca4090ce7110408be576e7286f784085ec76b551dcddc718ec51c2010a7bc1d5c6a4829f03ff7fbc1ce558a1d6aee4bc5974826597e0903f804ec8e8f06c2a1764875dfee20993529c61fb42c3edd8d391b93bc2b4eae1c25ec4ace41de6be4b304a607d2820ce0fd40807da2de69ae1d885b5549e507d912950f4daa0beb5a08906cce01c40d830b023c8c2974746afa39360558b17bcdbe6479b387c0ef66c7264194499907c803246aeffb91bdf36f840f2721f92c70a24dfcf7c68bb27c7196c44d6740c8dd8914fa69f93429629d8a07e27194d9e267752ff47e7c26047333ca888f029a71107d8fedc3a7b8de4d70dfd06aea78fde9ac0b8f6b2dac2b10dd1e6deb33962394ae9b29974e2ac62d2361517f1003353ae694927be840063a7c8f12c205613a42587ab399798d07f7547d30c5d1a9ac4c6793c9a2d1d0e0e3357057232dbddf765997e89f3ba7dc20b2606108b6727455a55c832d25c7c11603a43df95819714174d054a14c1c45f0bf6094608e70a57070e2fb24865dd5a98c5320cef2a4026904453ed547e5fd07c205e43a1900b6bdf835ccef88bf4306303ac320d8639de7e094d795accebfdc39201ac3346e340fec0f70f4e1a80b94c3264ecb79be563a7f5ae9c0a00284f05da3a265ff5a5f7e42c0552e43f06957c06e2cbeee78107a5b981c223607eb3768c972361dd3a2f9fc2f23f7c20186086da5cbd419ad68fe1b7895ab1704fa34c5fc630ea643faf042b0c4b99061ab85b2915c8c2e5081dfd1384e10220d59c3c66d67e6f850775b8ab8e30d866304e967c218bd26723a7c94bfee0c88de6e58424b88527957e88d2364b8e225823f3ee864682043b161a32635c8ef22d5a973e32a9cbb6db6d95b7611e74194053161aaf368d734e2d9a59422f18978d3e35e6dbbf523db0eba07113ed7f70591071dab918a195a1d6c484c9361e07ff418e1579ec8549c085598d35a827b9b02a1a856d3d4084e85029078d825131cec4083c308da70eeb6712874c108b0a8ade8beddc91a8d15fcbc5d4714965851dab54486c95fc331384847f0b6714ac3542672e20505fb48faf542f1afafe6ba878fda31bac8b4e1f4628bbdb688e01d9c189cc194fb4149136f13b39af1c43d789da30c8c5cc11d149058e46fa7a574d83abe3a23ec8b5bdf9a31210f9f3a96e63b7ffb00965ed5d36506e448f0f80e2a2b5bce5008dc221c04522ac43977d1047738d827bdba4094db969a035a4cfce09b05f130d258519143a307162b1bd6aaa9219bf9d9672a352d4e3619d069025fe7c6de8a46c437c178f08fb66896b108bab556acbdfa8ffa57ff747dc69800f0819f8e888fa210249f29e6361abbb28f01820dff1840a6606edfa757300e302d889646936b651574fea26c057d0bd4c856a2ade9d54aadd15713156da08c020673f193bb53e8a4707e150f657e762c322c9f30c1cb24659d4d1cc30dd9311c9fc31edf1ee61a1436a456efd2aa6a68e85fb61215ddde6a090986c199cc1c68c4b87b63cb2d7ebadd4e6dd9ae126b4f29299b716a7035200a6e1e48d1ca9d763c225b80cacb8d459c4397ea4a37287e9216ed3a0280eb595baa38f8bea3770d04b05b979bf4c1e2a4a1438a04a002178792608af5959aa739da6441ba9cc30250ef49b451585b8cc6f27fb90feec3b19fc1ca0167ea8d5c32be39da9f0a06cb73e4cd99704b98c1b97152ed761440d36733a1e9cec583dfbf18232ff4fa16a890bc9a0cb2294e395c0ad1858ee82c4b8e7d94bd5fa7999f48d138996a3ace726d4e1009c890acb37929c3f88cf2b021ab851357cefffbadfa37b21675f2795222e7075d515687944d4d42e47eed1353ad4cc4c4af46c49af654a282f3e984eaae3c73f3f6554e0ae388c46e087a7b24d57972b7b88a64c82ad8a49ca9f15a30f92a2b7537cb1454c715a0e5fce193621772dab9f45fbdf2725f007f1f8a406eb70d8b04c5cad3241c31b6abb66c8442fc451d4c3210f72610ea410ab8f65a6731f1009b23af30875946096a660957dec58e7a937738d02c673e2bb095bfc52b70883ad0162099a05f946fda57f6bae4ecb693eb4e6d8c56d79d4b809ec74ef10d6d44a14a1f119cda16f4525c104af2987b030c29a0872e67b7ceea979e2716a8a926722e9a182cf8dc846fce209e252adcf12be0cca8989bec79fbace78cb6b88ab1f9c90e9cca0bb141a1047492ac7f7342b075e5c8dee80ced2371bf1b84e44f86a6beff48ff5a6f7c87f956e9cc692c5bb5695bdf026eba82a19d76f119a39a932e562755ed212fe6b93ed8c0dd334e730cd7a5ca526e89bb1c89a847192d72965ccae2a44abd20413e5ebbc18f35247263a1db83cb45777e19edc4d0c21854f06977a74c0eae3c68cd2a21fb1dcfac35b333bce7925d04d2b2c58f581857903c0ecd4cb87b24e0a004afb0dc42f59271fc89262d147d764b66d0f99d1f8a95baa7d7f189b8b605fecc61827f370ee30a697fb2d78abc15d30d29af6d2a4540c70b1c86db325eec974551598cae6b8ec801f6479317e31f749a9d4c07e2594345951a669b4b8c9356599d7dc9bf95746a943b848cf1abdf0aeaffd89eb1fa3c1a8e201229dc75ae3dc7829d261cd4a0d3b4fa4cd12980692f212f2bbd39b4a0ffb136edd4c518c51c1b11d2424ba07fc091c91fe7b1a4cde7a4cd8a7a647838808f7516212e7d8bac5bebf44f483b77bac9dd0903e4121b69078ec9b03306535ed858067a09f3998c1f1ae94653134bfc2686c5096550f1f559343e5bf98bfa1d87ec0c5b26a1d4ce90e2b6be3152038b79af9204399c5232e841199b0e6ea82cbf228c93a6836fee1d0818fd6ed5b162e51098706821639e914779c8c362ff09d0716db85557887b859241256a8e2e566d8149727ae2ee1b5dd68c7462a7718a50b797be448f2401537375a76e4f67707cdcd0195a6208225572199ca05cb21f3db7c00c60a0a805ccbc0e4d6bc722386580ab967843e979813c1f2aa582fb19692dad4e4ae4270645a1c4667e2a488df0ee56fec1be137ec6232545e0d7a728be6bffa5c4713c530a56a7d47d049946d7aebdd7f3daa56cdb06ceddd5f8e2a851eaf7262ad673d7f370f039e17829bd37573f0db4ed93ae43ef5f62564a55907dcfbf2407cb0f3827f098f574fff4fdcbe5c48c3aa80e56b63b4bf83d04dff83f0ea6fd43798b295994f5e27f70a3ef295dfc15cae4e7775a6dbdba75667d927d3c994f202ecad2c2d66f96f0d786bc0b36a70825560a3f5cd184affe8bcb9cc0578d0fc7115e1e5f8115ccb07c5cef7fdaf487896f70d1dd19528f995e8db718e0dd76ec0f1e556ca95bfa213d3cf550a697cdd1dcb2b2065966221593956e8c7df7d10e0a734bf3cf629bbc0894f7217ae75f61a221bcbd471146b26dc161eb5f5aa0da65cc8570a53476e48b7103c289f940e293aafd0995d5c167cb9c35a26db0ce209721a84d7263401b92ece2abce4e7088cc95f68498318a0301e6b089b142e9c3fae354781b325751c1cbdaf091bcf9318ca91d2a76660b2e48f20bed7e36df83e7a54304b9e2e58af6caaf0b015b20a17b03fbc649eb39513da37beb4d043bbeeb00c5d33b99c5ba2fdbad734b34119d40da9276ed3c5c0a4c4fc93de6c051f5435ec111739cecbb9cf079f6a148b8c75888bdbab4f8bd9a74fd6448379f5171a36ab41454f6174ba83042584495f8a2fbe51f92547393e8bf2e7362111d13b80fcbcb79ad9527b1faa2688cc1fe60c39edacc6913c0fcb85b070c40200b81c3cb22651b105b651a9ed9bde2ab943e0a3384f6229937e8acf656bffd7872716b8278a7955da13b3084f386ab863ec5a86b275a81853ac5c456d9f73c409f42642211a4b28a47e0ab87a19d780326d4cb055e7cc34223ae0ee804f6bb9590c091c153496357dbeec0ef06e33127b8ae93b96d764ce85a31930f3b3bcac3886b38857ce7133dea950bba6c18916a890e24c2d86ee08c3e0b2efcfea8c706c71daba7b4069ee80259c295f2a0e50dc41947cd65c49737ff9c1f457cc1c7b2c840ba5436f5d29feb2eda9c70290045261b556f110306c9a0f28f25a3e3058eaead8a06ba3cda67d9967fe8b8352f0827da3099cb5a0513cc8d47cd6b5664bb6d1031ab26f43d796088efc4d1cb4170b73b46b1713a3fce9c6408672487983816413215b36b07f14df4e82a2d2f2281684fab00f70780266ded7c1c80fc2d7ef5f14d6be08cd0e3c5edd96e1a7f8b0350aae4257b81ca51c26fe82319280c00777361e30c399c7e759327c7454ec64f74368c52eca47e6bd7ad746f38b9c26b1047def2f1495f5718d7f84d92bff7869d978a87c41abac4632a76037afa61a6cca46cfe4e125d20b5d1f1a8dd89c12c17ef027e5985aca3480b96021b9e9ee8273b6e6cfe15ae655b674dc418259a4561760a54718b6f92e7944e95a5cfaea37ba91525753a33e36e1284bd3a4253940296a3294922a5af4a2a611a1a6f70da4fd9440b56ec78ba84be2366482f94168ded8f77bb9e6951da9712cd0d2b59dee4c2dc31d2710dda637c81714cab405436381899217e29823e469357fd95ba9957bd2602f79e71d8ed7fe24c269dfa8f68f840d27b8dc8b71a30d1470d1bf27db288a0a7b31012c1763f232e6edb9e945880f0cfa50770f1cbfe61142e78c08b90590958b9482725837498352d459f999d2d7aafda128cbf64f969e2a1afd8b47188382ef4eceac99a5d6540bd0ffa38ef9e541df30eba38997b85b8a9acabf1b211e7eaac905f93c97ef820f60cd4643abae76b9b328feb28ba789da4ee5f1234e3568ba1cdb80e9399c4897e78cdb8d4e8b48af68838929064862eb57324b8479d293836908f35907ccb91cb94a425a4e127588417176e93a56465530f2391a201aa1041a655bba270cfcb765d42514f098130f735525d0f9278344d53b6e61e33c341d8d64bdcfa15f9ee34f4ad5890d625adc4c915f8d01554a775a9c14b9cce360f65d8c1c4d01c2a9ad6f3c18f69893ea66e474119f56be1132b74901f5c8941d86e40b967ffc5f97d6c3dd1320d6eab9db67d380ca0b71dd07e7158ab033b209929ff464e25f25ea2f9688b69075494ab39eead7bbdd5d2170b5d6c59ab4ff0e13ad3b4800388c37357075e906b9a67579a709014e97f2176d1c8acdee8ce8dea19ebbbe792b2faee2d65e35962aeab7c0c918ef2b0c41adaaabb70330615b819f3d4668bdf7d430719999c6116a29061ae9c45446ab92000fe4b98e20ab23346b8c56aa8aa7faf1bef7a75238c3b4bd3e28c1611a16bd0aeb6b609c860e32deba1cabc0f5de01b3f8cdea9332cb4d88a0f9ac0adbaeaf286ff5bb5a670099c186869cdae6af16a9b201e1946440705cfba688663ec80aabc35e1fefc53be4cb11464d8e3d8d5075d53c7c84667e8de54b7778feff96b94d3a7a7fd50955aab8368806185dcaf4192b7f430048a21eb30ef4a49332f408838385e8fde2fcf357f2b765c8c6819c090a8b7cb7d78abce7e2e050dc087f5c7fa286415d0b108a61ed747a1d0aedae833d351fd14a72478d033ff5b8270c2fd75870deebc5a234b4feece7f38e03928ae23cc98489f47af8e144e5a5ff6bda882b2eb19f9a2c5629f5fade70a5197713efd501f58d98c62787ef71764cf40a9d5c2621bb496fdbd707f9452d5162c8ac20d35479591ac8502140bd54ccdbf46be90ba2d9c1dd177b64332b55c55265a633cdf90bb4681d07277493e00cad91bdb551853249b0b5d63e238ec9937ef4126fdecdbf612d0bc0bea628bc0b8f7fbe090f13135554bb3ccdd8161ecba868877387410eddbfb1761922c6f8f865471019b08a85a19dfdbe05c33396cde24bace8f340b10e7731a9cbce74fca21fade6edab969c58523386307b86a9e3ac383345c536b669e243ffce54e92bae97211093e70bd23bb744900a46a6ea07c5011eac4d094b7ad3b1a98959f2f2779900286a459a24e21b1f7d96e246bf72c8a4bedae0a3e7b38b99d14e66c42030c73d4a37ac82dcaddd88ea20685da7c2deca7d751583e60cbc01ff1d35e47b5a2bd63d41500d31522bf3bb3eda23d7a443124084f587c54566ecd155f8b06d505d362f237a93d69c1a92f5c6f2630c4d5521d5c87fc18b7552385dde15b4a8c1e3adfff96a4707e7cf98c047925297cfd77357095c8a39348b19070e31da3d9091a704248b96ee009c6c566d97961160a07aa9d09e04829eb68f6f98216f842cc7291a4a1c05bfe355a3b82429136f4a195a3abc5603971bf50d74dd87e870f9febd088ad7df033bed393abe7f176284b5edaeae0357b26d5a6305b4eba49fb957bc405fca9c169dcbf26522063e335df59d5deee9fef76f12e4003424147b1b9768143a13de8a0ad2cc2bae2e7af7ef74437c9170f0204cacdd911deca31921cc169d8b5534456a8fb76ca5f5cf0073e441af0152268cee6b95d033d0cafa7372b232a043d5bb4f127a82e34e63eb8f22dfbe9482755f8327b49d485ab3df65eb55d5220cf59873c1b81b0a5f593fffb29cf90edc0b34debef11c5216dabcb00d18948b9cc5bb30c1840e84b4738747022d3cd1c93899271f2158d44820281dfcc6aac47f8c3c31e3db517d8251d6ac4b0246f703fc39f2319d4befe4b38b1a6750de930aaf2201ca48dd2d71bebde8c0bd430d8fc238025ce5c4719e2c773a6e3acd7c48113815b9e58cfcc4d1d24a36086b7da8f4c8b5ab39d8955846ec1697760f46cb133b63de3583d0f8562fa58a424755eec4b1ce7d697a7e987db1d150566d3c83b770f97863693fbc7b65d69579a672f39219545ae936295b89e0f78e4a11ff038e70443ca9de72ab3a5db2999989bdec682bdac5d7590fe5ab5e8df7ae7ec3e04b93f6ddf32ab6a2053e99e41905152fcf51fb75f33b4141bce5eeabce87d0f51cc05e7ae2642c64531ad8e1588cabcb9a80467b6d8bd0726b0f3bc11aafebd361e741f72ca18e14c39e1a160565c7f962fffb8991fb904ebe11d6656fa95f2d0f2bad56c1c046267cbd01b0727fa72da957353046a2c7ebcb0bcd085d2cc20704b1960c5d8cecb3d90015c1142498790fc8b2605674282b423ce30b29f9339f387ea8a245d1458c8664c1c3fd028e4822f39e1ffea207f688540f334adbe1cd3188285dd988c5e3459f92add19be332a72dd50f3fd728c664e87e5cd59be413595d4ad502c034db5eb206105233e5ee8d35f52423853804c670f3cb751f85d26e0aab4a94f84b52a6928a0edc10bcb9b89d7faf2d6bd5c90d2e167fff5d3b889fae59f84ecbca84f38a450071bd3d4d27123b591240a3e86cb4485a53791bf174e7d2b8894238cf191abc9bfc58cd0bcdfdc5ad92e02b62eb6ed38f0b1231e6b82a47042b8efadcf3333b2b1bc0b814fc13a3fb547c081d813873fc851a9f8c89eb2ccac77555055c6c1c0e7d496ce5a2a28a35353f016cc6de19120a94374595e7adf2c0c9693c71eb98347d87804427b3035bef62979350181cb39f0ac27396c0ef35050a8ef7ca15c5fdccc938f26ad5f0bc874165b2be56b588f7bd7f730a42ea1656b8e1e5c86a43589c61b6a551a3d2f27c51f0e0200420bfef7307466890363bfc7e2cb06754d42c7ee1692b38","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
