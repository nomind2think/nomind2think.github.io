<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed896b8dd092efe3c6954e7a99ad75f77f83491da4d608c835d548334b8b6c75161656b4d0f2fcc7204ff955289db1a97c887bce889af435e56bbaaf325cd05d37ff24c99e8502f46ef647383aa0037f3cc6a75508bfa7d9f9358864de21a3dba7f28b807007645e062af29b419ed6a21fbec5fcd1828b91777094a8f49daf74457ea95a5b5feaaa822ac36f7731e99aa3ff61a0ef7fea4ea5fd93a33260e5735d81f0480798555610b1f80faf5145444ee9599f307dff8e9c5831c2ca227023f9e490bcf39595d1f8d9c6fbcc114147e0df8389c5c120c023a1c86f682b7f2cbd33db86e3871f930c7420ef969dee28741caa27f3e1e585e1db7fd7bd9d9d0147c2418d93290e018ab9054d5674f11b1f45c35be08bc42adb9e7d7e37d548865fe40c30fce7b78a76c8e18a40e02ccfabdfe323853bf4454a3c90b262a8b32dd30d5a29103ce9a3749ed14ad583824a28b775494c72c1821a1b6772db64286a176ac1579bd3cbfe67bf46e26ba27b4a4e4f768b490c8954a55a9b08dc185d06cefe39921915f7918e0fffc975633c57c0e62c11715fbc572e2c7487e9d3045eee49f58e1c144613a1d83e05ce69cbdd7517f12f491415c79494606c894695a5c811ddafba6f74daa3abeffbe549231cb5af9c793d0ce464d251374601d3d0d1688629ef568ea547e996ccf9677da5f5b19f6a1d4e9d8c0896fc51f189655ab1931c84d6fe35db53ce2a23a4d1b5efdcc80b450ffe53b0bb02ad9f05393fef32109c11fee1dbe92c41506accbd2d8b5af46b872406bf20f6c96cedec1cfb81f398d6cd2ad09165703036acec8b3ee9c86308c3c163f5f17fbd1a76acf0b3f4937329e4b5533060b20c34ae17b0ed6c951e184915c7f3bfae28918977e22870230ff3771bfc76a7029b2d3a043b7d1fe3a6ad63b8f8d4edf6cce9bd5b28f97af37a95bcc23c28df8ca731480e8aa150b30cfbdfe7524221e2b32dcda640df64506903010e886b692d4ba47ed6a25dd35c0403f4d05c4559ee489fb3ca122ce4e9419cb93687a94ab5296fb7ae0ea428893b4225a5a7f898dc1e5c61e13c8140c0326de9b7c1ab49d126b36abed4f96bdc18637123afac8326e9023483694ffe4489d9839d9bb20f9d7b50eb09c3cf93effb7f727550e16312b2990958826cfdf51287d35962795c345f19981bb7cb01d4da61a382f0a97e4fec0aa0519ca823b76e985df995384d1700209503fcafc7cd35fa4aae4dd593bcc1fb63a6892512b704ca1a0d0225bdfdd9e7daa77dfd3444e26f2456ed854f8608d3bae6de32a464af7f279162e9d417895cd02afb9151d8858a216e1c59fe0d1762bdc28d83c6dbac0f79eff13462c4ba8f7a31b0fc1418adbbc297ff08672414ff56f1c989aed64399edc1a6089846e6197e985d0979ff780fdabbfef147db92cec1949272a1309481c968d89d4484a10cc502f47d8d3cbdaf166404913a5ff9f9cac9ebc3bd684766121faaa18b7cd50494a6f8d366f902368abc0d00cabae24532f50228491701972802cb320983d2b826c87485421c182c053fd15d6e7cb0b9cee661bf98cb8cdd25854567abdf85ba054e122c1dfce7e9e1d00483feae9c275d0d4ac64f380fbec1969900d73106cdedd5bb8b7a11e2717b95907aba550cbb8e1d0820265936a3e5daf0ac5013e681ba7b96ee3d50d42a24ff7ed688153413e104815745be37fdca33fcba6d8e03db9eec9735257f2ed1bc9c1b11d0839c0f1638c28c86cb61d9e82c98a9751b7d2ec7d105048dd55a8cc25e5f053e2f1039a3d942a5b727ec47ad0ecabc312d8b1ff6517c97b4658aa764fd8312cc0618bc801b0f01696bbfc48733fb82baf48db1a7ae384a0dabe0fab1e1c90513ac26af662d4511679beb497f225eae60d2cbd12b7e251f3127e64f81537fec69714694bfed3edb2beb7edf3a34ceabbc145ddf3581a4ebb486b882638eaf648a3675d23a1ee253346a2e0e57375c6e2c66cb635f338fb74c834836e26e32a95da31b9cf7c074d4dc4dd0c9e4b9275a934c1dd65868120d7f17b8d49af2b92126ab5a1fd08faae2fbb142c986285c5ae4668673890e7319cbe9baf39979d72573683c2033dc5c666da94cdd7b942c59ead23a3a7d725446ad5ed23dbc3798011d696ab3ad095951b9702f78628f2bf69ce56ece087952c4dba2c6b6b4b7686cefd9d0aa0b1d5eaa957fd4ff81874aa394ed9df401aefa89d991f546dbd3a4a5aebf0366fd7c8b182e15a758601846a310326b2393e03c874b7cc9a118bb6b6cd39b95c6af5289940ed440ae39d9d703cb3f2504eda4831c9fa4d91f29271edb5c6f3d34d7fe9e3501c18ec1a822b8c5388b0aa8af8289e18fe004c51a86e34ece2a0c4f0155486e38c4d23600221073a5402c30b07ec2b36b5d08668bc4f85510acf3c4d6877588601fda30053b2e0e4ae52d3e1be5e920db3cb7adff14d9f0121f11171dcf2c251e8fac311af2ac9ed8f9cf014530de4dc69e8854b9b1b86e366c01a0731e596bfed9c90449dab2df3b0360f665fcf9f058009d0f9407ba31af2ac76a92e85475a7ecea0d2e183a6fc02b4ea796dc42acf810959c0a0d6c077b690cc24df9b9461295975a536cd9dfbdfae896d56fb530285b0c124dafd16bb57f1b408830f5d9b3678bf669c00ddbaa6c9fa6b202e645f7336aa66030257b52ec2585736913a91f60f2a03a93eb095c087fc241d81d0b04da6eebb56c2ffd11f98cd0f7045a3c5834e007be6038b46a813f023c79514a87ec6e067e8e5061008565cf84ec46766c7119f38bf5e2820e7793b7e7d440706a623b55bf12f357789b787d8b85081a4e8933a2609638b9be8121ea717d8c17b9d729075c3ac89404d24598eee335cd1117293a80c1b3b1886bab7938191c3209204602107f44f992fda1504df506210c1b9f9627d77d5bbd51c7804e2309db976942a2bb226911cedf41e82e40781a403f52833823c6c0a0477ec0d1e16c893fb86ceba5b298fbff767ab1d6ebe4c016d1292d112c172c2858270fe87c3a6a7f2c3594835e6f554d42f1832d8b2766ef06b43742d5c7f185b5baad59c54119d200fbadcaa11d523893736e7860f231569bc0fcae30d8f20ad306cdc3ec99b8bae724694572049b7a63968406c95ff5c7e4302f9fdc5761bda853db0df3a051341bd5be8e6f4ac1c44c7675d976c8abb699a3dcd5f100d82d90451f3c0bb9b827f3ce6e808899f3d9cf6e2dcb301407afa63b13449b748150470d45d1135a384293a55b433600548a137dd179514f542f052f23ca3ca0da0492b79d89ef96a1c48c0ec7ee4cbdb7029aede091eb5e718ff7534e38390560848704a22aa6fee2142aef8c6d3dd380657ebca402e0c40194cb5d2b9c455f850747880ca5f8c5e18a0afa66a4f83a5c26ccd1fa88b8fc317bb7e13cf4fd38d5f84d440240d15e0ff86441df5cef5a9baeab7b8eb734f6f452084c93d55b1cb6cf19b8c414556b6244016ca6f5ca35672380fc3769b83e5b1c9a73a84f704c3ad66846128ee0d18ae0eb12e203f6b14d49c06760553579d2088dc7297669a938ca504396bd0f40689a5121eda14d7fc3f248ba18809ef2b40e1e1e70158f283b4c4d24e9f455d59bcdab8d2de9f9a3ce0165a87f23552f7682eb2e82f31cb001e0a91f837760f6ef95088e88e414bf9e60e28b15459b7a1aa3a93942a778958a5ceb8033c956e58bc47938b234db0a401dfaa796af4bdaab0c81bc79cc8d12e1dc64939aea88ec2d6f8ddf25d59c92301b6817ddf347ce6cc42a216d93678cd51dd5d68e6fc80351df5b5e0a28b435f3b59ee7c0727566d0e661e1c85e10b2e6c1ac1c7a8d92600d0f28ebc58a61d1fca96e952f7a766913972b68c64c02525d517934d664a68f5aec087c4dfb49b2737b9324d4e7b0b766454d35c344dbd25e71e27283503348ba09fd715311abc098cedb49fe202f2cf9f54127e06284d12ec4f8c5b155abdf9d0e8814eb9298bdf4f90ba33c0b3a07ec8490509293c6d4f9785947845e1e1bb1b1dc6a944a65931fce34b5f368f3c67f2ca6628951ed575f34b0c2f358fde8ed8995cb74ec3c5aff8507d85f34b7453830a3827b68171a8eafc6e7f24eb8f321c3cea82ae29d5598c34c097222b80a6461d5a4e10b478c001d678e579a984bacf15ec199fa8a6109e9b57925372178a646359d45c61e4b6882a3a83e03ae9a4631f90fa4c42f240fca70e37a17059bbf52aa291c25ad0aea6c96e8c08912012c4420857351dc4ef31606375f72a72aa0123c2b0b62b1a5546617e66fb583a2d202b771549c38cde707e6bcd2b9221f57e4d7620b5b62e78e480a96f1e40c5d6c0e551d1b09a68b6af8d9fe30f90cf0e6f798fafcf5cf70513087d3945dc52beb23f69fa3f15ce83d8b4f69b1efc96adc236548a2105d91a44269f92cf92ec45ca49d6de01cca62e3b4c16f65146d85521967ae178cefc1df26ef52b34494ed71efa5eccfc2c695d4b0570d3da414ae78700dd7fe1e81486c81b2baf617ca517a2733715534dbabcc224f0722f26ff228b6a0bc80f3360795bfddc52ba307ba664d4a9c1c6b519cd149f62c3f60f785e475df4c4298d69f319943b7061e459a827c5e3ef31a343a7606a9d743ba72a68f0fbaec233e7cf49271785d3a6e2a946931119f658c6e0574fa14f3a5772eb95d290df7da1f70580b443c1b272b101cf17d156da698e79ceb23cf7e91ae4c721b69c018e014ad7a41ba18597fdae11fb2437250461e19bd738424699deac322946769bf04cb2a53a511080a477780a19aab05b35b2d8794c68e01741a3eda1ff8f79731755e1e5c4e1e0b8636ed393999310d9907a00edbfcf5e0963b77692de9ec703dd86fc80f5570f91034d0f1e0ddc07c7c965b5ec7cdce9cb39a27dfb921c2a98bb0cc3d120722652e7d294f611aa20adfceb44e19d56bd3cf23cf9fd3dc8a56171f2198695750e648dd13e408e909f7ed49ce83cea23469f1115ee994412a28950790e38dce028dbf69dfdb16bf97c78b1dafcc787ab54a5572b1c6f9cace10db4046940bbb1b0a0840b83f5d4d5c40694fc6cd2cc8ef71aab49bf0dbfdc6c8d3b603fbbc30d1310d5fa5ead462c2ff9cfd1a31ee65a46d2cc3ec873a37475dceb10a52434204859421379ea59bb10c26bb821e53325875b17b1297c39e940a67bdb8ea0b10c27f8c312603a36fde5ccd2e971ab180b89e1b73e84bef31d5c40b443632b6512ba2d30feb55e84fa86bc50ac42e1ac31522d40b0f7130e8d2333963b3142ba09aa414db66f89290b76dc296b0e7c1bea2e31af692a15826339790d18832ed8bebbb5dabaf7f47639e24a371138c7b132309949a8d4ea279c18fe79de739cf75a335b38541db1b5db9a978d757ef79585775ef1cec28fcbb8da3cfabd8793bdf207052ffaa3cb0208f0522a33fd0653008626c92d0ec2a560011095ed9c220eac0b8dfb466a223b3a9823a3191b4588ebe20ff971ddc3debbf15556057b0f7bcebea88828feec9bb03ee08a20cc67e6462f678ed609113fc36fdb6983855b88bb1e472c22cccb382386188e7c364c11f32079cb9745fe5e6728916bdb7eb78690617cf20f68828493d10db288dfd10d57f0b163f61ef21b1e8c616bd8bb93b541507ed8a2a7129707ca1f41931d96106241c5df866799ea04aa614af92089abedce27d8577abc0c950904f8a6fefb60157c53b186294e0d997f0a2f869c2e9d113dd71728c7a5c2ed4ce768d63ebee665ded8822125b8be4ddd00c06a081b4f350a32d8e16ef8284802750ff05660fc8f56a9637be24197156f72a0c890395ed56fccd3c4638e083917836df23efa71bfcbf66b5a8c0d2a47951a27d379d0c9ffdefb7c616257ee34be28121ac9186414ad173ed90208f8aab13ae054bd29f0d86acd738d4fe6d515053c7c1705e760bf410e1c1d5825a5234bc770a5da4e382e61f02e04d9a7d37b42bd3017d7b34267fbb6e45be15a1419d7f0e597d2b029a49720e4765a9b858104fa4de2db4f997f85ef3792924fee4a0f58e206f1675b701b528df80b0b7def84319e5edf220933f15030b116be7a55d4b3ff3d951c57d1f89a76eb6b321974a937a19e10bbab989fc0b666b1754a9b9eb7721e1e73884e1241ff88e4d805c6161e369a1b0d8bf5bab3c3e92894d6b7377551e9f737cb0e7c99c1958b4cb234a6b38ad347b98b66154b5a1ec9bff1ea0071bef4f3006eebbf3e410ed2c476846f096df6ae0eeb22154a12f1f399274c55129ea7c6748107b3d35066c88d42c11b0609c5f44f061763dd0efdbc784739f74455e83e350b42039adf644bcca206922f6f353fea1c5bd85cca028a4dc907b6fbe482f1ff20d15beb2c09a7aee18d1be900408b7e4280a413ca33a1e039e152a98434684236a9c6638f53fe886d729219b4504eb5e8aef0fe4058a8920ff1e7cef0fb4697709851af9a4d5696f255dd28a6fd87f695954f91232ef4454a373fa4b4540608268916c618074d2df9bc497a490171f1172685419f57e4745682efe3e8569ce15f40bc96a1c6f8d3f4499ae5f8dbabd543e01197cd10b711b7c9843590a3a900d64708f916813cb64ba9bb720db2fff09a7498ca33030f9065cf53dacd4133835b57becc466904a8e90108adc5b2f5e76fa2d077cf6275e0d07dd5f9d0b063452bf7ef5110dd61aa82c0ec52145de0f11bda0a6ff3630d0d88cfb87afbd6df3308505d2880a6c648674198db02266bfdd0d3255283519ed985480077a7ac631741aa77dc208d883443ac3644f02e2c465073ab0ceb382436aa758f067a3796bdb41f97362de858e60ac4242bb5bfdb852d569447fde871a5f609feca6dfa57a95a987fed6c036d6f57129230b9a165602652b9efc191d8fea18c23da48c9f48c8507a7bfc5378b9e55f60bd12120c02969e579eebef9a125e990a45a86386a42ae10980c67d4fa56f3ae347125b52dd9770d618c5fd805a3405a452b82e8ce60b46c4c53a492a41f02c45c22322457741d591075cd22ae710ec011e768741a583b6c204270063c0f3b32f005266cddd618b0392219b0532a98768b870ea45c179cf7e47e95e436386741f8fab363efa5ce16d93db1c381c163d02e6c5c1398dca5ea0fc9f30c1df4c175571f9e286d2990c843c39263b2887869f5ac9041d693b30dc6e1bf4b005a04057428ec9e8d4aa5e7d561cc1529829d5b0bd15e66506db2b1b76c7be14b75c65c1b68725ceff38b835172e4b3de84fa3d608835100101af112de566d3de3d33488216e283b48baea7efa76828b10fa6731e161b77351201bbe0357f5a23c2b50e627b44c489e7474612de9601571e2fb326bc45d149a3506023f7aa358bfb17f3976d0bdab8ec22e64b4dd69349d27b23e31547071c63b03f60ec295f1a2be64d5a6e7842f8c3a63cf244498d9a9b50fde6ce0501bb5ce1deab1b433d6ed8d219aa242de34e2b58dcd902c2eaabfc93e1bd8d7c724f7b699359acd9831a28e56e49f4f3192824163704d157cd47701c7abc7fa213f5069d4e087207ab9c18195d2c754afb65c1b4dad85274d757a463bd5bfa5bab5a41b8141e4100c0624376bc6c2fa98ccef5b5412fc4d4c5e88e659acaf05035081ddae7ba9ce8d3bcd9199b4f2f9303b92a823c3424d95be8552dd05c5a7ae652738e1dcb66626524838406950585f10ff5b603ea9e7e602d41af04d359ba6f58c58d87f222a5eaa3b8f5a2e2aeca3803caa2783b357f4948d3d804598dfe28c176fe446d6731c645993842a003564e222aa3355696db77627533477c4db1e415b453d22da3caf037238461698506a0a89867f099e2a364392fa6c0e2ca708e62ce8b67c91a5bc000fd70fa082f9f9e84396b9bab7d546a83ab15ee80d666fd45445597cf4d649d31c8924349fa3d285d4bce961661be9274364dd2c10eb1ecd681e5124238a378e7f5a3b0d87c8207c663876e525f5a8ed659e4a7efb892a7ef7f90868f61151c7d62710a379fd69e161367d87369b0ad8e94faa9405102ad14d51eaed1b6eae3033ccee595d27ff54b1934684e1d6487a194aa06421bc196c5ad726754631c8b2348f0928129edb8c707cc79841d13dd9fd8a68f4fdb25a8c90645fc0c6014d33d1d19eeb39e57174d86a0dcf8f6a41dec1edb4f16aa07ae548eb54acdb2a54e31c864af22ef747f90d9534588eaafb5bc7904155ba1f013106a2f395670bfc6dfbc11641c89e19252cda1729ff0c38ffa3ab70a9c5e699d9e5517ccb77676c38dc8c3bbfb0126b31a8a93ea2a20b7560e488e05d57d784b3dc67d4eafcaf11c347719c7042c1b66b704498273f40828198c4b8b800eac209b22048d849f663e22734caa86b8c6a68281985f300b45deb66be34466bb7fb4b972ef30bf54654ff7ec2ef41aea6eca93414624859e87efc33a876a784ff513ac17f87c282f76c802e7794b5de14e12e11b1a3b11135e8361c3a714e6b115f95039babbc0a55bbe42856c7bb1a30cd2269201f4d6425ca62241215eef9182a98fd74646a359464f83f685fd231012837833f087909fbd6f8ffc30e2c68819b32a72d3cbcbee40fa1d55c2d5c9daff6a752f51db15b76faba92335b3804456fe3a6bf716fa9932b14cbc22bae33af8861bfc0efa90a49747102669fb2f36a576f463c2400858f6c2d1a9dda96ab717e814bbb709c75b5a28b7b4dcd8b3a47702f3766daeade5d1572ae7d2fab9a9f84bb7fc24c1aefb9fcfe2c3590bf1ef077e2eba5e7f4c548281f2b34b64907f902f5f79e8a19695c0a1b193fb2cdf7805cf99be1cb346faafc8050efc47651522ba4ee3334f8cebf3458e70d2b6ec4b426eda8d380702153cdc88422eaa2835ed63a701c6f3a613a381eb944ce2301cc3a1f14e63e1b2ab268eea9aedb1a7dc9a8fc3494488f739c06e72cd92cd1ce41596d52a32ebf973c3a7b942ffe430fe6bec8bdbdef1fd41584ad031c36ec6de465b106325d30c25d6e811b9948e1bbd047be87311f79dd8a8a138ad202bf55c20da98a9671f6b8b00306a8e1d68cb174db99b3390cfc07a5a1a8029166f078f05c8275518c2833335d7fa59aff9642b4269e39fde26ba79e7fc9ca9d37a4af929ca541bc0845e7646a6049651efe955357d6d7102fff5ada03cc6a220262781275551c90f814cb711147e9323bb882942c27bf582b59147064393bb317d2a7a5f55fa4cc19fb1aad65aeca432706a823e6eebc2b2f9ba4146e7387fa7341c6ededaa185e6dbeb056d8e798a5c880c82a8e2bef4362cb2aba35a84f271d207e93515c3e48c300c07edcf965282ea9aa1da5beb08122a5a02fba5a2f88991b5d41b0247b47c8eae0ecffab5d9a08a413a93814093bdb4664d3818b14faa69edc45cd9fb59be0822324b1d3fe1fbd654a7d46ebcb51909678a996f033b71ef3a712bd4678b595028dd309618f49e4cf6c6d0bdaebaeabd557caf19d4a8a69c63708cf8e36295574d27343212e226cc68c6f8565bd9eb6eea32c83a1368bcea293e41df830ab5b207715697771c4964b9d7b811251013cded6374b0e7899ae5c7eeea9b5e49deaf28e7a4ae2e03fd946dd6827928f67b89240c85f692a52e3bd5c5cbcdc8497ef03e0ad7afc4ccdda78103bcbe54a9baabdd074ade0f8a83d894048717c6f406f570aaa918ac06db1b5cedc03f063a4b44ef5a098ae26fe4504a5712dbdf8032e80aa899dd9e55fed70d7d899f44533d1786436509c5a7416f37de55aedd6451ec8f120647be26032b1fa46364871bafd15760f293e2e3a9bc7947c9cfd48b2fe06092944f26dda135cf82f9a409565b992f86abaef900a91cbe397a9f7b5207138ba5800230992eebe5e441015c74f68803844e18707348798b04a45f50743b74263a13aabd5511f89f59ad13ccdc2387d4e30e545c7b4b3d696af26739ff508fbce03d3b9976e6b1630e31bd01ac8d5e755f70005d7ca119fe634d78742797ed5ee218e0dd7146c9b354e5bf5e3fcbe663961f1bdfdbbcb02952cc3628350f8a72a72d359d537cbf21411b35d8ce8b328bbc25667ec1b3d5b6a6fbf300a446580eabaf96dec330bd57c81da9afefa285e174a7d9ef9f6aab42bcff159c4f3fd3e2797e2d7d3f93e90f93897e3131f15290807beda30974e0b363219e22ab457bddd834f319b20d8494587d3863ee291bef590047a271e80c0570eed2d4ad48febbb73c454e99c9c3380b8b89658fb3346b780ac9f2ac60954bcafa7bed86e43dc85be40fad4cc164eaea46bca8f3a22c172f2f9d5769158d38604be6978cc084aba6e9fa911ef107ce0d547db5b51ba0af0d74fd2c7953846b02193b6872dff4fb0f9afbb8243d69b33ec7d780fc79de9038b2dc8d15bb08701e7bbccd85f78f0a90cb1326a83b85c53ff92961e9249e1a363041d7ff6b267ca443aa8736a869c7f332d936d83956889f7233c947a6d5faa1ecc829864c91743cad26e21c7286a809e3d0740529c20fa1fc711a69980425b72979e18e5348665a7b148f371924e0a2eb399bbabb0eb664d2f7bc005e3acd604889d3c4f08b2ac8486446114f998d7939f05c77ce12fe5b5e358babf10b116f2af36d9f6bfa6c3f945949cfdfe126ed357defdbb8930c86435bdacee0cb2b5469766041f0243e3b077878461df9e2734afc59f73b6068a27dcf0ae29003c522af3be7aeaf6fe679b06b9ab8caf2bf291c99b4bd8e6f645717c493a4746ca043cee742c5ad82c9fcb20e3c1444d279ac76fdc8ee3b5a77eed5f86cb39632f80e7ce3ade12d50d86a2f0f0c26717c5045ab8800e7b0fc3b1b5ae8c51bc6dcaa763db90a7645b6d931d1b19656ac50ebc251e7c8876ac22b2a064a82bc17832864a1fad3dcdf547e43fcec893a3222d3fee2b786fae0ab140892ce4394ddf02a2352e0b20d186584482cbad2102b9bac6ecbc11d2106d4de21dcdcafe448d95b9e2cbd6f7b8d4cae78a092139e7271779cbc9ba8ebfbb42b5dec71a772f7fd589594c5b897b1372cc20967c6b5c312f952f5f00d119d77463ae76f6897238a297861eaeb2ef76fb85233d6507d6c915daea93a73eac2cfbe2b333d6baf0c4dfcea2d413e34445bce450617ae876046ae8b392997eaefd42aba0d69f5bfd1fe3ae4c59c808347b84dc380635b62deed28657a5782ddbcac80d803d27731eae1d1dede2de068ba2e16d93d5bc8b27f692615a5f48a776974c4429bdb9fff26755f1799887ff0b690264dc002eb043e3af438a01f39085ddf7fd7de8617a40414962c19d298a746b53614e44bd03c0d091094417a40f2583d554a8a6b3fec7d39e4efcd6d2130f618f601c303e7d85c0fa24feaac9f8a5db73602cf2b3b3b3a79ba6a9e5ec585bba0eeba78877a49c0f67308896173ea271126780f63bd0ff53b798f2f55f062d544f3412d728bc4c1d5aaec4839434d930ed75d6e52cdbeb67b9990a9579101fd89efa21c3e3d1c33213c10502250630a0d96c80c40040e32e5c9e5a4a334db176f148b8f71c2b4d27e43dfcde38df089e6f6f8ce23b672b51cf31789ca9f08ac6577e4e2ccf4e3a8c0d611456129178df0d36868ee6efb4d5fec1ba9630e022916880d5c145d59ba71126e61c6a69fa3892e3013f3cd871698b7137fe2161021c49e495bca03ef29e73c02a135adcb125e706e9c331689340e0f73f1061e7fcbc4e164923d88d6ef0afa13d94a4dfd64044b508f973bef169266956ba5842b60b4ee82d9736b176c96a019cfc0a1fbd7c5e1c7b41ea054aab04a39ce134c3431730950d11f9c3cb1425fd5da22b18b231ddaf920cdc52a662961b1571a7a1b7ea279699320da8940d05ad16b5d67d4fbf4a1d70286bc089543ff69f96a68d848b4ae21033f93f5439ed71005f5974910033e8173af960c24efc609ded445bc1fca5625da500ea846377144056f542d92e751b18843d16ab5b220f4a3235cc1e6feba37d68194967efb4aa96d5b93f9b5bfef6b7347ecc0d7d3de18f594a566678bd3cbeffbbb2a600e82cb3b778f6c22f3872a31b2e37a7e0b0b926fe5347a6cd6916a2d4654049153ce93c119f2bbc27c222a887bff7a6814834840111b7788b212c7ba04400a954a974dd0106de20470261bf2514229776c41b58b6e1e04ef090176006b0799c45ef32869ececc8bdb0cfb217cfa69247674bb3ce31fc46a7842e7f0fd98ba2b02789de656505b6fbb866621c91d739d9818c664036df269e7dccbba304bc474dfcf58cd9f714e26a7c5e0741bf35401d33a818bf0c5fea90ac6e1cee3875f9401560dfaedfeab9c4e25272613d86a3b2f11ebd98e38266273ad68764a2ab5c19d0b6d50ebc311db67141d69e45c5489bf27e321a8f2df5168512b78efe99f4b7a97579a6c426d67fe16f50bb2ea9c7830df73cdfc69db92b86809d686ea51aaae2feabc2f24c11b902b141a7abde23e05627b79adf60346ed2116cb93547d665fc1074be305a6466a71bc2fe83f15f3bf330f496068875bce2793a19fe0e004df13bddd1bc58eaa30e5dd85604f32e6e77f336d61c94c21163e9a4512d8acfdbc92fd615d25a1c58443d56110fb628055823eb515cfad10f385501758c0a18a6af77db46ce24cd674f0edb83dc6fd21bfff664bfc188e7d46a561d6d2339b0b9e876792f7ba2aa60fb71887f8ee6a3f6c496ec01907168d1e2b2faad109488f088589f550cdf466865ee4ef91011a2e23de2a51fa2cd46659a632d359fe5f669dc44d611c684de7e3c613c3b89b9b4d751d5cfe0c95442759232924055b67a2aa5ff8f075e8c5d238dfd61b698af738a04ef871d17c93c38df4d91141c8172c79b438fc6d010dbcaa71cb4c441245c8d7aa56e1b0994c0de3c997065a8681755d67667a7ddde6c9a6caeeb9a6b0c03e9f81ff8d970d26642a6da94e469a7918638fd51d51f8f12f838a2d3ef51b11968ae8ea7f0082226061bb9ab3d5a06af3230ab3273b8fdbc0f850a3d21fba5af94b20946f7aadc20e44a2e3d858556bbe744b8c6c5dabdcd27baa2e4a26ce712f4021deb3e90876176275816bd94a5d2e153db67e71ce9b1f5117abbba0f8558f015514aeb20f68ddbd6219f19e5179671e014b0f25d48b4ce6e12f90c562503cb0daf86a988781acb55b16ea943be110103045ac67d8308c5a4c8ff06a549cac7b741eb1b4cd8d019baf1fb65de802cef5d89879f235b51ef4deb78fe9e20efdc9ae0dc6c2fea4ed1f725ef8dd56964fb5d5e299f33c7b230ed7c5f672d432592c69b8c6f772bd815daa541cb4ecfe38a474f3f626047b64bfa3fdb2ab3e5bd47cfe777f9570354f97fdc795d5419a63d409106e187576c2460c5025e9e3c76c7283516ad575977e9d7e5cec46515cf5924c36abc4067a20432e47f695220654ae2b79bd2fccb0472228bcd7d81812be340daedff0cdeb6dcc4985104d2bf4db8a206c4bbc11979eadf8eed76381116478c1fda5e890aa80efc7dda9d0184be6cc59dced40300b0c95202f940530164c9ece0b096c6595a9bb0f17adfd9168686d5efde70ead982406b95983cece52de473c259d9e6a5b1451491be570ae25bfdf19cfd058c9a7c52278cbc8fc328da81d940af88af8da280bab5418f2a24d403bd90611047b7790f641ae12c17828a544b44e5841aacb1b66f4532825e652e530d6498032fff0a303c2b7af7f8f397f8d9d4bd0feb918bec07ce5c1506c1c3c56822e4edeea8c1b6a840fcb6d4ce96e6e5cd61c1b9250abdc8c67b4ce19f486744b88f7af8f43cdd27e49d4403a507ed65fa940ff199be654c00aca2f04fe48c1825235eca09b74e6b1e62d5127e911ea32b742a6e5ade3ad8a4970f49b35e84d9d955ab136188bb4febe79d7cfe17823384aa70dade1a47681cdfd644293d305b02215ede45e15b4b339cc212a6c3783232773a69641ade2b6353d65abb26d6202d1dc3d30aa339e9feac81b7ae9420a7d4f9a6d623e9a44cc2414a25f5a6e237d9a587f4a71b0443c8d217bb5422244104ca77209f2ac18058a799c1577306cdbfa769cce7bf24b1cbec28deae863f7c6042de3fa4858569dbe8ceb51edc185db19adbb4b9bcf274a33c8cb04f074486719e2a372d2f3d43fb0558e199446dc785946fefbe529d72133c2543ef7dcb6d673fb5a844a2f413c933988ea227a6a922fca942f1673ff581bb7cafc766f576d91a2cbb1a78ef6adb2ac792ced4b74aa448538beb1f66487b84073280d2275cc1b6c0b30aaea21e06adae10d8e102e17157144370887decc17c70a368d24ffba3060d41eb191c23d3719c598da46fd635eb2cbc64881ef9f420c2b92886fe21046759b5da46c0f9ab49ee368cff34df3fe3409a2a09e17a9d8426804cd9d731b4516ef8a6cd3b7f508d9172da6d788f003c4dd1071cfb8342b689b2f956929a2a2078515faaf7f527c21c513ea9d5f5b6f978a6cb46d54937457cfc2eb926c8105ec9dd9458741e1221c3d00f949a5f86f8f5744afc7038a839f4779de08cdf77fbc8cbfdd3fd208d27a7376e8b8c974aaceae1e3c4d691d320d12900eaaa1ec8b586a1b24b84b2639be990ab7d15b30ccc347dfb3fe1982c6e40d89e5582a0660ff1811392203db1a06476e785a1bdcd7698d2e7d49e38bfb2407a429e77c1e4ca990f8df8f159cb956dc644bdb7dbb66145e30c41cb6f8ca6699cc491442e20a1ff708f5d1b307d6726cce1ce116708f1a61c13e598e28485a583a75b4e67064a19eadc064e93c885ac50ec7559eaa630f8471dd1bb531eea609ec0c7f0f74e9208876fa1c84cbd1d4322220dfff36492ffdcca7b6941048c96f339e95aab315aff100594cde1d6edff7bca8cb6caf06db45a45eebe5f6cba42796babbe4837085fba570e3b2f82d1b5e9b5c3ff8fb652786b704d8d317b494647dd9b9ee50725ef4f7746667473f982e310b8beaa6804c8017459fbdf2e4d89ab757f24946bb310b3fc299c7276dd01d76239a1e9dd50a7770ccdc9e549f9deea7899db33d81af75682caaab0ea32e858b16bdfd77a062386f7b35fa1424eee8aa4dd9a4cfc83a29029b7eec1aa9448c9957aa09f7cf9e4c6789d4a602e5aabf8dd14313ba71bd5323c6daf75aa39b9f5de67bee6f612c1d4ffca5b14977bc5fa42616a89f3d14e98a0b8ff5c413e9c1a70e739381a5cfbc2817dbd8735ea96fb2f06478559a66cf74ce4cb8dda5a958b28af05e0bbb909fd36c4d205d7a104db82f0c21afdd84a50fa65367730ffa39b463471e88099e05840717c1e19a76ca2122732dc4e060e8fd9518042ccbb55fdb94d5a526061a18f0b3fd4a9413c0e8a55edfe583dbcc1f87090bc1d1f70e3456a20c2e3394a1d06449834da9980ba4aab16752844cbd0eebe886f6ac142e02b9f57e4f0e6aec5a9e94d1b8e6789daf8356eb25fa9aa53a5831459e48207d7669033f90b7f1501fd9712d2af6812b28a35dbbd702ec2c60a3bebc9aab6870c4e23283ff902d9b8e810c93794da132943beed3606ef957a80217e1135dd5e70a189117d724df0cc52d6ab81868d325576e4a1b3877b9e2e131fcf62754723d10140a02956fde0a715c4a3862c70a5da9a76e188b5e942b6b6b97dfa4046fab6286496f371d5bfa22296b09f6da1b1757f3106689a85b1a1068593d342ca52d9040eba6d4a4f2b314de7e0756a1ac8118cc05f91c64cdae51411db92ca78db61128fc553cf6267fda6d12c33748a52ada5af0e1b63e57fe840b066fe6cfa108aac58c039421999e09aa75a480db76f9ca93763c80fdd4c730fd9a5fa792560b8658067527d7b9119012a7c569639b86cb16103433dfb874e6f0045cf900e672aa4bc3605b55193e9b6923dd47b997fe7c3229aadfa839ccf7e4484db7c0384a58f87a8970032a752ebcc35f4d6e53b6e5c7b8acc14265c3b4b3cd73d817c45f8c31b8e54adc2ac0b3a5133e7f6f648f81912a31207fbaf4d4e25fa9fb65972c428f01bf7f8e1732fe6dc3d8d910924866be829c41221cafea828911a282dfb6d9abf0e0d82822973165baa01e3cf8fe8ec8fc4ead4f2975f9f7e00ef11f3c373126d12e9b2db7bddaff95405e31ac6ad05e2b78145feaaa767e5a8a1cfcbf4dfff7d7829dd930a5c53920393027f5c23b9fd1d2664287d81d1f7491d42aa3c5fd768b0c8c1d10b7e3ca8d0654fac7380728c486c6dcf96cdfbb78fc382a777a61d64a05b9b1e18828cb566b09e82f7ee029e3691fd11e4e53b9e7c1ac3d437fe8e2ebfde3ee0ed1a6e68b5c66c02169bf4864a41c42d6a1bba9583ae04bdb32c9ec57e307dfd74235523d154068b2f9012d4662c71424b7280b62e88958578f6590c1c6218c2daf2a9bf54f629d2cdee790eb8249dee77e00fa7cbf06f9d67bfe29c5f365b2afa2b43c98739936212c53f6babbd26c1f68c41f6a4937f57ac3ae80bceafb4d36a786916fbfce8241772b2506c47fb7ce769ebc08086e326d2d5b218fc75b1ef5841ae8c14c11df3c7494acabac5ff4b1f2a076995199895ae412e7b6b746016a9f2f4b7f81279469fa90a2e5a6cb17a98d58bb25edfd6fb18bd10bfdb6c72a0d0cf94d99b5a4a8bb5d9525908e68c795e191f8fba73d477ac4fd8a01f21c9bb4890ab53338a19955f2240e36fab32592d05b82981c4777f0b6c5ccf8a824ee04b06ab4299bfce71fe9ca7de59a39ce16a6500d84068005ae805ad463811b7559828e53cfd44b4cb26accdf477494b839ea59a624e4495d7ddb41a4a5ba5dbd5816d1b61f42d0060d14d3a9e3d31cc1bac7c10819b6bdfcb02ede8f5dfd7b61eab2b16921217050ab801117dbe40bf6578cad326a835006ead26d1951f84d94ecc4deec1d2173ddcb4a6b6dc062272a3b6046770f60c1452a5634515ce6dfb96e4b2b37d2698dc0378bdf4f6038e2bb22afacfce7cb6b7058150ae519704c789eeddde077044c0c0d094d0ba7757b6064fd9a887cbfdf2c75ba6b87e271e178f2363b951d100d25af76007ec47411d48db148566503fef9bfcc4e4cb0a224222af6e7c34cef35d5c68e2af0dc314439f65cbbda648f16a5e503e1a4d9e49eb4a53d72eab50e7e51dd82abe26c1d6c8e428723b39f181ab75c6e810d66437fc56883310663b0007f1c529d1e099d3ad70734e0157fed273fba82d6da88f8d539175064f6db24d58e5295f44281d9fcfa7aa334e68fc182c3fb668ce38e608522fbd01305940fe7fc25e207d18535806e5593198d9e46c8eed752ba28992068e5cae5ac9e8b8a3fd119400d83ecdc14aad9c0105d73c75ab090abf2abb94757e3e1f8b77b108d6d3a51eabfb41c8108e742776057dbba8050788572d5a2e9cc722243860868f69fc2379c9be51777a7984caecd6a0d3f87f612d6e8b015fc2e5a1c982a270d5fe5040b7f2a2cf53a0c2a44440417849fdbdcd35a8fc7c1ecfabce12c454df406db34724a4a7d4c1b61f15f24e18b53fc1201e5beb83ea2d2b31b0dd407d2f45b648e75742727d35f3b775c069aff1582ebc3fe922e3332b819dd111e8aec62d44774480398ef1b6da61774cce0a6ab6e20dd2340ebadc57b0980692f78b6ddbbd5903e0c0030fc6743c648f1daf8437d4893d63f374f71a403adb529b669c5ff783f07a3d82c765ec3666e6e4f2c71033a77b928465f02204213d05212bcaf7014c1ac755c4d108fcc800a5deb33c6fa822ff9a2a36b59fd7608778393b0f20f738fe377e82de740581db0f6e65548e77674db7307145febcdfd48719dc5f0324714ee","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
