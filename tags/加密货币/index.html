<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4f4f295ada5a70d9fae149577fa8451f05f223c98b5722ccabf25d2aa1cdf0051d919dc675ce3a5e4b2de01492feb78ae021a142f747e92117b9d5b31aa82c67bf6e1b423d9082566977cf1e5c199615f75c64a86f507f280c151191b040fec8fde8bfca23f64706e3ecb63b7ea0be2a70d38d805704a24bf2634d9d3b29ad1453c2fbae3d08bf3f2dd1562df0955141f1196fb1db11c19e5a5416c51975e2eddee1e40ce8120b24ba8d067ac11722cdc60b3df1a117e139aa99069b4a85661df919df7bc0cf2efc38b81c3b0bbbb0fef87274d6326a3c484e52b736137fbecf1848b666ff776438d489fb339ba206a84251f8a518ea7f18ad04ea9c90f17ac76473e3d3a71492006599668d860230ca8501dabeba0ef318421c1071c8969e5505b0d0d372e550b4ac543223561995f4d02139537c69c8c8b2c6b524e555446a6a798e761ed995a8ed6174e82bbb905c5d794428dba824f77d8e71949c08d0500f7ac1dd8e9af089fbcc9fa6d977401adf516f8f35cd2d002287395599c612a650ccefca539af122e350a6fa97c163a3e45a8f120c121a75a65bea3c5a14ed5700f4c6b9d3d332d70d3b5415d4b54740033bb922e9413ef27451e95dae32e9dea9bdf99753f3b6cc41200a2e851e0add26df6b07104183656f7f27a254cbe93929d8a6e979d3d144345e9686819d923496dccdc8be074d0c5f52c702f7895f0e4658107a4305f9c617a049a3fa244890d588018bde40837f0c95ddb1a81048f299853d3fc375f59adec40b4a058704d1939c84e0883d9788e6673c3719ed1e7430819d79fcb5b6fc880d8d8ac408519542a471a362b1368d21e720377ff1474018b7e6690b7ad8108c83720b50a36d6ebd9b101519ffeea903528aadce2f21579957e8d9760baf2370722fe67bc41c0feed052d491e87e9c0a7d66db88be6b2a1ce5deff9c3cd43242cb33bcb85524eb9da8edde700dbe1b224d8fff57f6dff4d50af212ec7342fd5ecc45c72c5dd377ca9ba5afaf4704f9af33d5727c3e445d807716189c9d5611940392aa24390d035f79858a9f7dc10b7be6707c5805eb072ad4454d0587fc1b03eb51c114e4fb810365e6c7a5486a47d86d854b19d25eeaf0bf8e338f718e74259f802a7fdf7162d889e5a9ea4dc3c3e6e5c1d8be0a446aa0c4176c2ea250a74662c34cbcef3866b3e79c4ea55b94d57f9ea4c82bd4e7ddbeee7d65323f22aac63b929f7785893ec463f1e3fae78584fe214f6a489710dd8ab611ac53d828b144b6b6a108ad9babd2edd3172e943b75a964ac7cf561a421c19f87dd7ba0ef2bc057536cf1d75ffa296f978b2f40a058e3eaef093227bdb742392d2918fc49e4b8165f8ef86cdb8f5840ca28cb17e8ae85f7ca55ad88ad1684f47270fe7cc2cf8551db0bd74a81861b6257f2425776b622f76516aee57396de5f23e478ea0fbcc222421d9ecfd2fec3e84a689050db55eff7be6f542ca4d92155431e67e9d4d9f6626ce2ded6d121d5b2499935b2397dbf5a2a329ea2a4bc66006487684ff4410b59cbf8513e2e1ebfeda115d57e1b6d39d3e81f585470d3c4564edd7f72e0fa57ccc065e9210a7f16bc0a6b499d2d1b2a1d094f43696b8056699c6344a1e43df72b4c192175598cf1d93dcc2555dc578e4b68da9780171e048913eae34c93ae620b8caafd828e50b5f353c1f274fad7af9cf69573954873d9b0977e7f98e1ceeda0fa278e4d6478cc050627f86c20c4f82932574eb32ab1fa2527ae9fcf6b3f280eb01d6a51aabc49eeecc863f2e5e8e84366eaa171d1987fe84ca671798e59f113128914a2dd34179dc3e1937034e7cb151ea5f7fdd577e0e7900c4fc03264e5ec2189791f8d07b27ab44088e39ac10fe9517f6d5bed6abe870115bf6bdfffb0694db75f3f80a73fe0d2a01424b198ce7efd468f0839a4fd4a8fa994c30be7cfe0eb1d6b6814ba00ccbd715732661b2e0e4ece2fa0bf3294aa779b37658f0f064a52c5ebd2e4371c5c1c576d209f2dcebd4e43e6e13a75fe05bb5b646b4425a4653884d7638ffb80ae526d139be4624962d461f20955c78a088371c90ed3e5bc78d9b8e71420bde8d189fcd87b44125846e08bcd08f510b6d1eeaec1a69d732b3f0eaa95b9b068b7eecf988173e873d985d680fdf1f467d45050232b0b7fac1208ead9a323dac1217170bae8477bdbd5a85f5259c436d023e729368bd5785611963d7db04fe4a828bf6106a1dee946d61ac2ade73c6c76efaef2213d2b379dbbb2c627f64c5c9e1fb116395287239aa0586b1f3ed186b420f751339af630ff9d38673b956c17e086c1c635279bcb89a5c22a842c7ff6cdc71e00fb24b633538fa583f5e39899259112ef0753fc627c3a3e778dfb3452a604b5e0ccab24d484b9dfd8768a98d744103389228474507f89a9f614d3b4174caac1a3a9a26197582b530b9ab6a29f2db7d7046330116e1a99ab8939f4dcc1ee08fb6cf09a0ad279b585e153ea21c3d7ba0a8c0f714a41b4f5132ee633ab07adde99a0536f4b07183614b6b83c5d173d362797ea78d24eebea245be23e3709aec4d0211fc3cb93944b5e3b37cd58863be75d54ed626e0e4568e62ad1b251845ea2b558bfefc248d2d371ba97c4bf3c7f35663463c471dee30e15d3ca4d6ae0c4bdc371bfa4978b8328e71c7870e03b76cf9609d25550aa4ddf9cfaf80e46331bdf17039fb7de832d0df6881963ac1b6ff7409861b5104aa218adff8a546730f8350602126e2a0b39fb5c79bbb684a6576032a36d8996c6ffae6da89d4e8f7055960204498e3f11733c8925676b5497db04c90a939cf05e7d30f5288f7aa29be620d137e8b356bb087cf6b2704db9fa8975444a6fae3a4a22675553e63b40cc0859eeb423da1359ade5afc8909db89d91b3d11084522963e01e91262e7d07ef1679a05a885b1e3f3d013b7239c5672298e73c22788f9ccc1c7ac43257843b8344031187d602c608ae733ed934e2f82c5dd10448d47d1e3608329b75dadea04ae7bccddf477008b784a606d86a3e7317fe602d67b636444901108b729ab8671255354b99778a69498ac8fa345b5b43c19e7d4b0017961148081f861960b3e32b4de7d902f616e59afe632a35bc00e5e79fe2c3ba2c5d01accaf82a9d4951e5c1a172364c040a50de1b926b2ee6204a3e1f157240a6452cb7e6e0807a76e5ac68355595d214e22754dfb485fa144b4a245700debbcfcfaf9b9fb3ad080695df12e760892de819749fe5696862b6aca0176945181878fce410ec168a52a477b4da7a2ec3c1d823e37bc3324314f3fa1db7c4f4a539906e03f83ecd16e00f1281646c3bda0113ac76b19ff5351bfb793c9d1e692c1f9d778d4aa5eec1206ec549d2070faa9af2355b57abca04869add1190591338ebe511ca6b5f99fdadee49ec26f9da7d018932d4069aba75db50819866c3eb4a778e270424b10033e44df628b1b929edb6af32d4cf6278cb5af017af03e81eaae9afb1f47df724c339ec41694601cabcb478eeb042065ba2896c0a2279e54c3c5a1d84fcd3b23f84fccb4997c50d75b8209de126f49cc9c6fc343b36808645bd2a0c956bfab78bbfbf867bb3eff8cf4c981f87ebb60790563d8eb15614093014caea668f7cb283735cdf9ec2f62155fdffea005d6acf09c2a6e9c1569211b7a69634c2479d8b05ecd820ed8c1b8212ce3243bb82912e1397a343f49fb0516ac5e0c70ec3492884dbb571d54b999b370dadd77b14a22c1fe5e578d2c49d2e4a1953d799d0df940b712faab4bf0aa41fc4da3f97ac569d7d1e7e6cb992508b128fbd47a41a89e0687769974d63ad7be76ffc2b1aa013d0e53d1aaa28f32dba4c30a59e2b580074e320324b8caac6221d59013f951e1780ba3fd2c6339d473fd5ee2e3174b862e31f54a1dff51ed7bd55f1907aa47cafcf2a479ef76f7eec6f65a1c58bfbcb0db0ae3f59f303002462cd07064346401f33eb9678aab780a1bf0719e98ef5b75414b0c1ea0bff1d234a2d3ae6dd0e593a807bc7d106f6e5e6ac3aeaacdd5cd05bb36d1d609406e80870af91d9ecba9d9ebebc30c971281f81ba93175ecfd3625a7c509909a94fd8399183dd496d3732035082bf08c7ca76a55cf0fd116312f4dceb3e633abe195d53ecf9a5363faf1241e7bef69e6ff34e8928a3cb2d85a8e48725ef75e5612577f8c4de33863027b48eeffe983f1f389542bb52d6ee4be002461407f9bbf2dc05300b1c1c65e5fbac4d7b552b0f26a9394306b0637f07bb4d88aa41ac439a2a343357ecd24164016c171dc62726b6bc3c9b8fe3975594fe8b6b823c55530a7d3f671e905820bed35b021befb23b2c369f4e028a471c35cceeaa8d8a3ba51b570b0911ee190b7f60b57902adb5ec85085e1a1f8ee3ceb35bbfbefd3d846177f6873dbd4abb914dd55fbbf882069a16e5f337943ff42859c76c395da71c3f36a382ace87a942159f77c7c4c6fa1ac4a8175fd7157bffcb8d44753eb7092942c74cc50a31aea4bfff97cd838396d5d7f8f3407dd1427e368800e1b3aa6731de8b449efae4e2e415669a9572448efcadb74b9c8f9325ecd7b6de78fc4f96951a1fde2da534bde6049282cfcf683d64cfee50fdeb30a27bec687f14c814d1e8753ee75f50deff3383aa1e558e21a2c2ddcd529e0e56e5bad04e933bf048948585ab3001890013947bdc600b8f63f9c95a40fc4c2dc5e4ee35f95f465fd805757ede15cbbbc15b316dc145b40c732ae442dd31fdf380adfad0529652ed6e4fe2f3d1697c44eb93f8bba03a9d9d4a413f2b85580839814fc2bcc4fc296230ca7d6e437c38b2c055b9eefd27ca4d2db9a99807655f43c7ff2a22a03b8519dcbab01d48629329ecac9995f26e75b02c1168ba62f3eec116881f4397287287b307f65d57be6282a067fe3f6b3678e849854620c653402c34f076f582558db4b419b5c25284dc1b99bfb27b540c636f3fb7f53ece5b958520266d47fc1327b6b1bbaef59c4c055c2749b1ce0d2e80d37fb21f9b41aabd7fc1311e50ff398aab1f4f25ac7a5407592486fb96d71d493006d8016a9e1830dbc02cbc65061a4babcb49744e522b3d972d29e2329fbc40fa63a7ef03013454d3d9f3dc80a58a91f79cb62a0abd4f796845b9c1c967521a3e1b578d38b27e358d0a92f99628d5c9c59fab8a25e30bf97c4bd395da39fae0af2696ab194f3533886f0b76862bfb8f00c9c81063072c253fe197eccf076a8bb3ffebf0e01cf4aa46f7856a77d558a0e622d3e6037bb7545caa4b5572d42df795c04ad79eacb026b2c1c373d994ac7deb16c9d732ea139a2a5c8d937331f92803f088fc487505511a6dc9d57710d33b2fa9ba88e25f114efeb65d8b9c7bb882c3f64eaa0e9400c9164fe8c13162c22540a81d52e42bbb464f9a14a59f4692a6baabe6f6bbe62684c03145af66cd9ebd8a3463e11fc187e222aaf2453b7c268eb54d5f0f2f833ebf946e4897f4690ac2739f01b0960b69d2f4f3b58b3a895be3495b9a777b9c41dd2d94aac1fd33203907f21d579bc5dade9fc490433f401766359c6118b131288fc2f7046d0937a88b804b6cbcc7a49411fa0901bce0e43478ad99edd4ff62c73d73bd78e96f708f561fe3080b8f327aa3e2a42d5d93c5259668e9c8d9a94cd18d432e9c35d4b855f79daa813ed2a248ebef9b8e64d52a14e1df2a579749325be8234903e1f6cddcec167b20a1ea412cee0c5a7da200bb30ac9afa19ac37461ff71ef779a9c7bb9b97b62f8bef98c8d62d6fcefba27a3a99db73737149050697cd9dbdc401866558fd86ad719cc08dc7d6a6f1449dab1ea0c46f9c2896fabc33cd7f2836977645ad6316ff6dbc162827ba35c7e3cecb594774ce8434606b144d7cb607a8fedad8112938d2d33359aad367a44216cd2b4cc33cf4411683b1f12209bae45ef33489c426f431af03c6580c16ff64d3135d7bb3b908018a34c92613b1172caa28b27340626e7c0e2f952f4818612adfbeea7ba55f00eec3d0b96b268d6b801eba030e230e9abf4d339084bc8c809ad4d0fef4fdf89f19da53eaf524719b29b5cc44afb88bf915d4cd570961a0a352b535a0b5bf8f90aa92ee5530fae581d4e0d18f5d3fcf1802a52a1c10d352ea9d592b2040b996ec6c9b9b1a920d5660abd41a2e21aa753f400f455d89290bdf3a0f7d793392b977c0e0c077db94d60362289af2ef611ba71ec2c5480ee4478e8dbc9986788a77f5a8f05954d80339421a5a10d4d7a5e1fc778ac3fa827acb25aa355a3e064ccf87d917ff2ded0e73844118651f65c6617d81fc74cb0f698bf7e254c7f1545df155fbda30b9e28a15809ce3b48ff55cb97476666ca3d7201d7bcaf12a0e092d8a5e72fc81531ecc320531a9a688a99326b5e5bdb59a3efc7c11e70b76eeb3dc0c9e39d442549214682c109a17bc692037e5daf0b1ca5ebcac0463593e5e232eef4ef1a380221d4dd3d2b3471c3a6028261e767f3c027b78b532fdedd3b8c2c950743a867c820f66aba4aadbe4152ae8645bb0f9eaa52b83f1b0f57a299329dea6146f974fea82ff9a96d4e6e6c8deaf88e5dec39c106088b20060d968e4725a7fb0af1dbfae97ba248b94370c25629389d9f58ec3f4c083c216a7a120c1d0f1b62c438fd323d3712c8b67fa4beea8d5e36c0a65cc822ebb958893f9d82fad4b269f304f866cf542678770cc893ea7be06f9c844d1009e35f3b7e44edc9077a60638e2a7fe18bc84ae6a491f691e621d97f40382e3a074669a05f8fdcfb9e7e685da52304fbe7ac2c9a50bfe1ad867f0d988607921a82826a6c6b11c8989df2b6f9f79f26f3291e85ed96209176442bfd6d4de9c806cf770276263dab2f92ef527abdb6d1d08f50726ad9c37bb72179a91ec850480f93fb4087f11855dc91ecda2060f7f56cacbdbb3e3db9a0ec8d489b4d22dd9bebe25bbcab4eddbaf496e666b728f168546e65e1d3005e0a6d447d4c49e2e8fa414965cabee46911a101478d2823f205dab80220171bdc3882ce4c10ee22829dce33a3b85e197e180a68fd9b32d242e27c07b74bc853aa181b1aa7370fd0a43aad69864dac4b19ef7957ac3c311c5e890abca2eb8f5d9f432b8d5827b1c837e0e3809a5d23c64804492340f7210ee1e541ecff2146664c549da567ba247d75532257a048bd3460c8bd2d7bec1df7ef30ef39a592ca4bb629317c8885820929376d6f4d51fd8a52561ebb53a527943316da5294ea116f9a2fd09cecc4849f182ec30a0c16ebbde7ad87240381c0c270505f02e3b4633f50d517de2a036517cc45ac4b3a89222122941f2b2579d5e293c98b63b9410c5400dde18cedd010240f9732ead8f05b5b4f1862c76ac3933b1388e2aab418da1e0cdba965dee7745e17a73d9b744e29ecf7123472b9c407cd6abb0f4e38319aeb1b2822a6f951be49bd26e7ec6cb9fd52786cae98468cb22db9231b0425b15e8f77cb8915bb05b563ddd64b9a222d3eb7810a9e77bc82751e024092b147348864cce53f5c2a89ba5bc3a4df84d47cddd94d9adbcab488ba68ee6a4118fe402a08cb72d55f901ec9047e1306393a1bc403a91392a3170d90fc69201dffcb5a08ecc6d15d7a5d467c16733133f6e446bece57fa8b90f3736ebb79189fb3da818f1f2bbc4b5354dc489ba90b2bd107be31d9185bcc130d6a0a8c8b4bc9fbb2a7773facc4686fda030ee267fdc2bb85c64df5358d6fa514f6ef1d9112bcbed137d5b2823453097eae46f51ae1bc06c6a34a7432ce2ed05de561ad66eb90d4d3e0bf7646b175d37891c27e93682e3e83e8d5c84e51682bf8ce785b43637184b1c69e35a445c6d988d5b0fb6ef5c46cf6ec95e2f6bd2b2922183d2468a23b084044f029c83c3b5658085c2d86e79731b51c2d9ef0cca8157a7d11e85f4a46633d3f89cdf82d3297ed6a4b6f3a70b741891e0c932aab4bd7fd3c3495d0d9743dfc89de9aea7847dd302b1b7c5c4accf8e03e3b4a70601d738d810286cc797008c492ba1caa32630b8acb8268425911ff47de092f36124102ee685fbc6eb15bc7615477ddd3e46c7dea6e17576948d7b4b192e83cc97d2f5136b82086cdf0162e8874871bc4d3559bc7210eaed3de43bce4885ad93ea321b434c8623a365a3f48f2cf9e597afe6538255a4e9ae0a6dd781efd95ca0e8c13e85f5ccdc1e3755953dd3fb0407a2dd35d682df10104ea2358368b79eb4ac59407b1826ee64f1cc606a9241ea6e917789d3fa11c5554dcc54f67cc78aadbd8b126cb5ee51ce6091667f96ba7a7ca54e12ea70f89c1d4e438c248ceda9df439a0982bb0e4f02e1cdb4feef0452346905e83f88b607667cb8b6fd507a4adb97f514da75254e5d33996ec8cde4844042de6e33740542c140ea4631f8540264ea5a067334a384ba8d2718ea3dbcc5fbaa6d150898f54e749e07b4627af06ce9cae9fa834a59ba680f8343cafa30fbadfffa463fc8f6758bc559568d7ad3d606331a45eb226a8914722c331f72a548e0057ba06af61c231ab17e5f6f7080956f24b3d322a1a7281849a77a17261cd74f6c96806ed30da5f077ed79e5b3c01e3008938af60351323523e0329216af200e469a2a6a17a7db052a23f929cd72de4e4c253dfc65e744fac54106662c67337cad6c47f54b0263936040a254b1570951a68386270b705c151a103e18059437ce86e356e86f53490fa005415d48a6ac0a1671ef83b7543f2b727c3f05127b913b1283fddb0a9a075366da1f2af0805652c8bc26c5c58b1197be807fc31252e9c1f9f201fe84bbb593922bb8eb41bfd1f818a6b648e6395921cfb90619d5ace53e24a5c8b1cd5399c62951be374a829c42e7d84ae5b42dbe9b1f4e4f18366661466a33ceb5c4ce8c771f8b53db685ae1ec38eef76ade86e25ff0fe4a41a93c81c91f1844461910e891d1440efa7cfaa4a2b47bf9f2c28a317325a46267e55f6e97c8ab620c0ce870bdae817c93cd4febc71c9bf267fd7f928b9ccc93675f020505f4ea36bf64756aba49e74d3d8285bdd523c3b5081ca9edbbacdd8436141ee059b4a623842282bebd753f457d64985e5a73339ec7cc97d60095e7645e9cb99db16108b481ed596d877cc387c4a4a10a5c83513d8704d78b087ef2f69a090377b57538d45d9d063a90f4e72f1dca4fe35114c0f1afdaea72b258b00322322244f46bebffd7ed37b618b544ebf35144befbc4e343f59727864af658453d4d93d3452d727f8d308a5db58e8d6f27d1b2432f9270d61e795b3d67177d4edebb6b852af3c561d89d43262c7e7d0ef80616d5af61978ef354415b18c551e365fa0fcbfc0c8ba20e335026f24ca21cbc03238bc6d403b722760f199854cc550b43fa0776919b4cab276ab50d6813f9aee569ba67ce5352e1581bf8944e37807462499c5b9a24cdcfc750618c2daf71b384ba991f74a2c35b268597d4703e0cae6a728de9d0f10c7820246e27abdb2e477619c55d55c08a1347322f14229edcec54498e32abd09d326e07fafc47e6e36b2676ef3e037ab26caa3415f63530d7ba416a6415e951f3d4389cf922fdf2fa8bf76cffa186e2e0d0fa1fe370d803f2bef616ae05bca2ab9bee64136f9bd6601610ad02422ed30c8109fb638d4c2636ace7829d8e55f7e84c5a16eb6015919cadea1d1733d712927541521cea739ca4117b5d3955099cef53516351126b8d61dd8a35e09276b53f98e2a0ac94c21b48390c18f2ca9f312a73c41cf19b7538f2bbf5b621b2e94f88001ca421a0d73d354dbc48bdce9fd75f2bb8f10513658193dbeb2e2d0af7d3df150363043ea43fdaa759cc7d374887b61746b44fa8fd8fda16499ccc837e71792da6058ca7a023cfece93b6d7b47a895a5985cad8563cc74fdc52901b1b4c73d871c9c135b5e3a938a42a5afbacfce42eeb5802d6b6291ebe16acc679069ea1d73f2c7c266f03a29726a09b2282b76dc0a280ae700281516f500d5b221596ee675f9115071bb8fce2a617627a437dbd33ab11eff74444a807a2e285cb71d7335aefeb734cfbafc7b51a1e08857aa67b8a87c5d819271f4cd1b33dcfa1ab64c0e5dea7e95571f6e08a36afdb13a6ec3cd4163b581b71dee3a450209cb691a056b67ee48b10ff2db4ee4a531af5bf47d10b5e7924bd875ee8142788d2108a263b02fc57c84dedce7d222c84fc2f93b462415c38f815330a9fec7e81fb4bca268ccd994389403d71ba51fad282da4b8b63f65f6b5e0cbd78fe8ebb114fc04dfc26af354fa29eb0d1c53dd64499e41e1f23b0b96e388fb87f8c71fdd4dc074885260447130c0a1e75bd5551347bfd07d0fcdc86838771eaedadd7989f56095bdba48f482c697a44649b84fb7935295a8fa7c20946fb0f4f03c557f002f75d6da2e659fe96c335d7a4242afa48e5f8dca725ffaf970b2610ccb5f3de6f83d16e055f7a36326fd8182e3b64d4a0d5f3b63dc028ad284608ddf11d2a452cae8420f63d8f702b9fbeb2402697dea48000e1b22100860a69e01d557040b25713106d1bf58e582ba967387a18942d58be942183e8b5cc96c479053f7e07b276d726fc2e23b6494849a571b9dd82c54d38eb404dee7cfb6d4811bad3e964eec6156917dc7a80a173b357ebe5f0b57164921035e9db217ab35b021a31ec12402c6f92929b2825af005a2fab455e4599bc3cb630e2c40beadd3cca969592a86b82afe900ac5c5acf6a4f36e62ad0be07e044f51608b44283c63c2788319de77933fab4179c653eddf8307856f8ae909dd9221dfa1ad726e5d66104b55e47de8bce076ada673ea4c3b0c93917e470bb73714c48f713a0ae728c2e6142a78305d6aecb7599a7c81a169dbdd54fabefc4dd53cd3d0dcb057eb920cf7f2f9dd874f33accfc02a6fad017491afcf0fbd13f7997dd3c4fade467348400326dfef2f819229ab880cdced2853af982ec6c8398c2a83aafaeac5444946dfa514dfbb9e51f12825c5706814682fe9df87d0e1311e4a67aee6cc7aadb7cb4a180ec7ca89311c8ef766ee04f8bb12f3eddd270238671d94625cc0e73ed73def38393ad6d866f0bb1ccd26d6a134b2b7f29c3e182be3ad71f586614eacf26fddfdfa43afba5129780e00dee319eca222aada8c71d39c26e64a4487b9d7d74d741a1e47e9c84f26b0de8560e6b7ce259884db05bd35547f75c63421db3a7d5ff245e2399a9d0dea91a75c5bbd7263fe9b98da24ef227ec8ef3f8be88521bd97a46267218c35a05a10e30f53665dc3d875c6c73f0e908a115da877f5868d1c34e0c2598c37d31fc711520f04b11a6888d73f44b041ce2c87d012f2930e46d4346910937e19e763499d8e268567ac40a470fa63370dc00eaa1061b048dccebab80836e994396d8750a3e5665af3e65507718b8c47dbc1eece5e991d26bb1e28113a3255f5ab4cda27b6ede114e7f4c52207ce46b59148a8322c2a36f3423e96350697b143ddc6811ed6ab46b59672a42fa220af8ad1ab78e18fd146205edb384149c064cb2b6fea51f1d4ec7d8259e471b433cf55077828a5c6665fa0fd7112c725cc387d1f6e77a558b81e832c5536ac770916f4633b13b1cf6353a693d22cc77f0d350712cb68584a3f6cad8a29612e6e437957b6fd895d1ae1e26a0aa5fce32f1a9259d64fd82765ed59173efdaecacd07782d317a54422bb3acf29f20a4a6637a386bfb7e3a81e38dff1d61597e08b0786f3ba3684200024f41f175d3d5cbe75975a9677fb4b91552d5994739c95c7fd7001866c8357de7f4b6ebdf167850739047a05d731161252de95637ed148c280a7b66f53b064eb29161ad0253a973eef930e5cb576c92d1beb1e8928f703f7a227955ea37271ad1ff6afd5c51ff0cb59538366d10f6387817822efbc209df7754422b396f5ac4b72425040d3ec196a9c74db3827a61cd0bd7d0b052969c02c33a5b709fec5ede40660d2d6cb91e009823d924d8100cb0cec2a23d2267a655301cc6c149cd215d194371a112fa622e9db8ee953e7818fa40ef3a8d37a55669e9dc61c68d6c9a99d3ec5b3d1a9ecd3e306138ae9db47ed8772b5c41363f3f3634516126877bb500f070a408eaa30f1907a443c749a2bb65f2f51eb8dfd968b05604d5505800bdb7f709035ae3de8ec8a7b33870585c7f7a2f634d0c926963ede86a4f92b066d93c5949ece9e7a25a1f8ffcf038d5db3d9de6d8f0eeebb2f204961ef1255e05c25afc306c066afd7416332478338e59362ad651407563588d8a7ba755fff9e3347ef565c7beac4bb41a64b266dc405c95d50ebc057e20f3b7c7de252b0c217503fd0f0870e09600815782f5803ae27b1cafe741173014fb247eacf0265e0c5f962a1073","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
