<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5617fcf65de9e33e723e6b3a4c842d0670df0b6610af7150a3d559dbdeddea92b676dc1cbbed7c5bad7f28252ab6e909b99b390bea5470e411e2cf07095fefe43fa153a39792a07fc79b9ce3c33b23badf6087c75a1541b2e66dd844387f3a349007739f1e3c4d6f191ba8f16d103c72e1d8aa7489b10443d65be7f65a0328a9e529346e9eaa0ce3d7c77050077136453e64fbb9e09186450ea7af560d041e960227b8fcff7f1ca3db72a38bbbea076d0e7c9b4025bea1141896e4ed2d3e09d703f2bb9e1ad891df9b02773e65a9f5031e349d4186aeae52e65a1c18b950e8d940498cb170b908e496ce213d3eba7fa54a2c788758600b10762b53f1ce5f13d95ec311e2121d1534eb163b87ecb675eed7ff7af2b16e949a450988e0ad9a761f03390b3134dd47098e5ce9c134f4a9c51f0861a53869cb3ddb14ccd0aa97f77fc6ac62cec3dad30090cea5ad7efaf43dfc9979f786e5bd6e98972800f5587c32aedba003493c4fb2be95003eee6e4b9a92920aa07b300eb944eacb6bee4d75ef95084e505f830c79190f9decad50fff18a0bc4ac711c11f81df3611d8ca36542e9d09865c9f1805f0dc732eef27fee14fb9519e2329002311e84368e4617b1eec00583cc8a18254b38c98ff21bd5a2aec967d7022b24cc941a92086c5112987aad864a55c885eca5addcac096189325d55cb9d9fdd6f64cdcbc242be0c3e67bb7f1c968ac20644acac7b0af86797a5001923b9e1a1029dfb655b1decb704c768521d98bfa56ddc74480a104527e3de5e164bff4515114f2722e535eb1ded8aa62ecd25cba326aedc8cf45ffb67ebcac92146b1a27bc23912b3d6e1de0eed09378db6de23974f5ca4158bf614c736c0284896d3ca655b3c88ac22280691b1097dc1a3be314da2b4b505d8651fc24216bf759b82bee69ce9f6a2dd14cd9d00b29177af09c53696647c9fc8fb0f3b7c033e9426cc3ae9f60df90fe3c49a292c94e9bd478a8b15dd2ebe1286a931ab74d493952fc38c5a0042205c543dd2faca64f2b582b02cf22735114ae868a2da2aab2fa9a535ebd0ebf1c9946892f80b02e50cbbb2597010bbdb5d0be62b291fe4bcc6e18a73330f0d66f9689823d90c6e1373d8788654918e6888b360dddd63dd28b9fa43d691e84b0575c4b2924a738572c130e54a71ab0a91dc2114c32769f291ee9c2fe8b9fb12874c8f59458e2e2d7687832593c01a14a08ba6e96bdf3c31eccf9819bbca66eb058d224808d517f6f612415e8bd5eed0708a23d898b8d4dfdf9fe95f0dd7dfd6aa49edfff9793bd870bdac76e26f2659070dc737f32feb0ae2f52c1ce3448ab06610eb822ce252a3e40588a28822b4c0a147d4968786d7a784a0abd7b385a543ec17c91608b419dc24bac938f2df32c8c6677ed82d3c7cf503434241c4456dd918ead09bd9d0a866a20e82c6d919dfd7ca811d595c6ecac23e7688ba6a80f384f7258fccc3af655e6154f5cab9771002a2df84212dfd020ea4cf8bb9ea9fdb6201d11f90a37a3bc33246dd08a1f70bb0aad7362263d711ef0220946d5cd7ad00ecbeae3db5fed01838ce11268b70875ae3529cc6cf3368625b3d463511b301b0c309c133c535fffa2a6251d81db292a1deaf4ac3e87ba1582d1e013a2ec30eb6826bc456ff50f715251fbc0b873d3e0206b8de5fee51d18b4a6fe29528560db4be15a6be1b64c950e3534087b60ca05dfd2292519512ef667d6d6a92b55aa8f7a2a517023e309869d406dfb936b12ce32f89a2ba95bc9cc891f2aaabc548bce46023f59c0fe0d88aa136a68b6200b288da50ee3b9a799c8da78e622ac19f64eb606b799a931c09e1b6fa871a96324a1f34a3f985f337d1b8a36ea1cbc9201870e568823e3ea09b523bf1e2eb531f90235e5b76dc78ec632357e9364c3cf3d7854706a73708f7481658dec0695eeac53090a2f2d0b1fe15c39e1be5acc17c9b18d141419f7269a812b7e874e28027f32feb935bd69f1b04dcf106d046733f9087a28b48eb144725e70fcd78e5e4a2a004f16fbd0ea73c60d10c416d389289be9f72a0573a919ffbbee1ce0a2c25d911049a5bdfabfbf94a152f00540f5a1117f12e82be54967b0271a8daa497192489e5edcb5d1d883e8a199de007354274f189eb097c3903d8a96e9f0046221315ce24fafdecc55355a853b376d0b12e869c1aaddfa5f112f00d6e7ca143ed804f74cca35b0d876dffaedd07e5ba91956245e4644d59afe895c7d284d342cd2e09df04f142e52c1e794f6eb1be9f92ca03f3f3e53d76b7803a6dcae060d5ffa6d9046c9a7c2f445972e695356d75fd208a69af4a59986c76277999e622afaaa6810eb95fd946ef292a6a26df9f1ba00ec1bdd26d99d7dfe75431421d049f026327aa8e2aa1f73a1dd822c7dd116cfd5680ef0c87ce0739b6029384a10d1f462181a4a04b8a47de1c9bf9af84a38e630ec31799bfd4ed08ebf15fa75c69f5b5a9ee9bb1b0958cec2fa039b5d9474ef8074ae2af2c1b306aebb03d1ffb53e8a43aadfde41478aa230d69c5ae52c6f6eb22866131a3df8ba7cffdef8a844ce91e65ed99c436b030dbf554e1bcf19e7851e547d4bb1f0b95868a57cbd9d878a6f7ce77bba679e9b7fdf07d198b6c5f217acf17c5b348709c590fa18f2b3ec574617db8480b85aa8fab8d949d07581d6341dd77ea43feeb44e33d2492377646e72a75e8b300185c4e894757076411b51322d227edd8ccd931a3d9e53d4e24720d6820bbccf3f62f8b34d11418907e3e824e54df47e0ca8b9066d7ff2d0b87bff36256783d7994848e1283b94b4e3d23d6cf01bb527a96ed500068bfffdc8e9792f6d39431954c301eff53fb8b5dcbeb96e1065d961ed63d483338b0ad20b4a72223657a50a7265706216dcfe3db8c8817aa98974054b74ea7281b8dac8c141f4b158d085a3f7c364cd2ff567d0516ee1088d1f8f9152aa4e0d9708fefffde826db42098eb52b34a27b192e5b18721181d1a95c53a9db688d71b525b7657e9c7cde32a51873a2417832eaf4b78459c41912de4cf74029c323e741a1a333aa87d354bc0e0da21edc2d7700d228cc948f67f240d950f79af12625965b56450bcae40f8f50a0be310c62b8e2dcc0eabfc600d396cfd1dacd99e8935ce25df733799b16459988613da27d4e07f5180707bd41317e6e696249663b7744a60de740125208cd878551bcae5670dd85785e4fb757261164bbe453d7af45d2aaa260395c555e09c5ed5a2c80ed8cb2e54a48a1358a66bf6370ac1559c9da6ea64b3d85ebc41bdffbc766bcdb7d48b38b48265f227a575cf8c6749b49e633128724e701ad9ce00baf95e5c73ec85e4ef45f203bd9b78a4395f72e24a822c90230426bd53fdd88f428241292e5ecb52e935f185c11744bf2ca49f2d8fd38c40b7c939ad32cad2ecba09860a0f861d75d5b1dcdf445f5f35840b0d53d4acf741e83cb98de8bdca11eba797ca4988c92a804990af7598c403c2e28336bdd65fd51624810aa59a393f4c500551682e55b1a4f10ca414739a23665a74a4abe7172fbc1b4ecb2bec125b5c4ef7e01f00ff9acc85bcd7a17f9202e4dd9d5311dc4f9a08644c4b1dec757b18f1bac1d511df177d96258c6249c94744816cc5a63974209e39e3906dde7df782d9d7bb2412d55b52d79d0bd9e18035acc6d05cf2f7ee3f558a9cced6f946b0d8cbe59bccec3c95d7513997574cf39ef6b9be2b4ca66e07f505f693823f28032f6899cec9d52e938f98221e5b042b1ac5d1b8cdcb10b8c30c20cbc2858bc841d757569924fc2a0c098c9022d091ebcf4e7d7a74687499517d7850ae55e896c643a9d910388176c75f49a53b0f3b92d85eb6d96c79cfb590424557d5633bdb102b2d58252af6aed37b10e85a2414b5e6f872ce8d31d3d06b40080d1cb2da313bf447d6aba247cad7f8fe9378b4fe8ba4b082aa048def5fabcf00a7238306b0797e481b189ad552a407716f8785379fbf46f2e7c235335204a6af5038e9439dfc7cc7f27d603b77a6786b58acefd9cae0f1b1187ae9616489ba1b6324c7e0ffc32c86a7a620b02e79ce94eeb3c843b3edd5bb1e5b8e09d345fceccc461f5c19aa156e13042e1b30a6f973364574b29b71af148df9c2f8c9c65d14b3b168a376b3851428a7c25c841a4a71249c593bca0578604bc5d7e333998cd7beeacd9ae3b3f0caa8c240ff66e1aa5990a67bb92417c878731225e34de0c07bafbc01d66b27952ec2e5e72072a25d203ef9c179b561c8c0b5e98525686b9466f0b77fd3ff977249115e0d20a7992dd4b71744aa83b5d019b9bc74336384bec47a45c1a1a2dc429ba235ae03863a67f2bcce36d27b2ee45be8ef10ab97ded0ee9c59f5444a1f4aef15cab71e4c781d09d65d07d5a712b453b7d3c8cf91bb29d486199f462058273aac61324989f9c0a0774c792c1a09b84f28dfbd37c31688931ae636eec415cf5f1d408385325723bf5716d943ae2ff6c91998e19b6e23ef391f5a29af779567a1ba91651afdf59213873d422dc61c8808a38d68b4b1bd72d004ca3eec20415ebefb890d3a7e4aef147a1027a7b557c5e2b2e6a08623006c82a2fa24e7505f4cc890a14378800f410a6a840bf0a72f8e0eb4b15d5f954e017d17fed1c3b5f3475e98d3cf8660ff82ebf426dc1f4e18656cf3cf0b7bf9209a189b00cea74cf96938fa36aa5d3fdc99c6b22b415018dfd6c966b2de7cd6ece4884f72085325b5345588e6628adad63a2f6608033336dfbb1ded3c77cc8e5f9e7565ad836346a48ad886ee3c4cc3d479abc0e3249f077df2257b0aeff989b3e17679976229bb82ce9104c32fa697237dee5d520341e3e52869dac8100d2410b65735baee5fa87f547210e8e14b68b73dbf3af4fd4685aee6b934881a01b1afc970dc01439fee0ac2d221ef385b35193ed775c756ea3066fab46544ba4363eac1063fa046e63452ce44678b184311dbcf842a2920e272be5b9efc889128d781678c4400099a17a40edf6dcbf5478fbf8a7694fc2666572c6d93ed5507b858a47c087a0f64719f6f25e32bec734227a0dff271a03dc0a0c517a07557f3fe154aa580425aa76d9af3254e20ad3084df43dd53d2f09301f405cd87d2a4d7576f36b3d6a6845286afd45d7cb8b1170a9c325d4178a8d10cf44551f789cbc6137e29dc2cca2c17f700b195ddd3e0ee58557c6aea0bef94312a5dfdaeae1fc0e9ef48c31641b0362ad1a8d56304ea9a9250788fb6b3b8a6d00ca385c5174bc79a57486426b177f3db82be19b5995afb92ec8f2926640fae1d89c0e9d8534754555789f3ebad93da3ee27e6978d39fbf15af2b1ee378591854092dcb249e9d74191c6a1a57d74af95f42a4c3ad0df794800e8aecca108534885744fdeafd5b66339396d66697150331007836a8eb961539cfb3cecd2e6c820a9206db47370468551c73bb5100abb2ef741c18c510de2a637cba7273a16b9b7eb48cf37e96cfbe24fd5423d96796836c05df317693eb93a30f2383a75657b5056a80ba8424d908dd8c5f47b16ca0f52c24a3ed1e3739c122c022b79758708e785a2e7b7af101cf7f514e22297fc0bd7e8b2d5d0bd5197b04715f7e146f40279441f4dee4eac9e1743fbc3914451218bc05deefd5359f879ab4608c70c1d6ef58a8447954b52947378b5107c66d358ef37103622cac409593af24becb241fe8b40f4e5bfebb26495fb4cd21c448820cc3d25c331716d566fee1c17b7af94a00a24d8054eb14281caba5bbccdd9593c24143733509ecf46104d72fa35a405bde9895f905941691252a4e36ef51ffe389d1f2c025f3abf068d85b06f655c94e1a369faeab098a474e99f29fc9d407b896f502be13b8d203743f8f8a83cf2e4e1d34e70f1e84c38b24fda691d4bc147b18e59aa724cd30477ae1fb8e92d5f62bbd5ac54229484e6b479ec4f03c152ad6aecc6d73d5529153b0e613f3f849659a0ac934b031f8501711a316e6db657e0c714e705d6617e4e2efc5350ba6d4cd8eab8dca63a732e130621ee128d2af82325942e10d884c53370a015c380da271ee2d4b99d74b2dee5ba4e75f0f8f666d582e012fed8bfb32add5c6ef34cebc567a8e4cc25473216d427af7f238f1e37bf25c5937a562133e028dd0dd0260b2106249715e2d0004265cefb0bcaa93423e17c94f547c5f06428c8e435f8fecc235f13dad8ed8d767ddb117bb6bee86fc83bb9b39d36c0d5ebf5ae75350eeaeee7dfa5db6d0256ac5c93be964a50cb3ed1c7726608f82330b420530e30908484155d337215defad2102f57be086eff102d84ded3d74c52a96faf09dc2804af40f80228847aa3c7f5a07833e390fb709c9f61920fb83d84ff5aea2942ebec4ac58a16d66036a22a523cbe8a50801e2f63869de6bc9c3f2762c9f8b03ade5f85f6dd5b48afbce0803f65f25db39a26801592568fa2e4f9f0adf96f28a2752d06e68a3f302a17e208e15672c79fcc385dd16da90fc747afa8d49b4bc672c863af105cd8eff54823e196a17d50d26f3eb78e4cbdad88f1c73fc062c624c01b39c77aa062992e9eb24d4096c0d4829cec59a8356c17e26e35f1b81f4683fb16fddc042043fe3f2b011a6e766950a6eb1f7fe63f8cfbd580ace7f170c9db1ce392ec88bf62c1dcc23c12538210a06a03c7072b4220d87e1b173a05e963fac81b11b824f20ad9d5884e14b3e106950bdbaca895b9c940594865fef0aac2a4b81448b63e11b5b47b0bf2f7c158c14d419b865a135521a2d484f8bde5971c74890e084d239f0a7ea90664d347befb0f7b4aceafeceb938ea0cafac792b74428af82c30f39f2c4b1055384a83fa3fcb80e3ae97cdcbe61dbf4c1165bdfe55bbd82104d0d8f5fe53a9494373c6322aa547f7c910de6331af0895af410a9837bb4ee066d2e1387030846009f47e428e3e1a0fcd792c2a6107e85ee09a9c3244cbfdc0376599027a99e71d7142b0c92b085ff32f554c1c8f80f2848f98ec4a4d5693c2cef1ede3d48bc6af6cb09d86d1f4f251deb748b1114347a9eb4cd3466bacd9ee72e7dd82cc7dd413c6b25146a763fb7f8b0a43351d971576bf59ca6709544439c74fc08ae41591b255f7e2c6ab1edb88a76ae820ef6349617c8aef866d2e84b646ac2e61302a10093f5f5800ef0155699f7b57b427e449a15ce2ba1f676690a27c5df721fe5b1974abfb4e18d4bf1b818c85f20205c98f8bcab139b7c66df4515ce282c28428056f5f22ec39b815cef83360755f8847be164b359787476a68d6c24efe5d505d7691c852d55cbc4424d3bb39f136648632f75f4ca423ab869388d9bdbfd1fd6e261223c7cbf74106a4eb61a7dbb143f4f96250eae952fc06b0e01b5884a68d52e5d030e5c86fd0a4cda26a663d6a776b5d76bdd9a5067ad97d8b232e62062ecc3db94aa2904818120ae8d9b9604d36773c448870097ef17a756f664e9e58edd731b63ce9f327ea3f490e0072a9a5c2b7970144c104da9b23eb34ccc6b83dddcc7a2ec9edee99075f209268e59d4a80b9fed70fa08742e38c3662df991799fe20a2899fd3d7fecfd25ce346eae66aa26b90b5e903416ce62cd8fb4a55e2534542b450ea89351c844fbe5f13dddb0cc0809055de683deceec59e57785871fcdf7a431b000f7f0a8d2435f8b72edd1ec83a0e1cab747446874d00867c35d08dc338c689875b83c0dbf5c3c2cc89384f5f4719f9631ed8b1a094a1fe53bd9fd3322cde648690f2c82d62d33191af2a93a3cdb4de2c78330295693b5131cb5fa8b5539425a1f33a36c5632255a464568f7546ed96eb8d331e71f0d7990cf016b48992c4e5451c546947a88305d6e72cc561f91286c36657acbd286de0a2083cd23c5525a176120f577658dcdc9d2af0b6360654f8ec4027bc97a29a33e3f759cb55e78ad857cf880f0f31bf7b2f08c36e8bc7be7b5eb4bed2927661f61f47778bff1f1bc78ac0fcc0999dd1f9ae1ff63af49c780e8c79ee1f2b14355da8b9452b6e005f47314b2a2a25faa94aa2ead656fa55e270d993baf9e908fd9c6164fc37f7fd77ea4e62cafba2d2461d4420b1f00e6397ae406ed0745cb2386a7d1f5985713ac6cbc018c2acb48fe71b57e2ed19f1570fb7a80549445d5f666daf2072dabdfac17d6b4e8b3bed1116a724293610779a59b75146df9360cfacbb5631d794eb1cd703bf8ce6007c62d6a63f078184ad07bc6c670d671eb774f17e03dcb40eceb93dc0f28cdbd2a7056dfe284acb0ada2944609c87de7d986b0260edd778fa8e7715b00cd8c6662855c0ea3b8cb4d381f8c34909f8ff9cad861a22da1053f9c35e04ec10df75865261a9f70895d3b0838e5086cf75963620efd441d1579b611b9f9af0f5582f9dd18069936d90f191c8b5026be0a6923a29c0bec98b5126e17b88a320658be8da25bd2e75ce90bbdebb3cd0869ab2a9a1048f9f41cb68462a6b47c9a552ec15e7ccd858c5deb1bb13718bff5f7e5091e87a2aabebccc82b9a01ef79bf3f8a17a16e28dacf31837c8a687685cf239c90484ca200b74e25ceb87db2e8d2de35034af657cd91f9758d01969acf5cdf50131bbb589966edb80811e3d51bf026792067b763e95d266719e76c69331ea15b1f1ed82aba541ead3e3eaa1b562d0fd4ec5e2c6f9b6b272e2deeaaabfbab20c023eae86b2c4ee7a14de647a3b226f90a8a378de7b50a107f545aa75dc7d2db8d3b42dbf56ace8f408ff7b21fc3c2a0a7dcb94d5dfc60112fcbd19f2be2635eff19ab9fa0d06585ff57cfd7fe58d113e5c55dc1e76242b1827167f661c4f02381ef1cbb604c90da2c26cdf5d3e77bc6ac9e79f10ae1ac8027ac84f735703b053cb6dcbb5bc6db23934e95256885ce7bcdc4e3f0af64393e4d9de373438a5b0a39932c2295bdf18dadfdbe487956e95b803c1b4d9607ca9c2bd2991ef41999af08999de4d6eb6dd07d4def6325c415f732ef594a1e10562df1546c5819b7ef4a618decf035d883c116c221f70f643beb20a4cc7fa16db8a280101da2ba5da6ae2cd55c658a60e6e5dde1d608fad988aee3ae974896bb1fe04d26105a8f688edfcc744f9c14d3c68b74f05f98ba7db66fab37adc51e7ba69b400fdc83c7a39f5ae4c7d5c49d18e1ab2f4fbaaf50df0d4bb6f885701740f7959101d26de98249525a4ae6f249f9cc9738cdbc0a64a0bbc9699521a0f45b6cc21d2bd08eeba75b394a95d7c483d6cc50bfc317528e1e50ae2b7d0be3ebe22d2ecd48f598e4944d319ce2918738445da8d1e61aa69de4246ea8e9d87fc8237a62329926f0d57273afa2670408bc7f88a8fbbd6b83a25a850e5be2c957a9d6f5cfb44b6b6f0e01b07f35886b9fcaeaacfdf7a9d72d98c47cf015a01dcc9bf05c4a58b73d3ee515156414d4d9817b1cd7ccb88a32f34e16133fca195961888d1184a8d820e34e32e44f84827b642394cb4f2fbfadd51ac9fc9c228ec758fda8b569a4449008b574df0eb69a7b60bd08c042dfa075a3a9fcb40b143de1a01680efb8b9169cfddbed7495ab61ed351bae37a96e8acfdd531973782a65907a71ef78505c418fd57cc8f771595d60e7548618cb0a6bcb51af2fe2c31354de74c0518df7c616f521447cab801825f1fce8a5f59b25dfe1617d761be320738187398a0d512ea43451b0d784e3f4c2b0e6125a9230ca4df7e547f960ac0b58dc90d7392322245c384793b1849c86ea36564d65c4827e47973e2c3349a32c3d37b19d619d4496db9fd754e15b5e7f50e999b3ee272240052a1cd396b8953d5e9606faca1fcc128f9937e65f56bf77c776e7e73e9dca8cef4c3073e4b277af4a12cc0ce5bcca6c688bc0dc4275477fd6633d4ed02f6df0bb8a04177db1f12e03da61530aabd675ce1b7ab880ea1c157fa4161178588c3ac5ea7238ec8c9a54715566c2e82fc51770fc8601f5073b633fae2e8d24b1aaca96d3ab6fee72aa2cf83b735e6dc3587b2ab3b4ff02cb4bedaa8ff252a739d4008c54f14d928f2e2a90a30096b6856fb0ff2f3aa70b2bf51f97507318da8ac9d719ea7c2db250b5e88004d07d6958f3be949f1cce2712bcfb07190aed2d118a56b827dd5aee61508de4d3363ab502130727cd3142b5ff836959bb3bee6b33b1a6be574be11bdb17cf07e5b64c31661f4ff5c8dffa3b9536b5dd783fb50471fd73f6a58f52f727e182774e1ba4d52a2ce4aa417c0eaa19eb1713f0f671ae7dae58496a35950fea7739482b6fc1ef548f92964f1b6696aa701b3a2f5177ea470e7cda6169cac8461519de519467259be234096df1aada5ad38ae140eb013594d8f40ae05bed34d7094900122956025d3833dea5425155de64a986a559291f24babcbd6dc0f2a501adcc878f77915c40cdd69ff9fabf8e8d4d7751d0c28368f7338e23f1cffcd8a669e5aa3ac79f6bfb054745ba32c8c8d64f357a6a145f37b7b984a57a3c1f7e99842012fefdafc542a322603e2b705676debd74207389e483e33c80a1c7d57a36ba7e6102ce6d7d5f8dcca2a286311f53b8d52b858bc4982879b7844db6fc91a2cb72b2cf05ce0f1edab8a5506c968a5b85a65d099c50c9bbdd50759e923c97df60daf244a8d4a77589aaaf25b0bb908c71d486db6b78027d4012953c17d88ebca87995842336aede85daa2559b4e0304a19d5ffde5e09dcaa3942a2bcdbc6031aa17b22d21cc293e218463b3b199518e4214f6e1b81cede76ce98329d55d5f33e1c68fa204a047ea9d7192adea3c262d49e627ae7415f310883b572f77299506825edeaa4807604ae67a0658221f361d94ea98a30dba99becaef73089fe92ae000735d63b95540957bfc84fc217d0d3f04cc098ff3f4e3cd7f863353df12a393a9bb58bcb9252ebc9fd77cf05b69e598b7b8d2b8d1786ae94b19505db67f6f28b8ab8de53ce6038d0a6967e06121f855f6ce0ffb5fd59fc708bb5e7d55831c9ee92fed83aa5395a6384bd42becdb30432009162571fed97eb53e201e7567d4412a959138088e2f5fc58e05f8e6de99f48d3f4da38b75d368e00a7ffbba0047faa7c8cf90cca0fbadd9c6e70f6a296e1dd836e1b7607adc16b19c9cd7115cedc1ad68f9775f4615bcf948c9a86aa24e4185c17f98824d601af19ae3c5fa1294c9096a057379d4c8173fe6a72991a0ee8e915e7b37897c2524642cab5a161bbb6c1453086132cea1e610c93fb24ec4facf9a5fd1e4fe992165d6402987d3557cbef39172caee7ce56519a402d0954e876079ef023364dc0e2825662868d30a459fde99f72c80eef4ee2788fde741295927a11378420c48bc5126e928a9adf2e096359f429833b7e8221b37272762e1743e934f90222d9ffbf775f5afdc34f0560c4cfc389b9cde350604d473b712c61310b25c2681959ee60900997a294290e82b7726faaf8af7601cca4a34d10776a93c0fe36cea5311735a2275e82ba6bb7aa98ac8182cc9294d74298511ed7f8a912cb0b5bea961de2cedf5e458c36c80e9831b5eb5d8cf3601d3e68604d1948762bf39c3476e2a228aa714839da144ea2a8b9d89212a909fee3a68bc3753fb86c08790fc4708d0d0b30be48682b70e988dc34d22af3fbfa12e1c5f44704b4698233f34689b9de29547e38e7da444eee03022c9a7a4fcb569ff7571263fb7bc28f698b82b716cad6f0e9856eab4080217cc792e670a46fef9246e5f239935d17168faf3a2676a4ac3dad6ab61cd2e844a7d2a8ebf6e277d5767cc3187848a1e19fdf3c28615886316329bc63c598ed94d03cc287c052c3d290199e3a154947f64b1c92c2ccf251e35da2cc25ccfe52d12af4fb529614332e3505fd1aa3505ffc23b1ba7fcf0f3231cc4691288fb5d1485f28c940a09b9564316a6a8814cb7a9cd851b17763121e331817a9cbf88e9555ad57384fe18a493bf1fcf5aeafe79a685dc40c2c05df97be74d20b7702a1d0db4ba4f06d254d1c7bd6cce40b7858937bd61190cdf93fe79cb678ea3de39847d3a4a157a2fffc0ccb319011768263f25d3a0d2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
