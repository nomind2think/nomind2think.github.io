<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96463df6713fb384890ddf80d6cc8738e4110b298b369af7e0e99dfa2c3e7021223e5ae3e28a10db7adfb2898f7b8005a3c40a8abf881358bdc724dc5bf7f329a9d5120b9149bc82e49be5d9ee965dd9fe7ea2a06b2a48f6744d0db9cb2b31389f35a5078031fa9139a96653efb884a27fe61d790e2455f5d595aff7a0a86681ee28a8129f61ac1bd14598c23fc086e0fda055ce1f4e1b0fdeaf6396b6a1e281705552e186402d610d8b4f76d6613a1ad45f26aa7773c3d9f601fd09fcfe39ab9ffd16a995d9609cf473149105c8a28189379972af35f7a0777e0683501f80506acb48a9477af654cf15d8449f423d5357213816448e7969aadc11947e7b737be0a12d70c9a0f80d2e7b8670dca147ca98f842741e2e7d6d734422d392405862f35903b09316650569102bb3c1d5b9fd2b0acb9eb909ac9ad259f78ae5c6d53b218973a6561119b91f2e407e3d31803ad6012482e25e89844f3fea62ddb1e7ab0111fbc1342acb63d61cb9287998be8b76d280c56c1c1440474a946d31c2814788a2b425acd5c35c00b45b42225d3187765206bc7ddfda7c6cbeb10352f8478ced225d6bcb1f3503bab402d0606ffbf1dbbd8f30fdf1386bbceaa97e5912aaa4fafb242db5a2c0af8ad404c1e05e2c3e00fefddd160b5451270ac82f541b936c7c2db84b69d873a259a4479121e02f3aac6dbc4fd6400c3dd27afc4858af800919c0fcf067ea5a4da500fc90e11ef3733e4b22859409a6120d64ed22130ad914be1ace1384c11d1e465f9a8e4c98e99f8081cec3a974beaafd7368991cc17b5c1ea3f47e19d9b422a07c5b016feed8b3c3d597a5aeac7d22eae96a085c7f9b0022127c45b0646fa4f0798544a88231772fbd0f99972d1923740732f6faf04f345c4406f0abb0a7fe0ce3bc06016a682c01c82d6c3ef4039269cb278d35a0104709032e3b225dac08e0c23ff0680f5defcfeb21f1d52565d701778a2ec8e4b07ce24f7ec5fd2899d6a17f5cd1d8ff2330082fea36179a1f14f5ed2ac20514aad56e252525d5a960fcf9a2d0b667feebfa2a4837c71c40f8b699b5b0ef7ed95986382eb4eb6c14f1fd13fecfd084b5bf9562b03abe9cc5656f9e4b0b5f6c12f6dbb2da6333c29c20abc5b0874d163133cdcccd1847c472050a4584f98395941e6b4290a817750e7c612a208af27ae07bf1d50a7a431d83e362e065bb27b9dc130eebc8ffeb651cadf62f3e0bf5c2351f9752aaca62bdddd36db463066b7d2a01d9646e5d25857be8f7dfaa295b1361f260ffcaf7584614002718afed7363e2c783e90631a1f403932fc85fb20253c09fc249c9512507c961dc37777bdd40033dbfb74442d8fda8c5c75e791d7b19198d95f3b2b676e3e48c18cb61b88c4905da2ac60ca48ba6d0f1c45ecd90ba07990c9722844f74dda4248e932df16c7dca6bced0f82e2676e4899dd8b55b05a95c97611dec38acf45da3e586d86996c4f8488727b25ef41c95d671fe8a9814e37cd095a8115738812957f79824749e16b6d65e04f82ed8b183915f16516b645c92a23307f4091cf60fa125cc4108d8a6a9f38b1d2be0432670ba0c2a28a8e2ad8ca06421c8b47ae0fc7ff99e29ad745981f40a1eb33aeca00e78f2b4e1751eeaed0d30961e4971b0137968ff17095ed0b972366c22e6894954245261b877c953fe4773db75b3c90f85d9bb72c88d9899d1030b243e79a1d625226d8755b1fa7fb7a8a4cdc66e8a83d0654044db2fa32bbfca220cfcdbe949af0c3faefd85c7351635d6ac18f26575c04db4831338671e7f68f3a6d9e37d5573a5af4322b52ae1e37f06b4f2362964388a0cb363abac28c4c232e388a8f8ba8d5dc720cdbd84a8f6557b44efd60af84ba6efba8a79024568b1adfec852fdaa03938946089cccd23c7d04195370bbfd710a0ce217b90ee76df2cfeeed4917a4a3eccaa692c35313f60cd510d787f3e6fa6b70e175d635ccbb948526c22f47344fbdbade01a0d68c661b67605b65c7dfdf629d39151cf9d8cda30ab365acbf67fa76f32b16949be09d54859022e5766dea5677105f6d7950577a54da3b82e1a41410d979b20295eb2ed8821f5f6f7647ec511515e2ef336665160ce7cdfef256d21b08942b264f9210251241ba6fcee898b6800297a8fadec991dedbbd6aea129d45ba2c655d40cb18fab82df82bf8c8c2410b5634f60c3b23a9ba66b3fed8a8a88717ff3865a5bb05fe49384ebbad6da62b0da11f9ed67504ebc48a0b5f8234bdadee5a1058b06659d05d704de824941b426c9c59ad2cc984eb3dbb7eddebb3a307fb29780773d5ab9915746be90fcfc161bc4923abbe33e79a667fa04eeeedcc19ad2a9878b86071116782738da00207e66f89fc37873469b80bfa9eb0535abec44025104753c2abb376684be25465d2518d20709302875f731422677f81a55caa4844fc7fabc30201f104d3aa46e39dadad025c93675b98dcf03cd870cc2e17fcc1ca2333918e40d8f3a12b82753338bb729b5bafd3baa5b399349c2047589dc53bbf985e232e68e48522cda869c6df11dfb611409e04a22d073e88f34259d46f23c4a369571f55025c3bf6d1c0452c395f39173f905e9c10a263117293bbc72023e8644472630d626e39df3dc4f90a4d07ea004991c9b01e11a61dbe03693d83988b943ba2f52ba12341b6a769ddeb7138190a40c9012161b4943de1e001c1bb3727f4a69b9b9b80d44587b10fc192a695edf1354f51058583f52f2f3345a8445701fe42984c367bbbcbfdaa1b4d5a40def55f8774007f57388725b21560909cbac443131f8b222da79cdccd40e9f9e6ceae51dc5f39573d17a73c2e9fe135432f2e3f4badaa82967f4ac57f20f93a7adef3eafe086e6370e1d19b521fb04eb281dd94f84c00f6b6b6bda73b7f77e2b3382b93e59e910b7ee4e3a7ea289a0e5055f69e99ea468f819a60134e991fa059af7598b051dd933ef9a23ad319662f4e23390650d2379243738c220cfae7176d604f93c6ef842443ba4e8dd27476e01a03309d9c9f36e36622d624e1563bad8b716bdeafa469e43d45cede2698ae3c14158d0900157dfc66596d0fb2c70c7676bfa1c212ebaab1c65c1b817c03e0243464fd29366d05385132b6af9600c3638db4e1dd83bea536ab3dd2dca0744d3a3a3accf9464dae13c416ab2e45744db0881c69d0d57a888a2458e7ebe0701b6c09ae4149d9f77a588f3ce7d90711a7c45984e87280f8634e59db98b8a26e33aaa33094be0805e16a29737b69fb1ef64aa795d9623ff0786935ebe939d6320d2e0c5e54c2f471902fe826d801264c01a827f134fb55a1a22373660ee8c1a926c70d060ef29a7b777b1de4d7bfacf9ed45c48bbaf996da745d77b5716b28f17489c4dd40f5c1e89f8f28661597a7626b1c2ce8581c3f7a47f1108e899e228b4a9198bf7f5fce019e0cabca440748eb854b03abdfc5d2f49286b985e061ba4d8183190375d7a3a6880acb1c5637bbbc4ae62eda1783f04e53b09964127dbce3039bcd55916a59514b4ad8f940b329e700296fa230213cfda8c61a71f0f986c79ae8ce727f1bca3b98bf49f517f73302216cd84080add109bcb2411e09c1f8633495b0886f8fc7740705a0bbda2cb2feb6184c4cda9413d1453b9cc7684fc07ac602b0d44f7da295b6a5777f3fe5251f4114bda9413e2dbb2492313a0a22974d17ce81558b9a47254c016bb0642957778b61284ea9577d5768b4171713a3640cb158e6e48e3c664a9b21ba3844c36bb2b06f667b6ededbd05e71ff4a468001021b4af588fedb8e9b26122edb521cb36b4b445d7dba74d602fb70d0bbb5737e282f266ba3090c15b757bcc4a6ffad43002ac06c0bb1a2ddc067dc6f643ebf8fa1e2922d9d41e4b1959954225f54ff522c49b78290a205cf7cabb4e70b165e48272ea7990a388c5a0a8eae09323310dbd01c81d9001cf466356ed62f04347f34867565cb8e6eb0154e52befb4282c5c60caa3a2d3fcf0748c0c2c1be942ca53d7960e36f37e88428ff1847505969b3ee14b4dfc7a55ed061c8d0c793a583c9e2f20e59c72bf9b31f0fbf54add4217b42614223f2043f9df90a61b9a07f0166c5d29ea7b2eed1be0c1ad097a7a13b8faed2d0d1fc891ca454bc65bc68ee9800d0ae94be2df33334fe592049723e219a420c4e0faf34d747199b11c49b4b8e8f3683a1fd31612a300e597d4ef4822365b3efa599dfab9b94775a84b6649636d8ee71a8d42ac7cb21566d9b628e38de11ed82e7a868359a81efd127c4e9bd5d5680a894e344b8dd3c7bd873d6d3fb33d4852d76e464dd17125ac9fe587abd96f747ad4a9f4a9b19bd31ec09b93107a00c226b2d6a612fa1033492de10a7f00b9ba17287eeacfce4235c905c5f2f0d437601e4ca1893019e12b3a002fe384473fcf418a7603ae586a6a7da9520179943f699ccbcd5b19d9123042af76eebdf830caffcdc7471df229c940b0c5af9e0386b9170fef9a17cd9c4589a6561f14f4d240348b9871b8a971851502c639dd41e7de894b22bcf920ec951f04592b97d4229d1b869a5df32a1bf0aa8905d4a6ae6ce3f67a72971864b60932938adb1be7d00d026d3ea2a087f8fe1d3782ef85d5f0b6173009c0a25ee01e24b675cf620e54b19c88965579bad4fb15f5e2576aaacb44808452d32b6dd9b37bfaacfa7ca84dc87341091f3052e69f07b77391e9f8790344449b7677167bab598d3910af98b23ca0032ccb1c5a57fbd9a498e2d8ee8c6b493e0481188bc616657703465023ca4d88aee2fec02148190356b6067be1064ffdafe745646932a14db832159ccb1174455170f8e8d0c21b991349e00d985844b8fa943f8dbbec9be26251107d5f2c75265b58b84da89f6dc7c28630a62cb1c9eb0aa84f6dde0f650c5c70fa8d78428d9454449678e9d6b9d8d3c75f773c6f0482f43222b83ef54a89e971fb1e76535bbe8432e9eaf5ededcee77170d3e2de3b8201e7146765c7234b7438dc70bb41f05763df7be11c5bfb4b43f552eb6966d7db98a5283b5ca98ea8ff003a46357393bcd8d9783dec7431275094fa8aaf554836b6ad1144be1f3ea58295bf5f3c566a1c168d912786b959585415f3d8e6d9d824ec083ffd40ae8d123a2a74afaaa56ef6f844695124d325db00f778708ec74bf4f7f308b53dc113320c4b2e86fa75c4923e6d70cfbf23b2af1c282f01269d111310e9f6f4899158938d6bcd9f19941753e185fd0ca8817c5697919574e04733cd2170bfdba58128a973f1b21afa51117d643f9ea9b4eabbe42c9220a3ae232f705040c66d9da0a1c01179f9522ad05c56924923362cae9163e734a39f7fe35c306f786bf700e0b48a03cd3469f800d7c41b73b9773f12e6d2c0247afce13e1f49855473c43de05a8fe7515103e9a467dbedc0d87101391eb2145e95f980bea6b6fbc0f05f9890984d8f7d1c921903f80e2ff2b8369af96e7a713ca8c5f4628ccef8e957c8f2a5fbfdd40739d5ce66b264a1d8c41671d5673e425826445781472b9464de6054d83a2f7795385d018cd3a605c454ca09d627fa6b082f44694e981e40442130e4327b0f781712905b9f6b792c989c35144412db0fa75823994e7e0ead43e4623e5cfd3d1f6958bab442a622d35b6671b7ce7bc153db203607c7833cf2ba5e7884ff4b693d38ef1c9519acc5d323a7454f4c64daaea8fd7cca44b777cbd0c022562f5987b4ff456b6c66dfae3096164249872a92f620d48c29be1d109fed512ee7ae575ca4f712585b214fd69df93ffb8156b84fc856bb41b0cb2380b0ca17040200f0362bf1cd1e5619dc0f946160d2068dfcc9a33e000809873bbf765ebd603114a88db67b6b765ac5d31d6207ad85e0f704a40ab61e0c2721d692b8432938b5c126f29976bdbb8c8eb20cc319f49f5e8d3eab7120601575956848c8f18a9b2c55d93eec5e8f60ebd5013b3118193da5dd1ad75fe4613d68a5dd22470efeb73b0679d0f1591370d1d56e3d6f5c86ab5ce3e1f28b2fa93e7418c1bf59664b4d69bcdcf605a8561b22f0a1bed6c6b887019798d028149a6ecc26d1e4cdfd0c677c1a02175506a991d1192c5f993d97b32d9d2a622b9f02616c45c1e6780bb2534c2e9a455b313ce6e3162dfbf23830412384390af897127665a030c9b97afb11451f6aeae656ec75efcc85f8df74a9c0e2909fbf2f419125a8651f0f804d501e6747eb7278613e3a461721d86494cedc6386d04e67f7b55b4ff448df0ff23b096358794e06dbd63e1b79f150dd523124d804663fe017e0d53f0161f4b08482c65937c620ac93afa1fc90c089de9dbe04ca4353f341a4480779821ae9b0f90ec67f0448886d76faf9517e7cb24d0cf3a8bde44fb090ce952b087aec24f892df4fe204fdd6602891338e5f4896f520623c8284a6cc8c4424318aee49a584aa0aaf85eb36166371a1a76b31622ed688ceab42b6d2a2a3436613a98eeb51474b2d0a4aa9c9ec30f3894aaa645e11ff4ee7455837b4211bfa9596af248fcece5e7e54f77e29f0b1910035eeeda3dec8432dd8d0b8fc2ec12b9292c275c79eab76b76647271e1ee36bcfe8a5ca0767e388ee259aac6660c4f49595b7854268335a4d306314dfec6e0d8ec09fa9b0d22300389595c56ccf15078f5f96d4ef18dd5f026ca268eb81b7b76c143274becc7985fb26a4940af795076937b2b2d6a1899fbadfcb9bfc62d83b7e571b7312d321a639cc2031094947dd947b7f1b316682c54e82b116c804423d6434308dd73179f91bb272f347fec35d68e1b176c0f51457741b45c0bee8b149467e2bd3b1fd631834f83a9192294efff010e605868b9b3c14c3282e7479475d6ed30bd53a0ec14cfefbed0839dcbcdfcd348a0416a20f7ad22b110029b1c92dc42ec62710c4b3b0fdd01a8b28ec09bfe6ab5aa8334381280cbfd8b4bb6bf5925a4bf266b54181c6e44b3ee3ed82e63e161a3090637bb2d502aed62eaa5364d5d46b4b2089a9cfa344edb470eae75a7f37953629bab11b1a83efbc1b9ca8b92df24d1e2c51a1f1ac563591fc740fcb3f9b3d3d7c298688dab367fb1a0a9402734800344ce0aec8c2abf6fc5e9c7643545b45f100a67f5b4846e205d36d7676d3b1683c973ae90826ff25db455010480b53345b8aeff4dc03a9bf15e7c0b6af275c5edc8c722c26e9d7eb69ef705ecc0eca36f69f7f342c0a71420b19c5c003f8a4bfe46ec026ebbf4cbf911174789d045b0dacab0b6a6187a86f8940273a50ee417a7e188af6c946a05d073753278288d3707c41e4ea0c161af2e619b5e6013ea4c6950201018b1ced055c532801a5f684355d3371eab41b0839eb1ffb922ebbee3473160e9f89f80ba2bb76a1a633df5824e424406d47648f8bba608e7fe1086b13f73bef65739975cd8d7270046f5f189f0b60f64616574e488274c9e3622a551de753ab01707ca27ed03c689d781a04c11c4727c6f67a562f9d96d4102b4c991743e60b96b11dbb6242226fe17b06ded624677be90006ab76e94edc19fb93c42d2e5188c50d5e01c1840df5d00da6e673eb9842db7ab0073923941346e854d6baaa67be7785f48b63b707883890cf841b77a9437b9cc10f0be3a866c020ecb3bef86a9a448dc9441ec175f8924c1fe5e8c8510c3ba716588539f73de44122750c1fdb12b356a3085df7a8428918202ed46d8380e4716692702e26fff1f8a4d574c373cc369ae29f22baad646281a699f327b5f0de4092983302977cf5e418bb5557a22449300798f57fdc91b484e4060078b2d818784cb1f96035450586e6ee096155089f413d032f3ec32c80561cc2b69998a0ea10ae59c5759ccdc9b81dd828b0424b34e8e334e9316216611e5f478b67d91ca953826c27dd446ddbf0bd237c8b9a05204233f6efdf9d0ae36ee29bca15e17042f65d707af8fbb02dadf97de0a4e9551c295e4d6b3190d3d6186b511a799aa36c53b64811aa72009ddfe8a3efeb2dc781b2e773aca5fd2e59c7bde1ecbe3554ab87eb48386d8dd9a2d9e9d334da73fd9be9edbc9bec24f5bdc270eebaa522d5c8c2e69eb865a6558de30edeb7f803d615bc71baec0d8ec93e52a6fe65fb27c871e33dadffb8c8d82f3b04ff79ca9a7aaf0bb5697d1c72b89c6c50a4f06831efd3cae258d2ff26a390028c9fa1cb5de1954d89e9c46f6334e716b519da7b212d2b5d1427ff812050ce045b404f93ef8cc1f9420f1a3860d5382e36a15154a0552eb5991f6400b6d9b5d530f506d5d37593dd8f9a7a814213a978199e9bdb2fec791d6ddc42426cb2c9a20633f5f185ff34eda4066fa4ccfc4267b62018698029f8e6c284cd9089fcd7e8c5e86f46f795ca2c8c47ba2b51af1e4ee5b9a249c22666702f8f91928fbf403aa173270f8b96665846df7feb3a6cf434ebe4fa560b363dba47e2f1c07eec402f0b0057d5eef6a86d82d45fdbf4e251e1c0d4584f06bbdf0dce71c01fea3074c5ef8a1c5166c4654d1f753cb7117c193b91697a35709535b64dc6dfe427d83eb55a7133025ba18e85326a93b1c8dc1c4928b6d9e6c74be532786b6f2dc80b5049c80e31b6c867a2d85d8a3e039ac4ea463e0170867027a92736fd07f80bdaa08f3517c2b0411ac34d3418173e275cd2e168d4a8a2fe2ff598e65103c02a84a8eb44b05862355eb99401121256912e060877b707ab1c87bf8ca56b7d3caffcbb4e63c12a843fc0116d113b1f39e299de89f115f88a8a19e22a6da51ae4a4a03552cf8d4880eecb0406437e81c9db5269a08b8f0f85ac4cc259e5faf550f61dbe809330583e41ec925438574dbfd159a4dc3cda4984aaa08c02d81fa370818b4a42af8677694a18dc3cc88af3dcacac7268bc15c7338b0065b903d59cc23397b5bad8d358f63375428c6742729883f3dd05e390d2590e9eb86e2e8753a06f3a721ae268b075c452f434a278f013e030dae6e6520adc96c19997321e02095f227df47cfd5669c9339b7e7773d584d6112e7ac0b2f4735dda58577631830246556e3f39b3dc11f39ff813f3cfc98e715734ff6c69776bdd16abe835129cd2d592b31daa97db0ce144da8d9021ace67f69feffed6da22fe197da2853b9ad919ac5872b404e1e9ac59c338cb5ef41735e2bee8f023df6cac34c5adf89cedce4a1b4da34df96c49b442963db138ab1dfc9ae60f8842d0fe9d487a170c901cc8b84bd01ff7faf7625c6a1e26e49755b87b05cd40fe17a59279e7382dee8246555623bac9ebbfb609e6dda539873a15d67a57ea6c0dcaea0f3a1675be9374f233d4f9f57600dbb1c8e6ae3a09b87d404e36498ce483da8e568c140e9c54f19002b4625166896647e74116a85ce0d87b4059d2cf13432abbbddf917d49b56ae08fb1af85979259e060c7dcf0a2ff0cca6b1d460037bec214e2f7d689261e99fcf65b2b52f659a894e71900113d23fc10920a505141a6c1be5476978a317d0f4a6fbfcb7e90fd68616414737dc5dd9ec4312a915b981489d4320a0edf05e23e175a67f573c7311c431985bb17385c2360c28ba0b360e553d73222ade7ee991dd78e96310ad496708c52db32198957d348ee7e33ec8bea1355d63067fb9aa5d271811c6cd271b5e58e191901dbad8bc0e79bf25d11de6adaf4f77a754e9dd15570d1cf9ba806ef5b9738fe2645433d7bc949151b3a15b741f896106d664d31f8afad9b624f84a5c9fa688cbbe528a6fad615ee78c19024abe7f88499e4045511ada7403d4b9c6fc58fdf0e682a21bd6c06d0fc60aa83999d2cf1fe374eb3db18bb07e7261bd5332eb6fed58f0129f55ed031c00ed099ffcf50a7cf14fee03a492b8947c10f38aa0cc28b7766096e770e71925306b44a1b978a28ddc65ec94ee5d73d8345dd8511530aedd312b3ca3780df915777cffdb48e6745ec14b6c6d680644bce9b25f96b01f6bf12cad81c86a16cd4e16766e481bb694304df53919927f8274766c1467899a497dbb55489da842dda1731a51e5d0938fde13c8f761aeea854ce08fd0943415ed7d4482eccd9478a083400e700308bcd7e51348e5ff287b0db33226f207586639cfbcc98997b7e3c2454576261c42b0e7c5600f6594ed37325b29194e988a99971560cc4e4b6cc8fc9d9d49d0aa14d2f7562a68edafbba7e335fefa4b773c8a696c7f1e1b639b7333d3071247cd6f0fee4aa3624c335bff0092916f555520d46c5b338df3d85e8117e2d235b9ef066919890188267202948fb768b4ab215bb694f6813655a1177e8be7c6d452506d0e2d33b2b4de22f1cdc32a30949392c8b9679","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
