<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c59bb9ee03737a453715f6efd36fc8fca4057cfb8a6d8ff96d75ad377b3e5372e8072cd111f79f66df8b900a8293ba6c5637671222339db6e90503625f395164e38543251a3a15be42f2da6e6d212fd7fdbced02b3871243288f5fc5e420d5cd971cbbadf85a6d20e2f15a9a39bbd5304326d59123f99b46d3dc2630710ee59d919eaf0dedfd48614d4f9dfc8e53ab435358572a01c1818462d90a43bb32597005d3b49ab8b69a4fbab5a2d788cd2526e16753ab4861bb900f223f06f0496de9dd9939907835ea6604c2cc1954d3079870f9addedbf07a9d7eac02ba22fd81dec62274e43355a446b3af2b2bf9e1b9c8529f3c64028a85a9e4b9a41ebacbf326b6ffebc32cc49c1e656e1e656c7239d7239927184fa25d3e168df62c85df88c5e363e73fb3d123faf569300a44de461032a6855d48428dc91476e9808c3e5bf2c1907038b6ffe0bca840cb07357d318f71c12bf765984c1c83db7ee48828123a49f08e15be70decd4a3c2033f00aee8f64e7ba965ed9055abc2dd396e1976bc73f5e1a0f5b5f42f47ffd2265fda7b3c05c752a41c45fb0f3ab76ad390fabc083ba46ae7712dfa317bda88fa19ad253d85dd6aac2ef2d8df2c9ce023e0360eef189d2e323a2e35f2153e244194431bcffbf69117d20348bbb23d1fb11e18ec4198ba9723e7d5ea7f51c9ea2235a96a803e35cc24e74ab3b3b200fa7d799c69ff86b3d45af86bfea6b8911161d0191415dce91538270a889e6e88247784464f00e05f07f20be8d36f1bb3785757308cc4943ae52a1f601a31272919c466ff6b0bd63218249413bd5f254549f91dfe29fb48ef88b821d58a58a5e71d18fe1694411069246530c90bcaf62140989407893b23ab37a7c69e27850c8a470e69dfb4cc7ff64a8c64eea7e0e3335700bcfd81d32b180c11a77165849cd8c1b116f687f84fa2ec3c375e9482c13d0c2f589cf32c2ac14b1d04f286486488864a39bc51983279a627627819ebaf665dd6c2c966e78e5082b9ddf35925ebfbb984e661ec371a2934edcf2233b250ac4e1321df8ed9359073fc418c0f97dea5940e2f3ec265bda74c9a824fe4c9222028cbc7fad0cce7e9bd5de7bab5f7bb9ba0a4fbf08a4272346e373b7a6cb253340bf4d18f018afe81be0b3487c2458da6fd90909b94fcc8683775627cdf0a5028ac70f18c9421b7b1f011888a40ada393ca86701c3469fe87f890107edb3b7088afdd1eb9d52a53fe6078f798aa8b93828b05ac6eceb21a0a2328a343d273e5e02008a19f15657e0749f2cffad44796f07ed198fcfbf6a49616a62c60258bd192105bab8665fe480473b332917ec216015c7f56aa7fd833a2db255b820a00a9c44a62788f16d499c9e667f3fdca0b88e53dbf3c51c65c87f2060ef8259ae4bbda3595011b0c81218bb2ac498abe85e4c5d164876042f63ec3d888d69d2ddcb976f304e12b050463acdb058375f92541989383bff08156b226a3d285a3bdf17a331cd5aff3735c0b178393a7fc1887ebf8bc50b5c8ae9f9d57f254bbbd8a0aff12ef88daf4d81fc2b81a9eaf19388feffe9ed52d2efdcf1e53eab6c2dc0ef91f528b34c55f22ff8c73cdbe81e24a7301b0d96c9ea4c67f1c6a03e63dbee3f27673b8af9cd785f9c17cf8826aa5a2ab2681caed24284c63fbbbb764d6a1082663ab016276249764868a1eb2861a88e77dc348542d65dbbe97a614450164dcde09a8352b0022557898a53ae02ebeb04b5c4f002652ae7c8ad23f24201e1766b89c435a21ba5bbf8d25958189f129243ccf0d5b492d3853ea0cdae3230ce872a7320bda2911a1649c64c786ab45b19af8d350875414c09ae0d7ed59540c215e90c0ceeca50909a0792545939fb468f752fd279d11d20117c6cb971d5cceebd66a70e12e1a39c98db40ef9a39706afac4f6f4eb8098f06d6a773fb1f8223e4ab49d9c98d8baf6379afa9ec0916c5f3a82d20718a5fb24988d48d802963ce33a8c58fde2ff1e619f6f998688fd163232932f376a18868f9f544577c7d4795ce13ce153d414f20174713b45643e5d7237e7ec5ff520d3d6ffb876a093d0170013b84b22a42925cba7f174a5a7617603eaa075bba12e9d9482927e5900e6db66ebc0b314c55f9d0187bd588d8f2dcf4146638d70c3273b4e65d60c35ac7fe7067979b8bff21e0ce6cf5d4b737c57cf670a26352cb7b817fffe8a44356992e32bc7cec272de90971ef95cf356f1ccf686027268d8c5e5727abd997c865bcdd44e6fc14b53d98c9fe901ab27a1f1be384c0149935f8e90b37b6184f61dedbc9cde15102324659233f1f4a5c6e92ca2114058e1374dcd06965023bd5d9cf3754b13f1cdcb03c50e230b958bd71891d71bfd71d0e9a1ab8015cc636e4f5a19bc292c292a3c1e9ad32fad666ddf8298349a72113b4fd00fc64aaa35fa1973783101ea724a594b295f184c8bc8734a43683332c9495f53040e795cab1646d033c5415364cd69f50f956e4f480eeefb15db1e99bc25305006a4cab835bed1810835c454ea3defb9075fcdd955c8d6c48ba206a3b9d419931446b90102167f4b49dfa761adb903a4b5c6da4149c0e43ca637e7aa4b30c7e9859d8e9919041a3e7c322f2cf8545c18451452b7e32a0abd330f356450126e304dd20c8f5af5f726d3735bf8a35430494aa1ae70a2c2f5efacd8ceab661d07633ff8e299495a41289af3a99eefcf09d4cd83d70935b6e737bdf31a60e9598b717d0926f0e738f084c90f3a5790426d5602b71bb2f80b25e6f8138ca3984f24d6fdf6c26e35f1433285a43ec0bb4e6d6960c516152589be3fe92285670567a112f13ad5827adab22227e8ee7a1cc3e1e8ed80f9abdd398f0ede436e2c800f14e566b55da93d4c27d27d087ecc127d79b968392d829ffb747e856e07eaa811be13a27781578b350ff62af2a7322d546990923e032173e58648d004893638299b68790204610d5d1dc6f7fafe41632c8658a65022a52268e66c2ee066171c8da751a8fd148ab627b3fb9106d52c179835cb90b9492cb66af1d24a681a1cc2ebe4fa5714b9a954d507fd7ea7a217a224fae39fc11a935beec08c6192de93bcc21f62307c496afb113aaa9db53e13cf83b3178c27afdfc5f2fe83c113882b632eb8cc65ccadfa4450db6d9fd496b1f85e3e69a7c9151443cdfdfcd402930559f4c467f37ea0f1a90445676780b1a614995d2f9eff027b040f0009132271d20184c2c87d6d2dfeb0b296fee51e2005a0fe994cef08d0ee3fd754c229f14355fb76d954d032a2636ecca22899cbb131c8c970a31736b1e148534d5972f043e19648c846b57ce996599193c6c8b745d20ef2cfc811f5b52d06885ae6d66af3027aa88c4b70bdd5e1a8681ed223d99e7b1908ec35ba5b0d2c452d99be90ea23188c036ca838e417c995ba50f25ed56110a07ba39afdd5952a8a4e9aff5018f14120be5a108c73b9e330efcb667720e04b809bef76754b20cf11f2591a6b314e52bafa5fddbd0dd01e0b04885546b50c58bf245e89c148682628ee9a9a085e2ac57dc2338340760d24a26cb57ed0c24030c5db7d662d47a574c8a2a1b71b773539752ddb6bdcf7ad4a4315154d1c956d8db9c86d74b6623a914510b0e5db9f53538c21c7569265f4278c58067071f49b7a77b84b42f1fe4b3409e23fcc97ea3a7a584f89d516e8a9bfc9e62ecce67a8cb0d07b1e03b1f5e9bff141aee91c66dd694f186b5bbbfa759010b1387fcc34866d9a8ef74019bb5ab69be1819aa1f30243221545dc259ed22f0f69dcb82295f5b40b9ca5461684d9d113938573572133be533f6b45c1a6e391249a2b2d3ad8168b2b1911c2cc1c0f8ae7676f08c15defc7c644915be4d674f27df9c4d11013d49e6d857c66b1a2811c429c5908325b579825e717e4ce0b77f90cf01db66321f5dd6c97f20dba65fadc9b4ee75b66fadac8cc23092d7897e48f0d78150aad5ebdbda2554cd641289e76f4a52d978324445a2a14f5466e2127cb76b12ba56a2dae4cdb43061a37ad3b2108e298b1291bd24f40955afe58342cd51f6f5d06ede30ad455ae7f1d30794bd2d3a56ea370b2c9a99723004f63d100d90803b78140f924070dff8d9ed15410ea5dd092ef03249eee6370c9743d95aa3a7cda6e37f79dd41fef5a3a27a674380ed0f355ddcf20809cb4fb7dfb2214b94a0df5720d22a9f0f527b48c426ced239757af3fd60c60a364a676e4fa734542c0ddf9de4c5a9dbac1bc1ea3ada92c59aae55964e8e350a9a2b762a1c42a239378873ed144532a5bc5f6efcc72bcf33a8275b7ff5c286f1d69293fffdba800c8bf3ad893620aebe97d6a09c7e4471ace4b8fccef1b37dea43ae110845be4656602fc994ed9f9d630e80019674394b7fc57efb7a7c2971d9843e03916616c164d7b39bfc598ed192a65e161412e0860476d398faa018553c746edde2f0ce805f3279827cbfe69113cd6bfc26522baeeeb4496ff71fa08110143db7116456c8c04edba9221777ea3601d823faf4ff877579c236395235ec7e149c197319c3844e3d8d80deaf8b2bd93868629624e3062821fd0881a216a3f33ddf2123daf84edee68971d9f4668c5c53b7459f8c2122838a3d290eabf906caf2a20b919d9027730a48df903b81728ce8956110f262f00c5f0e6e4d166a211266fe87228492918cb25a5438d0e0009431153abcd2e4c8a62bc1f090c52eb155b3dda6a799e8d512b43d980a354e41136d2994a1b6a470094999b8889b6be639ba410472e3f8d63e84ea81ebe96318b615eaf00052ae792aa3d84f4035282aeede9ecdc6128465a4e2a5d37aca8b85ccb529d32ceb1de09dfbd3b0bdc736f72ad7a2af9330ee5ea62f8693b251b46693767172546825c3ad017bc8a3a9c771efb108cb7eb6648ebf2a5815ee6cb77cf628e89a19aac0d750292a91fe3ffd14eaebf2e7a65f91ffe1caef17dee07b2291cfa21e906a47744597d0fc96485d1c74fc03c95391e2f4166d3dc49bc2c2a0eb7825f2720c6aec20613bc75c28310f4fe3c71d2a2b6bc686cbfd0052a6a6efb864c1cc29b9ae1435238de689a259b12666dcfa0a85e5f682856e5de87f0d5073d8447976385c4f77606f79d76fef1b92a830349e09c2e7365268edd5e31e7911fb24f21735757854cf8e52923b5247ed3ce60bc9114c0a737e7111735b74137756e2d900c2c813e36f674ae3e2455943023e0fcb917c3b2ffff91ed6622c295f49747c7ab6343af647123070812e98703e137ccda08dc4147ec112843fca4ebd2c51513ce6fb065efb73a918124756095fa1ba0462eeeffcfbfe5888a1ffb279fa7b789a3e33e1aeb83d90856d5091b09b02ea42c6522bcde9ae76709fd67837cdf7dea1ce3eb11ef70fef3bb8eaca74b5a86b4b1f8c2ff6dfb46605c739796bfeff41e03653f667605cba77e5a4db21958e82aa7d099f0af18f05247c030b73dc6198c1f8d1f2b64e9d2b572577cefbc1c7c147abdf056b36e4a3465b6c2179ece5d95031c78102c0f8dfe1c67a5e8095db2605b45b0d4546176d125ce1e5fea716805f5463bb6170783cede7595a232e9ce2fb37c3107f1a39a1efb03eeb2855ef5624085702404d059aa1fca4d2dc25077db28303271692492b29445e4cf7083b398fa4bfeeb919ddc35ef2d6cbf73ebd36eb927cba14038da1f9f80963807fda54b2f6d71dedb6e951a09356a617d0f12fa93cceb34a153c85c8b3dde3afd23ad7bc3098f10d32de5fce7d3365ded7b448fe64e8a4598237f13789af8ec718f600585ee97f6777d1f4569c19621a9599302252477beb1cef9cb5d6a641af1872df60e6d45b8bc831554572c285abaac36ea8bf6215eed276b955a634295752cf40dd7798edffd6237065106cb4e025d2c576539dd6ca3f7046bccad15cd40eabfeb8127d43f98fdfd1fcc2969d6dcba6e42c6586b146bc5c8d6a8925c9b4a3443008aac31fd9c756ad7450378639e1f9c25a3dd455ebe4444e64b799dd590d5ef2518399224d210312dcd17f2230f0f447c69772edc1175828e9bf142c41abeeec1a2cda8e271cdf8076003be8eee372ee6b3c672a43f8899c944a17a5bdc285403f9346e6fbb496a2088b7cd353a89e9af6fb3c7be9ab68fe62a14630a72252910997ac23497e7436aef9636ba3f986d8b911cc79f525dc6f48401c9378dcd691ec5c5bc9a820918878aa99f59431d094ea1a1dbd7dba9fd73f72a30e4c6dcd689bd2d0676d65ae415b767badb618c64b12f58bc7bc57be173b4d62b89d295a6fbe97ebb7d20dc30e5bb4d322bff016fc8f3c4404603dc3de9b8c1407d7bc4fd059ae31c3593fc54da5f8bd262da2311653925b7ca063915627895191958cbcc3ecaa65ac2eb2f0e29e748cc5263038e647ae54c60717d571e4bd1844896124e3307013ad0bfb5750c4eb297de928c0c7ef9490ac4831ef5955e72e8b41931215515881f98a1be895b6f61f34a7ea6df77eabfac83aa0dd101f8cb470ee75389ee7c321e0574a48cd086573004a6a138fd5e73d114c74f78806790d50e2ae0105190467efc3eaace3f34ac9ee4dc256e50cf522d667d7d9a86bf19c1d9ada6c31f5999bf211209bd07cc3015c8df94b1c0bd6c1ff8fe89e733fcd8a80afb5bc3eeafa99146e7b61eee65f7096246bbd7bf5b57b9574956c8e5c0d2664c8d0e6cffee94666cfeeb25122b72a57e6ae67c4f9702718d94ec3ec8232796f13068937483acef0b7b971c2fe30c4df997943342df38378ceda2251dc1e6bac424dc3b26f4078509df67766cc75a2de49a2bb910189764da256b50a0ca7ececcd6943f93a6c9bf4552f5defed9de60a901e3f6fdad14897ee752010c210b42295be990bb11f5212158bd6c629cae34017133f1551672467246126743284f820df75bb268b087b11195330b733d554e272cc93ac056cc7f8d4132ccaaeec9f7f9d29d5e3bdab438bf37574034617750ea8096573653489d0918a2f374c08a7dd2998a1da591e3d1916d492ddd45d161a5b2b6a39afa6bcdb91db591fde20c456947ce9d7a28a595656edd2a5ee0010cec90f2e7e14fd86bf3ba30752b145d76a702d39b58587937fad2a1f9b20ab55f2a68ac54f46021748ce072d4fb389d682e0e8f93e6e9eedb617e3f7f399c693555a8cb30fc25113decfbc39a337adda8ca3bf05260a054f14b44d5b4718e47df7390d410338ba94628289ea3e6ad4a64408839afeb79a5a15a5f4f16e13bfe638ae8f2fb076075fc63f42af06357e1c4b153762d94d6083308e9d05fb71d375bf3ae7cd205395a2c8a9aea06b2f73c3a4eeeb0e5c424fde4067072db09ec6e35890465bfb3b37b47f8321dc1b9927090ec71054f28ef42a7ae0ae80122a36da04002b7d9c896761c6f218efb3d4ad0b97498f6df58cb0fe58ed90bfeaf3954bc98debf78b94643e96069e9454c32713296641a7d517e2741581130504ecf4b0761c719a53d2230a10800f3af75a6ba420568a8379d582adddb589e2015eb08bed026166fd4d5b30f676e8809533afe925a6a2511db1bae6abc29a0ebab3b0bd1975a0728e4209395b6069a2eeeef791452ba697f6f6ec38c1631c3d671f9058b2ac2e845767a7f1da8d7f9abfe508666c251f1cc1941c3c77148ce587592fd26beb86751d3cae9c762b8b44b63aa1ca1d83993aae1c79949f97cbec24d4493f60d29414d280888f2e2151d9494a02880fb56183b77d9e0c142d3665382a3bd7b9b84219384be383d9b08692da6b0b617bafb3581d96064815be6c137d782d293d7324b64dbabdd17f8c8f480e05f550b8bf1ef2c35dfd1f3c6807794407b5f87f74b235d9ef2525e823dc4840d75243090dde15c4fea942e4de310fc44e0004ed98a363eb33add58d79d0850b4bda3a4c424b79bc19549b109015e6f63f516ea42e72725636fef78c23366f0da4b437cfca85168ae4131a67bf62483df852fccfd518e7de44aa79e9ddac5bf1cc930521e749ac2cca1cbe862108da112e715e0f039b788dd0144a222a62a2f2b5fb9ea7a0db9ece88a657e6eec279ebf4070d279c38851277adc46f72e5d2207928f7add34c7068e5a125b4d242131126b0bcd17bfeffa0719167a14bd93fa8bb9e4fa6daf92797a0501f97dfad3d639a04ab530cde31743ce75b5e673649aa2644672ccce85352ec52e99ebedb7ebd3b99a55acb40de4ed3267bf5579c7d891aecdd7ad3302f2a46646e62fc91c2b67ea6b92471dd12760f9d36758b5a214cab5e39969da2bd2705e63e3ab2c95a79601fef7955ddf5cbc65dbcfb1b3fa8dd75cc72b2b898049d2452efba070b1330fd56ebd626aa58e238b609d2d2343f4b7c84dd6bbf248180020ab83324ee004c68629a39b069c87b81d43cd24ca303b8eab31a748d6864dbf8d54f02a091aef2ff926c03757523b886f4f51c453c15b57e6bdd2e2904b2c669bef0f7737ef5c022df557ce3370bcb7ab38965bf8c7b002eee3dcdcb4019512faa66149b42052a484f278860dfe3403b6383a5a578cd8e1f58588617884fda27b8131744d1309e10e69e26ba7cf016db3fc1803089b94927bdfcbdac4380fb557a0696597705210a93780ccce335988f7ef2c6df634399d9867860d0243dd2869e0d1c0a99610e6c879a157c1646c102e1c03394d93d701ebde36f46492305ce16fe8a6cdaabad17ffee101433d49c8aadc7d6a3961c5ec87340453560940ded457122ea632f076ed2e540d0ee482791282161fedd1bc78e527d7b62a6fa2839cd667deb50e38d9f642be000b98021bd01160eb53892e314def0470e878d58ce464871a1c73e49840a06f6f0b459f07ed938e45c845d6981c2a252bfbbdf3ed565bff94629ce109f8c0f960f2266407d7201b2f6d4bfd960c1d68d7bf8dd0a8890d5134b288d73f662dd14aa39aa0ec64f9806d1e621112592b5fe469e59e06f5ccdebcf16c1f4adec3e5a73a4a4ef752481043483cee7d4bb4f58433149ccb6f64efb37ed6858d3542082eb6835d097af2a0af37a12d5a683ca28698393be85dda123768d00847c5548086c5d656fd7d82984c44ea2e161565745a27be7c6906fc485c593d2062a6b739d6f67270caebdce65c8c10bec74a96845f64d8993130ca00ee384641566bed9716612ce5dc13a65cb3572395e571a3426a6f8cd1f174abafcd419081a7b5c5ae96ad82b4989e61beb1f223a15d8def3357d0df1503bf4375c83ae7031401065031daa34d809432946fb8282968759af922b552bf877c64b51bf949d74121ba94a6b89a4ca7b4e76b6e05f2ab292d53a9ad9fe3060e805dbcb0b3ad085c7174bccd5bec14f0f362c63c652343b77489cbc10ee6ec59791fa524d04dd159ffd98cfaf5c069d69a2e90b8166764e0aa512f203d47ace6c8bf943be2731adc746d29c400a080169b1a75c9810e4b2e7ffa3b23ea16b59924976e919a39924b2f381ecbb3fff281177b8aee85d3c4c7d0e261cb17fe01594517c7bd8c6154921005d40ca724adb7c2de31d10134537bae86cec1ed9bf127d561d82823f5f554db41acd63f5312c9d5be39a8bb4af2e304a8cee27eedeacaf5ad80ccfdab4a37aad7fe2e2af85a38f4597b46e1e528eb3e5c62890f1e092d52a26899c690180c941b84287706bd8af17e8ef873474a53f884b2e0d9441208c07b4f4aef874b659c64c79480bd04778b668bf41a8c9c6d1e13aa49671eca25ceaab6651d12e5c73ec17c001a5830158caec8810d30bc81cc1ebcb14a3c90e85b19fc7b8b48cff272e10ee6532df846c76d5a07941e14db5eef715b16dc01f5c848a203d3240388ea1c965e70d173489cdc2a3e5c0f9de41d20d6f9d7e739dd90496bb5d0cf949003cf221438c192aeb17079e15545e396f7a6a7bd5f440a2af0bdea567562400e759ed7151380826420dbea6f8897f6ee107774b473053c9bae3fec989425964e175b1df54ad1b7327a198fb3130d44e1ee8c07602282d8cc09c5fff60face4bacbf516b7a5e1c0f1021dae6ffc04834f6b7d9893d0b722aea6d9319d6b5cfdcc7790f46afe9678fcc2f3a3cb20b0b53b47af0a545afe67f507b0442f5d314a538be053c583b904d2e3c272f67fc6fdf9fba624a833934066f365f1344683e311a5510604d5ecb16fbd6f50c500ad51ab74b1c8fb7f96f9f3a3780d2b10b11449f921980a598fdff60c6540ca6b87fa51c4a6b698f10dca1b7d6c9ea92d9ac558ea684b9b49eeb988b27abc7dd95d05521f06a7dafabffce5e26261af1f12b3e5859ff579d6a21b77573897a28f036928b6751314386b2f727a791e152adf9a5f558e044555398d6f47ad2cfec8ab3541fd41808885fb45ee361f149ae0c7127940f15e54d41622f33cbfe7253861b3755ad82e1a4685a6f68703dd8301f244fe1abefb867e7db1ead5204234bd710f3a92adb20716b0740a82cce25c154bfc919ff5f5eedbd7b7b82b48dbad577f39615b0fb30a0fa1758afd72b5aead63667cfe5b6026df18fdaa37bc9c64d58b23444d2b6888008e3aa32eb3b5b62f19f632d29da4df55505230374985bd5ebdb2298497cdfebbc69e1cb58ffae48e7b0d1e5ec770803f5a343ee4468fdec11302a3c196255f1117859efc5fcb01824e4223ef7fadefd1ba0308aba03050887110d08f51fca262ab11a0959326a5c374029e0f3ea164a79183a23f7cfb8e00d4f7207bd966102ba7792576abcde9c4fe0576b974f1cde133908edb5a88665c8d1d05d9bdc76ae7b8311d00cd43fabc870b68e23aaef120b42121c686de72b42168eada85009012e095dd3932c9098805596944a97948d725231e26f3789cc140863dbe39be7aed7096afe2c484227bc177f5f5341b9b2fca7877471f2d5dd7e5eb421fc541f3f376ef63f3ea4cda920a07baa62c6ec8a45119e323eb502d2efd8d1cfc67d60f9fccf77cb441671d903acff916a7e132595413255b51c311316e5fc8a3f3183d95c8f253591308e748a5779c05f4ddffe1228a4cae782ab63fd8ed71b6da1376de26c7bd81f1736bd5edce0bc6721415317c3cf790d2293ac10a7ae2a03ae9f84140fba810b05aab95150ac279964ca5f0cc1a19c8e3e2f1ee8e923d06c6e469ab3a7a7dc4c35646d8f5fec0d16efcde32a032d0b775854b5cd9347cf1fddae33886bd7fb2748aa20b6ea911f09fd8bb15873fcc7e0f373849dddafa6949faa25e7a255fc36cb0425e0507f9c4c8902fb9a883831bfdca2e8b83bbbcaf6bf831eb30ecc42483be5f12fe116d7ba10c7cefc5a8cc6e0385e7dd197d2fe4cdf1b1ace735de4f9acbd1cc172c4b8d6405de0f66d0f236b8d5e87142ab5037fd7131dba5523426514bdee23696576abd93e98f593c6db2fdaa23b7e914ded430636c8255290e97beb3bfa408b8037602979e5f9247e2f35a951237beae256d0ad8eb7c4858f04407671cd33cbeb6a31839f982a789d20e68f086af28783a66bbf3291d60e3b80cdcd5f04c005d94817c432539e259583eccaab5625a5ea2d1d8d6299b66ccec4cd623033cb49c58aed6cf4874c4188b72e83be02238e50c55ac84bea9618d270a80c68a6da38a6a2f997e52436c4cf47cabf635e8c02998afdcfcfb6eae97c225442cadc35f7006eae30e65c2854b9084f3d061b857dc142a7016ab9a1d80970cb83c0fe807dfc4c24a249aa5a3ffd804f4d7322862eb4c78e87f76521d4b17ed73dab4fafc041b1f400db7de2e4e786c235ebeb3f7f7ed0cdf95573c97da46bf9008593ee9ceb345bcd867f19f5b54bd04a5d1d46c768de336fd1d1c25a69d2111ad2d3d426c3c828068a8b04d8a63165413a5730e303dda3e1741c9b14f30df269a35196b9b5a9743fbd6c82af001aba45a3fc296f3e888d4b98255539bdb83de34bbbe433b1db381872473bf88e0c6543e81cd44adc43c8b33994a18a228d183b9800773e3938ade433fc518d11ab3791d4037be3eb5f78659d04ee13283178c388887e7270f4a4552fbf652748843bacfb67a6a1181a1aff8eb862e3a9b5150dc277cf27bc2147e51b70e38cd49fe627b305f54bd1d38d8a6da1b6335190c2c0ea650dfec1acb40cab36f16c67bb4d52f25b8c8c47f4530365012653d88796fdd656601423095a744dd9a8f18a9d22751164322f0e6fa55a97ca4fa695add204347a7f783279acd1afeca421fecae685de05d18c0df6961e96ef205b29e67ab2f43055ee7c76a46f6946b8a5a1f228ed3c82bd6d3733ab8131d0a37cfca554a3d8b19f2a643939eac965664a00bfc0e82281c6823ef26d23c6a2f33963bcf6be04983a37e393e48f50788b1a7aac3786c6df3c5d039253698a1721f0bc37dcb2a2b3c87ddea68f526bf87122910c175c5560758db90e06ae15636941ebb9364b89b1adedee8fb440281b64bab5903ac7b2be2fba96574425e0990f83cabd5e62e44f21382746e2a21f0b7a1d8eee022494384f92641d48f722f2de3c82a002692c2be6ec68cdc0fe1fd00f89e71d2f2fa46516c7bacc508ffc81b6bc0a6dd881d0563d9344ce7de318a03ecdb55fd94cf919c32fba72172203cd00c104d21220014c97fc4586d267679a9267f34f5ba8a1dcc91450572d5583573ad07d131770064e399b055d098288774d37ac7be506006fca8fd4efaa4921d6f18d35a9e9308c0b2302c629f1348ac9e027cc9bd6e7ed350aafc0bb6eca1ca7e1eb33d40712b792dc426d336f3b250e8bf39830d3535c1177e68d4c31a565ab400a6348919c1634936150dfa0b118df65d0bae7ef90bf55b913c718a654d42730eb9745f08f739ae53b4f37953ed2aa23d4f26374de412836f8c80c9c2539f4ff8bfd0b9fa2b86941c577d4d952e86c3e4baf56eed7264c153d2a0f29a20b17fafb19cf06d8f8ba2c325884c7535d37da022c0ce863d2bef31ecc8fe8e99e91dfbaa3a4ef7199043461195c4c6c941d8b415bc71ebf0ff00e1aff095ff471be679f0db652845b6c556f42ae098ee5d4378539124dd98115cbb69fc5a751e53261fffc488c9524d2fb413e9dbeea77c3c0b400a855e57bbcf05f2dfaed0cc98b31ed1137a57b762f395f9a83445d0e73dad951a28cff93f9a9dd50b9e8e280e1f8e73f2f949e7c8e77c746230a7589f50ca0cbd0f8e82c5416dda841bd28956f35c3e6691c3336c6a145310738113f8a1f0be0072e5eb7f4846994fced66382d0aedcb89011c0729800ad2cad531dd6fb133b43e9076cdd47869d583a2364f694456c996dbf5a0f759dfe4a6fe85268ee3740d0c069cc8da206e12f53664c2c8087ee04c8b5491b481e03bf938580f0f45e00d6a8cefa6cbb191b3ea9b192e56a5b8db3d0f0197cf03f1117e54dc1db51e47ac6e3adbf3984abc34091dfc2f5fca59174fdb8435a1a0c54f1cc756ee38ff85ae690e7d8e6bc9b4e989508775dddf57b9ce4bd43c0d148becdaa71d1e2ca2080062e8e4127ebf650a5bd0ed9caa4ee555f642add14bccdb0ae6ac95371a6548491300a5182cb086c850776579d93eda1ba60344690564b8200dbe1bdfce013783950faf8d13aa50154f2db071e5c048c75b98091a3a795e38ce57fc17b5542c597e4660d31e3b59a75dec8e893cd4167fb73e010d91ba013d4c35daa336dd44bae74d435ca1824e8e1b563a8aeab5e95c68fcb20dca2e1d0fb5349d284c95c125cf13eedd8d802963149958520d001676ef357973414040363a42a9ea852d693916a2c7105c737eb44973c74ef22990e09ce4928cb916503006c0d784544608e6993d70b6b85ebd3c8702411c78080de42ef1ce0d02e0a51ccbf986bc01d95040884b5b0c966ad103e998debd3174a5ef7da08be1ff65b73cab480f0bb1af85c6f24c2284f2e35348e7b88aecaefff58f0b9e548bfeed58623f41963fb22e9540b6f854e34c4688bb6d687626947a75d561586d0d492f8cee244657d8570d0d2b9eef52623be6d780da3d8ab2ac7c1f850b5e6b5039c2432ae80763ac334510d7746012b00c350adc04df17bfae3a5c49023f9e18209ac3ed25df4fff314b7cedcf4a6a675d00f5a677f0c2912639aa07011d3b0ad611ce957eef3cc6de718a84a3e91ed7ed44a5c102dbeb7e8bd40f5d3434ef77af03096fe5e0a9ff0283afc2d2421c08c46f9cf7848adba2c7c2ce1c6bffdd2a07e041fde9eac96a07710e949aca83635a494840604eab3dfb2a5fdd238d5760397513892ccc56eeeafca2943a230070ce5248d488f50961fe2e9fbdb5cb27803503d20037a2e8d7e20f9a7fadf5549a0b61b112369b6ba7e752516634b6d830b3fac64def729fce017f99acc8fd4176d78386a8d65eec57a7d26186ddb177e04c074ee8e140266c92ad4d0f830d7bf7fb9a35278984b446db70a0704721e5d0ea6377f91246c15825e0396ac103da5b3bf3537cf04d9d38da063c99af664ca1cf9d49a93130a7d81a1e7e4ba08fb5e7fdff095a954fb986e0143a68fc82a686d6834afe6c65d32dc71e1c9635ace8686c1d5a475f138c4a5c587999310a0c631b42437c5cd980f6dda146736f5bf1eb5db229efdef0c59d4b248eae535038e8d2f2802ebc40364b42517e3da57f68130548321b1850a8abb667de64ec4dd1db8b800371bdde48d2ca016dfccdef8304a8dd04698a8f3189bdae25333501a68c80a62c43f2ba4972ce22583c07a47819a726a61ecb788cdd97bc7678666c1ce1b7ead4a6dc6fc34c7207da570c031290b889c74f53869e3cb92c42ef66ae1ba8e39b86e7702096ff1e717c17d0a28916051991633656240b9fe63cf71cc631914db73fe6cf7a2a62ca162efe82e353f6a9b50bf39be4327785a0860ac2811e2eba624ed153f564e56188612d9d52bb3c8197d5d8ddc5a783c3d351da9b38d08bab87ffaa7e51cef91459763bf58f3c3f9002e103b91c5107ff3db55f2f490d2e3b71193c9295acbf295319c7babbbd23c672d4627e3fda2c7107b1d9f2ca2de3ba7766c9691fa9b1fedb2f12a0b99c295f755e6c8e0e8f224605108084e3ee2057c974277674bafe91476d0ae6c2b95ab4acf674788535fa9176507f4e7116bb327dd6ed73fd8d311289909f31ff48ef81ee9477011d45a5e890b3e0df6db4e45ca6f4277f6caa750e244f1cccbed14b1d452fa53a2cf5829b1e3420df30b94696653949272ba5386ae4f3b9393e4de15fdc32f6f6ea781844e4aee5161d57bb993b4718e958f263982eaa79424eae3944bc1d76b70e02fcf29e0b806b2c6e0533595d6147ab4beef75f328de0e63f883f02ea7438cc67c6934f24065431fb7dd85b03128b6d71b8a6ed5e258605cc699d03b8a1656ed667cb20dcb1b211ffd0fe9327ac1894a5d4af84805d3d1935e0a4665418fec36fa4e802041af776c1184ad7b0b3f822076868b4319df481f15ec56a54dcd7ca65b5d2b2581ab077a560f221e0e87049e10a0ebb2e490a7277454a5fbf2191c26296c2c6f202940bf597659b7e0f9f0b6bf52adf90dee45fd846ac17fbb540669f4398b0f07e8d1ee28f8123cd7a5ab43190f9f33f93af7a14a9e46f1435c98057d3172a5542cf2d8b2cb7c755fd2ba9d5ede028c8210e86287dd59966dcd8471fa1246a2518570a39e478365cda5a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
