<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a09858ac056a26a26276ac97a5a0d845faf237e7a3847a433e39df67687333fc1e72aeea1180a27bbb090a36fb89ce47b45917db77d780e542151b640614119cb43bdd49d367e5a1ba2994896637b7cfea00b6340fb153b285548e5162184cde2611380193db30f29605a2c70b8926c628e272689310712f3e7ef56398a15981d114bfaf8bd473063a9fa5e9d96d0fa7a7c8fc467cbaa3061617f9507a354b0f27be6e9435e198a31f785b91b7ae20462e4f71242cb89903c602037507b580fba3f5a019ce7a4a2cbd2ad54e67abadaa2b34c6461a24bad037822c1792fc215929e09992164cbf40c3693ca5b7ac85de227035789120b495b6b939f52c72bb0696ef5161e35275f03dd4bb44b5789de500a0250d27936f7a4b0befa8f99aba6eb1db0d7e5f1563d775f2610943abcafbba6af449acb65144253397adb385c2e7fd9cee7cf12e2fc1a0ebf6f1ae08a289a04f8b1be37c660f80353430898f487b7ba52bbadaec91dbf7c52cc170246a696a6fe8dee99085bdb84ded90c471b95976224bf4ca72593b6d12ad16030db7a6f7d607a69a4684c5db6ca77745c4d456c2487313fe46d4653bd199585adeac38b9411022c3718b7f8c599377bb4eae27f4bcc4d715cb9d29f7fba9da1158418dbb14acf9ddadc22f29a6a2624e81e4edee819295b83cc3f19b62c25b587196e7a6c51be64e0d70d8af4e46c2935894340296ef6b63c476d67e7d745d0ab16faeb1116053421289cb35e9204fb819dcc6abe64c3ced71da440605fea2c2a87040a9ad46e1ac9051590597fe0aa0ff03e041be4f3f2d998dc3cbe19e1936468b120a42c5ce10f9334697196f0ef3fc535602c8d73b5ae7c87a860a0065c378ec08cf59a7eaede0a82a964fdef13b9841df6b63b91d9115c6e67d5252d788da9abcbcc6230f308b9e4094202d96baec75a1d70351539f49b41623e27457159d3636fbedbd5bdac17843e085cf62224f30644658678cef5362f36babb3df78d236867a563c0aa2748d48bcbd53406d68db32e633376ec70669de2cb455b3fa350e5fa95abe409061d896ed4e6ece2387dede2014bf7dccbb0bb3183dc5711e1f8941a1c6cd92abf9d169fefb3b8e0b4b7b5ea7a89da50aa291aa0d4147d4d882094a187e82ca607edb977b1df9e77733f61106273b1f064a86287bb79802d939bab594ae1ffa7e18f1a4fb2f877cf8fd0cfb5d70fa017971fc9a12b5910d39f50237659d02403d57d1cfcfd035daf074f5897935cc4e7029ae55b2da4ca8d52d0af5e03fbe82c2d46e6cf14083937980008945cee689b2f850e58d4154a3cf8fb5691e92a465fdd3927a9a3a6a6b7efc02176c490154ff3b0f47e5132e7c89919b9c0fb8a0891926a2f3ad522768d299fffb3d65fb88774a3cb6b6210915874496b8c31c5f70571a232acf8af474e301f756270cf1a9a6b402a7a650aa266f9dc8fa46c62e87257f3373e18ecb021475cdc181f4fd1845b8a5c1e51ef4d0e936213f601e00231fbda73adac73ad397c039bda6f3837fbdc75818861547545e2929d0cab3ea556d838dcea6215eeee5fcf261f2ce9749d0b941851e483402c55fb7c1a7c4dbe701a4c00e5b29876591ada2172934502e22df0075682874c21f02b939d46c449f7dcfde4e78130ee08b5072c25be2e72521128b8fe327535398f13fbf6fecab2943e4c0bd17a0a62e8d6a9ded86d26df41cc81cc78087ae0aa9506ef31a02bcb7315f2135e61d45dd0bb542303bfde0ad710c4412c339d419e804104522cf4614e0bf79657f550bba5127916517fcac02dbf2bc3f20dd8b64c9bf584a724d30bbd8b04854550500a0345a68506147e159c1e4c3eb090923e9369229f5108ae4b7f6d5969a7b5299f219ab764b63d97f3b4fb9c23f53d509c4225d7f2799dd053b088149609e285e480445af053577f80538fedc1b95894584e34f456241f527abaf4bc42fddee42ffeef6ce30e95c6e254cacd0d1a06e5c701b020cc5bad986d1f6d15be4d39ef8cfd45dd3662beea787b765f2c1db7cb61ae6ad8d7ff9caf0767b85e7cdb6f395d0e962e425682d56cd71f0932b75f84bd75f7e2cb05d3ab9746dfdc8f7c605c7770b0f39e7e213b3762cbef59a99a8b74e42f5d0e99b7a134e2652c39d84a39919a8ff71d9bd54ddacb801aa09470d291b1d794dd1cc2bfc3efcf2eebe60e7506cd789628cc661a5224ce29f104e355ebd91244c6fb90e7c2c9ed4b508fcc2f46881ec7aeaa940c1cb38b5b0bb9c9d95cfba3c49130b08f0bf0bd80c7cda631da9f50a09f015115b11420864eef4bde8bde7ea7a5f0717d151f6341ae4d54e67be1404fa4c76be5110afed4cb36ff5df41d26a0f7a64955fdd85635560326712f88d424b60d5d800de217e46c91627e8b6c2e4d9bf60d583e0e30c4f7cb87f57643b9aa9dc7642cc37fc9ad42c535522b45824d00757e9e9205b4d114eee58e9c557eccb67494b97019e74dc2c2f4613691aa65ce5c5b283fe8094879a6753b0934338c15de5631728490bc795b9e821a8bb4e6be16e7781841525f4ba0bb8197f4888ce853d7e9f5510fcc6186edb5a51a040896eefeb59452dcf7bb1e25a3edffd209bd6ea2b001efe75b1a5e81bd3f0bdcab0a764b033af96365eb00d32ce52eead11194aac6fec36b007b603512ff55a570fda7187bf7690ec8b861785ca75fcde80ed875f8dce0f95b62333352b1374c73b442475535377dcf78359434d9aaee8b96a77073a91caca0a59d6ab173bb46dfd23be444aa70cbe54a5d392aba8edf9bb54006d2beee246f4bfafe89473bfb333be2a2bc0ee9ef404ce328b0a1c1e3ed3623b599086a564054c896d5787cd396173ba9d5c9ba6afb2f875b73ecd9822e8d8214e032d8c83bf20604d81bb4a440f398c6eae0c5ae848ee0eae51702d927c54534a676714c4a1332890e6f9d084ec6b47b31891c7d86761d21b530cc0d41cf73e0a5ba9bce82f303079cd5821cbc4e90ad0284b606be206acffaceb450034da81d60e18105fa9a2a1ae75af4181496c00fdc48afecffeb4126cde8d60612a69b0bef90720a687e86182b36b9d2347d695cbdad3222b5692f455fb86c35d731576f8c9be64c51bf99a6a78a0b3c55ca124c291a54ec7e0d9c4db0d482b542bc4ae28647bd1f9fc2cafd78a4b460ed476cea71d7e341c36920ba60323cf75e340502ca6ba2640f21ffcfc41fc184b30de72e12adb33c8d46a06d482aa8fe14825c0170842957faa53ce6aa631d0e851e187660fb890b2aa9f58baad13f6f75a2f7e8e6eddc2c333c7a1dc1a6d0ede8ac8a20ce4f365795d1af0f76683a3c81cf77a91b3534e6fbb410b27bdb114b1f0ad4765adb2ed092907599ce558693e839e47fc977ae5866c3caffa13805c36ddb5b2125789c252420b7bc5a4073a0ac8ed7ce992e23a3eafce2c7ff17518c8372f843fbe10554806657dd47c10ac8c6b3fb7077e9731471f185ba9b67eae963c03722f147680bac4d4a5391e9a400a941f2eab7a5668097dd01eabb7584ae23e08d64dca36ba81adda3eb9063ced81295bbd8969fb67b3923d24830337ace19499291a2287b4b10320be0afbfb76a0b751c752695514d421da5b37ae8726ffce079bc9c20baa517526355d846457edf146cf3f6836a6f470566bf71c541551967a44203c07bbfcfb772910caef4f150af252cc0b5247ee793030c39189f4079ea28f5f7b048b25e967e2ac65f08ef7cac9a37362ecf29c8d8dd8641bdfb1d3839f72d16a6d83728401a20d50f7136e5b23fa0e98a36843b260f457f33ec4fe2b8b1f8ac1888949bd9d6e09c7dcc62631f51c1dd73381a0bc13e16287072c2bbb2e7b95d6cd49fd6677e50a1688fd704c354f7c016935dc7c21fafb09f9345863d5ecddd377bcb6c3d3fac91d05b7e9b996573b725679b16a808ded3ece809019f124d06df7fc6faf714a6d6b616cbd733987c58ae9e43b04021005a737bea7ba5d6a3c7eb8e5536bc0b8150a5f68fd78948d94fc4c460351d8300b4be5e5954506ad68eb69320625a9d6b1581d4c30f4444a533bb2822372113d87aaf37b9c59d0037faa706bdb27d11e51927ae927fae7a5a18f381a44370b54fbb14b0d144489f20a9f5ba64a692cc9ba18b11500aea846decb37d84659c8a84968d2be39f5866ba7ef9b34be27b88ad5fed8a5eee2b0fb2090dc695b50e56f6453e24cf33d5c24cbe7c4957af3390cb6b7c82eece030efacc68cbfb449158f9b8f93b07d87ab32d56557467147c67c2930b673cf3b9da6349d21c64ad67bda111ab03e6bb07e31662278d660e985f94c063693560507bc2584474c06bd3e1162e3d72c50acdf2bd691a2090c723db243559767e436bae93777444e8385423e8dbe59687de4c81b006e5239b2e76723002018ce2511df256f61d3a14b0a8b1e0cb87cca02eefbed59b281b236b4c24c043e37c045aad164665c36aab916352e890a5d74f7de9445c5ecfb7f216a89fea673c87d608f6c1b029213b4689cbafe1892bb89115dbc0132a0ad5a23a2f82e9390461bc6e24b9b662c8e1b56bb8b9a6577eeafec40fbcbf82d8e443003ccda2e3710061b718363acf648e37b8ba28e68470797d274a0cae5125365705e0a5f25b8eaec20ca5394bb03c65800d0b36528f021139e374552c5118e267467c87d85b115892dcaf5f58484d20155e0d2ea1f0601d92bc45a18c87a5b73a5fc9a5ad14ac0910d558a754593868180a7afd203cd8a9390e1fd1ecbfc634579149ff79206f72aee5fbd1d351d3cba4109292a82847bed5f59a7f44a0c9925a53d3557523d44a33110ad116518e9f400a32397abfc4554532cc8c10f7f92d239a61412c73c79f8c07173ac87c91493e8d6890d991ffd1a3dd033c1d9a843ac379ace8d8a6cf06d42eda087ed0a1e49044b50d8ae0261fd37d48c143a33a8818b063931dad706423d07eedf7bfc277a36edc240ce51bfe90bff499d3ee935b339a9d4fe0e0cb6aa9f206507a206b4c42cf0a85e66507ff3d1d498dcc8e23df7ad5fbfc1d5517440fd0333a5ad4dfff43dc899433b067f3ca3c5f6de575b17d4d5c2964ce2dc2704edf788507a9295552bfd3cb0288a6c9214b16c94eae53026cd91f44abb2008bc1554298beeb724d1f36a0f2d1a4ac3dbdb20d7da0bc7aa49ad5199ff3b1fd0ece49c21bdd05b9b612387fc932ef21c26e1666413e60d8cf1ee6bc2a30ef6ed019f1093cfd814ad91a729e9e69fc707056d6d0f65682047ac4e349180eae70f851acf813c9b3800ed94ae6d811b16088cd911086a006e51adb2a57f6284b43e3be46320a6b9638f0784175c106fd4d07f47b29b1312442abb6890b7170a2424046aa6f14dcd50c41b318bbe5d5d8678ab0f4022df0f70ae3ef051b30687e5148ca0630600071d5df25edd2619bdf987dff999c3bd0de098fda66f2e9f89c2d656482b888a6fc529bf7374b4854e0db582c74a049d781d82d4df4ad20e5780487f61795114eeed6a424edccc09cdd8b0fc15e0c8b9e76214f1836596df54e1e01b234337083165d4cca0399e4c86cad99679e9b3265d1a89584e188c6b2e5ea436df0f2adc81f578c9bf1df3fa9bed6dc8c8510942876ec0371fdf6015894d282b146fe708e77c0ceee8718f70161e4c2631d73f49fbf66de622f3dca9f43e77191e77933ce5efd76835fc4c49aa1de8418172ba4f90f3ecbf11c60544f04488937aeffd0bb7aeca68c5960425335c9f1c54538c0b69ac371c8c77c8d2b7767a635e27963eba67404158c8bb5ddc2cff89283fc23bffed3e2af10f37b2794701c936cc1f06b0188dede730013fb2ae6265a03cfa36537a9607b4fe377a5d998e40c6445d3b565ad2943892769d0a70215b676da847bddd96babf2416b426bd42aff7c556a03c2528a31f186ca51e7bcbfcf97d744a60ba00cc8a1803a478c8725e5ea33bad8a75ef010b81b3d431f4f420ae23f877e1a555ddca2dfacae68101754182ba2a4bf14bd54f3a11cf4e503ea4e22f11f61837aedc30ff9dbb34fc56b85dd3f24992291d88a912f24e227ef897674f748f84eaa2ace175be9f4b9dd95d8dac748c6b2b9bbfe10f5be85bf548d051dac041cfbcd91eca43000690cd52025678d543e1fc379f8f829602b89808fc062f588613adb0c98815ed6711e3f4c8e3d2a61a305423a9278c9d3b6d9570cbb67eba5d469575ab74a4b7c6aa79b13fbc4a07adb57d5c7b38585e39414330cab7e199d3a9d6474d786c327421dc2009ff9723ad43a257344001f38bdca3ec2f615e93f6516aafbe1d6b2b1afb7ac8fe363064fa2a96acdc4b0a4f8f9ed9798c7348a84e42211ee9af7faadf91a8c6ca3cd644f5e40e894ca5475ddc57df8a8d07c4d17b9cd76837839312abdfd3b5adaa6f936131def30c27bfc6cc17866845eb8f1aef036db28c9dd5cdab42d27243bd10fab68abd98bbf75392ce103b61d34fbcd7274543013102e6d598cc6ce3e322048f96fb019106901a17c61ee51b99664f91831705ae4d501bda93967f876ccb7386450e13125eed8255f9268b425c40cfb5d098b840a2403cf5dbc58f48985df7aac36da01421b08b40e08b1e150085212b7a4ad9845b19b125395dd234f06fdc2eff2b4168087d4091222bb130413600758615f91c69331ec50eb37f8fc75a269802e42cfdbac0ea51c633b0d0753bc704b6124c3dc1754fd8a7c0ad161512c89c8837f8a9c0fc6296b2ca1afadf9791c2d38726617ed41ebe871faa95eb1f7f567896143242f3f31a23548ba6a8fb768bfc75cb12529a8c0dbfef762b990a8985c5a94ad956fb1dfc535b050b1bfadae7d5df403dc105e7cda801c363a2c4a7df0ef5b0e56d264beb809ec6a62d02d1fde95f7b59e8a82af86abfe84b1e88f44c35dd27f161dac88ddc6eaba3f2fd9f3049a22596f9ef40af9c5961dd0e4806cb06fc2df3bd1f66b249501e58e69ec2330efe4067a580baceee5ad0e20904fbd269333d89bf612e70820c570b1644feb35132fa08846f9b3a31ffba9382b86ca7de4c9a4aa926925054f34b234f1498534b69dd683393a5019ea5e15a76b8d541a02e567ece26fe826d6d4183d1120e514f51608e6030dde55ae6486307e3cda53f61e485d304d0ff89a790256d10237a3a147e721a269c2633c69c5735274555237156646566ed609e3310aad04d1d26fbe4fab3c600165587d70b069d639e64ac5a9df62a2ca4758775526729f125bdd4fbd41d78f39209438c45102578f24941e5aa005b1e9f1448d42b68083dca19472428738aaddc4893b633eb6482a4fa62bc6bf25089e952162aa786997c45c5ef297ca7f89e13c1933c22cee229bb6bd35e12a68f46c41599032f4f71f89bb54fbba80db549f14db80d05e2ac37c30b623e001a9a1453075ef44afbff7d91b44d1196a6ea60a558f4dd2adc49b387cd7a02395bc1db53cf0bcb4d36843847f330df15664ac11444cab664cca40f33d869ad6ab2635e994531a6fe84d12ac5488e1f9875b880a63c27e6f973452c1b2dffac3d4d648bd8f9afb3342dbd7f5f4c6a9c6be70196f12dca95ff057e429883c2e16d7ab849dcfef66f7422d478802b9f035e2956d06416909e6358142c85dd5bb9fa9bff29838af999e729688bda4237d78fdc1d638ed6875968ac4c74be0349acc49c503a7f05053a50b8d88cfa847cb8d3841c974a85d2d08f22b7731b528c2abb894d5e7f043e198dcc678a597310b86d8731b092ae47e3870fc0910337e11aa80fcd82767c01ff7ff7a11aa57084991def19a5f49a4701fcfa084efa085474250210d0d0d47df76e8af48a92bf498b5527b5a416af4381e4097cf9fa3ffe696cc2f3de12002d3b6325243e7dac720575bb00adef8faa85acfdc9ed1b1ae61cf84505831250ff466a1f4bba6fb0fc1a2d27693c1eb67fb4a0ed83d884e9b028570bef63b3251dfc24598780bd8f91f3c51f85a7afaeadb3c097f98ce8109829f3cbe86716f50509df55f25ba891fdb2d4fa17337a6d8221209ff1c5e6d8188175f9d299db690fde1b6d66ae095a691c960ad60cd6c70c7555c2b08a16429f878813eb4dcf6ba8c5c7e1cb7b0e20cccb52b66b98e4979824c3ee9f317f48a79fe763f23c81e83645a77e54bcc8f49f27350138ce0cbde6a828abd1f1d46eedb74b99bb95050676474f92b01a6818cfca6fb1c08ed32c6d237c332e7bd2183ee1e7bc7990ffc73570abe7465b6251fa2aec0e793a9f71df788cfd35069213ce585b0b5af85471a0bfc975df7a0ec47a07cec58c7c3b4887af1c399acf437600bb318a144b817b20de14bcc28d0f8b1e06ab5f314494804c529f7238377a54a4b0d8e462cee39e37c103954a05cc6e145059bc313c28f64b2443161b87f877c895db25fa9812cb8d5909b0e9f83d360f6bb51a121b2048fb6da3f9866af01826ba6ef64ced5eb66543cd8928a09c52b713b3aba40d6cd3c4ba59984ea63e40536c2bc4b75c2283f3f97f1d8665edb203ab5644027e591d1f7343d9061eb831b8041f146694427f0eb6fa38cb07852cf20ef7d7f36b41390a9166fe13a6efa248c25bf0dfe64bd456d281968b34bc18edd0f6613ec24ec1600ec6ce2d0e1324814361539b381327b0a13123891c8f0f17623b671120a4ff8138df5e429d8dfb046f86e9e908bd47b33d66380a24b5becdf9fe30859dd0157689b700e337741561415d62c7b3f47d20d7f43345dca0cd108fed777152713942807fbb274abe084b4ac54b473e349bb79f2bbe8f8da3dc8ff89a416c69174681246653c8baafa6101580b2b1cc9a85d14c4baa718008d74de224b66881b813c0130ce4e92ee93c1278c87d800c3bf0e1d2f4229388c7e68ea44ae56dc7c85500d32cc5dc6d05d040393862603d93968383c24e9c5577847605eb31e4719e97ee87c4488e4802bb3883b730e8ae742c032774b993520b6b0a423d4a59c550bafefc3723aa97d5d9e7ef01552356d1f7df33738c01d6a54158fbac97c52380187f86910b64e4f19e62a7ba2642d01ada0184f9f8685df7d2badc9f41c0869d3090d841ed93cc42e1fcc6c9cf3bd98cb7e8e8c5e251956311a569a4a89f9caa91c23a55b8df983e25d33a62ca5991c41ccb9b2e00532228cb384c2f36b6428639e3da6c21523fd79c088e87e63f0b75ec1de850ea44b3dc216543a8f07988e26e56f516f92434a21933663b8f60cfdd336f7ff134b2e673aef636764b3b81d3cfd79b1ee561cc6495614acea450f313f9c4a1a1c5c66c5be10bc293e97ef816439e3919e366e593d098ac71ce0cbfe77389c3fa01fdd68d50a6ab61b9dbe4a8d005d18bca4674057b2ee8a9b1e10f3bfa431667736aa1e222be70b897ebe4943e6c26699d38cf94b3283cfc9d9229b5992ef39edab07ba45528d12518cf4e96264331eb7a9652654e0264592cee69a110db3da0596fb748532d08ac8411f982613081081099507ce4ecdeb95f509dd9e1d8c59d5f7e0382c2a1552b766103182724b432185a6af02cdae3f5c414125cdf3258bf82a232f06cc56a6932c687a4fa19ad137bcfabf30d6699d6ada44704df2ebbda0770511e3203d6cc3b81b33359fd9cbc53e0ab301e2fc3c4f3e3a3f1335f52d5f49abecdc0aa00fc9033b3f0c1c60ffc03b395bca58433f6bcd0b8fe7cb4ce288872ef339fd871bc5107f468ae309c07078fdacea274d65a444476e257962584db744880e06a22447b4186eb07bef45163228280344d767d021b499aa155ff67ab4a4ae516605851027e67c95139eb0c70ca8e606f42c55c4fa3648f66ae1b7178741febc1a0a61c9541151fb28995833910c81af42f1a0de940b2383e169405d8019921c8a3a237c77de4706e5dcbbbac3898e8de2f4afae0a5468fbdcdbb55e2f7b46df362041424b303213a11b21b007e9fbc82d751b6964741762f865b4f8a12daa0d0c38af1fe02f943f73a6f93324a816c990204f5cfdcd119d1f4a16e5fe689c7e5dbdc954bd0d1d1ffd88ba40362cb95cc7c5d253750280bc890b08d671bc3abfcd85d05b3ff6f1588eaf7bd4324b30384a48492329cfe6cf548427e66bf94f2a88055a953786631fe67053a0a89062e1531401086f4d1420ddcb484c084c44e2ca62e5a2e774b1a4424046d6e32c4ad8aa9cf56a71ae224f1729fc61a9d767f176fc99e0ff9ec86e24a08b25481e567a8084e3f5b9f04310fd9a2a12e5a27f3353e87209553fe0bdfefdebecfb69095411341a4bc1400540b2ae693ba26796a2924bffcc7c21e0131dab361b2da295a04a18d8c6fa754003a1048171fdd21f17ad1ac43dea0affb4bde553469e814d350240f9b658cb4a311baebcd5a52043c420da0135379866f4e8ade0c04cf0598634d328904050bf049c90c69e009fe579aeffafd97b7d4660c5d38d613c3ab091a0f80a5f126a5b157c35cf9b48e44f1735f3d75e3d6fe793a4a060edc71dc0314c1851c9289568f6a5893fa0b2e160f940ac9a6a1993004531db1ec24843e2b72e6dafc534ba192f0e04122c86ff5eb259c4a74711cb8466952154c653a6741fa832998cd086eecef65532f7b1bab979f3b084ac312453ffa18020bb0dc0e40ae6b79fab1d47227bae6ac0594f723ab467f2d2c82b77c312401a1f0c977b20b590eb8c9e5052d15daa632d33c804cfc5bb9f35bdb1ae2ec4ad68a7f1fa872a316331c644a2443f99b9291fc62e5b16c5cb6464ad65d9d498e6e5a0cb041501263e1ce0cc1d0b2c246540548934e2e5c160032b004363be96920185f97034a3f5625e8253fffb2637cf87502e38403f8c73394b5cb68601225e0dc482e801d5da7eb757063905c2a91129d99d2c22f48a5d4de7bed2efd84be232e58dccc528461188ccebda2715c1f7da73ace77ba6c4d7a7afa1b4ddede8820a375012b5f202b517c70c51a0027998064d9884610e287514e3b1931d432022cc01f13d802f93e172c9fc6bfd7bb4de50e982edfdf5159872902c3d7054864c90c330977a3bafc1fb5ff535b904ad38a9f27a8a2972d00602159b78f66bfcf883b9607b2867bcf2a775e63b5f1af301b86b92205679eb6ad3608e64b2ff433a274f2552a3c814172219aa489a44e25f9964d5c0a170662f6512cc8ffb4a48113e00838e7b6843eaee399bcb7a96e35efed011d03430bae068aec7b9777286049aa128293e988f933a04970d8bed69cde970f23a8c6fe7a48f8bc72e512bd96bbe839d6b5a2aa084c692945b6da0f7bbd91bbc2db88e2abe554b595a4507034609d737f3eebfdeea4b4d57d6f9399757f2e3374aceabc9128f8dcd987917d8a4bee893f7d1978cf5014099772ec57efcc0009aebbd556bdfc2e34182378f6045ed7e90cb3f93e066b07409185b0640555ad0a9d15d4a176ddec280a4f8488aa2b96c3081265a9d2cb6f41d72b7544dcb31ef9b07c05cdf8906205ff56a44cb22399bf87e3341a4ebfb7f2a55f56f87a82c94d85176fb7936aea2ae376e5bd57c4cc99316ad56106404ae9769969e401853cc4cbcbe32712470f56ac6be82ac04656b7eed3679b39a64a37fb9f986251d2a295d4e321e93eb5c846054d4d3d401f7e86ec56f8118fb989488de60d35d3c7960faf45d10af84e893a534aaa331014bc0890eb44ae5b9a9ec4b43f99e344d3a0a29c92b5ed2128896aaca7fcefc03b707a19fa92d6e568d64ae8f70cdfa4ca0f16bdb84fe620c54541ba15373e6756a5d417304b18d46dd0ad911280a4c94214bdef9c38cf7b4cd2a8d2f9b08b1a545e9cf23b6efc178b457de9bb77359a9a6f03fcb13bc9cd3fe90d64f50001942f9e2031803085c8504b60fefa1194d341b160b4243a77b38bc7a59ff48445ee526a9c5b2f102ec3834964a2f01a2b28a3bb8e147ce22459ba56b9a707c6c689f48ae2249bc70b403b203ac80f0732727c1cffce27cdea7f19aecac64d39f34346bb899c9cc1f74864cabb4876caec871e2ce5826ccc88b30053adba0ebc51f0c6da65a75962370479a3adf841790857efb5d6cc1274bcc048781546909c941540c231aa2e06e346a7a15b7cd8addc7e0e601dbc6040a925f60ca17b2ec902c6e50ef9464463957d7a1f7d7fe262f5064a969b476dc2e9f8f1288d1176059017c7420f0a394aeca0c326e67b3382fab831027ed381bd79a63c2e770614efb19b52fab0a21c601d8f00ad39322c06ca3db611bfea5bb5507c9b8b72771aa70c26fcb7cfb2ffefbbe31b508c01aeb9efc51f9ffb1d89a3ada968fe9a4c8e5529ea303fd2119d70e62e3a6e3a268be3bfd6ca49e674f10d427b966b84964414c7a667756d5267ecfcf1755559e1a321b5b6fe7eae444cc439f9b7b9f7cdbaf377e58d8deff9099e5f17a1075e2b6ffcc8eb08c622be5c857381a6cfec66712d3525fd053a532dfe01e434ccb23d27321748bf47de7c3b988eb68642aaf7a23effdd7d427c9538da19df8a85ee3507e60be908e78c1558c94cd5eecf9e865fb3db649da58163bc44771081ee89121714f8d80b4db66eeb3215ab5b26a29cd98cedb881a23b3ef44c60f77a530594c000f88380d8ff39155cdef1c03f5453a723e269a654bd22492ae91379b74da90a698860aab352225884821f699d89ada11a9b45d5c935b4d93539e475c3b1ae62cba3e337d8cca0ddcba3aad4e48ea473aed6e15c1f3025f340633a291b0eeb4cf13e6fe0e576f580cece44e7cbb332f8a4ee7be116849e3fab98976afa0c014db352be27e23fbebdf17a1de8d39586a0ccc58ec7ae7c89edaedaf12ae9dbe6b3f37b20ca59f33e04a73bf7277c124cf44c61398ffd0f982911e6b8ee0524396cd876b089dff3415677318e99d3eb113db5b4174c7ef1879c50e4088930428cf306a31eb22103b7b751844529c6698e63e1ca0b29f72c9a3f4cc34aea7242752bb6523110aafa9a6127557694ff2139dbb24c674215486dfeb140a58e95b80ee0efbb9e966f6cbd8a795d2585a1e7b8b63bb6b49f6e5854d5c7fc7a9e5544f475eb5911333fde3cf0bd578b42b071c76e988fcd8482a18ff1dfac923b586e231be4ea1b2a4853f52d36a1ba588ec208dd52a0a5faf47bf4cb9198876d1d62a1bc000ba0d81d9a0004a6262d6bb815b8625bc75558fb5b44114232bcb997af7cbba5dacca8f2aec0529a7609e0fca151ba062890684f6c4cb09268ce5ce5157cf87e8e9317f254d8102861d381a4815f58fa26bba1f529c244d2bca9c81dfa614b17a0cbfee4895d02f30ea1dd8c2a07288ae253daf13f852027fe3fa65b0f1ca7b0f5f4a797ca748e8846f7dd74df83d4de1ce5d09a4983c891e3a437341bb83be6b37c8026213967ed28e7bcbc80465ace3b147fb57cebe1304945d4d582ae508f719026ba7b2c058e78a2480d52cfc256c273f83bd14771adedd12b753f9db42ddc899d733f593951efa813d73d79d70f8bbddee53e6d2301d4c9b1acd44f68378fd8184b25e4de926165beb6fcfe29608e6f4de26b95c75de01cc9717ce06ddb998782c6a490eeed6e7ce6ecbbfa86012b1e30a85ec17b8e36bc9098657c7476771d4a8df8fe1d40d9238a48059c9858f6a54bffb6a525d969f96eedd6eb319778b12a35570b7e43e35ef4c973cbd94f49781e448a03966eadb4dd47a1e0a10b54dc1dee9e3b395285cf26d4987c38d2433b3bd8dae8d5ff756bc5682f172d81b3c421748d5abc0001f24e97a672f22ee029fba3d9800ebba874f96fed27b64d646419078a0e39a99d48cc5b6e3e1b35da75f5042bbbd2d286a67c7739455036577a6556c6f2ef818d38437ddd308b7fcbbfce6a64423313ece70bf97320477b36204794ddb02f45041f0b4919ce409d27214957557a605bf8b7a2f07f0df0b64b0a4d2741f360d8507125a3cd619a48af42657f4e63807f3a97aa5963d5117bfb90a0f53ebd49a700f6d410b38b65db5f0eeb27c11223393b9b14134495aba8a986c00ac7be6843137e92db7e17e7d323b302dab8d2a4a5cd9570d8e070769b94b42af6bf154744fa74269b572a674f7ce0d883700a0335bc3888407f868a06305159c7d95d99259361704ae51d8ea79785fb7a9091aebda18a4dc70eab58188f5377c5f559153387098e863358fb8f80cfb4b3ab6558ce0640289099348b58edcf9283a61033dfa66558e880a28799d9f5301ce7600164866c4e0abf922dcb45009eb3447f3f23b11a42043862de7e11678ee9556b330918e828b62a8b05d1d38f1ea7df744171ba14b7b3253982d6e308599ebbd73fc5aa56735f4291437e364dff4ccae3299c2c47be71457fd2467247f9b0ba54a7fab343c8fbcab4c70ff52898885969d61511876a5ea71c9cd18a28de7192c63b7127b6614f92b7b1804efc0b19b4009288f1d41822adf7facfa6b6d1212a89cfefc0855d0a90c48e40fe31a21a756c56b911f296bf324a515ffbecfbee71540a69da08701e6b120e88ad2dc6ffdb3f41935318264fa7a1326e150ec37cdd04ac6c35654d8929f17f23f7e8797a6d43f2fac38198c5866728b47d18f738ab59762ccfc3bd614121669635d7e9b09ede21ada0433d60fe38c1c181471fb70ed3b63073b11ea681396eda0df49a47a4ad257fe4f4fe1708fec3c717516f7a25d1f935ef53b46b1eb101ca36f8c3e5331f6ea9e111d901f12e76443d496b52d3be31aa8f4066af81f481307adb4eb82c13eed7c835b179b58a877eea6280e0eb200ec0e2cbee3102d5c5a610a842e3a163f87c1e056ae9d573508035265eef0b913630e0aaef9803efde9bcd0caa1e52a663bdbab5c355d11bcdab0b371717be5dce78aa0baacb84508f4ae13617a25587f57201208dcac831490c8ea3e577044038ece3b86daecedc6e59a47a4417e1733377058f09926fe0f8521f49d0010ea85ff3c870933b985aad6b5da5ce89fff85d69ba626810f6fdce416e5d1b547eb40e46f33f19e7a8a466684cd48e3f64df7e139b98d9ec3efb97d5198ee276c62f51b29b96f033987efdcaf6f1a363924046adcc061c9cc90c5919abb6dc77e1b6dfb50dcced43284cb8854f51bc68c91825f89d85cb193f6e2bcc8e2ed3e4b3d6a6fbc69290a4368e4f716ae6ada275475f01579af5c200b65c7be2ac399ffc0e751d90eb9878988c08bdb8c7064b6c53520b23c0e9164ed08c7aa4d32c206a831632a6906a75c1fa27f6ce6111f3018d5290a0937b67aeb73b20101da45070542c435887e6cf2004527aa3ce30db9224150d406a117cf3f99e2f4e1c7973fd7c32a690fece174855b3d792f4940519d971eacf699a7be4d7cb16b95e4107db6b36996f6eb35684a1becfca2146696d914c17920c310af3313e28edbaf148fdf46789511ff1ec35b1f1a7d76060bac785576292cb5a732f47912c78ab0d644371793408c794f4e93f25e67de8ce027a2920d3a77fe8427af5816e056c9e48af5894c93ad19e6056dcdee181f6452662b41e67f9bdaf4ad704e4440488ee54427f60f6893d4756f96f60f8b7de0ba47874783913b53fec9b06dd09a00fe615605ee131ea1f8734d237a0f1d292fbc63bc5d9854cb17746d32c8c20062873375ce056bb0aad7e2600f2770395231cf3d5405c1f965bc8d367c574db68740dec34b21c6569e93c77f944e6dd061fef13e36da9396c1c39ce13dd4d78d7377b382994dbaffcc4b22b495db9ec41fd1facf2798c29837469162795ee613c8f0a13d36b00d22beb1f675bb3abdf12f34a13504c518f3400e95b5322d560a704bf02df571ac621314754bc710ad0630298d5e0a57cec5972250588afa584b51a3488835098c81b24163a482f1531f35cd860245919e0a551a2b4cb411a4629fc21ea9928e71d2985d50d3c21edd742446df279b74b3a4a609d302ec53cfc0c53bdf4a4da897a52a60922f17684aab53d63667c5221acc33559112cff9b317d40f71304d1d38bc738c1b5cfb1ba5030822a46f4aab23d5a6d1da62bcc13b30ea3ac805ad3353595025bac2ac90756bd496307c250fb573800d8b3f795fe8ac1819413411737cd89ad2a8539b1863aed85e54701746ea665ec58986ce06b2fd0d05b71b432fb1429f3117bab3c5c7bb7abea6e4a8a33a69755a1eec7ee6c56fb9247a5381774d4788db05950333ce8338b7e8cf833bb1a58551e45e78a531413b12c2344b38e839bb9ee17f1a3d2143866f3bfc425bd0a3945a700529a14903aa14ae1ae5b1d4e723ba0b42c03304e006d6d0e75e81ffb6a3d62bc226465bad3ed368f79e5ba2ce6fad867f81a5ea7fbce27533041c352105d3c554b8dac856e23024295b144f7a2642fdc3a42ac29f4d4f6a9eddb4d4a9baa478036e37973f125e5ec2c07fe002f5cb232d1dc09b0cba8d3f04d7c405d32a51096d34dda3fbba903d7e5258583f7dc7a846dcac441c3b2be6551af550965d640f99b466105ab88426292bec739f1b386edc1a86c4cb85452fb825739550a025e275e7a8602a5d11b5fb6211dce6685c5138a88de54607a25679f23e71e60b576da902c74ed6cfc33cdb608b7c7e477c437d0234f5e9637db958406ed232e5a08c29cb7bb23709c6054fea1d7f9b264c0909d0e515bef7e38e70b3bc5cca649f5bda3c7104e1aeaf1b592dfba106fc3e1c377f3bf733ccd3fd93b47afbb3286be4fdcd24c41b3def6f70f7e3c79397dff7c3d80bcc043cc2aa616eecad56ce46dfdcd7f19f32fdb882c79bc04051d832959554617796e9a06959de57621a4718f845fa6e1b615139d168424387bcd6bbf1eda57fb08bfa7e3f34bc5da2e059ae2daaa8401e0e4244352fd18f8a2cc56088f969d9b24b1523fe4c069c84a8717ce829823ccc70600b3018633c11ffd787328d6abd253c7e9bcc6fb46db19cad09e3477054f6ac9c221e6f645313e6a054ac979eb4c3e398d036c68a91b94f54bd22ef1b39949fd54d2219b5bfba247b36550e13d3e1ffc467aa358d3b69d54b1c276266802db9dbc411fca6b47a1782f79dec713c218cb69782cc39786dd715594ddf0f9d2ceebdd2f45f0a8a329a81c19c701aa37565e1e0f3191fba5252f71c10dd7d39af825f2be13ed5fe163659cd4360406d3ef03721884a41d0f0234589c41cf24741a2ab232608cf05ccea3c6d960178dc129da8dc1cbd9339bf207d3329cc7a196b51b13f5b8ccc16948505ff936c5531e70a82a678182d6d93ebbde39279af9f3b48b00f89f3722fa6b99dea534c8bdcc45be3500cfa9507699d5f656706d9d5556ae65e587e574fee18472e99a026e386414e9c2e2f9dfefb0fa981bcdb38c7df25520a368bcaeffd57158f0a517900d9dac23ddac06ca3189d8a800460fc54c80b0de4e1a2e02b121650c872d2d8783fe3a6c8a9380110d791c6ee0de64a1442517bc48ad55906fcf063872af84faaa2770cb7f168efe4d54ca6f429bbd038f4a6616513d7f494b0ccd6d390b1c1869ebb93527b194b3f4678b89a953c18305dc8ef786133eef51b1c5d4ac3f5a405acecc7d10c0688b9227b1cfdebeaac965348f65c9c93f45fd778d22a776208d55156700e0b1cd815d1f8c388548fad109750f338ee56471612b254ba45ada869f0f4c799c661a92d38dcd6cb9cdf7c84bb4fd3b5073dbe3411306f0e77e048e7916e763be04a318c882e22f78628ab01e7b539867677c286143f1994a13be4c916ae648f6efae91b3e266f798d7f9d798dcefd37da987d80fe19ed5b11718b29bb53b34b3bb79f27e06fc8698d7726c02cea9c2f589d1ac79d7edeba7307f065012eb75603ee205812fc78fd100a922a576ab96cce55603f2e2a4578b81e4ecdf0f50d25dc72697794dc770c84be8521da852b6535608569ee9e74f92853796b5eb9cc384fed76eee8bb6cd60bc37ac48f2f10bafc826e5131d2f2d00e685e974a5ab7a065fdcea22f92271e6616d3f845378df06709855561347664ed2e96845e3cc26c0f4ec2a240e4d0f73695cf9229dfdea618f8a35714b8dd4","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
