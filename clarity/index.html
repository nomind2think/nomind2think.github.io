<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f816df59b68ea42a5947fe16fe0860425afb065670ff358603536c2b10e2120fc5823382b70eb0ccc846fb30063773e56842cd3bf76231db99100b81e79d02fb101e695a6e121e3eb5df12483b63d640893f0b46b53e8f607396c2552278655adaff66fe178fafb3f4c4be55fa54c4551b68887e951fea0b13c00adc3a89423abc178f9ee1417e360ffc76d4b2d6a1cd9ffe93e04bbdf4083b87247cd338a023c7c4f7fd7366b7117541d060a175cc7011efd04a33030843944ae1b205bb7ae71c2118b9a4cd93bc6b4bf39d94bca7f3ee06b559a3467696883eff6077adaba76154a477467d6612c440071a683119f8481b669cabf12e39be508b04aa5743a6c79bebc8505613106aaa576f5737e7259ff127fbc77596e8a3c6ff91e7d907e144842807918100afb10d1394b52b7f8c09a01bb8fe6d92585617b89b4c8779006c5590646106a7b705296d19f0de7eb90e084e1d4176327d3069b6a39c3efd55fc78ce593f81cf83d76443a5e4d8d07b6bf53c67db2dbab3f344cb85a1fa2a74c2476db4744c44fb06926254f6c42fc3a90938caf040647a594276335ad51bab11577d8e8113e946607dcf4b8884a3fa1e815e7e8563661c9538f467c245b6b4f07c872f4f37368ca77f57d3fb7836c19359aab6b952a022bd416890c240d162b0b51c88f63c2c74d367321c2c99a20bd0f29a1236949acbc1d0b5f85a310000236bd6f7394a5b4b68b4b2cf954d9f68d4412bdb2c6caeec6e397a5a9f1a1476b27d2f2d698cd4a08b866ec2ebf516c4b49da831aa588163b1b16177056be59042c99ebe040602dca824a60e930dd85e176649615b2fd250369af2665cee2caa34655df764b74812ebe1f64020e126bc2867a9f47dda76ec86ec86104e8ca0e869711812aa4ef319edd28ed91813100e43549d6ca88391d7e1925e6ada12464ea2869870c4188bc14ccd9670dee155ccd444b6e9fc8413208f3fe0c643acbefaeafc8a907b2919e7ec1718f5225fb4b1fce1011116dea39683251ee2228bc0edf8df1adb0fb476f36fc973bc6cd3f0b87be3da51e61a71cb8f2885a00127a060d2c6ed39266bd31be2cd9e01e37a63786444568a611ab68509904c05b14ff5ea9f9438da26c7a97e519d332fee2531e40676aa6083d6cb40848e8099b47d89c0365b12108b287f85334df3ee4423d983ff8cbf5d5bec0bda3c7aa4a29987ee5243bf690a7e9aa25c1d6ebd2890bdeee4cc7551520e94438d73f21c46edd22c0af6ebb7e956f25ab76fbf74b4b52cdda49c64a240b4760aa367bd74868a37ecb18ee158160b22f88104397d52e94802a1b2c2da25ab875c8f4c9af07447ed41ca97f5ac28c7bec4ab4cc9b1017002935034b68bdeac52d160de655204fa603f1a24021042778a2cd6ed5bd7a19d3a3ac28dd62355739e4a618d7147d84ec8e4c8855410989a26ad0f6094926c284aa515afef1594cb4233b15e2149e589955dc9171509d6deb580863b3edcfdc3a856cbbfcc52a3973fc447ccb4a3acb82c31c1243f0e2502f46aa179bc2d2b83ba410fb1d195fb637278df69ff8343e238e3aa3dd6b118ce65101eed7bc7453445379b1df35d9ada58a82d0eed83fe9045b622a94fbf8333ddf2939040c6fb9aa81e0f172b05305456404548cd805172dbb595705d302b323c2bc8adcce1a56f78856edffb35764cde261d619bc0089f226daf5046a63510cc2b26b03fbbc52e536f583e18ae678108fa820b17674f43bcece707c795697cdd64f2a35882196e76bfaa5c55ff2a4b2d0cd83eea5a392c51b23101241a3534bb097cf5ed6e51a4cc3534429ed91a1d9e8cab20449c7b617c5995cd4ba2d844a108ca0d1aaf0201f76ad9c4972636ad32062aa8bd2bf93a958885885e85c0cd17d0cc71f058c409083868966379c9282d463a049042b131c6d45e77ba76bdcba9a37810762c0bcf07217302e1c8c33da28fce604b74e84dac3b8008e835ad82a79c507fef4401128d4a6f5ee0e92dd23a00a70c9041d1b11bd372f0fd5fd7a86dcee6560b44c79b9ed3d7becd10d8a292117662e8763ce3eb5d692792c5f8dbf3f1158353bfcc12ff2b5f325cbe0a9075a6d8971c5660eb1082f1ab388f2a744ec470730298651c4542942c2f03f131eec84157613558f2c7f54e7e4a8be41f01de6e42fb73544a089eeb059cc4851da16363f614ab2dea767a0a0008783c807c52d18eff639f09d4e9b76f5d2de9929e0de6714ba5eb1173c6b821a70c6f56f6522a5bbfdaaaa0ba40ef293ed0b0659be3b28435a17dfab545f3b0f2abdbd381af7cc405e42ba1bde6b27a24aa7c6686a1a778be5e60e1ac2ece078de32fdd09dfc8e10ada99a2aaa7854b2b283047ef9387a427fd9a5d264aa2482f38a7d13ef654c32becfcb853303c53c2f7ad50cae5137e85a1e3cd825f185d8d2441f40612178373dd07af386866e32c1596a50827748cad28c2e672e04acb8692e0aab6f36b85654473285ac5ae1095fc2438a147eebec5118243302e51a8a515dd798fd9a1cb33fb01474eff04a9d0daa4eb498eb3b727c466e48c94f0df28b2125549e752a81ecad20a037fa52ebdf335050796d60f3a37b3a1ac55e80612ac2a43befc415d7036dd69240f084cb5065fdba9d2a569839f285d4f0e4336beb4d04295b22ddd6c140b485a2ffd318bf8c81646cb362cd3c506b695714c5d3f89a81addeb6199d3237064634cb1aee49357d057a085def191f0dc9792187da70e9259d6a1b6094600dc2499e339d478e87e7ec3d33ad238be1e409d80b1043c05fa664ca5c567365adc4e583f47992a46d3f34c65fe8730cfd6fb24a821a8a8c8438347b2a2d1a44aadfb29b9564395d324cad7cf8c66e7f0a10d0b85ff9c8e804313b4a209aee90ffa8f02657bb9760f33228c57cbdd52f988ea709b3bcab5fe752e4a5cfdfbf982f897a0863c47f3543d9c655f88142e8784e4c227f55a3bb4e151f7500c188231f3a59ea7199d0a835a7b6e0ca6d5b96ba952e9faec61852438d7e278bafd043a6cb6cdd2faa87ebc4c04cde14c726ebf694ec6f9e257090d61d8d280dfe22907e73f6f3654b30091c9f703b9a8932d211c3d0bccee6e3af55770db61aa25d6c94b5b10fc6d036725c55197c5755bb335d9464fc1be761ae412d3dc4a24f86d72c9ae75e7ce5294a800c26f9171cad232b7a47455122223ea2b1c4f0c283010d57ad16905a61af95df5a4bf1382ae197dd982b24c4730c98513e9eb862343ec89555eca193e62791825b41a4e0cbf7814f29a7cca8f6013b37402319112542dd9bb0459f2ba2ea48cef6f1ed008bb0ca03753f1ba5de85139d9880ef352410d8b49ec5e50d7dde072f8813e726cedfdc741dde816e3b7a8854d4b766a0a0970a3a39b35b5197bee45de0f6a8bd7cd5b122e24c5e1b6853d3417375b334e255c47bf3c99f1f91fe629145eb0166c48c0ed86f51d49f8966ea7cc275d74bd1565805bae52b9e31f4e86ff2626f4af74522977a1d86e053538e978485290b1e2773f8834912c525eb08be8d4f44f260c3f0696c74b492ea1778ce00a2dacd720a64845c97e2e02b55f302f3a6dd706d5c55c7acc1d65d79f9f7bb5b085b709423fda2b3cca81fee384f8d2fec38696f40fd99a3ba1e05364a00423b6ff01d998254812b37f6e022c19fd70c8cb25af0d05bd69e5f3127f4dd2a260cf27dcc8f48ee0cf06b337bf4d853d734fe83cff1d52a202e6642f9ebbba37fa745074800147e7242269094350ee7fda10b6d63da50ac91829b51c4332ef522f5d225920d2b6d476dac4f6fd623302d57491fac01a44aa519b85d75ae384c9d26fd5b67e6b8a7836299e91d48ec1600a59e864a72f3d841429d4f0cb117fd015d6663c537db49f47c42450c350db30a98963aab0bfd9f77d50fa0eedbcc787d0f66b2f8dc6d8a846e9e2e8806d38b89d7d89d9feef710a3a4e158dd98d388ff92440786ebe7d0063b66a7435d619347882aaf407c91e69ed46885e50ba694372ebc34d54bb4ae21438f4ee4984990255d5dd84c825b4693976ac800f903fd34ad6ca19374afe5d8dc4d0683c9a76fdbc3340adad313da28bd6aa41aea4dc97b1850dca435ab9afb5b89645ef23121b6d47749f46a24e7af724fd5631d2a17a164b468dca42b808e814f7d79c885d51636dcbd20f8dff6dafb191234495c9b13e817369cb4f4850e3b9c64d3b0d82eac2f543835947c5013ae67ce90adc641b7340d349bb33964852da3a9b7bedb3281476862d42915d88781d6c6d0626e0ecdf24c57fdd8c66fbfbec6e7b7aa6ebd55bf75812a0144dd987272aaff1104c69361025af800088f9c94b4f2f9118d52c43f235826a874e134f0d79effe71d14b567d3fc79a1f9ccf1635f1ea87f71d1f8223a2c82eb78c73237e00977633d5bb04b059bcad768773485233a589a9c76aac0a5ce4e8a2d09a0e469cc385f4eee51c8018c462aca19f98f14cd4c9ef551e2c42aaebe2b9bbfc050e8d69b698fa5acce630758771867d3dfe0b78ab65e8be6524ea89850db8a8cca944b5d0782965ee2e2146b4f40ff5d0af7cb9b4538ea6628ffb52b0817522b1808c021ed625778b70848803c43ded12b0f1d11b5074b188f939580f0bbaff517dc5d8e8b2f09af3ba4533de02199c3e62b15f28f039319a577037098d9332bf778ed7738d66c74801a24eb845931c7212cd162e87658af3bca6965e47438b1be88242f709760ebe89e2be18404a5897e40ae2ed6e0af7a28ea27d200c416237921390edeae76eeabc7c5fd97b6c6853354f8c99b8ebcfb05503f70836fce7069976aed3cee77e57159b5dc4e4f19af72bed3005acd5862c2fd3474dad0a0b00724d1e356d614515b06d63691f6c1c6efcac7a175886b53d7a0a8ce9b891d77aa1f6cd453583f4b22357b13d7e36afc1cb78e9591b9d9b0811046c8c842e5c93630af8b8293a92701f77359c6ad94a725802f4746dad5bc59cfab5b288e41ddf056e1c3f15de36d0cee5bf126e9e7645ce0ca1b04f9ea3fd05681a28066865444634b0b0e6fb1360ace5789bb8318f2bb8cba09a1cff4363b707e626a7d4bb3b6cd2c51024607817b2b1c9acd7ada4819ff203a0f0e41f23a217ea13e59c2d022bbbb0f8ffc1ec5fc8a54a1590b501910e137dc171b4d09059ac206c7998b02eb6533b65ae2cd08872854e0b82d6632b92553bc86c330a27fb2901e5d146a37ae56d14f01e72b7cd0c3670e306937a9b152d34fcefc0f4bc917d4ea82c5178b19fd0d8ceb0109680fb170e8d7760c59b121164db31f6a91e895ead7585cdd1d487cf4eaa2a1372cbe54353b5449a1a6770b20852a9eca636dfeeb0c1aca2646e961c83dab0ebd87665e223ff1eb148464b2d0f92cae472933ffda9567b1b5177e4b51d2bcc9fa5b252149acf9d617d024f0b78740aff9c0eedbef02e0bbb403c296aab696cd965020006c243428e5b0557525626afb13263ee0d095804669f34b7aff1165166701218e5b9afc2a38fe63af427eb7e1310c7648de0c1580e0b17c2a45f701afa40dce3e2ec51dea6d692b4a97c53c0cae07163113f83e119171321c92e80b0832edd13349a823f414f3b6d3d07506cf0ed2e365549620cecaceac94d59c87ea16c50cd45b424b7192a27d0404437bdeb969e05e74896d70e870ad0db326480cfc1a5b7a231e76267c4be9483530e431710ab3dce45dab959f8af2736baeb87b906de357c5883ad073d2aa0d4a1ef14f15f28f92167aecdbdbe77d709d40313141d4c071c3259f20a53ff25825c116b5e94a0580b3db131d64b55b16fea6ac589ea40990ea64dd731022582c1eb25534ffe9bd25e77d86079612bd0e566cb8471d7c569d14382ab067cdb165fa2859be4d9c05d60a06585a5209845141677c45f9a1a86aa174b0ce61d708f73ff1e809f7b059b0757f04ab3b54a2576b707e19a713f6ba38088e612811d27362a39e22a5e23df5bc03c880f5931c009393ab345decad3a2a66fa3ac94812104356c97e5c6fa4ae7f6f9215dd1cbb08ec0acb1904a762e98edd7f457943fcbb0b9595c69f0ca1172ff88dd6ca74aabadd5abc32ae0905af77061b21a8fe18ab4b680a6023fc0f9f1730b4fbe4cb9620ddacc52109f18431d8f326abf0a618f43e88d2f9a63f64457c614f66a3a4e55e237d7029fc9f45876cf6eda853cc6b85cbb4b6ec25b9baeb8149f0ea53639fc53bae0c587316350a0d615ec31f7d685807cdfc6214fc9f405e259f8fce8b30aa9af05218a0a16d99b677cd1640eaeb46402c8079b58cf5ee590dcdc9bfbf8996c1b59244cdae5adf5d5484ca7eecd81682511d9e9040e2a72a4ddedd1dfc02a219cd2f68ddc14fc58999ae67f3a305070bcec431e2fd0351c0b41bd47f9d094c331802a66a0361da54a2d838fa67efec155a976a5f43cfa82bf763b182e8966e38d4b7901f37de05a5e01ba2fe8d926225e468906f6989c20ebea85c597c08c8ec9c4a8d10b23e10518b853d944470536cc75e9c3ca8eec56edb51392a3af14bf25d6b7fd8ebe87f09a5fcf93ab5fd56d87d78bd3240851a8d17491966f86e76bd9e8d35253a37169fc9843f5c1496d7f91123a138aec3a8db6ea062fcf93a21a52fe9ecea4fafa609f15d2144d392f24581159a9ac07fce3e356b14a7fc5f13fee3f63d0b8c94fcc4153f117edc72efd89af5ad474e037cc336ffd4711549ad176b1a3947ac64e81be6082c90c6f9443751bf9f311e67de53fd97e122dcf0975eae33d98f71ee0a464a7ace6bbd78eafad4d79bb1bc8a31d16296ab9b1aad891caa3831dd86a5797bc6d0b6275b822076b93d4498f7bc33e4f45c09965f90b8937db60968de34afbb7eeac11effed931444a66813b9e23c43f2349218da1f5525812a7832e7a93b6c3f1683c7b6fc3e10784d15b09d3cbd331098ccfd2de26142ee886cc24728083675ff9601dc19b239c312944a3acf8727e68ad19e8a370778b98eba04661d444038d1ac65a07c1642c4de5518cfababe64d4b3f24a45208ea59cb80523457b4c6bc53a0b8d75d436fdb204ade7b99f4dbc999d094f144a15bf6c7af386d854d013a93c215d5efaec987f4f87900a578ceb954b23a3e032176cd82f45fe7bb8cc0c52648a5e13495b0b1081e6dc0a0f01962829ae8ab68d25aa53201323d2a959c4d4678bd5147c2997b611807cfd99cd107bc7078f45e0d2facd4f294c8e0d6cf8904c1d1125b7552e534b508841c4382a38d449a619b99bd2cf6a57a067f9daad9cc7cc7190c292df3f5f7b385c62c3319077a58aaed956c40da347fc3b8b4f43c42fd5d462e5bf3823e6a9b710c2eb781f9f7fdd0c1b3ab50ac823c1892b6ed067bfcddedbe14eade323f6d13ad5f11681f45bf0a072b524f2a3cf3d9e1aad671069d8e7ae4b31ff7aafed95366ca43dca298ba584416961b48651868608c8faac6a2681d9d966f894b3866b527dfe12d65b016644d851136a6d57a3ede316f3ba50fc4d8d45ad724d6957fdefcb62235f4245270d6445461a422f497aea8fa0582661a0d4a8dd358969aa9df94a8afa080f22bade51c2445cf90456f02317d1125d2fcde0f8f51e659ca7333dc5fb28d74d1041d6205680bfed450db6519ffa32aef472729d7294fd9051b0eec44a7d7cdd2fbabaf2036c10d7a8632ce310051c38b45a4ee141b29c7435715f042e04d7ad5fd343f8ac68e3c03bc9980483ca21d11bae51f37be3a3c166334383379e6a3c29320b9ac69457ea50bdcdfecf196fe1b32e88e6c8ff196571a92eecea15af281e29a1c3389ac9a5f6c6e1915bb8f3ad0370f2d1b533afcbd519080f39474500baa8e7ab9a0998aa6cbe27748d7280caa789829e882e61fa7f9599d0a7503e30cf81b9ed44903e66912f18577cddfe27e1f1c637c35fbeeb3d631da2490f252a1ac8c9132f63119332e57c7794db6329e37adb9a3ad7a8fae714ea73571565cd77f67f18077bd8e04e307ac272312442481fca3880713f78f1c5d6ca2bdb276de392159ce4a223905b96f0e282351fc9a139eea12b5921fe8e9088e55adfb6cfc14dc63b477f70f2bc941d00124c319730d1a5d5aca1e18b1f44a9f489952d6bf67e21f3440630d5a94bbecd5315f33b8b9aa3790cea7c1dc6fc9a5b30c885c6ca0d1e21e99c79c88c919179872b39d6cfa5378c7c25ff210f541b19448ce2f001240498bed7dad349d732d235b5dae0c8003c4089c1e3450f4378dad57fc3189ffd7987f6962ed81ceb706494527de6191ca9e283a9a35d6269d962dd5f5e6e3903bcb0f77800b2cf55adc8ad31197927365ab09bfe924fe7777593f024b2e847c2accc9fd545ac4374282819ec650d13d67c960b6796b837323f07c0563b6c6ef291251d6b122670b6692e2e800e442e200a5a73b193062b6902ada9a976b4ffcb19f56e16af51bfa3265056409c6ec9e517435a89f50780775400dfa52f86fff40e240982124b509c671902e338a8050d3f23af81d63d0d475c93afa25c156f5f3ad8bf3bca84c0e6195107b3dfc7a377705e3b4033c36e6ff8085468ad23f7c272df15caaa33c976b45bb17806317faae49c138f62fd9f178b5ce2ce9a3cf3502db7f4db68564453cde1cffb0da001d62c2c838993622149c5afe5092a4e18c7c2c6c167b1c584e146621bbf189aac197cf93e613351f73cfff4de723674710afec1287322c82d1e1eb47b8f47b7cad526bfbd591c4462a2b415b39ac0853f1618a7531e8da5b24218c2fe7cd24ce37d53279b5dd81e48883fd8a3f955bec8831e1122c0f791e4a7bccf5c6408a104f4b49eea6a0b37f0a8d783f8c8faea44d3e49da1458005800cecaf13f22b87b6255b4dcaf8c62620497854bff3b7969d0150564bd3d28932356b0310e3957d6b246be4c21b8b55b7a27bdb2e2a0eb517519ca3ea152bcbc700cd002c6e17415ec1dbef80e5ae78b87476fa61b959e02b26bcc2c8ba5f0535ade24087aaafbbbff117dfde94b3be93280e873aa7b5b5fd2babe2bc02f4563fb24f2419e96e36e2c1e5e1239684e9cf800e9387da01dd2d7b4b6cb85eb9ac0ae576358a7506df1bc6e1142bbc343af48e7c79269834e962c4618c9588778fbc83019aee3870626def529f6cf89369cbedfde9a10112cc5d3eab7d2093f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
