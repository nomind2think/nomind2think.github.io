<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a38d179d4257d7f7f13530608b92b019e6d7fb7a4aa2dd731b6ce771ddf0b1f3ed43fe166e7fc85cb8c004b0c055d645c567d03c89eb186a3a3d21b312da324612dc5ccdaed826182cbabeb17987c5db713e7ea18eb0fdc837cf8b381cab2ed641e313dd31a3761322e0c9641b99502743f6fea7c7769932f7915a754167950efde6941ffd8baa0ef19785c5df304cc1c0b3b86f67f39b02986437d882686393e3811f7e0217143ddb7f3f7583efee2fe57c9e2884633310e1fb4c1ce780454f5644d45a5d8a2601547003523dcdeacedfbce7b401012ac96b36c3b1b063aba51f98b90184808abefb49d07eaa5396310ae5cf77d55679271145f46d00535624c45a1530be63c37912816329ecb280d239ddc816172411689ce4341bf79758f607858be405f7bdf709c9f15a12d1c87a55dd25f38659141d18a872dd86cd0be8f755ac7aeb24d7fb489bec1c53c7ffac3708196592b14547b810bad9b3634e12cd181f2dafbe304c8234e1f8f31187b86674f26627a26681af2a5308e4cd22bff0d9bc7c5b2839d215b65a7471afe53b49974bba1ebfcd944ba61e9e571b95d5f1be7c4263edc3c594746cf5fffa565e808c23cd48f19c43baa2b7c23daee53a0d8915b1316d542ac225730ac53301e6f91272b38c673fbf0bc607b1fc89b3cbef2f0fa13aa2b4c4d87a24ce55b5b17258592f0f2d95585ad7ff3ac0715972b5a1cfed4d12c79bbd394a6c8d3a223eb1173a67bba861ab5e1dff9dd6c124b80aeaacebf7b58d0bdc0e763b83bfc7143e37fe690773420b9840d910a515704af87a5513c9784d808df132ae6adf1d5dc6e9c1465ad51927979e1eac860a41e6ab48a3418e76e179d009ea7cb741f7080173677c4340627fa079bd86e016a2c0058bf51aec1795061c5615346874db785f03f77ccf827baf63e44ec8eb59b6dc559f7e9ddcf45daf8275f735ffdafa7a31d53acd45d24e70f972a88928a4c2679d1f7f85dc13622ce2adc6500b17ea885f11816cfed51396df95179824a764bed11e74b3f23f8d0c007359f929fa3dea70c01455d3bc99ee4ac1abe660550538de089baf54c38225e9241714f6e9282788e2c1f14d7792aef2576983ea05a76786b88ce447fc5f2a59585a5a83f5ea6cca5843c29df5caedf2c06f1bfc6fdd04ed24c857462e0beb4e8b1c3f898bea94820b89f085be930dbb47d19f9831c7c4135dc193810976853228aff463395e04e1be9699d6c8cc2a798aee394153d980cc4d91f244b3c94b589293c32a5ddd5601cf53b665b2b05c7ee3ba696dbdbfae179b291d6ab3abe759455f6e9badaeef2eb41454bf9b605416652298efd6c3eba8f7089a4aec9c1d97e95f42fca90d8f8fd43ae3e5210b5ea5ccec44d23dfcd737d55fc10b4862c8df37fee8452d6c18fae1f6e6f50bf431d6eef8bb540894f4163c5ddea42dca3d116cc19f1001f8adaa18cdc310f847ad7c1a813fcea581b1c8dfa740148ab3ca2f23821f4b343884af42bf54030e6a84ef615ca9ba4f395959b420be8b030b5d44b5ec299d1cb32f4f7a49f914c703498de5ebbcaf299d620ec3ef1b556444aab032b35a1e967da02b043cd38ddff0ac43ba08338d345f2bc14be6b4d4863ab5653a0f2aed243a7ad835f45c6c7e2de793e32c114640a60a4b1381400ddd46e8c8d242cf8303001f8c695e21bb393230aab101a5d60b26b2d799f930d98c6bc1aae0b97b5011336b2d61dcf182bbf45317151af5f4b6aecae28c19410fd35f284467e41f328a84ffae48d01642bd30b6962ffb7ac5fe81c0190e3cf75fa6714a2f6182a0132273738ec5019fe56c0d971162a6ae3f3d0102e5a5da6abbba8d052bd338320ae05ed5dacc8904d6a65c871c2dbe55f2242cf45127584ef8b8257ad46f4dddcbd9f6b0b31a2a208f879ff56be607a81ad33f7dbf04e10a5e5409c31615222dad3f5b45148172d31f348de4b00eab9a7f23dd17450252aeecebb46c1712eb194b47ad2423475e97faa05b227b74a145a1ba9f729fce6a6955ad8a4cec4041cac732a769ff1af95db4f13fbf603687f2692ee9c6032b1946f5e80206b36fd76b1623b187cbe250a779d4a58b106b70966862b8a1a5fa9d547363223f8d72aec9a32bde8579f01da5fc909b30cd4c0a9bea1743ae8ed0584275b269ba3eb74f483a5998d04409a9883430bf248df080df8dace6da2cb2ddd1bb6ce913a0c16e97eb5199335e010d52fc5008d94f7ffaaad829718ba19d1d647f0e2bd8b5d06cd4f441a898a32acc7046178841ab4f5463aab522dc0c55a5faab1c1813dd81c2ce236c534a71028fa2ece9d72f1d2647a7e32b5d314fbd505984a8723c2c8c87c30015d358355dd0fdec91d35edab4e8a6aa5cf26cddd46688f521bc0ce51ce2b59528e9d76be63919d1aa7de4f86e43fe84ce0e119b6b81042a6e4a18416f62bd27195fc5d32af1ada08eb00a73e8d0664e0195a5615750a6fbd0ec538575663aaccefed56b9094222f04a1d777839eeec414901f2253508bbb4793d87891176c4b0444107a177f84dfb97cbb52fc2aab45e186e09d58f311222c7754eabde62cc4f6fd02e93e323118fa3dca7720f227433fa334e72433db0c1736f3c7eee283e5a6840dd284b0b842c18c11206eae0dbc847e3c787da68be3f74c5c80ae43768733ad70b70c6dcdd86777800a35788b938c798ca4e93fa74dbc107a78f4b5a15b90925c60828ddc836d4a0722fc1320fc11974ddd751b8a3487addea4559e6867d3ac3c3655a7c79f5a40364283c3fcb287af34514b6a06d6040f6d0b378fe2fcd5c56fde8dade1d848d06865c6732bd5414382dd911a1f5daf4426b4004f821599d61c029cea6e382102ca090ac310f4bc0084f2788a38974cf091c27f02468cf1dfdfff69d8bea9b1a406fedf43b890c35731e0363e102106b103b1c40bf70fa5f1063db6390046750a60d7248c86fac07370deb41e2a1ae040bb99952147b291016c15d513f5351486cd5733429f746a174dfdef54fd788911364f5bb2763366441b38cbfc1f918af04b104c47d6846c0c8f9536335c951346c94ffa4d33802fcbd39a66b8c0fd36b53fa1e5bcb8d50884955a215ec1e22c22f9280549025fcee3165bfa11cb15330f02ca3a443ca1265b9feaa91bfe09000d662a8b4dc91beaae85f28508e45a81fe4e32bd1cf4b3a68b8c562801d884f2488f1dc02d4ce8050bcb5cc128ed85978dcec03d3b5bfd1f1c245d67b4edeab6ad971e237629c9febb9c08a8b3327021f81d036836c84d3dced9f0f01deb005f61f10ea7a57087a947bd9ee16e9a3e3e0b6a2b7cddb728ba6b5e27ed6c9c8a9657782680e23e99df58bab995f063679d9757e749b38a45a84b1d641e8fbe003dd1906ac77f214e8e6e5ea6079ebeedef1ad33fad8775a1d1debf95dcee6f2c2fba67e79cc241a91941c96791942b914bbdc3557332e0dbc0eebaa724b620918b37f71ef75953f7502bcf7278630d0ef67458164b52296ef22d9f910f1a4a66af9d9ca55843b9ed8f51787e254bd92d441d28166e4fb1dee2574709610f75f663ba30fd611d03c7c018fbaa7559b8baa755a9b800ebce36f53044daff92dc7f1de83834fec5d571695115d2e715981fa8ad5079ed922175823e588fa98fd1a0aa52248fafadbb430efbf0f36118f732c0ce99849dfe16983f44e53abea4f5289d4b485cda5739d998b43715591091470495845b4c5a89cf780b30f8629a504396c1aac6cb91a11b9d80a9fffc5f24954c5b04b6744738948b5fef9157ee81a0bf93fa1ed4bfe03ba20d6478088796b796267a417f1123d4c5232472ea4c5473636a671532625184124a459eb53aab524786a1556e82a89440d4e979b551b916b4d72c8529339cef8c2b84a0d5a824b17443a45c97ce95bb857bc2de87bfe50957d25041bbe6daae9df855a4009f67837d688866053f662d587767ba949ed188d516d80a6231607ba4becb7109f3c12d0c6fed29e073756f3fefcedfdf30fe8600bbd61c8e2a946cc5f6d2f139839c430aebfbbce1bb5e978d3a70fe7feba0236f86fc3c72c96490a5a0eb3b9d134b4415e10e79789d768cddefec05478ba20db4acc3556def9dc6d9d0db283021162edcb18d22a5d03372bf9a110d202e30129e33e63667fe222bb19e63d1efadd634b5faadbb1df71ff9a7ebae479150a027ed393e2cff648ecd4abf7039548177b9decbd21a237ab0423ebace336e73540d31ffac316d9a074c4cb29b9a5bae3ebd5ad39d5465f50a0418f06fab286c6070dd1b9fea28d5d803640ab90c6d0f855251b06bfc28ef6aaf5d23c6df0453ff3d994d0800afea61666fbcc8e055ea391939518b63a031e27545e47905c07b786c0668820174a6a0710793242a34669d4e4f8e04ed4ddbbe31c0ce4bf5ee190e6780ec79d88c0e600963db428b469bcc8caff34597ca56961b5cdded91879187060291a74604410e8fb69c81a6c9d55f170f828266f2a0c0d1f3082ef0736dd50d2ea8cafc6f4f3d96bb8418daae15a962a641d2f0b74e7b10a145e3434f239f04aa0b2ee4ab4eb1ca98d903a501acffef8daf654e2c77ddbf175aa850f9ed06220b3243ec2247b7fbf3b80a7f85136e9246a0075d56786eaa58ca816ce48f433d4d97c5d1bf38ac1a2f64295ac60fa2c3eb8d07da1f0fda5d748506190e7c829c03e8071e133b34ba62747139721aca0a1e51071dbbbe96a2f62896528d4f92c290e1d3084d0c5bc871aa559f2b5a4ae478dd6ef74b2b883b1630ee4c13a179379742f7ffacceabe186484cf0211fbb707979f1c41b9cdbe7e4e72c3abfc61f6b6b6ee7bffb25cdff31856c16a2eaa68eb01eeb131b3b45e987aecec35204539adafd63f9801228940f7d76e2390534469122a46e4ee49d5b5e3673d81d8074a92400f8f0ddd14254fea397aff6f2287dd0d05ed6cfc89ba4ddfa4edc12019c301ac52dc4095766cf1a7db591bf80ff6f36b414f7fadee4e49b150659544856ead8eb7a462addcc17a24d1f958c0b9f0627431b0a2dfd0e422221e8614f35c41c1b483b4a9c26b02d9b009cbefc7e84f0b0453998a4e8f3a3d00e20cb97ba407763fcdbf19a45c2a93e5bb49988b5ff2a1d9a492fe619130f85b1162b907c52af656603f4c13b6eb99c00ff4f08340ead5e00dfb8c599f29f266f5b35171c0b956a57a1db53fde79cc490023bd33cc75f9cdd9c343ed925bc81fddf04c90f01d98a2d1cad312e619edcc208846bcf1a150d0eef72b7fc54abb124396b6b4735781ec3176e8177418acf4ddbcf70ab586a2e42e9b6c38d7161a8546b04926f51ea6d79cfbe4986ad308f18660ae9f8e4961baab6770137b2018d2135a296f8ac744a7a76e3a5f7f20ce95f5e47fc88cd7e63157524e257380887dae548e52e26479b640ebc273edb0b3fe1568b3a0e6318f9b5f9d8869074f98d7e5c8e6eb2f303c9a2117f1d9184240cec89e07856598b6820a2204231e50affd0b04e43a8aa4ea8dd60f7c58a2d5dbf4e873a4881ed85d72bed06ffa1cd728dcb912e2bf61a41c4da369a758ef9df4db946ea6f66d9f0faec2b0951afdd754b1c5e747ffece01395100b884cda43e9f024e64c83804d11eff01d68b5a5cdd76b588c257630bdae969b9da3de4691b7bfb88c80ec5e09096f004dbca1759b98a7a495d964630d6be361e1f8fa4be81eae3eb9e37c91f136a527e02f65474fa03cebc0be5eda55d946f2ba320c4575413d9f03b769b706de0d52d92e5818bd45ddfa36235f7224e1edec948fc1a8bec56f49b9d457dab18288ea5d3941eb14c14fdb6fc991883a3b8d29ac88ef5d7b8e77bc54fe75077cd9b5489ae12b7e768e588fdd5aa95e77308ecc4ca2c4c1c6cb804afa1119d6b2b65d63c05df4b9a14b3b5a0618bcb3838d1723a22e9b758ebdc86f962f71279b31d67382740d012e085dc0b6e90502bddb953e65f24bd27c38b2b61a0c512dc8765e0e3f0f00aab59f6307fd8c61a77819f3a43e20beeaa52565614c472e31187b7010a84d90df2d46ca793645bb0c117b36316bd6d5a1000378bac44e63625128d79cf02dcb7bca8731f07375f5b22f450de690bb0bbc5fd020b2266f06a6ea3b70ae37bf34ccb2665efac0f91d4ec796307324c2b3999242f21a605a8edd6d2e1453efbd91b28003ba6394cbe189c696ac53b86b5ce4029c019bf2b73020ad80eb76aec8652c253918e8d8ba85553fd529c3e9f6c1e6c68337c27d0f5c7b6bc9872266b9ed86a9cc48d04eb57a030e523df75378135cc4f029bd86057aa1a70cad0f5576f3cc578ee382e940f47d4d89ad1a0e023bbe80ea9dcd1fd15fd5e49b1699048639b29d1ee8ce23d1810c8292c3eca33a07dd8e6fdc5e7e1e585fdb3a5e64f9083906247917b7921a9526ea5733897491c9e61a8f137871b9c76988ab83666bfa3fa09259c21b511d4a4b611c852c19e5b7a9cafdb5ba53965ea53b60d61c2d59f3fe842cf6c7a5ab7048d3f78781c9df89e105e9cb85bdd7a2fed95359e4bac38b4bbd86000cc2190c9e362f2cefbff3efccab9ebf6a5632adabe374a12c6c8ad0946313fcb3eaea56e94a19f434f815145aba820b748334c00572bc5ff3f02cc2ba8da8c839b06ef69c589c5914cd6847cde9540c2f60d59ccbca076a5a647d179b91a5f95c28107e8a0ee4209c8dc4c7a535054913b69f52e043957f3bad0e312777df8c5846426af77a44d606a9c3940694f033f109d5fb3ead7e77184bbd761a2cea8407903d7799855c6df050d73f5eda3eec194a1202426a936d1a74fe08ad5754331cdcc703e75bf1e7ccb48ae0106a4ad969d14c6d7263b1247a39c5504d469c0f026aad1e3bd7d7aaee7af24fa57985314a499dcab70da8c6fdddfbde3dd422b6020b87a004404944a57a90ea23d6bef5c52c21d4a006f52a990a4f23426befb6cf84497020d835569ae0248c5542acc60212b0b00107debfe5927cecf4d3080d4bd2cdbf8a5995b67b3ec5f2198da741019cc23dbf9ae7a12cd3a4fed9e3829c38f099980b7727a5edbe5a415ac74e33a3883517b621eeff7a1c92c3b013b733a83c351b80627b54a9ca5351636e08b907f078a9b7dec0720a15f704d8902f7b683bf4e8f263bc2f1bb4d7ef368be3a865f1f47dbf3d2ce86922dc5a7b3f5063e52d55ea3a9252e17fdc34071f4d137def35856acea25eda36c0dc1495b5ae55855a64b4303da7beed2671b14c6a88f2452fcb8980ef7ee4e14269245bf7a0a8ee8fd5191d3654c03fb24a28b5e9d7d38d9b6b7ed2a9eab5384322d3bae7cfd54343c12b225ec647e0d2c29b9428dc73f86eac592b0428b8d7e328544c3a432b3233d9468e43aede6e589b251a71b7305338247ee08e5e5fbbcae48be2a495ab98e27736e91a6af27d3663d3c49c7dc15e78705c9b2c45ae9b35c1d95d7ccd37d0bb036eea74b78f1ead46a97e32fde49d43e41ddace40535887df72a43a369cb3d312c7aa133ef2c6d92bde6f450c0f5df2c0175576f8f4a9f07e07b19811510fe0c9a04842550c534defce63ad569dde6ad8290630d1df3a50d6b9044b7b9b7b621211bf64d0a049331a37ed753527c2b69d76bf2ef0bede6f9a2aa24b1b35c6b8087c4794c7e33d32c1658a551b50a41dd32a7697080c581a3d183c688ad32d1f1ca5966442e7da2e0071981b0df68d3c5e5abf0d0ce81f932c39ece990edba228b101a859e89b63a523a48304bcfc62d77080abafd1e39eb3a2d5aecbc630da8f5edb39194ded65a9e0a96586b281a40e09861bc4b7fb6d8d430593a893816b8fded28af5e61dffbd55e551cd59435fd156d3e30665609a815aefba9cbe1d780c7862b9d131c926c3993edb580173a83452a65865efad45f316ca1b87bbc377929ccc27ade5bb8e6d3cd6c8dbbc02068050a414673eeaaad54fe4c5d6c8a68456d9b378fafc5315b9491e4637db02121ea7c82a38b725975f4df9b9dca1f2a787384484c9d865b9ed79b13970fd485a0dc7803bcacb2b04b06a07758f7b6746fafd5d6c45ce77c7be3e1ee900a7651330864973a972598e7483fec1ebd664e845edb2af78ca9babac99a4e1c61cc87c5f962863a251f54103d708eefe2c84e3b93d1f3fe749064e9c5dcbbffbf7ee99d17df87e265bc1e23f6774a7568fd600d292647e90a6a0f9688eedb29708ccde8abcb2a6fd5f296c332e2b0096821fc8a82462c27f83c3548c109532920fc0d0462e3d1e97157f593737c18303de04565a9b8eadd2759b92574e1f2277068f8f6281ab156c96b0088f650fd3b8671feaedc080c78454d9d0cf3c1f0718d4d47df00a7d925c8f3b50f5fda2bd323c9964c69145c8296ad7ce0cf4dd8d09ba81d47c1d89fe1127f6007d4582763b3c9bc8949e24f3c82859982692aa8144b717ee735208cdf9340ad207919e7192a0f8ce4e50c94fb0dd29a4f333a9b81e9c5c59f5b7255a183c002a9219648c9d3e6a0ebf79c3e3cd9518424723ba9fac82d752c85585cca9bbc9ebf1a3fc3a21bc899605f63da066f187f7ce3671b4c4736abc7657c2801a43a0892e926a0488f0e3965b0848a30a267a09f21aef7444ec7b3e02e0a399cffcf723fe53b6fa009ae3b2fca9513b66f983476408c519e70da8231f6bf6fcda1d39641eed7557fccad9711a24495079b30d408abaa31b1b5475b89a913bfffa2efca83c06c02bf8a29fbc7aa2e47d40d235dd27fa69112ac85e39dd24cc104b65bf92eedcd5d241fbce798e4edc41f524010fe0c3a25c6b26a63f4ceb08c8b691daf3038f6b913c833ee2766fad5876595f43a8dd1ef8415bda7f6de84fdad003e7776ab9c240e5530e5b8dd5eee8208453aac8ac0876446ce119e614ecd3bc93518b2e726e2b84c9eeb4043331dae34a5cb46f6f1cf9982845d01eeab8b39440ecda7c43547b5eebc8c66958c8244b07ca3faca5a4670f99904d6acc6f6240128a093e5c1944f790b2a13c9cfc8aef7f67dc364c7a3719a5fb727e6df63a64fc36eb725274641b902f60851a3402dd59f81ac8e9561e0d72e8c64776af10a7ba0e679f746f6731dfcdc647864b49cb9c1dbcdf31576939857cd62ba07c1b16df0fea3c7203ba4044558c402585e74444c7880b77e6e4b58c9d4224cd6779046cf489cbc68ccb1500d6db297c10a32d4c9e8f04522b35ddda59c07d191554c46e46974364318bba72009c53ab4884c0182b4df70e841d562745db4490dcb008f0a24989abe3cb77bd6125551268460f9c807098d1991863817198e4dcd86b1d2c4c7a25ba6381c8d29e069218f8cc39dba356834442bb4dc0df0c2ddd05c98547454d6fec72fe6bd192e51690bc91d1a54a1ea6314a8301580c2d64552a6fd99f4bb29c797b42a973f2d4cda02c6de2ba8672ca12e22d3555f4f85dc4a210ace9df4b619982ef0b543b3ebaa790e35d6bf95c883ed44052f76b67fc330d6812376405061e0d29133a7eddc820eb5e2b244fd6c91067ba78a3bb28207b1af7599e538c5f0804bec911a7ef27892550fe85997a339305b7f371d8357b07888b759f368fae0476ce4f7711b13400635aa5f53122bb756a78f77ddcfe91030d3fc74d74585ebe05b35f30e4804687b97915c9e2fdc03f44cbc17a4de865b454300ff9cf43a8f845d4e2405a04a1a57521433845e67c2f484b2ae16c1b085f80f4a31876799ed85d5b21204ac549067417d8632ef7efac7829f9745c90d9518264d9e10013340feb9aab6afd915ef77e59fa6aeb89dd4f61a77c573e7fa86cce68db08c74418c582e3bcd5e10095816d60d13a477beaeb944635d9b8b4a35e1fdfa042cef73ddd542a52c4d543039b9c9a4eaeb6470aecde639987890f83d5c742309bd2b677af88880e00cc827f574aaa47c9223693036c43d7aa89e3485e2a8573a9643c16d9c3b59d1e8c2996f26111ebe4be9e3f15196cbcabc5a6906cc52fbd3b382f86cd35546d254dd94452cac85854cd3041a302570778c3d995f16137ba86343375cdd77a0e7e01cbf807ea37aee97fd9a4c9178ad626d1f92a4afa139bd86a8dec6235e6a1460f93188eb4d22f28a4635e388f56e316cda3230856699651f4e6e8dff28a7e90237bccfd1a14497d187521837d1011b7ac2a5ceb2f80fb109501ec390715ddeb6862e783a7f30878a9a8d1871d6b710e3fe87779d8fb97008d1a241ab240cb113d1be67225e66d4f47e2ab1f6444296a6a5c38ba2b302b57c63d83966ad3107c0c091fdc38f75d35c54b30347ae3c5aeb23fa0adc60bb63b501c112458f1395e3276c94f2f980ef6e36b0658272afe2453237dca0935a704dc6dc5e81c4ed7718138e204eb26ba919a067d01c6a8dffe531d1fa332922eaaf9fa27375326d1a0e54b02d47f06118c54c2417d3532c303e811b1413498037eafe1e787919f95a0a8585f3185dfe6fa290ec31275b3c7dd79ccf7d412664bfdbfd302674691cde211fb233ae4dcb6eb8159247d0e0911da9b1b19879f57e63214815a1ab0636f5c20f5f719b2c09ae90d9fdaad50cbfd05c3c67ead121bea81836d7fa4d7843a049ee60622bbc49c6e0d624f1e06da2d5dbcfd60a542eaa578e4cbd23df98dcab1c1beef49a0a0935ae3b34972b9772678d65b6fba7498a1fcd79e16e4c5db5c7d083d2b43e20ac97b0f793bf03a1f3288a42b0e99df5039e5c04c6a30ea938f9b37aafbab8c5390e79d051dfc138e3486990485b077f6f44b12e54c78ad970dd6778dbe219ebc2152331b12c83349c20ce0ac95716d416a187959cf100e75a11ff96990337201e4c6b7a0df8cead931eaaf11abf6efb40aee555340d67edc12f11184a584de90291e8393cf3e3f6e5fe57e16cbabdf7e5b7572d85671e5e25d84200eb648108ffef902089e91abba4d8a56fe4e37215f71365b444ab11d7c201b7b12d9911b81659dd3e9deaa24943745ac50cc047434c39cf19b03e89e68619a212c7e9b5abcb0bfecf7c9c67f6507fd61060771703f981a45be00f7f32ddd624aaa13bd2f24fb01392492b38e50a277eaeb78814741d145d188e45f51ceb6100344edd9827ba1fe6edb62a6cf6b9c0a1291b3f20b149e8542d1194fdbc9bded082b52f2c14b296d9eab611adbd93087818e552bedad3cf60c2a668eb3d0d5ef047bb29f7d3cfdd8c16415d5625e6485cc1148777f555a3f1a466c1004c36d0732c1579f0e398655a796395a567e0155eaba835be26e540c8c19d560f47dd1476c5c55ebdbab50729aaef0ce4675ab8d4596c670d83ccb6491fc928734cd72d0549ab294527b541cf85a32cb66ac090355c05584047133cd03e1f115f0430593d387eeb14f1b574950d5a726161700f5a891316a0fcb9a31df7220ee7948b492f1006b11b982dab5af2db1a2270d06a449012f5d3b537679aadf81cdfd90442f61369cd96ddc7483e3c0350287f961858dbc83e6fa9aa2882f325fcbeeb4a1a6c128ff96735570dc15c81084794d1af4f3029938f95db31b2c25c73ce44276861f38a4369e9d6fe4b4668db22df1e87d41a808a2abef7d8c4848efd3cdd4c349dd1dcd977312df21e738ceba42a6810840eb8b6205562f3ce1efedf5e80fe1c264324bbb89091eab89ea936cd930c335856c562c230c78a0968b34dee296e273de0fe3a1d48052bfe79246e998e32bfd8725c56a0e644a7d746f03302c0f074fc7093bd6dd8a9cf4fc26d3bad323529b925f6910082f56de41bfd8b24dcbab4a30be4098bcc925c9d3787e1ef4108a3c6069dc5c3a4d7a101258133b93f245eaa446888dd175419bbd73a3a582cba4ffe9b365d45a0481fcb3110ea292cb33ec81e4ee04d8777a59f4881b13f7e8e912bdafd132d224945c700fbc0fdf6f821b26423dc344968f75c4d09d37e45c055fb4038c3d119a590872045762986f1f6848755901b6daf6ec307b626fd70b7ff31a099dffa7ee70edc7d84cc8d609c2384c8f576fae01a6cd54fa1dcbfd2372844235c135036f5ec505afa3004e4cd5f5747011a50fc001849a261187899e3f51ee615e3bf65317039355b3be70b2771e0d73e7d7a9c1424bb8f5244966a8959c2d097944f88c8ea3a476d1c94f57b55c2cc4627a2f4148b857ed8d38f5a9e290ff33f93d0cc862b5df3620d3701de0f0b385767f02fa5bf38c6fa3f6ca35cde1a228e85994883113cfd4c375722f825d978667ca0c470fa9bea728c1702b285992bf7a394d04ad0eaabaacbf8a6d0be978f132623d2d19eb3c40f918c614fe79c1c0d2411012f338f2b102309822449a5ca2f6f328a8420a28de1dfcd69f35b804c847cb9849d0d3f4a2e3b5681f06b94260f87002abcbb5c2c8cf4f8aec6889070a67adceccce249b9e5f7c1448af091ba1e30da2feb34308922c8f52b87a1c3d3e48c2849912f5e7c05a5176c360477a76278ece35b07d764432307bd55175c2212966dbd374d64a91527a9d9fe603f93be2a16c1a21cf5d70352a3d2700fcf4ff1515f3c3c40830ddada8c872d8aa63e5088cc1b421830bf336d15d2545e21ae69e34ec52298cf6d2a0c451f80f468d7a4297bef67fc32c1703246f07de9352e321ec44a8abae499ee1a248642af57b6cd225ae98431af0e32163b6b5185a34ccd782c3b83f3894e72cd0d2b5273245859c0c1bd6786c57991f068db6721b36a56c904fd5ca7de65f3a4bae516623d1e4858ac5598b4aaf279feb0e4aa07514caa4fff32747daae1bf3f29d6ba4a20cfb7b521beb41cae60942df6de54afd45d76c4c4914de02f35c2fd5c2af712eadcde4e40d1d7ce6e39924fe63fa4a23933b727914ca277b75bc2cd130f0146730243a73af97178924aa0da62a889a482c8ad4e2d88253956c50cbe077143219c38f28ee82e726e678df5bd33629f80993f81e8fefd843ad2e0e6dd3c6d980c8b2c69236c0bd0a8495cb0637f7e7a30e32b67e794f2936e6146a2824374f277f1768b8a6ebb2e1330ec477ec854667f2f223772b319040d5a4522ac4e1c3b851906ac20257ca309096c811a3bd7d4055fdfeed9975ca3801bdd2eca8d9a3fca7babf58d3d6af16b6aefd12f89f82cc703c6e6a9200710b51a5ea9d77da13f87a3a7f85743b6af51dad7bfafd38bd63285579cb8ec807958b3d0a8a2118bbc0334d2b013552e4cfda7b24e4fa5e8eda5a2aebea9e92ebccc7b92a0718af37a8b7e475874b02497f90a3b78b92350e82709e4af25b42ff6d2aad67011d6bd306234bfbc22253fe97e4730dd12fa81aa6d875f860d43c9984cf8a9528d73ff12eb81c48eec8303596d4bb195bf1972558637e5fa4417fa22e143fa5a9eab176e320e6da0d0ad77c4581708bb87e6ee30431dc7f791ad4ab5e25bc4a4379686add47913a8a531e6bd7e47206cb1380c36b5fbeaa1d72c8c0a53ebc6f008fdff5ad43f7674218183eb3515e572395f69366f1df6ed03a019fd211bbf1e39bbf9bdede27ba29d2199a71a04f19a5f29fc5b54dfb10a2b2a7654da7b55eddd5216d5b52513fde730cfb26e07788d864276b19b24bbd5f949d6d2be0740ae952632291ac6e75b0f609ad3d9c69578bf686cf5fe24fc2f97259feec301a99687a20e868ee15adc93e326c1fce7d4ca9026b43a7adbcd8c10debf0ae516ef5791cfea474667e8e0a0bd2b10a5def89f38bc29263c5eb659ed42f343ae276163ef02a431ecbf64ea1200bb32ac8f3b68565ed5545e1a1cf66bb43f1ae248a9b8be47310ff334be54fca5d92b73ccac04d82d0f81e44a0dd503ca4a87587f43b7cc53c5d8c86a04d69c14eca1cb2f4fb5055f099b9d8cc9cb02f83fc514d988d3675a2a07f90a2ec636323fe0025dd3ef07bb3f77be8ba508c3d6babc7b0182aac8f555fbb659a64097839893103ac8237925b30d22b01554f49f16386a8cdabc38e1a94d0c8c800877472ecdd313e1e64e07080a7b86c12913bd22b12a1e958547dd9644f8d0e1dc211a98757dde2ec9dab28dc2edf6d0b3d28dfa39558ba53a62b0ef47aacfd579ad19999037c68b6c4079cbf9e0aca203c196bfe2c10c0510ac0a073afc9692fd8b34270b9eaadbe21613f9669b3e33e988ac844cc0867ef8c516b71c49a36a38d89dd823d28cc99b11bc951d8f2b3c5d605cad8463b1bdcdea3de27afbcfd65d3cee7fb4fadecd8c8bb14098c4241377be9e42f65ca438b0001a35f46749656073ff0d9e724887834418ab4227df2b21382630f3088d98dd2858a70a7b8ef6bcb30acae31b58be083064a1b819ebe87539e9053ed3a9d1f7bb35203e419656fb4bf5eea1aad970d7c9fe758a90bedf95bab19ba9b10596f905cb44937b7c8ca07453b424b0a60ef96170658fee0b77b20079b301e1e756a60dded085eda95966a27a9fc27063fcbf5c054b48347dd752a81d015a1109051c170126b335c70722c420cb9434416912e52b748d2926d6c8cfa94d7ddd51555ab6127856ebe9dde3eeeffc1e986a9fe1019facc6088dd52767de53967ce329d2859dd142d7c018df68424f0325d325479ea7aa2521285d07f82ac3e2252c17f93b109b69c36fead2b6c086732a8463254c7452ea640e3cf8c7201a944b78c2004fd547c6636f1bd7f9a548167115cc894292ffab64481674f410962d90b2b8c5254898a92bae39a6d1e57cc5b18bfeb2866853319ce8490c7aed7cf728427427db8ba1faacacf3898005c6a7ddfcb7f9135d92411d4b81840ef6f571f72fcbe1cb0144da282c72a17352ae9b97334935eac3efb2abfab012bc5f64bb11125b035d250088ce1bde45a896157bc1c904b6c9df9e02adfcc65ce57431486cc9e96773e61db9f75a52eb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
