<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1ed485052e662849f3f098a8f957567909b75495ba228cf88c809ce463e6034f82883b29d8ee51d512d05871d83839fd8fe53840fe5a73d7748388f7f74ae0aedf7c26b0dbbfdcb1167175b63f30e0892fd1df2d27d37e623aa111696e85fc596378193dbfdd8f9eb75e9c3cf857bf9451d6e7715030ff4d344f8ba3d2b1a6cd46d99a9fb8c00031594ccf8a28849f44d7b411046c95e5bbd8fed3b3d83c120a1fd0b1d5fae76b34dfa905ec144672308cb27fed732db0a0fce00eefbb2fc79631bbbda4d5d77f79abad07a862a461ca379c01cc5898fa6d9b69dbc870c305b280e7085b262bb75ad3a6eefb4fa92143693e5845283e613d5cd299182abf035ef950d98eea12b5453048097461861273770502b7af8aab9bb93bc8ee918944ec2d9bbd6b0bc1ba8b477ae6e580e05fada0a404410e5c4df7ac32450cd7637eda2ec5cfe63357854c316c8441effc8d7bbf3f9b960e808e8bd6326542ca04cae5b226cfe545c6840121ecf53be92123daf68259d2910544ec49a46962c1fd96b326300f792d49fbaa1467509b11d0d6166749b11cf486cc4024f22da51e77721c20a84aeea18738c832932c64ef57655f645bd1d37b2969ceb231d5108c1c1175064b72ae6c00fab8c41401fd0051cf2e0e26949dd8f6ebd146dcc61aab9d20e2988202e6bb75009b2737df0636ab286bd8208c22be7f8571031a3c6b96b17192d3451b7864e5b6fbc9ab1b117304e797bb812f8285c42ab52b5babe48b4f6cf916e9c19315b707257cbe763a0169a200e5476e8a495612b5bf55908764c83362b64b5ec06e100ed6f2defc2ed5c4fba0ded0b690e71cb92d45389f69852cf866a180b5fa575b3c6444a32bb58e19f2b01f1f430d83f0cfdfa8fdbb23d913197e810940b9a656cf681922027ae203317a5a8dd1084140d089f0460e42bd28dfa3b4fd3c5f964ec178c5e46b9c5c6bf4a7338a318be7c13e96aa374f3814cb2251896eb42c59e4e11d9446aceeffb496f08e268b85064991c3f448f50b0c3ee6d8589f34fcdbf53f182162c0dd5256cd02af4b66019da8ad0c4568809500631415d7543b942382ea331e0e0c192f2926275df40dd30780be197b3f01982619e15d398c843bb56c832a07a16962e4e65ee0616556ad343d26d298906c81c24e5feb36eaf891250881ef7c74dea55981398e8d6125cdd7e885f7955680ec5291be5d71e50a1f60875acf83f500607e6b00d7ded4e3fb6631cfbd9a3fb460b9368ca4ad607d7d51f6250437fd97c15ba04993b4f31433eb1cf0614e274e6d8d43e6bd37961e574f44972b47d9af5b684c3ff7658fdb0771aeb5ce9da845d051ec9104540d87d0062e43734082c5b724b3db8ca475a566c07098aea762516676ea331611ec5d9ba3f88e4253d871ed0641832595dc65de09de5159e5e88e37b3c62264c9b3e376136956190aa9c233e6239e065a781262419748da52bb826d8b65cbb7a339f1565738fbf724049f122633f4b676f70871a6b91b7306161a60b2a5593b5f6cd4307c8af817cebca1761ec08069031144e573e01b19035f212bcd5a008d5bec72774d7555f33940bd3a7b60fdce7f63bac5f32b8773774bf9cf516cef46e036a69bb13f5c9a5df5718cd4d713d57dd85b7b343a45d736d2f20b4d534e6f8f149b762737920f3325f157c0da4d6ff8ae32fc22f75bc63246c0b03523ac6cab238e01a72009c2d93bbef936417e2b5ee5260096678dff1222660c7ac3e093e01939cd1a28d8153aee4c1ab5f0d395bfde9bbcb96e715283824c8da21ffce6940426b199eb746cd7c57165da9deb21d10b6059f4d5f806cdf149976881839c2972f0c9155cc8a2ea913921e4e42bbadd4a41551d066d4cc52705a713f3382cafb4d386de0c5cc4f7893f1c7e4453ca89f6518c6b4f1f6032813e2da7e3efa534817bc1347d27bff21176026aa2faed2dd509e128343316a4579a990fe6fa945361198626cd3c44350ec906912618ae273c4905e1acdca9627300fca623d276a61c024636f5f48dda2f831729bb4cd3d11b5031c0a88537f954f1d56b292bc4126bbb92f200e6a0a46de8e019398c9e682b9dbdd0e82de89dfc3b53ab398b5e405593b35a6689c5dc8775a48d6ba3ef3917189dfd08995322c27193cd7b89c839f56a7e1780f624e1f53abb4e532afaec0ff93faa7ef071a9f621bcbdde6b1d7ed4ba3aec90a3cdaa91be86339af493f2398b3326c64a4629c586a534633117e7571b63d61c2315efbc90c6a221e4ec0ae62c602be080b93008fc1f5a1e041c8b433c0a49243d4cb039ebc2a9e8a2ea635607785fa6a673973b66ae2b49862a07973a3618ba2bc37daad3d070d14bd72bb5d7da6318e5964578647347072093d8048cc919c247233b1c6cb443096ac2f7cef16e98f76796ac54cc692b9588dfa42ad1962675d0a14cd89d777d63d13a47ec6e6c7f8a3c63ca3dab7fa88eb2913adaa4de2d1dc4e1621b4b33b0ef6df20b8c8458b9c58b6385e4466b64a185cf987645d065dba83b61c99bbd797c8606d59e93f6bc4984a985a03780873c99b32b1396eaa942c66a20da6c292af8ff51286d092d21d9df8a05bb2257ff1caaf593743bda3cdee2198aae25688fbcdf31c8ace6f440ebb777ff1f5dcc0c7a325c90c8c3ed374075b75f304cca5138793287dfdb86633c5004833dab5d069dfde43d36eaffa21589c78ab1c5cb5fa1f06c424a59c056ff4f87f754c8ebae422652a92e96eaa165f69d9a2bc48790b8a21746661461c8de489fc4c9356fd9d4c53244fdfe522b465f8b8a4dcffca47eaa7ad03122426c38e486f849ac8bd71d9a1fc9fced59d5f603ddb6e9ad652f0ef3e6ab2b72c9f5cf194484e00f0b61ccedbac90664a588fb42d8f2cb24a7ccd934eef07657d4d052fbb9518d2dbb3bf3c5c99c2ab14e0a9de5733ac956f084ceea71b1ac0cbdeb1a48d734ceaddb8541bc8a22a966853fa6f6f6ba5ce65aaf2038ace1c8f2c4226814b6ffa96bc8dec7a1ba0703e94d0a8f989281a5d63ebe0db1a914df555cf9e7f54fac7de62025460ff231a719586822c7edaccf96022201c3c1770f813882f6244232ac7d9816244865744251e8fe17bb798bc9e65513df5cbc63963fddefcee6e5e44ab02aad576d419ff3538163e07b9735177945af41855a1805e61c1829fcb9f25417dbc88cdd69459fccd1248aa17ffb269b802d807b72bd7b34d6fda4b913fd951d8e660087a2d085369ec1e7d9f45c2a4522c29ab8be4023bf0b2d2aead0c47456ce389b0a6ff587bb50b8b227b726e78f80d3849d6e749c3f9dca229f983f9636267a29372fb418a9c90be668aef876355acebba283c63a62c0d56089e028f823adfd4c6fc0721e4748304bbe47c82bb8f520a3ba56ff5501a56e24905d03c26d284e510e5786824895631c89bd5919ab5109541543197f5b39aeb604d07b123f2b798d854e0e874769150abf0c6f688155625da3c1811159b6174582ff875a082b46a4c0d53c9c0884e0ffd766f07458b6d08d19a8d4bb6c82ec21d58d55998e8c3e5551f5411297e1cbfa1ebfcc54ce58a51b351185289ca3b3c775c06bd57ff659dc3296a2f9c2687db773c0f3ca46ba80ab97e93f6c656efef4469bb6211d1d29e0dcbc1364156994161e5611fc3f72c9095859fe29e98b46712d9e968e7bac63f0234e2077218040fffd918ba10c69f0ee5a42c84610d2d92f3e0983b82ea29fbc6349719e2f6e6fa398ca18e2f13b227901de457810040e6ee28026a00bb8d8f4f6e1df0b789f305aa26266236fa56392020871ab4fe581606a70bc62dcf000208cb38bb24e51992c72e99f386252a7c5378e79618cd41bd9a37787bc9ff836de2944ec9ab89639bf21aa118995b43f6a27cf642e8c642a521027ffd361d0f2204ece3daa86fc9ab6408879474fc9414117c182f81214aa9b7e7f4793347b9d57a8c549db20cd2200a39d05ab563438626cf2719a48df2323c8a89ec6c68cc3c05bff122a970df22a381fd9e737b64bf93ef6930f1cbe461b89153b14be15666b3f7e26fb7b5896b1231d3051de6999afa0c362454b55c53366e76a38aab4ceecc2c65726ec8e9f06f8406820ded8056bfe186a9191b6090e29cbca1f51a134a8192b02f7340eee962f310410fe580605e40dec32502974f761a5f297e6aae44d0e8cdc7d4f2adcf65e566bd9a6e07379aa97aafe540f61015a4c18e9d52e90ac8ba7c8a2dfabc0eafbfe1eb25185b7462c03eb91058c3634f82e83bd80c18a100409b8b2f7db68d610faee152a818dee78fd834c78b861fe540848335a2ec63989b858b45bec0e8b14597f8c77cd541195e7588c071cfbd4bca3121df1d9ea3e5344c1287f568bf574149649024cb7f92f8feb3649f62927d42b0d387b6010981db20034a20b4d4cf06347106e5220fdaed881544deebd126a361a656a01fcf7d729095d1b9e454040238592a1323cd8eeee86fd4e10487b482cacd6651c1a7d399c02bd749ff619d99876a4d29597e35a48c4ed6929c696eae71a8f429cd8dbfdcf35bd31e641eae5421320169bbe63f38211cc8fa31fe0a9f3f9e5482816822f786157a9547ded8536e74b2b87ad1a475c159c8f31f249d1433326fe3f5fd8a770c11a5fd259e53117f701c5da01f61e339e6f8f02a6f06e6b78015251ef8ff47033682ed5f813e8bd27028c1c1b68fd560a710ed372c69d369e3b6665f2c04df70ff81abdfa44f9b83fe921e1e912d9e30493b7d4594411192211c7d919c8fd5ecc5ff73504ef2e451cbeab2ff4fbc7263f2470c7fd254e8815f729b29e69027fe0d0d5abf44528ffe211047067499fe9c87dad584912f665c4bc4835ac726d85b2357d0fac8e28dc33def87f8876dfa4064aa7ea2cb8b49b532f77fc4e1e608386a50136a50cac21aac00cb5d3618ab12809e3dc8d6291f19d87ea9b95f080e960863f94e997d28d567897f02613792996bdb42291e17d7f3b3657a066171f88bc4ae2e16e0d0fada82bfd90496008db422baed35ec73309451527f47e63c51c96e9898c9fa32034c4d8097954a0989a8c4a9d08fb1197b631643b7e6e1d3bbe53838f703077a1962aa6177fd6cf48d1fd35637628f7b94c3cd68e42d512455f4c1a103f624274ae72de627426a7573c2180d3e3f98553a7464f0cb625d53f6b195e3cd3af8c419e72e2cc02fc61bad8ebfcf83dc060381c3021d2b3cd57e252b2b75e0dd49581f98af99fee4f4b5be310ad3331f5780ff0f96557c5160bbff99d4e9c8402cdcf8fef4086ca2487f03a37593f0135abf5142bc5c2f3ad9acdb507c766167477be39fb299c44f03d2f657177c01f262029e3b428f2beb79c9c99052b8e988f6a09d390a82da168bd660e8bf1e29db4973dab2adab7276dbe5ea4b3e8648c02b1e7007f2b96508f89528ca9ebc01e499b9faff55c478703129f496d4965de39ab7269efa454e8b23fb0b05219b44e8706f508b31d27d76ec3d9b7342d46bf9b750972e5c300a54be1da98959467b0e51c034716469c5f12eebd7ccc34d456ede272c388471a15cdf64d08c35cd204cb558c15a69cf4868a05366f03519e22fe50fdbf687ebb6f74ee95066dcd3cb48b2458bc8595ade32cb6c12c0a0cd9bc1c1722b94a8830c8a8c64ed30ccaf0b587e56de3b4152e07f6f501a286639c8c38c3d4d6d4ee6a6d274d1be6c8d814ad534f5f1be279c246fef8152cc7c4648de53742407ca0f215a287a4753a6552d54cc66b25229ff0164d09208d648165aa35dde54212d960ac4e8a62e7e5526cb931bce8440d1e61521faf94d671615416e60c466f694d0f963251e68b805666686345a520a1f846ad7170951f8c360af58693bee364b0e9887689ae6980a57f1f36d56123d8d7fe1daf7f2a648b2a2427480670c146a722e009645db17110cd00da6bf803e32ffc859ac5f7b61bc907489e959841ad864e0fc38c8c4ea6c47f323f74ed45e7ba631afa225236f56521826fc3ab86c48593c459db04a17e2d2fabf675fe20bc1ca733934f2051796ea0399891453b2be8cddd8928d0e96f29f9ef30ffa2455b43fa40f2982785c298180e529059030639c8c27ae90740217ce3df1106f7312812420c6fe0714f69e7aaa5830bf8dafe6fb638dfb30e5417e7b5b1daa1fb985a4903e8356daac95b8cf7b605260632baf4e41c2eb6d89a4d63af8414a09d41eddfc458bfd9ffa5d6fba2c12d1498bedd97501e359b92f8f84a5599826596daf571738767be412bf7c029dab9ae0193aaeca67356897f6106b8eec5a068b47edf3c132292c1ac8de930f3a314bcfad0cbbef0a8732bc86ee9ce74dfd31592966bdfe4de52db2fcd6ad517d4633be7764f36c1f0579a3cc005a4afeb668627f2467652017c08412989d6d1cafd7dc286ed0f3836e0a7536e90dc67499d9017294d823bec6337a66b4778ce52e2c519a36f41b184a8062233f66cd654ae74e500907e862617427e187abeaed559d3af7c4411a2895deb4b2061dbc222fff43e2abdb47410f67bb08f3994e736c924d963fb3e289b35d5b4047874da16178cfd94f7f54100b1b253ec9c10bdcb35736b9f07d3aacf3f71cb31b22e071bc437115ec78718d8c06ef342d38d65d33de737967c87512a5605331459aa455355f51db5b2728b3f0ebae1305b7d6666296839b5f3141359714ef13a518ea30c56a5e95b805b414bb2a93723bbc2dad27f4651431a13a62780872c55cc675f59a1973181e368d7729da25a74387446105593338558cfdbb766d453395c89f1a87d00361df1b7d6fc8a5238fbac6443256c0bb8acd34cd8c6fcfc9583832e8011cdc24327b7301cd41fe9886731b5cbdbc9541f8586ddcd490f965afe5bf2c981faf642d77f8ce93e031fbceee83358510e954d06bfd84c6d7c36f34d51036993340503e6dcf2f5df8de54fc551e1acd5df1141c7c4de83768fe8f8c47f100317d09e8dd4e84507012d322b880708d05aee45db048773310f56e918a1e273100f8243386e53acf89cc696898edd3d55e7c6200afe41acf21aa91abffc6bf35b8ed174db9c31d93d9921ab3e6986407416293237354d742583f62c245491b829f904d0713772db6565b91254f79ea6a75a1197392d9e7aed03e9aa493e404f24239da4e5b4398ffcbbc8a175d05c862aa3ab95defcdf4043e8f15a5b072d16865f79d68c4f49b0eccf237d4636920c7fc691227bd9e5c9e5b05d3212e56eef43cfaf6e6ed1c47d097a7b2ad642d2e0a33238bebdd43055fa853c965489aff293e8442e2eddd9b00a1060e582267068984e1b176e253f4630e75120e3c820fda2bc263bea71823b1017d7d0afff66d3e0cc7be388ba7b59c9e2d6298c15f18cfccb7736179cacc4ccd864a1a3a5142f37d814dc9d8d8c019a551b7fd0e354b1d7d738ebd8d62e6e61a4bc8964f94904812d64fda27e51bd39afdb5522400ab2b373b02ffc0757c630be0ffefc5f70c44a48f7670dae51a7b3e7783e850dae706680850659ebe6a824da3c38a8349d52754ec391799a5eb0f623f70e810c8f3fc10f32d9ed63f582037b7567649ad0c363b2f8def1f5e6649d800e4d8d703896a8aefda96b8f2887733bb764360560b33bd25af1c99dc6220a9fba8f43fd9f62dbf3d9a42b7e2ad537abedbbee8ad09067c79c5fa5d95a47ab43b241badd33822e68f9d2933293bbdeada836317c2254083152ef37c962d1cd26323c06e011dbae2f1a49229f9a2786f2c6f1c33d70fba7cabf2fe509bf570f91d3f991b5c9f4d626bee46f8e154b32dfd76f18f9fe03fddb8f7e28e77af5a0803105dceae5a46b3acb26d3cc6fb01b9c3af80d946611365c54886d966fd313c198dd9e843ede10c4f360f560a273b2891291bb5778ae5fb011347bc323c22bf683b84eaf4eef276b374a423dc40b764c05ba754ef6677086dc66f7de714fbe5670edc71a6b4eb2702f03ec446003479a206ba838deb06bbe0807bc8ae739a8455a17dcef4e34dc8e216c7b53ff3aaab7b0e2a4ba37d07ba3e5f04d2524060bc3a153fd43025e51262cb460858f7168778ef65d4304c28e8521bfbab753ddd7e29f2893e841ab12618ae0ee9b1a7b440b116ac7394bdf7dadef3695356dfc30f08e6525a868871facdb44958796f362ef2c1d44e4315525034d2666e3b6ffb26841d4fa6e124736e6da583e9e772e141202200dadfa307161f430f7a0a0ab99e2c97c7f3223748fae315964932190255724dee10cb73a68f198184a80380f40d74228fe49cb31541c8f0c6a8e78dd51abbbeda6dbee6af17864affa1fbc8e182317a77ee17a4e39353ef5cb53cc6caae58a638c755b35c1f19a006aadf3559f246734b5af4efdcebe4cecaeaade30cf2f2daf5336550761ffef7edd5c849c977d1785d34c3cb7b4ac03f5c1a5fb21948cbe170e292e70e3233c368d1353d71f557efe92c71e5787d876f42175c9d52cdb24611a54c763f4d7012bb669fc010ffe2b06c27ffa829710ad6a8b3394cd34c3537744d5900e8fba0fda06bb1a0c211f8f547e79af2031444ab19a5226bc5c2730a4f9047fb7a8aa363d90d033cffe10961c67557700ccd844285314604b69b888843d58e37e2058c07abc96c918727b8e56cdcb110decc2c6190c3d8e77b65557cdf2e64f6abefc4f758d5145c2487d4fae5b1c37eab9151bdf0108710b8cba5f319d8f80cab9cec38b6516f567da17b551feacf5952d0ba9e805ac4720992785b23f13634178c3ac8d14fb2337ebc009b0b024e5f34b710c1750e04d97932a7379040ae5dfb5fdf5ed4ee1dfacbdf2ceb7a4b5f9c7ca6d42511696101e3eef000772e9cd24468fa801717899f5f3ed5c30239e95229a808c3735223917586f1f2f3227fa4732877b01658c484713cab22bc4bdd2a1d64972c17b0d4d8881009e7c53668816e59ea3e3c42800243d4532fb7dfc96cae48930c783bfa27b9403a4536bf02b2529119b8fb6b9903b0143bef146f9e3033448da7e0c9fba960308f0b1bb04090c82db8dd70ac506cf9016ca1ef0e0018c0abe092e427cc1f53be57330ba7e6afc781535f27b508b1fd61116ec3edf89cc451111bde61942e084fab8b3bbcbf1b6ff18f922ee10b37e29d8501396dace4f5ef972589ecfffc937596d7ca85","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
