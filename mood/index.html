<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca3804e67f3519e31dccc45fd21044dff8e0e53444b6f7dbc7deea5aa7a4673f0f5e191ba8211c314334aca080c8c65fcd6287371f3d62e2d8a960fd96602d8bc7e8cf8e90c06ed6d59b59165c25e97c445ff07c08bae7e2e8cd4614e529f3b639544b227042957614fa0d08271ee739cb967f33506fea597eac267c954eef40277d9378ed1d17cbafab1d2c56f145cacafefb20e2d9a84f7732a210e7890f05938313f5277ed2eacf6b4a5e2dd8f510c6e1f11681dee7850dae5daade9a9237564d3506d1c50e075dabb7fb8881c22e9a1d26f6eb35b037a81b6757da06704ad3a21d7f57592ce1b6a50bc5ad9e8cfa438d8746dd8056f6f71b1f1bc6fb9b3baf3a770374bc686734a1ae8edbf832d6190490ad97d9ee64d11d521fa35e2e59e5c732ab28a3106fdc60446a789f1462bb10360559bf7ec4fd9bae9573c3b2f251a931b506b005f1b098967844b00fa22e96bcca9c82b865641d4633bd1dd5cb5fd2b79e2680e868091fd4452b132379ccdb1226f9f2df3accaf086143228a9faf6b07723bb8b591cb9e7a2856e647aeca03457c9511f028582272184a0a0877014b722c590c9b7c1d636a16b6792192539e6548d21c772dc9b9915a5230ce820a29132aa65f64121d5bf03b49d288ad2ca77a36e62b6a7472b130511d1854c48277c85863f09a99beeb007caa4a0d1cabece6ce5a794c4a0defa68daf291f66f4d99dcb8fcb580f95cbbdb4887f0bb1f3bc1d83204f46c9179adf9918f1c86841607943189b12d0a4bc7022f4b6651203e9511bdf511f3c281c368851ecdef26a1c5f0645427857a234f493a81691621dead471ec047e064e0786cc7d46f5f759f3d1c7bcbd97e363d146ac4bc3932b0031775fcb8c85e3a297680e9926af8456224cb4728e1a4563385229beae697f51ead9c9b1ff4f69523736311e9a645224c5d466b43f3d618a33f22b19adfd3886c989a600527d8d660bfb35b37690c786518c55ba5f2c534b2a05c4288e13582b119d3c4efbab62386140ff07dcb4dadc9a622a737e3033545e1c9d6a5e0e3db7c38dd1eb88e43d6873954f9ec5861153f68dd3cd9394c34ece3dc291cbc9455f30322ab30e655303cd93a6b17e140f011def158de56c52db4d7a480fded7ba13a19ec44ae0ee14ac731e7cf87a93435a19a50351ebcff9866c380aed86854dd4eb4e90f8ebdbae667b56c0386794f7007ad3de09b1fbef0c18d0f0c8bc0425193fa40968807d31c7fff223b29c341349ff773f77f2715d951c2de8f76171e0d0c56a3901234e3dc3992519ed389ec2b6b8762574056a08e7ea55e15538c0880a7d80f287f4dddfa011ca674b332dcf0b7f3a2f4c65acd5849ebf2159e4990e32fe695a5d3745337dac442390685eb8ea31584e5daa568961f70b9160ef3c06cf35eda43d05b8ee7c38722fad92617b6e0908de200d6522a9271e78891441f8392de78a6df6cff6b3678d1c2f84b78ce65e1ef5f62cc12bf0ca87ee5bf6d2a799d4bd0f5d225a78be37212045b0bb9174fbbfa9238138bdd747fdc4a8fe48cd91d15275d28a1ecacfb680fb63b060565f39d04faf65d8eb1387074e3c17d131059df25fbe90099a607882b14969a516cf56767da44abaae93ce15899b3962ef0bd6512fb1c13417516e02163359bdfa2b1da1b79a134f3033e05dc87f519f2e8d326b84b320767c7f03c9bdf7a31fc68172128b27024cf4eee93ed3b37cb7fa24f52644b993d772173e629f481aa8d1420c7196affdacf87e48848e7edf3ee3779c0e98f1efa8f74f859600a75c41f818d7d5073d46cd6a77841b4759532c5876918e25259eb34a37d2a74572fc41873230133ce84bf0d8eadc3b7a02651e5911f085dc4a1d922448589adf7a44e57e76fd5f5e96c82990cf5a58634d46fd75aa2604cb6ee5e93133f2c93fd15cea41e69417e7b6899fb8dff8c803ad6d7c94b9f1c850bf0da947b6236f2bc20cf87fd034d284bc0d34ce29d3b93506f99e800019d96d3ab31469fd8e3538708a384b0a3fd4c2a507f8522c2d936f981c925a0f532e764b93e0c57a1ccc7034e19b8d27f19320c4b0bf0eb40a291349834f8a2552b930c73f79dc00e1b18d7592b9a7bc114e50123e4ec701421b69eda5712f600d757e85fbc0643acd25c2145e686ffd2eb58390aefde32427dee2cc04a089f0093bf6d094d7bc3bf1b740acabda339108c1af803a954ea26a0f568876da9274e31376b602740ae962b6c8ce2e4679e8dbab7012d4a9c27f587cb720a28a273ae0a30eea242388e9cbcdb1bbdb3f4b8198095f885af8b6b39186c5acf95e6f32751bb2cabd87d396baf218d32c8cf161c517ee65822161166e03c1627fd310194e2cb87add4a10e92cd34e7231195d36f3933c1d7daed0cb2013b48b8bde02bb75e3723bf2da8e6384f3006ae5f9780e9c232909cb2fbe28fe17b1a9a915614122bcd9e0852533b97b08f7dad65c7e621e7ad1e1310ad9ae1718ece1115c4d9b3b92252c61c9814b3c7630a91fe6f4858e250d8bb98c725d5e9b095ef097dd3a7f8972d654e47d8728a6ee1a847831f483fc70de768dea46287794133108882663f069e7f960a024518c2ad26ae586b598be75ae3fb322d94f5661ea85cd30ac26c1a511e088e10b4d2e61a647d73284cc86b8ae7ecbdfb9580eb72f99ea9c065865693025779ebbcd4d1e030bc30f395b4ea82cfb8904906ec222b018c6fd2865f1b961548d7a99c8590570693f9f85bfb0c7e6d5a0bf599b8ab1f8bac767786855e99bf7d8fc036de14a75fe8f5df9e2bd26245910875ad6a469e25fd5624a323292ab555909aabe83b57a67cfd075af880e98c677ceeb3a721b19d0d8d7e59500bacf3e338f936054477f6690a200eb29a54dcf81bf1c41a2caa20c3a2b2ff33ee00f910325941c1b8fbb6458b002d4dcf09d71811f3ee5cffabbbb396932dcf51356ab2c4d4eefdb5256fd3b21e2ffc4703fb07424fd5fc1a6744193f58928157899486e4b44e9fcf4c4047dd90a3be8ba80189070e1680393b90c6feb92ecf8df51244e227c73f7fabb85bcb66aa89456ad72c1095673a64a9c456c888c2574e09ff4cb646a8d4a8639f7517bb2ad8f35cea92ce3921ffa44240dae6ee06b995c32eb3616a3b14547517523e0d5b0c9773d9d7be4f4fba1957f5e486ca35cbb06d0f63bf494a1c60a8964fd2caa7072097b781659f5969a273c0cbcbdeebeec2b29759f80faf9f27fe22b349f64a5f443e77ba8af99b536ba410301bbd9c6c4bd7315c871a1c94703dec2710a40aa35822af849cf47cd09dd62c0428a863bbfc4fdd0160c3db191ca621128c0474279315afd43e12d4bf6d7c7202be9b9e87f0e522a91df3de656a24ed0eb6d8cf0a973161ca1290bdaa6eaa486ecef98787390b95b9123ccb2dc832165687a788fd5a2d862d2d4cce74f6209370451883ece1d87ccb716832c33a196ca9ef82aceef61fc65ad246359621b46f2760e8085e8ebe5805aa223921df2aeabc03d9170075d820f32de7549ca823a321f05730872f75fd401749336d67ee7c620ffcc254329eca1b9660560b8ae6048280cc30ede0142ca00438110e687d2663de38e2c5d70ce8386e627e7d1eb27c70980100bf83b4a48005e6403618899d2cd8316e770ce46331eefb33c34a9ac2f9e44229ad728f6148da5f69343a6823cec01f2a03c5efa7327ad14eb4ffe7ab0861d2587b557049e2c127b320452c7e7d30f04099896b858512dd8ed3183e55fdbf12232aede68e67347f34fa85a45ccf2388f59a546e3eeac50a070feb2522f6aec3d16614414f5dead567241ca51ddbcf72f13b59109ee4c826c8e254ef6b40522c81c0665dc64ef39626577b33e1ad5c578f315ed60e3a7a2d74a590f85840a66b4dabebfe50ed305480445fc77a8acd22577e6b07e55b2575e60faec8d062d0892ccd72b1b4108ef4f4478319dfd09a141d071b7fc4e735ffe7fefdca11fa52bc44194711c14f22622554b9bc15994f93836fe04369367ec8fad02c166942eac281ffc4ca04949331c704efacff1e857a86dfd6bc4cada3b48ae413ab47827e7d3cd4e29351073590cd38d55239680fb33eed642557ab1b1a1bf6e29b1c015b823cd3aa3c2ff51547e3976af564ab8b9d8bb8d619d4719e5f9df38e0c651e2382ead5725ae479744b743c7afda3baecab05788a914cf71c982a41ab8568c0e7270139fc90e808bf7ed91f9f1b0622f75005ec7a319cc83fd821f7a59e7cfed832fd1fc40691e0796de6aed48dacf1e1a912dc204aaac3c7aa89c771d95a6f00f9e1089c60711a5267cf9707ee39008b6a56f35119c71914a014fa34840f87a0d532caad01e966f6e594a7503f53a02e7a02a34c427de7acfc1b4e4b6870151e4e149169673098e6e1854b66932a26a019057c79501f658b225fd27985fa95a09f3608cdfafeff1549264b6563d79b175b9b25be32f4cf10f9257c735735c7e71a16fac015e0a48830c62815a1f619c925f18d06c0cdd99ad27cddbeab662339ad75e66c262f4fe53ff0071d73a1150abfd261373eb95e9e5c439a5192420d2ff4e34c0d2cf35a463c4dee45184dbb249662a87a2586ffb71c035b3c9271fd83959d9cb49c4352ef2bfdc5159f4dd1acd72cd4bea76193e39257a7e465ac5f1bbd763760942e2b5e1bf6cdf476255043ec85e415c541a305ae05f5e123e7825f9d8007856d4c5869bc114846ec3adbededf29deb8b4baf984cb4062ce4def6b5c5060fe39d4f7894ff7cf5d79749abe1685a610bb74f7e0333e5d3226511ae3408cff887611e7f660f083f1093b853b62fdb0fcf7a1061bb08b45ffc8b91eca8211169855fef405a3370916ff5a4cb6f0a6137d74cbfa14d426f95c2984512ae4a99004b13b1e323d3b8d77b4c1eadeecfca9b536434b7d3a8aaa2aa9b6aa3470c979b6f83ffc9b49e875eb65b44eddde58a3253526b910feb0b5c1954c350d4134e0796e9e2b2bd0165b333068079f9f4a455225e236062b92eda2cacce19e0432adb3ff23f9322e692caebfe35c8c037ae25087b6bf4fdcaedd9ab874a50264177fd5c48f4e041922fdd885772a6a6598acd5225723ad9310471d9b5181505cb8b9ae419050959a2b30a428bc49ff05ed8ed9160f63e501b6b4dfe1bdd1414eeaee7af42d50dc6b8e0dee98d5368f2d710869c51f6cc4a61692391cdd819f343f87e509accf5a8b40cfab55a61f5291890b18d4a638cadc3954e46ff82a80465e8cade747c59d872cdb2376ca0fc6aefc8c3abd1650692c982619e61ba504f1d79c12cf7fc0b4d03e0bb81b2815fbfae580ff9a98d4c31bba9a5b302e8389bc40c3ba4cbaa7adc70701685f89f41c75a348a2ffa10ab8064739d73470e977ecef798f4a79ac2a8df528d71147ca84545a9ef94f4a97c442e2a95097b900a478b98f6f0f2cf1fb612cc5812a363cecc3327d81bae7c7ae895ecd7b4502475bee89c2c745059ecba28aa3bc627a30b1c5d52e7f50fd7a87e361dea5b36483d60342a68eb7bcf77fe1be3b6d1a3cd2902d46cbcdfec5ca23fc00a6ec1e9d55766547a554730d39b15165349390532ce8b06bd19d8a44d1401db53a73f0bc887fe1c5a673e24ea0d86ca3212e507a28842fd0be3aa1b4740df4e52f9f079b0a226801e36d6422275b0a0ccfd9df8744e5bae5d2a08a6b5c7070210589f94c2de87e58fb9613dd2591439eb15916bb069316ac4e8c0604484ca9acd49fb1a908e7297d4640e3869cbde41fdd95fa2f5e2efda1d638566604128670267cf791857e7e2958795f82e58ed77164d8e6717f038914e61657a20f12ae7af9304bdd5a17442ed8feb43859113ec98942a645f06c558be84e1ac3de836dc41235b5a6a6791f9aae8729b8bc36b4bc92b05202e3d00bf8791a61e2b52248174cc0f160340d820f2d1819cecdeb5d97c882f44b3e6536153583e6d23a4a26eaef4a0c10b0c412b92266dde2e8e444f75bd235d1812ed29f07a2f61ddeaeb60dc1480156a6956652acc39b153a969007dbdc3100956acc9950a53af015a4e813fde25b6270996b882d60f469e443e8ebdd8458d26ffe5b0b7568ed80f19f11ae5bbb17a634e435ed406a166c3aaf12ceb001726ded8200354dcc186a22ac6e7f39dc6cfb64a671a488100bb4d831b33de0f6482a0ee31ab6b12ef6a6698b6545373e34ded28f7f836b03caa104e9f874dc5c9c660393da4d6bfb1329f96b8b30b9ccdea35f4343c00fb0fbad0769f7dda0dfc86a03a87ea8bbb57b98b1b237797f95df9b6c09aa2e387626015ebdea9a6ba3eea224d377e21f2c64f9eecf94d21d0345c3a87510e5119d1d6fdccdf98345a9af125cfe4faebd3a9499872a05e183b8f571849df63918d87a235225b3bf38711598cfc0a21eff8c4b85cb7f45d33a51aa385fb419371da98b58c475b7173ca9c79b8a3b8df04c35f5ba5f0ddfd34df310e3121980de7a9f1e3f396adc0be82fa9bce9f1097387fdd846d92411b47910fb1d43394ec4e35f6b9032ed527ddbdf0600e4d6094c76c48ebad5b304df29b64a51b87e23bee8181875e5d1a0bae6cc9090a5ec67ee8cf6ff9ad73b9d8cf74f9c330e5ed05cc8909b7af27439ff292a79637be374f2682e08de1fab58913a507049161878dda8d4965c6fafd3804d75d96a621dbeb7dd9d9dea9fb2767506c8078d49611d96a32a6f207a8c0fcc4aa508010921b3ac469a1e8236466a5dc9e035ef9ed056d9da558dd4732e854a2bcf523c8b7b3ad54b6ff67f3673dafd76f07ff5a19829cf7a09b68e495187116270da4a6dfe978ef43c9ec9cf4a9cf030b55fafeb3202a2c151a06d6010eb0e03afd4a01341d69b3c5e707d4bbd0a8f3f72c5384942169352a2d6bc06adecee239898dd3c0024893c5f5e819c3aa63f16e29a4bf4fcb003fc401528572f02b251c78ad460764dbc274f84f300b7e968f7c716882f0a44bbbeefa01395dd9a64f889d6acf627229056705cf0a14458e2aae84751d9f31535859e02b1bccd227875287851ac71c3bb6707aa3892df2266a7d725b04ef92879dfaa31ce11b7ff531988ba22b03dbfa59d4f41a16700e433a1860891bdf177a0310575fa0e0fc3fc7d0836e5a63a4f1a31d877c6fdece68fe888df2e64db7d2149c1a1fc52f76243e2ea3e7182ea02c0896ac64b2d494280e4b41c0f4993548ca16f1111eb4ce4b4a366bb4ad12c0a0adf2af6914bacd11536f76ad93db72fc52083c9e448feec20a221ac534b51ec2b4cc0c4cb8f2942494bb01a2c9e4d80acef42be74682e48408ef1ad33dc4069bbfbe8bdb51855e6bbb0a7d167fd39851f1573ed3a1a13ce26fa7c95b12a5e507009601d9b085d40a93623ca75c9a72c1d638ff344589f0201993d9638b04d6527a5314633e58f797c0a702705c3da4b0327a6452ce47d020afe57ef0a29cc327650a290712dd2cd25867777ec21628737d18c211e73dd2a5a006305c05f352d5ac9303a4e7b21ad30117e819e7bad71eba99f8c1aeb59239caa89cd13e85c5bab9f832349746769ac58d4af4b1063cb2cc511412cc86cde972988707cb05bab4ccb409e25749d76f80b14a12e37ee479328dfb51f2e052fa31fb33e4461a28a71bf6f855e8016fe726a62ed0e6384c7c22e78560de54cc55c5e5ce7b1a94647e3f49639cafb8b07682495ae9ed40b09808bc891a3fad3eab2e2d1f18fe816f9b4c049643ecbbc6240042f0b6a07eed1fb8a66a3c81b122c8ac17e0a37c3cfd16134e541adc6ebfe979659743dd9030efee6c05a6a897a23388757f9684ba4b9654fa40f9ce9c69d1d326421d86ac2f2e2bde3168b0e0739c26ce50b99d1ec59bea386f66d566b0a7b077f20acbe1b8279d36f81cf2cf4ed22a9464edb8f1a5a7e08b3abdfffccada7ea3b9757441236dd11fefbade3b50de12663a4d0576854344bf7c2a772b5069bbd1345b2acae54f0b56201312d870bb9586d27f0356bf3514756465cd968fbc94e3e5aa09a8a3ff4aa4cb0e6cc1c69794064055ee2d8eedb0d12aba04e52e2b10165d09be6894fa0084b732885b76307d07e12bed13cc4c9861ca14897e863b94bf3179ac45503ab19a659cd43bf7b5acd976ca3ed751141de53e73ce98182b071fdb3af2ddf2638c8c60226107c313861295ec65f5b3ffbffffa13cffd65ff04d89bf2b29f6ec4a84c27de11fbf95960380e8671061b156f26ff8b02489fcdd528fa19086df380c62ea83aeab58c6c62ab868fd27b819052efcbf02d6e8c4515ff0e0f91877ff479b498d9fc3fe68987f1e4530eb7338d530b5b83324ecd49e660c47050153b92b851d3d1be3d0edc9cb04f9723de73d6eca33f758eec1db5d4950558cdd98f42573343138c27c96f2d41fc86cc0d196f0160b317c435df6cea35f65e733a339fd2722344b678090ea34700ba9f64df88873e3512d74b0c09bf374277ca78668566d7bfd1c349909d293fa40039c1d31ad3dca71bdaad1fdc5559a3bca608b3c733db5050c5a0ee505f4d0894ed9557943e262c461bc58c8bb18ad8fd89d1fb3e0bf4643dc42fb595e40ec929d8e0270b032b913a0ba4661e6640786582f4b216081edba5589b58824b23918b8806a4893897277b4ae944ace761f9571f06ff6e1a3f4139346cb53f52ca1933782b93a44488d6b495a700ad1492e6739a6d29a970f5decd73b190974d5c759aae2d3f01815520dac2ebf260fb1c611e086bde261f0321a63bad9b9cdb1b23878c5866bd183d6b3ea31e967ca02ffab59d210cce8a85212e54645afe56eb38eae3ee73d76043abbc86a2c8c0df5003062c4542f945fb4768a23eeb8721ee0ef84ce9a42a55d5f8ec1d167cfe1981db9e8101335dd45bab6050973d1f8f5e6e87cde1798279b01261c19846f22aee471ecf693fa44250594ad9eb0ac8766e6793bed69cdcb2ec129a297063a2db860f0fc14769c8b6459822f81c6c74d1a821d773f3599e8270ea9e3c6cd73851fdc6bae2dfc9a96767e80ad86996d7bd5582f3ebbc707db84e2094a6d840ddf738bb3e9196221c21ba6b8e36b187792dae9fa318986fba3e9890520d848824b57eac13710e83edccdc3ef7f798883d328e0d42e831ca4f9573bf96df7a0368be8de8f427c1c3e23eb138d3d3aa58680fbc0259d2b1e44669c5d64bdc107c6dcdcc88beaaa6dee63ae1db4932153a78d397f27d605ee1cf50c3e4a284e6f5af553f2b3ac3655ecd3103d27ab401c37ccf11dd778f29a147c88c9d9c8ee04aebc93135e8f6652ccc3c48660da73082abbc2a65205e04ab84d64ea637b38cc0a3abf810a03aea8a7e65760d921642459b9197f400716efff38e8b361655e194b9d27bad2d17d355400bc21ee56a801df7fe23d05fcb98f0085d6e5afb45bc0b99225858fd9e53e4be7b7e53d3f5519cf4f54c7a8ebd09caa63761b43b11466a4a3745f5734afb652d2290795e6ac42eba48c2a8830dcb2533a65dfdd300b88cf9ca392c090c2850565f2f400952a0cad8279ad0c760a3e9e32fb88704d16fad3e6086fb7e2515ea8a4527b4750639c70b2e002c9a1be5d92b7c0111685eb498a7681aabd23617886a70755be249afebf706c27b7b3591a8bb49bcfbb765ae8edce4d7e4c497196e79681b7d123433d6a563c2aba43480fb0c245de074217e4f0e59c769a7a8c264c340cae63e93af988034ece9d8b272ab42db39a1d900fad2fa4f52e9370e5132535e5e9f4dafcf83a5c5c9280e10580da92e6ea8046a82ba8bc76db4f0eb007c2abc0799458d89db0ece88cda8a3a9eaecfd94d8e6b1990b5d80242546ad0e46e761f7207e10df798f99998f278bd2861e689f4f0fa0866935622ca3050a02aba7eb8a547ece042dbc14ac5e9d9c1667d7e1fc5524ce1340ca75eeea71bebebc8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
