<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e44c19ffe398051944d34ab49c4297462c6f0fca94c4ad5e8b9327b1889fc140fc091be800ab10595413db84d9940406f0ac7dee9497b736d3746c89f0d88fe3ccafddf2e27229ccc99ca5bc02ef773cd5caf8047b350aab063951755d31c82dc873c321307276486fe33016c9e9603339d66d79f834383ef4429948f198e07f51212d5849361c4ea8ffce1139c89bfaa43b5b522d50f5f32ce11c1672d482d1bb3acc29450dbbb6d9c450b4b568787b745ac3fe26ff40713887e4e5ffd9b43392bd3479c0285f672c07ca6b5be57274ce4dda77da3a4c0ccbe7753ac45708784e84e2d8fc56da7915c12fc9268a1a4ba52bfdaf2644701e9377550036416b43ca1618726fca9a24778430e4aaf4533f802ced23a3498648824c240f8b5b35b0134b92dfe20a8466bb74b61964523fddf73e3e54924d6c36af589506410395d9e65369535ca640083a457041d4eb4c451d937a63cd7346dfe714bae90c518d0a876e0b5b71644d440013ab4478eba23ee5dedf0f95d845576227d487afe751e03181293450cf6f29e7f5a1ca4243bfce62b595640ad0b149da39c22c0feec676db10ccef068fb58720c2caf0d9487c40acfc61218d0f2495932ef0708b3ecdbe0657b404d30d07859e730736436ecb64551cf5af25d4774e04698edcf098ca38ebf22bdcabfbd63fd09e62d8b36bb8570cb61d412a258d34025038bc7ea6eb4471cc5c1f07d94f35d18de05f3dc24f52c2f2b30c328e9fdc3d35c09c4278ac0bae089e359ebc1ed1ff59c16c1657214715e1204651924ef3ba24825cfcd949fa61dbf833fe4b2c86f0a320a5a5d6219c0c1d7615c03056717b30ee8e8876169099c8d436fc681f229ec7f7d06d6647598a8fa8d606e29adf50f924a2fbdaa35df27555733e2e225992cf1db98f721b9d148e6e8ef61d58c5fa178bf0fef1162275fd9e5ea757ec77947de0d0a9e222cb3de87c36bd4ca4f28f5205a9bb222b0991e395bfc6f9cd5296931e26c20be006a149d959a10bb7b20871b2ae119182d2d5d2f8eb943cd852ae2643c6791a3b7eefe182aa2147b16f200590e65ccd3dd2e30675e2761be79b5fc99223e4cef1acb479b11b44899a7e81708d59cb27cd18a3e98964a1138a9f47af75ecda27d92a57c45c632e9fb005ed7b30f5eefe09fdf8a71ce87a7d2c9c188739dda5bad540deb6613d6e454a8c79042adbb3c02eac821a4f1df2c22ad9d48902fbdb2fca8a559cbddb2e8ceb232b7d1f0f316f565362af221f8dceda2b2ce88fed3e6b418477ba28dfed81b917ef17583de72821c5880cd7654c6c349d612c5477d9f0b351f747aba55049eec93f2ec4c17e1feb3e1aed3847fc1794a6ef3ccf500dd8d66d1903210c5044dfa50cb80a373fc713034e83859ce46a14dbc2787d615b18925fccfd5d01beadd626d55854b236df79cde1ee012965b8e879118ab26574716593003e6c06a12895c0d7014fa7e97f226e7ecc8a35f7d22b1c303d46e279eeb6aebc625196c9d0b2ce7700556b8b12c5f89b3b580d214a2bc0cb45df3aa32662fb66574845f035dcbd577274866fa6971a6c0167cec83a43dea440176c7c88effa45fac0b29e1532971c0158dea9f3742dab7faf311e93b936ca9e56c223c32370e342a758283b7becbd924620dff6d30bd0f11e0fc170b56bb17df0ce86fda4e3bdc7cc44a0528c0e91710673e1d043915182130b1c6e8d49348b2c3297719a7c676ca20aee15cdfff1a1527ad2eaa4e681eb89f00261949d78fb072913c2f09988040d03f1b8ace38ddbeca8934c6892b49c28bac77897e1c617e6305b3d541bde8a524328ec185e00279ea592f7ce01ea84a0abb29922aa9766d420eca1127638b5e3a0d490b2a40c1abae382a2facf568df5682106bd43a146c7f98557e2e18ed0275864ca6e6850a9005beb138f582d17e8d00b2a4dd40b3ce2d914584ba6ae86943ffcb31d8e5d3e334eda28b058a27840121ae3783fd0d758a1581d9a9d9d9360a5f2ffb1655ba92ce7ff39ade2ff32f692580cb4bdd89391d85bdc63e5e7793a8906cfa83c56cae2f433aefe121263c1194ece4fa970d4232d349d9d4db38a278b002732f3a0e5c0d22120936bb3ff27a09efe9a54378f43c51901346d7f7224f507358273ea91c4337606a2d4b365306d1145cfad3fec719ce9784173679ae2ce12a51530a78b5873872305f7768f3f836cdd7ab71c37b2c88fad8dd4a0850fb7f8bf731b84adf1da836e74280c02dbc96d4957c5b91c0cf138330ef48ae504a56d1191bb7b81b227b71900e3d5c903bd4bf8bc81190f778db26743cf6ac5467279f2d12f60ff138988a6d7044661faafa25551c7d6088f69533edc75562137f9b22366ac14114539701908334d7f94ef4011c3b463d95c403926d9740420facdb7868aeaa721a38c893d943a691ec2c852577dd61c76c260aa2a2b3297d90e5759bab9a7b7e7ac29028b9cf1e0e1642e9bedf4b94177b5f3e59fa24202e32c6fa87ffde3ba5084637c6b98655c767b92a70c2dc268858971ff7c7ac5045473e05bd6d9747fea0501132627ea516ee641beebbd675254f0f35e8e05f46251ea18789ee0e6d9cb7670c6eaacccdce49252795c1cd491c805e9dbb6f5030be13f4d2c86ffffa4d35b37c201be72ba4293ff26552a0e58682d01b90b499de0fc774d80d4f7d41b8cd4721d734aa3094bd77245906eaf9660d48d8b6787a8add206e5354e3465b68bdb29bac1b8ef0e4b106283ce2fe1479defbfb3244f8a2e2335e9720396c22e0f4cfdcd661790df78126d195e20c51b55e16c84aa8b4fa235979b8176781899cffc85cfc8d3bb9de4932a90e162f4d49d0c171ead5e067fd6a33210b55061e2e2c88164b72f46f7de5db669cb0f9069ce02dde989eec5c8815dbfbf05ce2666e2529af4334dacea85ae8e9583ab52bc333837348125101a05a8f30ceb0f56fe333fb12056918508aec303b021111149427735dc76c1586a9d6045082a5ec5f918dc6803ff2849dbe0e4d08963463bde5af291900426062b02588c8a6fc34d1c06235acf70670f1a27114e629685cafa0b3dd3a375d22d4237c00c83f5e8b08cee27b128f351404e5e3ac75720939ba4d502812e0ee82aa2d3f1e90b47ccf72bf53d191d84ca82a58739b97245551542ff25b07301b9b313ec45799bb78475b0c3462eb8374bd2e90b87cccf11221f42a5bab1dbe2983db19dae91d7d58f7ac8078160877a8b15cc5634fb083f21abbed8925076f3900803ab2e3e1df8ec67a54a3525ce0191d7bfa9091f16c0ecd99dfb63f5a07ef9f9063fd79b792d3502e9903d5a7e0525dc373f9246808ffa188d881f52f167d3daa0331faf41946ed77777d64bce4c6b109717654ecf360ae912ec80e42437f51e0350d67543eeed8febc948af9399afe6adaf131081efdbfb92bcaa0b25f873535a05d8bd508056a0da5b3a860c3bca1f7aa9c66358579d2508d3eb0619f7fe3a4fd6c9d1463be6f20eb6b34ec013d60e659c4a2b8f053947f29ffeba763ba43f0cade0e2ad24d985cd2e08944abeee388e361e87390b8eceb21cd8f3fbb3d08870cf9240708e20c7f866ef9c5ad3674740f2ff523004e833e0d113c870b461bb6a49f7e9d5fc7e4283c8273a8c3d263e2a54d54ff637eac896188e62ae4fc62151401c6a463f5ea100399b2260e1783cec2c57936b07c3a4ff04af77f0dcb73e4cf9ac76f6d30d532c58af97c9f5b305e8a10e3cfe8ea89f94bb4a19c4d515fd98f759a4d378ebc0baab8a6ff0f92df42efa1788cf68019713851f770e5324475e12330c2b54a2e35995a580e98d925bf288a2f02296a3a9507d7e45ee4f4970de820fac66774d442d19c0efddee53cbf06ff009a7df2c4f9c5f8edb843755595a4bf88577dd7a0bf1a9f8648587d54d67ea77344b7a8264dc10a84421bc156b48b73056093e6284539b742e44373c3bf362dc801488164614962f0d283f2fb26d578c430bf09864098a8f036fe8b6288b2fc0516b0be7155e27d0e6375afe66db6543d8a579022f67f106640790ab86e41268e011d75e52e7615765eb897d9f55624067584044973524ac7fa078fbc92e7c334d05dbf8c71bd2c890218b136a87dd26b2f1b144aec086ec8c87be946e0e3b6b04b83e38d0d9484536691271b33def353a20cdab3d8ed5cb105e4f58dc7a34b76a96470a4a96f5c41d14e45ff1485ed9a3d6a9a361455039d2219df0d43ee9f274070c96e747db6fb8f180a62d844c76982abf5afdbfbe58becb11f8ca8d02c622bab4d5a1c4d1d41c7562da524ae70f4fa52a50805091a56cee304c2fc7376d326611ef2dc9a7b53975a0ee2c1093d22d89e3e25616b4d34b8559bbc10aea472e4c70e76f5fef081e50e7cd5f239cb69f3acfca55bcbafe4dbe4fa2d94348a7235cfb03995485c845942fb467eec9898e6f5bb6438ea00056e34217afe8c9eb1a8faf15305335360f3267ebc58c02a766d7e7b27358221d84361be2fc1bbb44ebb4c79c630caf88db7f9b85bbd4775352a04c6bfa5b38b38a18711d18855860c60ec6941555cc2a2f75dcef485ebb881d2cd2521c9e46cfbe230d4703abd751a86b8abe65201fa6465b22c3300c04b4185ca8a0f293287fa37c0e3ef3db5cbb6e89ca2e15575bfd90470451daf677b0375db8e20b89538fe01903ec08da7ae7447b2404a22dd5f260b72d9e9599f0e91fc96929c3584816a2678463a811ebb72c74dbef06c0a3bd9c37b04498fd8b4ee8a32c9f5be1eb9844fdf88a032f01304eab54a23f06d4a7bbc9b6e2719408ad056f05af94afe650d4c32e970b91868c4d3465c4c334025b0c628aea8ae9d9b31c14c6d86455776ba3073d4cb54d81c19548a1b5f14537ec46f70be76edccc86595d7b969d1d18e184aa34ff49542c821d5023a14b4327eaf435958fc4c562b5b7153380ca10c5f67701a5926e1047d5522d9fe9cf2c39714bf590885f099bb0f979737a6adcbcd9fd7706ee2efe6d13815466e6306cd44bcf33a1ba0b6f55fd3ffbed3cf9bbc48971ee755056eba979e33a9c3702666feac3cf3cd11c04409fc984d8372f91ea2b32ed0ac34cd7eea242e26780f017718e2274c05640d2e606508bf13003e5657b2959c881725310b6cbd9a824c48792924eecc984115ed38b26a4da4f4a3690fbe470664d7d92bcbdafb64e42fd148854bc0b3f96e7d54ddf1c975425ff2553493f6c97f776eef413eef0d5c1f5877070f12f5ade45329f2dbd16c4963789e2b0950886052dee5f4c06ae1a4130884f6d4695717abdfcced2fe27f5fc8203f4d30f686bdb48ca86ee6bcdcbc3887bb8f9cb6f2c3ffbae8cf3b95019c22c4c051e6114e3277b03ee0f73847c9aa03e7ee36ac22602c0a02690c5504df3f9fa5fd8d5f5a8a9e0ed626b06f3f75161e3665727ab33208489062ab291c03d6e463f62240024d5156537f7e0952ed63174ffbf360ef61e192ce9e30356aa3f3923b6c8bcd49fb90ef6455914e584fe5daa42fa1073af6997a82c43556ae9c6d12ebfa7f2f04c2eea52a9d846ce527fce0a61cc2e33df7a056826672ab9a391ad798a2bbc165df913f72e0f90387d50d4c307ce1af44fb95f61a98ba0e847cb37f3e045a369e6d6c032d7bfaa7e667ec3f667a4fc4d085107ef79d38d0198e195918da3e5be56fcb1640b499dda8a13263e2969b009354e8832900f518778328a38ba4495ec274fd627ec0752284fee1302411d7eaad5be6f9005d0627ad94f93dacc7346363174306c301acbea6016d10d4fe90bf2373dd8279c8f017b6672f748cdd22e54ce5d8052bfde8b42cd459ddfb7b6894f1dddcb28746d9fc20bc8a10fe2ede52fd3924d64e57c10d097aa0376c89d6adb132c02c12d07a56fe9d4708222c3ea93e87838b307e6ea2e1da2c00addfd300690379aef8e8481786c31f435ec53f5fd4f58ca1f602fc4d176c5edbc808bc6b8ff1ffc9bbf1473cfda1aef77b426be77a8aa2a3fa339f58fd2bc128eacbc8c316020cd3a2326e86f07fb860c319b4fef8a8409ed1bca58e913dba677e944fb95ed9ae62832c87f7149d88822a73a1bbb081d066f9ba9242cbffe3e8e8d7c179e0dcac762cf567609ff2509f618c7d70e943e7edbd0f125e54a02a9c1c2e415d38b5bb4dcbcbcf1e90f1153121ccde832b31de127becd23ed764dec512348c411486f34221cc1b0c2dd28301688614683aa250f2c754cd587e9872334cab2057e884ee871534e42ad702f6f80fa2414d5580dcd99b01ba3244e9e8c089108b18f62e7d6fd963304cc8f0c61817006464a57d22ed9f24eb73c6b62ca4cbb836f4593882d0d30d3fe8fec38bfe6f397838967b2d21502698450386dc16fb7dd384574f195cbf4e5f1fa9c882e0e11766646268dd1d5bc21ab098777d78e332e38e31f9c07f1ec5c1bb080547bc2be1d9678405e024285047d3cef1380dc424e263f1e2a7870830af3ea3b0f7d39b795440283e892bac451165488c512b34941492ba1cf1fb892bbbd071270fc7854ef1793cf85990abf82cf763299630c37c698b5029ba8a0ec96c014c9c1ea8185d04bf6e450c77ce2f5bf8a86d1001ffe45296782fe0676a4241f08ece4350b12e60afff53bb04961de34ae182eb2b614807637c3c495291a2c3369ad9b727c88715be09ee45db28447dd1fdd922bfe4fbcb36a38441795c907ed2f33cd23b168c55dec59d16207877c1e94692533670e52f9599520e1ddf51b59360c9be0d6fa40f220347f91330ad623620cfcebe43ba09ad14ed252c79175ba4c6b2199200c4711a5cad999e330786c59e351424e880a5ee42c47d737ce0b79a9cb8a97b094bf5aec2b12bc5c7c9bcd8f731af655d52e0917865aad54b618f120c645f043b6b1a7d95310ae0aa6044eef1535aeac17b6aef3c5ff128e15e42bc42b37e7f42d15c69791b286840abefb11bcfd90edff4f51d6fe14f84bc08b22919a74381a4010056910a89dd2ae72b04f0905f3d2802922d9db516c5b3a7f9d4e363245ac6bbc2a4b0070987170dc6b6fb954f908bbe23a2286e49aba10defcc97b0663bf72b9a07e8e5ff1e0705e96fda1d19eef45a32ecf68bb4628a6ab3ebdcd7f71826b3a81e5129669abab0b479b07bf4f9e5c0dede1ff1d82d9af22ce15f8ab30a825af909bf9275c7d87dca42297b2831b4cfefd41be1ba90bdd951198e70ec502a58306302e6c81bc00f51b89c435010342e022b1a8c38ab51891a8a83d40d28e517779fa248357656b189e861356b3c85686dc3d116088b74050111c578702aa02bf9d290abfcf75282f099b7963f8004c1ad75304c831c33961be46489db00646cdd7e73b885de94eb4999c5e1048c7990c94bbc8c0b2f169a8e7aa736f245cc74bd68f23b4eebb8647edab152252587fd96cd84185657dc673cf40b195676a8b3c16d239069757218f83ebcf0767da82f5a427a75d66e8a834da9ec7aa1e5200d1911fbe2354ad85e4d362daede521a59e75de3068da9d20d1b70378a91154530d3a2107de05c6e756300e42eae440292351406f0f6cd08ecdff4a20d5d3e5c2095058c5ece1f4702122e1c4a5ab873b8d86b2e9936e3f9a1b5cb2ca96669fb33ab7289eef20a8264382c4136b0e9ddb7f1454c1c963565396c5591653e07153bc2a1c8d808395650ffba9d565811ab77c489edcbe15004916b05e124402df63e155aba5743c6372f41cb5bdac8aea35a57c6e1c5d4180526d5244e5ce8b2576b39ba2082b924225ff6fa34d036b28a4a7f8ad8a5b366e68f7e7a9b0e4a00aee966326bdb635a2d93462a4b7c567a74513291dacff646ab12f9b55f2a63fcedb4f5c46af7f622e50d34349559dea40f678eedddf25ffcd642f8d1cb12a739f630850ddb6d0c182f2a9e4b48d1bad3bc76e6e908c6a303c1534784b3a5641de14fff42e9289bdedbbfb1f154723b0748d436a1c0a386941f8d9d6b120e349eaabe5db10609249d0fdc34fa8bb2d90e1d0ddaa2e5edf4c1f1a9856a3b03ee9dded6713d48098f0c9dc77a2b78e6e88e9da15eb3d75118db44c4a4b9e0d5fb4e4c9879ac700c1743c57b8e0619aa7006142fe551d1e89f6a55a0e091556122d5ee6e44972b441eade6d6c36e479aba8db1dec510fb9c2c8df265584953177b3d1e6f1df2c14b4189b292cb52d252ace3a341b00df3148abc4f2683a3ec32e0abcbf09feaca563690f9238263ac6a0037b7a8c4677fa7a182db5d0ec1befb0e76b2215652c3cd5c32557c80dbd14a77858e0eec6951faa6a40de6b7cbeb921dee3a06e6f4fadba80acfc1e9741f675a471e40028e3489777a462e626d2217b748c0e85ed21c70ba272161a0837773bcb5398437977fe65bc42941a755153931a3408e33b64d0c590141498d315bd3d67d7daab02c904913fc97290bda45880fe125cf7ea97080d9fc3ffecaef84873592914b26463f37ab01e67f72fd6a6ba19fa279fb7c3bfd4f1d647b712cc813c7be679525bcb6d07d218acb1adf186e850d312d97f6edf0c5b3b14452368f45d8158190afdac5c32325d0755f40c106f2a171939aac52f2a6bd430f5c38c5c261757849330910abfdd7896506d56ff08f0e1d03a4ec48db5e81b5d087b2a03898f1fd49a3d647696e5b6430cf29fca85209b7479be21eb5225660581d15906da21672bac9b596771043c14996ed76cecbf138f1d34c7f5f20b5c734a78e67202d40534187338d45d9312aeaebdc677d5f4ad5172b64c5adab312d89365c6c0374bb53b3015011667388fb530c9b9e9cfadd25b648352042eceeeaf6a4f31bc598b529d695b5bd1bff9befe8154f25bf360ec215cbcb9c9e0add5fe789afd0b46c15413cb5c15d79f27f10755e308c3b19a8d7911671875482fb0a4c7495b88f1c49fb698670ecd4393f6b2f4c53a7a85c5430a1f5cb7fbc047c5c46a544c42135ff5fdcd0539fc7d1d3b101046787c69f3b985370ef8b066e4d6955f1bdf475df8aefa0f46edc0b592f245382888ace119eb61042af36cfb4f3119977a220676cccac74c2373ee3ff4764ac1a8035d00d462246c736aa5e178b188708078f64980c0d3f621e874128c72cf79ee3f7f1bb5765448a18f3c3874453bd5335607ee2e36240f09d2a35ee44894133dd79ad3ef1934e2a0100a4d3805d327f89cdb9c6891e5f6e7bac2d31d858fcb4921b7128bd2c8c40667f501c0ba0e64c9759694acae859595de650ba895d15aca96bf9532318475e2d403e2adfbf1d6c4ad6524a10d5c1dded0d03cf120a15446e3f8093c6f2f20687ec6e238cf7518fc4a4158ce05e97f4727020d89bf9aa19049caeca0cc9f2d850ed16e589c89583938c69a710b5e1437a4b2770fed8606e5e58c4cbd6e07371b3c5bc65eddc44a0941a7193fffc3429e13b5bdb7631f8604471a8b1fe944794e02eaaac7edd90c4dab9d65a93bab73542110bfb30d97ec2724d9f661e671a02b4cfff4fc01f85f44adb45910248c8e78a25793e49c1fe6730c3b2d1485efd12e5eb8f364286d4d3d1c7911f3e99541d8ae986ba8817547519085a23f17966cc6a21772c6166a6afc7df08b48134492a07113307bb5965b841e15e428bf24e557c9fe0a1a33b4ae92345fa5ecde3a2bb10d6c39dcd36e75620ba5fab609c07695db6e0f1ca8594145724440318c8dbf9f0418c852aa214a7fa81ac9d653cb4ebda84e2963957a6d6e465b5f2289b843d49f05446afb9dafd304a13115d572d241bfe7f5e747ea3e721fc74daa555e1bd7327926f90e48838f35c44c6b4696501582306f42adcc7c2f27b2fd1731df68dbf4f14130dd7039d0842175afffb5e0bca6d9267a7eaad754cfcc765668aa248901b5e67279cafed72e8421ff29c799a2dd8c5b74ce89933165b209026da9c920dfcf556b9b1f17870b6d699ed433829ad137e9a9a7c97032c325f5af6d01e1bda2edf5ec32137411f520dcb865af12769f9c4ec84d9198b7e9129cf1d1765cf9d256ba59670d109a108918a06ad3be613afdd4f0bd265d51565d7e350ae170154e5ce3dfa1d76f8b7a2d7faea987de3f5eec1d8e9d15209ac039a6997c7e5c2938c1537b2302d9df4bc7f73c5b6772f7b20f6470c374cefa3d1a8b2af111cb48ca573019964044f10bc7780881f89a999c496e8772536426ffb466caa7561d8f7da4b9db5a0c176ce9f5b927cd88172ea21a76089db4ad993b112b118cefd5166900a793e69fa2fe20477d77e113647f1fd7162af4c026046250f08bffaeb86afed66fa60f6633319e3276524df023ecf77c49d006e155ec75ce5e508f74760356de06463cf073b8df31df532b873ff188fe9d19c722dc2206071a5d6f7a2f05156d365c9cf5b19a98843aedf57fbd251f269870951366b3e78af00be245c8f256bb6d6a73c9df632dbb4fc40a4cc926f304ea5171bb087735982e6db521ec25d047f181a626a09f37c87d9834d52902eb87fc78cb13c23c3d2650baf6473525d712a274184f26f40d49b82f1da702bb45a4fae45063d05940a56eac06b321b0057f1952b3f75060cf37c3d47b15291c7f799b97823fd5a3b7aecbba4359973d02572f4eda64de71d43b1607a8c44ca4a3f84b300299f2140beb4a64006f06f45e9f0e00660fa298af43ac84f2f48db5d05f447b6e81209caac59b68a3409972928e3cdd4f8fea0d800964e180e47f1323e5d692b4625e1668192261116459e2f7fdfa2d41a6600cf7ae97c17161bd4bceee9ca","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
