<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"605dba35a3d1c848b45636a18edc92626f58c477bda5da018de4c0af3f22543ffabfe30eb6b471f75d92fa13ff9404e15cfd95b249da57640505fbd2b642050c754851ca7a4e77244f7bb329e8555a71237518a4ca5959c0f22dc10867dd5ebb6114a76c7d5eb554d03033d192664905f77d64c9047dbe8790ee140493244e438aa7fedfd9b2c6842ec732696e742d508839300300a760f54de4c5e5ace140b9f4a9de14e6eb9936b958f83463f1a09536c3b79087c2546ba41c888736a265e218fb8c80eeeafa54d4cfd870775cc1aa67cb0dc5eae4dd62a870fbcc2035f02dd3b8553c8d9738b75fec74ea6c6a2160b0c803f287da2b3ff2becb78d24f533b027d282edb4048aa66b31616a6a00e985a146ef7c542bec637b8e70fe9eaa649aede34293d383cdfd1cfd5a09ee0498842fbf5133fcf41f7f1b078a6fabda6a28b5d905be61079003bd7993bdf48cbbb1e7ea64140ae3a8735e58ecedfc46e1e5f6cd177a129c02990bdef924f191ad9017837d614ee4ef780cd4cb534b014160230f41245ea152dad71dfe72f20fba599b30cb8e21819f992ce0b6d7f2d666d18a262b9b1aafde6df5d335a5a8f83f74a1ff2263abf45a9cfeadc6b35256222302264144484e98b11abb9973cf57bb349fd99545b487a2ad97938240021a2e6c96e0ede5a2f0392bdaf844b727aacc88b4d5114900f43a650d114b314232b27751b881af4240f3d29e7a49f306d00d73bdba13e0ca2647a348672f68df9d86857efe671a63ad45eb12103ef0c9728676a59461e0ec1e616de75c9c68562358e4d01db555b879f467cf4b9487e3ebf12e14b51531a7340898e2f7ad8c926b88d727d2c1d31c51b3ab8379b4fc0e4ef42908786ee84d46ca218629520e22fbed5306fc40f7860625e8f8f67ab4f0790b76a3fda28ac007acf5a93fadfcf3913c0fef5b673d75b60769592f769a10d7589f88cc5c736015b4d6a9931101863c16d01831f065b98af3cb65a5cbc4deeea6935e24421b9236e698fea3b5ed198d00787945d5be9db19517c2b8321f66b01e451aceda9356a3f0709eb215b4e0b25afa12eea454750a6c3b0e42cdcc92e6a9a7ea8491b33ac0fda349fb3ffe15cd364bc61db5ccc0d3cece99eed949a42247a8d84d141bcd9af052b3a3ee6e1f835c0d2b3ffc4417c48827b3564349359accbc766cdb082d8594e9af1e34bcfbcf481ee4abc6291a9d22cc1098f101e1f1cbc3cc88738e75b95c69c0c3991e5d6e0ccd41de8f57ef4530e546d29b7f64c7f19a065fc962387e05b003ff83393c007721d9ee12d6690a78338a981cd95372114157f608c1c701fbbbb3ccd17f0a8ef9d3962eac435cf86d0e42ac02870b01333881daa726f2a200a617d9fcde5bd6e94a29bf0526e029fa0f82afa85c8b4c2e9bc452e672ee40233b3f564638109098fdf8962a71798ad0d74b26b2bbb8c9ba9290260b78ed54d2433400aebd56095b3c98c93467cbdebd4b14e7bbace5efaa8a9d372708d6abb084346695339f7868c6a114ab3a9147ba6d42fec2782bbd8f9c5da5b62bee3b56fb39a859c751e902a0850202165027996166cac484bdf9bca6db9d9554be1379cb12e6f840e7ec79852c8be0c9e52961a2ca728e3a00dc6d26906fb7a2e1d80ebdd69268025c77fcaf6b3fb836191a673b51ea72ec1719b948b7831d8170d1af3b5fc9f48fb94a9ded34136f200f5b6a2481a25334e490d47a5632f8c8f7993afdf26c1a2b4e1ea47ae972282a7920637df904a3c4db04eeb6cecaf3911b3f57e1d6a49570fb44798e391e5d13a6bdacdf380aa94d073a11041ad9bcb6cb47d49f9d88b6e11acc10b66b645b4f07af6913d44bdf9decb00df2da9d2c1740b787305b3579b1bf7b72aa771a3efc0ae0c19261841cdfd5b144500b3e8430f62ea808662fa1ff3e5ceb54cadebe127b8119f7fd30739aafc5c47e9e6613ad8f8dd889cab5ebcdf4d5cbea7fdf4e3bc16a37135b82495826908789547cf9dcd63f7b2bbc7fad07d951f9bef43876388aa6a61979ace822aa4de4c8fad9936645967db2aeb727dddd348e06fe01d69ed47fe346af02c2cba17c9914ea0b735bccdfa492ef72727820bef3d3b8cdcaa6ee10092ac2cd62838836922464121081f671800dc33e3f32368a8a7db10a418f48164ef1b7ca67932200d0a44c9f4c62653c0e9fbcfa2a21ffc0d59814ba55d0997762013ac99610d4fa271daf78156d19d5b3dfc59e6e1004aae08bf20c19109181beec01fabb9ac6de83e1e6db4d4de5c3bc0ff7c72b3f223d7333752164febe1cbc3dcdaaba1bc851247501e5cacd25b4c88c7dffd6a55b20cf1f09fbafc4df259dc82d2f9ede4b6037a7107199328a5288363c6336dafc4fb7b100e34b9ca8caa8a5abd3274dad140ee9be440e5e177d3d8911848e83272d06dd442d0d4afe2ae2994e227be33765ac672c516003945927c76df56aedfe284496ab3360f4b418eb57a5a2841ec67afeaafc032d6bb19cf05b22e6ee78908a1517337a7c486516b51ddac3714548e05915629d00db7908f292ba9e511d0760ef8209426162021c0add409b59bbe16fbfac974bbf0eca2d6c9ec4a644bbe6b9327a68d38e10e97c5f44a733127a9c44a6f8c520d7f982b83fec5aa5f3f50a99f12c5e1cc7afc21747860a33c4b37bb1ac52f24b966702a699e94a48e8993e5aebb0309b5c25944f837cb6ff2015a4aaf86fc6f2410e62d12f58cc1672e3c5e69065fe45e94b843027ba03c7a1a36fade373d3c2bf32a4bb1f15477782efec1c6c0e12e68688377d964e46a70c19ba9db158ef0fff7abc46207ea01eb6b3ad445c3fffd47ad9e050c2ec9ca6ed1bde5c20f721010f3faf876bc505d43da2adc47119a3a083eb6046e5db0515c3f840d80a28de8e9c8b907fc6db28783e2285593adc4f8a2c261e84824022e2713e76e2ff3a8a39af1d8b787b46bcf68d6199ba15ade0b9e4a8c63090f73154bfd2589d6e088915c06d32e32096abcd871e49874a4d612d8d61cad78d91fb347818bd231ec4149d6b71337d56ec22a178440b76e8e0c70805ba2be837f6d93a42e2a0dabeb41475f0d1d5c1c6b5c6e113cd85846cb40f11e9447bc2566d78addfc296a773c81242e443dcb6ba2cda0a03e9bf46e340052f6e06bce9515599d7f3634290f8acc1442adb3eaeca94dbe3f2819836ae18bf9110254ea6b4859f2322042182c2add3676871566dfc3fdbd9e26f694aad0b7be4efeef0c62a728004a651d3be6b66082124c23e38f55af004ca29fffff7017cd003a24e6fe03db606674b70c672e2550971dbfc12d72c94779cc2e907e57b320762df5fec9eac8a5bf61741acf76f12b6c64d9c9701243dedaac86715134bc15eec8d9201b2a951e1c705b8815117f92874c6bced090b2ecd3f3886efff224559fc11bf81eb7201a826a4313e873429462fa320661eecef16d64c60c36e04c5fbcfaacedb6b7487715e0710a6e0439af199982574ac4316390e00f99e0df77ca83f29e6f9fa543ffcd1d47d9ec085be72036c2d0ab70427cce0e59326de2f5436ea4c06b9c9807343338304d53cd1e6a298a7fd904d322dcda5383c4b5ed38e160a9b54df921e56cdbac302537a430e8529897398e0a64f01c0cf3ef77f06af85b58a27ba968d1b10721638bc23ed0daa965ba38f5bbc232cc421ae6d10de0d0b945ad2b5e25cc44768a983646b4ab3b862f362022091d1c6d2a24bd00925e7bead9bee8a0781a4cadef80945ddc05cda041ee7064c85e83ba8c4e48e9214a91c159dc6f2ed88e1516aa2174feb92d7d4c19fae02a2909119b036ba5fc5eca4824c3f2dcd88540557e034237e721f6d85e9af54ec97d45abbc89d29cac4e747965e676ef25d28203bc03a527948bbc14fc3d737646b3d6da939baaeb0d117716b78f567c12479fc8a75146423ace920be9ea98c11bca094456aea28271c760a7cfaab524ff598af4dc9fd528ba3088ed01d19014df45e513833ad909fa460964751bbfd97899760e9db0a0230d568b2fdaef53d94e623615bb0b98c3d6bad1c89c216fbc40c03afecb0d1e4f4b03d31d3590dd31c12331992d005ad28d09226a7164f68a1e111797d4fc2d2a6336625c197b7ddc505a77fcf24147fe38f348410f328a033c3f7f04a00c4658ff8a1467ca7d577758178afc19c8f9499033729711c3182a07af10d4165de28542bc6e5fe63c302060b5f4cf37bd82963413470063a262ccce88cb59fafd7db18507f8d93aca93a61b0f33d238ccce9472361308bba80ce2517726e871193c84f4c852307b2ef7198eb104dcc72c6ff752da1634fa2d5b404c9eea949ac55be76b5353adb6a2ffacd7ee697659e69b9f75ebe0cae5c90d1f53c50a9855d2737a2d3328012577195ee720ab126e277f77c2122a355084f81d76c1cf4aa2a6330286354b00a03fc4f4ee129f419f53d0f972da694b552fdbc55ca0a2fa293219f0f63616180bb36c9ca12f20ad8bda3f7c46300d40f5b3b75c27a2b0ddf41e5de6b47c0106b601c3b6f299e7b197c9f438f1e83640c6b58794948e183377ebe7e3bdefe17829b460c21a580e0fd8a51cf9532a5c7c43b853a718769749ef662548f216ba4cb92fcd447ed5adc2e7ee67e7ae32a93ec255afbcd8e5ff902760a3a323586a233f5163244c6f862cf5d38976719cac2a1d53295b8980819b0f8af79c20cb9d3e7224fb15c9718d25cedadd44514fcf0e0d30315a2d4cf4c12e289b3bc23f3c0d99bec546935649e27cca47715afbe891c8091e356572bdb7738f51ece4ca1508007d6cdc1d4203245538dd922302738db56bee95c259815af90dd24ec1e01321fa2fa76b3e97b8415c9e3a8da511126cea69ea1c487e462362a42f66c9462d28386cedd159b38546abf33018ddee31be722469b373b1f3fdf3d5d637255789e9ab950e9f7915b31a29f502b677d9c60c42b17f04fdca408f24be58ef607c048474f8bc3ef19944c12a861fbef3e16627a0f9166f2cfbdbd677ec24c2ff8ee23c9bf59da63be489a3d924e0d249f135d417d4a68a2cba222f59414d0e71add791f24cf8272d6275e27b5c927add6e7bd66e3cb88692662026111e9819a881ab79334b2c45ce37a08708834c6cc0a91d8d1beea054f45972bc8893303ae9e1e9382227daf2d3412eeec0a95292f49224fce4ac2972b71d021e2d2e283b9a5d87933fb4b52bc7110e925d2ee6604d9ce31e0357f22b46268b3d805ed8aec5fba45fedcb5d37f5d6c5dfaf9ad719655690e4e4ac6bc98d1751316d94f6b5d123119efe84dc1065df796f7651444683d74e98c9f4f1bca8ebaade9c7a176ceed55362c50f86c6a9c6ab25c065f6a14588c18dcadea7143c180aa151ed78f971d75ab565b9a827e9ead464282aa042ddffd4fa31d2dfd058c972d49de5a53d3fb310e6dac07501bd8ada8d6f6af7fb87181ed72cecc5d8386bb84e4fa16870ec7860b6ee343e41b23c884ae3715c23ce18778a73b7662d4c2ea64febec793202cccb2da03fd27526083a635e8edb9823f47e555024891e20ac8685fa695f8ccb9e6d7e98ba305f84a1ab7546ccf42d6bb2c3c913b7d94549c907eeceef271f219b4c27fef32959005f94385fed6b9b73939ff9a830e130a99b1df375060f7112d28564614504f56d1c7ade747071a4cb65dac47ae8e07e18ce33a2c0cb72bcb42a5d16ed850f4ca6d2ca4466c4fa343ddb4e51e5d12653f4740eac42256ad73f0b9d796288cca7b81dedee84cf1933fe821fea03a80cae22d23995364530943db0fece74206a835e30ca0e62e146ee7398a436ceaa084af2919e5d4dfc373593399e0234dff8000d36250ff91d3cdf6d93a115b8bc5fab73c7616132adc0749ca165c7f129725ec3e03e4b999cb413d5c67aae07d02ed3556b44c50db79de264bc1a003df3aaa3f683b5ea5eafef0501450b902be8b9c36dea5850253cd82671d2fac065b68c0efc6274c5705598778888117eec6c6b855d7b05e8dffaf8e660126a038bde7035bd50f80bc097c65fea4f6ab6f6804ebeb609306dfe97ea71ad1e87ae5a2858d9e23d726a3494b98085017d34bb77e59960f2ed0627443270d1c38e8c71ff99adc3a32954d693ff057f2423f2a5704b09c7b758c0105495d307e85ab999c779ecd227de9bee9ce50caefad497b220ac087108ee9bba8c3cb00d08961502c1a98f38bafcce9cff8c96ffe583494e6f4978484e78d79e7a803cb8d977e50ebb278222c0a20ff900cc1400fce8fbecedade4a78127dda25ea8fc8e9952b5edffd17e93faa233ab5dc35a3876a6dd652782a1db1b40d27f1f13efeb60065ee588d3308873b8e08c0fe5a1f0198908141de5f1ea9bf8c39008871dbc94937808efc44d459379a0d939fadfab7b3172a701ffeed1eb26a9b6092051d268cb102efa139f0f4d98f67e9e7d00f27d274fafabbb5198b1919bb51e0295ef0d8e60d6b247d270b8a5927adca78d8c70d0ca4c1630381beddb3bec333e100dbe77fcf187a20cb943fd5a53bad48b3df5fa907509dd7a0ebc62ff445a09f153c326dc9407d0d8a2cedbc169014ee39bcaa743dcba5b76cc675efedcf34182b01fa88957a18ba29e6001f1908482c31855f191171ebd7b13381b5b2831dc5622cd61499caa50992eb7ed2cbebd94ca79b53c66707ebe7c282fe4dfbd53c00082332282d4348b9f2f1ea0870582bb9a990df8b11ef568a157eeae301725cc04519079a6ae6f82ace282d025bc336834296a6faf4e83b546564fe49a0c09c47b0e0f93d74cd41497d62faa5cbf4902864c9986ce5a27113abf57991a04df37c6205e11546998fa37aca019ab4af80e3c5c0cb8f713937dc88bc3d2c599115a09b5007279981105cc30bd958198d92b9d33001ce7cb0d7fcf4b40c5b51c5e440863d32dab3e1c5bae9651e15c435a22113cf3a626f22e8f3078b772c243cd2ab8a25e215618aab11134daae3333f15be38e22e3779341084699e5e313a2d0c529f2ea01276de5ef7d5d011417986634157fc4a8ec6115d1a6ff32118ae4945570482752d97ede5c3a61c0f3f7e92c2aaafa368793ee3841e5edda92f759b2907055e7ed8a7d6d4a37db64ed37319066bda26ed2f654d28a67e74eb7a0bb1487407dcd8dc78e1e977a7b5366c99c4dcc4754eded9a8afb13d1ac443568f95a5e0a5b1068ee1686f81aae652fd19ec06c0a01ad6061be1c1c10f4077a5c23436eb02974d549cfce744ed970343f25192187175c655753bc51d39a480eecbf9ae231ba67223388e4ae6de9bc8cddd9ddf22f8d3efdd1628fb7cf4932d83810f751647373a63ea40c444213b08390794d19f585f43bec968351cf7952abb32923a237634c790f28f596c165227219efa492fb2e384223fb15b223155b5010f003c374b2a158029ca62ac59427ecfe30d3a3c3d4019c641baf84051c4c4db2c1b11325c96024f17410c8f971499b8670e9d1122b52d0d17ef7a5d741d9137029c1dd55ea3a1bbf37405a14efc32d4ddb523e53a96c84a5b8da5ed311113a36e784f5815fcd83ea324aee498dc56cdb56b753fe3502fa6b9245a8d897ee24b0377e50e25203ff18a78e30c05e16a5129f1554ef9292ad093b0e6037c4bc3e2c4a67c9109333d9fb9bc01cb1514f33caa9c9d6a4f8bec601277a5795f79f422998acafc272ea0ee8d38c0fcfbc673f13ce6609c630f2669f9922a397ff66260b0db8a9ab81da21c488c70959e994ccb1ad0bcbdfe3e8de77c5a5720e8eccb24a0f063d3474f738e933cdbbce411c6055353c8c22d53fa0d82016df953e9cd1ed773296fd8c707906bf9866bda08956b335278592d98e0d5e07a94eac202ec9ecc6f32c7fac775d3f0a81d5bf32821ae02c60b39cf73ebe057348f9a0d64582e6dcb5cd7e75318be4907b45c720b41c1ce1c3ae5f786dba18f196e62a3d337becee47461789a7da42e2e8d03f8fa5d65e8a416aebf469a62d2781df4a48a6803a5b25c63e29709c6fa8e0c5863c59d9943ef2eaf3945b59b0f89cf8d6885f274c4d7fab2e6b08723a5ae6bf6e836112a5d3465e32271ef4bc1bb05a83348bc8be1d67cb7f7833507c22f0d51a026039128bb5755b0b068ee3368c5ffe026c6abfd38f135705d37639b17bb366510b1685b606c71669ce3c8eb352198c07b406e207765e23d1d2603dcdf66bf245c8adc81e08c752176042965823c19701053c6e7471e7ceb7e7a965b96634c156d18e194109929fdd959625c8cc21dfcceff892eb28eff39cfd16d502e97969ec114d453fb43e19c5227e0dff0d7e5cf432ab3580be164b4ffe574fde1c2b546e77387362c8355fd6b7900bca381d1417208cbf57b9cef9f34768391e3cb3e20459501df66055a0e5eb6c1823d389117511734f03d504dd563c06bc268f7bcbdab79008b577550fb7f04e5a9a284e9ff55f6b9f5b9961d2dbb47ee36b107aea1b3c9150ccf4f47ced806258f17ea8d693060425a97442f7701f777263570082b2f0a711946121060f2ce3ac637869bb22825beaec6c39f74480d2b567de492cd1baafbc4063f9e0b8882bd8df10972a68e4986c7e256893718bc5e20736e4bff30e30796986ace56d33c200cbf96f0d3869fa1382e5e7d47ff9de04edf0d89a7efc462ef3cb33ff69d51639e95ff3793c790f12a57271acce9174e6e70e911da742b15d5e0ead99112d08023d62b049a3de9c21e0017155c3b2f825c5650e84b2f3791571725aedd694b0974746435eeedf9589e9679d09a61dc7df241ef88e80e82b2402645749da643e8db20eee39c3845cd6e3b100643ac69b291e5fddb6acf06aa25f87f3b046c2cb9815af11cca6c0938113696a06635f80228b28d33d49047198149393910fac46bc3fe854938c9c19d18349b50cc7590f9cd4fc89e64bb3ea1eb7c97af527b28bafb537cbeebd6b93711b7a0813a445b90d957ad1c7a914c90a31c80a4febd1ef2f1e00be3fd055b5d512d013dde1844c001806641a7f37447c04fc95f662d8f5dd2d1e49a25e08ce4c672a8f4288b0014cb43c66c89244e0985a1b3996a249209d61922ce6b03eb43fc0e8448d9e8098be782e0b1a39ef11e6d46150d5d189af25bcbae8bb671e9daafa271ca4d8e15c5c53735d5a4fd1cd4ccea2000e9a9602c6806196821d9f88cce79d30d7c59765401978be0b17477fc72b5a0f14de7cb3b8027558d77920c3735df3e05992554e1679e17a9050d6f151b13de14b2a647202237e2c4e2cb57184461ccea4a1750713d5401def2b23ea2e7454cfb933efc186d9d26b41ab6372b7e8a32aba1b50878da0e53a806bbb1a4b8a9945e61a61c4c45ae86c5b87fe7b71c1c883ecc2e8f4a8c28369985a0d476cbecc2b813f4d32fa3e35ed17f6e16a134926a40aecb98015593bd025b2a5473981f8f4cf9a2b55aa628c1bd7c5d23617e8a1c7c6ccf462a9987c82e10cc0ca847f7988fddea4d4895ae649f93fe63017756756b639d4710b1aca64a6fb02753e3815ca42ac46e798784ee238e0301136075ac40d0adb570bf19e87778ef1628932b3c62c49250852554a6f861b74e6b92a1a139a1cd4a211b7e55817c761f6cf8c7e30638a9aaf3255761e8129c7de73a48c4df48d975ae081e5095e800170940b198dfc4367279bfbefc214617b34d4a0efd57e3586243865898af76fde8a42ce37230cf8b7d8e3eeed19557c0a9da707c7e77812d6de114c2f4bcd9a88dd99a4b31545de4a87f62b25cabf514cacbe38ea1264c8355a941e5076e6a40ab8779671d2ee1ad2ae3ff701728bb851443f5021d95b7cefba12e7dc5ad6753a68271c284ec2d4d07655af63658e353e084bfa416b8e5713e1071d97cc1a6b0d90cfdddbe6c192c308cf01cdb0d31781d8622de7eb459365500cda4348a5a81484d186368beb42c050ebb6c060bf60eb267cd4b2a34aeaf96a9b3190ec2e647799f1bbe8cd71e46a7f50dc988335e40578857791a0e38258a2ee02b62fadf9cef96e2d2c07795d73d7e43af3633171683c57685a61d81220cd313443be14f2dc146323ac734828fe325acfb6eb632e9c877c0451c851ba30b3943b2704804fbd4801c997e3c30182365aeafd8410f3772f7ad1e1d728e5aeacadb19651695d776ceb2715e2cf565d97351f314142421711f492f933080a204244d303c4de44a61d44c3bafe937cba676aa57ae134426f645159df5babbddf3a4270fef4b15b2c8170947ab3c92afcaab037bf7a71143080841ba4ceff0a1ddc7076cdb31bfb8a9d0dcfdcfccdb8e51278c3bc933ec8ac5afa580a6985ad7223be44554fb873d24ac0c1e855b53c14006bb24535a3378ca253b610e4c4d6314c28a496be00a727da379a8d3c9280ea528d59e8a022738e8f17d74331253c67bf49aa022121e53c27265e642337ec5500c23f382eae4e120e4af27ef41645c1d72d6ff670929807ccbf6afbce8c06d02e23c58cada25b64d7c8d20010b9d06c49d6a2e85201beac2c2c9033aad5dccbaa465931b556ced67dfdd704acfe8fb0c64a7f68019197715828cb5d1ad1a7b51fe957962cfa6175659a32309385afe817117064996f65728451172fc3305ca46ba4d697686a7e8344d5ce061aae003050d62e7bb056121501f2a75164b599aee2ce52b8dba743d8bf75e21757422fd0815158c78bc526c8c6658dbbb2160a741d6d0ac112f55202baee7a2e339701ac62d0616e2f1e0cd78474fe763131c5ef","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
