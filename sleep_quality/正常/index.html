<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e250fb2029c7253c8608e38570ffcd2ace83870057fd82e01d01fd1bf0a8cf0433aa3201d4652addf1463f91403f9e0566c02259964e9d0a916707b72dfa696bb78a9c425077e1cac83999058208904a80400078cd8e6c3ef55f69fd8c100dfd9ea4f836657d788a01cb916d20d23a1994336083470e9c5bf58fb175c9a82df802471837de53660627ebd5d3e6b38da325757a0fa8437bd88ae30076c6b77f2b6979592102546941c6b2360a853857566d9cc3332c893910154e0242ab57cee5b441d3364e32e47214800a0def037603da82d275bc3df051e5e4d3b1f0e18bc71a688dd8d645d5c702d087e0e09332c7a35650965b72f1b05b3f65312059df676ca7893ba828d04451adc63312aa7702e6eb0ef87dd1a63794cd5e302dd4829350e895a5ee26757fa618fafe832e9141dbd548d7e21b348abde60247e0cf1f5d928193c20a3bef68657a8d00da7f227214b8dff13b65d89f6c2e513b0e295303eae4d3a01350ee70931ad6062b0e56f317f1a7160bc5c528f5f5aca09ac5b6b384792e5e5e0182eeccb902b80aa696107508b64f5e568dee053b54da44a9e8f2ac84e8ca2d10f4881afcf45ddc6f6ff58801d14fab4ddd79693179ec0f546b88981e1d6c1a2bbb33a6718d274a21b11c0bb5c7301a93062e9c00a517e0a16a4c7a7a065fc004ee8848c7cf9057bdef2dc50df01e3a2d7126fd952f35e91fa871aaa3b39b65d7ed15f6bc760f58a972181b122a039e057d3b67547ec06184fe2882bf82f2059e5f97d1adf3ca4e88cb6b29bb676a1f538ad5f8bf70dcb4152fa9c49fda4cb9ee5a063260b8985ad1e05bdb964e05d196887d45e7b38b03a4cae4554b302d41c9691ee29d872122d7b54a5e6161c2011aafa5076b9d5b5b8a9cab336b59ad555212a1ee6fd1baabaf9168610f524245591f2d00de05467597bec018fe1b4611094d884224068610aa95b46103a77678ae685c2d4f57c210cabb6dac2c3799ef8c5e3e8a1ae43904f3ef18d7f4db8deb0d57a30820cadbb4381187ebe738595613456ae26c34686a2488e78b98016a731ecbb1e433824c31c88949a1a3b2819f557f5a41fb023ba51fb54d9c7d0e644cac7af876c28e9b3037a5d0f006b6269e34d5bcdfbc9d1c14d3dd15960891b493c7352a5368583133a825fa0c3700c4014228434e09207b00a5c10bef5fdb8d75ceff141899d9197df9946c71d0bdae20132666a72ad0330965cd73d1b2b6e99f026c9eabb3c49d1c97c064bc8204325c68825e4fc57cc4d7edf6ca7c6dff919711fe0599e6be5f9a624c57e892e6231e2d6312d7a04a3e8f4868a7f6ea79cc3d530af7bf2f0cd1cc6a4f82a316eb8e7456891dd16a399986b12d60f00a6043dbf5fbd8cd885f4cc0938853395dd0897a2a4c8070d8de866553a1101c8b7d4b9c1103e476e9b097f14d864fba595133afc8fdc0de44806f2b3672955c15759ebfa8b2850a6203dc75a376928ef03fd9191fd2e4cc57cd36894d781f936bd4910b9429c1e356bd415b661d965a5d197f20f8c73ae398e2b6c05d157fd6f2b61491f5a786447a94121bfbc0a3583ba34b888e874457f8e0701e9bcaef77913066d778163787884da6b9959322c4894945e642f9d1fc8f0610698314a5ef845443c45529408d5cb27e0c52d20b8c7c4ccb88c138d7aef249f019d798c509cb5cf7281be1cbe216212e3edf28de9f01fb335f1cddb53a1f5d673d13675a5c8a4ef9fcd80b8905e5dcbb3c034dae5b386b83ade6ee64a35a6d5c60af85f28e24181631ccf0cc9e66eb216f21875bf3206f980152b3e5d2d481b7f376c73c2eee0cd10fb98464f3a00f2a78cfb10e50eb7f0331dd12c13425d50187513a28a8fde379dccd5a4f50e3bcd1a59e9cef2c403a007c96dc823372a548dfff56233e8980faa11ea3b672087ceca5e285b8e6cf9e4b06e4a4f60e98ef35b1af332f83206200e1fde2f0dedcd5ec4367cdb8b453c112be457eb7c81e0ca727e5ca52586f3d90e14bedba617ce294a68d1cea8afe6acc71eeb36554c8d5f54a772c3af4326fd5f1772231daa86901ea6b171d23ab4c1800917363e9eed04d586c3f1d34c4783a5181bc68c4896b02f8001178bec7b82e7ab3b2a4d7237e8b4da6519d9fab36f9d114347bad35c9137de95aca7d4bfad604fc686860f442bf817d4388f1340c8bac3cf5e96dfc3ed0c38a0bb1127e49ebd48a5b59619f6353591d55a824989226f86c8b7f372caa632401563264fbae3c02646169a79d1e585d73ec51c3b72d08b02d1cf4aeda2c11164e364fa61da78389de641cf4016169c07f68115ca878f665ea19ce9e990a69c5a6efa1c4fc55a01e5689a5ce4ca6e71d5096830a7f26d2a7f36ddb32aba462985ecb889c6959b5155f9d17031d516628d13572a9f2fb90b13ccbfba90fc6320ddfca1df2d983752a40da999510a0c74d247c4178737cead9c6fe6e6930910166a57662e54e8206819f68307cdf0735e76919f126b0882142fee83262018587ba149cf87d78ad0afe0018c9cf7ca239a4b6898396242effda4178d016ae4049c5700eb4489ada035ea7672a292c49b40dff02c5b6fa929180500e4915be2b883ba7449f474ecd94ba5d8761fcc661c910da5c735cc24e2e6418f8605080c88bca3b112440ce5646714cf26867966c46a28c43e287a6fd53a30c1e01da1c83aa28ea3dd20c8ccd3fc386ffe57c33a3886da07c6552f64a249684f723246d1449ee84302f8053ebc551682f0ab0164f121c0cc69ba6a2b711f66a48ec346f027626717832dc6fd6b882f2b9934057eb2bc1f85cb3b3e828973d1fd31cc289c0ed569a3e2cd91f40c06dc8ff1eaa8d596f467ea935b15e9305f880cf40b7284f0ab4b487c1922da4ff6bd3b66fec3c6ae04c9e8f48b70e7ca8cefb684c798b8d9e5cba375153b2d872c8ce4b3a25e949a2c117ef3f915d0394aa3a55803dfaf96df262f7dd0df658eeffae91462a97fb70e065a9d89d024d5dcb5296f11dce28af7df90efa9e4cbc471dfdd063d87131b40aafa3d7e327b18ada875d5f0e6203e777a16fc29913a6b68ced0a80ad0e073b61c0f66b7c5670833b62ed185009f0bf618480a73770e90f3cc625a9d7a67306916d6c432b44c0188f9e2ffbda2076f4252cb0782942ea167b07913d5024027837d70db9cec633674d7a323c17ba1476000644b13e7ca06e47174a94249c46bfdab18e333262a3161ce489d03605be5be8310d457421342267906b4542335abc2967fc8bc4db305c505f598d54062048ec30e60b1c189c32ca9b304406e7ca4365e9d879bc2c7a618df9e61471aa568909a303d94bcddfd1f366a2deb67782de72e8ef345f6af7a6c51f8c6c183486e86c2473e1722359b774d778fb104ce6ba525e236d4f1275bf8079e5111d5cf65c94f2bf647fcc4f9bdd7b4a84471ffd8548d8d71d1cd14008867c766e8cf5b5c205b44821a86df7c6fe2d23fbf663b561f2712096d0489a1027df35509c1be236715642d861955a9c0167acd54141aba36adab530f0815d10a298a4155ba308dd958feec0846501e7f9cbf25690d22f4d7223dd44501cfdc0e1bd74edba04a857b4f3d1093b6a33861d9695cd0ddd0a488c6f4607467ad32e90ddbf92f112920ccff29933ec2e73d8f0f78063ab86a958426eb66089b644b55a63e2b1f8185f16814cc8cd35dfba28fcf3ca7399efb19fc66b9c4fee824c05e34c6c9ff15d22cfabd74724783d8b625f2aea324dad7a23c85809ab7540444928c58ad299e2ef030bbbbe572794878ed9736b934143753a6fe73f184afccb8973f5ab94053f370771f6c4ce9731588185fe5ab61c0bab21f09af7c933bac929846f8540df185e53a39d156606313f560b63f095c397b478eacc913e2d1cea0e15a6e533a0b5a1c88a8d687ee0f4774fc62424cd234030daa11ae8a6c628c9f5201780adf8520ced0ab1706fa9296d343aea09bbc895890fbf7d0de5d32feb85c9602428b61105d2e6b6b534314d9e6045e700368cd1d875a3312acb7f2de9a77e1bc9b2c0a896db952ecfac11c68a4e142238ef69134782f4ecc1fc7daad00d54abc221bdaa3660293c1a5d31530b85bcf6eb9907768fb36f6c1f66d9169602d15baa39462ecdea3dc4fd4fd65b7865ee43daec8e541aa76e15e699934130f46521cb069ddd5b2b2883d9f816ebcf5f6b74340a3b8e0c5066fea80c4ff66567ba5d0b4a65c57c83d0c0730b029be3a44655142518233eea0bc2c053a62f1e241ef030be108a211ba09668568cf6b5859c87d528117f0609d89253dde0cb9c3c68d504bf454fc025930292206e7377e4ba1db8bab1bd9f74aa29e8e7af78aa7740b4ef4a8ab9ba432ee38da2682f6a3f95b90ba7da0300d04c7ede0ae3994e347055f501c00f72f01de99d786faa4c1065c95713219357e71627b061bf9c55eaa91c74d91d4a41f730cdf4007b6ed24ced0256bbe752dc399b87769d3eca4f9c2e72abed8ff7dae26a8113c331c42f165465ea759f7bf36afdfabcf06e6e017a85af6ab810d234513ee8fd95f23ffd684cc53a12047a062f8e4ff3bf414be1fd16c8a50e770fec4a7726f7f9d99c4d86a85ddc85e26e9b06626fbf903cd0511d8ab619bedb9274bdf61beac579d3da7f0f37f39d9d35f7c46b04c7c453f79164506935931aa696253fdb88f1b3f26ca9815058a3c0e6f73a4b001142c0a334e824002d9962413284e9c2adf66fd3cf6732e517e1e278b19583ef80317c01fd397aa5e0ce6b257da3c293c6bc58362aae510ffb5c4712282bb2dd9325ef2c2fab2cff6cbace69d626647989f98d3e812a72bb8767e21ad00917970be1f6a1c673b3971541aa99d87613c1a4f801b8a796e20c2cf76290d2ee52c2eb68148e7d6d626f55a88f38489e03a2f6322d650d9438b03e171af32d2a86de505595d952b6060014464a5c706275a44270c374811f2455a50dff13abb0d0a7f5c5600543647083f85554459689368cd25c86324311d5aa410d61e8459b10d036d81430bed0522c3dd11abe2b0f174fbb290bccf26af8bb8af2507ef6c00d11ccaefcdd0fe11c1d03d8464918565f6ec5f133cc7fad7dfe8e3f845887af6ffd3268fc328693f5d5104e02fa9851f44133f3ad2989cd79480a6893552eacb7fa9a48874d3dc979ae84b9d11c0a83b03159b327c7dd4ffd699a5d506e6c0e1d07d645fd8bf9db604b51bfc0668a81054b0c88c070f2fb3de9d32b5793736313d93d54ac1a46f4138ec0a9d4f5bbd38c5522baf5c356bb201744f68db2a0789b8e1ef8fcf10864f4d593ef2bc27a318608a5e3933efa0c437af06c7cab112ea5482fce1c6320f8c59f46a2e55fc86f7bc5207c7f46f28f0c8bb650bb181ba46ef7ea747714071f4901f4055e2e423d18c3493ea6302451dd39595b2ae81e152b0ddff18f9df1a929d2fecb73be2cae9337d843c0bff281668f114cc9ee1343ad41e7a818c34bd451bea050da652700134ae385c1f55a82b49073d1b5add6c931c53f87990eb23c0bfdbfaa43a335df0a2486e6ef34fc01394ef2c07ea80e32aed098d6d64f0dae152fe46b3ff83f880ff757ee774d2f67b7720c969299edc53a46774bba3e6b6e8776759a3ed68649866f9ce4ae24b752cd18a1342db57cbeec64a0af3f3afa89cbc679538dcac5de043937fabada52f3311984f9ca9685221806b722b157849e9f34aa2b784d1c11c6b6280687938adc48134a3fc4c43730249bd3a8a864b9183cdc9db136b8868166cdd84841b2d7b99c5566c4bfb3d44ddb11257ae663b105beb2e6425e0e05d5fedd9f7bce88c033d95767261871a3aabad4c719a3536f1c50c7c477ecffe8113c51528ffbcc9f4130b301bedccc4b088510fe818d43aad936a1b4224419482f447ba4f389cbc26979c85f26eb1ff7c585f120995b153d591151309cc3667b95a83b66ead8cc5ad5c437a1118eb3b86079ccb880861f38a7354c0a9d5d8c85b19e1986604b44e7849bfd50a4705de07a11e3565949a8da09d917c64afc8ce06187e94e2e7b2a4e5f6d51098e52723c700f11ba8a45cd796e649159891c375bb690f2def0d121e864592698ad3dfcd4b80fe4ae25425d12f799384769b7663e61fdedde9b7f7bfdce83d5bb7ad318e2195535842b265c9b72ab8f02d88443f1f1174f933ee37c84c94a18aa3b2e0907269abe5e509850da02a5578db29c2d3d75aac5b0057356f10f5215d44c9e5a209f5181686b3f76f52e1bc8fec4e8d6eae6f248547ef959e8ea6c3d110d6813006deaf4aa1bbc3b7f3abe8acdb2237a5eef8ba85b54e9d9232922106e64754a3e9da0583e28186f6d6053110671808ee0fdbbeee018ac5ac7ac75263638c826b076f5bd40ebe9378f538400f3a8f3678ee728079ca3ef9f58be943ff4fdd33e14bf988d4617d252859b4423a3d57e051e5793e353d13a4a1a50fe3898e01ff0dffbd4891bce19f846181209685a4d65ce1d8be44d5f26508c9bac1cd8f6d18bf0be0b55d7c991edc330f866cfe743513335e00ef5f94489251a36f6196fd030b69a660b5cc79097965120f2fa7f71b9efbf72c35f697c2ae1f947a128419d2f994b427475ed8d071c66c78aa723a37af55fa1f637636f73fcf09392650e6e75a424c6d138941251f1d27983698ccb6089eb627eebf66bfce3c577a1ccf019ac54643a543040402fc2fae083d804e8f6d090abfb455836c775f025043dee085df7a36ed7741b2998271b1654e68b2154e4ec17484492807228737d3da4a0816d1319c8c20b7b2e00f9efcf14760a61cfad133308b14ded8c88195ab7e42d031a8f1b732d5213e1f6963333d68a4c4d73366bee717d4583c9c65f05bada811fa69b0e831957c3e4f36346012c410230384bcc46db58e7751f9d154c60425b4cc76ef99266319129e78e1528a37c6b3c1d00c80251f7b80b3665a8544131b8c528a4b95e2a6a7ec3e6acffee0922660c5ad97daf4e6a697f9c3e88cfda9c7223fdfd60d90279f3f80add462495b22595884e26f8b9d15b2f3d19d4fab27ee9af8c37926c610ca668d7365f6f2787cfab0049166bde4ce49059a97fa3e818d15ff60cb98ccf48d53af3e9c5c1dd0a108860f99091eb79b6f97c0be20631f98e958ca224d6417e06b6ce2eb49ce2ac0068d8ecb363b2d9a5ae972018b7fe5acfd97241c96912f445fe550f6d081b628ae30bf992f62aab274679fa331266ed3f4192792ef3db129f1bdef7906fe4c12cecce5908cd16784d5020c76f443b81643ca74cdfb410c86381665a413cb1d26e99060d2f3343a1101787ba4cfca4832062a8d3605ec56ed9947e9eba59616aead8d4a04ee8178e5f7a748696bbaac2bb4044c82ff119f266d1e66f0c317a7d89508330f0f3d1ab356738c9f83c270f02aa2f1a05b5e59075179b5565f53d01557a6936fc0e3e35878ecb86bc56e7e6bf1fec247963820a720430f26f4317f8e8365c0a5ca8d9c4f4849c3e037a9e0c9ece61aaee63ef87c48082b423767ef876a27c0a2cdd07af4df8489ea3fbf31c11d952214a430566fccadf8db9305133a15b3dd46341698b2700cfb729d68d7d930da4e062e564bb2402dcf48ed0a5058f45e05a17000ceabdad2108b3479866b6db7f34fce2ae2d5ec316d9c41be67716c3eb21764bf3c8fb4ed39c04b09dbf83e3c8a654b684e0ed45eb9c242d34be3a7c976ae75377e0474c33c66ee74ff6c8e4a514b84af5dcfc513e2e15abf7110fd6179c650f66d7f6df718b5f74e3802a46c234132c9b62bae361df1b697d081409a7632378401f7282664d2291a8703a9bdd8af914093931856e209c1d05522a943a268db724d5e3a5a95d60977d966b110b53d39eb0694eabe8d6397ccc7cbec55ec9f7ce23cb0295447b74585deb27f0b77bf8f6bce444895c6def1802d1e40d7cac09bc30b90121102b61b20ddb68b138dc787f9cd9e912d0aff24aef21932d43e114ff21d0ce4adc4ba5400067751dc2881b7c53f88c12dd556374f8cabd418763b0d02281028254a94f0d215f1b9db02aa5306e99cc9d0f82f9a1c60cd10ba2d6590c5b3b75943e8d1dd98924015e500ec2f1e87a07f2563a723cdfe146f6d98c0155e8432602f12d09fbaef9dba31c2ad5fcb968ea05148abecd15b3a05785d999da6f995022fe068c00241a0e066b34fb4cdf1f9d9c5ac59e8fef4d7e9d61f17cb925ba37e63cf5d3badf8961e82fdfaa075faab7071724aff82f6ca89b8eff492e2edef2ff7195cde031b30d0d909c5a0533b6b348bbb62c45c20f1e46e0c20222c07d6ece74f5cc617dc103cdc839712da738e93661449c5ad5faa9ce5b33bd1c012e32f050212fedc227fbed9a0189f579bce04ccc8b68a64c77b4521a8abd9d4ddb2d2b4007fb9b5573a5874d6281aa0e4cfcc303d924acafbd60a31e7a95a0f05aa10da9a98544e3d977c02f35b3f156535f35d43eff7a9fa69c467e9c2e740719c81bf504117542c0913085f7bea3f243ad3cc38bf652b005c126a03e5466ecb631eca38665d5a98ed261d1a4fdf8ac680d417f2d8d5e1288c642bcfb004932ccc3ce34160cfe6533d6fbf92e74bac91ede5f9cbf130d59c86b30f45c7742aa6711b12f31127c9f1a17433689f548ebde20bb00dc85510a5a0b0ea53ca5533edad3cf0e39709371081ad3270b508e31a7f86ff75b4c6ec649c3895dd4ef5dabb6c73ba87663fe7eb45786003f4a647cafd64f8c5439d600f21c955a5b147b4ca5cd1456f1fe19da0e14ca9b4285f53576161460fd0e947c933287802678dbfd8218c3e94d7a32aa790a557a39fd12cc03a6bda726b50da06e450efd9e53c6ddc0554dffc224dba709696fd4a64a18b2620273e2d059b06e07b60006ed7920dc35f3bf7f5e574e8397e117dccd6240d0886548f53ffbf3f6675d3001a8fefef59ef2d87fc7137ad7ca15493170a14d6052eb74bb606b244896259342d73c33359b7724c5d6a0fc63c075c0f9b5bc4413a0821bcd8dea6d0e0cd11b057458d2bc71adb1928c14cb5cf6ad7c4edcee3a090453e7d7681a8e0aab45d04f9adf7f98a374366d998fa775296d0d4d5188d00cabebfeebb6693caee2606c3a02d93da6b418806e86af34f658cba17ebcb9baf3ec7312502c970bbe5da52cdfbf2ece43d8d52e7c38b8304bf0e6c3e555cdb7503657cfb64b0b8c25ebd554c39da99808b98e73f4ed2f773c04d1e74faf5480ee579f3f39edcb0f1bff6806b2a6db3cc50fed10ea0ee4e31ac20cd3e6888fc2b8763aa337a74fc17095409be8e1baf386f79170393be06a55adefafdacb653d63bb8b31a3b5fa9b75bb82da4ede11b82ae15dedc0d9639fd68f3dbf2d82d7b1d6d9cc83773084858fd45d8f0abc79b655907ad4a2138209bc5eff4fb7e880c50e8f913e5d90251ad304b128e3202400d6bbe7faa2629b95380fe63fce54fa3167029d1511d4bc2fc7d62cc78b1c4933e928470c057bb702a9b66706a3403d8decd89bcef101702235ae3d09559d7bba194bf58dbe23d3b6a4931e9da999ebfc07ec9c0415b51234c4b62c3dcc955156ab5ac169e0e7895723ffd2fd8c14352a8f3f4a7feb4489d0b61628eb7e939bb901cbba123b8733937e85e2128f12a83d21654bfccb20b324fcc4cdec6647e21ad9dd7ed29becae4c09c12954bc8727ef29532a5d8f441ee07ea5d5edc9317e8e33851d2c34f5a635fa7b853d22bd677b9e93c2d3860f41218c91d2cce18a21f808cb82a04acadb05c76b0b0e8d7e88b3a9d384d10a619e745604046155d8488e338d84f7bb9713a13aeff4fa94baffc4e7d31f20c9fb535ca8924bbe8e2ef31de331554f9065b99496c33e854482fd09d182b5ca0d6e09342cfedad63063beafb3f18db33efe97aa88394b287ffe93574fa72216ce490b5cc228dfb3a77f9678b865e417cdc3637e871b43a3d0be4d0ab4faa331532f8dc83175b09c7417f78dccc8d0154f329f3de4cfe4634c461b68130895827a1cf440a9e33d44633ad4eb47f36f48a94f6b80e66c739795286c2ff21fefa7acfe29f29bf1b218a0c478b22b1e2b2a9d38d8a58d798a55c14af15d871fa4590e2345539b6859f8bab5fb06e5f1e259153d20496fe6d433fd8876acf1a26ebfdeb2d3fdd906a3f337b0e6ec6731aa09e02d39a53c3318539106b4e13e67e899b5fe6648dda1d7d75c86b5307fd7537dba467bc51e464fa5b9bf70d3dae9e0f26441b901a2fa5a6ce1f9ab272f8b1f8bf118c3d6e9f503863d2550a549de67e348cb81130414e5708353cf5b2b81f9aae36342166cb5e60996dcfa46d5d86217dca09cc4482b2413e185e8f58fbb09d27b3927fbedf61c1fcd8ed83d1356e24f8fc869d4ee3dfae97c41fa7d7230727023870966e736164133fe81fc4599595b8e99035444af12b7bfd0fe96957d7878f3977c6db880d2a69cb2b44230b617d08bd1d2854582fc834e294f997a96ff8adc3cd537076385b8706d967e8457e8f356159435fd71258ba8702400d182ab921b543717f74f816c94accba3565c5d5b2b4104406c2f63b1a7a590fd1d747f1e6f0878af9b6413422e6ef84d6689d9a75a7bb6bc64815a5139f89a6357730f084974a27c261d1aef5d2dad46eb2724328a2613dff133d5160d4748e39094e0b85d251eacf65416f312b682aa363d5f0d9a4ac37f001284be5d82ff6c1e49ecbb9dcb48313fe7706c89b6fac16cdcd515ba459cc4b4b1e88fa02608db775e1d04ddb21b9cecf61c8f00673d31de581a4a01415a1c228d442911a333d8b0c4d7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
