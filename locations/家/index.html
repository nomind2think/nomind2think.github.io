<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cbeb2257ba3c6e0f8a152e2731b6c25baba30e658540e356db6a7f716814003098b886c91d9428a0a756654f0b968f4c2e05438766d92a2c4eafe613ecfe854a6e4b37916e640f4f47be5c29d8dd73814a712a5d5784768d0173f987e3dae91c77fc0c3b85a0df1d14d3fe18326227165328df1aba10dc0b33d6b85718f0d8d12cf4dd107509dcd36050e9e898041134344879f55ffd06332a53754908e3e546973fbe9f5990ae02cbb06477d3e129fef9df04b300b7d5b4799ee79f9b9d4bf884e9f4f1968f55f2dda79ea32882ca8622953756cf197cd5ef76ab57bda844483f9d41cddae45bdf57d3eb124e22429ce559d3e8ee842e67c0d7c2d421e5c1a1713008801c8c8b898dd9cdb846cd5d4dd479e817b72ecb9e99263e7ae96c83705a9f2e639fccccda5d994eea280a1c419c4941f0e03108afdbafff37ff9b66e64beabca82b0be0db1d96b724a5806428111c8c5ce4d5f589b3fec408ebc40e8ebb9b08259c992667e6da0655a605fbce064e7c04c6ad52f27edf5139d9902edd0b33c61f4063eb342e51412ff113bc030a572036db5fa9677928dae7c8e08360acd75f895551fd71f1613c5028f67d07e0f54c908e222828ce144f029ba8c85e4c8c41de57cfe84f047bc010d79e90fe99a0143d30ee0bf2601867352e829862e19ea26fea28b883bc028401feb079ff7a683e1c68024fb54404158bc67e02d0965654d51f50622d6987e79a54ad3ea0113a06b23e47112dfcb8fa7a16dda0d295e4747e2c4c6588de3f373ae2353390217d12f580477981f981742fd49a6f4bdbf191be1ae2912486857785d1c048f4d65af90782f518db914dd9dddc4a97044d2b38c70b8bdfd88f216a08ece152a1189a50d3d2ee3895f4c178e6082b07fe17651bf02ea8bd7f11aa9badcff3f78c3e8d39f612e8a388ae1e7fe612199d964225731f5509e17782d231d19c9eb799f378a0ade56b6347b906ed5007c5772624b3f25091bb383641532c0596c1ac185b4d5c1b919a0f6d2d696ed5665153135d507cf6d4aac8e7abebd9a048e8881a9f7c78ef1912d2adc3f2249f956524587221610f85a89d09d4414d9175b41320e6a0a79c095348cafb23abe90eb9492e1219157d65a0656a0ec25d5a6823964f546064c7b5c213f37aada157b95faaf06bad9ef7aa39c2e261ca3c74a2d3376df7465ee035d2f5c01af25d006af5a8a3eb23ca3218410a2acf8299faf5cd4105532c88513676c3e77e2ca89a4d2e86402d4bc5a7b27601fea6b2d7396490524337e7746c431c09a918ca220d17975248af71a48bbb3bcb6e670de650efc17354cdb953ec3d92f4e1d340c95c405771e56076966757dc39f7c09d9675b43ead10f8e30ecc9c8907ec8954b4621ecf616048831abd820f11ccc21e1f0b65c84ef65d258bf2e8b26f6630c84fc64fa9a5d0d6e406021da3daccd28064f2605ab028b610f70541ec5979f112212d52a9656cd98aba12caffac1fdc45e5468b8a401544327aaebf7cefa4e6136921c44f34ef83faf70bad65f894a310424be5494e1db97e0e3a8005cce3debf1e893f8526cd023286f958fc7636e54b09b448e5d71772e4237514d2cfd68700f7b9a50dcdd69dc0f5246495353995132a0b763f0c32b4591e0186275af13254364ed980e4d51c1e9d57f30c59c07ad9735baf99d7017cbd6db9927b93773995d2e6c35ca66e09cf9add01663c22d586a4768018c13c31c6638f158a96b1802095a4ad24f83198d95e29015534d42b1b5025666a88a0838acb8fd2fd6703eb8b3ed3eb867b953d897d0d04521922350fa623887bbeb80d646b1840aa8e7804ee3f356bbc36c9e3c1c9e78abe787d8c8f10368423043d3134382e73da99dbf3eb1d62df83f4237fd9090846ea829d312ceebeb80bea55b2a1c4d9992d17a68fbaa19ab10d413ad88bbed67b6c2cbbfb7b8bd15b6e829bb96ad6f15fb42a2d2ea85bd8c0bed373ababd323b2496c26251fc27e094ca0ba1aee46b56a1eae447d37fc6f0572a606f8124774c80d4de8074b6a1f49784e3813f188046b683b4dbcf6248c6cf08abe0b9e8360c5c8714887bb569044be782417cf8506fa50aedb9cb18528d34a1ea2531c0e0aab27950512d7d85db0b846402ed81d555e4a723b0c9fcab3680ca6f3657b74031d29726ded69862f589d63888732660fa0dc708a284165d78b12c6e5b0dc4f8c17fb7fd4c9555cc4ca65527066211691b8b12ed3fad36ce1d47ccb8b30bf9b4172355bbf055e58f7bd9809e52ec8c82dbe2985a964027ca3e9ff428144b14881f0163f6c5fcb300f385cf8a779efdcf5237d0a9cf62a00c2c6aebd43121d968c8edaf2faa799b77c2fd12232101360f63ee0d1697127473a38838f10bc9316f733b586c55e8ee6efe9784e90d1de200148ffd26697ae3dc90700934ea4318a403ffc796e91ad6b56d5881fad4ab6cc304c26a2b24e65937a53b2ccdec3c685e6b181d50568c9ecd5f15e2b42088dc24fd0ac60f3ad48d975a84f0993136a195cdd99fb0a9eec17847ac10da674e236a8130bef09baf86071a07502b9559b031d5da888073a152f3366d7861aa33fa1f313c4e5db73a503cf70cc242291a83dab89035e4799ae2ad0a49797b4818cee0e0e0261260ff11e8328cb4528c5ba2c71ae3ad1afaf99bd583b1c890391b9327d43b38b8e5b2c4530d5581be14ef02353ca8d247de6d33282a8a4c8b8265a22b1aee1be4832ef00840800386319155d407c480b50cda8459128ab552c2bc3a847e648be43dc613bfcce8eadbc0cd749d7730a890791743b65644ea5a5a973897f772949fe03fcdd7419f09e19c66f79876cb8343a92f667d046f416a8e1efa3b9e2c30c2c9b99c6aae85622c8fb34cacd0c3b097f62520c1cb966fa44900f35bcb4b79f12d5e78b584c7946d0e7c1867712a901130dc195044ad27e8778c3e2fbd3a6cbcd577259f172eb9c256cea6eeed7bd96438265be6309fd0ded260540f401a9a559e4121082fa93ccd03345a121b7d9ca4db82b428b821a5a25f088cec5d7656b5ac0a7f9dd2e4fd7840a193486dd53895a9d1a2e8813c7b9cbb36ed2f9f0f795286e8f49b8b8a31064995b7f01f5cfbc3c23da8f5570facc18435d4645e585e67e5c545d0f6029a0f6fca06c2a3bb371eaa7723997ce29e33e5889090a5a0c3cbbb7bfc72678251fd54f197475833d4156db09dd873f3979e2f862aed1818f53eb9f0e592df1abfad8e9e17b6ddcccef0fac16db2a5be6b4fe1a7591c9e11f6a23e4724d110964b64d3c73acd1d4818237a7af8e1f159b07a587835d79208abf231a02990f3558fc8c13ca11624fa92280e8f364b19937dc80cf0e4927e602843811b1aa2cf43b61f7158fdbca57e7582c24f178b4bb973ea10ff7734b16776f1afa2a6977a60c6096efc608e7ce764c6c40046dc29f3359874237c9ae901b5cd2c310db2d2faea3ff40495b8fe0a4013f6b62f30b8fb5a355d489fc4a093c59a2754e00010d2c5cef391caf264f1782b333aef681b754929defe18457dfa34982b578dc64092bc7ead328cbda3a9e14e53ba9775694dc69a36c21ebbcfc55c4e10226c21904e74ee9e833cfb548f8cb74064afdc919fa7ebe17f5dd276155c9deea837fadff8643121a185f3a78b1725d9cc9431e705f496ab42c683c9c1ac3e8277787efbfdb9594db419f9e6c6ea44c4004dfc29be3242b57f4befc718cbe0e35ef8213c6d01e606d88bc785f2bee16584c0cb2c2b99675400cda5b3bcd1c24b24789d1b184ade618657018707c678284024f0690449f6aee8c2bb6d42a759870fc07c06a9df3d1f04863fe911dd6ac9a9216e39880edc20120f7e3121e13cb99281aa9084cf1156f5a162f6ddccbbfcabaf557c33b97a48a88cb98e91177c06172dd1e2bb583b97a4377e2290028278111b7b019ca233be5a33ac8c72fcc09187d061e04e001125003d17e8abf28fe904f7869425566898b5420be198249e18ff330fc5e8e9263da2028997236f5d3a9b1ac68cfee4cb3e9b512425ffebc56c67a08e809a270c0d717e5649f72ca6ec3a097cd5e99f53277f149a7ccadc1e1a1f0efba0ee377ed77bc084f0f945929dbf2b3b761959cfb8e2435ba3d92fadd9190716fefb9d696692e0c10e014b066782050d4c6cdcd92c1dbbee8fd8d448574503826ec298bb8465825fb55bb9cb2e33a55dcb31910bf8afa9a9b27d63743e483c6cb1c10101d496f4ee74ad1c488c2318ac022eaa1c476e63c942af428e8f0bc4d9775cd1f3ebec0747733d661bd6923e30aa4ee2c6b607eee4cea9d37483db9b9404bcdeb300c9fb6c0b2c80257936dab84439958a7a995dcf9dd692b9ed9499269d3c278521f8fb494470361006941bea028369bf69b50528c9b55de9abf855508ca0ee5108c9e593d0e86da97b1fb997804ea6fad99dc6f0154f47414bb66a4c7079c5ed761ed84f2c6e428889b2de7f5a4cb468ae37199d41e6d5e70a8d5bff3ebe95d9c2a8f0f1abac2e6fd3bcce67a3bcac2e717b52a2728e99a03d086bd555bbdcbd8362a74f14eacd1f4189f43e6943d40c18e8b88579bdb24434d7e49b2d5daef6827086100982d8506a0ef220d13e29f6c88260f7c0b511f67819e4737e59540ff76d675918a224015233fd9b0dcec10ac8a46844bb02f334510914cdeaffbdef5e08dbd599eec4c8e6f512687c946470ae37ea85a59a75b4d63af4172fc7229ac7099c1a55c889fe33decfac83fad9a1e890319d56983c498c23e8095ca16bf777fa8aa0487ec0df543eb6e4c3267beacd6c9e4f96871569f3beea865a475a306ddaab9b155920a9fe8125870de1f39ca8d6affbe9f4bc9cebc0f6bd7fbc5bc3a705353d890effaa37cae825725adf95589369878f44e6ce40e30defea7439f7caff6e25071da5065284a83d0b95e4eeb9b9cfc5ad59634b5a02caa3df1999fec80eb03a6be9d7e798a6a58b44ff686abc079ac437928a3ccf4a9745bc977f685ff2fa55a06de13f6d8d6c90638be20ea67c0ebad6b7eb8d9bd9290f8af8490fbdeec767e9ab7fcd1b0dff520bfb08300f992560abae85a0e1c18e69923e9784a56b7818cc378e9719cccd325fc7dfee510a779638a6e0ef4b1014c3411eaca6414832c38776202ec68b4e6eeba2fca593c720fb800137d18e01a674532471700fc48365ec5c58276d1ebf3441c625a814a1edb90dd11a94b8fa46a8333cf481976f7914cdf71f4389d242406bd60167b4c01366a244b116943fbbe7f854d4d213d41d63dd611dbc387ae7a8170e11da34ca0286ab8a1823a141cadfbfadcd90b874cd561c686454c0c7454e8d01bd29511afac859042b5816274a80ce0797bad8437a2cf21d2f8cdb220c82a3d72201aa5f0063665a574af67c7a587e4c3ab2571af916b06fc79d5374125d2fec70111059d19acabe93773c3cde979b2751b0b6e506d6248b7f9daa1f7963314af3b4177be875218e1b566b294d8b26f8e096a7353d144b25c61f5e493c422cb59554d8cdec6b3d13ea1169769796fe1f694821faec3598f623b7a6649c561fb0b47b4784785bd36c74edb7f780bf8ccec66d189a93ba2de68a10c0ef12034bfe9eec5681815d5a4dab5e244e1ae584696fd845d69f18e11febf0971ef12e086dd90b78b5fca28e26d2e783e41920b92db3f03ee1357d354ed912cb6b9a6f702fd1185963ba6fa921102987fc51165045d70323357357292064a190f6e4a78ebada475254e9a9178f8b881ad40e6fbbb8a917c0311b848e77c14eef8015ef8d952dd63a8c2d6625c10096ffe3824d90db018ad6d954e77280caebe7eb46b4dabfdfece0ae79ac00bd6cfa3f7232c89bb7dcaae9f24e42cdf892a891cbbcdc2b49bb947d691664909101f1c38176dd6739314e20de1c298d4635125d7369bceb32af4978e1bf72de34957fcd1c727730cc49f829b885eb81d2427a70101347b68256eb902c235f5d0b3943a9ab04b1b459141e93388a2b99bf59c80b35a85693900b329087809e5eb295a23a62cc6fa616c63709c734a04b7025fcdfdb53c18e4c388efb79dccea48ad2d2a22eaa3aa58304173308c1072544048c7d40eb22e40fd2abe3a4c105b05368c0a47660ff60acf47d9022a3df7bee5b9efefb4b9409fa3aff32c0826392057aab1b72686be7d6328dde669685151b3e3e894017a7838a5d7850a22e093815db008d7ea154b74d3d9c226addc059a24a3872d10912adc49ead47285637903991df316f5f7e6a7a7d7b88c93b700ef1dcd6963b617af5f5a917b2cf4cc537459b549e80834981ef129aedbbb74ca439ac7e8103069c19b41a20a3b825420dc11a75c12ad931e04c286fd95e48840b90f6820dae2d396f170d256c4bafd0afcd7474d663638bacdedc7e0bb668dc8ed169c9fe8c00b97b7ec9445e02e54283eea4b56fcd07df5502d0ec06ea62bd4f5491e38305b355168a5245c1b75d398969a0b69d77a57055a78ac49ce118d4f3762dfce447eca8b0e4986eb76a76782bb42b2e70b090126450f1afa95abfc0669e4e6a51bd18a364270beedac5f54f584c591d1885c56ba59358a9ecfbc584d0f8289f5e2568bcffe30948066bccda2db088a08b3e485bf26983655ddaf6be02be6a263686d22f352bcbd8c378c6f51ec13db6a53b3784812ea15618a69f33c716f865b4c233a4dc569d8a6794fcf41aa86d53623a40ab2a1efb2494578f403e881ab4289d85bd4b4efc5974b3591fa62e79d9655b7dad712d8dd34c08feaca2140d408ed3ee41ff1c0993a1a3ce1732e3221020abd805780f761997bda70ddeea92cbfc6539ecedbad80dcff5e7e1072c57ff060bee159f1e9355b8e72226ff0b6ab95a4a2f673d9b93e121b30fd266ab9ac59ef712eb3c169751aa7b33a03af97aa402005e3c45cae2bc0df41e7bb953298cb2f589dfeb069f338e8ae866c47701266443d11137d5d3899d99cb9c8dec896fd72212fb82210fe640f726ce7766a66b14fef6057d937793e6ea702485b6b37dc4964dfcf21096820e49553faea816e0911f5ef6cee497d4ffe3b903d0fdf50d17eb0d02ff85ec5c2f57b647d4b144510dffe226032a33f7599b316df13b75ff2b742c65253b779f2d6b6a4bc3ceed8a7665913ede450a75a81fe0ab2a010c83cdcb5ddd1a5938d61ad27f2c8e4222d5f0540c8cf7404e8ed2e05c7bfa71c376ac98a18c91b23c9bab723b2e379e3d9a0f16f295cb59b9f6f8c9317a74ab2a66b64e61f6a99edaf56802d631e029c7bc064517d09b00cd06ba66d4f035980050e5f0c2eaee759d661ed60913cda55ab9c6d75253a32cfafeba1260504cb7f84ab4b442df85ba1057a7174860360246465e18a8f2e9fcdc6990f00c2f283f89a44bf55fcede08e45a45611e38b6f48506640f6ac8f0ea4280af5d1ce97bddeec47c2021988178f9fc64766ceb00b3cde5a2a4a1d8f6450a5c9f53a9f6c3bfc0860c4544ff7f676fc4b7488584a859e979556fb7aacdbcfe5e70bbde53a95bd568876a3d9069651adfedf4b376a037c7f96604cd3a0a4580e458a0eec41e660845ad320623d475ad878663c01110d9f0235b81d294577410e87170fe6d42b3be011c65957d458b26d088d653d93002d85f42ea5dbcf00a2eb6d148b75e82d419fbb8740b49446b6516ce72d16bc7a0927cc8d887b000e913545de31ad101af4ee4742daf24360eea6be949256639fbfb4ec26fa336345dcf0e18f2d44478b5fce07c79b4c151fb9b301d35cfea7c371e1871675dfe9606394dca2a5005b575f0bb3019b3596c3dab5c0416b9a03f8c27c5c6fc0fa43411063e1312a89402b44d86570415eeaa1d2fe0eef08e3939df03f51fa1639381efcfc1978d5c527572e5fa36370b968aaa34674e6b3b1c440850ccc4d9f53bfabdf04c21b33bfa5352c6d19307ba80c374d238afe5e340a6675e5f1f4f222843119dd78205a681994155d12dc7fe8fb63b85e8c924b90e2de76951ab135a596c1f61413433bd4a8da684f3fac527648129c6947ceaa6c10dbd4568c545520ac83f2058f807d34dee76311b3552febd311e4145efa368f9b903ee7b132b7ff91481205a39a85d6e5b38acd8074a40d19717d8b20ee910f6c4c5bd81e003bcb6eed54792143e67a3fceece6b1cfd15127937de5802341120a1f934fb6f2e57f2be8b4938493ef2115427043521be0ffa40d1b218a31be1c3225b5d693104ef0df2596396193c7dead9fb4f798445daf952268374b458f8ce70326683d222373cd2c1457f12835537492f67e8facb3a10faf31e3be985477b29d078461b5264540a7ce835045fda0039a63f12e172c7baecd60fcc6fc48da4a273537d40c1785cf171fce088758d54a13588214dfda7abf9f050359e6edb34d0d70b07578330be29f65ce334f6977a2ee1b4f49082839c7c64d16f2ae4109f2661732b26bd46d3307f30b0f107ab0b6f68c1f9148e15044f29ed56e194d6f49c7ca6a86cbb935bfe1e40d929f001cb2a8ccc2b8ef799d1eaad51d3db6e281ceea73313d2f0541d29b0e7f2b280b9b66bccc0033ae6fddaf2b9edee9b6d737c6b7f98cc353a7fa698aefc341f89b2fa31618084ebfc606d19404752f4c831dbff2d93ce2b71e5583fe0b86ba141ca48ce968477848df9203e5eb2fe8bc7b70396641dc9323df391a032c240e041ab0599f8681952a855e6a45a16870ea5f1fa95f9c0c53a9a644d265f365f66a1b9747762e0a68dac63ce2aa1087238b688a181153a14e131e7a9573ad785345eddfac8cca23316d1f1761c882834259ea75c624808f63f60e2dd5781d05851da273ee4c64290fb49de41b3268286cf113080d69e07ca7bea846054e010aea07c4557c4eec7ce7200f24a124590318de09aa2134da9c4a8a32facf06a1254373a9b9b2f33ddc7fdc52b1cd860c21e221f238025ff8a736569d49d436f288cc300b3cc3f7e38b3c39e6a9d5f95ecb4c00702286ca10667047772e943eedd2e6d6542bc7b5d581c4a1b735c7a13cc15bda2d7470ae2f5c55c96b69b188fe9fce0ca7136a31c3dacbdd6fd1bc1e738f2f3766dbedeaa269ff029553d810a38588c336883f9a64987b0f8cf51bc8701a5f22c8e2d938d1292a7baa4ae7e9becc0214fbc7029f5050d3cc92d8f398513404c03e61b95e62a3ec0992000066eec005d0f6fe7ce153dae4db9cd02ba5ac05583f060786b165c3a5dd31722ddbe0873a75c1d955a06aa4fb426623b53cc8db8a296df21f136927350b7ef6b39d5277228b9f73a8938a02b86e8ea20e47d706e85520b633686aaf17e6d4e21e8deb06cb0e11773368affc63c0fb66d2c9234c06848e809bb70cc290ffc38d72977f4a8ddb3c0a25fac129cbce92f9e0c9708db34a313adb7ddfac2f3a13fdb778c18bdbc46f38900db5f3344b339939f79825add7b8186bd8b5e1aecb58bbc65bb00ead4f0093e3d0152394f30a520d3497fe3a5860f60bd2c1c463559426200f3090c9008433d0aa9826911eab3ff5e326c906edad65afe32d9fdc19a82ca94a44c336fdb014706dea6e8da4386bf6cb46b6d0b76a9c64d452d1a816f987bba85a54e427d0bac4ee43213c80b6b3c14b69466d1ee6e01f62f82f59de3bd3dc45db60593bfabf02e3bf899e89719b44b797020569d04834cfec52cc32c3f5648e58eac7143ecf713bb3d54001d198ab26930e9443c2dd5e6240c9b433941cf400b2dfae06fe97f94bd3590fad267f2744e4fe0237c690a2fd3b87f940c1c67ed46cfc98835fad1b79abe3d73854eb8a7ec4aa436720983f3c4453a8c69d7387e1ee88f7ac1c6b3e8fd5c8c048afd993a27230210539426b49ad64678cc6537ab435fccc26c8df3d1197285546703cfd082810cf2b1607682f729f7f8715683ca23b1bb9025320d217e34ba45d5f076ce4a4de75f2eca1f0c2e604a657870f843758fe6272eb0684f4d44101d5e3a424b1ca4144bb9415dde036387a41da8e848bed9d22b33a80e7cf92eb21d70bf4a4a63d987962b1a5495b0344f1b3ede4fae42d6a996091a76c5094ba69a7f98b0a219fcbb888e27a7335358dcd9bcf3038648a4fdfd0959b756901a620bc7ffd670dd02562f6f4a571de017a4ff69d86ebe1f5d69a1ed966ec91c6266cd276aa64c2149f59bb9fc54c7073a3703a3642f590ccb14d839415b6eef8fbc8ad03a783ebba0457dbcb943ccbb5914dd100a767cd956e78d8963c8d7ef92e2dc107404d3c0eb3de86d395700e934ad7c4b3860ef9cbd6c235b7aecdf3bb39ae10455cbc38bc6de9e3b7612cb667126a398a0e1c78d4c16b23ec35ee33dfdc2fcf4b82e4ad9baad3862ce1b37c4cdce6fcde2d322a03f5d7d23a23b960ef363194114a23a2aec801180aeaf9464ce39c9b2f31da2b820b21830db06f8fe43c90e3b5f288a3477e638d7f0b3105e6a4582c5d2686204036ef00b55a779278b833d2950aaf34a8117ef50980ad7dd3995f669add844368796a4507318401f8cbf7ccaffeeedfea3adec299251dde567667464c880a0f68a24f6030a32d797f8fd05f5e214c3e7c348e04cdedacc8ce4bccaebb254dde7321100a0f28864204b8c93cbc379701f9e6a67794212d5847d4e36f9a1620d045853c4e26d2cdf58453b43aa2f7a46a1c0c429823e3b795594e0071830fd2c1b589e1315e39c0818f33f7c04844a1aaf4d84dcbe1dae186c0adf47ad665c2294ae3948da2793428f1adc7b25acfb8e5b4e12a58cf0ff29517a107f9334be2261ddeff6e9d168ee2c8bedd303d4be678d7dc5cff2e302bca99cacd97229808769cb6856d2b4ba1e4a2fa7b6a690ceb40ad3fef7517d450c236e21c7e5b5f85c344ad2cfa69c842a7455765982fb3f61e18edbd793b098161630e521c48b0159fb6ff21335af3286a70dc28a49661f10733652dc9c10b3d43d8525f1c34944983e99ecbc91b9712f320e213dd36542bd69b3d60f4c1d81ce6e9a9e51f2f30a9b0822fe93c9c7b1ee788d2d5ce0a7917cea999cdedc93827f1a4c14fefe50245b1bf807ef7c50e2d2f701d982f15d8ab6416374aad4af1b60f2cc55ed33306fa316867b97eda3f9aea00951e4f5eab0850b0244aff486bea72f57962fc2f487a318baa2e8c22196f507286254364ca12e518a7133ec9f545f0375de25699422fccfd5baffcf5f53aa9f5d15717ab9f4d9e1c7ac5931ee7161e88ab8e51e7f0260b719dc4ac15ae02182bcdb97038d4f515844d692ffd69dbe79298509e5a5384b1f81ed38a6df74e1eeba4a304d95d37510ebfd715955821899f47ce8aa5bd3b23c0350af2d7fc8b67aa6ebdbd0e5db85993846216e51376890e96b3e7828c158365f9f9317c6a6f9b2883daccce0480b758f06686b7456bd576732dfcd1b9377d92756ce9fb0fe08b675fa4ca8c35902a99994502431be609ba76d4ba233b6091e3c5a4731e3207ca65f11e1183581df23043b0298237a5760c4a8dc5f166af082f145391dcc9d815b2fdc754dff6f3c746fdacb61fd516a51176a89723d6527fd1288aaba737c5a61fa010e5d71e151946c1ff61c7bdd4ac764846b193f3906670e56bf2e641d194c368e263c89bd0beb7e1cf04dacf6526e7e4760d3ef15b1e5459577e5eb95bb995f04b6ee046aba52f5f9754178b8afeb29b775ad5050086ef127af7f524af7fe91b57d6de9cf15ef691211d76578b9fdaa5d7d8902583763f11cef67fe85283d02f05365b79c7a11725cbc12290d4131d8bde36eddddc6a43623d528aa59091b1b78eadc7fb07594da94a055aeae3bb5897365db4cfbc44741be88ea39ad7ddd4c5bf7fd0f168fcb10145e128e75370222439da656a65644278a0518cd494e8fa018a98175ebfeaf436334f97fdfcac807cc26dc6fb6449b53870ce48a8d7243167fad6ea6480d6aa1f23d5c33de83f5c5a1e7f0d5be98decfb82ccde4a41ba3eda869d08e964387102c2bdf510e4e4cc75035b5b446f6b61e377229259fbe11b741bb6ffdf551dc6ce461edd244aa3f896cdd811a7776e3cc5fcb013eea23385baee8aa2180698d397d6a13b18d368b37cb31f2b49a64365234af54b7be959009f9453ddb3dca6c6badadf33ed927362a76c1701249addef7b19607d9733f1855b40e8e4255a18317ddd1c7f8734d5ef4ac4125b4b4e2bc2acdfe306980cae8b4fc42af748a99474b69dce99eb988a60e5b1a17fcf9dcbe1177c22ec0267e316030ac2e308020a1c34da8b114a2d4f0945358e48e1e1e16b623ea7c860b3fc9dec576ebb7d9def47536a9feee4a544b0e6b06c0597ae23922353a9c2f90b5d3e6b4b9ed684d23799808273bb75a8143d3125fc93dc6303d6c62f400a5c91728c14c260a25c9346291d3852d70f4359dbdf7871266dfc999b02acff78e0901becee01b7bb2adf7ff7be3794e0c1d309eeeb6ab3c0f9ba0145e2340e5b6e91f43a2c563fc08fe77af4b3aea9d2996aa85466fa4cbb5f7befcb39064708855e0d589890728778b9840245456f21c896d402054f4a27f596e55ce27dc7ccedd0cd7aa008b32fa7ad5770d4ac75bf83336d6f796074cfa934ee759c7e8dc80821c3f670e41eab98a9f3975bd744247d500465ed2283e18801774b0c1de1ef85e37061f6d77d8d50f8626b4ffbe90975fa9cdf2db35eff8fcfbf098487eedec7e2344a1dc322bab99306a05443b7603d054ec3a2f178b7798cbe146d5a46e868cac5d8a8571ddcd853c870f7811c020cd963f330f1f00259fa1572d512dbbb97b50589deec9cc77558a5e82f311afb4a7deadfbc6493e7fd147efd2709ed9f99de27f6dd932f90e459813732c8244f679ae466f97946eb85c5cea1f8a10fc869d63cf4f2e1344e09f32242dd12b2d59c9d72c9f1ccae24fa44dfe3ae435294e85f23d71e8504785d93cc7bb6848b676598d3b45af21d4a3e0630da79de2ccbe238980d23744c995b2880f1fcf38341e06f67b62acee7ee18a3d99708417af98670e4a1e0ecdd243ca1fce84a0ca10c9b55856a9d60fd1cc60106fa8d1cd2f8bafcf5a1db1983be621e10a7ba54f3fa87ab3657d2577296babba3b714f3aaa319bf6578ff55d00485b2481a5e7645e500eb5936f951141511b2054452cb59f95910b6c95d1f30791b7092f921574cba4d9343d1e560b9ae8e244e29bd6e5cf404bf05156cc94322d4e34f3666ddef06d8ae2846734dc79895121abc58746a32f591f40879ff78749a3277420704ad1de8ffe8bcb72ebeeb77f6ab5fb4f7c8f4c3582153c8a971bf9fa2c6e5720615cf358d1a11f56668f3a7a61b281a077dbb84e556ec0c71e09180ae9fb19a43769ce8c611500b02375dc92cf11e986ec86537b17cb39e497bb3eed87e058a8e7c840e9dbb86318da0f79c6b5f804ea5853101f2dc8696c94ab5d7bdfc909d4eb787c11ff882977968df55719edb653f6214b9e070c5979c2477726595061523a1ac1ab36d468d60e02810671eee3cb168e93e9e3f556470be02e8896dd6eefb4ec3a77387c3d4456bf9f2f6616422e985d999c3bb529e2c67735997b71e53f6ff5e37919faf443ccdb306d854ee5fb875485f1db686b0b19fc48172ceddf9f046fc955b8b2f2b779b60aa51d31621b84724ca03f7159a12f5329d2b3398a4425569ca7e87c3c1c4675d2185309b7d1dfeb85dd4bcc70350558776377675a3ae35819cfb3fcbdd54e50ea3cb199ae9ff8f731c427a78a48098a1a95bb29334c8a60f0846b9a467bbe73e051ddb4b35262130aa934f06a337d20e4bc6f4e33f6bef266a6db4a795d305507edb597c0807da2a35996dc5d76338e4d5feafb452fe03ac67e09e19c39f65fd8def25d2cbe61b4955476590a95e15b2e15ec19ef36747c5aa92fa00167067a45393778f7816c8b124d8a734ba014e1b2d2d60731435882cda61a4c8d048b23589ec88273531ed7a5ab0575a7af98b7a89786e59fa21b31cb69e94135f3569148862fd909ec3035cbfd960106e78ee3b0c1b5a27ba857fda20c1e715abaf27a5c29ed8b37a8429bd0695d385caa21d0305d178e277df3e61abb821f0ec88773da9d47eb2f988a69c4a0e8de994c2a453a669c670ed59275efa16bd72dd90233fc86a67f653ea54c69d4b445ecfac3c7b79818ca5afbff68ecde12137e934e879989a41f77594364219329d6da6ffa118364907090e320333dcd574f7d0d39730f1bce3e965cb796ecdccf19406004ac80db2d2e736050683084a56434460e763096cf864dc7280c5221787296d14e3730bfaec2476483ed9ea5c59531932b4c527ab94740e1beb881135f6a0477fb80767737e5f40856d085e8bbf9511ee0f08efbfc9558b57f280bd0fb4de1fd4cee72481f270ac89fcf75634f899e9303aa7e350206958846d589f138fb43fc070cd71edb7d406e474acebc082f5c4e419e3a937c2ff68aef8a20308b3db818092a43c648b7ce790967f0e55fec896bed3a4a4faf25bd3c54f5c77af5125be93ee54688abbd482fe748cb520b08bae039ca664cefbb2390c98a7e6a50b50918d333a813011a325e694a3f9ef77203e2b391504fe2bfe9c1c2814381f39e0124f3bfa93171a3662452c8cd841a1287fbcdad11ce187539c1d29e122bbb440f6b33489a5e5d8b39a2008c25bc23c8957468cbf166f3f1583f4cad12c9bbb9dff8090fc188f3f944560fc5a2c3f8c771710b36bfad5575b46bcb8a8cb26d4fc8e04576063e617ad41ec5bfe0a85ade51d69b965539768580b24653e900c053db4ec2856d5549b9cba2a338356c14fe2ed9c24eb23367730d35bc5bf1e5fdc51c6b4727dad45da437a4e8032d9216f8f174435b7e8133b35cda12409d6041575d155f437dbf25f92bff596ee15a974c35a5f0d7f218174f5c50a03f5ed9c646626da2f78ecb5f81c2439454670298a4a8b22add4792f479a899734e5c008126e0926faf1db90652432b922ee8b67a7d14f10a777363fbfaf9b104b6f752725a8e66d614889ec429001dda34caa21f009e61fb99131a575333103883c0e2b01b9a832b64ec8f0721178fa0abcd6da770bb7f359f693bdf45d1794749ce808882801320cc7684da36df4989b41b8f0a8dcc30c7d2afba8df51efafc57f81b9704df0be52b09a51e5ccba70de42f18833a455bd632b85e833b7546fa1bf8828af791ed97227036bb5f9b57ae9cb4439e88cbb7eac8e8d166fd0e0f0287f97454ac9ce1873e382fd47a5ea272e3b5569a94e42ddacf7dd4078fcd2f81a542298abd5665a63095c2e91f8bd901d80b893917ae9ffcb79e403a54afa95472fe014e5a9d0885a561a007c0f68a79121c359a452234f84516ae58f7e86f3bd25a6261cd30129ab08f202eebc8aaba00f817413d11cc264c9f90623bd116a63c869ed3ee46b2888fe3d5e03283ed694584c563b5a9635feaca78d72a59324cde601cdeebbc585b2cd20f393be1e763016446eb403d4bd66819e2c4a521905f04837924fb1e54383068486e6f853a1d8582301f5c0fb70ecc8b3f670dc3baaf33ace86a897967a6b8b06bb7c903ef436f9262dbec455f1945200c8e8ae1ce13e664df073ebc24d6549045c340c11c0108cd80b55e16ca62b4648df03f1c94748a75cd88ba609675544e929e23a9a9b5bc94355b701dcfb162f58e448304c135fdcdced0a4633f98ab7bfa72b7edef3b3ac60170a620b852f3cdb6666e5e45c3cc4eb36b315fc3f4001ef7c5b6dcc659621b21760156901ee852aadc3f08bd3ad5251099b11ba741ae8ee0395e0ddb4eb5ed568a745a8f867e5e620e4491252d9ae0be3776cbf8d47a6a0d1bed364cb9a2cdfee404c40af28ab1c5e4edbdf4dca3fb6f5661f2e29a20d980cc5211f96f2c74781f28ad41ee46c7b3bf325212932b42684060068730164938c54b2e35a46bbcc1ccc7e3ba068d6057c760cc8601c2029b4e6742ec624747d644afb5db3ccff7bece14bb2bf84ce48740519ac4f8009ec6561b38678dbeaffcc877377247fa92bb0c21c09132f01eb6b21b43b2c8752ecb5c298e5a8633396a78018a86d4480e30483c8597667ab1f4953f2004a54855386e9d531731d6d9d147b601a6f5979275a87b9d4e1250a1ff2ee63c5f6ae00863b884c98c3a4902bd38c956aa2ec7e681fec291181b9d951dfe051756390dfcafa999686eb839f600aae4eea44cc3285d087f3d416400bf65203601aec8da823094fdd7d64e779fd4455db37fbd4c091a9fc21673e00d977522edcd7fff60d6816c43066a09e18b713c60b810c5983053ad14622216678705e706da39f382f3bf0248bec07e0efdaa8883c99eac60410e73ca87bc01466baf30c30575df263e1508cf56f92a6f4ea361368c7617b64657147671574f8cd18626ebc3b5e32cf08afae168232a9336947084ac67ea48a0f0885aa623ee29fc56b5c1235e117a16a2537ed86df1c8aa45f7f98282e7ea7b34d75a20b34845165a6b4772ab938c324b930ef278fe38ec5170cb4f53d825b61f553aa4c83321a0d24df4dbac33bf74e38735227a8694f22a9dae14e909ebdd49cf6e490cecab3d9e5acea8a5ea99adc21b8d04ccfaace57524caafcb8a4eeef876b4cdfb8f56ab37028a27803984e4989e4a3668cb2b7f0119df65a1d33fbf4a52e8dca3794b75e4e6eca0e8b8a5c6fa9e881b70895d88190d6cf2b6a0afb05742a85cdbaa698fdb4b22f4761c23083a7e61e1f44e8179cc8e2e48b6d6e88e0101eefc9044edc95def00f421ce09a2a0a46b225a47bd83d7416d4a9f1d6e67ff3580fc53d7fdca0fa0850bc0e22727df21ecbb432ace430950350e3ee852e81a603e407ad7b3c1d9444b74c66fec9479c6ce7e28ddc96d528bd36760b23a4d883f7654a6051114e465ebe901ed41bb0196ba0c2ff02274ee011b1e5dd","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
