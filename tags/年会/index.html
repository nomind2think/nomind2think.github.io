<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f0e69a72fd809e8a655384b444a9df989683507b76c0b7a6764752c4599f9d969ca4a26de703bc8cb78b5a331c2a2b7db34c24961fb7612f2cc5dd194f2cac74dbd88bdeab7b4ac59e117a314a8709d0ab42aa48e3ab1b15b3b57efa5f65400a2fd2319ab95af30007495f712980aff0a4c329fe2ecc276315a4432e16a4cd075ecfd113118384b8c162cab7b00d3f2e87b13bdb054095f63a800a6244c57fa39d259238d6a74408e66aa108857cf17434035afcbf8836ac237c9fa8302fde00ef4dcbd04e1564515a05363e6a5bdbb9ae171726cc05f942120412aa73e2f227b8045371fe0fff80386e2018bf28bf2f6dfb566824b9b74686559b6a6f22a7ec6ff6566f45fe075a442f8e35c2c2f3e422e8c3ff42468f67d12b0e5fdba2872d098842e22605c2f0dc0d79ca94389d696bb9fda6cd470f939ecb79f708be843339d41b45f9d2aeaa6d127462381391189c5c30e6aa43b3a14ade0f0ffa9a74dd155c34c4e6e3f2657371e3fef602b91a0e16dd44dbecd46149852517eafef17c7ad5d7156456ddf6cdca9d62f885601e264146439ab9afbfffef2e46c0bde539744b61c4859ce41424f90c4b662e3452c840b1e80fc51c81984236d0de3a823475f1914fc3592f5e9025c96091c0642957062236080d5d89dbd398f37bbe04dae7836bcb2c2ff9f9fa269d4b9f43a39b1ea22f27e2faa728d856c4e8f7bedc9b07c958f6d5fad48673fdeac2132fb9d7f8f6f8d7bf7aaac44cacb33c7789db85dc1dacb9843629288735284893034d7b9efeafcafcb400a861caf66f66a72727e0aa28a376fc3d29b0bfbe1aee16c65e9a366cbedb3f0c42fca0df2ed611ea3be5333d14596f8846387f385c61326fe39a5190eb27f85a383b6a2a4e6d351040ff1fc2d5f5b2cb8eac0e231169cffdb5ad51b5020068836622787ecdc6e7c4ce9d10c12721e9f4b7875a0fb61c58b09bb9896baf0c40aa08ef99fe1bf0aeb3f986d7c3ba97622bc2af6b96dda9aa133ebdeadb546867c8d9b65aec976d44c57c32c7774d349b83518bfc0bddaa3cff0b21ac0c623c97d4caf5b7e7a6409ed2c09b2b3dd78fef64a6ae49c561cea421e3a113fc72389966c3baba422265ba74bb8ac6ea55e8a89f69ce979275133ecc85eb29c5b160dd94ba35bebd702c2849b088f6b42cf6b6a52d1477b6fe7e2d1578d639ef3069b45acdb4027dfb2eb016e3661c35c0a39387306727bdb6d1528ff5334ff43f359a829e5c86b17771b82469d3232277d8ca1d9d08f94669e83abf16b459b648e2991c15825741d025e7e2599ce438b0b9632639c6a5de4216be467c430705e9e7979ce24d2619bdbd31334438308703e1a05294223c8be951197323dadcc0e0b23abc5623c6e7b625db203a307251273690364c71a13d4e4385b3c8e60b645a4981c6c48623d53198d0e0c5128a554937a9d56fffed0552e8b0cfb6e73864f6f356ac40b30f8fa393006397b5aec395cfd077a715977cfb03b8b28ce8a5721303eb9ae4cb7138a0152820ea3faec5cb6a14f4085d42a7b76dd7db78c9093737b1e2603e75399f282af77c0d6f93ae88405c18d99f57f6ee935c15710a836e84655d5cd097592503fe6144d68f191bfd2b1c044cb7e5529e04dc7e847e28ecb6e260046e74fc99874a0725efa73f7623d3ce1358d61a8159e6c843206254fbee197548c79c6c8dc7207d00598d70cecaa43f51a8eea2428ab4163c4d704f09167a8fe1200b9588a2315e2dc82b5aeccbaca7703d5b783fa1ceac6db82448c07a8bc0cd55250ddf8e1af366c583d08c4efc4eddeb8597b1e4562e051266b85318dbd927f7cf84558138d6a9331af06d2b5560064bffa6203c62a126c7743b7ea2453c09e8529b58802de4f415a7d07fa1190073c543b740506d578d2046a13c6cafe12a36d435e121db2533ad1ee9cef908f96fd7e7fb49ef6fe0a8df01c4ee60bcd3591bee602e734e59378e946a413074ea30802a2a1ab776e0d0e1df0e9d07c4b6657bb39aac486fdf15c040c4c9a1e8f261a1257edf48c56a7df012cc24846ae9a5088b88de5d3b9bd466e0f3538f59435ef15acf52797ba3a1b5fa5da9179cf98db349d8cfde6e3d4f22a57cb084f74f407973eeeadc3963935fbeaa5d96b871ee57560454736297b3f6e2a829ed5ee2f58b620d39a74a5aad37cbfca0b6a62b4927304ab0ab7285c92dac6c86a577ca728d40f25a2f9722f8333710027b8ef9bf27d4be0ece7ca6c436eca86ba8c2764463aae5ecc551ed9a64bcb0986b0591eb63e6ebc5033ec4454437ab1159c259ff85d4e7e46372d82efaaa7acd37b5ce9f9fdc53e2edb8308583fc49f7f82c9549eaaa44173bd471d12b5d4c635ffcbd91004143f05d447c24a8ab46aac14e0130de62f9f712672362c407e283c8951853a501d8efeaaf7647a356143e129307beec9cea3f00b252384e5cc4df1aa991bebfaef25309d5ec72edaab7e832a45c9a109051fac875f2f0c5b0c3ce93b33a900304f88289a05ed0cffbabbcf5a7ce48e6be67e7304632baf8f9ad4f20b69088f051a82741a1e82e70c3645cfee29d03eb0db5a8f8306bf0bda6dff393dec4cf3234af8f787347b0e27fa2c2b0af22d604a944c7e6708ccabd3f2d8e2e7afa3d4cfaedd77862dbea48ac2d43da7836a7bd6cb7970120c52f5f022d5285fe34e75fbd7a8026586bba5557588f95688bd5a25671c1a27c0f72a74e0e9b4f6d52750bb929cd4d480e862b1e97e457e179be1573ce6bc3e8ac5f54f6313ce35cb7385288fbaf538360f6b604853fa44e71df017d32d67c745ac859d024272aa704c3b07513fc623784ba71809d199eee2d4706e34dc3cf108c66f2e3daf6269c04b3733d853ba57e2ca2d38bc32d02ee8868245a2ad112ef7493a9227a2363e2131138ef29654626d88c64680f0f0104dfefad4750271d2bab225d8ad4d55cba8d079f26746bf4c31d6360ebdfd241611af2df433f59007fbbe1e4f14cc2590f267b727cd8875b76be9f9cdf6cd2dbd61e4e5fe1b2d0450264b0f347950607d4ef0220936c3b4900b7f1c1726bdb35b03856e27ff97a5296cad3a6af049a7ef9df013a9561fec737d2ea8db9022a715631943144f0d3bd6eff4ba434c7f1135dab230a6eb278539adea53981b6331f7e153a463672bb2e17fb517868dfd9468b21d5569868aaa03a2c86ec14a345df5f6ace30a74976d8422bdd80cb32d09b5c4d6b282c60c35194b0fda9684fe244852675db424a95f7f8ba529378b770f8de9d302b0f2c045c137528aa2982992ef25a4cf0444e8df86deb5f11d1b565dffea7af7613e8e0e6ba1e4382f89945bb79bb61ee985a9e2628e33a110e843c8c799c58e61c6af9257611473a490cb5210ff7627320d09921d3ce2be1ac876680dd3e876ad67750faa4429d8c49e752a5ec14c8531cd86cfb56cf48640d502b5cc42d4e5a2bc1c7877cc35730428f275881bac8767c47a6dc0e8944ca3d946cb22339cf1c13f33cc2b0e2a52d3d2f7202ad24c969180cac0feebaaf2f9d78d2ba491c12e39d59f74c6165608e9a43551de3ac4d36374cf8751894f39f8606396d1d374a16aae5e3a3edb1b3d13410d0ca021ac2502aa724ebd6794c27bc48b3a985368e0b41bb46c35e60e8f156033976bafaa4be55d6a4d8cfc9cb695f2fe68ee2b08b18c5d14bfb5903ef9ba14ebb5c17e72c5b3c6746806e615b2e5783425c4430194f0444c89844273e51fd5403d1a248a8f4a50597ee8955c6d75b7b80cbf9324881b38fcaa1a7dfeb92a72556be971861aec8234ea0032a391e38780ed5ea3ff12bd6f0f87e522f672562b8f8c258ea07408ecc792fec9e537300cffd7aac7e2493ccc51cd70d8011b1378abc59807b171f6fed1862e5611dd2581c54f89089e5107935680dbefc9ae073d3cbf9481272d038ec476f69cdeb108fe9bd6d493a782f0fd085a7e67ab20667004a1162a4423ccfcfe47872f80d4864556583712880ae7adbaa0f74ac752e15815937af0f8f3adbb9931df8fa764ac3c64028e2938853bf91db6bb399399f644854bc6d8fa9fe581e7ddc64289a136284a9cc87da4a1543875333fd27e69f1e19e839b19faaa2144e50ed4dafcd130bb7d68b4017d90c57af794dae73ec502b8c331590fe28d1786dfd21fd4a0913b3998c44046dfbdbd14e5abe27844ab6312eb4157f3d736fb3499ef6a32c1c610efdfbc4eabf7daaca83bc481eb1733baf5faa61da905ccb99aeb139a9fe271e8ab3d3410940eda28139c7e2cb3ecce68f6d075d8068fb7e1084707bef85a312660505ef154869497e0b4294820c26a375786891b989ce563c111fdb82cf7f93a58ff1714724ff83a1b197b5b798521dcec0753ed94b994411c39a4e8a942e70711138f5b17323a0bfb1d49a0c4e921593c04724a99b80b64cd8332f67ca62b145007ae87d7f77b9ed422e2127a038f5fcd6ba104c1a93d5148210a00b1b8db066e148e65fba42e00ede7ef2ae5d301a0d3733f3167b3982b811c1d5ce55b7d2841dacf991afdd4097b343c8df4f197249d2be420bb1b0d35ce10d76d0af5340b19d640d5d5f6ed3acbddbdb04a14e71d7b278995ddd5fa49e8616ad213b1bf16dbe66e68a3816d67008d26f5bcf4068f71fc5e16793f53348aa41ac7163dfee17f7b73c8f33e05ceafb9075fb1ccc1c4b05de9618cc045a4ca9dc9120430dc0de9450edd038d0e4fe5ee1758a177e79f3ed0b721e5f4dc4032bfd9c5aa3d0f93c902103674d5f1fc4842c936bde629838466c19a0b802a477203ade525e60bcfc674d07dd353c250c39d0f0552d001e046f636b5d0c62aac4f1ab72eb5d3a160beee003ac9a26a3c6d1dd9994b6fa236c6b441436607043209bd02abd60d6af6f6c8d7abf2ef86d7aea0dda235f499fb0a74c5760d77c937cc02b93c24701d8c1759d1c7804b5e150772ade8061660e9e58c5095dab5921ef53cfd673be841dc79e8f36980126d273d66ad93b9e206bb49aaf86958c20b1de274bca531aba3eb43348737f30b1a859025ac566a6fe5492b479856a9f9a7cc0fa4b6ad2785e1b193371817c7fd465b812aba7911902b10aad53a83573bd52ffa520c0e14d5a0b4f6dc721b50fd7f5d7b90fbf540ff1f5912730fd04309774ccfee6456e1a3964f2dc20702678a8587e83481efe01c826bc329347d11af32aea899a140357789664c622d3ee1cc6a9392752a187b88d0316b07a33bd1bcfd19f5a60d95df3134823f589c852daecfd4c7e479b6423efdcb9c80246218dbe5c43a1477c427fcf31d110f9c8326abb51de709d223dfbeb443292a733786e4203f1162989996433aece63d4aa53e1ce41dab36a2fa7ed3f16edf2a125bd4f7d59b751ad84744c2816c3a32599d8d7dc2ebe092bf31094fed2cbb147f9a226c2ce1c7c9dd1a05022ac8bd809836941a276915349c2962adf85b51a901f94de0c6cdf717f32933585d197e494302ba2eb9e228d5c3a99fefdd2c2962734ae9f9abae13253b2379926c9960d971b49538091610b975fd8dff254cd5c16f7967c8242f1f9bcca99aca2034d175d684a6415fa65a41298281a381475e72a2a19bd13765dfeeb6572ea0245e9ebe54f715818f688fce5b3b1c77c477f24df414cb22be7be0aa1e08fb4eaa059149c77a908351cc2eba1314fc8feff0a25f84162da8628dfb814199bb0a17ad6c0a1df34c7ebd8b847256242ba4a41489bbad5ae3d88a3727e26e20941d4e7aa89cc6fd8c038746aa811a3ed488d503453465712480716cd2c58635bab8318f591af2d7065fcd7a997c3df1f8ad61b68fe4c3b0af5769ee0831abfb4417d5327bae4b7b82cf3c2defb20563ecb2bdacfc5144908559b9c8e615a955519dd1c6608bfddbf2cad0dff9338b7e187d941c4de96354c98ec8edc9f484c4bed0a64ae80892c55ae6cd4c1af8527fc24a2500e141d54bd71bb378bf9fa75a4cd4c5e1cdda07bbadb2e0321f48c4019d964fefa4920fcc46b3195d16f78e8c134108b54b74e3eecd2156a73a6f72d3a1e51cff4adda9fd8f0009db83c57be3edda674e8b13ee01b2af106ee3852fff697ddab003e4cd7c04ed379b34f3499a82ba69ca1121556f84927f8001e99169e8e607082bef9149c7b8fd82272b297e7d71042cda84148b524a4052d09aaca1eb4dbf3e02250ec7cd0913ace4a82f827bf8422a8dd504b1b600df26b263c8d4aae6adb2ed5c13dd6da865f3b36549be5f199354aa571db7fce390b231379be87e4c0182a20115f514a354834991365b39ca11ab51892b1307b4ff83761f8e300d0ba7e794a6dc1957ebc04447f01114d1b30e38128d5cbe4694a200ef0f6992a3db2fab2e2884679242329a19bb850b548aaad525d639320963579f818cfb5dae523166b8c1d7ee39851b18d8f335e248097d80fa64868340f0a75bf735d152f7161ea1624a0e22b9f9adcf60aa45697727d21ef9ceec0c2e16c5bb7845648b843537303d6bb1b1440fb7983fc64c05b4d76e2d43f44a68702bd20fc4a0da6f10965a577244f5d572994de31db39c04cd58fc6f9ef1636ac8344800f3a8d31788e919d7fd0448e142bf5154e9e66f348d49c1fdf74f14a2440049033b4ffc6c591d02f668096754fde4045efcfaf1b13a01134b8191ce41c9f5995ed13dadb1d62dc81b7570891134faee1c2583f3d37cfba98d91c383cc8dda70ab20b69b14282792c6fba151fda2323224a25bedae9ad6bbf279643696b331691cbf6ebf216cafe2fb5570bbf62df66cd48807e1114738d8cf4d115d099f296732ddc6b482112c914ebc75b7fe9b3f749696bf605b434fded6c16eadfca236ae98795f963cb7ff7e73617fcbb4976198d69e93b36e7452d54912759d5a9a92a9ecad674af82fb197a1722e8ac0e9564f53775471d28d936e275e4a07c903bb8ec39622f23fd1dcaf25c0b7538a371cdb6d264316b8b6f2b89047d7700216b27e71a398bf4a07bb2dd6919264c948ecfb909e90ded604cf0fb65f1164dc51e81b51d5ccdee757fb7c951f6cb4b21f086b55d3069dd896a77818a5c37345dab785fe5c281494b15babce2f3333acf6883a0c20d85b2840d179dd58239dbb4f791c0cef104c9946f8770d6a3f0d57728961bdeb485654244313a4416084b6dbb64e464a121d285fe84dfcfc4391e68fb56ff958ece3fd5384b2ffb00f88e98f86e8d8e7f77c3788c882331f6c2e9f77ae772b42dc0fefb6fd63e794f88382a1ad258dc318e58a2d5960b32b5d07beebf7dc3b617c1dbaf1435f66c66f37efee6e75dde0aa1dc1c51c4efc4ec6ac0bc91cac6ded7cead2dffc3b7b56ce8010a110b73b2116e41dd77a3ece9e5b36d64a1148176df87ef409ea6a5942f036a472ff0c73437fbaec219047e9e7b4b6b114dd93c86d8407510d85ce1ed0ad1510fedfd69342600a9a0b94813e6073343456dd227293acf9b1b3435c6e6e0563799a44d19f3efc4a233af84ab623c7e3853e6968b56252590decee907d7ea8a64724bceb86fd6e2d20a7f3a66e594b3c08b075337bcdd51b7b8a3d4565da2c8571afeb9edfc76f5c5043374b0f4c7139cefac712081da8de40ab5e2e1a4616f30ce57062f0a1d178eab1dbed16c757bd440bc8f5d6eb28df11cc2922b08a594071c5d018e9e39577dc7111ae92810aa39cb5797461a049282c14ad64326875fa8af0fc5c643c92055073dd044f42b51353c43720f88e02a0c16c53a7593a0d966f9305cbf4cfb3dfa20af4e494c9f1159b56b54d0cbd34dcf2dbdeab877b732f02c24967483c7d1a1d93330c964ea939eddc2b2f2b853931042b92dda906699bb7a0a4e0a83b1ff0d41617d05dd0b4011b5e53579c5afb19cf9f2fe6a08eb261322f427d345ce40359a6d37294534d7a81cac7b9dead34807b2f09a1ffa3e2527acfc621abb6b2464dc9c9853ac2456c9f1997fcfab999f6ce0568ba6d9be1bc6ebb2b6dbf79bd76cb7fceac4496abce789f7ed7431ae4f17701acdf5ecf5be8fb172d18f73f6640a40aaeb05c5318118271b9093ce1d73d0b3a459787037726a63d7e255030f17e1e67d3bad550cea8b2ef8bedc18d7f3fa716306b0b5484e427672876860c20aa38866f554a32abcc1ab1468f3904ab4b9a593f9cfa50ed53e11fd6c4b7d3e766957a7de108960c9159642ba6525fc57a0913737651b03228593fd7d783d59138d44114b75cab318ab89fea43ea79aa84be15113d33671c3d7205d7ced2f926f84e4a1cecf4fd65402c72a8c3c716ec8f5e7196bceb7e192df6f3e2c4cd410d74563f24e237455c8213316bef7a01f08a5767f0804c1696f1ffeb27ba87cf70810655aa5ac0c314d1a4935a958d0b866abc9aeb8415197eaf46b28f709df0892df57ec26bf057bfff38efe49dea9967e90cb18626e84860af056972e0015830a80c074a5fc79381a0a1e631a5bc2bbb34d4c6e309c56a6b757cba064e7afa3c533d6bf9cdc495c28d5b1a888ef07afbf704a319f803926566b45b40a296e56a41d2cda3825e3e2dca2446d25a1e3da78e5b21b95ae032f43054892ede151ed6322ddbdc1c38e79aa956304993997b0307a0dd8a81ceaaa91d7c761806b44f0948de158cdc70756714a10acbf583ace84c95c6c1538e2c4fd917074002e8f1473a788bdb574f9da5f6ff66ead85ef4a5668cc2b7238d5f503f91ee61a0af401d7a522e25f0548010dd9883a7a1fa5310bd434d7de7b3c60205450b1415f1b345c0b6dd7bc0ba7d293c2a8933b2b5bc0f46ab0d61169f763bed74b6268fececa7aa7a7481338921eac31c4f42d5dce8760b25e246ffb125cb5706de3660889851021c239360aa5193d4645fbfe9becd1ee7bf7b193cfd36fe336f0a15adfc1a7adef656eee5e471033fef9b00f6784725c3272f6a0a2b24136b45466056d3c1639a7660fe23a8f651bad67f324ba18fa084bc778ea890a5c05df7ae7d2afd66f00d0dde6ab32476cc91c46e097fd923aa6df941890e6828b4c44549bc3c8f7badd75cbb427b888f77c8672f781764bf70c64c569588b0e180a029dc86665c7815c6b49420087f1e9140dc233e9e6dc0894ac985271f3ffbdb0bfd0672b54af46708e1133e1a182e594633c19c99e7511cde3f53fff975e225daae536a69f64028024f957b373fe8c90c25c808c0a4600801fa81ad4f2dd475c09566fc08879dd46f973f73ddc76e3378a030b93cdf3f8a8bdb48d1fa71ba0a839a6f57051b64aedf98397b1fb410849e5bab672f7115a294f72d9ccf0a8fa43d5e22adc6568acccc66f6a932a6e8413eba8758535cbfc31a01e5c44e1907cf597eb1a6782840c7253cd40bf3352abe76919fe670502952b667456b9e1c76903a3fba3b8feff581bc771cf09872375705c064eede552dd7af94983f034eba51ea0967270dae0e10ec6021fa4bc7b49d0b0bbc7dd746699b5506a6cbd610952ebe92deb6892a81abc6b68ea4745dbe9671c9a460fad3025ef99405d188949dc8c992c5828366c821b4b8a742ee02155685b41fcba9caec1ae7d89b94f3cfc55e82d74001d0e8c14d3be9302bd8303aeb87931810364128e5f84cda5617b2cac4898a5c96c7ea7c36119bce0ecf83592d67849b21a4d43adedbbad9af9cefec12ec7187ecf6c7e18e43df10e06935c11bc8e3abc3aaa18bacc65df62441f4dd6b3b27b9f5d7f11fa14d7652f431c1fd72d8e95e82548db14530a5b7b96eebb10f7ab0a681d4f83fea56f6512df8c76b63d528a1101af342911d3770fe5007258267acd076f939092065c81324c4d9d86112bc92a6ef3b80a4a416c722002054d15cfd1205b494c23c092be6627f3328bd80188f68eb11287fbeef109201ba42ce1fab81a0076b03b79a1f7eb9cf945095f7802ac1eed85e8a7ab6a1193ee5586b04fd00926b7e64e17d8798a771b8d667ac3bc8acbc153db01e0cd9721378c68af8602113d7c9f955cee6adde92a4d97d8631d04a52fa87ab68e82f533e69353acd94ee274bfe36712c16658bcdf58868a50b736eb5c096f2e672b57bd03435f04efc592c97d03accc7a9e8adb132b143cbec2f44d6cbc61d841e63047fc48d1d51c6ba8b4a540df6d96778f4d0fb1e0daab42713d175c42830a5b154d3cfeb3d0c0fe68921ea48402a52427d3e1a4f4f1c8522dfad53e71a28761dc83ca6644a9d45677528ec771929ec5bb756568ea2767035c1af87a7fceb87f243b15602828f9ceb78c491d15da88a4406af2a5b0b6aae4d157a01f1df192ff1e59ce6a95a3cbb9716f59981a7d935696b5ae","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
