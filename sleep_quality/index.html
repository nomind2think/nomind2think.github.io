<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9ef401da0b1bbb4a7baf8bcba538b8c0d2b6ad54acf25676e4c2ce3002dce10ae7f05c4e311bceb65abae64ce2d52a2e7cae64e96d40ac05db0bd12a9c05ccb5a318391d577c6638be8fcfe5f45bb53139a46985e20fc8e9fff22bc8cc1bd33cebc6a2ab132b201246d83eb4cda332721b6ef33e764632f0c0ac49605ea953cba77ff31c15153efe57f25f9ea99ef34f5ad2a32d4feb6013df65fe946380e49c5b513e14e1045a9b43e0753dd9941278bb8594182458d810b05efcc420f4155372cde69ce5a7d5a51b9534d1cb0f0e0500ed8b40d7669b8902530331c35e9f46cb505d0bd02de5900970026dc8f3ed59c34a0acf74f77b60105cf42e24f1c0029095a0ef89734756779fe1681f5ec4e4db14d9e914064a9126d93b263d0faef756c7fe4f37030c645a0440d47e11de8c8391042ca58ef36511d39f99168ce0e04f54e3cf2c7d4969fe3fcc6d5721f2092d21abcf6e3a3218137a9073a3d3cd3d650dab322c16bc510350b7070f3358a1204b60c131ab9a35cfd9fe21d7213f0d2677b48b3786fd4437b3a831e4620f1f3c0365fcfca419a96dba75eaba68e6bae081922a0a5c54e99b357bd1110f0454758f1284785ea78db1c0fda46d08b66c1104410b606d635d303319fdc8fb48df7bf8d8777c9f56799e8a3379aec48de37a65de8fcbc84d5cfd296e5484e707b2f4793f068886949ca9faccbe7ad7486431abdb3b19c26c38e2a8e08129d5b79309253c4b28d979e9b147df7f5e1adf744e97608ece4254cc83c70573e1e11b8de573cd9285fbc5e46086fc16c71f41252cc50ac83c6da656f9fc60eea6b328834aebd1f7496c198d0b76fcb606f63255a063d1280837953930aa9da1321f9adc21eb12132e48e0116ed399069fdb07566b34c3abe7d7aa31a2a05678d0883e6039979941fc786eb09b24c37a7f085470679d4f88a117e3c7e03d3d2e6615d90207f8359fa4d24d1acc4ab6a6311831814dda5d5555a9ef571efbaccfc6bb5e795826bbc276b87d2d000bf9ebcfe77b6e333e84b87abe7735ac68a0584b55277178dd69da5bf52fe8cb39c90f47441766c0445c88589bd75214b45929f4c46d2430e4fb4ee334473337cc5f60f62e7cb290748f8b3e91771fc634e9239a5fcc9cc677e91f4151e009b131c4c53b01ba797c2adc6b38bde6c37dd5f89952f5aa43dddd844c3fbe20b490cb843766a93e9b831b3d7291e788136678662b18420055fda875fe5617060d172283aee5385f942db9444efc4fde444d2fdcbc47cb0b0182443d42f9c67b4f4e93cfdc0d8f5e48e1abb65a4084689c20ac7051e41741af19e401f6fbcd6d2b95c5cb8a4e0a1b2073adf0446b15c85211c98887011c69633557addf71b361fbb338969a8a3eeca80749827c9d2f862857629b9fe5a1ef06ed71d021146690bff1d8c17e23cfba60ed4e377492a8d52ab1a2cf1bac09e3756044081895ff3d9298c1d64f4b4653309911f29fb5fa80860ad0a4f79a743c4ed24cb406d8893ccdccbb964e98c1477262480664b897e042c1e8899969da1946258c968e91ae07db75f6602b54a40500a9c4298cd773b6485313bcafe2077722b5df871c7bbb424c5f306e1f99bf2fa5c90711c6e326379296bb3e948fba16b202a092cd9ecd965df6532335248e8bce78737aeeedb3ef0e182914240e889dbfd281d0b82319f6221673bb310c0fd5df678553cfd2e71fd02c1333a5369185253a479327cd6ca1c3dab4ab54342fee628e52ee350038757a4bb9e9cb25b6ce1a02da7a6c2815fb1daa1757d7876e50d7c41113e699e912ecfbc73fec43166f01dd830463db3ce00f6de18f523fde5a439a041332bdcf8390971f63541b56a75a153864396d8b23516a1af44cb59dcad0b36ca5f802484f42cd80a919f6d3d0d76755377c3a8e886761dcce33b54fb3ac91e9e4eeaa16fa9e8b00f63a9c096cf689f399a9374c7b8fe4b17972a533da4426b0dd79f5daa2dea818b4f4aa8354e6db55026b57441a7b2240f651dcbe41b99a42997d7eac35e05c5fb6d1f1e48240afbab2e7519b842479505a0912f5de3dab0520a30a0647894239503ce2153abaf7767e74089f55aa5c01081f58863fccd1b3d36368ea5afa09fd390e87f40b3b8d86bc401de33099171a26df877c313e3d68fad49716e63057602e34942983cf7915faa985d698f164e4d3c7c168d3d6fe58035ed30eedaa11dd868cd51260dc37f8c0e9ea0dcfd10c9b8908d05f071031d5960bdbfb3fb99e0c966d1149fb086651869fe634d198eda889efb2dc1ed7251dc9aea049e194415af9aafa7a863c704cc667d28a6d46e4c15ac46cd5faee2a4fbe42df135e7689b70ddfdbe6f7a669f94272d078532fc8eef98968e0e155e45149a9552fea3206fd47e5b05c0a970a037bfa0d6da9d30dc933cdb3c2da77e79ddc245ff88031218c6f904cd4741299b65b1dce1deeec5dd27d945a8e76279f573c22de38f62eddd635c0ec6fdc852597dc99795d1427043dd0e215cf09b0f8fe872693fad6271651b01f199052f577f493237a70c7fbbd27fc539ef56712546e1bf2206e248acbe63214300ba3179fda916f854e253fb8d0a02626e49762491b5fbd5da426f14dbaf303b676abaa3e5169420ac780e95c92c56c56562de07a75e3b3a2ea4626372051aa12571378ad59b7f6a509415932f91ed9f1a1245f94ea7a76a131d49ed1b70ea22c630467ab93fb9cc9acd1ae585968368bcecdb3db8ef581a9bc158103a184b53a5920a0f36176933de59ff45220b21d475b0d521843bac724d7fd6699034d5fa615294f6ef5f1c78f8d5e07223c54898633586891814a6396bea479274312048f50f73719da08e808ead58c4e887e1fff86c65728c8644ff211104fe22e62bc55532700b9744b1b112d20b5db39440e2869c85c24a53ffe662bddeb6dcf61ab0de7ea3d4099d97d1af6dbb2ffa2289b0f54309f17d05722b92ad98a55dd905528e615049f104531fb57282fcb9be5c171ba82f74ea8491d9b59277dfeeaa3e7a31e878d2d3c931be05aad343ee132863995d81871803736c83e62910d9e9ee74bfd870eed418550c8c03efc82e50b27685f18e9711dc78a0605eb00efd30f6d6ca351e9a5d002353572904ae76d3b1faeb1a7c68724c772ed5290f9c0e84202e3b803f9858566f8b0a4156c72808b6e9b74656d531113e3d0c8914fb6048b12e55778805067983ba2669c16d9fc545dd81264103ed0aea263a8edc9849f68f74c0a4e1bdf2b88c2c055b44ad4550dba99c838f27b694a4a7fea1f109717ee2b8fbcfdd834ddf7e66e8040a03c4fd6d28bf69de8db60e5b9694faf4811f5db98774a2dc9f4e390cfab93d870a04a2f3cb79af968615d3ff650216e0ef06a22e548be4f03f028b0ac0dc3450d24afd3583dcfd7a27715b98a82493c5d67741ee5885941e406234cbaed10c07ca739c42798bddde1e41975b30ec95773437b2a4513a83b33c1c07f4c3bc5c859fd2c355e282281393835d920e18348c9fa7027058265f72fa760898ea155f776a4d9dd58122dac06afebfc842f8b9b85ebe82fcbaa3efa9fb0cc8eff9c1762a36110300991d26f48b2718efcb4e35c51fc55c48bc4971d0a08c2840cb11d2d0b88aa3b07a262e8f78280e21068899f3a67ccd61867f6000a1586f00698a5486fdda1f123f23069dcf4691c7f29cbc2dc8f740f6abe94f36527eec81fca4e06c12cb319dba27f0f6518e075b06026b26f2c2ba3af685cb1d37723e706414d12be78ca0fd8bd3e051f0fa033ae5798bbbd25674b43490d15cd4a151a6a54567c50eb9b1698c03d1e0f37a2ad84c80652dd7769aecd5eee44a1616770bd73f3552bdf7e2d3cb3daa7321af0b1d67a887bed5f8549be6fe7cd4742d752ffe6b54316e9b4b1bbda80b74b206b72a301b788b6298cf33bee2ddd793f9aad009e8c079c5f23b1c17a28c301e657cc9fcb8c2f8d6c907aaeea1d3b962756b5e7811c78ee68d69829de11320f4b44849b2d56dff43ae1bc2c655198fe8e5616397033375012d35a7855ada4468c491ee395e8ad124accd42f8db751392cdd42196253f78cd651e72d220df234fa4001437c1f086f8b30c163a98e5a9ac74db1074b216fdfc8c4c6141bc0b3e538f56501b58eb7c512eb357bcef3c815d86b5a57ad9405d035d594a0f25500af593c07e998aff97b12b1c1677e7d4fe621b5647f964bc16983df23a9a0aa883b99b011f589449fa3e4e44ca65190e7ffb24e43dbe6e885d194338658d38dd752a11b23725f4c865f6a6b8b5b469a4d2124e2e73636798fe6a797dfb4d98ab4190eded11370b1addedfdd666f081f3e79efe69f98d5830a35d037735768e32df9f9f5675064737431a952a9a7a7f625a8edf6045d75bcbd398b4dfd73eeebbcabb185c98c5b0bbde3e94adbfb4f7cb6e0cc41bd15ba65896f6d4e481c8143439030d88384e77cb2487a2117c6f8a906a130b9a68fab1412172ba5b2db3a512988b677d680c9fc3bf56873a9fc35877e1d23080574bc2fc21d03a27037c178ff7d012093a9c32e78a246c048bf679151fc8ab0ce7ddf758df3cf1ea61d6a76a4b7ae032ca484d1f18b9b500e4fcf808ef43fa471f2b527451c0179b3985a55e52a32182676f4d3a9d917a5e6cc35a1be325a2ebdcd4d2d514138f29e114e2014c14b793fcefa99c83d8b59b0490160f8d63450faa4b3e34b5a98daf76094c04b6a45e8198ccdc6731a525afc2d68c11f6246c8a1eb884018394becbc77e89ccc6fe91df414e7134b0b562d834f17c4687aa24eca4ba37f22b290c4eaff94dc8d8b6d1b46a6dca29ffd613adc6d5d3fce543433a53ad0741f5118eba64824b29a19c9a3987a0a9a8dd5925f043109a80b82a73cb653c7c688f4d7c1ff8a85b9e50e5dadec0049e7e14fb2399d4e25e23b75a7aa954848505345b0af2ae53ac7db208c9c5549d9e8cc005bea67eb8065c6a1f33464ea44fd44634e6fdb4ff68d3c965db23ab1cdfd1eca45e3dbc3f976cf2f45b3a6bfde330db2a55b392377851da25fb31a3cdc60ff96fbe0434dbff996d5d13e4df7cae639fb9e49ceff5c016b6989993b009c93a1c502cb6992e1ab64b3e93c6fcb2072e7bbf6a0c47147ffe993d86885f3638c1b59813f55d5f1b10c557df8fe0fe1e4bb121c64fe946014905a7c04820ea85f45ff14caf5ed8fcff810600147e81a904112924d9d35e9b68fd55365a4579cd5c282eef95a96b25b3d7d38ca446d22994be31f8cbc806b97937c871fb114f545fa0d822d885fd54aa516ccd9ac939a4e444b86ff72eb874fa2e23a919aef0b18158d136978085a1ba3bf79d89ebe927c99e633a933ee04c0e890bb36651c0b8cf7185c9b835e43f1342410eaded86a35ca1b49f567a51a012066d040ec6169c0fd522410940a5f9d0351d6146d358173e0771d1fdb079d7ee467d1912cd5e11dfc29041be38d586a68843384b6e8f42b336ebbbac45f0d673159f6d986c523f0336cac0a50961f8c3db2ee215df324b7913a06180c0b132900cc4b6573d9cd6af3aaea787ba111607973bcb3baf71029df50c2593a6ca874b26db94eabb9b9f89fe6a9317c62dab4bc61bbeae10eae9810671a3a476ae9b3e1bb473575f0a073dcb03d85997f28ada11a26a1491a7ea5047e0b16db47ac03e8006da63ad9dff633d510c7113c3e7376e52c4aca8cb357991bfba5a75193c87f4572feb970d02175c838164e034c0acfaacf187c98a64bb3a9ffcc889e53f86d1ffd498e67065185ffeece16544b7abb73e7bbe0550ab1b7a1136e427d8f725d2d82ff82f221d3fbd18553bc091d99cbcf2fc8567dbd76d7b22a483d655142972bdfaecd46dc7daef84128a94c6eb7571d3fc72804897bd5ad430a29eead920aef56c150b3f330455132217e23e0a668cb73f7ced59644e7474aa6effd576089410cc86663de0af720d4fa6b0a10eb1367e63c6f76e79b017eed4b74e6b9432b5206a9fe966a1246d8114f6bfaa6d08e277e74c61206e9feeb34e8ee87d09337c1ff6e6af3a2fc6a3e43517bc42d2c7ad6c606a14b62367c340a0cba4aca60325f7060379d57e29db596c68132a4d344d7f2e1c9416ecd20c78cf404c47c416286aef889e067b269c6c3e02efd2f7aeda41cd8ffeb3f3354c5d6fc9a8636ecd669a6b3030bea0c2a169e2542930cdf83222a0ceb6483be602e84026a96f98a73154e8ae6be2438d8c95603c4341947aa61113da9e812e56ae87592ef9acc3d85be2353495632a581a3a1014193c41ea39c1925663b5204629e0a37926b04bf50e0c1fdff0d6066c1fcf1aab679485668cbb3ef511b7eb1d64b531e6205b9f73fcf8a0635c02126df94c004789f459a3185d8b4941256d38aeb20c8bbcb1243f17673ebf9e186975e64ae6534de6aa7e36bdeb9f630786a3b263d62e6b3525c66b538415565f2112570f2f4fed8ebf61577cfbe4f0c6a85fcb3ea8f4b01bc4ff0fb496d547ce18a6bfe6120ed483cb3fdcfdc01c148f0c6f868a6b4e9724524e85d91d9c582b6ae973227aa6769c25bcf71190ffabfa68009aa62868b13b71e774ce62d72fe7bf6e7f0b05e8d66d94d1b883c70d2c8b166108e4d4bd9c6951946b62d922bdd0f3b85d4a36e19b33416252f557be6a460c05b7b8cd2a17869b552e4fe59542d7df8650efeef0d30c24f27c9c8746f786ea1bf213b62a79c8681688ebd1b6d065b1a95ed8e9a5d2880956a58e5a2c63ea43d20d2cf32318e9537801a1b1f5d297d6f09de0dd4c17872230c136aa12bfb03774c511c4b8dbcae55d955b945916107e947b22d5e563f24bc4de25eee9886eb53e7e6b59d72b95e4b2c1127d3b6f1b325bc9db9ed226e6ce4e4ba31eac57d2718a738afb5d1b4e11d07856324c9f63777c01860f0390e2936cda509059fd1c05dbdac3ab966fbbd398d6601b4c877dbc6c6fa34c3e7596812eb57600a73f08a295a94b107982f9a2d49997ad06b7185d70954df0f56f02193c5caf74f3835b68338d6bcb7fb6e1f488e0951d71a5fb0c2160aae35d8115004f45206b60a66173839882b9615e8de3f1ecf95f00c794568bf8627978459888e214f17107dc95b65f08de1b5775b8a5c5e599c3abc679b25ebdb1f632195e3df8c093b198a07eba373606b6c3dab84c08c45009cae7ba09cd4025d69894a6a80ddb216ab4582d5ddb1669ec6f3c7489d388d479e633e312b31805f166ea9bdb9cc27726d6d201f53dc7c4ac341549af90f69d9537933107b62a64d593f60c9ebce1fe4a94607296958e499523d75766c3536cc2bba4afdaa16be8a549651c02e4e7bf02f63b7894897db049922c833e52946d3a3a30c9e7515f2086aabd989a1feccff6bfd3e34c83f4e4ad9cb8e022a586edad6ae2b240d74d1ecc5f5cfba7db08d4c4ae4b1cf93e388f20bc1907f1dbd43bf3d76bd2766e1d3c7c8e1c27b679358b23ba582c11f9314f8611d0366c20a9717a0e6c83afca432396bfc054d21a61486702441043aa916c042e855919b9b81403c7d391c4e87e96837cca86f0cf7f80834daeb563073ce4a01ef93489be55357dffcdf3e1e6306b69755b81ec88b582ebfd677f806fd7189025c6040ae95f6fb70aa11115cd69b1889bcf6af6ece38944e9fa0c6216c80ff08ce3028a1631a9a531cd78411829b8ab1f908f1089ea32f38e609f51b4c6263f8d1d6e3a5f1c594b5ce77977445e114c0efbae60c11c717ef0fd05f573942a76cf156be19158de3c7752c74e49676bf0633a33b07ae025be2d73347c657abe6c29e269650dcc285ba59a03150772718ce382b7e5bb60be57c689183ba3ee27cc91c22d8183d642c34cb01f581b48c6b6d6695e0e76ce5fcde5f88a43157f9903a40ff8fbcbe790082b94dd22ee2fb37dd19b078f4a15afb84e4e0f91fb30c11aeec370884ef0af624c42e3a91992e867767099f4f5ef79501300a3cb4a07e0815d8efe53e64075cf51d33be6e1a5fa29e53e896087050f97e3e378c24165fd8752f74c9b106abb026c3f19800369a317fdfc28199f8aa81340963f3f812d525ad46eecefc5cf1b892a540b9538a0f2a31bcdffe3ee3fcee6072ad423e8ec498c2b9f2dc374237330fcee75a825c6dcbe8b605a07260bf17f4feb0d85554942e3b16248449714222b4ce3428b94e094a06497437ec2812c6103afafc167c37e7cc68c73a7db5472f850ef0bbc11f5fbd244571c2ee7988d049cff27a0ab4dc6cd1cb36c0d303d58b4ce8d1d9ca6fd8e1d4cf89a1e012c1eb5918b2a385b996e9a9454781f142c9a2b32a9e27d850385cb9f20ce5e0b432d2b793594c4af9b39b8e2bc3a513ef0e15f899dc82cbf2c0fe989b9501de0816536d950eeff5e4c08fce77097f9aca32f082e51edf5cc05af83f06a7052af29169e13849609183ab2a8595365caaadc71fa27aeb7540d9e7e12690b7e849a105d4dbc02a7a5563f1599b1e172f55a3b6155f41a329a5e072432f70cdb09815c54b99c3dda90628181c2bc1c41aeeb8e7cd3184fcac0a4dab85aa71aff13497696cd0ef2bf89a0bc1253435fa889af9e5b990e05b1ebfff6efa5754f3914b9e4170965a0ecab5eb585ae396aef069523de1dd9887e6f9d597e9956f6a30b56a1f62823e3f18f4c001ad4e0496cf4e5e247cdb9a79f59f25796abf9043d60876c1c7b31ea13036880770ffcda2e83542af9052867a700df0dfe6ae94a4b8a1b3238d986990f9746856c8f27d4f3e12d8bd1750a1e9848dabe00b6e00e0723a86a33e334506cf58efcbd17d7e51bba09c4fc8aa2628521d4a3a9202d6ddce99ccf2bfeef662e196a74d44d23e075e0733cbc917d8f450b4767b849f098849519240ecbdcd574dffb7cef943bb70585044701eb8cd79ed75c61cd891e36ea623e20c8a414f7d461f4f3f23bc4b400d0c167102f64029f6d93cd180f20dcdde316ff1a8c9a4fb1022ded55bf30a496650b83457b744fcc90a63cdb63133240789deaca4276d27ef807872fbcfeaa6ad12bb0589616ac6f89d026c8d395287f391d6f3c4ac5f7947e88dc2efa228db98dee99ce90a530f0615737fa1ffebf4327dcb3554c7e7f62507e7a635a02b5f555cae4c7ea0686fb3c791208038f4feae0c7c9b7c2ad0859661409576e749fc4396c2ad8631b0d1fa5b272c1b86c1ec6ad88f1df6ca13dc637570d53d4793552976ee0d0d6bd3eb991702a08d0f02c87f18f41","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
