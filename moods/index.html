<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"accae6c663667fcb98be60ed8e34aaf5cefc944ec94abcaaa1219b3bd7ffcb6c088265ebf25ee5246e666adb0c3918d8fa49682403e921e3844a8fc0b1992b4b4ba6cfa76abc4622094ab9e0df66495b9622ebc57c23743ea7cb5c3d3d60406cc4d125fc395a89faf902c2b8b18a596321a9a83bd331f7c64db52107b01c069ae552fd8c9d49fb4b9de87962be57725fe0add1ce9b2f9514616e3b9663b5c22f6a9f2024b7d1c86532224d72cae900980b6484bc61bb5b9132412b8662dd9ad61d6a5bc0b68fb0500d0523bb0fcf86b89d6c23b9d6f56b29e04ace254775583bffb2205fc8b47eb061e1921e35e10f96e12036f8a51d5984859b7a50a510f710cad35af5520fcd27b6bb4179762b075c0c8a8e1d65e028345eeae35e902054c95d9ef9f34f542b89d1b724b62749207b31dbdd3c63aabcb64809dedb9141a5d027a068894d7b79197836dd04fc33685ecf55aadcaf5485fbf3356816b8a3cada31364f1e1918b45cb8f138c9b12329d587899b6c78192a3c7e0308c1b2baddd1eec434aad5de26c4d890d992ca50cec8d188e05d875d9abd5c637fba6d32e5845ae500d4d4ef36a581d9c276e0d466087bcb2bc1e6d3d0fb8f95e8726e86dbeeceb4ab1e6602c17142b878d988531f8358b8034468ce099c17fdd1bb4497e527b748639c7567f56d32949a7958b8fe2a9e18861006ea8d6b6891ac0f51cac7b7a9db076d00269254e09d0c26007aee1c539af93513dc9f6b5323485b9333b1f10f8e88b40cc5b6f41741716ce240c370337f1beb45e75c93c652d6a160d24939a0a0135b3583c11ed86ac3b01784474c4503fd8433da13e4ddd95a69285213e85d69284f1ecfa085fc94b30e32e0298261b60320ee49a992f7e9c069f0a0a6d3df53e35d2bc1c55c2b5d54bb3ac962251c45064ced78049f8c9616a655275176dbd99b2acade75f905e6cf57eaee2fbef76476cccd040e5704d9c04f5a0d33e474ce93ee22c2600d0becc6ab2dc04d86e8cd363856d996d5c2c5602cbab1490e5c7c88f956a13d70ae3bdf3b9c575b42ee8ef1fa0ab9a6256f5c4e99320ed97b0b7509cd623ac4f5bf20539f548dc9d28fee4c9f2ea78d15e9ab3fda0a72a2b52a11e5d2f4b6dd2e34e1e4dd02bf2fc4591845773c8adf9d4b4b60607f8e9232dbc852fbdb1994d1182c88ab636f097dda6b6713bc7cbfb30a74d32b9b07fdf031ec0c5eaa885a08a671ccf383433aedeeb1dc4e21f6648da374fd58f7c2b7684b9c46ad2d705b209d15bca41b03953cbaf38d3327eb05312b3054fc34e3ad4d41344f22f663df0f2d0ea527d645da207dfd9af19af95bce3bfa3a27eb0c30430ff45e24eb570c9470e524d3641d119fd81ddac53c4d72c2b530234147c570bcc9809922636303ef05f32f4c35ee86853f04b0a7cc4a206e990e431afc2852b37fee2f521d8a7ac3a35a35a638ff1f0dc4363e80b0a7b34aec9c3546b946dc233ea2eb7a4004d3c337a2d433e0bc0648a5f024a1e1e6c7acac4477efadf16774720ad06bb82bf3aeefa4f88325ca0bf3d1878341c52b7041041872c18a84fed8bc6f00eceb4845d680cb84659f69052982bdda1bd12e97c9c7f43cc96deb0501b62a44e028877f4c5a2d057b1db83e1a726672e520ebc194ec68fa4e09ccf50dfec508f41df3cf9c1807ab8bb9a5c060708027853301711218324876eb6b8f3b3fba86e6aecebec72cb4b3a3eedab41d931028d76008ad0a9ef9a0139043b265f141bd826f02549b51adecd0932f6c0460461b3cd50a54eca3c6c3a607a7ceaaa6e55bdb03650479c4572b965d2d4d693262ce3ef04f72178bf428b1fe8d8ac7dbfed188028b2a987884eb352df96a6ad4b8541f32464c87bb7133790825e487e88897b857b96f3bb66a5b4ea13496b558a514212cdd25410a69f3593d73b17ff657068eafa996f1e9a3dbaf93ab31374783c55ee3c832cc31198cf31045d28c60d5bdfd4d2066cd20780945c1195f33f1eb34df8762d56d3e85bdfdeacaf6df86e583298603a94c3af98c71b6e01d5b32877dfb6432700f12329d2da48fecf614bb08cc40e0306183831067b5ef64e84694524a97b36188ae131aafbcf763880d5cb6e9fe831b194227c8d8323f6932f346908c91aed692a3d3dfa7362bad2ed159dda2eed52653bc4343fcaa4c5fade60c869a2bbda7299982917cce4491ed13372803300a273b40cc5f31bff364556f7a6ebcb0df2f7e2a30d7040f34294f186f107738cd75482691079aef41c1b08d787a8c6165c2d1725777b4ff0a80e27ce389af70b1efcb7edf8fac8187e8a9c024c7f711dfacc1d2fd2768503ac68255f7a003c96c7011e834b924588cb6d7d2f1f143abda07c976c488c832ec8deec0472a17787ae69ba2db5bc63ee69d0be417de38c343984836fe4299e4b99cb434aa4fab12d973310dab3ccf38dec077039be24d8a65a5979a08471080486c80a003bb6daab744bdfed4c2db3542f3ee1e31f46ccb7195ccdafcd39ad1b6742c9ab5b17afca239ea99805cc877d37e69efeeee9598cc88c09ec2b403e04704d9fdb40c279692c182ea2c365e16f9595f27c5fe2f9aaaa9800a53928c0d8fc565c9534c536a1731d1c4ea233b52065624b9bfaa7d3fc7183ca17fc530cd0803074331f704714fc69d43542db23034d5f1c28b0c628c7e6dd19e0db10c0a9dbd01bcc3ad6fe8465f593725e35e62d458ef861f0b924adaab4f7cc276750c6a903dfda7bd97fe9f5fe59261d049807656574e70d3185c210e3dcfe1aa2c64bf8334e3672dd517f798d38aac06127a11a9f2e7ff675b6838e71da79eaeb6db1935395fe0b41c11fef6e0a1cd15bdfb6cf7164f0471f8b1530eceb3e36860954b97f77868d7593e867b9a6987aeff9376e53871a4b6dbf50eb2668f0f4578860d56a1e5682dbb71af652167ba2bbb3ed3c23944f3e197edd3f39254c8cb5f0974822d9f3cc86a2d5c144f13b6ae85bbd78c23f47b719959e7950135a28e5bc16da398234bdba09777f2d0abeb7c843b85b2331971bc72031e366502d35020d2946b5381532ac93cc311b2e5428c69343b40a7318d1fac3aa1377d22b538e2e91744309307eab88094ba6bfd6144480818c413a13b267b9f0d5f2cfc25fc91e467af0158f31c817924d98fc9358e7ca0cb0386e3eaeb1898e9e47c2294059eae2d3c07b883df88bca42e588cb758818b881ba371d863c6690b279820b16f7fcb9d37b061394395a7f0b2d0fd288ee503c6dabec0366e957d1e88d79847ca2a7854dfac0e1575b9a77b4798b64fd11392b12029285a2667cc976283cee8d6514a0d45195e82c491f4a9218b27d85adb3b41bcf3c9423280f9390172bdacc59fce9e498273fb9eed477612fedfb3a65cbac33a7dcc7ccce49cff9f80b9bd2ecea828c2310bb58dfcf514d76afda3dd922a58e2a9398c577cd713f3dc8f6a50dc30ce88c26c74ba03c7c1bc55061bde01792dc19f3a8f9149d44dd7d7551cb1e3996f93ba08e313d9d6ee5fdfadd4d03f9d70c02067ce969484a4ae8cd09071348fd6d0c68e149a5ce51ca8d9b33008384e45776df057ebce2c5b6638dffdc231b50f5ff6500d2425c3e7563d7e36530846263385cb383aa5a6fae7f4a18554fa18510b75dc43d571036ef154dadb6805acc8faf70cc3da69e30f1afa7b7ce785f87a137633d406659531f6b5818a06589873044e6b5038a102a4bc8940088cdbe0fbe02ca79a964131bcc3ae721233ef9cba1991b36dde95ed0a378b030b97634456685fe945116fb5e3d9f4c10fd3e609a822f25bb930aef4bd048111941b2c3fa8586acf8fc1abed9d4c7537c31a0b8199104dfefa9b1423fa7b1f8a0b3d55f3494f6d274e2e09f3c4054f42698b35645bdaeaa79e35d487e645322877b7a505368992d653d82efd91ae1b4f46529eeac1b08cf2fe0858ba2be621cd25908dfe1eff786ec08e48c3d0e4600c7e6c79d380674ed295e1566a76643c400a548f2dc49070fae7680f2483db6a4a1ff0a0471b4d55232353232d38c639c99f3cd5cd843552f13a02669e6143b2dbad9880cad1b7fe1b2f1f18861df842dd846e4187e6704b10079fe6f7f9d26c4e70e3ffcab44da9fc7c895e8b0fb66b1d36f25f869a6283682dcf3604298a441f78669987be961ab47b9aa6961306713023cbc8f54f853b6c87de390d186426b26844ef173c71893b2f89e0074a1918e4a2d32fa5d6bb5eb35e48c77837595f6f0b9af0de40cc13bebee953a47392684ef69edbfded6bc68651e7b726e6dcd7aa7c034e6eaa4c87751dc1dfef1e36708c91844eb6aa49262d1f513e122fdef5dbbbc32d2974838207ee3a6be0f3e8062ecfe71acb38a407e381e2b0ddc12b2bd9e391fde023095f251e4948e828f461a60256ccafd7475fbe3bbd68f75ae978ba899e636ea1e7ba529517d85d44c4d0875dfbcb947943a24b8c9bab75ff1b38acf28da324bb8c6f4e01e6d1e08864c5a7ed6e0c9234400b5892e17bedac19b6d681a1823699d1a1403d7506ca84ce40dca94c13812a1596ba4d05b4c6a37ff2b66a627ac1fb42b5113eb146fd83e3fa0363d6d76f2744ce3087e88fc7b01151fcb0544bef3d2cc1ff7525eadf72074d1f373ad81c5e45afb78edc34995d6475f4e78ef9b3109dd1be971f5863404d5f11be66c3c348112ac9a6d696a17b57a850f61722e8f79a4c09d7bb68f75847e2b3489506c2fa4ecbb0ae14480f7477df4fd1bb85f8b7eaf25e97079152b0fd4d9e90e4388e57bc7c715b088a9180156617afcd0e866e332b74cca3cb6882a91f2b00fa1df3888b3cc278433d129ae14c5be2e239bd801d8275b1badd71879cb80cd9e045054681c7d0602d6c6d2ae540472e709636d2bcf144d89a48be0a0d03883b66bde1b9014ff480f271cc745a7725c3311c122f387bc79b2efdb76c386c0a2aa13441f6b32c5fd9ecd63f00e2dfb9527abb69217a2658f0669d107357c4599cd56ec43b572efd9b12df61aba84eb2fbf2352cecc7af573e30f1cff947bd2f75d5d90223f2d709f1a2053781f6a47ccfeb71e734b3c6a99c989a5a2e2f0b849387eea9ce3773da1f6863d3da79593b85db42e1789ea847bc3f5da8a2de2d503b94c59664e501286b96856c89a12d48900eaf770118c218d8b114cefea2a99dd28aa991e5d54c8f22f08a1a3a6cb152ab2ea7edf09b1298801aa6402ed5cb37ae9bd15314fa705d1d2926c96903fd144710a1487596e0931e9232a5fb375e96683707eb2bda15881dfdd16641280ad7dafa5139440295bf6d893d7724b8d1b03321f108eb799538e5d0e8d12291dcdcb0e84ca5792441b7d513ee522482b4e4bae7424b04bebc1421d4f936af0fb3b3fd18743fa54ddd35c2be17432fb82a5001a5c45c27eac444a51f62098ec710b7d64dbe215366c70634f5a421ca33ca9e9ce177ed83c5ff4a686666f68ad1fc52adce0a80e5918aa56c6b4a94e5441c41fed9bec7eb5c11cf7208e5558312455bf073d50dc3756595a90472cf25393efdff679246833fc9b34c9852117bacf309c4cb3d132d430d09b8cdf4f893b6682d75dfabe3af760c90d69889ce98d421a3d01449aa39fca0d961cfe0ca9c52b9035f3ba8f6728444beb293f831203e85b3ef06f6cb2214e1e0c568d53aed3a8f8c23efbf4b4947db68129a25fb8b08b067e8d8790a39870abab5270418c028fd0ff25388bdd932b1a5c3230c3eea273f7a14b49908dddfe78da648f4195efb38059dc4ecacb647202c5106b611d89d0b5887247ee745e92c1e5f51231264893979c4b37580ad62223087e3298c5bfbb671d46c94d9ce1859a9d4a9e7e9d7a61c330cd699ae351c04e858c0671e542a817d8cb876f1b9046daec8ce9a918fe802374203fac207b30cdefb2bc00a05966d4c5daa0aa989ab2452d4fd90363d2b0ac5b393c5117237339e67d60b0c10df0354a712296afed2187ef9b9ff45e4879a54392205d3dae4d67f5229a86356d3afa492919dbef6efffead3670a02dd1fb9778867c68c1ce386b1617ca7a3e32dfae0cc6cee399dbfd122905d76d54f1729a2074773fb7dcbb04431b06cc0e8d8fed50e481ab0dfe5bd84c81992348497b02aa6e9070a68e6a84a1b8013dc8e78b475bf4507320293a432d8b48db9a4882df7b70b6f5ed4fc38700f187eb5aa6d8ec30ca689bd063d28a98d458a471623d93558d5560c9bf72d77094ef063881364225e8a194c329a3e02503dedcd075453cd167c1aaeadb947124ba4527441105a2e3c13724eee6dc8748d6ddc5a64fd99634c507a2a4bd5fb3784ed3435762890bcd0a6921728626a7d86c82591925e9a65fc547f2ea63c74811657b3c67656cb4120c0b86619682856c87714b2db9cc92947c17a8276ca1474e66f9b9d40a6f3c3510e61aa0f80de6e7eda294b9edb4917abf69f0981ca694de1ccdf4c2b7c8778a2fde21459c61052b5ad52681c565e6c2eff648e246897ebbc3846ebd557e7aa26d70f1716c78aaeca52234b1079f493e25a33256925afcea4cd9b94eb29f8c6bf8ee32534a280f05d9bc7ae45890a9e1513adc60b10bb178207d31ecab904f6c17d6dee050395f5c13ff13f32e445dfe2aa7561c417cfaf8ece38446afa1c48248f2962482f9959757ab41ba90a7ddba66c94f656257288f6b07284acc2d71ea9d8c6ecf8f6f8e6c914f5e03750afc35991619d706aec10a91e0f8f91b538859fb9a2cefbf1196468c86e2045e335ad1db12bd5d1798c9acb08fd2f92eeba12007a14b79a9c352fdb6b4ca1289085f9b741a98b7984ccfe5b1ac215c1b8184a27732397e0f82a5c27fe31b8c1a8a26b0c9b11e3bc0ee9a84f73e73954066b3b5cfe187acd50aec336661436da040f6a13155d8e37f3cb9c728d9e68a16a519534458feb4dfc95d6dde5671031c21d0bcb2c610248c1e8f8b44fcf833cfb6851e8ef76fc4e792538b8161cae66f94658c3603abc864225f73b550f2fb67bef3bc6d854a30b3e5dd9599371d834d3e6f5c740450fa7ccc50e8f62dd26ab7690489364e4f1f977dbb12f598d693c1f4b1be65a24e70cc28e21995b8580cd14a9395b9f516ddfb82063af49900078418836474abe3dc3006e08ea1217477510bb23d5235920284d94ca54518140d1afa64aa294aa7c5f5da2500d11b92955f1ac578f04553ab8da1a8db973a51a7ff7d9aaa794841b8ef71dba3ec7b115285268be58a05967d593eeffa6612ab53605d2f95f9fb346795e28f9b574f91e5519ee985b51dc23b42f013bb5d3f89e7fc67efc95e1b48d2216c102ae5c363148d16feddd402d3bd78fd30f8c2db22ad9199be6cb8897a926c8a611f081c495ce9f572a029af6b93c7b04a89e5d024a2079dc8f8718d1691ef74017a22dd1cddac3c0b45aa9e1613bb3f233dcf9fccd3075432ebead4eb2d452a62e790588745419881e5119380c397c95f23feeba665449a9285f99b5f5c9869ada2b868fcfc1c5abc1af5c74daf604460d8fd6169fd6a8b7ef075fe0a60d54db462409971ee97645c11cdcef22fd9374066fae986f4d06dca56716092726e9fcd3cd8ea7dcd7864fbab0e7572acaaa71f63db18cd08e3d198e5586796ddbe21d6009b136799b80f51b210d6b2d528bf1bfccc916cb82e6067cf56242a4d75cc689235b83c0c484212ab5cf764273dd6751c1b33948d5063a9673dcacde0e57a8104876453d99d9b830b4e8a04a476fe69436a5118c798d1c806f5c5ff409e2bb47988e9bf53983583c85feaa13f9d6db849974ae38254c024d691c285b2938ee99e08012bd741b4a2a763b8bf56e57b49a9dda06c34eba57de934239532b6548d02c0a911487f226ac317e72321ad162725a7cca7d6d85d892a38a1052a8a70f12240a02e64d3c5a5843c4462596b3d61df0427eeda19e263ddd5207c6b518ab67bea1bae9e83839afe6f08420901040304ba14b970f8c2c122b27294225716e92fe300f61acf920fc1c07f8cdf41fe52a3ae263d80bf14cf8e962093190c2fd09fbc70bf4ced307eb6308d0763f37ca80ce841439337e197d16c892024547909d7470013fcc5de6d6331e7cb40578214d69924d4ebcebdd74048e562a628997ff43a8814a5ad55c4772fb7b62ff08dca3a041b467b1a2f9e65f33b3e0976078ec7de59003828b505b8518460a865a75072c1071f0cbfd352fcf96c0d1aebf237a2fd8cf2925e038bc6f2fe6d2a732655dbf15690f23a90a198a3c241c1715ee8775d6cfa42a4bbba33544e7ca51314c8135e5f45796ebfda6073da756a8237c9302fd8b978e44643972caff92728b985ec98d30a091ae9a95ab635eda7bd5f8d2304d84b4a6ec4ea5c1299dc60f82d2505960dd5b9dbb7eba2a4d9c8f7b199c8cc1fcf999bfc0e6b7a7c049f0a5e8c77221c60d9ee6d8799b7170a029a8a0513c7a3b22d52ca0931a83da95b98c203ba65fa1a44da4eccb51b67b3a6aaf62a2d6ae14bb90cd3f89c73fa1924b3efceb2e0d3636b3acfe2f14740ae47317da9794dc200ca323e62dbb31ac59acf2201e2b4923c236a80eb3f4dd76925c17873721934c694c7bef10f312a470f0c5074aa75daaf7ab1c52a371cad162d444668025b47840189657d44cb83bc8e60c94ecd078183cd2254ae920a808f9ee467c376813e5834348e3fae0f3fd8d46b18cac2a7b0bc2c43215fb713680477d57f14ccd593e2a559087474b0216b4ec6a18bd8dfb692c0654c869839a367bec3982dde08c12b4b5491bb0c5fe29dcdd5eb4eada1df11dbae86d61827ad3b946b1652157ea17d34695b119a48325e31eb4832b46eb6a1c9bf083a4b489f948aa3ea6fea671298e374d4f9b6d4e3dc0b82ade94bac3f4637e7c02c0530482952a43ecc77bb2716d8aee6190ec45b85d1d91a0d371eb726594e591eaf1fbe8b11d17296b763afc76abb443dc3828d369a8528cfd7aa2c73fe50e68cefab28714ffa44a838a2e881ce107e1a73c7b6d681170ddde7cc238503dcfaf8f886250bda7d556a38e23b89bef6190d8c8d23fa7dee63c116b147a11c9a5dda0f36956aeb6612864a7942b315d1a2a287bf20bbafd4bb98d035db3f01317d89cfff4aca18014863cb8470ce44f3a71e6e15bf220ccb6b281ba329ccb45a0591772565d2e800fadc0a66173c2252c8a4b286cbdab634ced2c2f61df96a573f666ddc5cc1e0bbcba460136a27c585733c3f7079399a44e90b76128869133f37d14af6a350ed6f5080cb206fd13dd592aa256b64937ec1ba7678cb49062916c215923c3d07a287aa2eaf567875a06ffee6bc20522dee13df654675cb241c3a2b7dd77fedd7e67f543664a3feb76be92a40c01d74e078c40151b7ddbc0e2e1e75843816c407ac8f8b2dc84da76b44e59790360edfc164404d70a27da5681cd823593bdf416384b6be10a351b9504144b4d12fe04dc0f5df780aac0cb8dcd7683020de1b04313a6bcfdd9164c1b496ca4c2b27ace3acaef2e1b7c01ca39138138f9742ecc59f6db7453e7cd79a24724ba58740ed73705cf5a40ec149ba0867209c848460dbbe10d86b515f441d83ecbc976dce5824e5b76aafee4789f5b149c16acebc9f1609b1ee7274f6953e390e4e83d34f7fecbda299d24c7128d63fc8796d4c72ec264078b6a9fc6e65aa143d5105e60996a5c03a9799b9f8ad6c7f487d9eace812a314b57121b0049cdfc44226d7caa3027b301b3467da894a576c85911695dd50f22c92ad2418b43a5d290d5105aa83607a7c5048fbbc4c39a73933d76448a9e60c2d6cb042799ffdf24783e33da6ffcaaab0f1f9be6c2e80a760368dd2cc8235ce836f44e221860b1ec581e1a0de8e63687c1dacb0cdd9ff8b4fa00e7b08b2c24c59937870192c124ef0a2d93beaf72779180477d04f7f46dd0cb430e840ff09d4aa1a542a8c27c6cda8ebe29ed491b5c945e754528e96706341fb8f43ae65a9835fa1670a09a0600cf16561d653be448f612c17b5e69","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
