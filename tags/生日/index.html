<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e8e91147f11ef1acbd5f24ac023a392b3626d555049b2d0bc0d38ceccdf7c2c5ee24a3c0d2dcca2d680c3cbfd1e60768a85e726216ad84f6638c7f52e6bb555889637344e0f3f8fe1913b02764cd55ee03b2e7f29f37a714d998cd755eb0e5068d152f7424ae6a3d893371b317f40aac122c60d4e8a12b3d1e2a9725f73cc0916e9138ceaa6e0b884049362039d6a206d31643814cbba84c909a0b205d716223b6de527b69a2115de669ff6095f5a2ca690f606704e54b87496d1246ea1b8862196f3df4c2d0617a985e67c59f36390b0d9fba30928c158f7fc06d240b850e6faac7c89d4c9d759eb1da853e71366b53d651f4affcc54f8c8465393d7c5b05964c3fcdda7161253061787a18bfdbe03984e3f54d05ec30eec180c6423f24bee3be555133b1070ff69927a53fae35dae5cc795bb09ba17d5464a75aab48b4e97c6adcab10563ac15565b4087094c729bad453654b976cca33fb3c0bb493db681d47bade3f0c51fc76fa46317e48d2bfc1e5ca4441b8dfedac37c2cb9a0586b4038a4efae46e8a3019a6628c9b0b0ba5483fba145dcdf091c0e8da5a2cc3349898cd46f25ada9ad631904ba1bcb59d6a92d63c8acae274bdc2c45e6106c7a6dd7d544e18132fa779a2f670fcf2f092070fdd761fa23939828986f6e369bd35999969f207a0258db89e2de9e7caaeca7f2f7716a9efc5cbdd565152e6c78e1af32d0034d3f41fb927679873b4745cbc764d8a68620fd59a96f918d6136df055912ff9a2ae39765246cb1d0fd21760ffd0fa74617a7136e639090b44185d7bdc8aed828f76dc302af1e3f820be35ca96bf51fa175ab95a228b2636a627c17bd712677a6a059f9570970da24467399d39d3299c7721e98d58c2eecfb33d75ddcb932cab27c7cabdbaee1d3b40d4c2a56cf8eb49ac148e05c7b535f6b2e7e276dde3bfa75f646cc7f7d1c9a3c160d76bdcada6c8270b15309545be142a5e55e35671f9aad91e8c45a2e09ddfc74c39ae1c870e3e3f5283752972591dddb471c3a255f1617ff319854e817c302d96be9b7d23179912657a724f77b9f254edd054f720fe97019eb3f85e046738291bb64e0372758fcd45e1e5e471fff9feaf7e25890c6a830b26335ab3d8e3bc9ee7889c1535e0c8a0fb06e4899cb227de3bfa30fe00030e34ae676fd1843a345c2a1a11b62d7a89cd817690f03cc639f8694cd0a5d55a62ed7392376c36cfc52e20fd9602412c8c8cbc3c604074cfdf632f162af71cb59566355b5c1492e9992fa99cdc0f7369b4f4c7a660a3b07203438cc76ec1c7c8060bd1616fddc4139d1bcbad2b7680d8f7c1dea37224e74ebd1fbc75bc227a1f447e6e3a9362f64ae65e76739c30bc5c300029cf39f51ec205a7f98fe09c7bff177df086c325dbf6b37b77ccf93f9fa90da3c5b98480d1df4d9ac9a9b8c1cb923ecd409419f676dc7d1d4c6b1b8165ca818fa2b49d8426167010fc93f447f980c241a3c3941ff4e3c8dbea141ea8b779d8be302b23a2f89a53bdc574ee7dc5c1a738c99851ba0b49b6d91070bda07da5f805299cde548285eb236715882ecbe21791276ddb56ab62ce41cc7a68bcd682870e762b4e969a7d1f118f5b5e3270dc5113e5e2a975ea4580682759cd3a14532a681da4f507205dae46958a7442e262a180090d00afaf719b1b310978355e33963c9f2faac07ae34d1cbaba8213d1e7e7734018dff59d6608a4210c7a5f8b310f1ff137873abebf33de9e96bcc7c5bbd0467d22d679251d364b48c29b724205d0d64f4d5a6fdafd6996ebdf7a9fbc1ef4a7b38ceecdd4e1b1df3a3ec6aea89a78cafc00bad759017397dc331bb6ae78deab8762aba54e8eb0e0f046a67ff418435e3db30d08283560a2de44f4b8794a2d26d7638dc6835b14d50f65a2194820cf4396276cb03925b34fd791a1fb19d86acdba5dfbf51269b34e51b7e0a8feb1c4bef1cbff01de6241db92c6790bfa967197a36813d4a319204a70c8f57046bcf2d88cad3f39894b683773e94ef1f0ebf17f726059cbd01ba1cc690349e415b5571a84636b7c3f38d43cd80c8bcf7bd497800af5067fbc4f188e9546c0d0e77e67aa3b2e68f41e0c7228887a5555d06170d80d1ecf4228dfb7152086f6d01d5924361a1df5442dbbf211dc7e7c50f21367a4e54d117691745221b780b08e936ebd22ff6eaa8b36c4e2327c72a54020d973c296c9e11a282b2392025f774793a8c3ab928d4bf08f381c1ff634212af5238a8757f614788a856c471532de9aa2bf9956d523ba7e67a51d24311c626bab22130cf952ead6a2376084b6804ed1758bde79fa0cd0eebbd179a3078c63db5697ba2b45ab62c661fe1444b92515426b06f039cf53ca785abf063cf33cdf19ffa0928522cf179a37c8a902fb825ca5039336cc51471284935d614a0cfa782c18ed931317655422c37e18bbf76d579ee92e64fbbf955832a6fde2e63591097d801ea154e66b576e03591a26acbcc6f3d67e0dd3e1468cdb26432554e59fa2cce1daba11132214f3f70820208f293254de7ce632b1fda041a9465259274e2e6550de7ee42072e66483b873e958e28e14b71a051ea85b72bc9598cac38d2317dd1c9c1e6051faa014ea886c6c19ffd681233c8639a3e970fbd322234bbf8c75b948e8d39b29d4f22849d3616e2be23d80b18d273a3c2686a7ba7af19908ad75d1eb2b7531afa70953869aa2fa9198367a50c2bfd5b2ddf8b5283f594fd04e9ae484090d76a3ec4017a8da5c173d746310709ad8f5f4ef2e2576b29430c74bfe34f6d7cca4341044e4ca20cdc2c4b78c47894d6efb6f7a5a79667dbb2f30facbbb6d83fa302088c42fb8dd6f306fc8bf878969ed80187d69484ee320588be65e4ffaf2100a954973cdfa7dd772b21418d118c70db21c0c2e3a8264591315bbc5dcf26d6e0ef0eb7cd3800f5b1123b62edcccb831caacea3530f33a3c446d9473ca3e36f934b02f6d51719b700ae1b747df7bdab5b0df23c10829d62ae7380fd42dfba355e8f5ab148552bf03355a77c808bb26763a737981e9a595aea3c13c26f94c3cccffcfc58141bef186f62d048d28e13fa077f1652eb01233065789782da6dcc59145b6175b2d9728a534ff7054405eef364ea7712dfb610ca7bf2216cccf8ce5a91d6da80960653d80361ec361c4f829556a245729f8e638abb142f06c06e5db5453ea249e0a5478773e542a997c8c22cf885eec80124cd4c361cbc1704f9125cb2558a63d99b2c4a0856a47d170b9d31901c4184d27c440b935aa0f28ac01f3efcb2e66ce9e83cf9680c323a3088cbe61397e1ad4bd62981bb38855f65392fb060794ebbf5d73db9a01c2d7dd0feee0a76d9e21b181992f44546df81909fd80fb2d69a94463a7a22b0208fe5362bfaedbdd04c02d89727a117f84e8cf0928e1ab69a5d36971250b67a0e17f509de9aeb0a283aab2efed5b5bf8846dc326d8e2612ba73a6754a4d814e0dff258897fd2cc528ee7f6380bc8c2ed69d0393a598a4d11803a809da8608db2d2fd65c972f9fd0351a17db6a59add196e6afdaf6cb243f789ada094d153209ca148f33bb66873f0d1f54473813ed4fb9f13d20c56c6303252bc0b62145b354e6bae566ff56b004136cd49d9916959969d5c0131d74c6d49b2e173808579e73cf478472ca4554dd003744fda9734fcf8100de74670feae120873df893a4d11735254f7cbc175a54a0b824993db9d7eaefabd35e158818813776b7f26ac4e2de55b6faf7874c8f1b815fa3f6b27c924607c4e9329593d4ec657eb9205d00e18d4c36b8aa27ba3d0b67461ab3bd04a17ea439f031dfc917fccf527ef1c643f8428b5aa5842d09dce9686f75628fe8b2126b3988ab35316e29ea99c8f85f935b47f7a2d88ba1957d2209a288799938866a5dd64bc35fb09c8508133b28156205cb08edc78bcf4dd2f36efd996b00833d73e69990d990f491d7547d8183892d86bc47b18c8123023a42669ea1b39a32da26f537200858bd683c0b2a478e64b193ccdf4ee78397b39fe4c84299f0356d197e3ba8b4435adbc1423fac729174c63b1bb17337f8d92c5026b0e1de5f243f46cab15fa66a50f757ba7f1316e310fe13ee9489147d2733f10d9f289a92f8afce9ff6f704d34ddd4258d67a9c16f16a7eeca00d2ec31634dd9a121187d3a3ed0ba42adeb693b1b9beee4be3b57e8ba654406901617ab231823f1663e8bff370498d1162b2356d39d67b855994ae8185824a3fb647addc738024501019432bac1fdaac04f29bf11c44728915ad0614af983057172766139ca7d6d4f370ee4e8879ec4263be5f243a8bb77608d466bd590debec919f4a893337b0bc22fb3681dc8732882f19b2f7d7186dbe78523131ef70b3ec483e70184981f480f2e7f45bbe313ad33b780d7f2695898995b388f4a53b8fa7e24fedc3e2cdced6c93257b3363510f4bb3b81ee04c37c42e902fecba5b1654266d88ea0cc3e218dee73ce1d3d120a6f5ce18adcdb69ff9a5a529322685a067594e633e6415e01c9f2f1bb8a177bfafa2aba2917615b3480d225046966f9a898249ec489cf8e7edcc99d186448b3b6bc9e17f9c302734ccb23e87c106a847a0c59a2b98ce5cc929a2da044137e351e4dcaead5f053b605efb2897a6424c5d0397eaa54c820a30103550443aad7892ab6d2a3ff80b343d3f87393a9b3b44bc786ff4e096d9cdf22c10f022422614c527e1e2f9f84444e38bab575de43ee793602b3e3ff2e60a832afa3d5ebc959b3440618f45f7affba208d8a233cbe5fbce35e5716573a7f87cf0441890e84ae972540b5a0aa3c20a12ec36d5d8b884a15275e3f71b377593be6731d981b59721ec3b23baffae208a5a95910d22990600a4a2737a0226466a60b7781512e415a4b21bedc5d758fc3368a3d6d77a7f98b4e808fd9ccdbd77f0410d98b05fe89780f604959a72d295056293a52d73d6b188643a71370e9ce4338453a73bc570ec8bfc0b7324819f6252166eccee91248699ad8f30d3c0d7d25553193c5d701b42bf3936b798991904561ab59830b24b5bcfc4e1a8355508d4432ac41afaf267016c76043ba4a5ec25ae7efaa903fd3c3f673fc2e45e84268c232a1bb2fc4c134e848e92449604b46925e224a9bc5eb84cf3d919544b187b43270ad12845f0c9c1fb954aa7db65c875a561538f3ac7aadf7daeffdf08ab9f189afc0e4cd614fc30be6affdb05693b2cbab0263dd84e21b70030c74f535dd8b62200e4d46799a22988067ad063d6f93c4c47f151599eb44704a6169ced2d37956ed0888db354db60a067de6c9b3bb8d3f0e9ce19f6d4c85ce47026abe76050ad8eefbd10baf3271e2b462fba427f308dfe0aff1d9a835edce8968e12b757b1671163ef98b3fc6fe0e8a19fe43b9c00478642e140ea3cc065fd519f318ade3be07c7ca7c4da2ad2e255ef6d559985b9eb98400873237af694714ab5936c25999d84080a32b3c5ef261edadd354d13d03776a217b4d41af9cdd00686f40cff652422ebd60be09df5006403f7c19db011d51e4f34ac4fa9595ea8fb85d974f6025c53a4fd622349062f6f7156a53f599a088090996d40ad0756ecd9493c4261f51b08ef463cc50233fbc00f5166e869f7489da171cd5e3edd57f78f15c5c4c10808850666d5fafeb7f3357bc82b3d669c1c392343e6c7b2e37f30c84aa9aae8aa2426ec7e72cc8d951e9967a05c86a64eaaa3874e9ceb85477f823a186b2b1260beca74bf6aacf2adbaabf80796781ce25e6021f7c9c1704e3b0b2e41b7639fce1affd8b082d58f446d03d8cb3ddbb41782bd04f1d848c0e1fb68a44257bf34af95b1fbfa21cb97b53afc269ccf1e4d5efe100a07b438be4a532f2ede64cefce0c1a0b11445f69d48b916f81954dea711a938fd799a004cbc7a61f91ecf7616ba03acad926501867eb1ed7df92ea77d9dba6592332106568c410c7eb6f2ba4a3356e397228c6314ef3a17b3f9c9653ac3841ef1b3041a80448567b4aa5c578017d63c8a252e24313fca91f5ad8fa1c0894107715006c8fb4d85f454d2fed145404a039127f69542c9dc277d48e87448fa774ba77091d5eb30eaddec8760b09d26bfa9244527f27fac50941677530ef9a2d6e82dc5e17ad020b25d0d0e6fe9ec3d18a4c8258158e06f8e6a8f98d64e373078b33e2a64bd68432639c7ffbf20737a043eac102dee6055ac78e41d26486713a6c81226038c957d7d9313c3f5d379b0760f509b3acc9b9192efd54c2f0687042a2be1d62d59ec13fb201d1f118df6a448bafcaba162e4b6b0c11668cbfd12d4d1018f790b1f9df6c8eea7434f21526579a23db79797cbdfdf94970703298aa1d1e1d82036b935f065ee92f2b68a0f2eba88da9a9e20204e22b403715f26920a34198ea1dd88bf90a675ce4c33ed2a3ea78d9a097ef7f2fda18222700aa821ee23d62a6ae2dd1f089ef71d6bfd279c34a76f766540759f1e3731128b7f782dc83f3b2b7c249e6f76785888a6558bac18a08c41aa8cb44dc4dcaa233a4732c04e27b7a9319e867b6569aa878c7c3188cf85406029b473823951a6c618bcebf0fdbaf680d84b40e3da22de9b317ae75fd25d52c0573b30f03fd36d391a143639611a810cb81356f58e3f37ed7fa37ef5b20952e22afc5833ad0560133349e8e5d4cced3bc81ee76e2eb6ead16fc18d751fe49f1b98b0286eca4b06713e9ba5a94ca648c18be6d135de95495fad0eeccb64fad76a58ef1fe84e7faaa278cae6934184b54d258e206f0e61ebc1186914c095902c2b1fe31df0573e994f3f13c56d5008737cbf4a2d33089d4190283a2271aa2fb467ce44a3d886cc918379f634a49b7a5c0f9339d0c5f8fb0ff65b2d6f01528e74d0bb8c82bebd88498494f55ba49825c8f7292bf742b9b720192fce28aaca1c2351baec1bf8c2c674b812f508d8bd0652850fb1bde271c44ac83a4f64ae51ca52904140d5dbdeefa35ea518913be589ad660b21b1d7d967b91de4a67f2f42c972e64379a06285243818d87891c3a28356c8cfe59b4f0f8790f977f7ce8b885d42a17f3207bc3316d76fe807655ad8fb800ac0ffc4b024ffd6041d062f0f90e877ece650b7fa2e3ff8ef54b8e9a30c5ab20a32b4da20d765705cf9adc3be029b5f2a127451810aec4d0ea9ec57a70a29864b207b6b455e742237422244886185141e056b6b96869e5dec39c10ed23b0408f10e0a98c90e88cf9ce0e6380063c3cff8cb63623dd251862d5844432ace8c213a65eefda1727de7850e5a8dca741ebb8062f2bd2d280354582ed3e547f5409a82f19b25ce5abb74a13a8a70284a6f03d649105221c8ca6657c99c6502e288d3d62dff9ce222d39cadd8c0938d0b6c1c625d3c16b07df9bba07f0df47325e9f167e469c4bd339088f399d6032f2d2c6e5135147cc109a14a9f3556029c3b5ed9373f01025309a8da11047b9524408eb479abcbf649cca88d90101a1b6446d1d3fccc62ec337d48e3ab2691d53d20c64d06c37f618fa1d2030976920e7c256ba0810cbe676e8a7962bb730d568d8a9505a1be2de69e1b931d69271cb3e3770e8495d13c73237e887176169016a39e159fac8721472c2069289fec9cf5b99c1048768b888bb1e064aaee39360af926ec9005348ab8d1c0830ae76bbc9d31c239c0073f6476398a4093b6e096ca2121b8b3e124cdec8eb953905f922abc02dac1de76812963a5422d014a99bb9fb570442c5358bc6c62c95bafb37d74e614e8f5f51d79c8e1bdcb97df1dddad3f726df99fd56a80b2193a3056dd931f97df6e1933741c9d53c8196b06e9f880aa5a098e4b112999a59ec94cefb6108f4870bbf4f34291de4b9804e4dea7338dc5adcfe4aa178cd7e23f414f9440b9971eea3ed046483b23a8f59f52cd17fcb1ef4629b7b638ad9829652dc9df748d936d202e47e7dc79d708001b3bc5da7ec053dc7ca6da1715cbfec8b4f61ab9b14ad4b7ce8398a05d0dc24509df9496593f38de6944025821fcf060eeb18bbbc05a53ad52bc47cb41f54ad51371fecf92c2a12e48ad5ae5e5088498536d7331b5c376bb0d941a7e84b53e948d2d0d29a6ed7041eecf6d5e1ddeeb884b88b301c2713b02786379ac6aea65661ef8dcbafb914270f442fd56219e2a39e9192fbfa9461ffd6aaafc53938bfb4f09fc24964aa9397640c95c1ace2fd71c2c9a87bd11433432be0f3efa3ab5abf6be7ab2817eac9e7f36add0f3a5ae605e8440826454eda43d8f47b5ff67b345c6240d956555b5f8312252370a8ef8553a363dde3d5c65f05415545ee97875430d231650493210f27738a873356f68b501ec569fc2acf912b2f80b54728f0019f46f75c959275d254f32f29cd87c40e05910b199a5de5cee5ef3ac297df10f630d81be37d9ee5e54c05574dcf81f10830bd43393b3b907b57364b87991ee997a182ff21bca132c3e6b5fe770b46e46b0b0c705676dd3ca196d6267b1c967953e2478947b0d9f661ee5cd9150a7f5aa9eb500ff13c44de6f2e13ad7b6a7f6dff10f8e4da2f4092cbb78237a4c46185da20f5b34262b3d494c01e514e590e4ed453eec7da3bb7480eaa945e879ce6c39a6e08e00240960e33f0236fe9b344c317a376fae59bf6405251ba714e2ce385fa8926693a67627f26035624730f4d4ffd544fac454219a47bb44130fa4580998d47a881c1d4532da014a8769c9d378f14c49afadd0396bbf6a41cd05f27f00a3bf0488d61cc258369acde54f7c605516ade9fac8dd72484614d65b072035c97be6ba74b5f7cbeb45d177a0706029321c312ba4fb88bc5d21d90b999e3561f93c89f44ca5d20ea426ea5de7dd6e0125166cfa74fa5ae21e7cd79dd3047bf3a0871eedcaa61b44abf9a8971910aae32631b0e90f3950a2049e0b2169ed19accc7fb67520879493471be6d17422be9c5785174beaf4ff96a653e02ffb56e60da09e02520b482028f10de3e697470a66ea36cd628163ebecef3b345a1ae37c08d63b74214933f40cdd31ca155edaac5bb8f38306ee64a6ba54ed2107093d24e949649e7585518689e29b194fc5cdfbb4b6670e7ae6e2c5c0a14bf9e9e4e3a951fa812b7efae571c9f7e062ca9ac1690beee6daa75c9ca728c5a0756c92c2f852d7d863e4bfc7d181796e1454a61fd241276ab9ba76309dc00a5be82773f9cfe554627b8694822a941423b8197dd32cc4ebb28abbe494c74ffa00e5f0cc266d3bad539ea0ed605e999ffb7b645b681e37e78db850d0c9d2e95c6b6b144f28bc107c72d0fa729364efb7a04026108f791232f4a6da25e46293ccccb555b9206c77e8a17267ca70973e8e831885913b6050a9a929a98b6f52864c1b240406040ac2298351bcee4d46683ceee7a13f9da8a29a95527b18e4c248f942b2dc04b9bc278c9ef8ebd3940900aa84d920ba488426b628d89c81d264074b8fbdfb1bd04dbe7de6bfec0e16e7c2416ada325e531da8ef90ab0491c6b710d2beb3195c5c7c72a1a37d97a799c19ed1f32bed8a5ba5644d3d20b28bf78e54a1708622e8526fc363742b30ae05f55d53cdb5cd0ae7ca025350044109b5ec4fc86a937c41faa67ed81857a51e48440eb890d05ae218878aeb6f37b0d0ee8992361573cbcb32a57698f35a6a2a4412c7d81cd66b10566631cbd7600f1e78f60336e8336285807b760479116c69bc2a9c35537fcbbcdbfb1204fab1a976aafee0707826a7a5419ae41cfab70c65b266164584f346c0d34b35a86f0c83bf43d180d8d24e9324bab2c99f19dfdce1106953cd805d017ebf5b3ec1521058e52da2b01f674e30d4204069083586079f76e0131840a6eb8b06f7e402440b1b9964aced33771cb0d3e6bf022ddaaadd7b860ac92b973ce6f376c1eef2bfcbefb8c9858031fb73836ed9b27c8c35a330803d8641f78b5e64916426ba32ca7f7f12b88e3333dd76888df90c3c872dbf575ddb596f924c739ebe67c8348bbdbecec7e75921e87714fc40da4413400a90a9627250a370b3ec666ff7476e1d171dd66c436be3ab7df252ff085e84983e1bc1c6767bf75691ea8666ae7a2f0ca178e583e1150574053edd3729bea33a224db5c9306cfec0c526ffc99c486fd5b0dbcc2637d525fbe09bb777b82fd9550e727f9f77924bdd43345f1054c14a45ba910cdab8229b70e8941895bef60e3e71cce4e612783f26688f786bb88f1778d93785b4ac0fdf670bfdec8764cb8e14575322013c197bb9fb9e3f53bd069b9ce040483df47190c60745faaa95f04612ae8be8f287655d8cc3bd86e67da46bcdb1b9ab8c0e7e4ac228e998cbd08402d689ac0170be752e2ccc7003316a5f07ffeff2702941ec786cfd110332d941558c68ea2f6c245f352d03c2a5334a77a63e72daa5c5c5dcf93604233c2767b05776dc19f5ed25a92ea8302319f0c2ec65543f8270c99020d8dc9dbe10f179e32c24912dcca523cef925f44ac53c0b46d43a4b6e2cc5fcfb1ea5859664eb424c33af35fd155d25865b7a12c47074524cdb3b3c683849828e35d8cdb2198bae9b94eed8998cbc6be751e00703b970ea786e82e5902040b60884ece4bc0700a62390a696d035a37d261f7590caffd9c948211f5e61c170d33becb1ba039abe093c1ac631965edbc2a6f681cee04e5ad04c5f3d3923dd8be6f84c8075ac5564107eb4d88542edccff6f2fae9d5b24a198b4a179002754e36f6093c565f2a205a1e240515fbc32b19e2b663a34b940de11ef2ec7fd7811bd5b98b90ed3464f69c82167cc22fc8dfaa4cccf6e5552f9375b4f1f04352e70be65b752cf8db29b4894757b713fd6522c7e60edd39d47cf385dcda0f5a5af20269bfc0b12fae4296bf8e48988461f3e24eaad126841f4bbca27296d5a79a1d810f1e457d288b8bc3f38fcd6d36f913b459742f3e8a854f5145d2dcc0144a24daad80b986cec3b2308a1f12cc62361b23ef4158f3cd52a552be6ec85d3301a721ee6dd12c670018a7b883a7b837129a622a55cf2dc499e9368c8d228cb47a37f9d4a6729c7d9738d03e0700fca67c73caf0e83b682a245d34b61e8df327e45a5efe709d8008fb91c64cf7b49b40a207b397fe7d00cce9a0a44579128ce3525a5b12efedb6739fafd4e4b1b003713e99be7856cd0db93dedeb5ced5b92149c843e8298e0ff42b7b3e5a8bd4bfbb599e8780e442e236d998f2cf3d923c12bdde9e12c61ac52693819401ebb1502c4305f326dd81e5d318f1f248b0bfbfd702a2bd1b7121d5cda0a7b94d23b0a0fce8d54e0880b076148f2ebddd0df7bdd21f954dfc370d7bd11955da4329fc8f03fb6a3e62ffddea007d9b0444c39a0ecf089e1f542a6bdd1e37284ba0ab705ffb2417db33c024a4343022c99f88310f240277ee7f1d44e9edd4526b1826e18b2837ccc23ca90df538f08d2144bcee88657a2362ec90af5ee7eade65ec4e509a956a0a02d12ba3fe2c9c9a0c5692f1b1350ebf6bae8d83c18c1a0d676942f5bff5b88882b83e082bf3931a93d7bc9c85392ff485f69b85858373f9eb4dbe3a3592fe1759bb92e29075123efe272149e13caf5f7e77e75d4000c88559849877e410e884813cf934fa2d5663b8536cc3190f8344e45346bccd15d5f6797d3adf6c08760c4356cac1d10aa7fb2ca65245a0445b152c582a6153fc8a6c2dcdcec5d38ced200430ba30917a893e82a954a89b9431e97ff5fc79fb7002ee1a6dfd4d8c67fdd91bf394a231c26347c4b764a35037be57189e214e280cf7c8e9ad07e221cff5e7ec0435ad7644492bb1b7b09ab55ae66dce6c23a0d8f1afb93b9f001d67f11a3165b0190f47eab87302037d80aea49db9269e9711f7521bc9fcbcd11088fc60944411e3a7752857f4abfa0c05d2cc928790b4be37bbc0128de09c51684c0c0e6352308fb92a6024e42bcdc66ceead94ad87349553cdc9fd5ae9eb7605421ae176df9150127a0189b78bf25a2f469df8cbaefa3b472ed8260dbf30220c358746c10176b2a70843bca8e7d1aadaf7b5edd09a50756991367e4de0e70ba65424a11bf86a44e683c2d6d3eecf01c36b635ac4ffed19b7079f9b5300428dbed6e0f8ce6c03c342d00a05d36f3f721d8c04286b6a11de9dfa2edaa1afd214e8d91e6c4d75c3e51058e1fa9962bb12a56b92f11aaf19ef58da2c37d0119d2342af3d07e924780e7cc1dfc37c7bb5b3db6587d0c8a5e1ebd5b523e76297ef468a4f18256fad6ad6efde453bc4bc5fe7cf8490dc0f6a4592edff5919eb7ac8d12598d248eb082916261429b3ff7a65f28d19dbc81ad9a68a68104e1234a19a6c14375ce7f807748c66618ca0e8e5d2a695a2c8c51747ee8aeb21699b0ef6713586116c2d56c3fb7e5c5c628507e822f668b4c7d4c7691ca8d2965e1aac00a2f1dc74b8ffbdbcd14273c7cbc81876fe6a964ab599e7bced9a68d00b083ceac668b38031c911e835f7116f21a2e7d444457ef017f6175fbfc0ad265befac161dc3b1a1a15a84b84ed0e04475d3ea79f5a981fd499547a1fe60ef2b69273360bd83cd62106bf5db11b3355ad929a1fc999df76bd2695dd9579bcd859e8df3cba7f7db0f810390891b215192b742fb2aa07a1652f6fed68f7583b88320a57e102aad631fbb0402aaecf6cd0428c61d0e1342ee3a05617e6e79ad4ed971fbe7218386d1bf70b33e9e9d6eb545b378a002b4975a9bed58f340183279a8835ab7df03b38c84216fdbcbb9da30d821274d5d4c7de3710611b98004a047438c7ab733deec2105055bfda86a75ddc786bf3df25d5bd8998462d356293072193fee0a14d63d0ebe42ed4242ab724742f6f8df57729b77fe65b5cb97b76f1f0bb0a485c2b021f8500a3360931075bd4d6296400bbe5b7a9291d33bf75e0997b9d6d17261ceda0685107a083a7708d8ba53a882c5ccef16ec217dd8bef69fe163dd21d84273f6292a76d3656e89e3538f76ffb913bf599ea5c2217c58be2d35a916fa673441d111e55024cce6279145d6f8313b6f96a51c17055d2842badf29163c51744c66d31fff2ff237ec23fbc09b819c268d7a0bdced5cbfb4a94039b0b378b92be7ce0d743ca3bc3e584ecce378d1230a2935221aa71d02bae57ea032cba1e8c7304285ceba312d2443b50753d7e402bd287f4443ccb86091812fa3c0f45074e3b2946c160c60a88647afe1ef50c5afc7786356dd22101b97d538faa3416490cc268efa982a0d2e6f241ad79a358b9223fbc9830c12fae9fc3291cef64f7db9936d17ac016da643f49dbedc30ca62c1c03241a1b7279402f7638ba7c25dfae06295729502d8dffb180b27cc20fc5f91bc1245a0c0c4935c67440871f7d46c7aa4b77ccb5f5a83a5c8d481ee88ae192afe77c627843ae8183be4affe74315f812e40cdc963818bee524a0a183ee79cabace6660b044e222a3e1b66d91df266615bcd2c92254145f5a2e7f04cd8061dc8bddcb106305ee749e2f5399c87a4855a857a3352e54c1c6bef338454a52038f10ef2ec465f08b7813ed71c12c543832233974e500fca214f5548a07ba8f77ba77d6e896ef164ded3670053d18de37e87f973bb7abf8cdcda1618f6b12ef9c89868d1402ea2fa80a57e57ae4ea409aaaffcb09b94ce7e3b92941699c9c396ca98c271490757f17a4c16c7d27301970e58fa7ccef079b477811edf9f1b66fde8460511044662203756b47f2ffe452ddf5161259727a4363d9fab9ad478e89e600f4e20aa60030e20f4d7a0249b0bc443ce5f4dd4526db78cfc2a8f11b5c3745a7b6748376eaf692c87c19ba62f14b1f8dfc5c8e1c05aa4927924a878f4503b4aa768bdf3863a8e148241c3d5d703da0fae56194b71c1201064920ecb28c3dcca3af27c9a84f4840e30cf6c8f947e4fe37e1456a2dc49b12f5bbedfab2e74d6773bcf8c4fe7a23c883440d2287f233325d7c5e61c9cdf266dba8dfef6ccf2dd08e903724dd1c477ca0bdf8f77a6d549489b9f8a673d664b683579f4c3d7c5d823e6b46566be7f803b553d8c6f30d66060a9f675f059e0039b6bbc052361bef0de69281fd964ad7a573d4d58665150df315f5a2ec1639ed055cd0684ab2e2b1404042f727bb97784de218358d0e8191ee74987323df08390045c55c21b857b6248ab21536a4779fcf74c4b3aa5231c836dce701d39b8390bff7003703636d356b1e4b1b3d1e92a13cc213952e332dc237fd174248f00b6a69b783c40fcb386adafd979b467ba0b42c0675aa0e19430ea382bf4d330f67e6e7599f0c49537412601cc7a15272ce03acc1ce3741aa6cbcda85f6b0caa2db9a49c867b990f506e267308180ac261d8e38674b0f8a5fe5ce5cedfcc44477d38257d37a8fe817001dceeb6f7a1fd3d1e7f5575d7ac3d60cca7598b6ac5bb5bda00b85103e79e561a499217c74217cb4b4afcb7d7d12d5f6eae09be2b66fb16ee4dc9a44749cfc2f4a888e5f6701bc424bae3e2bdc044c47038de46a62aa3a9d0482e6a9a9eb47c05bf7a0d5aa3bd2d82834b73c494589b5f39cb1c9ae31fc9b721d961bbab7d5d3835dc8cda00f2e2fc0f95700648bd3232298b23327c3aa8ff1037e7fc153ccbc0231d846617a090898123e4f77b68e52f801ec1e129273c4e8156b592559b199ce3b58a999091c9484828256905cbe75acdbac83240168d7ee452b95c53da00377a0464d4a4f931649952ed98a67f72420978daf9415312be341d54a2b7b755f4554a8f7fd8db9989e50cad740c501a626615eba696e293b1dcc6bbce78af7c251c3048e17c9398625d171ac339042fbc893c704d9b0c0420482ae63ec1c95522ec3727b42c18075204b7714df824f05dc3fc4e2bcfac34c9787f31d57b2c3a2ec46beb1f0e0b740f4253bf213b99e2e4615971f5988f4363adfddab222a530446b0bb305200898f68d22f051f53ab04af452ffbc0d63dc23ab210ef0aa2d1ff9043685095ed4ade51bd2fd6176a3763a362d9f86a55c00a182f4f99fcd72f63e322418d5694dbdb0e56bd077224cbde85f9ecfd02e425f7880d2a955ae176f0ab533dc7253c08f9820aafe48ee436cb976f80cbc58452b38adf749584b95d3edee3db2005d56bd22456642361d47e38f2a68a7a93831b86d14667c4e52b4bd8f85684a62131df0202307e6e701b466ce7b085e313c396d66c8b8fbd920ce3087c4466cdc842f7bf2146cb7e2f04ef4dc97e84be32370ba60bfcf01dac9108afc9ead70415a99c1ce32ee060ecd509b5794b9df4d0b10720ead133879ffbb46de17c8c528beb1bdd2bc69d970d924d3709548d854cca546d3db5c3b58a7a5dd1c4fc6d75c31978805381af40187095c49e11916353252385f06bba358c5fb133efacbae94e758eb8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
