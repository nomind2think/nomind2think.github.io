<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35262afc6317b7d99f5a93e21aa5cbd95bafbd470bafff67f92d16445f0bb9dbf363aea578dd2f7ffcdaa48774559ba8240508e55eb566058eb013f611e194c8de83fc61790f8d79684abbc011b8986b5242787c5fb4dc7a25a99793ac521d496530c0dee17a0d3df4955522ff827964ff067ce3047791034b479eaedbf2c0330ccccf93979586897d5924f1e952a00e970a49f8c657e27cf446d182e193e6f6c4b72d1a4fe495edbea124ee095b826ee3e55dca50cc1a961d82d96ff1dea9d0581f8269816f397345a51aa5e7a39570a9443e3da0e24b2c47919597a27090b92ba281f251de24fd20bf4a85c87e7baf4b72df90781d0dcaaeb4e8952edb82040162d68a49bf9f67fff797f46551e2823c96c6c975b4e978766663b32a8632c542e3fb47ec4a1f359f58be677e7d8e7669ac6ae7ea703dee0616ccc739848e19f4f09fcbd516d41948b488ed20c187f5aa017a351cb4f62f780f26078ff3f7eec973c8a8502ef1f5036ef95505baad5700bd379ea17e645f496556340db3c16e5b095b180d6e33e300ea3076e7acdd51a9d772a98fa527837cf0cd45344e7d6d6b97548559b9916470ff612ee95ba59edf2d7d3fade458e613e7219ddaf6dad246b903dadf76104037cabf363b2d661c35439fadd97ffd30d0c2674917316bc03c7ca771f67d19592ef10bf79183c5ca75aa4997f3cd6e553213ecf96c91415a5aa2dff4890caf37096d03bdf2730284674459559bacd7e5a0ffb1dfb26ce554c476ead0e1f6e7fee45560ff1fefc30c3846913ad357794f8c3a9529d3d0b87d20cd2e9872a495fb692c10144f37626cc6f0174024456a7e89c09a781bf79f6036e205186eda401737ac00c85cfbbd3cddad1fbd9d081d913c564250478cedcd8b800066777d46ac5695a899b3dfa07d435b6882a90bc873830ef78b6a4a3c599578b9da3ebf86feb8d5fe912a3c4688e320a7f9b0dcd2017665673435fda2191ae2753b9768e3ca2921cb7f8429ba049bf9ba904d7a40c184bf52b331ce0d5d49870a1098f402d73369f1ee3c290d9bfae5f6b2c91fa0da00b4d6b29d3f5c4cfadd2c72d254ce2e07fded170cff1df7c6aedbdbc1dd633034d626ec5fc3e352f8c8ab8ebc2c91b936b5df2810eac36851aed0676a614847dc7ca8db92fee7e25297ff5e68229a869bce4597a844bb98ff953466087e135dc36d66e4b778c2be3d6a95a5a9071fb8d61a875a33dd9c5467205df788794dc2e88bd88fe9a9475e26610f6b86b7b9357d37eda1ca4d87d0e7409e223a5fd0312dd7d9cbf7bf07edbc1703ad8e85cf1e71649ec54d68da722c4705873a4c604435606b3b71edc13111bdbe08f6c677367074daddf00987b828bd39113a5e20e2edcd34eb47ff2ea328de3e53a0451992410708b389155ad01f2e66dbaf1e58100db18f0b4cce89183308971aedd9856e795439f9754696874c5c8a83bbce72edf848d382435023ac243c187b64a80c3860298deb17c2aaed78634b5ec825af5eb8ac87dc3a8f4be45744c5a70591f048df681f78e2a00b973952f33f5b6be962516a3e959c334eb555c9a9cdd8e127a95bf38afba47bec8f7d03b0d3735a9dd3839a5fe50413e61490830e2e3ec8bb44ba43e56b0f2144cdb4a371b4e5ed213a2ef3d5b77a6f241480e1b2d3a1ded24cc5026745ca46abf896b9cc9eb05b128d25dd841edecac27ca4855ca6ce2b854e7cf810e972555e3a82b21db5b4a1d4cbdd0b205f7ff4a5b902d79cd0626b0404adf848447e958fa584636ea62f1b267dfbbed3876a125da6712d2e2ce5bd10cd688f828e84d04ec0e8cf8e35a1e52d9889894449d61a4dab3d677a92793872f95c802b1a0864e78a3d412207165ec8a1d1b047727e53c48265033e12c8240bc7d63fae52777e65d5f77078e0df9fb226652d28a7c7ab59803fbc170a0c6afe722e1af208940448fb533e7db2e193b01cc79362e44edd864b115a16d880bedc5b56da26720eba9fc1818acc00c8875041dd7fb18df83211f3b2ffe2eb34da0d837cc2ec1dbf1762924173190a8b50cce61bf4196157db6c2a27a2a4ae68b068d26386ae586f22109f4d393baa6049129d6a619d8d65a7b393400ffdab9f5ae70c1f45149211a6556ef0daf214fa6cdc3e556f481b5ad8e8e42e26a0f1e8419b111207be89ad501a69d5d677c49af3c75c8f1f78a1d6a5b5891d25989a1e5a7d1dffc5ba0b7551d063dfc7938c957f0b986c74777055ebc25cdd2ba63d3d9bbbcfd1faa1eeddfb5cfef6ae06426e49595c32fcfe66e8409719f03b456b48d8296027f3200579a430fc06fd6c2d748b449d59edc61a77c3bbdc4a6a3bcc43c2641dee35938f92aa93ff04d23db3bbd4caeb3e801492111a36620627eb431d5598506d4b76a75ce37b325aed4cf6cc3d9bd3f36cbf6a121b409549615ce3161f875d5781668f42b1ca9c8b71c5fb0171b2aafb535fec477bdaa37d0e1f199e81372e0a6b282bad497104e438beba4b5601de9fe099ba5e797514c6d42ac37ca29d8690c672278606c719b252a29ec58ec40e4913378530bac9d88d8798539ceb4c7150fc8afbc61a3953459282a52112b15b8cfa34cd17a7f6ee33f3be5077190b6928833679736d172240be67fdd1a7ebbc8d3b00c1018de02d1976cbcf829017eb9f0972f96925d751da29a6e02728f5a7382006b0a33ec52b130aea071d7a8076c5673105190a73deadfe2702b69e6b15a1a180c9124491911f4772efc0451bf5231c1d2c22bd32ca9efb495294c4a9c86dd5160df6c2813dd9bac5717f002035b7230377d9cca595059ea3b697e766133fbb76e30dda1745bc1f2cf31013175dedc4fe63c26dbde9e375b5a0a6e6df332744c7e3c1164561aa9069d2a5d2692f1a33982268dc5a13071cee8e0a0fb58399d0468750a361acd359042e7546e32826e4b91b00be2bcf470e8a0ac6abbcc6c3eadb725eac7f04db24100af9964d0c841eeb2e620567522d5456dfae8d4300fdbb0f07429b53678d9114014497b1d20ffdb56f8d5aaed39be80d7960ac5992a281ea737888d7b881e67cf65fa233772f1aaeb47766e405bf11243f2f4f70416f0522f942e2f409353f8f7b0c3833d9659d15432f775a664c759027bf0359010140b772eb954792af8d88b2085677fd1e342b203a2582550a3e0acf567ca07f0462e31d1df5b641f8d4340b728dec456fcc545f3e0d54d9d69a3cd027784b1ee1389efc3c49a483177885b89287c4fef289b0278f91f11c9dcad7da9b8c4668cebef81b2f46f76f6e330691c5712202d9ff70814183e357b7eb6d217237aea38dfe4e8c7e2f9e34a2a69c9bf0ad602957609c69a2aa4241e5fbd034780759ed55f252aa0da28963a61c0e7cc173a165f61fa1d57d7278369c92995942c1e0ddb286c8ea6ab091ac0d2c7522721da1f22ee5132f51890c3c867e49af5d4f42f06304d89e6a3c7073a702e91de98527a0d9006e5f00a424423daa1326f7730bca41cecd4ffd83edc775338c2a01d099c861a31eab1737af38638be7a35239dfb9d5778760391a623ce29292d970f7a6ee3f36529f752fb25893c3e707f5cfbe01d1f36baa7972898213c2a7fed331a1a3ee4200b1f9ed1bcb7695977aa6227e8553bd04784b9c262580426aff38d521d7150fde0dc0fef1219c482203f514b189b93216f525d33aa5f0ec3909085e819aff10970314dffc64ee1ccd69bab2e2d599cbf16583ad87307e8568bad5e2dcc8206bcc335b2a57041eed566718db31b1969f7b43040a83a1893c33353bba35a3ccb36ad9e2e71154439fc1c5318cc5ae1c6a3512420f0a4522c754da14cea022843742c176023815555cabc8a6c7273808f1bd82ac284a40d334a290837f1ffe27e406b9c0d10127a7399ec317e57ba965d8f90255584c251006102d2ce7391df1a30f301970372480d85feaf551862f5486b9194fcb142f7a4036f10e6c5a916d8dfeef2768ddfff55b6bfd2d49e9568c439f6bd0da8be5134d1f32c694419de4ae57bd8626c29f9d95c1c5b2cea1752667ee5416e33df93c2fa34d30a02eee5e4b6a27540546ded39e5d19cac8b6a5c3f9218caf130cee4eb85dd8d156a2473c8f31cb3d13f559a4429a5aee1a1af01173b93eeeae53a06907ca4a1aeec70d19842b8e6f571e79b3abe85cee89770ffe073ff6d7e0e8e23c31e83e429e2022bf7f2f269bbfb9d99ada217420207ec9759b0978dc09c1b0a5fc0cc1d176a56a32e33135e6f468ec0c82a186056b46884c4a49a942e9f163a276905752377716e52240d8f089f9801b4dd93422718f0a0de2aeec4d6a8f2b205210c015bd674d1d981274c86cbfb14bf5980e6367ebe02a3c4432b0254441903c042f9fe5b296d0ace6dbf356c310be98c7a091d5eb36a0a09d3ae7c0ee8d5da4f47cf5d8d0d55cd18f7c56ef28e5a77b63182c497e34e87a5ee77cbb46ce21fe4ce38caa4a7bed0b8c6812c77eb220e02b1d1ae5ba902ee14d69d2b5e04558007696be89864ca53b1c0c9360f4b184475ca0ca14788f2d5a1995c50cf515947ed5144599372c694debf97a9a837a72391049ce00995a328a754b07067ae6e0b1eed59ecf64f4fdefd95405b4321424742ad02528a8c37c2a2139b8fd967306cb92e74e826c2c63e92da987e3677fd3dcebe6cc27bf9926c970c514aa22cbbec55ef96098884af591bf1d606c2592b11b50011fdec0243e1945fa7285eb4e722883a5e3c18dd612d36ed2b0273c37e1ff9371609853b05bf57871c851b9ed5657b7be1c18ee43c2b18ce1a44035ba1aac5e7d908f30a4cb8b35b9ad0c697f2976d0610c7526b5a8820e45da1858ed385326aba1f10953e211b1039ebd207e031c0e0bad90a84e33bb1d89341c6d76320f7de8bf4cbfb210e25b557e8c60cd1040a35fcf44b1ad05567147f5ebdec168393a00f66e988b5475b7029b48ee886153bfa875f5589dc836124617156ad857f488a2da0da4013df62e5ec42690f59013d83acda6f67a6919e195af955721152ea6e220d04fb24d603c7dd9420679fc16d5d94706aa7bb42a59c7962ede2ab899363fa5daadac6752c0494495c2afada32cf31afa94e21e698754318ba80d35e08ab14cbdf6cf33ebf68cd260ccc294a005c3b2b579feba3b0a9e3bf58c595f626b9062ecec600bd127beff272e88a725dec8bbe36c45e8fa3d9f2333311850d73ec13b422d39c1add6605cfa46d2863297284f333cacb8a71e1517b9b4189c13755652a51b693b551a6ce11793b7784bbfd91dc1e5b24a3e5b3a081b8318c145e59880c5da56892619a0694f3d01f28ce26b0f0333d34633e3dc188b9bb54a7132e783e5d50e024c5c888f73c69d15dba2eaef33dfcd4d304b96a4b872c7330108a44fc52d1ef8fa9b47a6a859aa617886443d120252b9ca3113424a7bf4172fe7590bb2a19b2f2e49d91d88786cdde923241cbbd9d2d76ea1efe6bcfdedb36a34811bab415c28009553f0560fde2b8c0c41eb4612e314bb6f41612e42494b0627d1cb212b990bc700d472c09c81f6b525f29c26077b7bba3552ef96d850a81cb1d7e4209023253d19b0688f1058bfadf9112ca127295c4325969a7d860b546f6168c6bd2d93ffa2b9165e7b3e65e667b1fdfccfb265d1ce5b34eec76dc11da748a0460428a132a4837c5ba95eed0806beb79f7215d5f426fac8c216606ad51575c96e36174d2a11c91299812de386920a1c8a4bbe186f1e418e59ea43e06db2dbb2d14fa52f2e55c034ab9aac3dfff3370525f0346710a10a1d31de07eb9091b165b6f126791d64d6aa2c34ca365c7deb2bb74590e9ae09cc03bbf296af8bdc7c2554d329d4caee644703b6f80e3377473cdeddc7b4e8781184d7ce6a0366ed69bb676ae4ec3db7b89124db0294fb86d4729c2ae6db5c85436cc676d119284f3bef3717be3bf4c043d5da84f995618c9971ca6edb83d8339d78672fa1036987b31af557576866763f8bd92b6b71f5320547a946a65bd56e14cf11a6ad079293f6bc9650000fb46af8b25d203624794a15bb5fae25e235b05b8261ef14ecec3c7b32fd8a303b8214fae7a11ede5d85ef27034ed51185ca6a57485fbe7829bf0433e11fe39667407ed1573d165090ea84dec6933d21ca5759daecfcd82a1dc7a4a40db3b295fc62320771a9768229a31da66f4a612a5c2a654b374def6adac75fd5be91e38b4469bc0564234ec1b996d4e6f821a875f1362522fdad34b03c5f6d8a7e37e8d36ba98c0442893a610597037cb9209fb18804205d5bb1c153ee696a0dcabe3b7040bfa18ca486cf9ec3c08033fb7680a1f9f6448eaedd34a37df0dd220d749e668a00b8110fec1e4196839b85c6ca7ac80ca689c666ca34e9d3b9e4f226fcc6919b1eca1922bab441efb4f8ccd941d0733664249a726175725d167a9de2dce87076e7396e355fc2d015b2606753018e8d8fa8fc1771efdf28f7d10c5b2d00ebf8e068f55a0490a13600e73dadf89cabe94873cdaa02901d290317d685cc448aa17ab97fcd5aae70b52f89e3e5ad1bedf6342b5c18ff481dada748923756c1c71850440739f841c2fd89855577f079af4afdc5ba90cc04b13d9e1df27dba09b6ee45632a76171f90be0719115a992d8b10d7d11c33d0aa2d02602954967b551e70b921b4ce515865fcc44894d61fff7a7e6c9b6c88d21b78b9c8727b91506bfb6a75e91819b8fa0a4cc93d332bd786509771058d88a94390ebd8246b3c630be28a912a96746cf453cb3f1bfa7e84c43296fba2c4f3ceb10aaffc6747c778f89de759c3fd74f73295b79e2eb4378119136a79306a49f94a60c68779a422bc6f7fc78b466b5a12dbd0eb6f56f63de9006be0b37edf36955bea84db1abbdcd96ba602e99227a14bf92015ef7aedb9d58709cf777e4b40707e1c4b54994a651fac47a95d93c684130442d828308b71e9ea2b77790fad5ba11ec4d8e336bd0c73fcf9cda5e38d2e89f295bd67e8d0336469fb898f27d34effc3cc269ec77b53ddbc975f3e970b035dd67bfb36e7b6fcbda01732b8bc2980525a935112c6e9f1f284a10a7f7e2c357601e19e9469722adab13263efc1c69e74be09fdeed146e02ff009ff588510c8647e3dfdf504a9b04b5225b7769f6f6215431dd398d57e2d9ace3cce037ce8429bf0a2a1c25d52b0a519de3824497d1a31efe43fddb536c325887d54e4226f0b51c1b172f14b988d250e3db13211d3527a1251e96fb3d28490b47febf259e85d59627e406fbb39b52abb575a5e9ee9959316b762c0cb18e9e8ab82361ac666c4276a09a47cd926d68dc91b4f857dd1b639e9c706643d40173ed80cf596ac52c863b9dec4ec799dde5e5c9aaa059759d5b934ac8e8dba48188ac684a296982ee62ed1b53ab46923801b3dbc16189a69bc16748bdd8edb7ac8053c4ad8d8a169bb0861daa63e9dbc3cf977b48e40eeaec54a5c975564a6f54e0d364b4b4b97b449ba82108b9eac58c5f2d4172d5fcbc96ae9f07c95e8b7013ae2abbe87d13ba4fe3d84f873b7741a56d028d17023a0344800875c3478637523844b905863ed4877446eb3b130d13f5d9878fc9c96e6d78469c29bdc779d71dc9eadf5502de57fc387678a80b72ecc9fe12b48c7c3a075bdafed24d3d8c61718f695b971369e5393db9cf9a06b8bfae9e6f92a9faf6a844d814ed5e7b92d7c92ec7133b0413b8cd886b000d517aaa5e12e1faa2dba787e4e0e5315b9bf0f8a6c154b735e9195cbe6465603b587630f1205a9346b79261fcc43c6b09c1fcb5c6f593cc255bfb0ed63e6d6fa7d07eb0fea844b229e55b606ab275f4918f387c2484edf99c383fb44007f7c1ead04d450113019f64352b31a8506eb843ec11adc5fc7f9c0064f0f4e3d8212e8ef43bad85251b076fcb7609b20775a2189f490b03b7aac56581448bd1a4c057c6c0e1d0c9a06d64fe9b20e6df356c2b3450e34600bd56898a252fde22e5ca481297e01b8f8cfa4c76fedc93619340cfaa90daceaa86e7c4ec3bc9bbecea808d8688a6dacf9a4d17e0146ec1c401418b0bcbb3a4c0d4cf8f51c19e455e21650be20eeca7965147ad98fb4311e5a241b6061c6e92f5bd3751e3049489e2f819e98a86a6fa241a2c5174f0460f3fccc1e0a964beaf4c88c81752436b38fb2d61057b65d0d453e599dae39f32ed3eab607ddf6cd0c66813450987a76099effeee40df074fafaf58174c36f9661553959bb53c0e797a6431cd5461aca27aa91e9e5ab25d0d574d85a11edf36d3e1ec44bc1485af4ea2a5bce64307d298731ecd122a33de84c2b8b9608e305690d28637d16104d0ebc7d320d1c4b2a815336cfdf87561260a0d8f947c6a0f8d8edd9de32225679f463ccfb0e8b1f1c91943645b2390f5d888652eb288fb80527e68fbd83173a264c36e14009f26bd6628237770e225a3b0a4556e27c0ac7e16d41f188906f6d2da26c2835a8586e9085500c6788b10e796213a611f18870aceb377ba90cf4a1725c1f81643c95b98d77325afc850438fcc9833054880973d806fa6af112fec0234eb5bbf228bff9018550fce44e1150d34a71900cc25d81ea70617c59ff2af751b773ef7440b26aff17347279c0cced93cdf5f83f012f429b7f605e981b7534cf4a3caf52888d522d48ad900ac1769cf4b99bf1b8c07fb5b193df2b24fc6a63ec004ffee84ce5f22ffd74e78aaaf46c60fb85027e5afcfac409f2080f8cb70f4729246b8d992d849861d2665e4c5ea8e6eab0b029664ead64950844798054d6cf715e68a1424c12f8542629d320f1cd4b6da68e8fec571e4d5eab5f0c143cde7df5e9e51d5a877be1555f8fc06f0aa07546bf04e79f0cfd0a4dc3c2b78184f1fc34a090196046a4cf51d05962994dec581e6942ebe3ba01cba03ea0d308a1fcf718efec7fbff497d6debf47cd90f3d97f3af50606ecc274f9b682bdf32e3277174cfe661fe689728b9d56911e5f8a57241d7eb7f0a4b29203a121eac6f9af30a3f546729e3c520f7f4e699526cf754fd8ee8cd5982c88de39e81f2bf9284a5189656cacd63e6bf8c35328d88c01faee21695fd0f46c7bde4064019efa42bf5f64aa541775e3a929ea99de74da1c8c19c72866c5f6e4cb2bdcf40ec62b538aff52b2deafd54164f9bd05170421b18e8a213922cdd75ae0b4b5bd1cdb1542699afa097596d7f54d3f577384827eea3901575c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
