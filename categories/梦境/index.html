<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"739b07a37a1b4596357873af524763859f0f5a45bb72a49c190290fa3b434e264f3b4874d70180ff3bc3eaba41e84987db1d5ed50cc442429a5239424f11a93d22e1ea604e7fa6fba6ed33223a7fa7cbb6897065d45887ae17b123ef95afd0591cdd725e17b2be01409eba4843e20cbc7a082b33b2661399d7558d7af0b84fd80a1630943df37631b762bb48038e6ba1aa7529ec356f90f5da7eb1cd9ac9962552d1807f0762a2d622f31e6218c393704ef7412fbd81cf4fcedcddf4b48acc6ea1d81fc983eccd137da06a8568caff71aa8c004c8e84071bbfad3a3c7f44763ad9d2e64333d84ed5f02a4588d170c825d93e09ba3c554cb0a3207bbbdc3fd052fec6da3aeb6b3cefbb5a71fe5896b72ca6fa234aa3966b88556a2cc116a41e2286ff6fee30b1f63481adbb17f8c1a84a4e98f4ce298cf29e9a1dde94fa4b3194657269f184fa9d35d296aef1f39054e05de4ef03774e80ab2c1cd863857ce3b4df18bcb9a4fca05dd763966d7aa8348989fbb9f4343d6c9959ca413e13ee1416b1b3a50cd3281f88c65fc90a5a12627b9701d958bd41617603522a5271c4857ff7c5ded4ca4cfd20e1ef58421413d0fbb7d5d6d38e1d9445a1f848b9a8ac80e58def75cea8cdce9d18f5e61a520fd010876bac69c94995a72c371cd3e0328830dcecf610569fbb0c7508a476480d35ab47eb719a0b0071f56f4b7eccf2ed536da9a021920e28c0dd299a1f271e9c8fccbd2aefcc0487436419d0d8b3eb0dab08ee797197b27a0c636fff73c562223d372d9d86fa1506922732746e70b9e9a5abff79076f95cd887fbe546dcd324b3c64611bde19b57fb00f35e7d53852fb7284b2e6c75adf27c5a6dfaf6ce34de07953f36ccfad215e83349dfd0fa306f2917c0ddebf01895107f1b9167437290703b38e97331dea00d8f89cfdc5ed255a3eb2f5ea28d743186160b994c343641fc1af071de5a2dbfcd179eb8ac78233e4cf35ac6f6e3d4d74694332d690aac4d89476ac77a3bc9ae80d9ed63b74b4d9deef7a7193021d6d5809b5259b3256203f00a5bdbef100b217ed1b55738e48c2570afe0f7b3d70c2a39d547b3332a87686544cd841c3b553ce663b48069b4c2530660d01b3b45f073101f07842369d6aa3eb2a41c4b5af973eb55635bed3bc80be26f285e97fe77009eda8f6a0f0f8d147c26fcd7ef786f9e27eeb3f70ff23f9e8608587ebf87c1b041d2ab1a7a2f0a558000fbfb2b0dc6b1cf03a02e9f9086cd7c9dbd797466bd8b03e7b9fa8feead77ffd4a0113e785ab1b4bfd166534b0615385b1a34f678190c0accd59be31143ccf7e6c76bb651fe6125220b332f0b2478b96dbbecd28d1615c6cebd197ceef289af2762e21110dbb52b332812459cb91793f56c50f1d5b66875cd0bdb70576aed4f7a6b352b7fd04bb5c66b84af941e2155a6bb69d0313a9df680635d8d86276b1d52edc52a30703f250bd3a25e5f1dc902a87d6924e4d5a4433d6ed554d109aa08d75fec56794b9eba289441e2c1094d7a01bc5483f06b8949baa2f4cdd78808ec9abb116b2b11e1c12f06d8bab783365c0ea75500052354d4349c7de15eca4a0618a3f1fe88c31fd408d85aa327a2806b5d70796d70d6cb7bd7e090d78336eec4cbba85d0828883bae9ebd2ce9902b9df66ecb8bcbed9de13ed936574b1f69171d98c5d3f560a1e4676f80d86d099a61ae29fc3606128cf8a840741717b672212f5dfb297c3c7744d5fbe26cb8f3cbfee774fd4f931f19b4af29262d92580ea79ddbfab6b187c27f9eb13004e4f85fe60d742b525e2cb83de26b0ec7bfd988d0b9fb2324e8e54020e1e52ac9a6bdbafaf47aa5b3974323a0744a07e36d0898972c97754fbd71571c3dc74b37d576b6432b52cfe12aa0c41c0ef00cc4b049134e816e91ead91f58c342a4717ea83e0259b3dff535e5d1f37d911cd3b0cccc92cdfdcbd698bb6c47c0a2bfcd59e3b7824bcf3e57f45b307f3991c6693bd8f7347bbf22a219f7e248a5d327e9f7cc97626967fe099cb4ce220d3e13db30405e0efcc0addbb0d78573b35cab4492a77fac835fb2fe07980a2c484bbdb3742cf86c367d9c890d42fa59bd890b610958033d195b38636bb4055221251ceb3c858581c383b08301ab0e019a9d2a0d5767c0c7c505b899803caebde91258bff7f4fee32a57bee686e7296fb30009224b347ea4bb9293c81b6df9e0d54f2db5e047419e0e39d7bac7495cadcc42dd6ea388f5c5415a8f6671b134b0c0164821733dc13519d43e79ea6bae1ca4e8d4de4deb134916a78f14cdd92bdf43075dad719abda9674fc41d93d2b456e9beac54822ec918b1bc1de2b40b0a4df93843081ee7687f8d09a680f716c329be1ccfdf6d7929510c91462700dc426b49d665a91700eef6f07dedf5b3c6620ad4492eff482283a10f37e34269b3c51f1bb04eed1266dc6fe4e2030acd37519414a7238386b317655ea62d50e66ddacacf9a0c1f5f6fd1c34a99420da1a3d62371a6f17a3f17ea997430275447f0ae5e10ef04f696d4a27cf8c9cb2a5449dc4c056a26e87cb0c411eeb1135b0da98d5106b275f1481fa0eac398722d1553076d14cc8953494820f6116d49cd79ef4c4c4f1c4f42c406c16d21db926c87255d6779152f038380e67849d2748b62c51e0c6c837d76a69fade9a8bf8bac94b28c0fd8926576fae8400d0c01d0746e3f89593c3a843e9240512061463b73ad95937872fa9ac24d70a70a8cd66b079d237fd50bb74f2e8b0f090c53babf94406fde46c166b48f7ff7ac6446c25e919d687d6ad3a572cb520dc8873c4f406d28a81d74e88ab8b8356bab0fd29243cf08e2e5342a260830e344537c5af248c9e1bcdf41d3e3e6ccf197f757b9c15d52e20daf9d8051ebdcb3bea481a8a7ae128259f42e4fb6bf08c12084b2c3056826c5d9e4edf0444a0c95f1214624e545561d7d85df2885bb3ba098e7ddee1b9b010cd8fc6700be3ec6fd7c58b3ec9e40aab984ed2d28b6ab912d7cad13ccb242bce7e69df88b65def78c8345fc7c443641974d8c7a3669d7a86985c7b99bfc6e88c593155d9d808fc01e8d9324c6d26a7a2fd9dd99da350fba7b600d0078bbf65351ef5bd6c59169705169c02994ba18f0381114104c59bb144a6a0ecffc2d6e03e7e1f800c6a26fabf1843f2937def9bbc47827ac44b6903c169f3bdb6bec769b10cb80f73e130dac81776b60366d17a88da1d98ecfaf5d7c05db52c8c7a8a0e01942efe07569259d057dbdb49410a21b3dd200f0470ebe5d04a20d4cee01d4dc7c13ef3948a6f4e0dbce2dce28e9df83134f6c375beef0039303265da1be0b0754fe94a42c71644890059ff313810ec73713f8ed7c0ba1dc15bcbb3da33ee82ea4a1c48e575fe771abcf9fac2ce621418782c0d26fe166fb30cdd64c22d21a8e69b5c784684ddd7bc8314a3d96c34ce5f515d2ee950406517306729d38932cc5e4317ead22d123758ed91c742156f6623893ceb41a06aa2b5399f54012b419a66568678a4ff6b5e600d846f825f47a845d91766aa86d129fb4a0abee82d5099cf6e4bc2e7b138c478c29281e17e7254d7b4a89fb03d6ff3a398599fb2e801b8477085e7816105c832fdaa201d59e0898d2ea7b13bafc442c11429723b887a4fdd587e078ec816de57c9a467136da94d8535b0043c3919975c6a9510971658916a02aa392b4c5c951f791875cdd405eb9a1166a97366f25f9840c690124c8d11997dfc49b7e20eec9f56e1ea899275fef9814f35c6908d24c17115c21c1e08573fdef48c8eb36b2f1b5f54186e1a940055ebe0598056c3d72e3c4d4ee1f72a6c9ca3372a2a97c76ca8cd7c6bb65a671921312e12168452962ef44592c820d22c491f4e33a0a0d940d686b597d52936c7a844fbe678e6c29db1f398b60b9fb7bf7e60b16471cacb4a91a8646b36964c3a56ecc50fe42a9e1ae37fc56f8a8b75bc08dbd9d819e4612a8597451192c549e2624f7ca43c0c755cb656e2fb97ec48695a4ba1e0120fb5352a8b257f9cb89050692926df373c36adbf80cf28bc7bb26ada32066588b46073042b8a6198460fc8470b0da6012e46a9919c0a40ea46e2d233f668f70a882458cb25ea3fe1181ca68a40543f38d677d62130475f746d26c25bdef4d586d82ee0e28efbda3cf6b324e4f0e0b487ca6e8394db81e26f1b5588e5695d716c0564f40d1ca8d34c051141c8c5b9a881f1d20f9da4af4116d13efc39b12c02871bd341b21e5d749add9ee22a8c28febc89a900d2caa1e40c77621c8dd7b63cc21cb572e700ab606c31d4cbc9bce2b425b6ec40c317bf2b28fcf225c8c2f3769a971fcfeb91f18e06e86040566f2df89eb0320f28ed0e3e93eaaa2a9f5bf12c634d8c5b944a4735c576712b49edcc3fa97f809c046417cd8b6dc22954541d5b77014fd17d6c7ca13e131e8b12132485466150e91d23d7b2b5c6482648d4d5769133a65dc8cfaa833180fd424be04e220dc8329c9d05e2030559992b6f07aa2debe837562a3e4f0ca3b6efba7cc1560f6a72f638b14c3c48b768c8def89e0112a70123aee921e9fe77c2a5f87655006901a6d17e0f67bb0c7dd24c2d841144bc4671433860f7d7160d98ff90302e931f0dcc99e4c08398e254385d5541e62605b84d507675d0e0120666bf7a3731eee0a97653a48357d8b7670364729743a5e92fd842672a1bd95f46f4147cf0c5175b5e8d52c263d7abf67f48e38ec372bfc619367b278fdf9562814737d4a23043740537fb316e111f88804bc0750be379f72486ec4a0ce3188f16b1216e4481a3d845862e7da21a693bdbdd6b21f81b2713a77e22a2db4111359c05b082123fe5c225a6c779baadd8b489764351af937d20f26b2937d6db5951b797af8263763757544bf7c5787def4b216792a40fc73c0cad3e388e0b202297fc4eac2c4c9e6c08470d455581024ed12ef09358368cba99e72f76d44f6576a0ed31d36085a638d2c2ff79548439d1a62ea87369d6d3fe4f268d2ea7ff6c266ca33e03b48a3dd093015bfb6e6aa0ecf302db8fee1108937183540be8b77a87438e17d7fdcc7cf036d313c3c4c099d34a3ff83899d7bfade746c8aa03e7c2abb4b45b5fba623b3e389ab68c2566afe3ef516c3cef56dce61aaec06982fbadc6a99a09aa3e7b093db7f6777820d5e255f816c9b006e99b0822946ee19d3c5095bbd16f247aa129424d07f279a047459bd9f303a102a60e511037fd860f451da0e7edc3eb5ce1f5fe51e912ae51db151f9d653abdb83249e2869b429e3af809deb2786d436f802fe8fdd1485c27023170a9292401b923dcb0465a8367e14ceb5875ef2586347f91f8cb28f7aacdb5acba86c5627094b1afb2e79d014fddc8f5fc20355412d8f04ddf4bde3dea867d6daa504c5c483572bdb6da739ec5862505905ba866ed8a7059f29e686027a4eda1b91e5d6d784402c3537a0fa3d42a93cbd7eee475704120da0c1c638104e8603884d1d44a52384cd35325fbfa418aca7e225671341fcb185f5196c1ab1a036a6ca8701de9173746b503c31fb3eb3b6b97f513eed71bd84b298fe6bbde0356485888c20558bc4eb099d0d84d00bbd2c39af842010906925b3028475ec1edadb307795a8f66a16845438f7b21d25969816e18f54ff8d0044597dd798b6ea0af995885cd483d8e01d996e9a51404936977649e7978d2c04e81b9a6c1546178212869163aade2b54cd167e7f450f505dc3c4d65433d6cc5b5eaa348ceac3843eb4f55b812231b955a72a9530df11b5768cfc41d44a00dd5b131d37a0dd1ce765fc74be8782adf3276a363e7f4f14d79b8df3f4b070c43c34ca9cef42af4cc7e8b442fa6de134f43957eed2c7ae57d9377f9633f89b9fac5f77d4383ea2e102364d1046407941971b0dc32c5ee562d1f848a103b9eb2f17fecbccb3c217a915df94d2fff2821d96928a0f0d2060b63df7bce4e6e2c06cb72d27a1ad13d9e4d2ac2e287b346d0e710f077cf5abc0f967103841ab7a6bb4d5055df13cce7caf05d82fc214db08cde054a458a6236814efa9a6ebeb59c085be1b36169e932090a354b02622f423ed148f239ad8503147d885e11fc254b3e9930a0584172e9083b3035283423533bccbddb94562bf724d4ba6c2f395420c8a11e35c7653ed511c4f77ff1c0ab60af828f40c649fec8b4791e355331671c1750a82363e362adb8eb120a2191590035be1566a8d8009b7633f54eed2e2c6fc2b426f6e7d49ffe1f6868917d5d0cd9f9cda9d3bde818cff93227afc679f809828c754b70863a10f5fa1ab8b2aeb19d06c8921a1424eb41d8483a233fe0ab93ad09bc15f19a8d32235139a3b1c280715dd2b1d2dadafd1ad129c89ee95a03e3d9d0c6314c58af1038725dcb38ca88c51a666c4495603267c33e9eae814cdc66a4219b55e24736007ec96e5187029117e839b6a256273e7e0c2e0bb9eca7f156e8a09e22b5a7c51d2df0722462f86647a2ac817b66f0392de16ff2a58f1440e6ba845c41b298a197aff0aa9a21d27d59e5814bbded2e2664041ac849a1768ef203a0680524546713c0070f871029c755985dd31bcdfa4cd35a214517814fcb78c7a4d50ef79be03a49571afebf43a7f716ebd9dd3a135003730bc3dda322a9140ffe406208bf824d3b2ad50fe05062e346ef8081a17b7807ac4c32a91e00a2e1f3b25b2184e6171b2aebcebc251b43f0f664b067e50f76dc481567e4b374a244fa88a656fb6ea591124e21ac6c4b281dd96d95bb94ff1543e154596c91b0888b86e7a63c772fb13dde4438b416664e6cb745e78b152c70a78c6baed1590c94eb59bb4cd3034367bac8f29e554ac8839fafbe1b8943cc6d626c7dc397f8bdc0435be02928647459fefa01d67d3a26c6afe0a4ae0078bd2d861513687182ef60f54a829a48a7fb04a74cbd939f2d88c46207ec23d35f4c8b3d17032ec83a457dc758e69e8ff852b9dba0f4d169150206ba0170294f20ccb22f9084cac1793b918100a20f34796f84b760cf3a7e2c2bc86db248f201c59c6052ca8db85b18b123581daae3a49c8f6c01d6c608ba2e4bb8a7c127585c4fd74867c2031b55671f37b584957362bca74f9b1b91d22a0279860cb246d33d152997e849e2076b5c669a845586e783e4a4bc2417c274c9719b8fc79fbf787e5adf5e067863e855ae0371c0eadf9d579a29a1ddf36d06bda9c0f43f1f59b7e468178b9fd8fe34b2a6eb5da7beef4ee2104376708507a758ec5af795931b029603b1aaedc7492faa9fc620395b946bd53ca824fe9259be83d7bb99453002f10ff8b690cf9116c4c5881b10bd313bdca2ee9aa3a068d43e8260794ebd73f516d6f7a982998990619e0bd3449cc71d31f53f61688be9dcb519206b54e9b59f1db1020e422b545c3a88c56ad52e09af378c90321aa0ece66c3ee6d41b935cc2f1cc313a0279ed0ed994084de3417fdc5128c2cb28c7b177a5d4b7a4f8dd952089b65db97486a9cc7789c0108f8b06eb60989ff3eb33c34339e2c0952ba67ca0a85248da0df3521501101b197bbd37ddebe1a74211fa74198ab1370cfdae5a7ecb12def65fba380aa0a2a8db206c2ffc861eb1751b85563043bb6f0eae6afc5f516dae56e3556e1c6cc0aecb9e9cc5eb10a57fcc2d4a68e9c7a5e32196e56cf0b4daefa7a4432dd1eca58fc18343ff05fe6cb57e9823e78c7497f83007e5ead385f8331f83bee0fea58e8f15d8aff6cc1277308ae2aeafc1870af122112445b5356b547e8f63428474d4508ab3873688ef7897baf4c2f54dfc3774a41cc9f6f31c7972ac940cc1907fe230faac0b458664a45d00480cd2bfbb2d3cb4b1deeb5d11788069e3c7e23c6033775a7344bc6b8431f5f310d5db21c24c6b05b5c29ab3f4ac476dabd1b1a33f71de5cabf2205fe865883d937d41fbfd8ceab79b3db40b22e418282b51de46f62a00e4cc787ca2596f6fbb4e0f29d58d113f868f920b2e6ee0f44bbb79655bb31396ba4a2e492ad31b45b747ebbc9bce5aa48f453726b8ca5273c4b82ba73089e3089f657334b0ef9580c08ec811e2eeb03020bbc99602e0849d8e17ce11935501cd7454f891ff2d9d5b32a8e221eb5f8461bb631b5ce38d9d58b70459f67adbf50dd6010de57c2b9367baf0def22441f719fb6ff8d03d17fd8f8da15612a0491e3af9e0d27dc0687215463bf3f9af85d49e09fc02c0e029c81e3f4df6fbef444ae70a1d0a04ad06422bf882e785ab3607c29eb46c6f02e062c89fe0b1526a716c4e7bd69860a75e7e964718c5b3b4cd1ff3a60e6cf0c54e945542dd13378f2e6b750bad9cfa63fa45b07afad8249aa4f85182f3a9f07a8244f447857bf1a2b1e3c77092c4a7f6121ed267c940b75b74f82b45ddbaaf87cc539e033c551550b7974037c6f58338bca95173b414e34cabd19d29dc1c951c40d95023ece2891aede5e26806ad43218d7dedd5b4342d8f2d03f97ced4c67733cc373d8b9d9953f77e201e7cb9275626f32d142510f9fb029290e7273a19cb9aac300c6a57278726ccfd16da7e0a44a15bb503e856e64d3380488b1f788d39095de6f579f7f2c2ae85b3b705a854e05b3085a073e308a9c9890ca2bcb004b7b8918a86e3d4ab2d465453f7dec1ec2e62b47f52b3d932a9cbb9ebafc52e27304977c62b4445894cc72631516ad9da38a7b34b369bc6faf7d29c5e42ca796631d78091cb6065c415d845ff55ab9d2a1520a45ea6d653813103df904f9f8f1f32cc87984fc8fe43d3a9427ff25db1d7ae12da9ce6e6c4ed540aca8df6d3bfafc7696af3a122969da2e278c74cbc34fe4fcb1fcb109e3b709b0da4f2f1e963c3f8c24da603f0291ef0be6b97340d72ae4acb5cd0fea5836f3e9b14ebed4481b783b4733ca726a788ceb4266d27c07a7ab8fe5dfe5eeab02d1368a8a020d62ed710754fd3981a56dd628ce0b3e3a340fe7618eef6b11ae647ff785b1394b31c458a377b96f31dfa98393319715d1ee7b0501c8f1f6dea57c98987fdd54bfe90eb1b97251fcf9bf3f2aede7a5ffc7901119430ed51cf2758dbd9cbfb25dae95b6257be3c7d2d9bf45e289e4bff03c9b785a4a47c1d9bef59fc46475559acf4094041d3195ab69494c6042d0df0a48ad74f5801c06e473f065b3880b8b91b0a39d6f124ca277f0187e019f96d4d08f72dd1c15dc7af33bf829229d52f31c8ccfd0494ca6906389299d65233afcb4a550883a2013e7cbf120162fd8318ba0cd67d71bf1bcb584e6f21783ac1d5b7443b5ed34f7ba38af92871bfa90a28c35b6c2443de2bd06357c737f8369efa3d0df3c9741ec158ff2ccb641899ebd5dde292a7daeaf1d8f31f9a7a2ba4e8230fbcd0bcf9cff4c9243a95965a46bcb353111b2704eb86603385a635f951a20eb4ac9738a8e7ac1fa67997a7bf57477502ef4138793179b8f2b24c15c777715746b54c65b59da33f0be45c4d0fdd4b2fc3969b14636986fb6599c88b971e34842437d15ae3f55fdd3294bbe26e86c1473800ebf4eb41f777624b284c84b6e3fafae06f5797997c9ab3e3ccc0ac51aa9b4c7616c8926586ae4bce8c7163025ebdf142b7dd291fff894a27e1ab5a2e0fb5b1cbe4db0a18a1cf30d9813a975a5132aab7767ea0ab3027260582d6dcc3ec2a1902d17da53611b11a3d6c1a60c0b091750ce54a04e360cd1b29b4f5fad50e531ee5673386cfedb97086176daa7390bb20ecde44342cc0768702fab365cd41ee8e9ec4065a49ecd06743fa1cd95b69b03121a61c668b02161820b53db8008592cd7d04b22d9c1c7d2f6406338ae696daece6c2636ff5b2a4bd43a46acdaa22f6c7b161114331484995192b2f799323ddbd6fa6213cf386aea55a55d9ad517810edf6447d9224e546e471faa1c1edef3d15b97bc995bda45464b08c54df129e41955e6faeb713f5f045bb4fb37f3c2b0dc4f861829f40b78cc0347c23e646b910924660d2f107ed159a09d062acd2d24f25c8ce1d9f53a4daa84803bfbcc9e0d121273776f7c91032745a87310d0ea954451b8596dfdb91a8ec496cc6ce5a6974e9413317f1408a6b5bed372e245d7fc6d480645943e74ed7593001614609cd51a21cd7120e5ca84247b25bbdf49930f51242318d597e29598972b6256a5dbcc7595b928743558ea5f90a23928bcf6c69dbe11222aa961a2a521b7329c0618f532d9244347eaab95d4da6de945698035f72b711c0bd9d15c2404de1b2429c11d557507cfe474d0590a389bb5f8f9336b9fd18726b1ddd3a907b7d4e5aa0048bd4de6592b1ed50cf2758cdb13e3065b8a136f3e8e8e092d026a924459fea74bb148d0485221f10523eb1c6c6286e4fff4abdfd461b8dadd280defc1c4ade997a0f5a283f8171c2ecda0cdc8bab7495f09ac4c9f77f054885f4ef7894c80fe17b4cea60422c25f5126052ea9b97901a0690c05999c2d530971acc68da1e73494170e1db471a73c4c3e6e169682e804efd75684887c717eb3422595796dfd2f8ee118f308c7da0805e3823f328c47e2bcef16c7300a052cd55b44bfe4895d3f15d43d8baf3cf20acc341e5ffe443085a312baca26cd48ede3344f1f4fbc8c7ab9d9a6bdcd780c0e0ebd7c0583ed87558c636e5ae18403b88b228196d1f952a367ce30d01567838c70997e60586e1e3aeb2edb504d19dc6b1224dffe21222cdd68bb128afe9a96244aafefa7f9ce9da6b0518cb382c345e4ec8c2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
