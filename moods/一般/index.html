<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0047617f31bd7d146c68fc9b082b0a8b9c4c29a5f51a5a5b742e1b49d8aaab6bbab54df24954a27933cd4c7d7198ffe16999d74939ffa41dec7208aae3adb01b3979e1298abbb3d31e39c8674d41918b1b82baf5dfec936f20b5ce329c33fc25be861e6b6c4720e8566313d40d0d8bfd2ebd45370d6891bf917c8d28128823b50467566099599436141804f0f99760fdbc663a00c8a0894ecdacc874f8bc22aba1a6bd1e9a0c43a39ccf8d5f39c5c6295dac78ec7eea695a9f0634ddf4d24d0224747fd81d3ca87fb3b9a9c7e536ed9a2aec4862dc650b41ccd5ab8b1725a5574b882f99b344b2b90e589b5d8d2d8a327dd688f8a706c59e57edae172f01d05b19e5572b011b4a2dd4dd0a889fa9d92f49d2776e4a11ab9bc05eb5dbbd33465bf0eb5c870294564d4035f7ae35e47a89b9dc926cda353598d1916e9bbba1ffa0a9f534009d612953e308dd971e5432d3afb8de3fc398eb33caab3e0bd18673e7a9604946a51a47f10da62e2c32a5cdae7e136af14d483f92bcd32f093c158144497b7caa641f4c0eaff4da0e03d476d15a10614519be3f4d89d73a8ea3866a36c81162ec67c5aa386e291408e3d27248d5f37a3aed2f06a21eb55c44fc1bf45e4b82ab9bed4578e7bc4c642754feec8e860515859e19c116508d59a6519ee094b709bd0aefb8bede513cd26c6e0ca4debdde5875187645b1ae62ebf17d160bf1c8ab3a932e11ca4d77dd46beb1642bc268bacf8eb121611a0219c6fac728065d2e2ff1aeaffcfdf9863b605b45b48386130a799937b0232ee46fd4937434e324e6673039f611598baf34ee64481e540df57ecf5fa4c8135914a0b4131e920c27d0dcb122c391871763dd575558326876ce4e854fe03b69314d74166a2abf29d55a9472479f8d6e0627169481be14c562e79d1cef7f424de9d10d52ba5567afbf579455c3de5e349044a33456d08b2f06faa7101be9f9994a38749fa2f541cfa7b9a5627dfe1ee1612468b4454709cfb9c1b8b0508c9ff2058fb188ab4d36c8aa19e9a6e7119e75b289a2225b9c1da59a04a54aca1c985645fe0961761514482a158c60d51eabd616a683cf03caa145ac5a35245c03694a8f26f3b31c7120ecbbf067452dd788392a0301b535d6bb8ffbdd190bbddaa5bf53defd2f4a09977aa3bab47c0bafbaab05090ce2a493fbac1d8105d62a822e2eec9ee628cd30dabf784c8c95a35b091b883e0d7c74ee33a3566dd6c762b6529df42a3a90594e51fb38dc03b78c261da91df7bcc22c4ae3279aa59da1f9f2401194a44a39ff1296246c710403ba364ee4b5830bc3a0a17e1885102a6451cb8c90695cbce3cc27d6206fd4872542f9dc8083ad5f7aa750474b7569cb56ea08636bc6fe14dfcbebfc3867e7f40b40cccadaa65d88717e3f65cc3275186558f6808aaa7eeb1cf1912311b721f3a0cbf9d67b6b342f56869054102d67ea1fe7d02e6301ae6ee61e75d2a7fecf5fa7541319c7c715dca463c09e45bbd731dad982ec9ab373c2c605f57b281f1d0f2a8f53d520c054bf2a8f0d1aea6bf553773c7b66a3f83041da6242752de1b505ef168da9b12c2cfec664c8e56bc21afd5700bc0271feba82b0e2fed66b61e6668ef4b8b242d7fe5906c5d5c2e38bfd0dcbd4dc4f75a98baaca132347b29d32d42d26633a863ad345140d31283a99af4672aa698686c683a327862f5bfa5ea70c489fe2af4a915b3612ff5dd04fb222a2c361d4145c6b075cdfb134ec10b0ceedf9dfdf2a8efd856dac1621e0223428c6d0f469454e390e88d4279d9062f2d2f024325b5496d07a67d4f77856824d8d245fff2aa8e280b39f6ff710ceb8b5be1e544e67f1e5a20c086816380320ab5d6c288c04a7e4b403817d4e0bc42aa33dbfaab9a75efcc1409ee589c67e172fa8cb95ce67e49a1fdf868a441129bd8b4dccb2f9e3fb3d4f5ba0e7bc8219ebab9db2f07f17ccb8e2d5ee75e2809b41ae610db78b83c768b366d31f2b53318aafc16225b9522a3407f8340d30eb3746f7a1f7d8e1ec274511f8ae1119f5ef3fe0bb7f800e5511440b6b5602a07b904e10772d16205f224f439ea999b594938e7554b9b1260e20ecfaab3ceac70dc648ada70ad0842d0da40a4fe16e8fa79c714cfcaa41c42a5cc919da0b73d92aa2a15e9a38f5d881be085e00b2c32ef44fd927ff3383898de988392fa546b745e28c529659d130949a18a1a9582555bd56d5942ec8309afe7f66c69c1af84365757c9bdc5842ba59dc7ab0258965c6a15770bc32e779474ce3d8dc0ea70b64982d6f58735f9a01b7452ae0fe484929013adf549942ae8802681ceef8f5a2b3cd6aff1f3e4e9fefc1a06fbb730d5e5696f55c07e4265a49696f40ccfeaf91416cfcfdf2dbe987b9588ad563ebb277f8d2b34a825a130981f3c31e8b6a3e8435023f88c96dab4445efa3a8f0ca3cca457394546d6a26dacf23152cdd5a6e4ed22e9a9db952f525e986f4d72fe434d791207e686a9215d4d92198c0f42edf6641c165297bb37d7e610e838feeeb7676218bd764c2498392d78dfe9a0d08c799b8e1046d17e381c5a4cb29c201347fb04dad758c2034cfe3a15c5a10adab80c91387e474a293f63a1474d1f21605c96cacf4ee377f4fb92ba7d97fc9f43e23031fb2e76b806408f75dbc06f8e6f865010d613db00f19ca296dcc59afc1d0f3ce61e4253ae5c92477df649a0addc7893eaf707ea52da4ff5398c77ddb4bd9d0b26769b17170bb22f502c9b7c6ef0fec89a8ca92640b1de67962ccfd23a42dd4bbee632feee9556f09b4ec374d35285d75971d8d0bb0ad839686af62b823343e7a096aecdf92cc4be2cafc7723ef0aa5e61dd9c80b16186380ef017c00f078e10305caf73b9cdc42e8819ad8ba16eac998cc5e50ae2598b0a4e37273643c82628640a6a5ae98e9a393e6313fdb551ebe0c0e4d80e7d50c42c7a349c4b8c24f649dfcdd19205afc240eedf2c8632b72d3e9d220d4038f9a7ce6d17358414e07955892e0a13f2c37beb5b998dca7e62c5f2c5949155bd3f63f19e332837d4c22c1e7c1d406eb2f71cbe9f218aa58f173c462d6a9b9645d5f99b63c5b419ed280ee3ac145939d3a57c0ed41b3fbfae2b4f8e995491acc153321982b3d1d6526244c5fe68e3a874a1db715f85c4e7930c07f7ead37b52d363fcf8a0d7949b814342be9ea0249ace586ad6f0a4cdd9c94b1cb703cf77550d4fb1e8ec416b1bbb0921b2f26d9698d8dae1f8abc5ba16002e39afce72e9add65552194b76a1789f676684fd921220e9b6a52f56f9e5d7b6a7b253cb03575da25582bfc10bc09d8f9305ede9ae38657b083e589b1468154459272c566fd309957c50f9fa8a5dafe0420e77ca6656f566d6d6c060d9f8c7b46194e4e168420f98e40f7eee0242525366d6f79a4ffe00f39eb2356112500bc79001f8a19292e5fbd7eaeda4e86b4d2ed9e44a7bdd58f88d1b4201166707960feecde4dfb1cbac18b30e95bc6da95091b2aee9538a51f93894e19474a5e73cb22cf95110acd0c4172084ec12f903575165b63b413466550ddec352b303b2a2ffafc941d5f23c8828934b048112a0a769aba5b8664ce79abac7511b2d92813b67c0146e142ff00e6e5f085a520fd04ab9f8fcc14fc13085adbcc9e7da2d409e7c33238c120547ba51036eda68efa9498f22ceadad9c6aeae083b57e662330275bd616c36a238144870d0e94808024e1cb80672d1202295caec399316548175811024e4d7558868c75640699d2231aecfef9cd01b8ce68ef7f29a723ea0e1a3336119cd4569e45a8e38a14d959f8ded650e47064c6cdfb5b50774ec2eec15d6d6134a0df531f8a21c41d7d62675e6e041b60270173451d01080687b1b4d56837d1e7188fac7a3ceb82d7987087b8c08d4144d505fa6ab5726a4c35c993399232aa8f2d0e66cd2246fa2a9798176f78b982aedb5d4b8b0bcccb40af63593a5d56146bd0aeb9b69501a878730e96fd24fa7f2cbf6c944e3e2ceea9e031810a746b24d43f347acc1d08ba8734256b9324847eae41223acde404b6a9204be80fbcf7b9245797302548f323688873b901bc680ebd3acf9803155adbce5a6eb30a5205a0cc79529fd0f96cd16582c50e551d76d684e2194cc6f79b3d0bacded7689f78a5367c645bcc09631b3d3dd2d3d4754112b96e8c68d9610bd830b42c23bc5489d2eff89b379feb0455ae61c208c59c59e7a86ddc2d8bd3254c90d8f7cd8c6a6302c286a800b6ba20c7509a318a77ed4d1ba1814da6bdb445dad9fc22a5310069ee638e0f2c17f5b489c3f297b87a0f63d27b06de743106beaad21b56dde0e5078f0efe3fa79a5b86160718a14d0e7d05956799bbdf215fd8bd37304915a379e8ec6f02db513a3dd7ff214e0d236b272b37c545ef7d40e659d1f14373bb7a1d24d7a667720e91c8aca0a8128cf8cae2d9a6e30b249702b694d12f6210cff6a4220696bca51346da207c420516181f32fb7f21379e5757f4a05f3785f007217426b60884990c1a915544f472ebd0ff0737bbcc2aab4f3cf628781aa06bddca9177d15f68bfd6a8be090cef1ae18a4b536aec0113b3ba14c0d26a75373c5966399c436e7c690349bd052d7db43e5247bbec2be4da8c79b65c2d687e9fabadcd3e84c5cbe8078d8e2a706acee7d14967469d829de0e86183adce28f7080fd059795b845715904fa3d0f567944cb5482420be421f51ac68ecd8d26b9dda1fe8153f246f2564627df456cfb81e62c867345a7bbf8c88b314d5f5ccf1d716ddf2da3101354292fb23a7b4c931066cb9b2d5ef16d2db317dd87994d8b5d09eb33fa3d82fc5c825248b5eddc0e59fb1f42219f134d87d91aa8afdf99dd47a07abfc122797e3b2515a5a3d7948f05cb2c24379a641716f45721d22cd5b3981dcb9eccc5899425b1a89e7bdf9182bdbc3bdd12fb98e9dc3255b6dd56078bf465d16fe3205915a61ba6dfa8f587b7984272742299bca4742c7d0b641a61c6cb8f0dfa85254abd9da78f75e6f83664fbbe0bc184b120c79f7fd47e2a6039ec1f2b1fbbccb4c1db4931e149f7d98277ecf68708f1ed849735d7fd2a52c82e63c6cc792024251ca53daa42b1076d18467bec2645b8b4ddb77315689e176336b819be3766ea3132ac63e94b5054d307ef664349dff5dadfd0eb68698ce067ff55de540a7bb3e1c3730575bd4893a72f9a8a8556e8b2af8a67dd16ce69f7f2e82dd579392720c519304fa6726bbd5973cb1b2ae1c39b6b7d0a24deb3e364ad996250b8ea4b30a317041302b87566fa6b38ee223fee818149249d4966824637212105e268c842a8eb92301f4ad6f9ea659d346998d99c5dd19977e8e65db4321c5a454f530a3d0931d283b019b8f627d44d6f30610536992ac8a1f0372bc0bac9ea2062c1029d393e95450d3fb889b64b7816ae9695e5b6020c3901cb6724a7369dfe54510d35722eae7aa096b1df7a50c43e37708b6cfab15bace4e1fa42be06f69b9b1f23eed493e8c0ef5cbba06291fb0efce1233f9ff98b679771ba65e3f73cc4b4a60650ebba171713bcc9a90d61b57afcd027d8202e7d708322f59f7b7dded113911fd7aaefe422d11f8d4b3f73e97770ba3594395a45e13c469f44f15d2b8a287491dfde17ecab1225fb0511a68afe3c52aa77d14fee9dff96e50b721dc24333c01789c09ec7375544ce2db7ea2022c77816b7ddb86f409f0db0a48a4034e31fdf309a11cf1af6445d938b96c9b5bc59a64ae6a745c19f520c09d71b4c6f936b7cca8db05b382cebdf7b6208828d00b9f2269b9fc4f26cdb85464ebb46fbfe3a353c59c5569c76f8ae3cfec33e517c675c20a0590094d8f32be7ff3f3fb4414118145470f4227ce238a41c9e17dc16800e88acf44b77f7a869605dea75ec94d8addcfb29c73dc7bc26a85d65f32d5f64609c154c2a99adb826c4fff171c19970f54e6cfe9fc175f1613800c5ac181f763a0a0b220ecd2a71c7010737562c7f7079b1e086956de22de791987279a1e3b15385581b88a27889468b16735edf43bc388d3332d214e8fe6d6a0b0894095519bf2db2f6df55940b1eb7f0a69b88baa63af97a81b8bbe7488d1e8766c6109a8bc7f7b5922b5f9a93710efd89063f8bf7ec199d9e0f06fd84710ebeaff3ee11b577dc82c9c89181c9b95d4fbb6fe39bcc3121d1f99ef40ebc6b85055252d9d3086c97f0617f36960f6bff5116f04238c58816a09fb058252731988ca6f309ce84b359d3cfb9a097538aea758cb5fe936fe14ac3dd54343411eda250c279f783d36c7e714d34302118ca20f607a2397946f177236b36277fd14194439e5d45a9df0c636ef8bf9eac41ff89ce121e0a8e54cb780fada9055aa424234917d728cae35fd64d0c4ba2656efd58c51df8009c80039bbd9d4bdf143fbbdc451bff66cf47176d31463d3a7115a01920544d43597fabae84cc0141ed3c1186b2b2739170aaf15faed3c206a4ea8fcebc2afa055b8c5b7ba82b66e81a8124377a9ea6e7c69e31c25368295de43279ae1349aed243be8d1878cde1efcb41ece113631560384fe8dedcbdcf8575408015b51d221e1542cec7e1762640c4febb2f9c0b896ba3dbcf98dca6f25ba8c5a60abbdc425ce76bbd2cab44955e8fbe204859879081770c03fce8741c41ab13b80673275eff1c5620aae2e73bb06d88d3f497980910a4ab1014362942095b173fc105a12eb68608b01e51d6ee68a29a76df22bcc41e782c4057a08fd330649ed1b245dbfe974820c4dbc654ef1170cae104aa23ab7379ab492b59ea256ba1d65bc83d084487f5a44513c380349ccf23a511df3f408c44b93869721ddb339c667afaa9a7a3ba86a39a540bf8cc89f0d9de81def623124bd755a7e8e06428e38e6dfa40cdfa4684d1508def82144f99996a446837463466cdd84eff60745d79537ad85434aeda98e49bb7145671d746bc3f8cf900b5182465fc1ce78fe3d36d38a67ff4a6a654a3bc7f9deaa98acda708331f49de8aaeb5347c74fa8d781833a4ba9cc88d6e959bc4f8f12a4ab352477b6c3cc9d3e952d2740dc39441c45da0c6ecfec36a9df17a30891ac5ed7392d141958bb749487fe5958ae8b08d85eb0626bdc9e9333b89903df4416530f0c71218ec97720c607c0127ff31fa34e61763bfbbf4e153bb3212b954f80d922a3ac246d20a9a00140fb228e375712d93a3ec4fc38deaaa6983bf368374e3ef19945aab50753c2753ce1fbae2e9c03fbae1ab6c2259790a6cff47094d9427fd5d42ddab452fba9955aa9eeabb826d62b76634d2a9287fe845ae99c502ce1289d8aa01ee11020925bd84f7a2966a25002fd352efa9be4a239cd53dfafacc442f5af63ba1bfb4f4a88d0216791bfea1ebb5fcc003c83abf156ac1c5d1beff0bc326a69b11aa322bab14b18cbabad0cf2ee282e82d46bab16a8e7ba7a78732d3e2f7ea2914ebf578ef9c90a01d698ea65b57bc61ee8d84d4895286178edb5de65d1135ff51d11bccfc319c585e66560a5a34d4b5a83218791e6f984d7f40a96cd6d10efbc048776eb7d793d2445fdf4cc2163dd94d9338ebfcf380bf7a71111374455ca6593249cc575ebbc20bd756796ccffb2e8b79c1dc3938c95699162d09e033c1e43ee3007dad0d7e547d59b4e23a8d42dbd457b6c514e5cf6c5bb872862f9f028c9a63559fd6325c58078d4513c38372cb75383691ff7ca0cfebbaa7499a53c797cd2097e52c8d99f806d165cd66195a02ebe448f87c1281876f3d94a781e781345d9379f059ac5d593e13565225333b95244847755c7ccb94520a9f228dada84bfbc5a0c30c3355900dfa1034c156e8e85788ab9e0ce363b6ebd010de5a0005f5a4c1f0623c5e559fb43b1ed01bd16e4d49fbeb284172d5cf6077905c27fdbc0a0d1b12c3e3c490ff15e897fad6892f88ed44ee3d9a3009f731498ee3a2be4676f0406725c56bc870595eb2dfd2027c229fc192850226784cf30194ed1fcab349650913b0949f7d16a68f9a9c406372dec3e8cd07974b9fbf77eefa305e3674ab8dba6fcd2cd0c259c07dc07c88191e116a427ab657d58d45e63f025a264f4fad113b84d736e6e13783d94d0af0c70de72f916fc4024f03776a3a5af3081e4b86110ca11664a56a9b46bc1abf6a61d320a96a04353465cd966caa3d2811ba5c4234c0cb5d6ecc2719ef2e3c9f1119470d2dd43e1c49c957462e3a48dd615938442e40acd0252a95e1c7c86a7218bd0f2656a7465b502b6c41047c9091986ce9b8e36dea60e6365bb584caad7846163342704ef232f80e91c50c9de4330fa273629e3f4c9c553892f7b24bc926259c030afdb6e0e3e59e2103229e3d9aea79d4749ce228c1ef08d68207df4efbb42a4b22516fa27a4bab6bdc67ce7978bb654004584b3045762f822d281773ac3151e3f16c60f21e66e27962b48f059cd85a5d6537710f6a576c852eccfffa5fed6414210182cd84455e934a4e6511594d8700e4d81a2fa412fee872ef4da61a2305d28d757bbf2b28b0d8d6cae64cb6a44869d039bbab13f41a3d70cf5c4854084a82065070cae308f9c10231a23dfbc0b835adf17df3a2659c37ee72131b9aff063d5912e9bbb3bf25ccde2dece3cc84c8d59344de0340815eafd6ac2604e2b032babd16152dea67577aee2976c8ce7b8cf82d12b24a8381ffdaadb6164aabeb6c7a9078a1de06fe1ef722e0ca07fcb9733b2e3fbcc46838a46758fc1658d7525688764ea4efadf41e0f5c8d5698c14d502eaea4bdb9824876064715082c5430f8035334acc28856c2b716d236a81e1ff84a4aa90d2305f0a421bb9922a974039f0df5f2ea3dac96a29f7382f92a154157e536b47b7a5da854482e65205b0efc93f34dfeb0e201ce26cb4bdee4cefe3be853dc785c69831c22a607ff4a65b3680a7b7105d708fa51888e87e475b628e8ff1681e9112f038097d555758c6a5269adf13f0ca81f50be7e5184de6da72bed9ee56df0f54b2e2504e034510e4db4c798e6393f06dbe3ae802a1a52ada0f3523a587fb4343b7f00a396658b51eed1f3f99631d7a1d142fcbc96feb1b0bef53bdacdf228e26cbaff662ba06bdedd512ae7300ff0021bf77a00a3976191b299ea4e8a602b37b753f1ff161f10111cf578ad21946126dd3efeba263ca522c6b3d0f6898fe9d4a03d3bde8ab736b77ccbc3f0f5ddd396a68ddca728e00c9c71d9bda6a8d7fb0b83c8882be24dd8f7decd09aa229f5652c701a8a747d8b1b3722dd0f04ade8636709f5e0fd301567733df5efb3f0ece94936d83771fbbc038c5071ad5d607f123809364cd79999009c30e94772d1ef2c65565b19cbb30358d0453694280d470a47b36972e1015aa1797a96aa8f9a69e2a932139a841ac69a4059b6308738d7ab3801636a35cd3592798c4fbf0a0e30a408c7d221e8cc0792dcaf09b619e9d2677c061aeb7ef32f68848467aceeb5b9b264c2dfd20a825eeda031d49d2b53e1ecfb7c66f78682e313f920f285bbb2b509c5fe153a3b7eb7592155ea2dcb4e3fa4235fd728e6351a9931f5cc54a648cb6e67d1820728dd314503065d0d283fde69e004e8c766fac322597d93b2a11d3e52540a643b2c18892e998d84801c5be14aea5939b64b77f704f866bb62d3eb4980257682bd010e9c9d3cff0ef4c438ef725129342159fe3fcb0b4439d7b0d931e93861fddb883c3288c30ca79bd9d011cd0d1ffca43fda5c396d3b2c6a8b1fb4a969b083d5879da4e7d2cd1620739bfda452c282b683864111d661ee960ca6455cf19db1a97b3dd83a89b77103708b2b9ff959a39e3b2d5361aa70c044c49bc9bd675f9b47683d5abd26f076514ac7c45b8f5afcfa6fe3f28361dfa06af35b3d40205edb29da7e66e146fed6e3d209d1662a401db5bd313d95e2c52cda720f44a1c224103c689302ea70be996a837412c5f238b352cdf2c1f7a8c4dab1ff204154046a9392407d95ba2adafc76b6187b331a0d6af7a67ed21c8fb00239b17e8715237b7dc7746af719a386cd7f817595dfdf307d01c8eac6b53ed89526c9e1824aa02599f8565b1eddefa66a8041d5a783fcb22d91a56230f2b54175debb9c3c951ed027e5ebd828e87e18e7d5bf2bc4c7e7d6f24a9c332aa6d2b0d412a5079fc2ca22b4542d98c7c80e7c1186027cdfafaac6360e200e140810c69b9b54e8e218ba9fdcff2a7729bcddc9268ebe33b5cc3e2a09a75d142cd02298199589feced2656ffade5d002aa64f0f5f7409e9a5532d662051ee26694c7e51b252900a43c500306b36154308ff67561c93bff1e6955d465b2c0ccaf04dddc4b4ab0927cb0068962e3dfe482c03824628f37bfc1729ad7bfc00ef9ea03a90843b092a47c77f02354888c93f7a3e4a829ec27292cac891e9cefc42b7a4c1201de9f8eb706b443f764c4a116850eae238927e63c7905a577da1dfa335e771b2ecf1eef73d2fcfa8658ed12079b75489af4f81729d5c76311ed8bd6955ae23b8c1087173fc9526f159da761d0d82666e2ae72b56abbe7393e1769d12dfdd870be6a5f2258cb6c755e5d8630b73c98a4d75b1b3aeca89577ec1325bb590e0e62b305ccffb1f58f4c903d7402ce058eb414e5ed1de262c5d49c07efe4eae116bdfdc28d14c401235fc04653ad2f2514ecbd42d3efad0409ac1dd23b174cff089c0c6f4c7fc11bcfa51a4101ca879b768d5be79f78efc5f9d1e5788cf6d2d15003c6ff21259e76a65ac12bdbddffab07734401588a2fa51c400174cd17062d7dc3c038bbe3a9a5b30f4f517ec678c8df9ca48b0e0fd08d6759559aed064f4148c4cf2974c766afeb2e12ced90612cea35ba3f78d8bf05781266b136ca4ad778c02cf4a58a118e6f4d70256d80ef279d5e0cf7fdd47e12e8a5a2d2ec852e1d410aea3a7d1e4d7c0ae62f1f0f6d0a974b363a4702a7acbaedcb8e2eafc13cf62f9301f8fcb6eb757e3997edbe5dc90a165e83cdcaafcd2f8c371e68eda1b07f204f2b67ebb1af43b3d532a14daeeaa3ee71e7e922ac3144a76ad315c1bf948f1118fc14ef90d28cd963df55783e8abe4d486b24bc428e69460d047c8ffa45fcf7a4fcc0351c6be2860c900fc08a3af990605a6ac481d9004a84beb2a68119a62c688d2ecc7c885d44b5fcfa4525693f48901dbe132930a7f6f10676784342fecb13ab71344e8a4ff67d6f5852621884c3757934dde7d0b4594b55e07c8190b5eb7dd020f1cb935ecb7e892cea65094a7e0dd9272df1587a63c4b73a59b1084e0f42b45303821f21264f69b67234881b8fb0b60fe027a70e1e6c02c96c72d25702be1e8037db9a589049e836baf8ee0659443b13ff219da7c3742dfff457c7da3901375041a6db73b8d72d5ce0829ede308e4cdcd6018d00f0afaa43dcbc48f6695ef23a23fedaf5e991a534de78dc47a32ace24e7087d2c90b443c9f640624609e8dcdcfb4a63e9dd69ecd58142d81e317bf4d82e57703f491b5707797edff86b879c0adfbf3b100ea469a3cf0f324e3b12143b3d3ceab912a56d372a836b5c80deeabf492bfdae8f890d56ff4a7d08e3ec2b0893cd27d8c6344afd99d475e70698956bf1141a76d595f4a5bba896fa77aff4eb3bd0b51199693b261bab7136ff8bba7951fd2223bd4715f4ff97471105766687a6f23e50015ada573b529378e18b3e0854bdd7f74536852f7569c12ada214193d45360a729c16fe06f1468c71d72b9985c2da8d1ece5520b33ad5e4e9a62cae3289c54116744b6b9c6326f644331d4d8306e0447b55f03cf3be4c052d61faa402bf94c8c1ece21ad1ecba2f811ee644c90762a69bb34add366eb6b3f9b1d54346749aa0431c4efa57ac650e7f83b9130c274e6c4a3eaeeb0cebbe0ae0b8aff4b8404d00c6a7648a74d16da30766a6cedec144913b9b0fc45d629e7bcbb877f0a912e47075cc3a7128dbfdb21867c0e11c6dbfeadcbaf59b73a5324e5496337692e7406a032c61903c77679327d8e6e1a0e360d547f028d3a7fd4d8ccb662f216fdead9f22a19c23a0c10a289bd4306099c4ca97dfdcd6d97c3292cb0fcb06a29b8b44afa631e2cd26c525479c209a87873f9b9c8867010ce509978198ed06ff71176c3f8bfab8ae10ba810ba","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
