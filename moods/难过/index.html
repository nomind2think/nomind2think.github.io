<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61f39767d30d87477e56de431d6e410cc0a52369cf452175b7e575c84418df4c6c7d76bdad6b1bc0ca1f9ebcdce6b1ffb171723ffcdf2c7277d844c1827e6ee6e45468dd99a528bd58988484e91600b8cd03df881d17bd27f0e1af2ad70c597223604fed4c7a00d34404f39147f7b805ada7faf1fb645d161f994c20a42996bc3f4e5631ca3f917adb4c6b6a3b54512bd57f75f45389ba4aca4c268a3de6622ab4fe35913bcfe3b21ef94f05cf218e9691021ba9b202bb3e7594c24f527ef47f4320d078dade1bf23892eca0998fffc632f97b6ec0d0e4ded23d7a21f3b5db06bac283c95801a89e4fbede5a48e79751e46ef3b44aa3b4a00a03e46dfb25b015503f301b10c5e3b5691ef2ca006e94ec6b92a1e13e64efdaf75e483a8a28dee28c6adeef6e295ad6730cea221dd8c3929348604b6c41adfa8c1018422fb6188e35ce9adea1def801d676658c15acdbda4a5f4304c84c80773188439ee629384240f51d8caa99cddf4b00df81198575972bf222a6250c7ea40397814bd0e310fa4e1adafa90fb11aa8bbb607b10c86c03beb435a90865310ec3d9a0c9cb80df6b0b6c93ccd7a64d775efb62e6a55989bf85a1022e16b983b4435af2ec1703521379055cd3c7929ad29824ff7e3f1ba92cd9bfd5b61b0d03c1d81b875f7244256baa3ac01e85e83f358ec5d317da55ea5825402514d2fedeed3b5981cded28ad7508ac405104f41580fcf2419fdac5b51a31c1ed29ef1c35abaf873b18660f00f948618e08b3daa21bbc80f42c43c1a3b8872ba9794c0d21d803329ca26c5c032b293f9955cfe82105ee7c5b3cc815551d1c7dbcf9c34a5c5e484bcf01e5958d1cb2cfd41a10edd805eb2de18b856f77bbe51094f859b0625c2650a6c5632814ae067a5744b10f285e98d34d33f8d2606cf49490b5a2d7427c6fe0c4c9b4351d831f5051e84dae5a5709fb488d3029fdea7a3d3d83087fe4bfe1e57176364ae697d80e94a7bc5d9894790a3d406a007581d8ce347f55909b0235e9e896578fbca3efae1d341c639dc6d8572b292920c4930378a772817b800f480773275f34ae2124b01a33f695c0ae88a77bac0b0c867340a72165ea5e39b590a7f60668ed6dc94017a87867679515321f95422e53336d0f306f283ac70418b46a137dcdfb1ed9e26d07eef9d51cc4727503a9d251c18badc4c3208d05b3d62b2fa061444df73664aff94477de901e3fa5bd6807a2ebcf140b7ffef01fa8319178772e5f587bb72d23098e350d12c3ce396b1d70210a7241ff6f2290dbd97b2a0f95d0c07adb6e3475c57035a4df4cca2b62d5b8259942e37700ffb1bfc689955753c17c3a47bdf97d459f6edd368c6d8784451507abf611a09db6ecf85191df5516bd6d24fad353171c41d8540547b1d99929d74d41a2bb01c064e4532f2af2db3fd78d4f7a9e9370f65d61a3f15b82e547ba124e4cae85fad73170fae290676cc3f31e04b29072bca46a9604f4b64429d4385155bb95baf9ce708f7f824491b86ebaa8d5d60df1a0a4a6925039c917ca46a0386e7a14f2e9bd412fd8859e753b0ff9804f4ecf86278f4f09123d1d248f6744e6d9fde429dd42882fd38bbbdd77560411bf35bf6e087fbfca059a61edf4fd3dfdc9305e62eaa6089161a81fc97644ff6f0f1d2ea2ea6e5e28c30229729ecdc27ef842067d98320632e9bd7c4f057c67b2ee4936bfcc51bb726ce16dfe53f4b0f2fc95b0f5d5b36cd18fce297ec9aa304186c3f674c39ea67adba14ef8ef132806559f3ca3911b98a389f7480af3c4e2b06d9b22123ac48b420317e3cb953f877e04b498af50a7d561cb71851c2137660f517da81948d7942af3a28c307a0eed9da5dfb97102289033628eb11a09d20b6e78d79c9cff74b48c62d29f3d6c0bf3df6a95937cd728a5dbed8f7fec64a818636ce5aba3ec62a084133274514e1806e55adc53dff769bca6012e847d634cdbf5d194ee4c4b128a7cbebd73a786c0701503e9f867488564a6abd557f56aef15ecf29ae13197d6d0e1ca82dcf1daf10f5f656cb963bae82bf0adf3a304d95e0db6771299f4192903540e6225ac1fcc6b7dd6e88e48da6e0d3cc652c536daa8fb8148627db014b858e8b1376edf2e742a4e22ab4d38e9858501c6805be1f76b8b64dcf403156d4346624c913fc9b4a1c4297e05445fb7fe8cc05f851f0e09b8628eb47a09a265cf8a6a58946b9d5d1004da8ac6d3f3457f9bb58f601372a8757cecb2da1daa69ffadc1fe1b84a0b42231d2f3541e18a7bfcc9b7fa49aebe2ab625ea110eb31e9c5a18607fb21088b515215e6cb2ac024f27db26c4d659d39f18a61397b70fd92f6f7eb86251b7804e6e055e7c03bce0f8ef725f3f5a948e6604c0e870220998283caa7cb04cb766d2e00a791e40affa60f58bd18792f53d8ce3762f18cc57bedc7bfd0bcb9a10a860a6b3caaaa2cd70cb6aad5024a828c1ab9c9188551930fa7c458736061f04aa224a3fe2d6a9eb4dd4ef9c934c9f9514c69a70d3a60aa41f9aacd6db1b0a281c747a892d91551593c61f619b0fe6b3d1d05ab544c75b5c8aa9050372ba930d91ccde26068314793aed0f430e6d198b55310ca47e77a741fb3217efc49100fbfa2195efd208adc38c01ab4cf34ea65aec2036e08a2ebaa319566bb962b98730c37305304069e0146e7c61b53881afabeb35408ce5819f623f4d8b8ed6ec52337cf19ad368f1b656d2b40a133459e98225f22c2d32c7424efb3c9e033cbe94b8b92cadf091bd28d1e331da23043f72295494d5b78f2617b1a1bb1fc4060f12860ce1a719666f05cabe7d5c97df2c80f474c378e99128a1a9e42afd10b70e49d9d1f6833dfb91d3d81a639bfd3ecab3a8d327770503fdebcbe412d19ccb6509f14f41083b2bed6e4f6875529640137883c30c46018a1204090544174571060c9dd6f99838641b5a58ee18c12240f6c6dc18bf090c15ec78bb71145cc44dd1fae1742462363460550652ab12afe535af243f6d1cfeaa0f92db0d84d52d2deda88d99b60144ce3de74d459655f7d2b82155170617922eaf42954fea7a2683d92374042e9857e10741c48b2fe142c610795b97e87667cc63aa6257cb7688ef62e22de2dda6faffa4ca284f7e3aca1c827e70e5ede287b301350fdd8e3056cfa97607809f15f6d9a3e645bc2e3ad9b3dc4ce5ccc44ab4aee93aa0129887e0d735e8ee203f88899c6c39969f2f8375dd3cdb3bdf2a0b8e20a4c7a96b7293e1659468f7bb1c308a43de9ea68aa1314f69ae0069991125e5734df4215eecefc45ec2035b9cec72289720ba3a735779091ba76bb672b01a33e5776a4ed3045a93f72cd14e0862b6b6bee01ed7ab4b63b0044596015c87afbc6bb7185a396dab7118a481b83af81277d49280367191a3ef65335d6998fc339ffe58427ff686fbe8dab2ca2aa959598033347b3845ad98bb863c21ff8144cda93b5ec144d7af77a81b7d75fc568458013f356b00b4ad350f658097e966aa558c16cb366edec90553d94a40ac4376678f81d1bf61fca93ec05dfaf9db3a84883147152dec3066e95cd194e5b134e0fa0900439731a29292e13e3fa3c30e7453962096ce053507167f45073170c19ae3de5262e85497d784157329ba6c3d2e4f3f44fe6f4dfba82177f2c06361e9cd83a7af7b537e33b78b8defdfd1deaf79edca3b4fcda6a4b5ffa406f68361aa89ceee72dd2f53560a5ce643312df9b5fd3923e5acaaa0035a18a29b7ec6c62bd7c19d4dcece6166ac7caca9efbf510c7099e256140873485f011c09d9d9d7284c608cc7d1a2c37bd23e21f161d8bee29b0f006d1b4ff76a2b96b3a4793620bf3732d96f771ee0d061b096fcf1df6cf7f16e0d6e19817c1d2080854d527e0b9900edb6878328be5389b1502488a8cf2561b093fe9f7ec7a34af931c179f91f3c999275b23ae12e5a2331d6616c5797d66c7b08bcd79cfdb287402c5194622c8c3b2c375cadf84f1f026c2a19fe3b7660bae70d84470c9857f2021fbe011bbade39059c87dfacdf2b5f598d97528b7f37b15a5a62fc73182b1797e221212b0c56e8345817471221207c763c14fa650b228c1cf36a8881ae843e49837f7ad2ca5d466d466e08ba67d45ad635943a586ab594e97c402239ea03affd0933ce65c4a04faa7c566565d3a18cdac3b0d4f77a1cb14f45ddb806aabc127c038a91bfce05590f1495790c3f332237dc9e801c889bcdf41037bd448b2e543869a7ca3cce78d520effa5a037f7efbd953a2f09ccff5ef83c770953de253f9ed3dea3dcd657a7c14606f90ec3f796d8f141c1e66b528c31f92b60f4f3a86f6d512e0652ac1bf08673b60bf1cc166f6503b9e34de84b821154ca3a7b2c18b07ee5cec1aae5777ff8ed1943b09b054b5f3731f4621149b77c5cf4d053152c000c1a222cbe03e43a8a6157ac592bb13b318adc41df08668a76af23f92aadc24ad4bc748cb354d4d3c7c04502f3d9129331a9254cd2053a53b2c0af9df45a17e14c979be45314c4493345230ed439d06792fc2a4d8293cb7ad2cc03aa4b6c61d5a56a6280f543060a1fd27aa5e3e08fafb649a8bbf7ad7c63ed976eb42e83a0e5a2039efee437ba98fe66211f3857068e4c7cdf88d2b7b210ad20ffa2f15e906ba368ef094c691b944a71c4c1fef79232c120be41d6e3334509716adfe99232dcda3b738060deedbda38db0730881829b0d46ca116701372daab8abe471b53c198d6373fb79530c50c2b8a7de290cdc560f2bf5d06051abb779f9cdad57d3ea743e6faf867fa9d686d4894a573bcd85180b889306f75d5dbe1dbfe958327fe6c737aafb2c29d4903df730016d3a9d47150e98339c9e8122f057bfa11298fae15b2bd79f485467f907038c5614c04774e8c667d28d17c8599ff22dd598fbeffb126acfbae6fb8c642937f41728c2701b6c0dc34bb69976d56ba065f9a00448dd4ca80e83cc853a284f227e7599226619b61a7e893da81733e2799bde956381ec4b0266614b6468b2ffc307f9563b5831be1cad3006883bae501c68be70a79abc9fb15b58dd6754067a1ad9b652d1548cae4328e4aa36b4f76a70704cc0243ecf78e31dd035ab80311ff9bfe7472512dfe79f1f90b1054b4909b5c81881f9aa1e5ad064f2b4435e7b2579ae59123958c69dd9f51f09209f905dcdfafd950ce985dd071c5a8ccc3e6266c494866ef28d40a99427d6c40c1f9e1581227fcb14b57c10a56ed975bd9dfa4afa3facd9989744a9eed921121596a1890bb3e5c2eb9a90c32b5df5797b950c03c3dc1853fc6f35eac7a41cc84216aa0ad2913776bd9165397af87bb8e91ebbbce76715716719ecbe65d7afde72b5d28b7316b6d5e84ab654f9907b9ebbf2d75eae710c906c3df2cfc9823e59be45b3b3c6fcab158b87399cafc5f15729f06d71cf8fc667f2bdd8e022fd509084ed9cd71764894229520b677c5fc237b6cb2644697087ed207b59668cb8ad42bcabaa5e00a18b780ee724ffbd66b582a99f7a47bb6468d77efacfdf91d74532bb8986ab66a6675ea4fc4bf0c3f66a5beda6d8606af5e0141dc942dc152c5f2884c326d81ad19e23b1c5288b7266f1b9a79e9218779563a229328cb32b1adf95340c206e19ccaf0fb2c589fe5e3da4e77fa83a36afb19204315fba8cc654ea903a98e06d95a95c108f80e2605e960c297b06bdf17cf0d85fde73ad3d25ec73a8e4026bedbb7ad4a37baf89082bce132eb994273b24dfb3d40b06910caa029ce701e375354f65ba0930dab37f5b4befcb34637feb2016ee6032279f5aae980fb31c794338b77e6b92cbe86eec47dc1eeae0cb9f2a740a41873c5993d431c2118e69236ada0461551bcf231175495bcf6d9dde073205145ec4d4e195a20eb2c72ba5336e590649daa5aab5a111c09589dc418e3c3893efa2b46b2a994b10efcb3f70fd4a897eea1d89e52c0c9f9addd7e0e6189bd731794c42b6791df0d7469bb900509990bfe038209bbe6e9c71bbf3b992b6b3ed63d296e4ceecf6a31e219126b1492f716816d5c12dc5586ba1f9f610f8c6e60aa65106a30081e5f0a62214fff092016b5e29eb08ec183610e2e83bc7c2c795de7e42a4b0ef1a43c63d4f6b0adbcfe0984e4f3fa8d38e9d814fd72592db5850ec61fc7d37a5c5cba78898a3a29afe87f2d28054835bf0b50576f5dd25bb151954827a39c3c646e6946e2346f561bce49ac5be8229c96efc8fc9424a32004006aa600f23600e7ea7d07124a0742126de44720acd3b856bd58c542715de16aed89b916a9b873d15e6e417071e6c510fa436834e8c0123d7809bb8311f8656969393c571cfaabe69861509de6e3546c5735f6889d790ad8b3678b0d61e213ca9f1127eb9fbbbc70a576d237b9df88ea245feea57c78a3e4b6e51b1283d4e3c6cf5854b7f113739e575f201b282c2270bbb78d9ccfba564f596e2219dc286206198db96537fe7098afae93d9c7b3b36860ced008ad5abcd392ead100d6112198605f923aad868c1280dc42c73e21f57d7edea1e9b0b67a82fcda5530aa56a78e74b76183f81612a670418678a7542e85697cbb2d86556bcd35a82aab5624893c22510d2fcf00e50d8323847d7f0b9ec6eeb671b9210184050978c733994914dbe360d8e5e446f73a82b936f2c81c07c8b35e34dfd5d2f6a56b5bd5bfb99a15d4e7040f398ecea240f75539239ec1002b0b97ad9612d6e56ad869e374b9cb0e8ac32dce7beee85de4baa0dabe60d0dfc3cd8eae9bc3b40742e4e2c4230623eed180ffc5a2a979f415de553ddf5a700f59119eabf3074aef68d5cd13faafacc381ec0beb6465b8af7b5eef96e9ea05cdb199472bf9e65f8883914b161bf9e61eab98eb5259b5e0efa66326335c25a3af5b26fe7fc1a01ba9392f3b98cb6c3e9774d2e6e8b34cc05ae8218b79eccc62f1cbe8be40f5a470bd9338564f46ddb97a5cac3a057c60ba0fba7780911fa33df272d2eed530b2386c2ed15ccb4741e7f5a792a571b1822cb304e2b3bb28b513234a5fb3683f31cefe3047d58f631f163f6764aeb8433a9c3ebbc5e53d957007f910f88899870ba0d0e464236bca6db4b545b6aff59e4cc6340c6ac2d704c1470931d8a1fceeb914c326f29e6e58fc9f3023abe3855c35ce81254b46ffa3b5ada140b6fba00a6070e63b0e75b74a2e0905ff09aac17fb3c0afca29bd890e851962477ad3df0ea99fcbba55d434e9a0ae4cf9687599a97024acb18b06276fabf9e2c151f86b74600cd8d9fb6d0047799f793968512cc0777eb4a6cade5f9b63a357ad44ff1c027e48d837da7bccbc5b160541db78ecb8200b6249d27a84021fca03930725c369035aff48ede1e2fa262f97246904b757e3eaffbfcf41fa4ba60ac4b7d7f2605dc808a6f58a12be9c3c78649997ca6ca941fa7aa8c67ede200767eae423357c305e2960f51dd62050edaeaf4cb3355904a8017c8f913203f6baa54df5766e810adc5b41f994665db5128ff7b475b7bab58bec812b38c056d4b0bd232b0c415640be8a070268f2c1d6f840c01f20df88fdeb822bd3d08385d859a9bd7848134eed71722082745663ccd958547d6173fc52a77dcb0497ae2a4ddf882636cac9cd476345a22b1f223cf3a0e575f547265d0b0cfdcd955f8327d875bbc6d5e709dfb2ad2b76080823d1fe6fa0f1f3a1b18c52854ba9603a191ebcf7fa521c737033d1263a0eb1f2b6f53a2bdce88dd9f4b95208469c4a5a65266729853b889b6d7a14dd08da5f8eef237ac9f2503e6489dd7f68dce5425aefb2eed642be41f8530de68f58d3d28f26c463bb08380f4a762a23b59b7038993e0769781061800c5acea1ac6a06495045370fc07645a6a71bfe043448fe557153533cb81b37dd795ed9abb21d7e7f569144a7671d5444c7b2720440c05f4f91e283886b6259984eecb9c9b46e77508116577225a0fbcd43f2e606cc52fce61812ed59f4972c9375db7bd0759e29919b247d04d6dc357280ddef7fcf5d41e90857940a67545726257b7a64d91108536e11d2d99f1f5eccbeadd9a616e1bfd6900a15fa60d00d03fe6e4b5f49ce0d4a16543f02027e9d0643f326368bb57cdaad7d30dac9775db789d6933b81041dd8b64657d50b511a9c0849febe6aced5699dfa28acebd6f7b2a93fd826adf7d3a6055d1d879e5b50d2bb0901fb31f984546043c18875607396208b3e18fff03d659fb5ff2d3c792c2a9494fe431b0313df20e2c65ff8dee02dbb5ad24e40f712287363547af7cb51cb588d753e6eae6ea3aa4e4934ed6056f432ffdfc71e488b84d2ce605faa5cd03f138d3f457f533a1930e90de173b028801f2a738fe3ee9d58f080163228473f45efe560ff5e0ee0d932659ec8f68a73109f5da6155daaaf4f84305c7dd19f25b70d13289e75c9401baa60ff8c66653e854bc6b6cfb973a0cf94ea8578221c9643dd2d5d51c682d7a596b08e274828417df3158959e3d0bc051f7c3f07ecbdecf08dd05b55fa36c66f19fb8e7c7039571c51218327533955e18af9c864055f6bd7d02aadd415bf12ac4aeceb84ba0770f94f561883c4b1f5b6dcc62c0bc7cf9cb9da2cf6c51423c7e26a1f9c5c217954b24a35dc4463015ec9b37673a06a38b454d97a2bf9497123a83e5a1dfa63aa7c13eb7f8d266adf94ce1d762c3798e712f27b28be565614db7261e659d621509aeeb4d33de491316e278c766b04f9a9303cf0bb2967de07c011a7c590d2b63f9592be0e14a954fa0df8601e5cef8854b32c607168a18920703ce51c0d19dafcc70d3d4b686773ff3060fa853aa45de00596eedc026d3e17407feb0396fc512825cfe3b6c9f3f11d63ca8f7457d870666f77288d6aed9963853a24d8d9bfce79e82e3844629a1eab574e610139cfbc43df6a75a682ac3c6453a8f31d847fae3cbe9557c9d6ca90c0bbda5c82bdf5155b08b7fc67a5275abbddf9a2eddb9afc2ab32adb921d1120ca39665e60f9acdc76fd502174a5a829b3a591a2187377ae751e38e2f7a408b07063cbee50f4cb63575eb31a9989d67bf6b08ec4034b5f4b55c859a5ab18fc51b364f2076a8f5fce6ae3108970538db703f0ede0f828c99afabb0dbd1c1680b60b417bdecf1d3d30bb2a41a77caeafb973d8b9edafd9039b62ac50e600e8b527792f1d93b76580793934d816310ea9fb0b9a9f23db4910857b69a22b23a54d310eded0f7edc51e375710cf9f4d0d3de2c49aed9fa397bac39b6be370ca0aa509d25ed9409c5d97209064bcc485c8826c1f543112e8e0fd55bc179a6648495609e5d80aa25742231ce179b44f711b305ec8ea14996778bd10f0a059e9aab02ac23be0607c1bc7ff03262f68c9f722e49b2ed49b11708678f33c0c879e6a8abdc1ddc26c8e5f54bbdab717611af3ac48a45f8bf7f7f8e755681c7626130d7cc71859f13953941aa8e2340c386187d8324e2d5169604874b9d7d47fafeb2cc0dd13532bf650958d6cf654407dab75a2a4fb92d42442916288d652aea407c1636a006d6ddb63fb62fada38c984cfcba6ebe31200c82479dcb24e587a52245daeeb72f54e08b0057473f7ca993273d386f2d80ddf7fb342b2b185b9524303a34a62de99ddc96a621ea9201ba02dc52619d3123390879e4a8b52810d02e275cee257e6609d8510a9f7cc0b489b89c657f3b3d6232294fa7ae0e460cf29825115bc08c021b140b8a92c30b8fc3ed28e6960a97b1ca5b97394b8ca1b0e13b6cfe1cf27dddd380b9b37840fc9d19e33a78a61e40a9b481f62895a0fad4d277a86c2aa297fdc26b925bbe8cb9075daf7d592e523dd87cd91d4975287a53cf44fe695dd9a3986d9d3d3d72f6023a04bf6212640271285726bde765b482e74a8a85f50abd4b4b86671c054b0dc0df3275738d77e133bf942e076588635abac4d5834893d0c41eceab10227d484c74be0d2365bc549fd43bf49999f3a0d4c6287f648b0aba140f84232913bff5b4c0aff837a4fad555d9f608496a69b3828b488b0b618ff40164bb0072314805aaee3ca1fb4f7f6a37be9f431cc62d4073e8cd602e70c56152e7010e255cc117322cbacff09519ebc40cdd8dd6d6114bb590545aa054055bf53175876b417f41fd937c30ac8116f608f631265ab1690a0cb768009d78ecb494e59a67c36ae2d6e39b979b6c598ab5345047fe4289c8d024af979b0cdbe454d79aea898cc1a4731b4ddbda1120fd41d0b0449757a1028c5095ce58e560c98b53240baa985897722eafef88ca6b3237258f3277c8bf14a5c2f5d3c89e3ebcc82bbf447a29f915ecf571620bfb1cc63463f2cb75f8baae673b81256269a99c5fa50b4788bee48cafc943f593f6d330e08b1143f8f713539f2454fcc4ab45c32fb3cf0220dde94bfb613544017cb8d4b7aad96c44addd8e206fd86b9cc8ea9a92b1e7e1d164c4da6bf9a8a94d09732c59b70f62909ea27d0ca1860f0cae85cef00cb923558d32c94597d8ce6e96e55bf03ecd8fa455b9224463351b5307daa965ed99e3879b91bc65d2d1685f79341596f2c9cec7bd9773f48836d587d5e61743f1b13ff4019aba022d7846cd361e2c4fdfc584f09473e2d3c5b58dd2710edad687a7ee85a8626982b4400f651b0edc8440a0f8f1f97dfa9da7ab91a6aa2cb392d64f40a5bb519774b9030ca2c8e47ef5700f9ad73d1beb5d113f0916f4786b13ffa1da44a8f0692db27b74d3693d2c5bcf3730fe69879b2a54b00ed90032fd70d98e020ccce59630fc7ad3d88cd4985ad3255d973204a7fac8d8eb72423aab3b77eaaea397909df97449c478810caab833cc234bdf59bcf82736e74e9543b34d027057eb85f15d1d4498f13ab5adba86d1fea7fa83db25b452bd6f12fb44a7def7637c0b6fbdcbb2c035a6e82e4f1d3cbd72ac7c8451ffd9d40e0ea960459e8301eb80687ec838b5d794e111f9a40bcd860f4074fae8be4601ceb77850e506c7da34bcd227596f3b7cfb7e29fc0d2ad134b84986be28f070689ce3e6e253edecf6f05ec1c7b18b19dc348e45efdcc55c90ddfc8d1eeed02852aa5dda198948b8ba0956535cfefed61e841df63f648dc3f5aca06910add9889354ca70cbec55389481e05ecd9ca2652d6fa58212e8df432b8224224b9b49aec0a4141500b6df41c0d29dde2a3089e7684035e87063c72cfb469b9ac911c89473774e5e518db326640d59d7d8ef99a0a4ed614ee95f26d33423b41f5811ae5db0763f2c8dab7fbaf838a2ee122dd0a76957387bf7ec94c67c83d4b2d6d2f0fef9f42f9844c122701dc697b46e5669d7cc8d8304d0f2d0d7c546b471b6f2a65661d03d5c9d675f4f8eb2cd7cd0ed73c006c634b65f8a8fc8c307af189adff9136428ea8b3aedf1aca7d45eea681a6578ce5e59f7de06a2dca96baf429954a35f4fb572b198d36e333eceaf660587d20ea6ab29d592e536b9cc108156af40fbe2330239db8f1745b70154c76386cac722ae2125a47756d958bffa5dd465de7f252d558722320e1dd1e36e6062b91e4652b057ac2becd30e0fbf3459e439707cf52f4ac579a06b984d64a5175cf571907d93a44af6e12deed045973657088e09654e482cd471f861ff76a055f1f9bb4e2cd6352fd01b18136603de7d1be36cedc1b102dae567fc129190e68791e1cc7bf5f0d378ccd5059549472e60809408c3a3b1fcafd14cb34b48425c78a76d23051c0b7590a74c701959d36e9f6ea99c96daba159d7b1a93bf03e9f3ca96e05535c7dc8576a09047225148306202060c69091e6840097d1b799ec6f8a331936ea8abe25f9d56a1a886fd5707e2f2d5289389e14b9f91b9951bfac8cf2507933721925e970cf5940a621613274b9dd1eb082e21d0c5a6e6a3f26a72f25fba706362a746a84974b3900da7981428e981ed150e9bc7e5d2176e3847b9cd5dedbfa52f8660d1d49a28d0d5527454cc0ecc68373d885663235bc0224702a739c0a9808791842eabab166627ebcad27e9e558736ffa87778246974064f7ece5ab0a03336b83214ce0ca316b0c2a38b24b93f6a5968e1bfe3c5548f17e970eaa0344ad4e577c78cc310c149be72a24c84942f42800b221db3a9c5c09f35bdb4cc99820414b0e63ec483215ce65a9a5003a64bbfed676c4eea8a6a51f6237131f5be8a3f5328d07555bb278466f3af6c246e93","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
