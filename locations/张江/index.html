<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7641394602c2f622869c958f0c6bb13d482de331e4afbcc891ec6776f9da7c895e6c35be8b111da5cf2b808099ed4804525f4ae0a3891a7a929175cf0a7e628833bab945bd7909dd7102a3935e7f1199bf748f74f4e9f86cd8847d1456a20c6be1b2caddf5fd974742361498a7a5ad223600c5974674a120e72b9a7ac516423d8abc16128ff426314f2d4469005a3cd88b59daf012f5be7641cb3082753847a07b45d00f3d16d32f639d02adce88f2853146dde1e9b70a3228436b31014b75f935936f070ebcb9a9fb6c2a5ca6f033f59f7d6e177ab865e3571d6c9320f5d4fa59ad0210ebe6851c182c6fff5e83250f7405afe69644ac2631c0c7ccd29342f425c3cd2b4b37d5be2111aea64b8e72f7860e7d25cb9fa7a5cde282dd3419fa9505737d46d7fe74e3c83a9bd5a5b7711bbff5090c50a4c4fbb8f8c675aaad520ebf2393bc9a70f8ee17b89305ad9cb9b3252888d3f3eadf5cd5267fc4c449973b615a0d7c0298eb201963f118f301c7da3ac957ad18a2777b7a81f76ff4580fc150576420e0789d208b931177b0bce417ba5b9f8c9ffd1efd025c5fa2f31aba61f7c8b367596877da4d060a6dde2b7fdcf122177534373f1fb5479d157bcf04cdd36a84975f28e6f98c3d7139539349c92fa0dee284c1acf633691e4dabf5546293787463631bad83ae42c5301d36f753b8135fe7f1644ae0c5080228cee9abce2c996b597536d6883b8b71be10e51e583f8322b52f2b65576c52dafcf2326b43c6a5fabd1402e1eff1b6e42df1601b1c1b0fb9b0de118cae0081f39ac13008e072faa2101fb9dfd63e904caa4e3c8c565c73ac943f9321bb786ee38ac7f8acfb90f6037305cf37b346b70892c6b6ef155d00e7fc5768996083afe54fab05348b0fb55cae93ed7bc5869fca8d58211e3b638cd70dfb0cfca162f5958299f25f3500352e9cd9eba7d2f134992ac925fdee1cabdf106397e747c1ae7f96575e267597ba7f901f61e1c501cca7372408e0aaa498db63c42d905f04f18b9521caf238d3c03304e378b09b5d20b294f38b6645b35144a007332b17458b83756a320c3fd791fd2f9891254124356c1d212412cb1e7f3391ed84f6cf404741a278f7db21ced7c0e3e37eedf3cbdf1bdb2c6327356ce1e94310960c6639b1cfe00b5aa1d6c588579c9a519d7ab25b4c3b5d06148da46b93add202a8d687c84affc853eab154f40f97767baafdfce38c3e0e30a08448a09c19bce3aab0d3c7c98230e695c799902d04aa39aa8d9a285123c4a7571387e99c79811ddd8423a9c604b0d33623adee1cd396c298736555a3e57f8159ac696ceb60565add5009a04ebed3d41b2dd07ffb3f77b16eba3dc1f134502731e4834c580676ec5ab0b9704c4a19b40a767e04ea771d7c352f1c0ebdb85535d04c917cc92dc3e9fd83954c0a243f1065e96355f214aca9ffc7f85b499eea154daf5220311177fdb134f3cf021ea70d17cd736dcd4783ee159d422d352210adf228b93576cb8fa90a76ad4ac7b7a5604d666ce58e7c7a2a28170b8c75d551b9bdefe8634cd18f169a9613fe802360fa12873dcac8013505bc68746de85f68a9d9f7eb7bc38f7e03ca4b74f3b8a75c6a90bdcfc215b81218460d27493db2038d4cbef60c2fe169855c542fee304f12c6ce9ff1ff4685338576cb444be15f36d6909d0e94ad56e718c1387723cb7ea656a8885d4801d3b1bd030f651f395fe612a7613de01db445689c576af54998d5d53104243053d09fdee733c192009cb0b5b6310dc98aaecff3c74d3b2d6b7386b53268653e860d1987afa16acfc9dedd0c8d8882ee40da43f1af4daeda26f933c7095e8e7cc7d4b0336b9d32882706cfb609864c3bd22cb0290484c51f84588ef5c7784684bc5532ad81f08d65aa0680c3f88fd6bfb6c0965653e44165b6abd630c54ff6fe704e3ae6fb3fd16e16267dd92a91e8f424f81e07a5e4302f432810faa9873fadc6698c9d3b14f53cd017edd5d4f84b814f1f9bf6fb2475f5672e253e275565da4b656e8088b627c0a4566416b7d46e359f98fd91ade6674b7741738c0fdd95bf87e3dbbb363cb06aba51dba1bcb09871ce4e7445ed5c2aec7ff64884e4a91699a83a9175e39062ce343476d2d2089698aad6685c064b0ef8896c0bd98ed61af61592a37d7546db1668fe1cda6648fa9da8044604f0345920862e809ed3dc3b600e7abf6eb5a9ffaf066049a0fee968084373146de5a5c7a30e555ca81ac08ab0208d4f7c565074ffec026991ab5054713e6f79c1c6f8c2981017044baeb79fe3a3b66a67fe8428402f7d0b5192445b0b7f7c4b3a49ef37d3a5fbf8370f0a1bde12eed508fe7f1b5c771e5ad44ed2badec174260633be11f7ad61efa1d820434a54ad3ad1472a5bd5307189f2b31f8f2c4bafc8f500b45aecbebe18f4d5d552bd5e125962140b8786dc5ce08627003bf9dbe204e397c3dc0c694a639a394ef67ad5f0572dd60ae07475a7ce9dba4e2410823b58ccd0a456f37746a8bdd031147564c3cff7561f3434254055e6dc23148ab5560b1dbe707b78f06b79b2110b98205bba1cce442da25d8b4903bc3050b83bd244979ebfa10827af606e76dc059775b661b841056b0d6d41a07fa441d223bd8c1622fce4de62e1a9f389b69e66aa1d243571a298923a16e014398a5114df0b72e64f15ec259f71faf27bc2b236b4f761849ad60d68e699650f2a2aa60e4f4d4aeddd743ba8f367ddb5d0577abaf2a95660a82f33cbd7ab63ef07ad70ee6dee790da9fa4e3cafa916429b28c6f49a54e8c3a97555c5f5b82dd3c461b1994ecf6485b3a6f097b34c45d5342fdf05a8bb11b241e6dd9205aeb66f6eba42821f6abb539e653fe5921b312b42537388fb7454a255eed2e99a8d49eb15ccb62e8a88c987f929e141d32fad63584af8a3ee96fa1afd0f1c893c9a20072ac8d6cbfc0e2f3183f2b8a9e2e6a8e4975e143a099ec6ecfa2830201d30142f65790c2da33e974db95f9bccd42c4d57a924786c135f2695a71b31b9e813c6b633c78fff3dc3f94771deb0fbe69f2caa02b6ecc79b209e7b73aee315dc632af844ed1e5effe9be9a31e28e547f1c3a53ee8243a99b130cd6c7db783f3668f36e42bf11fc56f26e464639fdf2b6918299114cb527372a520fabad6730a47b024f3f5076f15b7e2f21a2bf80075b432bc6570957b9e538cf5bca757a4edc12cfb5042dcd2179977a575832b1abe8e51739417e5293f4def7c4fc9bcec6771c31ceb4f387397598648dd3f092835890901e809518b80d07c5d5f3af2efe50dee69e9252d2cf7df3e2034885507ae779c3c5683ba84432e4c9b7aae68cb447fc2dcc35cf07f1c7175de2870ebe88d0a05434e2c3d6a6d52e1df0525ba95135cbf42ceab64ebb4fcdc763e25439a8aba13a0d4e2a641dbc98e8c098c9f4fd8ef0c95529a6bf9880015ce6d905047707638816b58223d2fb5c3f178c4970b1b9e6c1d39f9485425d4819a4fa6e1b140f63553098df365521d036b6a35dc32d9190bf985e41af3785adc8e10c04ebbe006806f8aabf2bab586fd3a5836836cdd5b10273e3d3f1046dcdbdfee2091c014dee7a4a58b7aa05d5808a083096dcd1aae5a9dd4a64e816b8cdf777e2f19655b4932e70dc105f6f3d84d764576a484ec6c51ed7ed463348a598e280547b299b02118896ff81742d982355c04b223bff592e85532f79f4e6f740eeb4d449c507aa4e999f19c077827f5dd1405bf9b36b1b932a18f9dfd75b1cd651297c64583927b30329df3400529dbc3a905c5579c4e78ae5f8f499e75e3c4ea0c08a421b3cbae459394aeb4f6dbcb23cf243785ef80ee1010b777c183e014942ecce376503d6be665312006675ec6ad6932453be5e86d9fc298932d705114db7f9906425184669c6d139b31b1145a8e2552d9409ec7b2e9e9a9e9c948736edf4c3070449a39106991c343c75b6c9918f6507d17c972028fd078ddb51610680b9ef5c9f502fc2bf51458e8d6b7f0d8a8aa9c76847637c0e8e3913f755fbef34b28c74b9d026f5ad4006a847ce1c4349f1a5dbc09c2c5713eb9edcc8cdef265362d5d9ecfdc7c2df8ed5de19738621644ce4def0427b7a657d2730b893478c7eed91c9fbe5a5c38d9f8ce6e89ceaaab2e18f5755f01266bdde5f4305f0403368b11cdb68a24fd09aedb3a74e3515a40ad452603d38972d87da8882d9df512248660e34c4655f09461e87bd39b1f66288a67ad6dd527391c25ff4ff98020bec1983ce94f65b29fbf3fe3607ff52b74881a024c04eebc9a1e6acf0c3bc9ffca806522e15d7790ba9775c85f7d7d66098635730e6c13c0bad84f7fe2382d675e59cdcdbc8cdf3e4b1f51ed3fedb82ad092e7f53c480b13befc702629cc3208fffee2dc2bde66fcabe28008ae7bcba3d3309737a4c7c861d35fc8cd0b8dd9cc37051d09a3e15906b38299f9960183e135827661adf410d9de888ec16858cdaacdd7a8254b8d1213d25629e7bc88712b29dbb7119ed18517583d678fb185f8a427818cf7f9d31d577b4d75f5ea6f9c92dc04a87c0fbb71dd175842e58b1bf189c4d796510cc9ce969cbc3f587e8c5aa76035591153c356615194c00b1202c3f84ce21aa84d41356ac4b7e0b3df89b23beabf6e569da9e43db1341db49eff3270f5dc330ed76841e20a347756e1fbb408dde5495e276610ed1842141a84d186ae3bf8940b0af736aceefdd8f4999225277a61408b3fab2a088ecad3ac4d376cd1ecc9c398e06873438b381c53f561a3cd7efc2ce01c37e34063b189e3c93e68fbb65ae5ba56acd2055646f1352fa9856b457b2b1f8c66f74c01ec55f5b8563020bc1ebf302c3590996601e1160f7cbbb01704aeafb0a706413744034189119054209e1e25c7ea31a4d44e7b9aa3baf746b0019fa251bdb8c9a9c7101e1c99d0db5df2a14462848f7edf3bdc37d82d8f5269677ca86213bf2114416e2526097dcc4f3b63a7643088b2c22359ceeffc5b2549ca10697a0297d22e901fd7f1f920859a5a85987a8548a24a2adc4f049ff8bd9aa1d4c73bc2990c928408b7b0220846408c2a24da30bf1df2efeaa129ae2f23c06185cf1ef9c55837ec7e6fc44c58e5578bc8bdd0ac984608b5fdfaa3b564ba28061116d1e798276f28ee77644656f19b992abd0ee167f70d29193fca64e85f1b71f404a9b09839fdf9e83cc6c4ceb608b84f248627c73ffd9c69b125d1f11957f6c660387a9be966b310c6b2e425fa7cfe3d6cba2a48907de13af83c283212c38381b0611a1a417a15c27847ae0ecb20667844dd62508293bdfe340d6bac5268937303b591932c929a398864edd9b45dd7bee96f5034725d48e717f776805224b9498fe23b9e10847d5da1f978bd698a8a7a220bf854a2f364a6dcbbe7efdd2a0dc8c39f303b5a22ca20e3e41b879b183e5b8134954b37d6738124404c5b44910bbc724b17c2ab35fb06dfb5191e5ee9f200100d785195d75dc3ba67eb8729d04dcec73b819e01c8288b0210c986e7c0ca9819c566177cd4618f93023587404b2f126762ab8e4d6a6c875653c4d65949b78f658e425f553199ae55d276093936514023fb3698d233ee5031d6b1ea04162c2438038c43a3ba4f052543a467525e37ccbd103a341b3592778cd11960adc2ecc8ba0d7c6fd2e8aa9011b239fefd8f9006beb51ab6e79ba1bf26398c9d0bebb81637709cf643a445487635145b7fb17a571795b5d8c1d8d422df030420cb099eb54dcb46e0956ea62515202a5edd71c789463ebbaba5bc9caa553b9ac3997ba7c1c89c4dfdfbf40f5090b064e6ba50026c05450b27aa284ef2e2e3eff875de28889af6889e522fad5cc0efb59cce1d8e5b9f3f58153cadc77777b6e86336a8da028ea993be1dae5d1035a05934cff9b43feb482deffa8bd364010a5565d3c4e6be8bf76f6277e7c31b22da4ad9a92c8ed7dccf4bfe7f42f65e378c234e036bb1509db58265a5ecc426babce501d21c640342581e875b2646524ca34cf4e7de81b19105c5b9cc479a6b69b040a06a8835504c06338cd6d52b5c6accea59d6dbd61165f8c4026b8c4beb9370402cefe00fde10a6e943c4134b9ae86bd90f9cde9d3b2cf134609ddf9c198ed97d9d49e7a45d3744adde41e2c9aa8d59b7d8aef9545193e307fff41c77f1008b80b696859a1257f629313b974cf91f8b5f947a7da2b2b680ef971cf147c9f24f3e78b853756f02a7311704321188b55b2ac4cac15fbd96a847bfb418d8065bebc0fb9030397c705f4f6b198e1f5238971beec84697188068afae23fac7053c9a9cb035c759ee5e8da0f0001f71347febd02e43c69194aa3189739792237522f73231189c9de4408c281164c0ce4c80e45076cabbae6ee3a494e5f3802d8749c7ffc0f50c39be5d50b8c80e068b1f2f8c6eb1b47e06854cbeebcc4ab7abaf446ee9e875826af01d2d49370f9548c5587bf634521b9875bd270e865d8b5bf53279fb294c6d36a7daa08dba64690929d82a8075d22ff2b9cae986e22ad22a8af216495bbc0eeefea6315185268934109fa39fedf37372c1c8e66e2d6dddded4c3ba3d9363101d515529ba803528400b20cfc918dcc4caf9b7500e99f2c9558e04865376f1d16a03700dc3bb0498300992ba662a1c5ec43bacf240d4bec8579b90df803229b096ceb7c424b9f303444715f9311a9b299a027a3d5953fc8728e0b9649be21f88f9984cd5da30cfe455fd346b851d3122716d6f0ef33f456e02bc288c1c7f4896219f5364bb9892ac4c5f6ac17e2f32ee9d143cb3e20a8a7f06ef0b7d6ff6c84f4962984bd27f420e8575bbe58061a2aa0dcd2b2cadc09346e310d224f3c022ebb2199be13128801ca04f6e6ffa497cb34c68cb1f5f956acb0988553ac513c5e20baa3db63da588156732c188b363ee339b6012d799eda5f893e7d3957e52fcbf45343721e7048684a82eeb36c5699bfb3c67be236f5c882f2e0f8fc4b897ec4da537d0c82282d55b9a2a8e92e70d9586785cfaf1af911c7eefb931b8a3479944e481cf65ee0a5a576f4684adad537a4043a49cf2314660dfe505aac88ab27d68a08912645dddc02fd79854d9ff48d34bb27be32e37b2da4a7a47e212aea9204ca3bbc504732bf98e08e8956b615cbef2cd304c5db3b88ab52fd621267412a7d341ad8c9ddfc7af7a7e9783457eccaeb2cbda155f83cf1f91d32e758bd55599e10143377421d73fb2b3086141a189f04d1e49f773ba6283aa0ed6b4f7320ee59c23baa22063e6bba03c3ef991df42a4454629167b7e4987c5fccd265be12927c6ea14dcd7af8cef03a2f377c79b9b3c53ad9d354ea863e391314600a87a29a9f543a53e6a4f52a2a081ed11ebbe3991a9be8d6db48ad29774241477cfa4f0a8a34aeeaf993b604acd5a19e29a0f24d7a01bfe5d81983ad461c2ca334a86c8ce8d02858979bde68f8843b2cc224d45a721eda2088a0d13a97a1a03c42701b4375dc9bd4a6b4fe1d5b961622673e7499dc17f0cd8cb811b1e23f5a629623d1bdbf596999a86ee44be6eb34a9cc6928ebc13e80d861a2be18b5557f5ce9e73e032b90ac1aff1237459ee6336e4cdff2c12f53e916b15b4fcbea9877d6050dd72a21850016809a29f4fa1d68ceb34a2e4cb26d92748e7ed64eadd2c01cce7e33639f34e1c6adce1d1c2db40304ecdfa2cf933c873bbfca08fb893adc75bce001c3933b08efbb07d109b8896da18c8e8882de18ca9a0a93594e87267972c7ca37646a0bcbbb17d0da8af91b4d72f1f69d99976088910fede0c3ca593c2cbf471245832ba3997796fa3ff1f2e5ab05426aabaf3097724b824b7f5561f9fcc207abcb78292b70d3cf468eef668403085da3167d292bc8618f2048692f4eca9459c90f84200abb4f16307fc5281291b08c17a6a55f05205d4f1b0a6c9dac9914e00f5ee46ccefbbc9696c77a7341f61511e436d004c05cc148399b3fc23584d19e5fb31a1720bcef4379e2fd590372f25c4edea40e16fac635c2b5184751d484658decdf08fa2997f696f57a9fd9d47402c582291db3aa4cdcc26bf6b36bc68e52965bec1c95bfcfbba96415ac939485dba7e116e5b51e8c09907f3706583b2f7a3448f4fe86db55b971ede0456789d7d5bc75c468de1da65115999b504b36039ff24e9b9236310ba8c4b0c2455f29e438d04109ada46e9aa800fdc88a619e681d5b31968db5e07b947b41b6308c5494d188c43e35efedcc46ab6662a9b432b20004b4b30582fba9598a52eae7c668c1bfb11d795f6f445f5cf530cbb7c4997f4053085a239428cd9b92620cdc641c39fb619c390bd9db60f74f97ac70a2bf4937867746d1d6a9fa540a954ab3fbaf8806642913d0a97870aba2f0b8bb9a4dbf5c99881edd106f3304398319c62e64530b007445f725ee2b9b7aeb95588393a4d1b430a132ff090cd2503062711b523d15426173c98d42b31265789a8a10560264c051e78cc4da95bd25ac9a879964cb207726ad2ce0f0778e8e31bec4a44b3bbcd9c7e51e7281238fe8550638d437786b554c8c2de2ed70b6dbe8262900e0246eaf0daaddcc79571dede4259e1e61cf46da81609a443f0d957d0989f48957f9c5f2a326ae79e908b0ba62480da6bf986181f7455e4429b115f28dbf6e76306cb54d544e8d81844a4d03ffe880f069770fe457e55d60a326afe7f02b9b2f99bcc2214e49f9950fe73fcc59070e8d50c3e490ef87196770da36819adc0e89aaf2571a019150206a572ad35e9baf6ad35bdfa526782d17253423882e3390d0c671b174630c8367b1458b7e8fe59deb05483acb59a58c68749cd5515fff64f690c572f527ca56dd54892fa6e241d7b94e66da3b0bfab69b7291ba30f8a35ab1bb86fb6fae92831e981e1cff8420d9b3ee0c0a339d2a1a000b5192621a4d8c6936e5342bafa707b65308c1b402ac1b8aea4ebf8dee13584aae6cef6f82db67b379634468ba87b305893cf8799f8d5b80478934e69854a137f98cb9378c0b8cebf426692f866803b93e150882c2ab2162ae84a8e69d1dcc6befd0c26bd9a0145dbb012c122997f1731518c89eb46a6c001b0121e7fdb617699a46628cef49adcaec5c9d512bfcc68dab994faacac6462569cc043f3cf4d4c0f3719b88e1301971ed232af62e7d44458acbc494ce889d5ff810e6919216e522d4485126079c1f7835b7e5da3b3858204373c2984397b8fd7eb549820b62942086e2a7a74425e067c1cb276db44587d4c183fe71ebe7a95bccf8117b647e104ef5fc9829b6b92d5ca20bb55658b3a9ee478a10e69ce30c5bdd44f22327999cb664ed775f66bc9a72c4a546b9795b2458109e8ae720b8f0c24ba516c1e2af09118cfec9da8a37d77a5d0832074d7007baefd20fe4acdc2aa0d3962d4691409da6733f840f7e1dd1e0ef2ceaee7110870ca84928513b2ef34ad52944f45ab7132342bb394400a5cba7b9dfd1e1ac1abcf44f16bd4bd7210be149fd9cbf006b5d1dbfbec0b48b03065724d49c1348828ab1ecf269fbe609f2fdc2955e6f7cc7bc9d2f04f27649be3a0fe1c9b5743cb398230d74c98c4feb39e18a925acd3c2f524e3c94731e39d93bdf91f8675551fd0e02101840707f40af82b40e787a0f9835b097a3e33eefb5ab18aa6a7a83c400b6920182c5e4849c9dadeffe6fc7b3fccf345b05440d3f36c2a9e6e866bc629cf607e9f21ddb90162c5528f71240ef54d09db06aec617b94d08010c16a1f09d74fc08c60fa5268964281f369f647067a1f80706baa222abb7bad2289abde379b1c1805f8abf587aca38de42c2ffc8be604230711fbcacb9db9adc940a44a44a93ebf597a64a4c4f6d689e67a5a943caf276b18563deecd17801fd2235eb9e829b72a10db6e66a8baab3b053a9af98f6ccea153adc6b6fd8ce9658c2ffe444a8a6aa99c17c72e5bd5a326fba1fd0c2bcc6ed3af3b325a43293b3aa8e669c6bbf2b15d0ba0e82a59c18f4ef6edef04162d81cf4d3cc46cbbef158e86936e6e0fbb75fdeb41016784ead7cfbab2aac5308994a1756a370230f74d979d49f4d70462a5c259b64392fcc91228a0c5d8444011824cb3daadd25b36572020c860ffa0ea56f245a182923f14bde65ce0e8ce668977bdeb8e0a95c0cb347ff80f7d158de69b8f2e65e0eb95301ecc47f3f1848e93d73c93d55b3c03fdc4c69ab76963a59792688545c09fe3849cd961a2198c47203affbe0cf0e1dd9053fcdc6d47c913679c025b0a36256bb5bb60782b1480becf7a9f5648b3530f55500891176c255e723e14f7a8d434db65f4c90a98106a0fc11ecc1d5e16ccd994cd85f9ebf619447718e73c87b0024a6236cdbc606cb82fae973e2c1ff7b732d9c36fccb85022901122091ddf7d3c8a72816872394e264c26d45ee569c467959dd23e22e858c2047d86bc9df3127acc9f15aceca3283edda708b089df27ba5939310dc56be809932d0ff7adb98927a6f23c446edf9853e7bfcf49673b2077af89f880af839f2954e66ee300feea0ef70dcfc9804f06f6cc75d2522029b00b167059774a2135cb610e4f8d16063d9ea8a78cc92e9c95dd8cf1300c537ce1b5f5139b11119e57857c880933d3f5a353a7cf5da76d1afed4b27f6443711f36bd76d8c08d1332d90afe8995e5323d5618491359b1e2015b0a220","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
