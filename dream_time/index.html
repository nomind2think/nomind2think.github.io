<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36e44c81b245b3035d978d538b6dbb657d64c7e60aa6f7544b0af62663b08a0d62775278d412b0c5deaf79fc7cfbf856e250b2932edabc9928181e351645e6bc3c0f6e4406e2bb0a09c7d0fe436bd9ca6c183b68dc459850f3a1ce6fce6ea6457d95709649d40ab59c6f2615dac96554a633b35a88a11ba8447e16a018fb46372fb30e51bf551b90361ccc1866564b2a5adae26647a7ac7e170437a0de065dfbea465551c9483f24cfe9208980ceb5d8ee3e2146648777cbbd5049fd37ff2d1f7ca7b881f5a0f725abe27d75b5ebd782622df7536dc75831b77d004d94aeb976954a0e13b14b49b6789e590a24c3a3f2a197efb580bb27003e99b172b1372714b6a8cbd02372aeb7d0746c96a38f01ed01ec9e3e60d2d796ab25b793d0102058494a75d2e15f7f50b0dc5eab8a3ba7d54bea16bee243669f7aa893e5f31d4cf96749d43bafac9a8985f4c1f3969772f9fdcd544ede53c528396d5300583eee82d45b236a1e790d0103fec3c30950266a8278a059c8ff9265572a5f4bdbbf2680467a9759248254144c2d3f87d9ee7fee119bcc413f7d4a1989bce8b0bd11ee0145c08b8bfb4edbe3f24464ba90dceaa69845ef70e082dd3d7cbb517ffb8418d5201a71a672618575c055c930cebdb682e1bc6f24667bf908ae261ce43b0b691c5a18ba600ba8e68acf502d49ba8341cb0847bba19fa9825c8187ef367bc4e221df8f8bdb927e2d9a7adc8172cffb0a3ef61754438d4ea97fe020c13c241599e5b1d9b9020ee08b8a1403ac1952923503b9c5acb10e4becd3c44655b0648d7af3c610b29743ab121fa3418691545315e493ec4f2c3602f1f83ea0013f592583fd3a2058ef4a26e91ff45c9934e5dcfa4f4bccbf9baa7bedd1e833e1aa755512ca3b5aa17f47be27719f2a4abefce4ae049a968fc37f7fa89d7692996ec1600f59842430b6496c7e54bf6cef6c3347a000ce8fd3c5eb9011bf915120ad5de7159977585f4c392e5acd3477e84950fac8871fe17e87b3fe7b6c93c03a17b6086ca6fd17547317390f035b21c6c40a1feef91d4623256d4c7b71e7c098eda91dd88b7ed27606a6bec212a7f7f180b5f3a6166cbfc546004e247cb613bf4c17425a072e7b851d2bd4e358f334036baecf1479ce551f55f30ae261d49962194b9331a834ae2fe3e7b4ce7bd2d5532a23c763ec4a817210ffcbf7c53a3b464f46692d54228aa957a8bcf38c12a87cf15d6312db7add6c3869a34be753923a818452cc4dfbd894c958941d6e933d0a9bd6972f0bef3cdeaeb76c0a413089f9bb0aaf89e262c8682f9059fa3f555dad9da7b23b94a1e60060f06665d72d2b4591d42980a9baa016bd71fac87e016d1ed354dc64ff59586d56c8dd23fd43f7d89f6ecee0e13b5ca1ae8649bd148538ff251fa6af183d0837cb7060d330e3f073e5fabe81a1be0e7d3d73e6f14fd15be3fb50a0dfe6151a0af1eb96f263ea7c45328c1e1eee7bc94d64cf46de54d021573b6507822b24465cdb44f74a22067a2d9394903d27b33ad0d0c01c2fedaaaa922f4ed2cb380e98441e47ad32fe2ccc4c5ed881fa15026bb26b7aeb823a5a69c5a3b3329045ca296921377e68734115fa19239e903270b82e76b3f563fd683cc4fecb9bd7e918fe3331963aecc5c25bd88fd3f88bb91148a83edbf363c8bae06240f379f1944c597848f18cbf703a6873d30dcd659dfd0f48c66bc78766fc5ded4b9e6d6b2322f903c603e82684345d10cc06ab9b4de8a488684baa7f049c1c1699d909e14de5c070fceb2f264349661ee7a119e8e72496e699ec86604833970e00524f64f74c43c7956976cda505c1f7f0d2ec4b0742221501ec00c6743c210cb3d6684d1c964bf038c92703d901f0ac2c66743b26d13ef49dbf53be52ddeb261c3e108a7062ef22559fbbf242c280584a20326d9e9d3941668cd75badd1bc35031ec90ce5f5882b2e0461b7f94717ef80a590f600b139b2fbac354f8adb96c368fda3a0a9af30aff866d8a16959e30df56fdb947e2621516035b0289f1f30e25c60abf03f247059bcfc06ef65b4bf10e1bc77a660fd8090f22a44955735661836bb2370c25d5c8ac6541f89cf49a3bf1afdbd0c05256b713a6a76e0d8a0d82023e5365de2b5f708177ca397d0b285a7d001bb6bb3e012913c216f8bc7bb225067b6c7076eec47359d86a1d6b3ac43d8258823b7d4d6576e3df0e122e6719b280daab978afa370cfac34b2cdc40387d9ddec36a7f5bf4ecea01f6f7a96a0979c89d6a7adbe302668118d1d78fb524fceaa134b415942279b8239c5a3cdf3ce22f5bb5d963e4eaa6e479ec86aadf4d22b1048aeca5178fd1c451f122c8daf32dfd95124fb9df01a2af170361833e71ebcdd7f43b2a3b7436a08a624a0a7660cb10231227322ef5f1ee58b800c7da9ff479dd2fcf95e52cc5f590d9732d3a812bd800893617ac91b7743a84a1d424d9d4bc5af6dcc5ff690e26207700e2cc8c5182764f8db3242bee4d4afb5bdece6bbec35c4e7b37a717eb473749ed8de590ce2e51859ba357e9208a4160dde27ea511edde21d04216520b816e899aae13310109173c34a7101c2a532c05c54435b9d918462f0dc4693207bb8ad0fbfbff2aa2ee70201dd1004af7e1babc4de778fbb86991f1273dbbba4ccf529d1a8b05ef4a468f1011d9932d317dcd872dde5c408b7213981490c5640edd1af1ec89df0946f5c31248b2de5f62eecb5495206ad4aaaac4a0bb96de6dbff23c665b3121913e8d4ea8656d3e9d43909b5318915b0436a42b9b553c2eca8503d2f28bc301a662c48b10ca0dd85468429352003e620bc268f31755bdf2bd1a436304e9ba084daa8f7930a533c6e71cfea40338e7e364bced52fa5ce321f3536f217aafb06fc41e508bb97bedc1691161d51c028768a3a5dd1d6b8a45ba75c5b7a42ae6fb9fba8de6be24a8ed6d53a95839c2a0d1344742517531af677609ff7a183a5b8649d78e764a828b32f21d3ff2f62e7a3e1d9512c2f8d0693ae60714920e27b2d094184214377eac8fdc95bc77d0bd73538f8b628961b12c25616ab433c13e24b9e553f519adf74759bba23661e2a164e14ae14b13774cffa097895740b89e799ef727f5118f296911d851bde0a67e684c7f11822ecb33fa8ad3c2b832d73019b6e63c1882c346e984951a82ccac6632ad7bfbad53806115a31b4550a6fad822703c947f178046299e6abdd140692fd51110ec95ce442ee140c232703150b80ed8cf2917dedc6573572bf2a0d2f3d346957357258ff9bae0faf74b5e3ae7e71c4a568731accf1ce3f54b232c2a0799eeba3c77454e30d9ad4056eab0d636adeb2af9b457fcce251051084430f1d12250d58757378f988ccfae5393a173a79ac800d6ddf37aef4a6e339836428dd0e4897a1a094e7fc59ce2a1b98594c46d4e99dd69907ae5c3706dca662ec5acfb63ece05cd752ba67b6954c9ba7dab70503c97c055cdd45fa3439b407a5dcd0fa338695a75056cfe58910815212b442c14fcf0087a83390f75ddd0116a090a80d05ccfcef09723ad3e41dcaea6b77f6c825b1448da613389f9f75b7df79b006d3b41566efe7d374ce414f9aba7d9987f82f91ab3bc21f5c7e49ab0c9c00a522b856612b20da171df481d649ed0a577fb14167c6e82b19713819019ec0c260c4c833fe5603280f8289f7a3d5a9550f5d29de1535110e892c462c9d6255cfc33d59aaaea7636d6156b722f96cb1b6b92ccb679fa030f2d0442f89dca4fa51b2a13bb6f198c98a05cbf462334b4e61878e1dfc177a687affe4319cb5134070d157a92581186f3c6a686cc3d47c56a107a87249341c54f9e2cf16d16c1b96ea3940c291b31017bef00df1bae7a88f107182b4972fb9b28363d944af5df40cd6100f93e9280516a87d72a7fad6c5a178a2c33a918835a3c56ee432e3c739d8d4db62f70feece5a34a3641957e72b83dd309b5455869ddbaa9f3934ec122088572e37c9ceb3a9d3b8acee17e59ef42f9f3b01f4365bd1cf36cac13de5ae70c56a3537700e02bf6788fac802c5f9a2b23bc28e9c963252b8cd45548432232f26bcb8621db5eb918290d6267c20f0c7a2ca8c17a7336668d0f471468736040c2fa1c1e5dae063ea1db2c24f8af96e8ec93fdd67d7cdae2ae06ce85b8dbd0fc5dca112bcaa8e826efa329341e2d3b1829276d248eeedb77102d27376d564096a7595925f9eff75cccd97c347f55edfdc0f2d9d3a1695ade71c4ca48f2aaf477ec10cc2fc1734897663be9a221eb9d9652cdf908f3c41c400943781c8d05130b6f22f48ffaf15c4110ced41045e406d3d89657c0b1d643ae807655ac721d3e30dcdb945013a4c146b460d61b5cf3e500c8ba4ea38cdc49fb92a1b7c795755a463dcb41c5f7f1982ede38932fd2a80f034675f72448cc7a089f5cb6545b222f28662d95df949641e8dc9a7558a9942bab18b00e5c88bf812cd2991d76b1da79f421ebc0bdb9df316fa47f3b7b7d1829a5cbe6d7db8f997ac4c0842a4ac104f950c4d415b9769c58d99c25cce09dedd414421510ee5be8852eaa9a0e788003de0ee7048fc45209cbd0942bfa4ce7348ad219abf81b3b7f80addeedc100333799c1d9a9e82d62243a29b2ea8b7da1c04685dab10b30afe81f04b4ba9dc444623288262073095f9eeef4f7a5375cc67ab65559cbc3afdf4e056dcfb98fec12250adc5ecbd5725535d6d1382987d09fa37e15df2496291821ea5797532989cb2d5c369c475acc7530398fddf81057b18e9af6058ff2e426153de3bfa1f99f8bde5cbc93b05c8aa5054489f57d80325d8fec30b1abb46a6bcadc31f92ba9bc33c1a7aeeeccd67e25fc5426e4f74575893c78ee1394b550e6c6e68345432c6bff8c63629f5461a1ee15189b42ec8fb48b3019544169605c4681d05766b8b54072ed0973fa386c82dfe3816233881d46bdf5cfa5260de55ab861eefd4b3906634b417ca1098946253309c02f02186cea8ae4fca48fdb34e4ad78ccceedefaee19f9a2d5ff8302ee469a09e15409854f10e59110681e94009018d90a45dfc3ea0c97d33987a4c38aa68d1c2c7a4f974393bfe2ec3caf30aad27d6f8bba81770692847d27141a944487d3fb1e7bd02e91a813dc759ddbbd941be38c58df13310d3ce7e6a40c8d74c3fc96cf1fe6479169f67b5e17e60df4ba51826337ad656ad85aa3bfd936d13cffd95c0badc4543b39719a209b79c4fab714315e55ae74c8592c526233d2faa39ad61461ba11b050b7a829e264ce4ac54ff682e056557668c94bae8be9d01d5aba4f219eb711cd3eca82d2daff9e4023ff10c5d19050f4071ca73231baffdd1fe896b925daf2db92b9e375b69d93c078c2619d6df9de3dd51b3ef14994727bd5349f4edb2696a51b34a1912acb409ff1aee1464fee50ba985ea82d366005c9ad217f8d5367ad89e0ac1c3f3d7942f451d88082d2f5590a4f3046e5b55059bb1a60c6a0384e07eaef7fa4b1ed10c83d1bba8bfdd609068654eca1c548681da5f57b64460f12839dd3940e907114a8530a69f64a085880311b3ad1736cd760c239ed77bc48c5b2e379c17f62d7ee0394b0ac5aa6edd3bf11c846be66432967b8098448509c893876f91a1cb1944bd3181e2f71ce7c8053f665158a05c760b46cceb79ce232b063becf4b4676df6ed6d05e19d03e019c9f4c8380509779051f3f0e3d04fe328f627410700a22d78daf10c6664fa0ca0106ccaf483adfaed987d044a90581db7732ed65c128def531b542047106ee3de6b56ee0d5abdeaff65852cbcd0c33a4fd8727bc9602c7dd634003423f58bf86afcd1cd3dca14a13abd76620d49b8086190089b45376bcc2c1b521c7e67c66ce88104936cf0e89d3d1852d18719e186170fe9493969928b54b8dd67a952c4baedf37903bc28d43021ef6b71e78b6b9a75ffb4c4a04a240612f4efd8d70301ce5741174f86e82a2d0456a019b028f0187bf469375001eabad2e181e49bbe8ac3a8a41de4ba47b21b9461160653d7d23b4c81752a28f9476a7958ae1e672229422614cc6f9202a70460b770d682d965bea6fb0d20107290bb1d63526e74d0497ed538d76419ff7001f4469b66f8fc273ea8020de3ca38729624432b7db7ecbfa8d72c4cde3993869ff4108507d2d9e95ed4e751750d5fe5422d204d6e67b77dbdd9f19e65b987d68558ed4a3636bf5824d5b454fb38227e38c031273d1c9c40ce125ebd8abd0bde25d83247605fb3366329afcd6e3e217bb186af2cd5e9ca482eafc4d122f644278f178d0c10c459bd71a156c3f2128ea29a8359d47e9a9693067d8635d3372f45da39590874bb840ed44d478ed356b255f3773f94629ab4b0df4a99d218c2605961e41144e44fb1f399f61e094d9f6b367ec5f3140649655a2ae8f6344848b92d9e13847e00a1b9f383d7dc2f17ebd8e25e531be816f268f98868c456e16ac3d5e9afc2adbabd283a6329299f45fb1710da23caa2fe1788984ebb7a2ac5ba4e135d7e93bf5f13ba466ccc0bdf933e1a329273771a3148b5b69d9f3e8dc45056bb25c20a09514ba8292493c6a2ed579557a5dbef064b48d99e28ac6f4ec0ee77c8a9fdaefd1198a857e99aa7101ed768d537d9a5fdff51e14d7dcb5694f86852389cf0f95b364c6809b40f5d77ed4aa293f979a63e312d0dba2cabcfd8048094d96b750b8d7cd56939d3ca1e01ec877b53dfe9afe28ec3361252d1646d74598d1204fe76daebb4ef82f0149bedd759fbbc092ad828b72c0c86b72bb06a8f8fdc2ce0b07a1542f875bfaa5e64dcaab78a2e931a89813cff5fd93019d53380cfe91d7d976416c77487aeee3053e67fe456debda824a19d0cb2f48480549ecbe8c23dff4f0ce6dfda0bf6b7ceb17cd6f9f1ffed08366cdd12b5802f6b50b174e8ad4e8105a8d38ed5513b3918fe1f0fbbd990ee96a70a0a8cf042da3bc4a9cc8fc8963c98bf9346de9cda03a82ad43675d2367349e3c26c26d1d129f5e9611e357175474ecabf508ac3e83856a82344e6f2a4a58534052113270e04a73534b7262a495d9f6d8816cd1503da2826b852022298b4eb9d30b7a5abc2b2ad43b1b4d84aab747611ab29ee5066a1c9478764545eea2a04d66cbbcf6e69f1bf53d909093c534e4e0cc9dfbdc07c3c6af3d6698863ac02697d374381307cfdb443929f38176a48cca8dceab76b06458be63fcbceb283345948f85ed0470697235ed0b7f096265c4bbc69b4ab5b12ce28a25bc9273e3feb1dc9980a3a1bf7bd2158540e4da23881d6009e835d23631c36282d106ed9e56f51a755c5dc0ea1ef4f011cdfbaaf97898ee2436ee206dc4308bee8941ee6eda08af838d92e4407b2f61b812e8d9143f291f7fa7b4226d1288c0d4c3f2449f5487a1cc29a1f5073bc086274b9034ec366cc78aaf7a9ce167f96730629e2bf9c212d2d7d0a3e599320e8ad451327611ee5e2dc98b94725bd2cf25b0132f984aa763d73978d9ac4e6e990da73f2b8e6cdd9f585082cf95d25699207befe489835fc1c3434b68e0d3f143bb531caf2f313bcca0f3474a35b131118729149cd23caf3a16b750cac8e64fb117a91bf1f295c3d575663227e75bce784f8cae6572bdb4671976874dc4fd49aff1d3c030eca0f0282085e59aed6cc2c85a2200084e1bdfe591aede10c53a3111828641fefcda885ef09bb8d3a331cfb9c185f2a93878e9a2a9dee24faa6c021ebc16c092823e16fa919bc6c13cb4151b4e5ad60087e46f207ee6b68a209f939b292ebea8a8dc9c62113d33031939b15d435eacb0d0746cd66718a3a357f85da2aff9b6783029f768c1c72851d9411b19d1d77dc81f060b8110bb5740237b8c06d85ea97a5e227c76bcffd2daa47f7f966c211905e081449f3640f74a0766a8ffea0461fb3b689f0c1c6ddc0c5908a8d0d7d25be230c860b07ce23bd8f1aa57e57778db922e9e4f14eaa439e637899f5acebd9f88a9dc28386f1bc85a5f36f8821f3f57e11ac84939df9c9d76c75b4ec0340c2ccf9fbdaae826c2d42e16e959dbd2b2b92f242e2e71442a079f40eafd5a21936a7a39f5faf7014028f2e6072f57f55c22a3f9d0d69a0e5f1d171428b4438e0aaa453ef1da38356d6aaacdc4d4c53cd8fba96552de0a0b04b9dadc870b88a609929c986c67a5941949cc875a82edf3abf3df241b75ac2e0e70093ae9f4dadcf672a4d88c648099bafb6ddeb1b1445ea1af9465835df122e74b647605317eb2136538df602a0feeb6cc34483fc60650ec1d098398dadb68d32d3be6816df8ef72036409fee2b618011d02e17e3c258c9f5f064ba2b253f638f810550856e344a5384a0ff9bd100e49d94db98b2d4cdfffbd7448937a2b2a167d4c8bef89d0c23a3c34a5ab806c3a60f74cc5e8bd0f17dbf2d9700898d3a0ee9a762800e7f5f752146a5a84a115f420ba97c124c44c78a2323bbfa6716d6eff33c1ec7f29cb0bf934a747ed5780b9e8c2ef50ac5140f88805b35005dd142dbd25efea74622eeac59c7e5a6963a5b22101a035eff9a5f71307646d9ec2c30434402a97d53ce3bc9b4ab777a5bd5089a0bd74abfec724ed714568df237a145482742d2782094d9d9d68b6ce1dbc6e8147f8259a443fcb4cb90940ae4dca2e6c359b9e05d74c0019053b2117cc171e43f4556df91dcf392335ad024bd0e6893611f31cc03f1579c966ff62e6483907f8e9ff90e192874d53940910ebc8a884f28ec08602fd01b0bf82f862d675af1ec84911d6e4849a0628f250fb93fe5126758375650410c47d066cedfb337570395aeeaca45fe030daaa22c4766e8c35a95e596949cb2ae922b810e231d365422cfc946143a46ad66c220bd2ccecf0bc90f36ba6fd194b8a46634c584c95749500a29cba043e7b144120938aa72c137e60b3b2d19a17ab9863300da1997db38773da12017c5b32472394cc3dd716d4d3547a07579e8d0e9154a60b404aed36a7589e396371904366b6430ff00455c05abebd1076ad94ae71c47c9894880da59fc20ab295ba139e502cba5a19a3885d3f682aeaff1d1021193ee785337736af96edaac2d06b85dc0f781f50c2b7865f8580bded66c93b3d2c1fe49079895841bcd616f69f1830df16d86bb25edeb9d47e1630b521a6d0d446c03a23aaf7613c456cbbdb6d858fadf3a7612012e36a5c4e160e1112a4f565f0827ae7d83e1d5a38393dd1e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
