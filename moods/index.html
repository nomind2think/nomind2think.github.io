<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18061f25030c7cc7a0d2e1046e75ac22868c12d2beadaacdb7d7634fc90c763e1918ea43fbd9cb1e2d6ef9cb0c97860438f6fb36e8c80e41305597bb6d255dbc093da272a62148f92502217d7609d4e760da9057cf71c3f9f485f5e16cfeeb9ec2140e5086caab93f5056d2f1bac2ddaa6fdd8f785f19e54b18e8242d00da6943b619f4b8d4ffd0869c02f6d69564b56b6fab9738ffd1588356e8000825a3fbe261646cfd107b549c52d17166a806447af9c9a3c4420fd0e8232306d3587fa8c8844be7c74541af219e2754ac489c80651e9de8439c8e5b201c89a7cce3e8af0502de1c946fff0f8e8d3364a371d93c97c9ceb8452e6e14f2213057f98ba0f28d5e76cdd7f613e0f39ae87f14e986f13505405129228cb9fb99e46c4b86628fa3a53c653a37e16fb15d9d43d0e5e993591d7ede6374ec33190a995271eeda4e5c4e687f57d00cd3aa2b1cf07ff026a62d4add6ad86136077cbaacc1bb5d28b96bb09b78db3bc6c9bef2dfbc1cddbbc3031272cf5de1b35aa4b1dbd01bf56a5f3e807b7f288219f753e23f41179f5099af40fbeab2c58e5525c81ef08e635be2e18bc533919c8b6c5d46a50590006e169d5076650996ca9cf95b0919f3889343d13dcf978e7044ae7bd162fc4fbb74a92e76c04deff24f548d814de406bd2b758254879e9d61505e9fe025291c4dbdb89507b2b711495bb4d18a9ce85df11bef7114fdcea39834753d970c74eac60af80d83e85571951a3b58bd3fe18c55664ae8b08a7fc9ff4368010f6f6b97ff311d8f9283629f35bed01f9c8a6bfefcabf1abac7804302a861e7e53a3e0047fb0ad60b523e0ebcd5b3229aaa00d17239ae32b47078e69d7bbd4cffaea7e71777bebd283868e88082c2a467c346260ba5013b7cfb12b8902d3a41b06af68bf06f6cb76e221cf808eb3c88e272eda37c6102c5579959970dd06bca86701f0fc7f3af8944f86e64675152080d47dc2d54e70738d4902d5508c299d16d9acc7b37e2f142bf158dc2ab0d082d748963d874f53f4202192026ab09470d88607b53332fdfda638a1274c67eb0e711730a655bfc733a6d03f1e0b6233425c5008f0d2867fd1cb01c904bda9f2f58d6df2ebd6faf71a2b2ef1932290a781d0190225e78aec061809e0599b8e5b11b83223a916337a89c9da037e5b1b2e5dd7fbcfa9e6438e541fc67bc5463f075cba99be0ff99fcb289335eac8fe1acad0d49ac838fa7d6541cdb15765869df3fabc15413d1992d035ba2b7bc27bd8ce6d0c055d70bde1f25a4a7b7868977c36cc99a20ca0ca8308d8d3536546dcbca8c0cb010a1575a405aaffdf8d96d2bfc19aa8fd6eecddbf5b96dbe7c3d0c8b87a4c0d7aed92cfb42b5df7ddb08daae0b6d3aeb3a39d1a2ba12161188bd626c54c2432ecfbfa9cac1dfd3652f7ec1280f268442044e1491d698a6ebe104480f208804d76566237158efa4458adb37ee9cc79213ff8302fccc59f8a5aea1f2b373e6865fc770d68eba97bc55dda0c99c59e5ce8b47fd8a851950da24acdd6b6898cd12a647ded1d0c99c1f898960d31d4acc7d2e1e84eeb8247018dd7c3912e7c86cfa2348e80394ec156efb755e6b023af7faa1ba09ae64e96e333583b939c2aac31a91e7f96e0969ec8ee3f6766c5193c16230b8006f2126cb6098b049b8cfa668459c981ecdd960be443002a5f4de41e404bf3e118ae14d154bd2124b8fbe80e002d9471efa2cd102b1996ab2d70baef063e52be63874ac5043370636558a7ddf515dc68f32081aa46acefdcb7b2e398ae79af338faf4d6041338b64c71811537c12905478a16b666b6152abacabafc39c145aac95847e59f90fe317fb0ac6d42862a76714796bdd81ef6b46ba9aa10baebc5629aa78c998a682d18022c2368970f4f6084241f5eedc56864e307dfeb7ebee05c29b6cfdaf235cc3fd1679bd51e6b67cf25b23959bea1aca8e566432b46ead8e0f61c1fb8ba5c6eebec64ee48b09dd88d8d95d864d86702082f45f9e7f6d4cc07e1bc3c9c51f7bb3cf576043b8d1a0a0b9e2d2ec0612664c7458b0d9703b2196362bce804e015f63a9ee2413f2e75b67c88387504fee9adf9dd5b54da92f2b1bcc546ead8689a7d899b5d50c0b799fa61b014258310796105f6e3dd3189e9d3354ed35f5f9d7773baf16b28da164d6fcad8cafc0725c11405a2603ba934766072b72018943b78886066d249e01b248e4a376f1bb1d92bdf7db8b190d6e642df921c9ceec8d367fb52e5566765015c828f6439db85b121ec20cc671ccea875b1e222a1fb3ae84eeb54e406038dad8579a162b7c903d9bede46526897f4d82711b89295308abc116f5d0bd26011cb4ebdf031f59cd305321b71b699188788d581444ea0b4671bd49073545f1c03545758c83316c3e3127c2f1d6eb875c019bd8b37ae93a72dce58af39ce1646644eaeec686eb70c6bf7f37ba23530ca074cc273132f4abe5fa0aba6a465b09c1a82c85438cfbc843bde02056fbaf520cad801c364c48d657e290d55718066ebab406c4eaf39c457f7022cec9a9e2844f1de76afb8fc9a3f6dd2d4153d0d9499e44aec66839bb012fc5010b8654d2dae488941e66e0c787adb6f11cddf7b415b36aa5e8acafd9753c84aab51815e48638503635a8ce9180bd3479ced7bd9f7c4dfa9af9fa188488bcc49dfe659aa4a16ae7b43e404bba0b0654fac97569783177fac7623ab4285db94a963a7df7360f5ab5a608f725b5ca6c6df41b062a4c2ef46bb1858b4b562bdc82acd6ef934e3fd465496a36f70eac3333f7713a7ee81f18841098562dcbc9eac7d9086eb13c36c0458dc233dc313cd1264e8a5cb1c4b30c8a3364144db1e202cad683fc59c38f2d484489dd2c0ac0064cddf4a5c35cef1929109ba4e245de98c20acb3d763b4a3c2caa876b264a8ed726ecdfa48a3204fee672fd47a0db84b21976d937d6dd342b4dd357400e5cab978f78fa97bb821534c0699db77452431f1227d178c147ccb90e2da0ac56e2a7add8b2cd61538808da088041bb292b99582af7c2aae94c801c2d09b7693f37c428ff68644ea19775c0b17d750659efdf475cb83c64d948f96e0ceb7a0b38fbb7a49ae96e3f217fd817d26bf70638fd756442985ce46b88e57a6576bd63fc8b6685408d360c8ce7d476494855408cc6b5a77716316896f07a4d1840fc4687b30d74307794b3590a007d0dd714edd9c2c154af161d04d363440b0409187426105d07a81a81a0a6d33173e178c01eab17edc64c743fe86b7231c000d4330a939402a8d2a9a539a5f8a91f8a20bb2285c0f2a19c19f1bb0cc51ee97528417420b74e23afb5747e7b22138dbd0701b62e9b630ee5d9f0cab74c263fbcd18b4b50aa44a636aebe01a20d23d618b908ee175302c4b6d122b77c94a92d6205dea5c5e302e64c0cf4dca3cd4c4b1abc59f025cf82be0cb9f232380827badddb84a562ca42b0aebd91072560782c542bffcabeb51507f2244ea0526aefa851170d86451a10d56deda3893f5db771f7c72ec4c6eec15fb094a098e0cf26a9ab863177475ee4976eb03c22496ed2049308172ca6337ac2b10ebc79a2b9340557274a63fadb350d5f455019671e4ba8db5f095cfcf37760072fcbef05f421c1ceaec54a912c22612c193b90a213b9f9c5a9e4a72d8d1a71368c4a07c18cd2b156a8ab462c06553f10a10db578df9d2938c1f6bff65a99149f377b4f8945847b515228dfb75cd44af8888de3da9e08e406ac459afe2288f8439d2b8ff4de38021667e7a079a77670763d273c506766cf0be2c09c8a49b634733bb0e0ebf10860827b8ddcc566c1a5a2ab1cf9199a79c34b19ac46c894bf0078de872eda0d9c65c71b0af6519bdb6e4374a3803f793274dc6e3abea627ed2545f54e05f9f77eedb495fd7052f802afb0cf0d623360a0942338ffd889e3f1bc93c472e651888332a93b71a4e27a055be5eb1e5268727009fd7e93c836ef1fcf36d72d6f297e8d2f24d5f9924267fc9b6d269cef0d983e0466e2fcb97025a647be9f7802decbf534cb3f87dab9aa5365f512e674c339c2624ef233ac654fa035fb0be8ea71cfc18c2715ff8e852fe74d7058c0679f1b956266b8b15cbade2ab90b1f6b71e1b191ff9ac7f251dac28ca378634135c7f218451109e9348afbcab8167eb21d1814f4ad39c8879d5505f24a28026f9f0edb232604af6f444854dd4627c74f8ec37bd60f54b9e19d4545c40e6d2ea5525928b54cc4abbc64880dee4eb9ff9ef3cdd59eb36b540a1d15520abf1305c4d5865fef8a0ab704656ddf33a540b5dc92ff737498d69d6addb2126bb8a601b526cc7b4897012848eb9ed0ccf4665203936acfbd18111bd0df6c16b977c25be4b5dcb0df0b15db57e87e121ff22998352fcd4abbea78dee1640f35407d190056fd4335b58be3342206847c78bc45b46114ce307b622ca399194d6723274947daf6399a62726052fbfbeba760d1561d9e52aa671b03bd458530ef44e47416feadaad4f7c3373ea7dea11f014cbb2823913f767e2f83a7e99ac8a30f978f6a1ed8c75384a6a9071a3dbf1333e4a37e3517fbcd1d8451b0c10c0dc0cdf8f9716580bcb5bc312af02c2877a40abbd4aacacd9cb3e3d34805dfa16a074c4653baf84dcf15465ecb954406e372e6b34c7b5f6578e0bf7b78858cce5f7b7f40141b11bc03a85367fc135f7ee73eae4fd894ca430a2e4a0f2c1c7e6e150bec0d5d8ee47729998d914c6de0fb2d9b11de219368dd3883595f0a5269e0974e34b4ca70112cfa2a8b1947395550e0e4083d564296a51d9f5dc6ac659769bd5808535daf9a3f2c8c703b645b7cae86fc1775798f93cb7732416d93a92693c966b4fae3c8c841de69326a96bb6dd2e9ed4517c92bdd76304c7da024a8eaeb5de2a968e7e66c81aea04686106cb81122e784679868e8349830c8e040c92c26c7aa4135887918ef248798c86c4704acd9e262db72716037bc15491c271f381f555b1f1b7276753f8aa0daf6e362979e80be10151e63518e4802a19e1df0471b594c2114963ae67838bd2323808df69897fa4567a52bd1bebc030d3ceaf139da64ee4c5844bbc9e76a10587161a3a3b52061b66ef76ed3e41a13c43e0d3f80073de0b663398969c88383cf61deac1a85e4a49cab78a48161a388f8d4582867c1d3f56aa6c3820f27c433d15169fffc8fc429256b30167b070802788e036dc85cb86a27d072865550c5a31fbf334b7a1ed3474bbb8e09d31f406f00e4b616e255e8bb945a2ab0cb0871c55b98dac65efcb19e05f9ce7d6211e705ffde2436323f39f8493d660f76a20c3e8b61443b0ac9ebaed6dc7f32869d56e9be547b2f290868e5f2aad31b8011cb3e3993d3bad98fa1adfe8a2c9b06c707820cb329ca964e3089579225961b7479a500b32f2913af816723ad795a9cab7f5d268074f0d8c905d365addeacc7a395d049241d3ec40baf042c62c8783557b09ac9b38b73599f0fd49f844daa8ee2fc95c52b7ec871cdb127bf9e922fbd4558cf89c187047e852a036017301834a7b838b232e792803fa4d981f8aaeda887de7a8e7b0db7926b38e1a07c26d996ed92721f6d153ddc3e547bc4a5b88237641adfe5e76fea1bc7866a44898c5b53e03151bff25f75d1273c94307a57379474c07de7f60b3a8b92f7d04b1890b36e5bdbe9ba70d61cb7e259bd2364b7afe95de5b67af2bbc829da63f264d97b12cad7385f0d76f531bb886c75fd709a2bdd8aada8efd157b5dc86cb14afb675c0e45065abb500ffefb7cbcba47887791a3906dbfee735b3cd7ab88f9222cbd89826860cacb7c2a030561723849e7ae32563e5715e18fdc0c97e9a5da1b10a8eed82b6df13598216b3d2927aa7103b06375fa5a4fc757d840cbc51133d250c97e07f4d313305d7a487e6189236e171100ad3606989df7e4b1e44373ebe354b85c4b42ae2450fd005a969b0923ec3110c48df95273583310b027caf38bc5f64b6e4c4fff2ce6eea2485513154d3cffe182a2979a002d3517bad93345c6c40984118f738763175d5082736dc8936aff4e4ec6d3813170511c1505d44955831db7e38c09a1246254e3baf43095e74412d8a153e661fbb3d7e86cc8776fa5c4b07ff77c48c028e99c27b0f5f8dd24984887d3991d82b4940272fdb1b9cfff7f27f8396e9ec264d995a3ff92b2aa139a62105b90854b3257598cc703f055a164f9d89b5c6619b81d764a9c220f7ff63b14f27631a631247485d570087ff45e2110b2334ac7d071232f335f3a5e701b96df44da71e55f2682a81341fd8f16d399a4b7cc214cda36c4fa2b0bcc5835c58d9c682c521aae2c06c952ec191d6ffd947f002c78aba28e1161cdb80ef2d8db9ca551dfba6fac7d75a52e674ba940057cbd7162badda850d7f3eda3fd3d888760e25cd3542bb0875e4ce68207ba04023dc6cb48b3fd542d63ca857434facbeeadfe1683b1367093a6efba94c756795405d13c3896ec2ea34f1321c7dba90725a08c3052b5a92475f8414484e75bcc7b79612552d47b9329f6cf387ec3f2403dba76931b69ee0307d856d91754493973ef6dcac5b1696a535dfcd02863be5b9e0e8258624aab4ab7838cfb128693933f7e969f982c5ce45f93d227a5931b2e22572f87e44c33d47e82763d0d39b56aeeb63e7649e3951fecc12c15dfe1237ea4b2cdc0607e288196459a062b43f54f147fa1be22b7bd02d67dcc7a148a8d2181461c247376c9acf85b857fe778057932099f3f77adb29bf5773621101381ef5e1e7cec118828168a51c01f09be56f4d95c13444e9df07fa6ef3d8928b0826def1177a296b88d01a82af020dc1753cada8b3eb7815e1fc449aa12ee97ec9eb07cbae727dab5ed8afb6c89a6307125e803b9e59bfa951ced56ccb357d163ef681987e9c6701d3aa0255936f480db23d278d0f46e619405f3511d08798a7cf093ad9aeaf5b66eaac019dbedad9bd58c02be455037335f35413bc448e7333f118e1258542568422ee7aa4da7cf1402e4c4313c7372a0e5d701427a5dca0a41908c6f9bfb0a032779220bbeab228a2b1e03acce2d2034efcdb9e98991584816c725ceb7442a4d16097e5441f1e74cf90f06297182124251c167970f34f3b1986fbc239277a6cecfe3173f3c259335299b2a5ff83e30fa0f08587432ae441db7c0e2971f541350b001e26b826cfa2fb7a7698f1289f75087f914f059affb438494701060e988c103d205c35b3c219201226d042fbad7f012507b816dae9209a6cca9af3b892b62c0b222bd565d99a10658f44f727aa0049a11bf37f9d29b173984f246116469b1d95e1511e07658872830de6ac097e2b822aa8218438c82810c8ba807c9134425431efe717ad329e9fbaf7a26598081636b1bddf9493bc81550a9ba6869d135c5a550fdd56ab3f482246897195bc814b6bb2b794582f28bb76c8c469de87b784e62f6081f641fb7dc58be2470e0fb2ecb76245657e893dfb83c3df12c52370695210d2e264cc157267c97ab3ebbb4396c59309eee7f2e4c065722df63322d367d91e7ad952c133462f881afee3ed2c5be690a7c8991a9da1eae423ee5e7b75c72208a1ac5368f1615e836f40bb1cbd3eec28ec88d49fec86dd821c9396dc52e07778a5098ae8826ec78bfec9d776c4516ddb608f8bad9291d96c3bda5eb9752e0078efb3d53a5f745430776369a94cefd232c6f8a165fdf7d16037b3bfc8a91bf75202e69a4b9f9e262b72459fdca891ed41f7d69f0d5182734fa41c5651e229424634b646ce67312242db461385bc5fa5487344b9dcc9adb5bd395f8d85e337f753810bc48ca97fe306edc4d5ab56719a53b7fd29a56f6994140b79a3dbf0e80b38bfc9d2809fb35a4e95ff12f4ed0a2233bc0c6e52ff719ae210a30b33bbb21341712660363cca03fba66d8c61340d0c9838ea37f461cde9cf4006dfa206e6fc1bce0aae56e6202fff80ffb48f092063c4d86eb1ed557c0d00cd806b1d44f57deaae7d9e80dc005e052db1674500b6fffd007ef82008eb2f6487eb7750e2a132c05f0a0e70e0a4a885aa9a97466d971fd473457aa6a03db1cd19e618aa3e3c200365a98401c11b974c182400514114d1c4c4e94f18196e5f29646059f1b433c1a4340d53994ea58ed7f0a8eb9a5ac8e702f269f7efac9438036839c4c23db0f08db67ddf59d3591f0b37618cf0bff1ccdd553f8569fa1d746897ce9663199ce8e4001f5f1de0767b42e8e9832ba44a8c9417a92ab8b29e4828e1a56baada20f9504381be1156c1fdd8f00f016ee206159d85240628d488a04cf0cdc9f5fd677bb8a91cd2f96e389fdadb5232d891366a93e62421b63075a15d69b3a33b450fcd055e2065dcab9a0074fc0d77dd4ddc2d08ffaff371fce1112b80e455045f9f40b5e157f2ebb4d65082ddf45661b244b58a28813f128934120ac3eee3d7828f9eb7c9352b476f495c216ef55c5947f8f5ac30a632dcb23b9fed7091aa552f7925fc8f616241faf0f54432cf3820845bd4ae4be3e02f3dcd61d804b1de44655a14bbe5c643fda32b0716a21f82283a29d1c00f4060d0c77a13bf1b4207e931279e4e5695b5cc3b411647f017d72b9541391009c19f48bea0caf90c48219a7604c65f63322d0006e694cd7be26c2d3e73f04a1a5036ec2453b3bfc6288dec1e1de28cfbaa7fb26858be3d82527092613770d8d1f3702ceaf6a00966a9cdae4724acbadfac5957a095d90b9d1e475b9a2b49cbdc5167465de23db52e150d57e7ae9f6d11f46e93f765014668008ae179e9c5a4c0a105608696bfc332ec3f2bc03fc76b4c929796fe6bc7e90f59a52f894b6a4a83fbefe17bab924c71f1fdaa1560bba6ad2cd1aad91d49518354d5678f6b385de909c8b2ebb4ae6d05e96faf48548a7a06a30eb3e173e3eea3fceca372cc91ec581b00d4de30c553cfe5966f6521c678d8f8adeed82864ddad43a6b1320d1b2950965dd0d45aea25204bfb5cb8ecbeac28a67ecb9f298f0a4410efb29b4a1e37f921a47c00f9f93ad3aa4b47830a59fde6682d3d98456f3f3c93761e9360ebfc4b46c8b5246909f285f66fea045804eadd5cfeb081ddcdf36b3e5521f54f03e40fdcf957e675188da06efca4602a764609f25930c36fe9599e812a2a63576591cf71c356f571d4164d448f673f4e2b6102f3e041306f6b0e391490230c21730bb986936dda1a135f048600ca3e3d320d78c3611d8e702200dc0ccb782cef9dacd343c1bbe9f9b681a5ed402f9ba195df862f219a5caff52f12700bdafbd7d413def6e400afb55e1dfba6f5fb883dcc6fe1138cf64697bfdda982ee2110743255f45c39645e73745c630fb74730cac17ee21f4b274cacba7a74b0ac100293111e5863d4eea4713f9252d00a2229eb4e54bb36e13c73247931e350c43b33da40aa4e925040c858a26421d29abc8a0d6829e5c30f2f95bc7836cbcc08fa07e1cfac7ddaff47523c3024863884b91f1ca38d5664884d59cbb6e4ebe573b5990b39a434c81219ff2b63643974538356317f2bb736e947272a7b7928d1e4b36b8fce92aa3124fd29a7f275b18e0ef4f19e6310e2060ab6a61b9171ef1b101ae336e78dd901f884b2c1a4cefccf6160368a12c04f9854439a94f8c9b9cddb53e4bb37594e02fa5629704f9304946039bcbb697111329ee4ef1d0da8e4828a1f3da5fe8d5fd0fc11af1fe886d1ed4ecc25eee946386a9429f141d54fd62b5d93bd11b58c259b69d0ae22969db9e3e79f24adc521cf6f86df534ca628d90eb36c633d38e1557d54a21d5b7398e3e30a73fefac17cf76fc99293321f9ff646650193ed8ecf02c19af6f84f6270423bfd0fddd59dd4df54f5d23f0014f7e68312da7d1b1be26f1875f4f9ab4f38457abc558226c407cabe67fc27b1ee53a161d0aba5f7cf57477cd7c9682f08bc6da2df7ed003ea0ced1a3ae4eb931c8242efa48bbe5bd1704d979e433d9cf8dbf2f41fcbb12023d28","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
