<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e906af094f8b9f5f71ff8e844dd753a80036f7f62ba0b8a566885d1474762414798b8cc6347a2ba31b3572b2778aa79509c3ee53c0aa6f126b11f9bda200f107d77b6155412c38d36e580e968d6b0f8f87143fc9358363d2db5a19b9187681ac2064e003d08c994f94d4569fba8c2fff32ea69e75ee51d51ff793620fe9e2cfc5a93f64afe173daa2a16b200f619b13fef8b4d51550dd41b0eb51019acb06fae70afdc2c31cc62217369b347145e1264b8bcd37ed9d1afa844902d17502ddae60a6046a22f5b7b4b7ebbe9cd0b66b11136c84360f494592df61e03077548e69224533265ccbdc0cb6a09f7a0a4457f8fab3a7ff992be5f0f7548a2510f0116bc8d06fdb479aaa0205c1fe2ede779ed5f0f0aaaf5e8738d3f5bab29b093e16729bce70013e7d950d1f6df87e588478c6e0be53523ee30fa07eb2d7f993b858879442d8ad36ff2dce6f63a5da83eb964bd327eea0ff541b22dad957a80f72350264be05150d42eafde513b58de0c1782450a8fccce1ba24aba0a397c4c155a01eebb21373d270c48739808bec3f17f33b3af92de4ec3410fa8ce71c37c14fb80fdca90e000da02ed07625f0d7e2faa6e8b5e85a0da3e62f06e3b65999d4f93ebfcaab731869d4565e8f3da526da2d1d7d4a7157a71b5a698ef848928e7874f67df7bc18ca1af6e9db3515c079a4f271a5f5088efcb417c541698ebfed53e73b1bef72c30bef579ce35c6ecddcd23746e28f261e1aa33d74f53965ea962d3e2ab6f8e3e4a66b97847d2cd755a57b01651f958cd0ee8a564956a7187abb9cb54633c08e14d2b16a4a0910814e64b47e0ec0ee2e5812f73cff998df959eed29b0bbd0c5b59bff5480c6df399b3b8a7cd16f1dd438b7c31fe55650a3a56d161c63e38d4d5a99bcc4dd61deb344b4f19397f3159eac5cd1f5cea11f49647d12097b1e7138700e5cecb54db2c78b5c315a1a83c1bb863dd58c9b97858a61ac1feff8e85806211c3d9eeddc0fbd44fe91eaad0a01de64589843d890e54ee4dc4167311bab347a34b0d70de8a8aae983447a6c41fd2bbf69c3bbaa9155740fbc4f91fc569d6aa9016aa5cd0ed5f07d4b7a82fa32d8fb5fea9ce74e0109aefc61fdd92d0883479f9881abe484dc441145b73210edec47dfcc58fd8d6eb75d48223971e78174f297f1e2b28a1de6a173d651cc2e770816a07cf1f63b62eae9dca9d0a42ec4b7103d2739e5f8d5468cb905fb83641cfe14c085ce22edda3922350e30e14dc4216a2d3fd8e57e20e88d369a4e871cf21bcdcc68ee68a683c057faaa07ae06b91f94bccf9097330cec71111c80eeb42c50a17052a6da3ca8d6177115f33b3441b4f6ea5877b06298f81a7885b40d79a3dec0df89fac0eff8314992837b4793dfc15fe8234669e742754a5548456aa4a315fd7204328020cd1412a20b6a27498504bc9b7b93e118ba71eb161ed61110c37a5b94d6a26b493487a7248bb4dbe550121c6625bad99f7a35d7da5bb38da3dba29084e328fc5ecf5de06eb4f25ead87c6d5cdaded7c633b105872ee525002ac5740b67f4f61f960ee5ac7bfd7071d0d51757cc34107bd29b3d9b72647b91a92a909b4ae78fa6dbb2028d444ab69ce452dcee3d752d053ebb8b72bc44a444c0712d78d461b5a9714b2706f8a9b603909aab5cfb9983df625d0e00e4003866143e86ade3cd008f06448dd0b54fe9d543d627d05e61d98403543b5824bb758538db87860165e8251356223f9cbe89b30d481232f48fbe2e70eb02f91fb21ac188f943b686abb50eca98c506641adfd6b3e837c615980c22bc5bd355b8eb3f82017b411d8d42a4a4fbd3260fc10aea06c9b0f612c6502aa84a1009c83987b6f76e2223ed5df7f1eae4bc0b0e9d7d4a11540ad7bae4425c64ea8e281ea5bc1087453a6ec35091f1c0fa3b33bfbc1da9850f2ded04bcce238f4a8860904097ee7f8e765e00895830eb3543611dc5ec576a55b0cad117c326039263c2ba101813062ffab03e965e1ee8d0931d60a4b02e991ab3929eb9e7f636b9304442b758d4bc85e286f5faf95b485c04256b5fd66b052bfb58ee6e25c33f2cc7c43d1a973d7f525b44fa48a3cb53f681ae0b170751b2161bed9ab9b5bfd21e5e771884a475d824d7b919c30aabb1f36e760d63da57df2c43e5ccec22b6ed60c4de2c414cc8421b43883d8840e138d9821cddebf2a2e35be8a923e4112238df443102e21af921c67be32a7dbbacacc51bfca8efae768952e457c0911ad50e8f99d632a46d7905ed6aad2ada9a3dcbb7ea6187ddd8aaa3a1f729c35e1de1346c4e247e38d07b4a521eccd419a75af0610b25b010e8afce249a831822c0dfda6a9eee0ae55fa44b951d23deeb5272429261c96dc6ecb780efcace644e52b0398b7c7a618d20e28ff532f7947bf26459aa0516228ee6552a781163f824cf85bf69c721edc9a1f32e2e2b798efa50a85863d66dd01d115bc16f522bdf396747d5970ca59f0ad71b74011bb8b72781b9d3a17000cff45d64c3f8006a7da269a93c2493c3e5504e1e2312f89613ff2c4c6b3c20fa91a020ce2a3fe112aac501f8342f617d4c47dbb35344c2bf4a218e89572d1461e54b1d27d6a70527bff2f8cd529163db439e3a7a6479f171618d1c199da2d223e61c02ba6feb06a420fd7f320d96a8835339f5687f72b7dc9f00646ae089fe8868d63392d8923faaad36b8b8d549109a2e136a0725869827950f48f6b360fda1b4b311d88adb5056da6e0e93164bb929a7fbd4f69e06b3340c84041c950567d5a2490e0a707793efe37ed4080eb8d2e6cecc669036700418eef50dc04df7c48ccc7a510d7191003b1a828c78963c691d47c22cdcacba03cf3a5141d047fe888d6fe9ce19bdeb3adf546c175e7a9bcfa2f9ea6f804756560b2b524ad863a7cd39c4dd71d99669071f067c6dc282a4c93e22d90b161e1cb20dd306255a7ea6d0c9697f122f84c96dfc10da7249e3c28baa14d6afca75bb92a8715de6efe1c9bdf4d44ad27952c821942229a5382e63f687c57390b37be31849be75bb33c806af681fbf77269d35e7d7795966262e528384e7331c7984e0dcd01946679aa35e2079d2a6d63bc752bb06f41ac112e3d083179ffa1e697777cf20c2fc379f80a2e7735e5204cd5adc97c8782a0070f4782c71ed971aa729f337087033f339a5e9127ac2925232d11c98c69ae948009c294a32d5c0dc499993977cb989477784011cc52015777f9ccd5c257208bf93663180b3264c2761c7551cfc9dba83c9768b3c877fd40f77c546d087fe95ab98bbcaaa8c52776435ecf0cb5de37fc9feb89169f992ab579d4e764e0844c3f655157fe94af4d0949536ed9c12be14f16106792550fc99d378228eacee377beb6ae66d576fc615b17e8ee4cc2f17dfaeff2cbbf29d2d9701ffad167ff8c0738cf8381511e1bf9ae83589c34e3c53b88d7c1f1dfc880d37ab3ac777d94f3efe518b3966df62abed147134c94b4a5e544b5a7695328e9770209f030a7ac4453ae0ea741537272058042c080919a578941e992e1a4f75eea25f221595665403008203601afb3ea3d7b818407fd985aa0f1778e925859dbf40f2bf992c340b2e4d1103a3dd48f5f97263668b69c9c91aabf256ec9962ec996aa275e3ca304848822380e97e63a897ad372813705c4859bc5e740fe67bd3ab5455790bfd30b7e635ba02a8e3c59fd386c7d68f9fd31bce6b9c0ad66015b93f1f62eb4cad89d658ddd487e47f1b6bd3c522f91589ac5e90cd907752a03ec5e2bc4c059112c009847885c8d4a36a5bdce7b360f6d018ec3c0e69de11afb76daea7bafee3e79b3feded5b094a111ed73b701e0e95f25de460f22607ad941f98475bc957675fc689bd0543533e4bc7883592469cfa046b5205d5e17fe22bf34df642b875b17a3392aa4bd15efe6f1132c305718084bfefa732f8c27fbf02cf6ad7edc4f790bd69d4dd831912ee88a1bedbee92ac510695dcb04bf1065aa38d407c20f7adee4ba95902885f1b2cef8e5ef8976a75e6d5d7871fd4cb41c09054ea4c96b0bb6054cceb3d6f7b83ba352a887223e9cd4baecfd6f797eea93d6bb7798d57acf2a8ef6cd427ec745abc5e423e20ef7d2ae53e1da36fd3244487c790393b56efdcc0c5b7ad4487ce3369d264f7b8777a064e960d93a2b9f2215513bc46d44229548037f009a9f3b6f3166535b5f493464eda4c014da9ac507a40bcc3ff24a790b1dd70be76bcbaa614c7f696efc8ecdff816c5bd767d04f6355f3168d6e57d13d3899ad0311e350df4936b49b7e184404ea9046b7c9aae3ecfa32de8f41ef356627887380f2992f17a69f297bdd5e88039873bb292a402ebb80b6a6922735624af4a302c6c39780cd81ce2bb9e22c00578873b2e910355f4c4b52abbe2494a5991448732c96c0e89d880529186d2a232e26d5d3f4005e1fcc02405c33666e81cfe26321bf3911001c30475e3764f7989f90b1340d2cba338e6f7c240a2d9d9f55b00c6487daf8d2a5b638084beecef6709801d308a97dc7557aec1c613fbcbf1a419607360fb757835615aba3c67461241ea5068005021ee4ae382ecc35c85cb33a16060755bad4cd3a0e9305fbb73324b7e40c3e3d9032f70a41ea39d9c044fa0fbdcbcfc8e2da47ae102ecd096291c587be1bf2bbbdeb93bcf03730d957aaaf8de98f81a288b8e76ba2e55ce65ccf66b90858f73e4e410c9f73454007c301b7fcb26b6423e93143b98cc56d956ceb3f962b91fa1f1c860bab45f9fd00269e92dd08ddeaf85bea8830dbb7472c293e26e46193ee24031dd32fc17facf67ecf330b170e1b5fa19e4a9d0a5c14cffd3368a73d0fa47012aaeb36c9dec346bf2c1aa039a260556d9e9a5317ba8316448e5c47ca8f8dd6496a3ab6c067ea30f27ce6e006b7a960346ecc6ebb6dbf2a87bd677f3123874d56099921baa8a10ed2a37e351280a8405c2d52d0ce9941950d1ed484fe1e6081a73a99738ad6f5f7e3bee938ae7c90734eae77fdedd222878c2f6b4cb976c23079016dcc0236dd2749da1dc65e383cef8320db5066cd2b0f7037c6b7c830871e40c5269a61bc16445d19f8a7ebf588bb2ff898ca8ce6d756e31358a0bd55de6a4eb31809f1b615bfa31425210924cd424a5c0b45965abed0f44814ada04d48e906d154714187b20b8df9f1196f59ac34715b75c9c78ec5d6075f0fecafeb860401bd488cdb89e47f5fc67d32cf141b9bed8534055cc1809e97c384da3ccfb1e9ed956a7b745ddddf5168502438822b2e27913614376b2b4564add17e1e97026613d377ff5668612b0fb0fed40968c71bafef8c66e3cc46161461b3660431b348ff333907d7eaf97ca43e82cdc470180b9a3425fef1fe764fe3b0a967c85388a4f38494bb05d6d9a332183429cb12f926de43ebcb2e7471808f03c7812bef9727409f7b22cc8c2340dd151a7eaa9842eb1363e7711fef9af717bf552de15c12d6e3672b9a0a0e273333b0b9b50a8aaed545fc5f30a3351a9be6af6638112218d3a63f327878c318fe60fa6ae852c787f63d98300314ce54a40be55b6d51425958a7d1272473672db3dcbc56d600ba109320166130d69efef26987eecdb37626b873c2f6b50155c4faee16efef10d987705272d660afcbddb523a0f008716d193b5aba8603a18754078a5e95091674f7294db17a40581384c06f2f93f7b1eb1e401398ade99667584efe5225c1b04f46a15818d44844db69aa54ddecceaf8802d0d0a14c2d49a1ef17a6e038763be9d2b1a006a01d8fe3de72daeb18498e446d7c2c0c6fd0679de24f24067c388d88ae99a2f69653a575421040fe380a4cae9f6a64e46e30ccf5c0c5c408dd8c63453a22c0cc1a11770ebcf66baf3319a4290633e52e07b4a8004a4e04c82ef2264069e924c6547dcf73ab8c2787ad604ba3560f91899e5a5a3154956465554017e4d6d50a784be35a0bae7d0cf280216b57c523e6923e5befac523b7a1a4a3bad5b372fa89bc531f6c045ac1b17c6d571e9dda15210f3ecdbb5dc42d39b61afdc750d6b032681ca527b0ba99fc0612b7e5d793daa003be15cb6efc6fa2190eadb3c3fd7f84df6a2db677a6f47a90ffed3165c7b15803c81e1014e79336f6a73a7f6a177e2cd032b4d7b6b2fe11fcb4a70366ea554a39fd1087632650a61cdaaa34256bfd28953026a3a2cdc32fb29d8c946ae3f4de316b2ed8587e85b23fa732ff6b7cb7bb1b49ab97f76a0606df99e50a70aa284db0f8e434c16df5500b76ff31725467e005111d9093069705d76b7263542816c8958f95d00e527fa905fc63160d4c2e3927b19b1d91463b5199f431e0e61c7775f6c0347ada43525761c66d0e1e0092a9684d1bceb70cf30024e88ebf65e07d8c71cbc571fae015ef0711b4fc6933c5f70acdd2df91f2751d86f27a9bad423b4536cc800ff4c09ad9ca6d5d2dd833b4ffd32aef15d7a64a7e9b4be4abc784ba2b5bcea01c93b63e74b24cc68f9bc0e655f106dc35f177ad5688b4fc1e638ddee4d8b388aa15849eeb179bab48d6b5150ed4994b1e06dc8b20f205005610e2cdb1e12a38d440b5aaa11979f09475787bcf7c4ee0ca6a6a40d3beb3070e2410200b1fd4b41118903c880b5e28b99a42fd9228e7afa93770c323105d5e953406b4212e3c4104da7b00b119be142b18c5bcce26533190962c7c1f11fa63032f7c97aac8a01ff716ac07d2c1d25ab584e8f25f7e9c345ed45e4ff96913f69bec967654ac0481e8a1119b35dccecf8953b34dea8a55885053ee26c8f5d7662cb4292414cd1e9c5ec8c412b0bef82ad24badc630b849a2b44bd68bde9a9e6bf08d3f224e4d8158dd3a521d59abf640aec3299b5452de9532ea3ce9feb060fc0e8fe235d423471b41332ee77df231b8d144653094ab21e051a5c8179a96b212b0a2d88a249ee99dbab7fa016d3e4c4b3a56edf4de1cd9e6b4626482edf8b991064fcc6b3535bd77d4758b7d069fb277e567bebd3669177b4421f2814cb2d1ced5a4e555f7b8cf7f8185d502f83e4180cb289b67cf83ad23f450c26bd22449b6fa46834fd3b182f8cc660b12baac7267d1bb5539af8d5eb46de9f81e92ad0281624637a33f8b42eaa91189f36511d1b41bccaa0221b75abb9526165fd4fcad5ab4ce90ab3e3eb356648a1b7899598531ff095a7d910d701330d40289134367cc9dae0e35465ae6e9fcaab76a2c1f2691dbb9deba2d9c5ced42aa7313761cd9fd09f8d622f6b1b97111f14b09d418258229cbf2e1a21b043f80f1795d785750fb4b80beb5721b0777f9a09d52a7e280723dba2ea1c206ffcbd2207a535d54d0ac02febe206b89bdef1c96972829bce75783344c37036b3c398f67da6cda1ee14f6365a4fdc66302702d41a83378bd4b35fe105e350bbb342c4d48dd9def0042fd3b625815388371046e2a48f4463a8a6ac5ce6ba549a4c19a15186fea88dced4141875265ac6693849a5a2ea2d1a9a012fc0e0e6eea66d9aca76684a507094f2237c177957db5675b08adb1f8454f799adf7caa2e79ecabf7fde8be0a2bd5ef452f0ef606f703bdc17914f61c768ab1317165437516e04379387c2c0d0bebdace7d68da5f7660c1d5c80016fa4d6cc74e5e579121a909ca6e3064499b738a05b5b4e58ad7c4cdc47f30734eaba2821b54139c974660dc44096f53ed001beaf96ff8776ccd075278f44dc22bae9fce2fd0292c9c67b310732c33ea97c25cebc4ba9d98440bee508debdfa573408c3c66e21e29b9d37a3ea755ef5f73e39770a0502798852e00f80dc41e0df2d1abdc00621e66700824906a7ec65f33bfc37b55df9fa218f4b96b703a38250dbc8e352eb3c20bfc582dd693f7a5266e4fe3ab6267a2793542a4f86079c207f0d70400639bec1cb1d6cbe50b7b1b4b607609a4608ffc350238ec698548f53be5acf696c348d3d26c4280a040902335a4cfb5b50978ef2de91e660d3c18cdeff9cd630ee2fa7938d481666ae3ae94e2472d3fa53b9d66562bb2841fd9b2200aaa7a19e99507c26da7d97dec115d956fc80a57a131a8da63c107a444357a10d2a5990479d58717b2c877657b62d27e0135bbddc1e179652fad327f25033dcbdd1426fcdecee0454a5499880a836fec69f27e80a2ed422dd12a52d6531cbf107bc0fef0984b9ae61e6670f55baf17f405b85d376b88813e7c98e6371b70d6036007017d5e18e982b9411ae6cf2d2ca3b97ecf35b5d8e37bfc52f5e431471809301da727a03e97295e2a34e9bc063e3e7a6b270c1141704c601fae6386e6a0354da708c6cbe055cb075361c14a337b3bf8ce1311d453dd1fe142423c415880469f5089181eb24752d3a67d05296bb02b978ad66a214e7d16e62de93500a7abfdbef7b5ad8ef503d0506727a6162b0a95f7a5414ec6f9eeee0bbc4a7f07b1112f46818174dc5183300c64f699105d8f80c4b8171ea7eec4d8681a5ed81abc6f1d5614badde133759b1ffad4b35e7734b5620a68604590513d2aa800879e3a78f3203747091a3331a5d606b9f4db620c9f5df78412d7c193c097182844b7e2174c9b7fa170b3546576b3a2fd87bff95386052dbfefe19f58100c24329549baa7a633988047d3fb59a18655cd88a35b9bbd3fb3786c49d4b596b53b10bee798f9ebf816ec73ab3bfcddc90fbb734301876ac21ac0a57d42e6de82ee20511c6e5a5982bcb3c0923972674cac6a163a840fcdd0b5a2223ffa3fe4060b448dad4aa4449c31c5a42d2750794ac3bfe56e971304264e03f9608fbf08d9730537162dbbb4d6cb18682f5fba541bee8acd26cc0aa6d74ca03ee96e8529f7d137f4ce720ae320cf073bb7c671e003d44310499171d57a4977d74f8edd9f18ba82dfc83fff445ca1c0d860e24161837ba9a41c96d0bc95f5ccb2daced57a269a203ec1bd1f25cc91b1bb6b41ca95fe93219dfab5dbb138f37e84a7e3345644cc5552f9efb212590b7c9090c05499a961d152f8ab27070b13799d4eb03c13e16387ce3fea0561c40cb67bc66af413e3fa38d39ca37b10ad1e78dac629216d2d6499cfb7c6d2a40880722b3df7c78d6136ac2d4fedf09c8f3f71551c239b6cea58a8697e08276a4aaefe9a792d1de53c92c7a877e6644da5b8882af8803499b0982b3ef4706c4563a62ff034031d69d48f2d926bc1195a7038fadecd45fd675fe2455c70177da8aceeabec9d01852505fcbd45a629b28e885a2e0f2d52e81c3aad92730c9cd4b2af82476052ce260232f1843def97023ad0cac62c9bad63f99b1631f355577daf9a3d6476363f1fc875e3022dc3bbf5d020e2d2683f7fd51591b5f24889f0a8f3ec76037a842818358716ccad08f60859f3aa58c0e70223e0d7126b33d7570db2f415e66654a28ff9b8383102b537474e44af5ba87e4400aa84bc406fcfd93d443e2fc72436f9976b8d721531568d85f0124acfffb8045167caf5d234d9c458c096306b7e763afa2a99b6ddda66814ddc0c62369afeb5c996e41d5e557fe2798166cd828a030680b114fe122d569036af259e9268283f1b0d28265bc9fde3d1e91686d9129038fbcef538ca93cf07180858652ff6b0bd004a201323bd21ba4626e38b9d6290df4f0370b818f226db313268ac650920b41ad031abfe1fabd0264f49772faf0d974a57f11cd2e08850c6a0c3066998d0e10a2f6b56727ed1cfd9c791606d4cc2794b643402e0488ca9aae6b967f649dd862ae74d038e6a7381d1c5f5e8f5b598d9376be650f7ecc85670977f8a38127ec51578427e69255d44ddbb5a25cf0c459f3cf406fce3895f376afb61efeec4c9d168c250559e950da8b62b2387b5588539b5010dbf26563ab6d7e17256b526f0d8123212d44ba8f5177e78f6111a0de4164fc11a3e139348ad58cb761ed8fad42d4cfbe85cf1b4a7b597e766fdb036c7da76d3c09a4d702f3997092c22eddeff44f35cd649865873f7dae1f73f3c53a62b10671a970560585df0b26d11098c91c123c8835e93ab60ad1ced8593e9cc508d821da12b6840b3847f575c827631b7e7cb764a67cde21a1ba9e8e917efe83e3642f999092ee2d2d41b89b5c971a6175d187cfba4315633bc81e9e0d10b2a43dc327950da5ae3bee1616ebd248f36688e2cc6adb16d94576f3905d163bf31e572e8a10789f7c6d5991e2358bda67eeb254c0037905b009e282844d061523b8ac5baf923a1cef15bc7b4e5d29e34f702b58ea1c34e6f73c02cfe640cae717c82e8c6dd7afb3aed85da84048bedf5057573a7f5731e9fbf969ca092a26dbca3ce625f3ac01506454cf7863e551513aceffe0f5540096c316c6b1ebbc319a277551f03d7b9e1d87ed86360bb1e906d47961867f5aa7e527ac01d5c3c0902ba00b3e974421e3ff7d9d9aae6d1778fb5d1f4ed26399bca99233a4e24390bc48f9432f0c213a39d47b5a5d0d2a2a7a1eed49b8b02a772c9b1be1e5e865991ec2136d6b4958893d3baf9592e648cf057d2fcf75afa387cbf38a785cc612863cb11d35eab5416780f011fc792436d7c837b61f24d84486db736a14f9a598a60e3e958b2185f923c65d6d3806a8490812b8e9f096bcb08a889b84db73c545ddaf3fe884b215dca6e52230e7a2b41a667b4f5aa7d0af29df63f532d51aef31805675900b0ec6bd2cbbebebccdc686b2c4e04aeb9eeed6d7d336d0b5644549bcdf0a2633b1167a66a8d188f9f8ba4382fbb852678f41170510cce77bc7f3e8b15b894f315cf6bb9e878","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
