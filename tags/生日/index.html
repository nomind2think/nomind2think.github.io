<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5102a48437eb18dcc0619086b438635fcc061e174fbee577206bacae67e453fc59b53785c84672c4292c691d89eed50c31f6f95903c209a317aecb57c2610f82a3832152eefe9ac7776cad800443e58629c66645d1a75ed88fe8a2df2ee62d7b15cab17c7985b0d8db691c46bc0ce7ce6386ef9c7972dff780b17310b53de5dd70f3d58806d8563c8d34e721b797f7a3931f7666554390d13beeb4619a2bfc50c60e577f30790bec50b3c07736c95afc9511a9daa0ba36c150dd991a4915447eebd0cc6d924fea73d9841fc601fd05c63768461cada39250a6be35c5a43dbe3d401075794efeeebab43378eaea63ccb2481f5a6cf1e3088a63b70dff39a49ac28bf8d4ed33b424990859cbbabebdd50a1065a85cdc2a1da131c5a026a5a57196d0ef48efb872c21292bcbf0a220fef108159f84d9003d2b04de748b14d35263adb4e0f92dc53b2e98cb62c6daa2df758fea61e38cdc59255c63f674c5b1e8445438eafa4c5bb783b8b26d057011dc6fe55676d30eba34b00cf3a9fb975c570083bb5292e65ae1977308b8ffc169fa20de125f3d5481364b28fa98ec58fb3a228e5260f626605b7ac17c7920efd715a7f5c345b9964027625e90a73fbcb87a6de3411ccf7977e4bee6e5f0524f0aa572156847888114f3d2ff89124f710772a3b58b36623b075a151c42183cadf51b889f6037bd0c95c9e51edacc617907f803cae6abe3d8f44215d13197097c8a8051a3cafde68c716ee5dfa81909377a175bbb042dd5df07d6ca2de425c81ae9cfd48f6a9d6562d6ac4ad812e0f793e0c6ade7981b8fcf7f14ce305df59d31598b80ec03dbd4ef6ed2fe2635d939b7696afd0aab9aaacdcd607935347d7e443054f8234fb6e44b9187717929ba001b1fe538f74827102c9d98a98975583171a08d25a30126f3ae44dc55da6db088db8c9f1e2ed7d0377e748f931449ad249efd804f55c9476360867881b4f1c318d76cd3e8a0913ed463ecf7fca3f384ee1eded69e079b996724f2cdeb39aa1c9925b97b7fc7f81939bc798cc4f7df958c7996f2f12add0c8a7da519d1a59eeecad2d6fb31b5c361eb8dab5ac26d9311d4b1bf64dfbe60f84a1e17169c481e3441a0a8df8bc57e76ff7011ca354c1ad83d45bfd48d99f4b5cd93af456b9a4b6c63ff89409726f4d53903caf65e505adef299191cae1c1afada687a71012dea064d04ad4b031097f0d1c057d853d3c64f150c4235630308555d6d8a3a2b52a2ff3c8ac14791acfae7d6ff74a75a1fdef6c0dd16d3de625a547c2b3a7a831bcfc06dd888545b2a7b383360c088420163d32aa9663b488f2f23d4952b6535a8b7110df7becc145a63cb48a6638db253ca51fa95a97f02701f7d10360e2132b3eadc1749fba22d516d6186172e78a3ce3e75aa1e720018c0abef232712708c70c6c1231df59238b39b48d3bb0062e273a4b828b825ca957766dbe97dbdc4222c9d9debc0c8b4cfe8fac1eaa16b1a4cdbe3398b08c3056c26e053c76509316785926914ed2cbbdf4aed9fd35be3b706f6cf0c61e151e636e997200f9b1c6e32e8ff149291c993eb50764eda5771b57fcbbf68515ae5fcdeee1788407d103ef57945a342950fe1c8f649d2cfef01ac66e766ae2b9470e2d9968d165b40ef802589ee0d100bbe69ecce382045e4f1ad20c7d49c38a33c0c4ca44e2c08dc79663953e11ee4fec96b4d251951af5d359138c2bc66ac53c13cdd23cb7d92ebe603a95256ca9cceca9edf4d881cc28f01fcf2ffe9c2a87c84cb5d2e929ce8bc4b294f7b9c5a96c119e154dc781f03382f7d9ef5ebfc181755646bd4a4682fc15d32bb948cb51173bc9e3fbfa45773df447c17ff8dc8b4b39e263adadbcb2ed66efd9cf697681752fc4b658e81e86dd38f88fc4e422138d8505f8c067e470ab09b775cb7af375f69f1ead30b799bafe667b50176bb9c822f9ba27f81200d07be220c3ec2aa6c6d3b33b12fbeab754ec8bca41d17f2237676693a66dd8a6f280af9d2603479e7d73e6f35290c1bcaa1444a455b15784c136eecec73c43cf1c4923657177f02635cf72e7a41c8ee6efc71cf9b0a798612b53c3c0a094883f599aa0c5456a7600cd8962ae0beb22bc98f943a30b396adcbe3cae9db136119e422ffd24873b87e5ea2f0d513d6639466591f614d4d36bc7b68e7a42f645ec5004c6f5bfd3d91df2010fb85b35a23bc39f1ebf0626e2cede06b96bcf8613a181fc5d4ab6a71abf393dd5d7b94209fdadf9c001550f2a57c7f58194a0df7c7ec1f5d3639081a9858a53d1dceb8dce21568ef6dcb432951a564ed66c62ddf9e965c093c1a37d195bad37ad81d7c168244545fd3a0c21a09d1cea06eccea01b185bdc286e23b88196d3743c771034152df68cbb807593833205509a52abcb4ba34e5038254f3c6275cdfab2729a62f8b2168201354346607647841792b814d034de52bd9f74b32922b852a2b2fa91873d449ef55a696012873bc8a526a5af5b913db0f53fef97f4c842fa9e88a2b4ff8e8391e47cf6ca4d8017d71a26bb28f05d215b576fa6c36ffb3918fda0d03ad478b93df4a945f73e3e8f5c08c5ef804fe72e203d799cb4bca4e92ec4efc67aa69fa352b8a691203b5e79dcac7052d76a7d89fcab152b19458d13192867009dd230ab3278a55fa50b2f751c7becb1f288dbc2f0db8109dd7b4c0d02a2bd6a7af0c87c4952ca2e035a32454e2a5fa847cd76bef576cd0ccf220823fd901d0148d988c614a1cdcc40deff085c85467876dc93061b6623ca7ba2c162ef9e787a95ec58abdd3340be0344545d6660b35ca953792da4b098f02980dae6c190099e392dfb14081cd69e6acdddd68ea6400b215c44dce64c109d2ab4d12dfac1ef1c078a383695e3250bff6afab3550fed483736289028f4d7588d722fe4d522b4c2fbb4dc956ed7b5563baec29daa6f4a746bdcac1624f8b1dd6e040f1d52e593b76ad349960e277ee28b53ae77d3c33e19189845ab33404722282034a0b0f811237ccf02c62a9c01b08d60661f1b4517db5fcbfaff644d7ffd435f473c0ed4ed460047178902704433fef0472f35013164cabeae6a8a9a772dd9ebf45e3be74d1c4ae061373c9d9ef86905955dbfee2905155961fd9e74cd80194ca5ec7e6f7858f4d64bec157a0eeb1a2851a151b309dcfe66dc58bf1b146870262386cbb6fd2d9c7af2855edf21496620f7145e6400a0e7b2911849e661baf15d478bf297f537020ef1fe13acbdee66c2cfb448bab6af2beb067e7d7861286091540dbc2a1eda161b85bcda772fee374ecdad331cfb50fbc771ed4d09e064eca09061c47b131a5d3602a64f5981645ad7ecd4b2c6dbd883390cb181ad8adbcc5be83ca78caaf749bcdb25284bf952a039f661fa011018a74a3bf478a63b2fe11ba69dd7164b854a61999a69fbea85801f447977911dc1343af4ebebff567c61ee6ee05750d7dafe729784dd8a0a43af0fe78273a33c96ef53989724e0376fe3d7546d3f799a36237ca93cec068dba342d1b350692cb5a272b8f7f30bf6911debecdade13f0814687c76fd209ec59634f58c71104a1cc6a7bdf01c9e09b2cb473e7b2cd515a5273864b1b754bc749e35af466b840b0c21fad44e4735242ebc832729eee9d23196ca6e78dc08d4d656d8ee125ed985533f536e9a0b54d95433867372defb0b1a5e693cf0bc1c8d073c7df1e53f1004351832ef6474023d84e1f3d7159f55d95a1bd1c78dc1b1660aa63510eeb74ef127fdc4575ef19ae85ec65b1369ffb7eca0cfa95ce6fe8306190c43838a578f2d75fe73d1f9e47b012e3909c88d338e31b648c30e2a42d28e00d622e6b2184d7149ba2b89e587166e9ff082fff28f3826c0217553fd5db986cfe439845f4b93bb6cdf15432e5f76d1d47145f0a585105f9457fc970ad84a81f959b6b41565081e2f71ef636fbab52ed271b06459f7c6cd148f306d09cd010ea2e71ecb1121559cce5695626ed37f89d496df094f74818314c3e82f6cb755c261a38b48b0c28e4b457c604f10a9122ece411ede10f6bc008f00c3d2548709feeca5f87e48d9bcc8b502df7883b7d5f415c2e95ff22a1f3eae2d8a40cfe3e25e9293989793d60d132210b884da1a9d4ae8b5c4495e5ebe3e25a8ffaa0d0cb7ad499241b578ea07a88262266c0893055996cfd482031b38d022d7257124a6e6ac40fc7f663a652581ed52d96198c7caf3dff3e6661ac77ccc94d7398776089838352cf2a46cf25f1e886da3389ec8e4ae9f9d8e1b9ff494c6940246151661fcc0279abb5de01c57f044a54631ea801a5a972e3d671ae4846d639ae6f70db7dad849c99a3fbbea681bae08aae7f185a688df3a9acb37e64812a59f1cbb073d3bb453c28c837536130bbf92edfbe49970b5bc925387db06bd2a5617cf168136ea83975f494619737ee57527361df6443b335a39aa25324446cedee215efe4e80a2740da4bc885d2da08ac4b4743b410e4da192d05564c5a3e2b17fd56b723d512fb1746e42fdc1ba34770a32dadc516526619026b4eca00d7eaede71948e34d21cec3bec082908fac43d95b5c6a7e8129cf93f8d47d3cbffe63b2d50010c18fb38c6a93fe78700b670b9aa02ff9f2ff01e05bcac977d220748fe52f5e9c22eaa096bb5e3d1d895395e12fd368a9a9a4e4b1e4babfa06a8fba9ee9c54c6c280ef902b2d511a0feccd9f94144a0773c515ade77a6a371afe5bd0c48b9afe360732ce2893e991ac3e39dd2108c0f49acde0cd691dc7a98a1ec4f1b7108295962405067ec195c440fe13a6a533e3b55b8c326cb2b33b9ed3255d7e7e84715ef92946ea7b1cb127ea81fdf80164019325f23da328e6eb0340f8bcc786071d3452f9392966a0427804298c3f384975f9f4328f3a15afaec29dd02ef8404fa8b7e881044601fb43870406ff5a484b5e1616737b038d8dbf80c9fa75d0161e66fa4808ced26304a8bbc20fadb2d89f5328aacee133f62ebe2a09e2e1186e08d0b74ae7c9b6c036cc88e1b96ad4874ddb630b82876e7047c7ebb5fef02ca46817bad06fce473387fcac60c39acbf08908db9296555294b5695ec4c9a1173f885720b17a7ba49c95c1fff45396d7b1cab43c7b422c771d999efc5dcd1108fa701bd21617abb52f60d0cd7e23354b07d9f3b019cce447fb0e35c98c49cc09ed266ead0ed5ac18058a3b75513a0f4144f93e9b85b64457f37403bcc3d576732a53c304cf6074cf3b06edd6183809e64abda03563f8ed35eb060cddcee827b67481e953c3393618885f38cae4cfd51d074547e43e5c79d3f5bc9e1c5af50373c9f82667167486b490895cec4abc2eec29f0ca5f1473bf27e11e4d8fbe83801d3e96a85cc6d22b67c2a5044708de12dcf753918e1c1d98182c3a994f179a00b7e9f00a3210c76be419d97b6ea11dff59a905b93dafdb773785c494b13ad254c1b4464dd014bcb5890d9e7497d8f6e4a21bae8c77c14dd63a23499fd41373178759a3e565258f15366f0050053540e7fd8de0db4dd58e5a2a192511263e86e4e29ce9150d7cff201b834872935ec5648059ba009a9cd1985fcb0f7b01bd45ef36180ef86957a639e34810292fe100da44bda83e5e1e82c2e0d53b9b10a0b0d69bfbb4f5290f7e7bac14e0656a5e0d24f734b1e73913f3fcba36d51516b7a90108cef655b6fc21dcc902220ea1579b2f491770beadac41f309b6da9f042a396b03f2e7a9870dc747081d921da3eb97815da4684d6b491e0fb76764f32d34a7c8e57ddeaa92397fcfc63c1fc2792c481c1b82f0634756e294bb4bf0ee7ece6f55081a465a2c38f192d4ea5b4d415701cfc50f435d3b986ddec9d74fa39a78c90e9c77fe94d0286216d577831388ef806237d937e3c6bb310ba9f2686c38ce7a694d1933e02b60fd05b07207e1530d13213fe91c6dad44ec9bb30340d43bf4e27decc0d41927d90ee6886d93bbda2944f710b771bd271cadb0ea0f0cfd71e10fefb08520468d83ddc6c5e3974083c46126de3701d52a8bb9b64d470ec926978c872e4e99923e138ba521f8b3952dda05f9799636f2f7896092480117a188d0dec6853f617c7b5978f7455af974a8d7a2c35e134903b38998e24172033ddc3adf9edee33c2e390f80902b8825ae2a9fae0bba0a8e351967fa822c2df0413d35b80d78f0b7f21814fd8bcd389d8f576213b28016246e9c5af887fe6f1f51a1b44906585557f1b485f7b26a67b1aa9a660758056452accf51141cde5515da5bb05ceaab32576a1895faa7395b381ca11549e28b29e129310c7ddb03a28c38733f9320e861936ef8dafe8a0d0092802643ee0ff98b26e81d02bb53330bff1668ec6bd48b7a028d3d9ad1c2c7ce13c06cae7d8390c76c4f3b8543560cd2d37fb06d8982989d1e712f1dbb30382e5917db291a6191f4d6de460575379cdde6c8aedc6ca2ea630891b31ce2aceda4f3f6a57d6e0c1c292b3b3ea14c1eb7bf29df48891e76ba0da143a365fd082b122af743456e65ede4dd4adff05c9e1cbec512527ca1042adc7eb290844be230d7a693682519d142f9f3a7c8b269d7290aa001132b22aa9c1113345d083043d1f3f5116e70fec64d49a96b54df83e84fff59a034d85285cb98fb84a520d4ba8724e7576f52751cf54c4faa03d9be6729042dad0b7ee1bfb9839e6dc268c9e0cccd447690b104173404ef243a7b8fd908763de22f87fb5ff0b826ed01dcd87f519a4e46e6d2de391360d00511cc5bc4d810ed70010d87d0f6cef4bc4c135e29a5b767e41ede5bd8af9bc270068a9804e4e8bada9c4ac398fc03d75094290f481578f1790d1aa9873aba0d2e3d9e44cbfb9bf4f86cd2c8aa8a1c6362ace9ee5e0d0a14a13908313b40c54738255aa0135eb109562079bfaa95929faaef3c4358355fb95708c9d411dc6e50608a2a08400ee7f1c48ca52bad7b71d0ff36b9a016cf58f467331b0cb9a2bee872c3ef63e743c649e8e2ed0a993d800316e9661ebcd2ca887050d094f44de4a5e6e895ec3d99eed8cd9cac59fe21bf21acdf15cef7c85b817a9428778f7fc14bf4c24741faa4b6e3413bfce99d95413b6a626fa4f89b62e50c35accf88b4a104664c293b4da192eb8ecc10a6771bca88e2a1ffef1b1f6b6154bc90b5081258c4b5589801d8019b221efe6052a3461ff3f4c2848d928920653e897e7f09d8d96db801e07b0a7f583bdc75ce5f1162e7eaa5d64db10f6f426586a7c7afb2f916dc43f4110de71d856696bc2ef325e52e93da4f825b0825f721b47ed626a2868496377b097bf80adedd306aebb0a631ee36204b479d17d07aa29fb29b28771ed1def8e68ff22530aa94b63c31e98837bffb87fe56c7d1e9e1fbac70f61893bfd1a2440b56dbd49eea6b0b547916a548cef7c470177c7518c8fff293b719caa94095f10c36d7ca3f4655fa3ff21af9fe5a347477c7ccd445ebbcb7e9b63dec2a60c4b40449015c12a37966f1b9d34c6dccb21c5cf2deacdf731b3b0e46ad5e232689a6306d1e890f5ec74489758d6ea96f80c1c92fb12cc1deaaf08c9ff60eb704d4686605acf60b4a71dfead5a2c3a5d35c9d363d7fecf2b93c66f0ca40c95fed7d9f1934e9f3fae4a7d6b366d802d84e8b65a79a1a1069e9648e36465eefdd7d42e3b116794bc7e64a5757b97731478a588f0b08580883a3edef369b2df0b4192c7d31afcc3121f7188ee0340592d088ddce6f4925490b349c2a4e755c0748231958b49a4ee85141f4b4ff453fd3e8238be14f5fee850a753af574b4139b3e3d2d2424afffb947a3e5d36ed53343b7be89b44a06e7e69503cacb43a5b8643bf242e19604b926de7ba6552f7dcf12dab79f85eaf16d46a1fa55d71fd1f2b845a12287dc929c06b7532f665db848aaa889c9e65222e6d0873604a801dd1ef26a83d81a060cae19e482811343bafa2b397b96f3877455d1570327777fc0e69b6e5f0cfc743553f91debc703ccad8339f17ca9b756f03facdd0543f7ed58d4fade01bfc22d6bc581fe19a48deb2f7b36ee96b14660b73082e5528d68f9b78ced1d4586cb23d33620983a0b0ebdab3a361cacece5d3b140825906246eeca2831513c4a9a257109423ac6492994b0927b01bdbe27cac6fce7c9620414635a0f734b12b76f44600ee857010a1cf32c70cb65ea72df61ec893578d97b1b9eecc2e97af47dd26c49f2ce6922e1fde7d2793d4d3f9a391aa8ab74e059bfac63efbc00f6848e06bce3e425961a28d052865f59750fb5f0a28897f9f144c59a8faef1956b5f099b9b4bfa4d82f8b989a474aec1e241a6fa001fe87df531a6ee45aa502e2a05d113ad7c40fbabf4779a04dd9a521b1b8c911e1b08171aea257fc698e42130007da67baf4d8742a4c16504ae2f3c47c18ac64ae535185bb3a97c729939ab4b514e23da9d446175124e6f4b240127284888d4e3699ce119b98774ecb06f8d2c20f785c50b7c0311dd4079bd687b400b8d9c9ec0d3ca55e08b4a2d598e19af4589e4504fe9279f3a588d4b5cb5184e21506a29f3b7533b907ad1ceac2c9dc8f7df679d2d342ab64e09b518a4ab26ade7e992249bb39863c2e6b952562b2c6554a86f8698bfd82a8249d5a6b318b6206018f601c6389e7a138155399ee44280023dec8f6cf8bb6fd931a33ce17ea0fac6e3460431d189c5ef21796420bbc8c21a0b9651d935ad9c44ea22a988fcd3ca4627b8e34a1b3699cb2532a784eff5200a1e472d38d84765d1426aadb15a78f57f9a1a5ce60ab404e20d8b4aece5666f26ff902db0c18693bc109e7ac75fc765cacc248f4bcb8e6673913737d54f30f441582e2a7e6be3f554ab95065a9c52fc1301bd60fb197174191904246de74d506cf1d5b309a1f78ac44d31810ac043c1b03f28509d35f3e8d272c1265d42a90cce0f043b70dadc385b682690c73fe3a205be062864878c3d9ac8a14ca37a33538a962f0b864b159e8def4463ade832db2ca8b592cc457fb8c5a4e67e35e69bd50046eec8c73fda1793d4ed48627f9afa54d45af44f36395221976c7fecf01efad68e6dc24c8fed77aa7a413567f4e9367e219114677916d6018ef8883c4ec6d98f1b89dd0858254effca093048a99a0fef84e67b4c727551e0f210e3c9bbbbabeb79503dfb0bc15c74fe63d2ff3f81bd7f6cc8d94d580250d23cc44d35ac55546b45d99c644c3b37101097e183620b28e39e5a4a0d4ef086ff7409daaae73382e44ab780f4745cdc63fa40aedb8a5a5d766b44c0b087f4d16f9bda62fd1aa45933fb9b52e9c697ad425bed16a7552335dde4fcb39ea4d66b2ef25384459590a2b297b41ae4214114e0684e5f36f1971fbceea65c3cd27b8e23e83e065b3f92b4fdc1a76a9295736f18a34ce257fe310af44a09540d21c3808da5ddd2a1933b34c80dba951db3d0aaa47cedc280383ae18cde23404bcc08b650c2187ffe4bef3d919ecddc5aec295a1b7ab3a8a8215829e4841b337ff0ae338487f3e92e6bd7b8b821cc746023310e14a1643168a7d204071983f8a8932d5e3102ddd02f0f38b95a06c0e16182f0a301f50dfdd4461cefecc9fb38a5740363965273d8c2647c4139d55b0a12072ca243f5fa506b9e3901cc62ac3c87a50566336a06ee98a20fbe47f3f40c61798ec3a3c74f422ce1c405706e8af186bed69c8a60f68abfff58f113f7f7cd4f35ea05fc1cc16ee227d93d23175cc9f00b12055fdb1cd575318927fa11807d0f6f7140d73b348a3069d19ad146bb856ebdf9e4ec2ec99574adaa85a070546fa40836c40c13793b21f3fc905cbb5434dd320ae915e5b4a1de095e65c57bededb822ae41f2dd8a1eea7479078242bd3b50702ff478dbd119b7a6bae55fde975a4e88b39b8eb964ac0f18caee5095fde3da2ef8669deb587209450247b92ebdcdf1b0201948a0be232bf8a2a8eeea9b798c5b5ce79331d92b62cbd238c63e9adfbbf27781ae16c1ed499cad78e7374c646e98678c86bbf818adcbc566cff7f12abac9f397515cc4a2273215c14f7f615bfc0be157f4192c94ba5b4a86dd8cd5dbe822068d8705eb6836866a08f03493d1a1323b5f09cbf35f65806773240e50283aa836a85de3a5e8e381ca9036e2dec3bb0abfe647b3fd12af50b5d494575a89849c4a18c5bcaea246548f10ff77af00e4dfb9fb9c8e06b3e583fb3461a1f03abd731c51f163321d1f36925661ecf52d64038b898725103d04f711130ee668c1fa537bbc706f3e10a843640663fc415ae8184d5c8236e64596d829a6a590c418760efff1db996b1c9f5f0726daae2a188ac52390d98c2f4879ff6ad6b843c9febf9e2d3de5d5c145eaa49406d46fcbd834544c124c21a7ea92e89062154b41490e7d7d5f476d99d6b05fcf34e4caa569f922d424bbc56a899e1d7e369bdac4ec0aac17d7c81c4e60c09d5e0d2ed448efdd99e51cdcae13f9a4f17003062a2f5148304223ff75e7357e2a184f0928f26b2dfc2e894390aaf9252af7d85dea4bf14347c642c2c7defa5141db8ba5b60ac7238c514a64d625f1b0d874bbcb4e980adbde7a33872aa57c99da9f0866e2d8d84bed11b9da2dbef458ca82a45b8b6b0e112133a876e146bc35fc2e560d51bca6fb3017b5a54181d308f5e5959c995aab0b63a6184bb564ae978cabc9e0111abc8c3a56df4d64d18b52330d4317013156e4921d2f817d9b3d11f4429ef0ad25319c1b823d27f37ecec551a6a100a96d20f65b7f8f70e9d8eef9e08542cccbac2b212f60ee6961c7cdb1e6b9daa8a81fa4aeef923d3969ebe92eac04c167e16b3ccb145a66c9d95b7b2e1ffbeacf846eb54240597a67b72ddcf8ff867c7d42074e35e4daa6987ea4d5bd63ee689838f5b101999635fa7ddbc42ab7da416bc25051e6d5e2cad0c7c177da930e312a4c3400cbde29f1873736fae168c9237f2bec67cf10aaf2c93cb988212f62c9b9c68e3308d22bda76d3d189d1eaa5d613ce08aef5d73033fd018a5f65de840c9e4e927df66a4d2855e8354f6160f979d637badddbd154d7f3df32eeb49586fe46f6b1a474a47ca01c6482768864aa198fd538cfdb38acb538b6eb42230eceb8a685bdb0f826cc8dfdfe55dc609205b3c4abe62c34e345bc8da6cfcdcbdaaf8efae8f48ae664fd58373edd54972559e6282a24b67c4b8aae20b06f16ecb6a851024f457ddabba65cdfb7e2ffbc2fa7c58ec2208936bfe1cbf96f5607d87d41c149b99e75917ebef58256f6c81f72f366850b50eae7b52eea2cecba308ea3807d3a2a9a1f7adbfe2dbfecda5d2c7ecac9476485e8274393d70b026e1996fd43696c3d7698825231867dc82e82cb754f670241883fc0f9300c70521f6d2c47479ebd8e9fd4406211f1f3207f20bf4e0c19047429238336c9aad3f275f17d2cbe71e4230dd62f3b1688c2fe2e33da1be6dd288c4182d42f9d51db93a7f3da98b84e7f439443de66ccd52b44369fd5dd658c8fd8ea5d94d011d47903287854d8f654408f5d8d9e73281d374be2fe30671dce29e904e26959fc314c09ec6134296125fa7e3ee07233064541845922bed9f91751346ef63e75b2ccc5b61d83ee5a48b0a5abb965cb88ccbc1ad20407c89bab24f7f739c6aff14d781db37c0e66839c61778e2c52de80b48f5ffef1824ec93572dd4c1c2b03bfd9cf119ab8da45d4d441e8c23277f3713539bafc9492b080602a6c9e6270bb2466ff5a1bde8b83863d7f8ae3787735ecc69c473b680dc0168ca26a961da840df3a219f66e75f89054bd7b3f4519799288bfd05ca0a6443d5180e4d10dd9e6de0b2ce5c615b939b3b49478625ae45da05c002c6909530a49dc535696e9603c54a2ac198c60d2a129938f612e21da052c38a10f0fc8880227fbe9ea1c475ca4429a3a0d48a7961b4fa8043c548a57af7ee3fef161d6b3dcf1d31e4e2ba207c8bf1c37ebb439b2c906e4a9579c1cea37cfe16dc7a83f6e9026c094e86133e065b65e02750ec1527de0a4520e5d6a094ba18e27acd400e9245c810d3ad3110ffae9858f4cc615f55cd682b905c84826af0b7c65ff56ea448372c13ae42fc9b69687aeefc00da483c4746d476d734c6398335751cf70c60f7982dbc5d6216f5058f0421b08c4f0372f7ff1aca55c4589ddf73fcececa3f2477148043d32af88b9ed71ef116b137ad84d2596caf0384877bb82c882ee36aa0ce30642c93588ebbeb3f8772f6b5da633b7ee4fc9176dc8c6bf5db2287fdafaf1f0348d68de328611e8bd3eaa9b272e695bfd28266ccd4637d9f748b1395a54adeb80f1b52f2ee40fb3570f3cdf6c3e95d3d2bfe2f97f57c8b7fde399049cfecc46bb82ff411aacf70012b98cdaea9e96606afeaf1ca69d61390a64f9635f316953085b174bae77b647ee036d210b7f0331fefd4675e69e9b00e6560ce887a8455e812fdefb195d05a09b673487c496d12219f6dd66a1fcc64b284e34a88eb0dd072bc53341ed96538bce9af608f2fcabcd4a9cf6543b71dd710cb30fc6b76d622e79a4f280baa35878b3307078e6c59a4ad3ac333ec3c5c0585c7a5f91e4a09498254449e3d8d3ea06e383a7a6315ae3e982961f7149a431c442b478316f2417c15ab90a4ade6b8dac32c445abcc88d530df83e018d6ee60a18dc875ba689604be6c80c2b3d4fd13901731e244b3b2ddca6f1813130a857b117abfca8d3855e989dfbb2ce25fb3ba42aec82ae53e6c45c76071bb278a74c1133b13dcff83ccefcecf508cca66c5672d52be22cd7114bc64dae84399981deed2086399220e117fa4b8bc8c071dfcd0a230733fc5dda33aa0c0203b87c2755eeb974974af6ecfcc0c5a82acd37208674f7cccddc9d00663bbcf15378602ce367e15febc360bb08ccb84033e548ab572f66519dca05d09a898c10c1181409f9a7142f5dc45a606214d9ff0cbf74c98cbe9c8c342cba5431bccb1cd2190cb4d0d79d70bf4f76b04934b41fcea0ba11af465178fe2a29329820dd06a3cbe4f3efbdd70caccff9d02b6425dabd5625e1fa357419bbb7a00b96cd2849eb91137aa0443bee47814453337fca1e1652117ffa82d58386e8d12e2028602902f0a75934208c0311588f533d67ffe2dd0b89af928c547ce8008f5f73debe1cbbb41be0bb272d785488795ca065f45e8cabffea58b0c675d6ba340b89ddc347d56396e2aafc16f0e54a5c4705e6bd6bf5b32bbd4d0a9e4533c624274b24ba1bede1390cafa559745df3558f93df088c01ebb6c5b3ed640eaa4f9a9f6834e9cad4fce902e3ba49e36491730afd8a727d239b851bd695409d2fa0d54a5d1153171506c11dcbc8eadba5cc0b70dbb67be2cd39491974c10ddf695f047d1901bbd6d2812f9ff2dcdfb32e13925860cc6e160f236bb0a25eb49f31f3b44bf136f5439c4220047703b34e01d006701492179a72d5c8ce39a456494e6046ce74161826b936867fe12173e0bfb112f85ff702b2d0dcf661cde76bb93113c0a40d4f0df62a4ae29895402eaaef4f035753904c29dfc3ba30c8a87a75787d5a4ff26aba27555c359bc87163a2a5c99950e872c8295e8107cdb23621edf96d8e45167b7177d00f1b0f8c5f41f86432c6d50ad679a49114a0330e432a40124c7a11df02e23fa415a872871d11d5f43c7aaf157ad968f6ca9f80a6fb83b15f89b21988b9772085041ea515188d8ea34d0655a0c50637c7a05029c975580931f9c279df91e83283b5e27041b1f863bf79df010d3232dfe024c4442c5dd83be26df61a5f35e66ce322ad19922b930c0729f6d5e9006c77485d7b1e4d7aad9d8f3b5aad099eac3ff4ee6f35f567b4c36830e3de560a832bedfb6d8a0e42440080e1a342e0f196195aa87b43ae9ef1d45e745981648e20c25ceec51a2ec8bf309ef067ef637bc03cb784d17f61aa77c9e9c1ee4a3ba5ffb7c7a63aa88bcdfe76d7735429f8eca89ea0b9a817e39a0654ac9e05514e749cfc3cdb8e58c25b2c64f806d3b74c1116c3b29f516b147f9c69ac2f1c2d45d703b46e7c3bbfa7e24328508805b10cdd201c2d51120c970de7ccdc48f52cbb4a6cc67d46ff9411bdf38181463ec022b83ec7556b07345a802e9a3a869ee6ba5e3d9ce164bea2c90b0eb1855760097daf70b8f58e853b094cf11ec51b882631bd9a1a7441eef8c082b4582000781dc6aea5c253235282291e6fc5b0d3c942e17abd1fe75083453a1dbf7041b270cb44cd636b16e1dc622a23423ff8ebe20b0aaed8c0de19eb0c488221485697e42239942517f7f53610a1b191cda8c34384c7612ba115f6180951d74dee0b4d0a92823d62186f208926863f0b410804a31ffd1ca2783f82867093d1a20986ee2c9a6f68d122e034530f3a60e8dd9938a49e73700d7871a8f63327b81bf0deabebfa3533aadf85234f17b998e268c92b3bc5f02c3db8f0f2897254c36db6c904642b9c8f72b69e8e0e56a2572eeb80fd15ad40e954cf297451e3c46d28051f71d021b5a8d7f08bfea6c133632ea9efc9c08d1e0783a89a0e177f42c695c0db826152e8953f3ee941831052d40b192c6d4d1509c32da82c71121391d474dd6cceab133e1bc65a39385d0e54132e7149400b70ed2d7185535ea3a3adda33972d1207ca660cc69171580d6988af75caee1db5a1dc00a7753140d3d24481d73e298cb2b1da4897763714deb0a9664801c53e8be6a8e08b135fc9937c122317f03aa462f01c8f06792d3c4849e3bb64c11e0badbc4080ec4e6592adf4ec3236b8f3d88675d5570549490e73517aa15cbc9dda30f2286d59ce66b4db8657168fde6ecd21488f49b4f4414f4bb8d6290c8c76fda79036c3df1b80976dafece65bb169bf5947b56c9750ab440d0ede0374043068206df088c881d7b78f73c114a7892c4f7315f02c0f7970580e72f65ecd7bf2adb73bae90147da38637490e50d62f5413947d824139663be98878a0faf58c4f862a9a2f0f30c20051e5f65c4380192822b25929ef2fa009b9806b7429f97dea81fda00c842223f898845e800d87e0dcc9e4a50a3644159e2ed379be60fec1bf4d37920b5843d1f16b88560ee7c35176d74cb6e4cb0982c3b04755e18cd6cb5feedac1ad8b02fcc03c1bcda197573847ecbeb24d48754dc515e4ccc8c46f7c91bd3c7b285362ba0f2b76f218b2462678a257bfd3ea5fc2c1bfb21843b8e64a4aff3fccf3d99015091117b5381a8ff1c3b2ab585ed3899bc0ea13cdea4de9c2cd09303492101aab9c545a978caaa85e22c680b587b03877947c0f527b35d728c4cba9a3a75d48bca2f9fdbdf1a13bcfab341adb9591cb9e901cf965597465a56a461ab1551789dc461c6298ab019b628fdab76f05c1d2b7545fd11766c473466588efa46b828b6c8e212e086043dd3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
