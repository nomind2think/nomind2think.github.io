<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9321ba7c8554293cea0ceea93efbce1e928032abca5c73b2644e74df952f9262b3b5ccc35fb72ae95107576e2e2dfc5ba9422bb7f2ebccadf3b8cb4857ddd0430143042fd5f8183cb42adbae2734d7f5c5788f0beb401149211083044cc370b45608b765aee096b38bc4442d08ed973f89ba27abe192e0533776139bf3dd43b4cde9393af8a76cb0842740960311de9f65eedfdddfc30348ed813ccc8c8365b99658fa7c94d271b97701c4109bef02824c6452fee95639d4c5c74c12f0a0d67cc12858aa2ae07473a3ae75e438fc2b5aebd311faa1bd584ce9225876a71fd036416ec0de5e4595b154b18349b1f0f03abb48aa08416f84511112ee13434fcb1c8bc8dcd09d088c3863dcd15382e63aaa3406e632f7db7378cce9af6b97500f3208111c9fd2a55c5194fbdb7a12910207728b063368f8204fe50c3cb25818a04504ca30cc4814beb64602a90584bc6b2b97181ef39720895f00dd9fd2676f440d12755992290ff5ca953f6b1d56078627409b9cd40747272ad8dc4c87f03997d406d213118d3d2ee1418c5d3617124053578e93a99edb5cb756ebb1677003aa35050e77797a6550478dbc09e914164e1f79959e126221a967a8d12a7c20fb7824fa177257ae71ee0cc7060c9b21b67a20a0988e953c6fb1b908cc66976a2a71a97bee5fa6395680de2a23a798aaee8e7a722ccac8b433cf7c89b13350661361b3b97d5c17f8f9351dff931676718c48b0b28bea250596deb3aacd76e2cb9f3faa8db0bac651a41d14b7ac40afae12e4614243801bbdc4d4777d1d1e5c5a3663a09c045065f280d60af0d16a8bd68bb744ecefb80cb6be93678e183047b4caefb73c7027f771ff32ab80ff06f3b40dd22931a00092df0a245c256f3b1b43795fc6febd00ef23e465080175768237a6529e15fb1d0557bd8a16b5248f14a07e61798c583334d8903d077218e666924272273be46f06186d20aa5b6dcd6baac04d1ec1a6075accfd3148a107723ce1fa24a5793774e93f0167ebc2c35d7132c8f3f12c4c155855444b700c2ac34e0cc7f4702fc86cfaf189754c92b289f39ebec271ee4cb5b5219a9fbc4fa01a80b2bee9c0df17bdff53dc2f2bcfb83ea983de868d1765da885b239d027164702be3d8d7e36400379af78d0844de75119ac462a35979977678813b84dd567cf0fb913b8ef7bc9f3efa4c548d3fb6dd40cbe6a38699aa22d2084177b1ce2424193299f99dea838c29548d534ee07c077dcf89eb39c95cb73030b43ab468fdb885ee3748837b4216d11b236f9033dc810733440bae978e5feda50629e5aa4f79981851782a4bdd7595830235f0010404c392bcfa75ba5a293e3ded2c35c52a41571edaf5053257a062d13f1cfdbdee1d2aa0982b7631adc51cd0f2ccbdbbfbbc28523e0e35038e19a3c84ff8da90dddeeddd6b2ecbf0bce0ad67dc62a011f223a0b1c802ce99aaf172e4fcf6e652f488a4b4b39e2454823ff705070cb88fffe148c45f3ee7c0d711c1bcd00f459885eb210b73761b5099fb44faed97b8751d77ec1b86358f9be125aec8c7427060845fb6a4d03d4acd39df83af7627d6c4d16ecc30d76c39fb1a12f98326e41b8ceb85e4c939f42fe0f1bca13774225da28be7220ad34d72d7acc3c7ff0404eee89e4a5b571f963cf4a1ebd4b5de672653878503578fbd3b4d59cec7a1d78f2632d9f5a9b5ede1cfcd7654be3721a38de22afd7251feef1c53f966d86d86317bbb38aaf8bb4aa3b6f44ae1819bc86f08e7faa6408eb0ee1695f6795a777abdad6fa5a5f5992048cc4d709ac99dc19dde424a983397f53829050613973154dd72ee97870daec9b72f4fff8478e26a4f971f4605d2f0e375e481102121a7836c6965217a00c14d1e2aa7bb546fac82d7e1f4397faceb3827713e388d79ae90bef76a72d4a2094aeb5aa42e74a182679357dd7369e0b024ce2f198e794134436b53d5657faf930085158b22171f8955ca335db888c72651787a4babfe7f070dcdcf5f24c2a6e5b2f447f493d08d24348eecbe8b65343988b5aaf39ea1ebe1774471eef5fa5691f736712b848915d12673604d31da5de4fd7079f2e134e2dccfa84f205348177237eb3ac13ec0dc5df7c9befff4eb5f8cb3625e15b2177f818514168d7373243053dfaf45c81de1368c87ded11b65e0723476d783606ee9a221f0165f188e3cbaa22cc0ef79010c170862742949ca8b0cf31a2778ed48cdf9ccb8eb644e4db9be35ca9de06c279f236c64cc63795dd6b811809dc115d7602b7a8c0065c5176fc7fe95ca6e67fc8efe4d134a8ec048fdb67792c80bef45e0c112a62f65b7c955c769664b640e91957f00c127bc9a174d7a6bcdcabf3ffab998cb1d2d8248e1e2c6b2e4a70b3ad606ed53837b58479b67a899b47ea04fddbad8e79fe8ff81a08a12a110a0eab056a11ace3b286480efebdf29a398ebe96511c943cab2ae6335015812cad86b1ef9c8751bef94ea6abf48664be35bb7d4a041c01b437b0e9fa352beab3dd68335139f82fde382ff74c8374fd2d8f83bff759d3c9fbc68742b87ce14b79c93242c6a5d83a85e422469efa6d2aca5a22a24e1411c1476afbe57be6c28e90aecf66eaedc3fa035c792b03c1686ebe790cb92ec82b3df3c3b6cba24a89ba13db5186c235534860795445b285e3c093a67b7c3cd2949e0d0e69c010b77d05fe015aa754016d2f3a88cd288115e19e4829291b30192e154e3dd0401c88148bb2133561572fe8a9b4ad858b50750c81be55936de1ea6ef83dc529282e8d3db538cf7fa78f72582953d806d1ecd504fa92001accda1e93966169b8524c1087b750e237767cc6e2bf2f9878bc12f09f43c9457531b843a255925cf77a78e9d9c8f3316a58bdd66c9383279caffb32577cf404b56d8799aee3a416b88b1cba46176bd859b1b7b592d5a49d43224d4c69063103ea7009e8bf75eec7beb23633da76e947a3ceda31afa623484c9bba99566845860caf661f7203e671a9b7e21371e25fa25e0dd7afb59279bb7e0ae837dcd0fc9ef94aed9f7ace6924b7bca3780fce506490681f3532f520ce463df96009efa47a34a481a42c3706e74d8b33934615e71238f26dd97791dbcd8bf6ca5ead92c4d3f3c350ddfc91bc449dba10f3ff9f5d154392668adbd7319d9d521c1c2963c38e25fd95ffe8cb88d838204e0da4662ad23a1d560a7fd2d9cbff1bfca2af8c03dda1861951b0880cfeb1842189e0ec840f2229169e330e73006c197773e2a138a1f12ac409e1ce82032f3c77e8070b5595660b63603e4eb0a10112f0ddb02b367b3ecae90ce0d8fce0f4d856a6bf38125b38268dda1bf628d33d512a8872dea3e321e9783209c78bc16f8cca2e275da058993c3ea702cebaf826205e157c9590ee2aa5c8c5fc750c672f158abde93a74ded491181323e6e48cb83e98b7968a762324db20d28ea9aaa370849bf33e296a97ef85e80f9c95965c7e931d303557141e345a53e3b79a1e211cab64d9cf189859de395ac1a962c61b6aa4a1ebb3b0b0012a8ab9ff29e28a7078099401c5736e22e5d5418b538c5c3670d8a9c592b93d0534f750862f7fb91c37af381c7f2cf3cd0bd4e22d74cd3f852c44c6d66025d833b6d1e8b46cd4529f06e09027a4555dc281614a4ad20fc3f9e6b31954133952ce48ce32f50c8b740ae0e1725cc81b759366837306738396d16a315e164bb7a56aed537cffff748ba3650c651f72850e9800df97999bc719376c5d7d6c58dabd61b57466a8ae6f72ff45c641185cbfec6ac5d61c855ce68142b2720b5c18d4f0a4aa3969dc1a11aba7ad8d862144a8c970bbd4e67a3afb3cf129b5a1108e4a3de387588a49210e18806d783feea16e7263b5899d489dfc04b31d2a5123327d16d83dd64686e8b563fdfcd2fd235525e15760d37627b583319f87d4bcbaa115a5c7e6a48fa20367bdc7dc61de8fd52cb79997f9dc9ae66695f0796054d98402675391822a5768a520e798009fee622f2dbf28b755220698f37f8d574bde5b70f3d460f3cc81c02adb18f85755fc7a0b7752fdbb9ff46b75902f2ea0d409911407fd5e273d18c500581231983ebb3f6c08b2044bc8e8ce3d475862c49a35cb5c2c923c9b04e118fb5d4da9ec5bc19d93c6efbc7a975a203f9800fd40af4ec862db1f42b20a84497422bc7107c9684470df1ff0bdd12a9f1b7ba0cad683fc40960d9d70c6d2285785e80da0071c7295853f43ba1625fa0b5b2a1cc2d83ecedae644e1e2310cebc9e85eb7fc592382b8d35b589ded502e83245298bbba62d6738956d1ae78c0968617a9eced55f0f2f9d6fe4f160cd82409302d5422f832355a5fb31ad4401c416f7e1df31c612819e878f87f05e1018941af72a718588cacd0ddbf4e687a346a3fe9112796060d4439baf3630914652b303b66dae0abab2f4680f16c556fb71f46b2f426f6328197e6fa10b74dbadce2c960bcb8bd90c671beaa56e278424037306b6e341ef38c23354cacc2edd9b163a2811e23df38cb3680ffec1142678ad78d804d6a930f69bb5ac8cf6645cf382acc506d8087892c7e79a084f5da371e86b79f6882abb51b633a9a1d1a74043392d01397499e83d7edaf846dc6988b182013fac0ebdca2a4e5e0ae570090a5dc6d9c01a5a9cd9f3b13472ce19ad12c16a57a4e62835ccb56cf3c24c9ce0322fb7938e8c477e18fe3906860e47238006a98046400b08a3c3034b44b270663c400f745cb4b75f0cb146811132c0867e3dc5f4fff69a907b0bf9c84c25f0076ab7bec918d630ce50b9e7feb77e3a07ed592eabdb6b6d945db6015672ccd442da443004840b4a9fccc039d46993935ca04ed747927c637ee3f58e6e6a43b1d76295a6d740e87bda1219638824a62f6e738e045f3a1ec45f35cca5d4b40904f92d83f712423ceb28a7ad41064b5bbbef047c97c3a04ec589cb28c175b870caddb6f366269bd51abf6237d0152460974194edfeced0662c28ae0f61ff69a94816f2d20cf2e85980277388380c087c30225f0c09c8a2474e1d82251be7e37a7887ba8cae982c952dc45313c457709a6f17601cbee5718fd88b6b60d1cce732361edc602a8839da20db6e80f01106f0459290da9b5c49773b18400d25abcb883c56c44130859dea7f8a387b5a35fa8afdafcfbde127874eba6312419d7b2a11727cefcf9ce527df94bf8f484169ff6dde66b47bc406af3dcc0426ac8177f6a574a93b92d1679a38cc4e7bdcda1cf628730e3efb6c9de9f45538ff7a56322d919b1cdfa127a582b9ad25738b05fb304654cb6e3872695aa61725d476f6f3ceeadfa602e9c0f2bce824abfb2af8df1becf73b40e723196ae4c69f363ae6cef940fb3fdcb6842b8a6c014b05147bde0b2c08b6e2194a73d99d4c9af1337d817536f8c5bde458cc6fd07a81084538799fb093c0da5a689bc63d2dcdf7d03bde786a5d88568e4005d1a362b0e344cb683704a8d7bf52b8bf8d3c5f2c1f182d8d6090d900cbef8af4158085788379552b91e7dccc0628345e4afa9f267d635451135369b9472d65cdd7b336cea03cc51d4b0b31e8930a02951957e3c0a0e8afcfc47f1448b4b71aa6d4db19f35e898b2924330a84bcc750d6e9dd7aa5964f0228920701a2c49d2bb737c87c17b3d40dff295aafc5f8280baf8d852c45a52397f61508f7fdd548c6f8cacffec75d0c46f19ff39834c27cf239f43e282f0bd1d88b99df72502d9d9930ccb2ece5bb0808860a80f4d7775a089252b2e946459a76b523a4016635feb49ec0b406e3d970c26e6da37b30940980e2b8106207859756350386997be8cb5c770360f7cec3b47e02e8569908d177630315622af017dfab982ca6760fdad422536d7be4c9387c5d93a29d0a602ae07dbdf97cebe3012cc467e7713f4255360f7b8cd40ff83464e0dda723b5a5323cd30ce6c12a9422cac9f23b3b736f9e8e1ee0a120dfa7fa11a5d0b562237f38a10223c2692d608a5242b8ae234be7db8e8422d1c5e0931aee07e8e39c0975af0a36fd3731fbc044267a1ad6217011f91a7e32308a315f8b1a30269944f44619541dba05acc4607ee9e2082d05a95da1a2fd6edd919085948134401a447a887bc811b3adec1e950d1e0863610ec96713bdf7a48d5d0ea356b465e09993b55b1527d22114cbaf9b064cc955fa215321b06c0aad365d8dd468267b10dc2a9c864dc3eea012af3b34bcf929b63212ab98a0d3d7c1a40203e590024ef1078991b609044f853e09b999e30f95ba41ba1c7e59260a6d846ae15c700022823d194cce850d6b41f1931dda99f2341792d567f8a6e92f8d775bff93fd60987c7be79e9d5baea917e9a6cfac0ee38b66d1edd3d45b0f96da0a1e39aed6cd5decf52ed1d7eb848c9358ba73bf074b52f03afa0164e95a3cd68d9518a314d11eb8d6f8169485b2732d8bb7b6343d6614950cf3d42e3b7ed25f4d8f3a1f4db2623db8873d7698457d07982ea5e23a2a6754bd70b78259baaad31925e98daa9787ae141807cc25500b4f8a970a9ab2bd4d43db7b1632a9dd1302431c65bf6bf08f343c86f9d1beb9aae8e790390d9a70e2ba0f51441e8bb65cdb60cda5c49310348e47715e5f08365cff71348e3c424e282541b4dbb4163bc335bb8cdc21897230e9cf08fb38b6b48f0e2993b125a0935397b0a15e2e62d7308be0f3ccc5c88816d25c660736aed17de1c352c2f8aacd46a13173cb2c0e456357c283ad1131e9a8fabfebf45b9802a4b26ffa237fbee88a7881cfc52db3cff83a1d916d1c7b31ca10cadaaf7add0ac9c6b565190963ac21e599db8cbc5952eba2af54627cc67df538c6709cc73786801c48c72f2f11bd0954daa50964f54b00c9cbae94ab5dffbd36d2b1fab1d1e871266b42405000f3c147d222404e37ed17e6c202692017ed132cbee3e3a0385ce47564c3d99f1c127ca1c6fea9eee30374750f8a1be8b5bf8b73b8e5e206afdd8888a50d18b45765779b753af91f75ebb35b9927f4a4a6b2d21423c7b1fef4e8564b47fc28680508ab20f9fcc7903139f9f213474e8a3dbed0705e29c4e0f4d2d491c3c80fe9240a924c517583201fe9a73f9aa9d730c52db538776e0fd4b7e9bc63bf96b8d5bf79fcbfc72dedac535a3f8abfdc9343b0e2f4e4ca2de4bcbed11b6d887d094f4d50ab3fe3286d8e40b69d5a6f0893c5c50e420c93f4992044c1cdd22a698e77ad96f2b2c345e29d02ce681922c7add0941401d11a7be285f52fb905383945d4ac46c9b9925c02bfac9e63a2245c5b74e25c44cf5989f54c51cde4c60f97b79c26016dc7b8cbe3004fa1cb9aae1ce1b36af766c73ca0f023872fa75a263794f4c20f1a003fcda62d1b1c64c77ff04f7e4ae3a16764d0690061eabf4b8b0642809e645f553171a412817409b46b80fa5382e7f81c305cef90d8769df103b046b0dbb0f290e7e9a73a0c8a51936080f897320ba693c66e74da49a0e0b51f260e5275bd3849791dd63241125864a5358c9348230fdafab19702e9b31e7716182fdfedc0fe2726c19d9b22bd5733359c0ad8d54792ba32bbd3bf34ba957f513e915be5f40ad0cc68db08a6a0732e14f3094c2ad070b1774789b025ab5ae14c7d2c1226b9207caa3438d5bc1d3f39ffaa9d72129258f0da2539e6bb0a3b4858107e45a967c993e0c500e57d5acf37d0516f6d5791a2ca6e0573ec89d520c514c973b91393067523b6ff8ede69be59740e6230571d9bbf762d3fa8bc14979e1256d3bdf7af84f6de639e93648acdb88de17923a5515f86ce49ce0e1f1a9a622e197856f2be554405bffbc1465a1135ce2a0cc8aad5cb6441df6dcfcfa747ea2d5ee9b82ab279ad1d2f590f9ff94819e8cb1ded84d61049161476353a8cd2322b7281b588fb828e5fc9b3d63c8337db122753eb6ee3a598134e3126c558c7adcbbd34b85e69cac4223d85596f69bef78d1babe890d18524d5a8fa54f7da70caafd944f8f3037ef5de356a855b802b64ab4a05954ede6e3a72d9582410c6db515d7e87bd65de3fcc47a245effcb87427316166c9c2e6035c7af5a5bb0ae82f4d1941fab24eeebe47a3bfb9abcf76c7042fdbe48d1f69cae8e568f5696ffc441da9a4c7906666f56edfe4b10b696313a1dc476e348288b35d6f875225092ca107c817a1fb523b517f6d8446274f7d0ddcbdb010edd6af04e982b5c80f04fe3ab6ae752b7a2b5be6b10e472743ed6378a15ac30172f0121711d339bf94ac87a294078074062459f84b4cfa8fab1718a9e079f1d26ee448b7cee8f57635779dbb5adb74b777c595bd7a2e866176d0ad0a08a1948d75ccad86d38da1f73954965a21c6060d6b5515867662aa29a7776ffdbfccd568d0ff395f1999a716ef553c635a437e84660b0e0b3d04941adc33a4327425f69ffedf2138636b53dca7051161369d1c882448ed80c711343bf9c073def61744058339e1302b2a00c9d888d8409ec50f03a1ef3ed37c8058d6c5d5481db419201f0e7ddf8336592fd698634bd11d54cd3f56bb34b7e53fdc97905acb40dc14d4d5ac9c620043a37c0ee710f4766cbc309363649f538bcc7827ad9ed7ced91c92bf2d4ffa91d35f3b3f71bca65e27eb49a42e7588948d594e98e31564520ecf74e9561733ff25851a912405bca4010ec4ab71a7c3be5844162762cfba6a3ea7b60e82aff0ac6bd2427c61eaf37b840c8418900520a466e69c5688c7b8c4e22d9a19223c92b376d5c4c0eb65d2556f44923a2c36faae41df6875c61873a93439c6b9aedff9d4f1b95a405ecf8cadd356bb51473b8ca6658b55829b24fb3466c01c63e5815967a1b0f71c5ff902362f4fd48182907ede9901bcaecccf70ab75b6bcdccedc1d5ee4a6b107d0390a0e39096fd175c525cfea41c59056df3d88bff4afc298a1ff1b62e653cc0a18848c8aa3846c4b69420805da1d9ccee166454bfd66228d6d06d216f4a132ea3333155ed0ff3b4cee4e7b214c0c56aaefce43dcec80356f5ea382ed69c6c2cdcc0b4cf67d1f935f7d8d7791fc35bc783b1f4e55858dbea22910fa96db7566ed86aa18facc82ad4064354bd484dae8ae506de29fb8f2e5b0812876eed1cff26a7141b85e29d16d293240c2771665493db7d18271a5fcdbbb1737f10aedb3304be0","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
