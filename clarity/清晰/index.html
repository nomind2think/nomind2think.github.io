<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7843156d03b0b0edb69a87ec3f66d8d79492a0bb7173a7ed862d3984a230949fca97f1774520188f13fce569229868d89e71ad41adeca3f0b0a92e6bc45240bf2cbd53be1b945db73939c35fc61317d3499ccbe2b3446f2dd151293aee277b98aedbca0b41f66fadf42e78c726e75eda430d2d0650e33a551b4ab0065a7dd6a3023534adc281bb8868169f64b2d711df4e2213e71c6d42130a03aee158e3692d5aae90ca02b7f752b38c94414f208de4e5e7b5ce0cdfc59aa8c8daf2e2de570868182754ec3151124368374442cd0961b4c1a948d02c724ffa4973359c26767d96da695750c7ff3d038f998a3adf239d2b976c2468af7e1317ade65e58f101d2999d54b63d0e489dd756de21988b5c12a7d17883fa81999e659fc4637765619ae366f63d64682e39cd05db3a7a7f744aee4e6f0295c295005ef37247f32fc9e97732afc1cb9fbded93355a49c5868084cf0a941790c941342e5e1e63c23e2f84fd7898ce8851bdd0bdf442eb44682d1243484c72c491d78905aa4593dc057167dfcaa5447d0e0ca392f4430e3c3adf7314afefdc3d389e92934256a91459b1fec86abf2b03a19d65af8179655a2ecb534cfb62a13e3601c151ba68dcc198f88871be168b20c75c59d9bba51f3b984cce7982352b0959c601b0c170120ce42db2f15da329b17dfed943d180628bb74bd65e184a89bfb941b405573298720483c98e8215589a0356f4dcbf9f34294a53db03d7d0f54b44674d7a12a87a2abbad3f3b24f0e525d29ac03636dc514e1733aac3259a6049c505b1bb261c0c6c4c4bad0806e43c992bf79d9bd09948d053ee8d9147282e613175cb65605fcc64d80a6150f6198a6e1b0a4a6a58ab1939b0a636b5406f58c8616f4e299740128280c51715c052e8b2eb207303e9ddae6c06f91d63342b3b238267f74e7e084fa3d42df84b9a21f7a9edddda8d06ac12b6722087e121fda1c5fa94e7f813aa7d9e79583a2dc186c49bd9fbaf61ca4b372ec2a14b0454d0420fab03f94701e2a8535c421474a33241ad27af5e7cd8ad477ac63889ddcb076b23a26b3e589f3a49d10317ed0297c5fab07ba2ff05486583c92d4211bda08d64d110f3b5f04d889b1d7a065a027b18e06f3cd398ddb2371f81cb96ab4918b0775c75d95cef25e7199eced3fbbaed0ca76235aebeb8331c74d65a67e4c179e5175e6d5a770854134b18a18b22b043bba326ef953d51982e520640774142f611195771e594e5b7b2d3801e904874d3d75c1b42313eda383b87f91c50ec8a754719b93b02f7fc1d46c136ed4b64891c102178ea7072d09447a868c61cddeabe07f30e77c426b218c3fc2e71c91df2c4d04b1043d81605056693b1987bd9a7107a18164ddc5adca6dc21ba9d9f8888a0f650d0e18941e8051507689f6ced82d52e8ca148cfd8d48d722913922140d26e0c140e6106b4824ddcce58975e65e4c6fa969ef49cbaa05b6fafde5666612c193a7807647cf2ba712970410b3baca532a3f1a523e6dc0b71d01faf04c11292cfdcc235299764c889f17043c22d89c002c8f252dba00e60d33fe572f9894d3c8c6948b7a1eee68e2d39c1275c93089b9236f6568dc09f4a6210ba616e3856e4fd8e6afad75a40ad8ec8e0e5fcb68575050850622c338234d291e690130db45459286470a04be05812ddf3471a1f63e1d5626ae02d0ab4b1e914d2ec15e46bf2cc0994b856d0f55f24163ba5f7b4352882db5a06441c8f9bd82f9afd958eb8febd1ebabf13c40ef9e1ba867ed1b0a35d6a0603b2dd31266ffc1d1affe5239b3ac1709a0af9f02e5931d8c080af230f137588f7b41aa29ca084953f63fde0ba627e39f389050d569173aa5a632176ecf9800e7dfcd88655b33fb9fed4ae97422b77fbf520f8655a3ea2110eb75ce9f9bc539f45b6f27972005eb46f99235e07684eb48835367e69d70d1d772c43d754b1609549b06527950f5cdfd85c9c9cf38fe2e551e958232d403457d9f492e7c7688d0aea4082c393e43034fb860fa10b62514486fbfcf45aaf428705b08d5b2b8d537b24884e731bf3c85f3e1a675cafad68544e3eb405d6a327b591c7bc3acf983994c456a783dbaf2f43f1e1b2b760a6c19c203fcc00eb98368413af39539acc144c87bc83e66e544d58ec60fdff2c3b8e8af088d627dca689bebeedbbd48fd132a722a123b0d3d7fae8153f46f5bdad11c4c5a6d99b7992c3ca3726290255a242adda10472fbe446a9b3a4b98b2d3199e9dc83fa583c285a4647a07cb47d2c374b0b6f2643313e2dd5c0cda14f6ba574a2c7f32d13b901c915556bf99727ac637f4aaf064849970c5da729433823b7e2cf8b711f9c970c3c4deea45beb0de02fa7604b388697bf27bd2b14af9977f120edcd254be130a21db626ea1c5d62bb6b2800171d6265908f5f022b5bd4bf52d85daa4c00a0e2ec4a7e2ee64e3800b9d89ddfeae4777adafbecdb328143d350c8a52259be22e20bb90e8ab5d9fadab4896f2221bdd8d8b4a4b64d8e321dbe2413568e039af945bea511c41048c222e0e165fea0cd1fff5a319a79fa8327a5d9f2786ae84d5300c2f463aec3766d391463854cb6a08b6870b679747337bf9061e11d9f140e793b6658b39cdb56cb27f414a343ff8c06c100356706ba4b5bdba4441530290ffd92d83537519a0ae9331d45f7b5e08f6db5910100b217887a3cf1713ad4e5d5cdff2f1f0b5655ab6b9bd70d465ca443f8690a2fcb6fe86df34a438a292a89b2281921cebc5c9c7029ed184344a5b2c124c42a854709406e8adca525839362b94a4996f851bf7e0ba94cd5acf45bd939a08fc11dd994c667e63e01f165043a957155bbcb5920d81fe5d0f61f06f48a832e0589559abdf35b5cb44b0273ce811299c56b2a08ddff4c22ec7d7a7390787995d54a67e84e701ef9450688107b4d83d6b1e97abe024cb674457041585d28045ceaa2c3ae723f1adefda93869ff0ecb23974cb2ea2ff944875b7805e0465a025f929421f5da11aa20d571656e0b6aa84c7ed7d8de3011853a9b55cce58f166b6518500e1b7951e5ba34a6ff7b1e089f0ef81c4ff373185ac06861b9abb87969cefc7997ea081cf2aeece3d4431bcec0e26d31bbcdeb683c07ae3a83c976985c8fbe67fe4b76d2bf8c1e0976f2a32124a2922066186fe5cb79b734ef3596b4e1f7449e786728debd27ddcf2a135a1217f14b391939804a63a8b1388618dc3dad140fbbf7cc324269e15ab17a8148f1ded11c15d288ce384e0b1414817e00d66ebc2d3b13417b810e443d3ae3fd064ba0a1a5ecb2d88e5645bd802d84f553f8698c2808a71a853ae1cd35648bff9488343916bec1430dce7a2564879b59dbcc7bc5a246b5335e4d83b5053d23bfc323908c4cdba79d8182cc1b9ba72b8195448f24ecee62f330b1d2a3ad91d582af719ffecc9c220897067672bdf514e65c74e827eca66b3889203fc19459f510bc55e1b2f5a27e91b2ecfb2731f44aa7d06940ffffe0185ea46c51f475feda00e6305f3389a573bc42ac4e03eac1e35b3949b4b71793a8c932c22b0c6a49b8caeb60c8214122ac92881a90227b32dfe65c05c285f5a15776d28fd1945a3deb1219e58bd0375799bab0948631c49eb5e1a0a6a6485b498aa7ce1ac961a18699180007c50cb23230e7926fdc559c9333d861e2dd66ac5551bf5ae7bd1f0ca040f42557a002a3190d1fe99b7a37f5fa38a19271aaba13beed4692393ac46ef0a8f4fb35b04e529aeb199679ca5262718e9d3bfff2782287d97dc487d1815928dad66ff3fbc8cdaeed1f563f61d724eeb5071ba394010062cf21d6cfbbacd15543baa1d3d01476a9c5a8bda90cec412898aa3e00280beccb560b568f279e20d1483902e02cc0c60d0ce16d98173dca18c9ee7a5a669b0f9c306b9b94623c44af10974614ee753a1cedb281c1b68e19524e8f7621b887b7bdfcfb572d60b108f017603b29f6abc332e2d46b6dd8abf832a1e028be64149ecaa36b370b7039e3e68cf01baae368e48b356c0d20e43737305d13d7f56cdc0c81b6a9214ae5334981968791d3e87db7d74139e1baee4158fc2009e388fdb1ac8b421afd16e6b015a51ce894b6e3980309a280abc808e12a25ceb3e2458d3910095d6da31f79712b73e86ee77787096e06bc679a366320a39c90b69cf50e5a77ffd1d5b07cbf383e23a61230588e2e22d06b062703df7ba6ac6a445c13b9dddd6f14a455639396d17db2320f60f548c8b2ea5b26abd6c7fe4191e8610da8a0a2bb45dd0bd946d39259133a44095d5e04b13762aee06a8c83f5982ad7b05ce9ee7c8d2d86e29c501cc120883735dcb8f5a3f9612dcd86eadb5eddc9cb361872c8268c0d41fcc51486dfe57028d12bb3166ccdc603d2e903d66fcfc7a9a3757b1bf20f8fce439485be648f0ebf74352b72eff6bfa23b37750a633fe8b5abc33a19dd28ff2dbafae1168ab01f640af594d2b305edafe8d40e4265c7de511ed5cc0bcf9e167cdc78f0bb86a71e5be7bbf8f440363600dd41910335b216e7dfbd67389b88fd2626f101fb5d90c9ceef90c4940379508c0defe66cdf7a27342c4873f7de8cabc38313a553c367f4d8f6c154dc9e2d98ed8a5f19c253fbfa209f03fee98f344983e4c16a33be56be7029d281a6de1d5e73fa39fdb9c6fa894d105ee21188790ef7c42054361e791de2ad5e5df9f27c3cdb9a46ff27dd0dfc3c7377fffaeeed0e47e50adbb7a2338bb453c64c2c221df51a9ca43a251e0b476733407fcb9806bc242bd13506d4ea52653d093f1e28a6b280db514c7cfc8cbd3af7e28237f14f81dbc43bf0247f62dae74eb85b7fae3344bb2a0c8933c1b70153b82770d20a6123dd824ae66fff5669aad3d4479377149ff1f37fe1b15779bf5dec566ad1bf6aa7507fe7a8b24d7b543b8f377d84ac3abbb8ec09672a1323c40cc851bf6ab91fa3237ae1d07549bdc0506bbd09641b3d03839f6439c478f09058037fc104aa43122798b35c78d90c457682bd337c1e332b57bd1c66de8e411732a36afd36e9f937c573991d515e99f4c1c79a473f6d7e66aad500b2d413d63d0b9c64081a44b537d648ce274af3e442f7e574db11888556425bdafa7278db72bb30b6bab1ca54575d4db6f5b1dd2cc1854f5807bcac63132a052f311ffafba896d58e530bdb7cd47287abf4c13a1cafe67e4d35f43388e9fb5183a110724daec86c5460105f2e76f8e7724f87c0231c06b8c35fb449ffc666049e4928b143a0ea2e357cba3c36bc58e08e8c873abe4fbc5fb4503631a1521ae1e8718ae2e5f8f8150b32cf7b07462a27dbd725c0013a48a6eb5712c65ad288894e344f2e3c774d31633ab558b37eaa1e34f2b0421c6dfbf276ccb1471db104a02aaa422c932f2247dac801ee33d31559b33c08b396f8feccaa572e494b333ffb64fb51265e3ce1b11945fff6350f8d87f3bcbae9952f8116527bbd618cde1fe34a8fbd84a0c3c35068b3a9d783686f4859af6252fc2f3e604da984428ed0eaf5f30fe971fe66abb46f0b9813ee81b8f3bb628c24f508b16a5a8af7bdc402f9c2b695ed2175067bc50441afe9c268d2cd0a5c72459001e0fb9f229d388728a8bfbc65d172b65ce89b94038bb1cf9bc5ee49ec372abdc977a4b6b672260e3c0c9442d89680086fb66ec752ed45d086a0e081ce61c9e25eaf484376417891a61edb3d2795a073809e940f422ccb8d81bd768fc6a753812a327e963179ffebd912b2f666d7c86113db2d5203401ea937d4ecbc5f06fe4a3202ec9dde87607c4efa698e0b0dd3cec56f85ae04537978b783419427fbb36613ee5a81efd03c8a472f3f04dc48f7892a118a230ce505677b3c441e39c3b83eac49380963ab9a6ee6d5d94e331ecc522d2cd093ec1ed3c0115234999c25474cc42d3e4ac27635292b7e5e674bc15fcec1718bbd9cf485b8b9764534fa011c4cac398c5abafcdd7ba675b4c4c8ec4f5fa67b44fe94cd1f28219c6b3d65969fba00fde727225d6d99de39174ee92afc2478c68059103a78e3b09d63abf1c7462405bd787b95e88e873f71650caa23a2663ae21ad9374585caeecfa95e345d9eeacd3aba70aa85de6cc1855f1842951f5edb57e1d83f3e60e063dd55c791a1a12d566f0057b1003b871fb5f74ed39da0a7c8aa774768779ba26b8bf3ae6aedd0be7cb5db8df6b65ccb15098d329e764f1eccd80b7d9f48a519b8c844279659e3b75af67f128462ef75b5ba02973a67407f61fb4ddbd8ee84c63146be78accf7cc3b455c411b5c67d82002c38d7098a70c127b8e782bdfe5995af1f6f01c2d6cf52b3c3832b0351572b9afeff72d32e4d4495f848897e45dc2314a1cfd9bcb06f4d455e0be8bafa08c01f441be772664fdfa97977105ca7c6e860d6ad9accc1e0d93e2cc579bfe2ab080a0032a448f2e3cb1c11ee0a759055ad244c06145ce9dfd781a6ec940c42b7dc0783b5e0b6b2f5e2d7d83c6d9778e8093cc33d99fad8e5a60558f9a9d0ec9d28ec9e9843e4665f5caf90cd58c567e5e95368cc82931ff0541d5b53ac18e5af810600acbc82cd9a0c4b5de972e817bc71e9f21fb6e5f8d5278854fb736b6149638dd32c9abc7fa6e2b9bb78bc418a7247b9b1c7388d61fae092c63163e5d473549599a8d23ff50f4dab88db424e859bcdd24272cf8b343781535473094f7246e96d6efd7ad3edde158bcddc76d57c00ff5d74646285a0865d137afc7d390c6071dc22d0ed8952d6dd98ec21c44cf0fe49687a944be93da9ec849061701ba6790b0f70b008d4e8ef620b7cd3bc948fb654a47da799008d57e047fa35d496d21c81b38911a9c914627f477a19461ed601eca16aeb14870740587653a8a092b0217a4e7d4ea39c71eed9ac17ec4b1306702c93b74d543d8e27dc301036cc85f46c2886ec2ea91ee0023f1287bbb8be48a1d2725a45171cb3c2c6d1166c6646d22f1ec752beb6bfb4412b4d984ef8f7b4c9198b34de605c63546ee1fc41c6f4c497facce4f49d7ffd675394141d8a16792698bd125bd0a5350460d8e08fad4bfc7428a8d1e6558b7b7ae3a8525bcdbcbf8eebee325d473ef5ba053e07c3ea5e896de69498304be5d570cb7bdec4a9eeab8d7285800b5c8496624064fe29137bbaeb5d7f4fe32600e3e9fcd158aa21bcd137140558749daee2337a8d847160fe5051da10bbf0dfb24c3c112165b699cf4e308ad7c1a9b982f3e4bf439e489c47a2a8595dafaf44ed82866f15bf467db6d600b0f5df4ee156b90e5f81d05a476f1bfaed58807ff96ff40b2adbcd8dd2f69f19aea00e97be386df0a9b7ce8df4968b1fd0f75a998eae26229aa09b4fe5abb9e8485b77042100efe63b45dd504c8666d1f82f0fe13bf3af875d427bf20da2857004a97aa275c91fcb7b68084d4ce6a4a4b8e4409f8d9a9941d323e28f803a952585471fc99bf33c28f87c35eedca8f7e89b694100e45826de46766406d71dfb5df5694295f3ec90d92721890dd0c5043b9f3ad5e97cdf4047f742b7b2732e42a820a51c9b3825c43b42a3d45bdcd002990a5879ec727a2be47aedf9f9bab35d0981342a68c81b272a747ebe2cfc2019156911a83132851571f129de1da1b9478bd7b50f2cb98b6394bac46ee7a6dca1d20f5e35e0d508e28a053cc9da5f42d4f4a5605d2649e1f8413cb67b25ce0258c657fe0179c8cbc8e71d6a107ebe3c07813a66f2d555b66797ff2949dc412cda34490d9974be7a984cebe1dd6023c45d1d7f56b7122847a28493642458d2234558af47e60f807107a7756445b2cf2929569f1551cbbe71757d806cf9f8f899702866f104f724e049f291028d1a0eb74cf3f7b4343d9e0632d8343ca9180ec84aac9181ecbcfbd2945578c4edcb1cba96709ec37cde9e93203e4f43f468bda1ed034cc4c38465eb0205e2b6a644e2c1039c68a89a7bd4dce2abc9c6d3cf2e1a709deccf0371d4e13e79a7ddaea7bc19a66b2eb741c53d46ea2464c614d965c6526e78c0d33ce88d5f3756a4ade1fb643f78f56ee2f37b18efd857c476e58a94bf167e0d936044dc350a218d714561cb7cc9104642b6fe2f6de6d56d98c98a30450837a64c57b1bd1b85e0ca856849b4de2c5a422c8bd2a3fdaf244a4b3e648e8ea83aaefdedefa514962b5a9d7b83b27ce3211d793600e50f1a28302cb03ead0daee068c7f6bb1784ce81350199c814e63490c3e0ac22baa3e311b13959e6eed26510fe46308906f1dff4c84c75263531958c4e4accf0b11c367ef9ea8da3f943e669d320fbf2fa85200c44bca1c0d1ec8225fa992c1ac7dae094a5aae9ec12df4a9af9060d33f7702c9c90159ad464299801af60c440f170fa5c1cba57489a5b074aedaa2e519463b249745e14a0bffb849c3071ced656945f6cec2cfd936f2ddcabcfd3c4d391b2831673a5f7f814110eb50e385f07e6b157b02e585bb5cb283c9315bf2d94997d892812664d60c00a7b98fce0c55f6fc37f04e51ae9105beee671a14b9a7e974867ab35a09b6613a0088f7f52f8a69f19304b7c2e4004d589ce1e3c98c3313d8cb5ca8c53523c12106bdef5c34aae3037927958383ee36c3c13d95e6180319c966c0100123bdcbf9102f72e947c3ed57c5cca17e300ede7a510c060f1d9890c014b2932c60ce3f2a84903befb683a907a77053c398609e6524c3085561b24cbd11d787d37c3ddda47d74e0270c1b4e877ed82ebb73a9f811639021ddfcaf63efd51d03297b43886e21de536905ae7ea5af2d60ccd3fe6e3aef60e7db57ea44d6516b276ef82c5aa501355d52b8179c850734ff6d80b52692fc55c369d67b6794957caffdd9ad7b6d68da21e36f7a407d95a26fe47efe9b42fa84106e25f5f4a25e3a7a1c71ac5a7143494c85d43277ca1d4aad05447dc4032ffe6f301f25de0192b1b60c86df7e67b9996c97da76e35f0a062aa82742ba427eacd95cd4b930540d08dceab2832e058fee35df46095c6baf6e73332ae658fb0668e852d8a3892431244ff077417b18e54f2975c5851df245a27ed38d548aef681a73ffe8430759b3cb28a51626112276c41b53cf264c7b5737e127e8119d392a05c1c746656020b1d7c801edeaeb037812ad2b5c1e7f0381ab1d86e23e4c652f4ff3538134acd1ab065c03edee0690fd7ac947d5ed0a4b3fe456781c9427237445e61f26e790c59bfbb05c0ec87060248630f28912e132acde3b27eb67af31d9d53a1d522aa40462e1178ef9154ae90b17f3748c9ff014e1909e26e4bcca1d8075c91a1cdf035409497c0ad0f6458a26c8c22f2eee4f0d767944da0712e0f991937c05b1f670a7c6d449f5dca684232febb9868aaf212a28cd2647d4749d5736debe972a5b9f8aee55d343287490f62f4418e7dec1b6656e59e75f19ee7f8405435fe1cd75ba058e4f26cb5da5f2688fecf534905e25666f216608e55c8b29fb9cee6ed46603a7605bb40ff8861d26c2744f350a797157d5182f7c3ebc4d9257371523f3cc205f02b235aacb8de6e3e7d25d781a72d31071b113e7ee18978ae050157c64cf2866293b1984a32b7cb9c4fa400ab6086f2de743f0283407417478c3d1c9b3ca282bdf59b073782db71e63a6b88ca9dc072454338ee7dab5fbd511cf84206ab89e8c9d9c302d598f81517d9ce8b58d985c120d3c7a7bad73c748717187f93e5ea9a9cbb853511f9d6e9e730c0093911b6d228ca3b0cf0e6235de01b69ec8b53d27138827fcc3fce3aac26502ddcef541bd818ebf400d07b96f8c24fe3004b7894abee679db90f7082eb5a490004395006b5a8b8aadae06bcae3711ce167770db3d552fe8f8d6eabc2377632afcb53008818570b814307a3e0bffaa8432d88695e8b765a33d803152b77d748933972e415ff56f7bfbe952587fa62ffb04f82b14e10588157d3507e5661d1e106e9083b52e4361a2e0d387324063a3c69a1beb249a50a9751e8b99d1fc5609e81cb63723063b38bf1480c9c9ecfb43501e7d08ec89505305dfffa8ab3804d9102677a523710f6e99ebd1984636b383acb45e3398f126bba5494b5ff5583dd750e0da81c2678fb7b6e21d376bdc96b8dc5345cd66683fa80f8b0531c86c9b9995bb7d4541033a0645a7fda766ef569bbd396d9c7f39657251873994cb90375ad47f979b753cb9d85d37cd8d6bcf79f1eaf12d0036cabc442f5826d6b1128ccf2de212c7ca6d345712e8de629472c92785d0f449bc68b5e52843f6e6d1236d62da0fa835075e6e6893656b799a91926a5f3b64e6696fe1f4fa79a9e3eb114c435105e48498904f79393738bcce2d9636d44522c57ef26f52b8cd355f3c7ff617da959025da29d7d6f1f2f79c366c6095331abd6ee627d3de2503239f87476068f7e9d66d63e2aa713faa125b36040cf45c372c4d90560823580b4d4aa9b51777cd84a55c0527db905c5efaa5e5345170143972c911c93aa440a029d3fd2e4bb141f4e954c272fc893e5aeb31ce84ccfa4b54dfddacdf9f991e29a059dce772c35dae712128f90bc2918b07e2d9d7d8c44284ba8c4b8f5d4e940e19ebedf1dac98f7b0b32bc3de43cec6106cc93db377672ac654f2d6f912c28ab55b5be3083b7b3bc872dd8f720674959957a0c0c65253a4d6b538484f1b43c5824263dc1e6728ad328d4cfadbfe1e013e305d3934e4513ff8248dbfe1af797e3820f91d56eb053979b998ecc89bfb859f4cb607190a1e9a50a2adc451b63","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
