<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da0f047cd086bb155cafee649ee7d9e14b69ef383278d951e56fec227e9ef004f74def770a2f787887a6200080a8816f1b37c7c8bc4f73ce97da45649fcd6812518aafad48117f5e756f54bf910833a6393132972bb53fd115e1d06f6b0946950fda2a451df2c4602a63cfa2185c67ff023a0594d65876689e3f4b6a085ee4245d39b84ec5a4d85b39efb1716aff18e9167d71f703d1e9a9a8ece062aa05e6bf80ae6d1c44d6afb166a58606cc83b1d4eb7e61177643eefab0000374db79aa3224359e38657f3adadbd08197a31842b9301d51505bcabe44321407d71672416c81e7ed3183b0e853cfc862051605653c1f70e0080ccb4cc76b018b628ea42ed0edbdfc1f7cb7f2f05360f2c465a2c93fac5f4c4ae8da745ca4dd2a18dcbf25054a5652db26277dcbc2ba1cd8fb0b976ee58e0c09b74f72047dff4127259e01a19131a314bf577db1a1798d8ffeedade7356f65d02a5c3224ecfa7e2f5c05264fb4ff46709744f0dce3aab1a84da6644874e61e46900a26b34dec8ae94013f20891fb3ecc6d85b9f5dd78aa8686da79f4d826415a8c9917363bad6d2fde2c9adb439b564cd093168fb1fb1380ef9fe775b590075a58faeaa4a1ddf757136a8db7d059fa40b9cd54cb2d38d5a028c4f6d9e1b34a4de53b42ff8573c1ffc35d81f4351a97b6fbbeaf442e2fe706073fca92d65202fc5ccac225cbc16edf0bf456e05f707a2bb9d5dc168dd081347f821582aa9e01d36ed626069eadaccd49bd39bb2a299b5b70549a03f3aa9ecc2a89a3d6a0385411c2b35c0e820877fcc31d8ee862b10b2510737e8b9fde2c1957eb4392c19c225125a8b21f443e501db1730fe011e5902f373436d7d9baeda8fd8e1c2db94a6e7ea7832f060f3287e5f62d084cc2ef954d7e19a9726c3be9446ce6ad4180feef071d5a81758a8117e4a0d08395fdb22da021718774b2db6f73fe7fbd54ac0f964b9bdf737c147b7eef6caa8e61b2b4f9a80b6868210b6410e1a1f5ec205346727e1d7e60c70570b32918f23b41b80ce3e417d94d13bc9c14c147723d502eba6eb46f84c737d7d9b9207d866524eb8a0fcd13db620507838782899e84fdbdc9f637a13a3daef6c76e28185d1810e7ff662b4ea351f5262ddecc20089a2f41693150764e0502799636b1f41c8fdc5767c59a3bf67ff0fc2c3981887c055cb63932834cb68332fb298249fd319b64e8f80545af751c93c54569a20a44a4677664afef0efa0199fcec25bf8589fdb2d1e65fbdb0446bc7715eaa999100edb9c8f9f11763e45b8767a1a02c16fcd071309b8443e02893144c46e35f5c2fe2e797f9bfc6e1b21faf7db43e4d2f8fab59742db0b26e0950fd9750f41895b7972333170b816c0ce19481b0d7703c49859744b45939dea9051ad88ff75debf0f90e87d20ebd5cb9d8fecff0644e43d10784525597f702d71eebb2215ed7299cb749f6d448c0199dacb01f05921812581a956e76f1314a45220c4696c6e9219a159697448330d5838f30dba3ec9fc0537678edb6b0db7754cc8baea1019b43b01fd4f08ae0ddb9c02127a3d0e33f8e29bf1bbbc4f04db6719704370123a3d6d06d7f187c285139b2ff218f84f3534da5b0d683630b61e24b7538fafc2cdbf6264ced1a87331c36c1c542ae41d720d38c2ba3afda4ccae7ea364abfaf361205652c8709227d7465e2de8cb033ed56ab0f9868d2809b1f818a3f16dff036965cfa90844fa7aab48a6bbf06b4f1c2d8fd6a615fa4f8ca0b2b8e986c391db14e166dae42c93db6b6b346f210d7f5ba64ff6f9fdf07349887f345e0bed3c7e46fa5fafe0c1e7f7e20d96d3e7a1927846b9ccf19aa953269bfa36bb18c7769dc78df96e20ec06252d2cc91c44c901775f2d9c07eee2ff3e01e4d48f2165b59f42db6404b8513e1f2d85ffcae5e8ad49ffe99db8748030c764da1369088d66d54adcd50a744c4ee893a19413bb41cc14cb419a10472c55c242f97e61d890eb9f1852053617e782a19f64c772e146eb1de2f4ef396df4d29b36f5e1e05420ee8b40529dba5c3984ff844d0d8910da8b65c5ba016c10ea565bd15066fa4786ba856036477d25b82bb87e7009d5f257175dc6b1daf2dccdd2166cf1032640dfd40012fd51991df132923415f6debbd740e84e7b4cef0ca3c69eaa3c5da47576d87ab7fb66f52f663e7ae812f169cc5489c55d0b4561a87917978f79e2fb85d46e00f825794dc3bf21b29314028819cab227715034f6c1784f04e3de28da22dab9bc296dc08522cfe572402f89ec4e0df20544881b9867f3c0b093bfd94377b6603da45097bb8ee9a93626d3db348d89161d11878eb43912191efa5052ede5b43d6c79d81f88c7f827b0d9cd415b9066877f8a9fdccbd7597d50bfb4dca537f0ed257c917b50a36db3bd664e336467c64bbb210429b3270deeecd020a0d3369d22a8b45807a5485a15789e00ffdac4a78b6849e00d2a1198e7484728bd233643a158bd59147bdd67161a650e233f1d988cf0d3bac1bfa64226629d9dbc065fb18e0e8d7ca5fe4e404973f6c1548f2e4d3d093665f087fa242f98e9588f999710d6a900a2790fb6cd40ed38028255635e9c9f82fc1bd5aad1f64f7d87a9f420361a8ef37830a3cc691edd3b75b14bac501bb058f9703149cedb73ed9b1f404c691ca6d3051358572311130ad492049b5289479c0d79b4cadd71e0b04123b1c8e283f48d0b4c223c05ddc15ac510e7e5940ac8eae104fd87a7766cdedd357d7a64439a1690da65db49a2f3c4752a095f1dd133a2ecd735908782cce791ab88d2bc2b802131e8ab35d784dece7a6b59492f634836fd6ec6b335c7bc3d7bb9d90fa7431b51b206fced50f6816b8ef86e10803e6922ceb79e186db7a72ad503336842c2b8e90ee469508b5415133c623c6e9acf6fc30e9dcfa06d98f9a1fc7c1dbe3d7c4af83898e8bf4e05cf5be7c4cab1a778862a1d925a6c7e0b18a0dfab747aea34bd16fe6ea8379dc4a100318d8dadc0f3a2802c675c4a6f148d12eed162a41f2c6fead9a842d1c3f923d12f4f9c7d99ed0145307cc98d2fe140ef37be124683c2616378684dff145fe285a84d84c1f4e9ce146c8c5caa835e223e7ec2f8ca1e5f3363bcd5c1bbb5ab0248b5657c220d418812e63ead27708c33b028726bf37f8a646034023da4b0de3f514b78b2695d31b225e75ef96e25ce42000c35d41ce643fd6a07e6a14f7283e94b0c07d670a6aaaa35ff73f971401e50addedf52b05c3886203a653ad5f109b8fcbd9486a5f6724800125516bf9318088299cb0bdb70d2731608972b2cbb6b9dc36e6cb9670fc3ea9c9f90fa19aba042c13fded4517c0c7dde3911f2cdfb902b63fed7dfb1ca88a98a05c9f8ff41d7f9f45c0e69fd6669b7a6e62312d275e776fc1894e4e7b6b80aeccd10f55a0d47b804af86484bca5aa62a13d5576e6c9202aea51b817a4f3320a520a9546c542b66837d6a6928e12f3a95187d4f71a1f397b3b20798ea0b67dd52a35dff81f19d8868108e0d5ba8d5e056297cb7330bd55666c06684a9543212d63e6932f4f31950b110a5b7c98603f00c71ea90b19bd2759b354fd44b2f2054ff434c78a16c299834a0ffa1474be2bcdc7e20ca1e340bca29ad1deb230aa947f3d2fa956cc700b18eecf55001a206c109678c8f25200430bfb71adbcb7590ce4c7a3fba4c3338ec38114fb8cdf24e6ce380400f9676963f49eec59487b114653eca4b1510efb7eeef47132abe41cfc97ea57e5ae8bafd7b436a4b84c1898cf9d679cf84d20f7873d7d64059f74c99550a1d73934f14f64aa123f96fc2b3e8a0c4b5e29bd5d6c56461ee8785740c67c5d730ef16c019237e2c06ea9ddafd818307dd8bd82bf59ae440a9798948241ed14e4e52ee958fdd27e03bb09adffee9783aeba19102f65a418a21c97ec013989a8e61a061bef998b0a6457a5bfac87087f1ec4799432bd0773302107b21c883231d854776f9959dc3e4263354259a3a9efd825fe453495c565e6621c16f0f96026384ea3c496ca896d9bb7f2745212ba0671858eaa4cdb36880cd140a89ff47b1232c0aebd6e5ba843b9d56316214fd06a4ea8960e31c2713cc015051afb989369a04bae9c5cc3a7c88a4c2ef6e6408fabf8064f8538e8e54403ca73911b589d6b7a5a1b213c659a78cf06c2ecf80f7182352afe378661f5dcb3b94c5033b92d85e43fd0171ddc5983dd784b37f5d47588c3ec5f2501e4beddb7f00d43a89378b85879c0597ef58abaf5968f739d17218ff2d6cc576535d3b0febaad3f91111adcf18576b8def012e4f14356a8a64a5d04431d0c21b16c5d487fad0a9624c1b73ffc7aa058c53dcc3a8d9fd1713c750bd52e4fc3dcb1ed85e252e2e43d9da2916ba9bb0b5ca0f91dc7606c4f3a28d7a96368ce205a4373c6e07250f8f376b4ce6ef7264bf010551fcb4475f519bd66b01dc5ed6399b54fa2bb20afeb1202df536f098e5230f6f88564f48262a321952f2640d431e127bb104cfe00836931e7520145cdd530631497d38b90fd570f8b5e1019481a02c9f400313180dffa1c974f7d149094f2bfe6d4c6b722d60f79bf9a69f681a1f1c2ee509c8da1172c1842adf15ca32905da86aff7f30eb8271c5c0634b1188d4bdb3f3e561b1b2399fba895240080b1eda8fe2fc46f1d2fbc75772d8d1ba181ffceb48ca47e54c705b09421e5485c842c4d03680510125ed7a4d2f0ec3541fdd76ae10fbfe060ddae57283b9a509bfb222ff92f3ea0d1c3eb478ce5796d82e7b54a0fabcfe5d7e39cb849869be9445ee9bd892a122750aac9c0c22092430b94f81aee6d34f8ce8989af0ae9e7c11c4c3d2871ee5919aa8ea83dd3f27c7c27171576ff2e2736f6d3b89e21c9b15b20616bf10b606b8f784db766e58c29834dfd0a36186b8aa5d858b6714477332bec8384d1fe40b7c829c58ddc81a8cfa4f4d74e39b27696be3a0f6f35aef63b4cbd1fcf12f6bc8c8bfb7bc4a253d5c4f61b43bfcb331a1f658b2a29ec2b6fb7fbefd83fcbf2f1fadb19c1534ee2234dc7a502d1daef70a2fbf8da716e431a224efd98f8bb2823b5ca279404777acd5db65f0993110e9bd90a26fb7e7d17f65b5157adf56d16c7c22af3fca959ca1247cdcf787bb0915f1bd86e3df9eb3aa0db4733ee2385f459b7cd65819fe06443d186da8b4d4184a433dab49eebb0ce3caaa6b57400671e2d49e0847cd7dfb15264008fce400379b169440ae9b862de9340fc7d1ed22ef1fe04f2a76a538383624817b5bbfb379518a9cf5f9b2cab98415d5c80140d07fc00057235a92552021a090eb4d1709c42763fd2ecdfb4ca184520232ca465bf8f4cab7d1e6642d2478e94f42cd36316c5b08334499922fd6ab39c2365034a76b2bd44d7e69c52b5d6bb3cee6819795b576a1c3390ac0e3dc9c266c5d13d62141949d5d65123fb1af447ebdd82c3869ea8e73e0d567058b0e706025b11ce91235b4df734fa5ec9f764ed4f8089cadb2840255639f8ecbf7772e80c733ea253eb6c734c0ce1ac9810f0b971b7dfa23d5e075f122e31f8f6c4fff075dc251ee7dfe14a2963dcef16e4836421977ed4acf6fd2be92a37b5348a9ad00d3af9ff6966af15504d3051a2639dcdbda3c4611f5ab05c18e33713253ce3d779024fd218eeac5a8753c77301e594c511b54a95ca34379e0098ba149800fba21b401c8e60b3d347834402469a3c2fba93a861dc791b24a1fa860856cd2701effe85a9720811fd24cc9c063ee8812d28665001b1c13da681057abdb33e60f8a87c4f8d7d8891903f2536004136cd3db845c5178372249c65d8f06730e7b3f10e4ff4e5a6a63a392106ee09a2062cb3d6f18ba5f046bccae31876101cb07ba6a4ade64becd51f0640c8277ddbb0f8452ca6b624a85dab7931865ae32c8841fa94a07481d2c4a947e51b747f6ca4c9d52370f41f4059e85540466ad1e86954f33910f1173cde5081bb1b69a4fb5a5cabdcff58b8f920b0d0bb26493e13084aaa2f44c94f85cd7402ac7095c44eeede08c82b595d4fbd3899ed779dd294ee1acf6373d1b71b4d5417014317aa754bd1283e8e9ee182d8298cfbace40c962f33f70b03aefaf5e0fc39ac4ab33e62aff9da93d7b2a039954324280b13e086803bf4d8d32a364d65d2e938adb6bc3fbdc1045ea14e95ef0a27d43edab69736b00f4a55bfacd39cbb9affe6baaf2bc77b6c91a7196f150c96c51393ad51d35205fdb8c77569775f782e984b9d8cd7d1d11b258423abe122b82ab1cd154cd7889ce9ebfff767b2d144897fe6fb6d04994ad2bbac843c7b7fd5911477107bdd564af0f442068467403166781d82d8e986c5b627d86baefb73cb45fc227171e06ba5e2176c3ce6846255fbdba72b1281d359b0dab9a6de611325b5bf85bd15b382680d422deb3bb6f8b5473ee095f308840cbcf06273ee761ebcde994b1563da4ebad612bc5424d174d00cc31da6932ebe705c47054a9a707ac4c52f5bb1c38320064a7d0512edba646a4655b10d13e0f3f83e779e3f85a5b00a678e7af366e2d921309ced03adc2eeee9363fc69b2a899c351af03920734eda120e281ea6675489c33901cc34cc50fb4255d1768732580540bb1e8127c3237a8ea82dd7426d045947648db62433db44caa4f6a4a7069a48ba526f09cc80e9c0ec0d64ea92197db3707e0ca069d1623976f1dee06a5e8ca8da0d8009938464f9e5688828d3cefec7221e92ccbb579b036e14e78089625ffad5893b94e45b229655e5843049de035ada9c295a26f8cf7557e359bde7587248ec55921a37cb1d3bf9f5d8a7b6960fbd3613c1460680d4562094208b553407b0a79cb3836f53aa9378fc66c387e08c069f16982767ec508f80c056d2fd805ba585f832c928100c7c48e5412d8f637aeeae9c9563325de47eb3b7cbc64e80ed06a2572eb6a5741629204d4ca0082822fcfcb5a38018a33b01d3c02adbaca65db79835d4b86ffd8c93d9e7a78ce1df05a7c52b38269b7bd4efb3700b60b184fd278ddaf8b388eddb0ca5a5ce4eda215889abe4c8562588f498a437c93118e143ad7a745cb270606580fdf323f7df4a40585c73cfa3b2be4b7b779ae602dabc0e62e2f3599322625e94f9aa179dfe7efc486168ed4d8463cdd86e6ac5fa2f2249b986170a4ab99182933a2d3a1a27e4d201b882e6028f5e4ed8760ccff10eba63ea6b348c07f11d68dc63feafa53b1fe9c4efddeb88db190ef1e824cb6099bab4b7f80e3c5cd7a97889a038868b2701118da8e3c44215eae61d6aa34975fcdd81e9e82689a2ef3fdced43d62dffc411ba5d4c7dfbfe8fb1718135d5e1218f099d0913c8725a2a498849b2aff83dcaeec5068fe888e4c9dc07d0cc20c594a0a7d9bff996ee1788fb4e1ca40fe2eaf37b972c543f9f7eca11a921773aff13664ccb333a0cb5da907251f00f5f92b1fca726a1195849c9b4cc560e9b76bb67840e4a3bf7c34a441a570905aea723b7915ac48eb65280248f2ae3a9fe2abc43845c06f411642e5ffc5b38a270f8799e9edcb313c1717b4a90c8b1a0b2e8bc5dfc4e733a4ae030655ebd59bcad66e92cd31bd2ca786bc9b1f49bad35cc0ff2e6aa70b244249a775320ec2f3a1e4fba9fbe1a32ac32c14afc1748a55379e4b3f520f3ba74ed67c7378ae3b50404622e272b08d07b22b6bd9839e4b6be41742987d1118f84110cbb0b28aaf0c289aa832f523af10d66da7c930971e5a8a5f5087132a8a847eed87de7a5b3cbb7bdea33ae2dc9fa81f2c23c1ceb937650302cca9be9653303687cf37f4fa94d7b22c6f96d15aaed3a6b2a2116b28bf9aeedc0ee836ab7351a5b1e386cafb062109a1428a1a4225ee955db4440f497cb4f51c0513a497ed1cef3e22f7371c1a03256d9716209dc939d2739a019ee6281a507e05d83a49f2db68fd9ba8e9bbc790201463469088f049d435960b350fd0bd83d7e0bb766fccdf2221838defce6441eeebb609159a42ce9c90889479d34c27f08beb534584fac740a7ea6e36c07eceaf988c37499f05ad119d3f4bf29e1d287cb40f491ad7e907341f514652fcd5d27ebcfb622287527cdbd08979e107181fe173ca3e906065cffe12c9b901f6830a8b9e12747599aa200630e64ba62047887695254e5f972f0758b7e0ce1c9de81217236b28eb3e720ee70b1a72347eda9eb20a05838feb405b9156fb88f8478bf6a7f72c95e55a7d37e17c281a7ba70533915acce0d7add0d460a34b67ddc1ae4ab0877c2dc70a5b82e605461b850e3adfc73a93eeee454e8a678b633504eb51962218cef288bf006ef69303ea9510c24c64770f7c50c11b00290064a988548f04104a1953cb79679635dd238901543be21de35e95c33fe9d10afb84d498f1b832af8f08fa18f44cac8a1cfbb5eba545f4e1283813717d0f6743d471af9eab696dc3e352c518fbfebf56217011046ea14a79f4a3ba6c6a41919248edca04794803f23f102936aa6add99a8c53687efa6da9c4e93b1fa383746c734ca37ebfb7c8e991dedd3611a7602e7e97c1bf2cbec040982ab6f6b712147c52e5fda0cc1ef83f85cf62150fe8a7ed03ac604e44e24ddcfda25afc7c80d0d8a5b35b043292f45ab1d9b37b878c26dcc914084770b14092bf509d097606bd429edd598908c7811b426849b3c0fe2ec8f1387607f3a76d99b5efb98f43f024eb7577f22f3ac26b89e68dfc428746121654900547c9ec9af5845a1f37f2d14164f3015fb5df318ef6309f82f060b9af55c06357bf0ec33f7cbff201ff5a897e9382137eac71dfd1bcdf84a656aa24f20a5fc10f2dcc56dbcb577ee5c24274e6eeb19298d4ccb5f01ea6a04abbb68d9c5a20115538aad74474a83cdb2a0af2595ad5ab43f740452f1d3a4beefeec1351d350ffec332220d0bcc09018c64acae61339360d696b2fbf9d2b2451bc9e8050df2ff839e61aa12d6ab7d07f6b35e7bae89b0a4ad0f640d7d23bb0631147b96e4cabf8477903d9eacc4d2e9ba41ba1387400bbcf9e0a4d7e015cdd2c225155549f1ee05c20494207a873090d86b20c2dd474c827fd1c59513f96e8b6c4c2eb1cb945115e96a376646bfc7cfe960b6586ce849276d0593125b945d6fda1f8d6564901588878ea6488e1c973c268c4e26f23d48267cd3c556f11bed35368b37f1ec6c23baa8a62ec23bd95d9f538fb316b0e7805766b5a918d28d1d77b86cc4a1165d7688ea7b222c159c481c9575a409db7dbd45570905afd1dd87046621986af8ee9f04be36c0b1411bd43a044851c494a7c25c3b133865af9139c4af5a436df36a218d9f33d11a805a7e4ea2bf34bef1d39683bc611a2dc0dfc9ddb5433b8b9264daa5bdf5e6fd5d761ec0ce4a31ec5e1b4513580445bbb37fce01f25d195093cb26d91e91b36bc542071c7a4d3c22d9e48f9b90a597d041b2f361cfb87dac1059eba52205e48361db7bf0b5503e1a36f42ebc017f8af5e68cc13695de1210b79fa8023b95254fc6455e668a9306201fd6d8a7d70d79d8148f0a3e72142f727eb6ee67d0aaf24542b9c7d56c02e488a4eda039c1b99fe88a7c7751ce5ca59a397b2259041b857c94b249d381d82bd13faa979edbb79c7de5830938f6db6b4bd0cd31cf17a8002fafbe6bc02885c537b69a826d89972289f2d39031ad71ba84c9187c15bf59d299c7b8867f65f99087178fe2ced2aa0f3267f5915a3e432dcf6cd99f3db0f379a17082809f0a5ebf4ce6fcf3570ea25cdbce4c68d819a5829a57f3d8c875cbc90fc14be680285dffc78e3a273f7a91d6ca312e9eb5be51ec40f34e52c97bc118778dec999b1993563ee28e406ef21bc55055b173af6fdadbcef69d8dc76ec658ac15c719dd8cdade4900fbbe66df7c38917bbf67622e79b7061f3a0df5b3be7e6a22cc358bf693c7c6aac471a82032f36e8d1ffc03ac4b2e71a954274e7502015231ced9cb6d4f0dac6eb93928f80063b2bb89c5f3e6623b29feb70fb8a8813a263efb8cfd44fdfb01f01131d5bffed6d47c7db55c0686db1bae499a4cf452d49466e33ff7857851d557211f2cdfd053ee708f06eb6dff45e03a9d0f4a8f1d509acf907efa8bceae8e53ce01a063c6ea40cb3da8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
