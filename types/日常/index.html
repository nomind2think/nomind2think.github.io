<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"005d11d3049878c1d751fbcbfe3588a896053bbe8bc8c66bd7917c50fbdb0783a49a9b6b737d9b239af00ab92b092f87926be44c5a30c897e3588b3b29c01d71e6aa5163d3cc3981f073cc32926501848923c1d7a742d779675bda2581761e071c098d878f325f906e2b5fa6fe55b99970ccf215db9aec06a4d1676fddee333bfadeb050c6483ad5e1aa53d055c31eb5e53d7c058306278906867d4db5b80c6d8c0eba10e2bee0f792332572ef40a0438fcf5c1aed6bce37da955eff136636b5fd98737cbb6474f5228e5feeb57d834039aa17f6ef98054350a25863efd9286874e87c095a68da970cd00455d768cc77d3631e92c88c7a7b43d0e3c39988db8198af8e38b68a7afc7de28dfcf921c5389db01a63783fd0b67dde5f8187b8b6c892103fe0a44a4e8013a0ad453a0c0d55da0f5b1ed85910caeeec4833ba93b2d6a46ac149c2b2296b0d7916a7d76ef8945dd9f024365deb6d20ab5606b03b18a3e3f28b8c4691ca09cec465768edeee18783b017b70a632ec6f588ce46f1be245dd2cc39ac308e4ae801bdebfd1d7f43a6f9df996d5ac3889cad4b8ba759aa7e3f5e77395ff55345f48259ee001b2c39f237b779447cdd354ca1b3883f4504c2e089fde2fa88dfd331ddd0af88aa321e78a00e9b166fba53daa3c6f52bee02a56ae67fa4feb068754234156ad30ee1d739e748f48e7f919091aaa88eb78a4f0e8c93fdfc5e6cd40b53a70d4776ac34b4f60601b36b8fe00da9359cdf375ee3281508cf02e5ad2f7998f1677d2fb238671de49d505efa30888a8977fc63ab0a3c408fbfbfe3e6a51cdc0493c47de22451c1ad171d54d17b44521a628dd012fc1a1ac4472c1e08596f48377ddae3ed434660f2fb19f7531016f542fbee27ccd4306b5463b3783e74e0e0cb835dcc0b5ea6a6757913cbe7815dbc91353621f85995703ccc142d4dcf23ffe3e1e0d10bb9307f51e9ffc2395f02eeb866d43a7df0bdab3a063c3d7b96b910c7ba2f13b3e1aab86c04aa12ba8e41830c109d5ac47a6d3b36b7d06b0c19544f1e127c138f0bc02a1b49e8d9e3deeb9fbc18dcf1f99fa0791c6a3ec18249cfc99c69fb4fcc599aeda5e45e61d2d110934f8e4a2cc103b0e5e70a244e1e87b99b96646f55493d93d94ab28f293b9dbb96395f1d6ceacca13299d9b383af076c80fe5241762c4f15df0eee3d6f266fdafef0e2b123a477e89fc868237eff25cf99e5035509ff6575060e6cfc541f78e35431c504153818b5af0e815498f9f98b88334f3e63ad6b5bef5ca8434387cc1fde3ac123377da2e650f0bff4c95ff424acd05b352dbf0cff375a6940b93cde85e635164bf1cf863d873e7c440d31498546dfb58ce656ed8767a37e371aa436ec832d47ad0a9d487a6e61947a529e488a6279b5843067210c5ab67bbc5877b861d39c21eaf2c5195f1b29e5838f435e75ee4c548980f47f977710dc6176ba6b30674bb5366bd8622eccfedaebb0d823830e9e9d46f867910a9f54fa74b3cc0c120d6a88976a634948591524924361d0aef55000bae5275fdf4b2b8234effa4c305f2add3791ab9c9fa2fe673148c2dd711e9bd04a4af23c2208b4c95d8f793ec8c735ff9b2a2a8af664a8d09dbbf251ee0a4ee72ff740a648a57ff5c2ccb3989ec8f6e42171daac60e666c859216a2b6d88a23248242a6d4fa0fd82cf04e4ea3f62a9f22eb7d41ecf9d220b1b9c0a0f20e41bc487980ca9403145c9e76c35c44057e08dcc228616bba130b80d349856f008b0ab4ec175532576f317e345ff7825964536d9bd001cb003fff59af0124be5d596eced2256aa13f1b1291878743d22b7105efaca01b697a62003709cc1ca4d3da055ea889d6e80bceb982f0ae8d4241d755f728659ff1931772bf8101749dde812156decff930bf7cc451810a0c2bf0f5aa8c568e7a382703b517439bf5728f121d082b3f2ce6e6879d4aab036268b0eb8a9d6f7cf99c7561927e478229f7d9d67da8f8ed4a48d6d652955dccd417ea958af3a5d4b10d732b71d9114c87fcf403c3f3cd4546eed7e5315764b5feaf75ec0834725b8a15fc86e0596a93a5b1605c9809786aa5041632ee6a0e2ea9ee59070f1a1c38967a995961ae70b36c4a98f664bf4e3f71c52d06aafb89c10af7d24385ebb92b500befb5d03554305ba51e5bba0920eb5e8d16951ae8462986d8bab2d8312458e5eb1deedaddc979b052a216942718380378f13bce4ab1b8bca20f279766c883742694c7b9c8ce89e4eee5f439fcc61874944170b3e928f75d2776b68a48d58ceae85be2f8ef2404f470ff098f8bcdd05e5956816c5226412c9115a5310a8d70b3fbb01e3c029190bb610a1a8ee61312d24527b29fdd3589d367065bdc9b8584f99f29336fe506b0d750b3138bb49c497ecf1189de98eadae1dbc9e81d3e2327239d5ab9f188171be6e797e3db20292d6c8d4252a6f35e43f1b6d3d9acf803b644fb913c4ecb0f48f8e37d169685147f774b70b47f712445dc6f660a3992ff0156e83cdb9c66501e75b3bc41659c29cb3330f7aacf52425087daee063abe49f0a7c64c542fa873d19db2808ca3c9f1b3377d8e5836839a7ee719b635eb8becbc29e712696b811bf6ac8fced232facb7bf5919c97979150f49b459be8a2088e62915ac9b463f6d618f71d83bd2c8f9a5938c740dcb074c8c4d5255fbd5a6173865ddf1934f2df8395ab589ac5ec5334010f665117d0e07f497c82b704162e637bfc125192cff721177177a3c59381eecbb13808db8c2d7f0221db5bc33caae1d538122752c6a98ca25319a99541b456061e60b4fe9246873807599b0361ceac28116e94dd2640b1527346c97d30c5a7bb917df4df7c23f9ee68887e70bf81ed899c2580f7f6afc896e894c8eede816c49735a26aa970d869d3580bed45dab8b3827c4feb388ae91624f37defcb31c279ea25113d3aa314b6cbeb97020e53a78d3adc0910db245fb523df1d54949ee17f2daf4e101fff667aae9bd81964a0c2194db84f841bd3b3c6cefcd1bfd92028500ae506a30c648ff5b123ef5b1e448eef386365541ea64b971a4471a7499b45efb4f4b6bb3904aff1b352fafb82954f11984731437000fe42232ff8443ece0390e579b345eaf3f322f09f6ac0f47b159ab2814b3f9b8f5b11ba72d0f4fa083cecdab181613b5b19cc5f6a4f405fd4557274a581eb0e9e751f0a85ccd8b1fc93bc4d766ae94bd36181ffcc13c63dabfa4ab82c037384c945ca80053b7d3ecc47004589ebbfed5425db39df8bf8fa5af530a6736df315dd455384d11a1149b41e897fbff6fef40cffa8dc0b1cbf086b447dbd73ea2c8868d282000300e2c6ea6e2c7a5985736557ced66ede5e3c3a0f11af99060ddc50f2e1b96ebe6c1d950cab3d834a50fb0d5196afa58291f687b9f73656acaeeeb28243ae4dd7ee12e875e8f2e6eaedb243413fd0c782ec53987f1d18808883331e46bb71d8c24542099056ca380c023a56c860a84f6b291327c65aee3fd264dd1375fcdef47a87cce3b193e139729e97744d52b4f5ba1414ee26a5dc27f2d9d73ab0039f0a6fa80b82552b854936850fa0f6807873d1726f1598b10b7b0034dbee2336403cf177d5837bd7373f743aa82638e7be67def6296d437513fb57cee25fcdefd8e81f09f708e31bd3b9a7c76b455c40864f54a298c083457926be57b39b606d77cc34b4e6f7851b161d218ac0272af2b9a6c1d0c2b8d28f4311435a79d052d114d1b045aced1f429ce09a1d08fd0f021b7a513f8bf1bfb6b2b8c6d132133722f2a087f654782b4d0042e5c84510c8786d36dd1b774d0015527285adcc7a97897244f9811e1c7487167e230e1de73a9bad346b44d2de2457b52266596a222f20d7eb6600eed5e6eae14b8416442e91fcb339ca477bd557a9077118dff3a14794b74e0a05a807fcb5902b5970a0999c253f5b17966318c63611f01c2d62129251dd103a275e8b9a9e91289b1673f035a51bb2ca177ebf69b0382fd85204061583621b88a38cf0c77151b963fb22652f18bb9472fde2f3f8f6b48a02c1cab921e17f5779bdc9c125385a67ef8a03f176f1f93ea912fd30b0445022e7864ebce541b96f4fe4eb1649aa4ec0266f90401f1ec0988b322ad479a4f9aa7eeaa2e7a40ba848cecdea3b90a9ba5a02b149d925d6f3508534d28fd8505a5d8e0ea2b5d63de954ae7ea1b876de02559c409a701c9d8138a8a80f13be9e07267933310f7733e778cb841b2d961b8fe5dbab2a9bc392892574223f0fcd41c35bb8236db29033c7113adc6df616c4b9d9d842cd32dff5cb6147addb9cd3851f020aee787ae8a9c44c78d7406ae59b4a81f7b285b53c4504b5dfdde04db59ce3e5ab473b2b7bac4b4f6aad35ca15df8d3b756a59ef79dd67741073f0cdea9a7c821dfd9d5ddcf581206891d16441dc5fb4ffb5007022a8641b6a2f1e69ed19fe131a4ec5abaf422a01fe287018e5b2577d13face0dc88b412b9a93f94e3a056b9f5fabb95e0d3f05da5d4276e3e8986f3b40c1fc2518b277d194d03103208c050e37cda6394b45361a629840f793a0e5e01606a5aebc9acd2cf71ac2b35494ea06f2a34ef5830d327dd8b44a756186ad7c1910aa116daefacbe706134fd4b1a7a7d432023f107c970b3e308490e5de57d974bf29ac2ac718ab48d9ea62c9c8a6cbf515b23dabcac23456ed2fdafe619152a854721d7543f0a488fad32499d52cde118e2517157bced5f7339c74e0cbcd4b50222a42dd4ae068a0551fcf25db35caf5ba97487586a456eba25c7678eeb7c223a4be28a565c82c6df4308436becec4b576ef50806317f6657a15ec8d72adb05790e0d2bf7ec8daeb91a140a894f490e44d83938df9e4af9c4875908955e616e57898cd40200c84164f0905101e28b7893ff04c3b6b27a7e0b91b7253f75dc03769e935e71f1a950bebc5beb78850d6acebb1b877ad1b62b92519f6f2eba1cac0c5a58cf70149349d39353416f7fa63e14be0183df080530c765294a20b56e9f838cdd02fa0e9c4c6c3649c7755f652499cd3312c09f5105fcac466bd5d48685b5704fe6d5b01722ebd9ef310b407e32d53508688fc718502e913b3db4a06b92b212fdf8633f7f130759200e867d83f1028f0a36d9b17069136392f773a139d926c975b8c4b36dd731b8a976c16b5e0302b8a2bb8997738bf3cdb085b82ae7a2a9266f0199f96be76113614732b3dea69accc0f300636d8eb8116b4f39d62c4708576e175b36035e29ad736e228d42c1cdc286ea2489a13d6e731d1b4353ae0e2291ec2e62ce561c664f8e455b7bb79cac6bda26372c6ce6008cec7757126791a84004ff928a82dc9e98ee3498c264d7221d121391d3a960a411b6a4fb73cc0a0d26270d8ccee78d68d1ad1438b3b475213f055bd2d911dbbd34d9429d2a01bcf1d475e16bfcc92cfd52ef5cdc00d56cf537e8b8075aaba3f3688fddb5f84883649c3d421d5204833b623d0950dc6e39c27306f83b50ff57f74346b79d4697b6281cd0d89028f80ffd438f4e9536d7268efa607fe6481256a919b86dafe326a770c6dc4ab7f207007fce7e8409fbdb10fb425a7a4b6dda92d6052b308ea1a838edc3423c7712e0c9fcfe676efc20009bdeea58a12d000f51448b53de7d47d2f6ee48f6f252a0c3015e9bbe46a657d50c3dd0a65d6e9ecbb801470825a0cef92183aa002ca9bf503e9123db4b6732c890e41c279817a406a280170b582fe53ffe110d0e15fcb0dc64078674c40ec8fdf404a015db5b13d2bff42ffd9ec85e4343df71d24e2d04c225e522b2f46370a428f256b8f9d9c8818dbbe2ea16858c902e7473ffcc2e3ed48faec18f903954245a20c94f5f42637490475604f099d2dbc03578f701ef0c66f0c7f4b0ef33eef0437c1cf399e34cefe73c69067d2d4e960af78fa2bd8af1009a4f3b33338d51e44dba35fa122de2538b8ba7b4d15a057f7f143fa46aa544fd9cfc30169ef04f9136ce6366267473cc427ead5311b9f05a8dcbdef1a82e72f1e366790ef8b8deb2c086caa0a79c5b38c3416d46b170c0ae00383a18d31f3bd6dac67415437f5b9dc0a40013ee97ee3753dba02ee5fb46541fd586cba4c4c3d3e5054ce9f706b25afe8d6040e44ac8f326c67b643c0da44cc424f933f52e6dacf50a805c1f0f60a6d5cabb53ef4c56581b3758c747877f43f47ab1f7dc8240d2eec5521c8ac6ce06f7fa9f2a8a380393c7ebdfcb9a46a88a6424c93c29001354a3c57f8d1c58033c2daf3bf1af191080a8b198a4fc8aa0795f2dbf3ee5a1236973b121042dc5c06d49c3e3f234e08d04734a9c655adbc905bdd61e9ef7bdff0552967897661104de0150e7fddbf0a835213de70de0738513864fc6e5c30d2023ac7af50e1043892714fa73b44d4d72c9c6d3f2b0e29de2274f99e4557d3f06d49c52e0544b3abf47fd8b7fcf7813dbaa50fd712cb9688277011f977d018a234c188cea02e17ab7b8ac53fe771d02404ff28d202bdbee1c2fbe4cc2875ec8cd277ad986e3b50c2451659fed5e96b433a49da6dffe4bcead6ac86b611a31edcad019b64c6c619cd7b31ed3ff89ebfc01302aab78f91e6477949c71042cee94bd13554288cc355f9edaa4783222d7e860fb156ee3ff8cda38f97d7555a6921f766344a1535806c9ab2965b4bcf542ddac4ed4efee1789cfe7af1e0ec679d3435adf3c024212934246455c58987c06d8071fcca24419d2b0d5c0725f701019dc0181edfa9aa38565101b66359ff50cc9dd7deff37a5d6a757971612ec7fcd0a91cb6a0b7127e4561098e37918a4d09749acb368463a192cb86466daa5651f92c9f321b1d750071c0d6827ab97ae84fc09229eebbfbde3259d7dd16c787c7b313a76d971639b6a172d26df643ee74992046ecbb26a4dcd85349fdfe12b6e33c6cc6568e675e186abdde616d79ae5cfb8c0b11fd8852d06dbb96f76e8130821e4ccd2e31f1b3f278b2650fc8f72a91900deb6b90020bff2673334a39dae8c31180102cb2a32117320767f2c678916bdd04d9d920fd60508c75c22222790b59ea05ab5b8918b8f502b8058cb3a7a8c2a44a3641a3cb02ea8e6196227e5ac55195a1322a589939343865e9f5387c5b2676f31132e0ee08e1b2870ffc2849984ec000400b884130c5cc4f6316670557611fddbfa8a2a5b4535178a7e9cf86bf26c5aacc9d1434a8b34bbd6f7619b4c581679f7f420b3b1d36eca36c65d8ea31442c8491391f6c654045c862e8361dd0c493f955f6683d3c0da56ec4d456542f7fc4b851aade415cc4923725dd4774140a82ed6fc545500567caa3b21f06a59c522edd9d27ce7359bcd0a7643260c07e06a230b62e53fd0314ff900fec2e8d0acb98e6475ea186c6fe752000b56abec579f7352174f2c7f675ab3b9e698c1445910874a06db9fe8bd497feaf03da7c49bccb54b04203de1d212c49038aad4de4ee306a3216cb994d75aa281f25eb8d587f9e9f09c37f765cd070c54e54327f35fc47136e5950c469e9406557d29a9b6b8740403c5e4ca1fedf28c76a354d416c7d1c21c8f88447df675bc90806bf0509d733fcd2a1e9a32e5582ac828fd5ad8d46dfe4b7212fcc00868a9d5fd7ea6753b85d888ad99edad1c7cf659187606ad95fe6731db1a07e09c4211ccf48b6729bc7cca3805b31bbbe6f11df01446e9fd834f6130e75ce3646501a4148bf473d47a6692c3412ed13b32897832335e4098d46f5ce31d0e2c64c053d9eb095445de7a0969a590a3e032c0fa7749f8d3e69da7400b8ecbc442eae7029fef3d3ecea6bcf206b57f31010e098243e9515c7e763853423c6ac548efb6076121e058d9f08ae68a6d2727d0d1c1ac44b3e021c3161c7ba012ee3e1d9fb54445fdb336da72dfe26adac31fe067f68e3f6318e1f782f268a4e290fc7e3726a60b9e2b5a5ed74967b2d5c8c15560eff7838ca9c73730d5e32fe25ed951fea4ceccb27e9865b05b90c2d45c0434d00634ecfbba9aafde5b68a16d6fd9aa28e92aed032320f733b61c2d195feb7fb4c9483fada694e84239b78b13fadee4b0520f4632ff250cb533e0f6863121f7d9a001da3229f9462716a76f95724c1e2766cd4e92423b019a482ebd6758256a438cabf24836fd8dd9fe07b7f20f101241c25b013b5b22f819b66b7093587259a0c498eda7fd072eab7820ffc6dce6df0b639ae1421b46d6469ae26c25188b4bb9c5a0c29c89cecb86dc4c732692da19311e8236e0e24fecd96f153dc1db63ef401101cc668137019b4302df995466281ddec5e5996e073731448798e7a50ff763dcb52a564d984304f8d6c0494a25ee155c2465ff7c84a15f9977a7d32b31b0cc1c6b22adb5ef1733990d93069687928f5e8d4ccc0e5189be77bcfa99260a646a01a5c87aefa689bbbdbc7b41257fbb0c6fca01d135b5ed6a35ae3184f05074f87fed938a8bb63632916bb38ffbc43037cd1b50f1ca8a971fe64ee894bd2511bcd279b846d38134f6bb657b4e07b045d384f13dd428bc3fbf49abcf10a155879c836c89926a7420cc60e317e4a18347d1b69a54619ce81d6a3eae4588fb6ebcca2d8187d7bcbe75fc53da423651090470127ea8bbded0288c5255f0f2e5c7ee385a9702e2aa745d32bebe80aaee0733fcac05a13b7c37f8c141eb8fe04a10bdf7e7eab3c1ebd332d2fcb1d5409c3c4f1d8e968ae7ec07bd472fd294dae6b09e50a07f7a19a47ea967eb699f550159763ea9d537cd091931a3d463196c84d3655be4b909d9f33cfb75df76636a94698c56b7cca1ef6d848b5a7c43ced2905b78bb6847be7841e44d1eb9e3e26fe1d10803fb5e31465c0e2701e1bbc12893a603b12560c73aa5605c726d001e49c747c9e9dd68e6cd285b36cc17a11e09f3708a6fed0160a9af4c9989ddbbd83332a096dd4fb31f03a2fcc4ee1ab4ff57e1926a5af36a666e0e1beb886afb41fc724eb96ff0d9c8180a4330b7f215c4f2f98dec586baac3ecf700f8f16a8b9e67cd428280558c022e823a39beefaaa35a76a2727c4b184eac9f35a0a82c2c298137863b5ab373b4e91a9b30126525f396425a0b34da72c1e3d68ec850d148a5aeee322e8c3af6c3a758037dd42995d99960a959c6fdacc8b3dd795646b37a92dd1e8acbf849c813b78be39c9da9ba57ea48497e955338b0d2eab7582106263b39d19fef433e232dbb9d30206f377855203904f713628de399a2eaa4f3a499d8855e6cdc508ea30a704e45cde1c5fde65d2072a90a3b1de1438810edf2805a8918bbda21c8641bcea7a388baf977e4bdfd718a094bf96c223d5cfc84346f2ce7b13ad765d2d3b0e2ad2f5491926f6ddfea4d8d17e050086d5aad0e00d767f93587ceb7e4b7c3c2bd16aa23584b8380df3d027f387c570f92e76e104507104107c0fb471b919e2998bd5646bb77e0e0b062ee978a6d1b23188c17155d47e33290879bee0fe125c15ccafa343133176a9145413bb9c1070e5938aa1d86cd307169b4cbc00943a8770b4298083f76be71a75ce7f9450fd12c888408c07698e8ed4ea9085a0151f1df6c459a5fe8d1eb750401333ccca24078cc2cfe0760908bb62984efb99a10ba9e1397ad8c1f220b6a404497f10254686c4a493e0a56f1971b3bdd528bdcf8fcda00d822d0367f3f35ba7d84d5052019a500ba14bf5efb0388343ddb58cc6417eeb75104e2b5d1602defa8a86a7831aab2d929172d3d8f4c92cafcdcf273f771d4f5150d5c60e865a4a04c30842c8e184494f3de1d32509c7515fa07e3933cbbc53834f6d8877b2e79b4bacde1bc65ec4ecdd42cf8a177f6bf956d20ea17a23723866db3d817c4234b52a1ee80deda5894d8594911183e076b2b953d9a4a1918fe653b51f4275f206d11a3db2ed9eb3a18213b49b09a825bc54422dcaf773505e2082fa5040da66300430b0d5c1bb72e619e039f3127338e76567823edefdeeafc962e8c6f7edfb50621b20da533e7e92e92ae443bf27952dc8da0b82b95170fec4b588962bd8e6c4ba05176a123d293ec272656d6327c42b527582b399565fe2baa32d8c04c83bd13e0776f8a2bfab208d80ee4f31a37a0db96b5003e3274be990535c005e61e715f93f82208aaff5475cf4d05e2f72edd67b515d02fd43e24231da7ba44acec078fccba01e0ed00f3992e9011bc5015ce6dd70d698983f2089746c3eedd5635f16e9649fe991cb81de5261fa6d48ac60a1a060e3221b77f61f3873459f18012631895558255c1cde8276ec14ef10efee12d9e9feec7162f4856575b69bb5034b4f58399dcc2bd859445f61a74721c612806dd947796c5ac9955f0d605d607ca27e267e00481a91d1573b1e87bed4bdc0651aa204411a98f50e9001dad69490855423ffd3e3ded8be12b792850e9ed116684fb4913f824e6835229c07a526997aa3d13a1fe267bd1d0c536b652e62d28376fdc6cd0539682bc9e583e724e5db7b7c14908191f35adf2e139b8ca947ebc2eb7aa416de6d7af360e097c2ea37898be5eee729121b56ba0f2b4c305367137748f83dd707726a3fcc982a3d6d5cd96a4d900e5ffd00a97e7ae49b86b137dd65e2129de1cbacf99c46e755e8e85e2062baf8232bd18ef9b58aa51b68d091b0d9dc3fd311c0fcc13ee7f8299d12b6d0b61ae749406090dbf3a209dc002227e5a8e1053963086cbafa40163bc33ffea59b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
