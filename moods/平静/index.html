<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58751c930d2335d7d70ade5458ae1822e0c9e11e09f21ac1bd256940e5896bde9a1c717f7703311d07a3421dbd1d9d55f82b3066d3384b894fd4e26b63798fc67a602bfe31a4459d274c1d318f7c40cb25b02eed20ac462106c0919c7c1c109a965a9c2066f78fdb4c2ccff00f4e269adfd1d3854466ec37c0b3c0ebc346cd54c084bf9079d1419b81405c773c4e46c094f0fdf8444dfc1418835838af0833bb3aad92226d7f1a6b0a6d242813a713a477933e88c5a4332e1f02b3ad0a5d2068df36042825fd7e8a0dbeeb28441fc49957fbb5d925b3afa656bb2b8dcad887418f8ce22f9293e4debcf931b46c916fd5b38fab237aba1e325b6dbec47277d2a8bd278754dbe61914591d35bc8b02ad444a73b2c3e0a7c89ac91123b0dface525c88d984bdabb1574aea990dfbd82c19491d7f740d33c4149f4bbc7c7ec15d8eb3bedfa88a38b0b1659dc0750f4042817417afbb6ec1045c8de02c644ae3a0d00c1f7cfe3d45133615e9c005f9c0208e48332fcfb7393fc6e5398e5e9893a31fa0afee3c4b9f0be6c244d18cce809270583d1ce61c5c9faf256eb570bdd3a2254843157f017a3198ffb5c1d4bdab38e0477827f12a3560147f29e9f5c5638256da5e7d9ed2c954d19902c2d8b2c953e7ec6bfa7cb2ce8d465237741f4d3a1759703a14ba6de14bbc7dee728e5cb2962848d63435f0620964ec534ec07c90a5d81c8c552bcde26244e274568a43b99961887e87f99dbde70988e3e545d0fff18f09061d05280c7b8c820079a58ee4e8ac8037e59a96698c8ff4e1051003be21b43cb04b220927095c0c2e926e6c880f1c85071b6d095600e55629e26c7f3ad2512e103e50cffec05f85d5c3cae42c5643030603db13c927e827f0742078a7ee83d32d040fc3f27b1c2fe7172637da223d3c79791e19f775f8fcbd836ef08a290b8cf018e681d6c543b4b1666a8b29eef33cbdad6270869272ec077ebbda62d9048e15233e2600b9eb808a3eb19e14ba14719033642c980499720e247eab5488b6310b21412c3e7157bfe7409c2dfbe33e525e1aebfced6ac95c8e24bc04e0b8c2e05505bfc03219e6914b7fae06a9d84218e81cc307f762627f36a3ea9415655c881a35a476695b8a9807f04919c9614f51d90808bd68a6c3e7321d8b596bb3184699fad67ea9d303a95a6d04d22442828af8167c9af522e6fe955d7ea3270e782bce7fde566de989165737b846e1f9b1285d5ffc5d7b4b59774989f741faeba15e6a67767932178d771ed97d062d5556ac0ddcc583050cb451bb2abdffdafad156310871d16bde57ac32b181a29ed985ee9a0370c796685f78f801c92a108672bcf3b84de31a97474a537b58702182265aa0e48dd5a19de685a5118773045cd728236fb7a34f069dc9823abb0768fac402a151d3bdd2e20809574724b0b54339b49327c2db332a600cee9be0cc62bbd065de677f9a0aae41ddfd15fbbd115f82f049cf131210733ace90eeb08bdfe269a67eabfc6545dd7112874018597fc5dff4e732114d3f31fdc959852be2a2ee9ed515029892dde8774a9fb46c6f4bcd740f8b19c76c7ed01041e4093da1bb5e7d9c01a999050c31958ede84be1eabd14ea9dd605bb762d6f39b238c1d4eeba0121ad9a5280bd87fb672101354b2d5cf93fbc0991c1ec765bff3756483e0878a92391d7f271144e77bc0a24cd69e804099bbc2d5e24642b2c12b9754d7511a5aa4a037982c3319ff0953d267441b1a63559186bdbe01a87510c8f621c66a03650419473938e8b3d76a241eafdc1750a608c2d22e697a520ca8eea190a5013ab287b29e3e8770020ca6442cf91522f0ace1c324130ce47291a2e8966fb687ae868b57ceda49fca47725835dcaaf3a233d9a39f2367e6061a340b878866b1e7aaab6700bc3a1c965a48b2602ff4aef213f7339f46c95e85daec9aa95e554d7397fbb900f42b8c59699858a8e62be4e6cdbad3eaa507076d54562b3fe16624f7832b0ad34245b19b5fa2abb6fc7976115c9562dd0759d1c35fa0b5e70c078264721b6d0f0b30e40894d257e9e3274f18f6422b468b06959cfececa2b74342b36e42aa6ee0db4db4a9a46fecdf182469f74dc6450bb86362a9a114f35fc6afb6c409e383d29828be81918d1725b68ff8a28e0387a5884e109add5403d52c65007ec9e3b38c8a37b119950d83703f4ca074e3bd14cf3c6cab26e3be3edf898f0bc2c709d6c64bd90a5925248db848d2a033f0cbb91e37989cfafd7a6e7dc075251f018185b4818f9cd406f6da9d073f8a867781d956d874a1dd7873fa33d262116e8ceaa711ebfeed2fad5c5af7d3e87f36913b577f481bcfc33a27a4bb93b994a6a673644725ab364aa78329a1be221907b7a58c7a0d1f458bd3df5061a124ac9096a4bd78b6e9d20344dea7e7c19f94ec1a87116d93335a3bf4fafcde594fdaa18c73e9e6f481efc620ee102eb7a0b124ca4128d377643383bc61873e495171f43478752a026d8521d1ae886ec85c2461a440f40ab42c00cf669e60042dd641a25af79e950ee01f9dc847846ea76c8c4b8a016643b145285e86032027c98f6ced6cdee635886747e611ab64f6eb3192b0c8da5e3f20c061c1eace6cc68a9100c773606f06765b3b119ba4cd888a25a04c6486d4b393ea146c23323e6ce709cc825121a2193de7ff13f586f0a21557dfb49f965177e4669a28bbd54c9d98ea1ba70015b3b36ff637d6e8d3223dbc3db65e970c718eb7e0e7f9c6e747817d81c8169dfbfe3734f8f57dc42d9596afd80330f5ad8ea29931d698e39361f1a30571bc25a1c2b9fc36cfdde7bc89a2cd437c1b9cd668d61578a12d87cacd557c836ed339c7af1e0228e1d703ae2e1c30c84d1451c3d7fb34e92f1211898a4fa96a2e44880539c993d0c34aafcb66c0e35676a6d16937f63e110551ba952ba785a5cdccbaa267e472e4385e83370c3631f9b3b4e555504aaf5176ae2390e3df22ff3ed4498271b35d2a90b7405906aae8ea2d5124584e1b768bf1d8e3bec643d59e52d6e3d828c8c8e534ebb792b4273948f26e3305933f073169ad1ab8d5e3466133e9fd1a131481578797843b2db22ec623820f322168d9177e710bdee18faf7f2126d62db93535d811e43d3bea516faca5c32311fb19db74afc462453a23d75095b93d2fe0672309e47ff614e77dea257fb05a615a8a2282b9a18b40fef5a3443df0b5d5405f45bafa6e11a3fe279e8d27eb655aed74b0d6ea6eab608d437e2e6b15b21eff4bbf97800e600950a872dc5af096818884faad67e7eae5403caffd2f3794ececbc2882246320b825eae320101ae5243b366b1d0afa51290c3bec79945abcd0a651ea10829178c6f975891f5571f957358871675132e29d09c1a1f702ccb3cac328f9929cdbc8cd065f3d62516bbe3f252bded518c92fd26fea9bb5d308428dc58dedf8d77c923ecaf937d1305406a7ce373873a92d0c1ce8262b13fb7231ec3372d662d326e80335e2b58d65d714cef5406b808dd073e4fbe05b0e6c0ae96840ac66c6c0a3eb08f6281c09295bd56b3ff57334251194678b4ece1d1c59c44fd86df680d782d6361fb174f4ffefe8a852d5cd7120d708bccf7caca01d4d07f9b25e79784cb2ac2d95064034ff26bf3112232530f53a0b17b0657cb4b1dca732b53fa9dff3353bd87839faac5d032b0b814ca1633607f4aecbf5dddc52f7f95dfc12980edf4b46519ede3be0be41bd2e2e1cef20e530400085120303d1073246231cfc3181a29079dc3004281be387d39b8742f9bf38dc7b825a45f9d84d7357162d12884bbef19ce3691a54efef7080942fbb49c3cc230b7fdc6755f633346aba8c0d070a82a455a13d06062fd8a3120e2a5d85ebbfb086cd952a72a5431a80f4653ab66d12e14a0ae9879abd1d56d2cd82514e4220959ad807c1f64073184b191bff45a9c53d0a62a70c1bab010ff5e4583796b233970340d4f0e493b89eee5d59a80124f72ad926f6dc664669df0ac9488e5b783dd4440ef3aedc2c1c838a3564d28cc66528169df21af53806c89f2132d7f5609effa691a152d0ef705640b15b9a1af2fd93a56bbb1fc1168e8785f436c2510945a23117697d59449b5231d2076f76af00c802c382895a02ef4fb9575493ef52a5a3f46a54159f8f85c354d5e9359087f354405a46f0fd8398789bca6f31da30cc49ffbdf0b6020ee90c66b82d2ef51c629373ce8d24c4336a0fbb02b0e7354cc37adfb4f0defb5c103ff117f460bd96e09399541ba95dc63c111e5c341ccdb5585c32821bb3aed8debde3336071cc189f643408e730b38545b412b05240dbec1d1598941378a2669455b974e82711516e00aec27e943427fe02464fe6804d8be9ad79bea319d634a2123b5857a0dd8f62c9a7a9a6c68cbead81bc6e13d5895cfbdae34aa0290d203c3e02c2e6550002cb6f589aee1f182ef84417422581621b14f1f5123695cab1ed95bdd5855806fe20dfc70fa9a511ef80eec5329b00fb41f96b08f65effef6f9fb0998b5508275b278360d07c4dfed69eda2d5d48f1bdf4bf1c41bae91ff7e078dac59be7764f09632ddea053b2fc5598cea72a0cfaa0575120e66dafd7a2b1328d6ffd048eaf7c4359cb7f75e1138902dfd7754832797b1346e8c15e7dcef6ef75711332ad2c9d5f10cda012f82ed37cbc7aee6bd8cea9b9c2464c868abfe317f22cf91cf5908ba415ae25c37844a0c0d7384f2faa96dc6fd41cf1677c4d6c325e91beeb99fac8fb2bc5e96b7f0b00892ce95c0eb84a8ac7fb8e41f5d1f4f3e81adb5df72fc81ef585a388097315775a08513f490a548bb53b7af0600faabf906f73cae7de86a59daeda6ef9c5fb812f8659c74296a4ba42f39af983fe1a34ab72418af3cf7e99cff1c9db36cb31cc79a8b6f3782d3201dd5ad65c0c479dfa6152e6dfc150e3675dbd16f6d96ada8bbdd7fab1876c4e5e4052cb842ae916d87bae93a397249d8af3c2cbf3a77ef52e52aab58c0e23ff8f421d6b96335afd7d933d469670a1fb27a245a64c21ad39b97376201b1bdd5e0b74d42781fc796ee21e2f37f488979835fb5307ef397f8f660a579173b01da903331e982b0bd098695ccc82ca67fe87632ee629f5f1e8fba241b837c14ee148927739bdbed797f9586b6edcb4e781009f73581e805b5cb87f2fb91bd660b282c184e56474831146283df76b4760c1e8a5491b4594dfcec2aa5d7f72f3c12d668a0292f58aac87d8d562314f7442cf504cf626450a8bc9d2259d75496ef846a63d3622a7f0c26bb6bea3b9c82fa86ed8ec537af75e26f1974fc33c9c3cd5efd6312b7c5f66d80cb34b7f342a5e04e15f4cf8023b98ffc10e32527dbb8d6b0d884a8addb56f6eb20fef5473fc32f996299091bf39cfbe69cf8ae59e0e7a4a8a494ac2308d5c0de602be5c492ebca80dbe64b47881497751a2880571eeff1f873d3d55f73277366102eb5e9d4dfdacf7db7fb0311d8e4491848fc83fa30ffadd5ff48a7f51f0406fdab2d58dc639d8aa8e2a2bdd16de458c75e5362dd8ce1ec8dba6e1502a43fca3423963ca11dd265ac7a88cdaf7b632b532d624cec190ff05fa4238bf9813f92d04d9897bc5e54fae58de2841713a63a22e8b7e368525e03a9e78d8a549c55637083be6e79e20723ae0ec1f01239ea93cd44c0cefb305bc7ea99298643bb0f13927ebbe31cac4e065fbc06d522c61915e8dc64ade7ba1c38920496c801b2ac946d849ac302a65b451264048339bf350048b92dadc8fb555bc87dcfe02a3c0dbed1e728b97ce1d6c13781648ad8f1d07528f719a7f2b2d5ad6983dc6095fea2b37dda756f2514f1b150af7b1a0b95bd647e0545effe2040da05214ca6059675f5e4ba06b0172aa849da1ba576ee4a43557d80ba80da52d21f0e043d2fb907744b8b6c6a1e3a0abefba760179805f483d93690c523f931740dd576bee0260b2ad2ea32cc427d7929ffdc30bf6e518149c6d41f2817891dddf1f93f27ba3f59dd2ad58b6236b4b8c4614bda4159a7206129a2ab332dd5006cc3f5aeb801def93d5bcf00b2bfa1d2f1ea6329b98525b2f88461f2e557a254735a7e0d8ef30ae6f2bb0fb2244459d3b1220310e66c9bceb58557ec32609e2c9c81b75c02204cca625689f3fd0cb36bd3473ed8edeb869f1425b56becc6c61ba555f74a2d10d0de68ad3db3082a3e078923b24420ed2a2d8aab955baa02b9de3005f43878f7ef9159aad3999061b5841999eb8feb4beec93024b7c1ef7af5b9683e0132765fdd976cbd7b974c3e43f159392b7b516caf60717f4357961d5004d13759c4c8a29f57af578b86544725eac998a68cdab773ab36d0dd37bd602693c4d02447bc334fbced6cc3f82fc7e92774f526927d6634100852c73018b81154c4b3a830b534a718ffa16a70795451914041fe69aca5bde4f9a455f87a9fbddd254a2b2e71ef56c93ffde8ab5da937ceddd244089fce475a7cb7b58d510475f6f228500b703af30baf1dc3887c68dccacddf31c76b2336397a33db84af43030ea1510f17d264fa5fca837f4cd5003cd0aa1451e249ecb11f1628f361de8913eae63a9a536489fa3f9e4946a66535aa87feaf6146da4cd0a475a85be625ce7a2e718897e27e67f06fa0a6c7efc454a79f83fd21fe488fa3568b1ef566bf93a56f7c33f8969bb9ddd10e1fd817cd8245e7a9a71dd8cb27cf42b5023cdb589677bb645d6b1a829885df9ff16ba708391daa365c5f9faa3acdf8e7e8a15bc8ca9e06accb6d73f1c6da8550bcd0e19f36f24e207d6ddfe2a33d7bb0fb6edaa013b596d9b244b4eca0c9a5fa9a1cbfab3dff8430eb3bd0e8cea276b8c9cd6997794c45ac6ab971e512a261a2ffa0a616dbeab25e4dbc9a2a8cf6d1437596ba08621508f416adce33e0a171ec0aaf57b5cb6bc6a4f3ae1f64bc281652dbff7bbd13aa47d53ac2e1b981bf159ebfae84af389c43d6d89a6aa600ef80954d95cbe3b2879a9ebde83b3aea8816e0a701a6959720c97fe0c3cfdb2b79b5bfa2b469c35e84680dd260f1b28713479d380d08ccf3204f3fd4392235080ee2916fccb8d03b9c3fef628495b4fa232a1fdefc2d08c0fdf1a12c2ccf3ece11348ace5a0f2af39d3c226f23657ca6b05698d311527eb7ac3c9048293d1f585581a32ac263fc4cf54b7e0effcac8cc7533404075fab0ab6c2bfd1026cbd38e0c7aaa9e4b61167110532ceecc94bd93de1e4a20525d96a3369e4e9d75dd441b82a766ad80396e617633b285ec3491929a3ff72f3c1ee0c4389da6ba0dc211038153488135652d83a315e29e7d64ce4a0e79d7d184d8f429d0c7dcc8ab8acc3f1d18abf682c8c07ba9d4f6871a3cdb09896517aef026b01fcccca89b07f4d54bd7a6aedae427f3f8f677973f0d3e7de89fdde3fbf1beb35d9acebf29c407f294dfe1eabaf4cf6687b9a7ced6b83f98af8eb5a3ae88db595668d33bd4c35edd519d42fceba6796f6b8a928daf4ff4fda0e25675bdbf6adef1d6d42aa3716a262ed082dca2d764040ad8dce7c2aa734be899b239050309f770f9970ed9de61c1489ab932bf148156c8479a8ed347a782813261e481cbda62a377f7cf81a28ba5e35b6f09a19e30a54dd7698dbcd3c742e488eca0f404c74019c09234de551ad927f3d468de948204e162a97f15698548344d237af8c0a0aad0f8eeb3eb7638a6367cadd1153af0ef97f514856894c800231124a4a5f57ae308c2c1b1ee88d32c538b368f9928f2ee4b3543aab8b483954ada4fda890c291c9752bfd96f9077ab58d1536ab1401798aff4294a38547eb010b11bc69cb34d3255d6bd0aba3bf16f5026b5c07612b43c79151c33e6846efd09bd580b39717d34fd9de371010417dde486b087b8724bcf330b09d1cbf1c1b00d509e80b9e6f91cf94c990720e5ab57d7cc4ff41c4e17bad2f44f04547fad9336ab94d7fb42b048d8413972b45f9210ab5349362316ed14b570959c9cd33558f6821064de4b886beebdbed6826e33042c7dcad32205b9339581298b090c353fd5ea4f24292f27d40d3a847afd309e57b092ab4ce42b2d51b28ab24d00154a56bc6cb15f9f3735ebc13cc47c815fdc45aaa75efd8da62632d94d631e944f1e69254a040d0e0af5a69c43a626c07f0a7add74ce78903d49a90936b21369e4e6b5d8cbc6bb37e9ce3a5f608eea9ecc5059ba267504c9f33d18f8990466ad587eb7b20b262bbf96d2793375f690e4a6d1138efcb8589ce151b38acd63c4af4b4d12b5a5518ea457db02a0371daa9e134020d449c08f6f60bf4c0586370b5a248655289abad9995d5cec3b99f88616f3f909f0262765a6f6a2098209b22adb678dfc7f90fb19a9c8b5f74c4d6cccf3e7cadd905bffcd398f5b20b12df2efc960ff1a966b4cfeaf9be1c6635b4533df4d33e1697f51f077cbef3f177833d000e3eec3b53653b7bcc7ba8322e4e0e5bce415feb3c56246821e3b5078adaf636c1be5c3195cfb168ec72cb02d72bce7162d3e9b531021859540bb103d1bf1539d8ed224732cafa949c23495521d3c275048ce985ccd8cae355461a5df7709b0264465fa90c367d40adaf9a6da0611c4619eaf03415e428f67e4a95be05397be8f1e0ec2229924b8e24d1586acdc4925a9798ccebd1248ecfc9b8706678d2f04b6908b5aa30b181f48460fa9b6843e8f47b7df18f5aece2aaba99889833ed219498814d7b5d9b0d9450fc49f0b48e52f2b679fdaa079847258ea1394d39ab84a8eb7c59a93b2ff94f8cacb069f61f35858010bb3dde6b2f3c047e8d0026bb75f99075b8953f2d99c771e8012c3b48da827f98f44815cd0dba860602d8b64aeed2ca2764296572e7d1cad9bd5cc7f61ab23f6a4cbe343e3dde2913ee4c335294f8463533bb208621bbc0e8640312ec5c8b32e7fc796f31b8722bbeb6c9f956acc1155d561dd6add1ae5609bde6aaa0d328ac023e810e39b1215cbae5bd9e93ba92350ad3582109414193e7c0a3937e53756067bf3b5d4017ef88666c56dc4a145a25dda7ee133ab082a1c162c36f68a3892aa509d8b4798295899c898f606d43a4035be73e0a04fd39fefc2146af9e6871d7ddc7d35020046fabab9627b6509a391d6c6e8be761e6ef6d1e671294fafe496ff4894274fbacd91e0ffd78c3fbb11eda80580887ca46c06f92d833d1d3f22a2827b37fb555fc0c41f38295d1af0f5b63510aaaa9d8e7e38a917305929c35e0583cad5e29e467cbe3f789e87715a8c254e2a5b3b0306b328c906427daa946ab843c1cc1c6088971a6f639f4a4e1c3ab15eeb4976c55675f3c7b63afd74c70e7fc59ddc6dd3f935539af5aa7c412997ad20ea2a71ac28bd8120ec00c2368afa6f7024cc91d04436c2f775d2f6cd693355e18f67cfc94ff3ef88ce8dba0f5601e227405f6212774c21d355045faf594e53939138e28fa78fc2e4b2ed814cd122e23652f90431532703bae08e7415dbd0dc751585ef62f5ca6ef53007264ddb84c8c09a9c15ff6e3de4a2d7930ef5ac8aa5ef9e04b434c521eba6348470300a93836c1789ad5b7e6930d21f6ccd9292a253a6c6205e97edf62e5de49ecdf3c92e589680bc350af0bed8a861c949420f1b1437911fc35962b230ba16fd3a3a120bcc6461525d6ea698fdb68366dad7573dd2584fc471ed4dcda828d340538636d6162778ccc71017d4908568cfb0cc8cf9a221ba447590c10b186ebc908fd51d3d1b59cb93ccee14f3f8cc4c0696cd6fa329ac0cbe3e6d41de1ca0ab3e01565b354bbaf31d5fc7ffd7d0289603929ec9e6c3ddba9d7964a277838b3ce00b2faacb05cca4ade68b010c45699b0f4821310ac205b2739fce740af6f81ce946cd3af398063e9b7799326d3f3791ace6147fefef744b6048509c1a0f9cda7001e607e428538ebfe11bc73cbd9e92878bfae45682401d03d8d23aa909673c1d1bad70a45889c0a222d8411837e91c95091fc946997d4ddc53081bd1507e055889bba626b48f404fc7ad8e2cb8c7884beb60972c62fd4b14064f9532b7311f01bd54f3660f4840e927d581500352374285b5108a6667a93d8d005d63062be65c1a5d31f62038009b1e7e59db6b310688ba7c24a9c7f89d3e53d40e1b24ec3ed9df73238c02839e0cfa9f1a31ebfd6de5e165fef4bcebeb2ebd3e7220da2940c1ca8bb4b2d23933f9e834a94c79ec71977cc799e69cca01de56c5623f06877e80eeaeec0e09380d1cd1a862a28c822fd97e3108800adcaf15ab602e199f4ab00c0089a494e253c12092f62c68a7f78806fedcf7be2665213490aab2bd34065cca504d88f4bfc33138b8ebd582de21f03dd031739f6a82d091c1f2262be708fc5629e8309b554f024df82cc5856754ddb6b55b042caf124545129ca16cbd159f463094a937732141a61df19c38e64c49d92396964bd1eff726965e560e8861eac88c110ca58f91d903fe6161e8419731d434c4ecfdd1a4a2ca50eaee0df9faffa4cc4148b995e8e3fb305d38591e0b961fb89984d6db70e8d4c7bd1cad59b78619fa3589338a389699197c2fa1456733e963401a6b0a811d65cd6c1818af4de07e31c49471dcba1d983b1dfc850698b7ffe0915502f2133722f534f78779d1a25c1a37fec37576f3f2cdbb4e5bfc70b42dc4491b830b66aad8c156d3c0319f9af6361c6029094a7be3f705ede50164f527bbf37da5de979cca3dc0925d8b5abd7bc2cbf0db56d6d1061de8ebd54b20f63c3c7e0bdf8a7a42c4ebe7df63031ad87c15b7c91cd8aa975194aff529a688459bde9677d4336b24d35165a6dd61ec968cc19dff0be360ef0ec541d550013d9a1a9aa2591e0bdf85ca23657527fe73a950b4b456f08f06d3e22ba1eaee9c8cc2195a04cd87c1b9a9af5ba3583d9abbfadc7ef4d1fb96fd073edb0ecc97c5312d42c8d600cd0fc54ffbf66d829199d0ed5be42bb73700208aff015b5d195f5b2f1e32a672db2384af01abeb787824a18bc113cb56f14af7eae5b8ec4d0ea2ff6f94461609d78df43360c738c76e8715911511171b7757040a856218544d3b31164ce2f93a68fca50dad40099eab588676e299e78fb07a17dc0afb6c0b136a0ff2c4b91230b53db76787d8b80b28f31492327a7c66dc44032f2f707baca0a125ca22fac3172b374ee903a609a56df63cf487042041ef78d80c30322110007834885c132b34ccf0a55fde91023543e51790e706f63a4b1629954368801f1246dc5c00e4ab0cdf4f1d694a3fbff66740e879f1a7d7142ee8971fd85eaf18b60ff17ad013f008442832d47740567e074e618bc02f9deb529d84870952363584e5658e6940a035538ce2298f7b37c58ccbb4346000dbd1516a5626f77cfff72c647ebf9daf0e304471b16e7794f60547ef9b83fe4b38e5f8c56ed0313ba06bf36badda9b790104b7fcec256f2dcb0d346ab3dccc9df9d614a90ecc113e782c80f6200b70fb3ff6e8ef5b44809429ab23400716e80673d63b4388945d787507364698e369ad7e7c522f069a92872f15663b65caccd54b5d6963b710235507c8e025ef24efd3d472c9965ad62d8a73c907d71b0828a73b199394ed3c010ebba69067f64dbff56933ae7fdae2dab41eff9e22849dc3074236607b93ea49053714060b5712d9c281b1623525b87ccba8afc7ce069bc14d5df09628aa318a32929370cac2c5d4f69d1aa8ccfce03e508f1b4482cf393405e258e162abb4bc2b7e0ecb29512b90d01a5323eddb48fb598fd0c97a984331382431ab925af9fa3c0777a2dc3102bc3b5ef29b27208a1e11b00b7902ca25774810c2a2b76febdd249f6ba39c3441042bd1ee4f39fb2144d75d31047a56efb80841b109071c6d2f99ffc5efba1fc6a5c6d6f2da5f7481395ec8c56b3aaa0c081c9d7fee757228b32690981ee4c33feaf04608078caeb533ae224005c958964368fec1c86bca37cf81908a05f098b4bd268a2f46207f811b6e0ce81f58c13036d43fa5de9668c018e131dfd041e1ce96e4e5caac247b867376689676c71c755a19972fa53661585876dd013e5986b16f0871f896781cecbd6934e28b8b466c5860f7926062a362c364dcad4bb3460da4c8e07008cdec4e0b88576ab8a48c022d437f928c2ef1b2b18fe012b3ee3f251926e379b2d678f97d43afd931fdf4c133cc7597d053a63eae332f99bb71d921b8666063a5ce453e9c21102a0d1ed879654e11857f1237fa45fc43c0f9198298e33071ab5b492e64b7cfe5971b9fa84d4a73c88b9a55050e926b0cd86c35fea98d027ff0fab99c593c6218d279a31ae0cd29cba5d48dc4af270949699614b06b06f6345ee1e3c90bea9c2e312e928a619a9c3130f8d1703110456ba62a9032f82678afdfdd0898a305626089e16fa1c31800996c6e6a6aea5c218c19114f145f274d992af72db1bc3d5fa42f948872fb469e0d2c144c5db17dc8b4c9e1a47f7fc34a0e0255a575a826b85aaf252e9f2bc8030a76897696fd63947a1d2547189fddb8c82597f1940b4531f6b938a0a6d8a14a7363e5501ffb360dcf77ad98e2e7efca0bdd3fe4858eeeaf44bfdf3c317bdc8b0155ca2325ac7b20bc86afe268d3c0ef40c511a16788721b094682d9ec24d8a175e6a71c6cd31fcf2823dba69e3f3cf4b6b06ecd72e206e9596a7cf9a4a2d194f730dc7c759fc95d9cd3ced7afbb44939e32cb0bc56ddabcbddff656bdb911d03f2a6b88a6dcba4a6b82a726c8dc95a2a950c9fb9c80e1b4329efee7164f6a5c0162dbf45cc07ed14dc216569ea6cabfcc12284635e08f60888ca4ccb808a604300a2afc913ce8fae991c1b8e7b7730f62d4d2468bc6f00b9fa3e263a6e926cb5e5b1601c2348194939cf84c673f8986a41ede58d88e8a80252384e7784401dc9c151cfd6a72ea6715003de23fa6c3aa63e45483f054fe92dd34ddcd99fb1cbb45c703d04dec798a73b24e8f79d4f6a68b64dad1efcfd607fafda2426001e8b7de253b66c70d9f1ec6e3350418cd96b0e0a6cf6abf6fb142305ab90fdc89f66fff539d7d87ed4582939cb65f33e720bce0142f9f700f6c6943753a3947fcc7e7c47b555353d9f7664bbccbd214fca984227166a7baa1848b01d0cdce0c9dca1fe4c92fd3d6cf664adc4bfdd7abfe80c0da3b9aa36da887953fe9e6546bed4e4aada37c390f4f100681bb90f703ac508e994406d9f534df34e9c3492a9285730ba3ca761d2987805c1172619aba1a5ef7b55f73fbeb42e614c7cfee506edf9570cc2b1a13f79f40a9903fe30330c4b6584cadc6e2fa4d19f9c2bccd2327f8443eb0784fcfe938105237b9b43a56dc2bd8a803bc064a09d06d1762870a1814a3639941ea6b3d9133aad85e15829e5fefbfcbfa811caea617a82ffe72fa58be1e656877ba053f7dee1f027c59d3f4913b218b403bde8bb4a12209b6dd830bb6738bd1c447860a1eda67dbb68639b22cf927b6e7a02b589017e5185c73bc472be3e7471ab92e25de7e84b556245e935742480a7d056694dc9318282bd1cd56e40b37af783763eae4e353f09b1f309460b3b96cddb5b7f07efd3625d9399ac63aa260d29b7611258509d5a4e5969ac704e414a0096b4ca27b3debfc32fc5b24407c0e7e5bce33c70feea9b17677e60ad40c7d866d20d001332d2bc0b3fd6af49f18f5aeccaddedf444f49c221edeb9a5bc3d57d6e5dd9cd981867d21583c772b3db81c33f540577675626a5f3e2cd527763502d06725571329ad66182e89fd8d00c7cb4ffad23f966c9d90fb5099070a5caeb9eb485db379e99ced6a3720f0b77c547a0bc780ce62a99de7fc0a9378cf745c168d1efd866ec425ac370fb2dab6e96296f810427891f2d81ba37f56f4523ade15ffb745f02964a5921916ee651994484fdf1c2a08226964b1538c9a323845b0f2741c6d110600227d51f01378a4406553c9878812e8838fae6a09de5cd805380fa6f13f348dc386977f4ffbc65e4eb2e098e6842b9500fae39f32cfe9ef46f840d53ddb211885ad5f6ede35f3436fc239ef61aa8372dc2ae97b1681b949ce531c9c4debf16ba706dc6096bb187ce791d7358195dc526378edb7df4e808997bee7cd058b4ede5c955ea4d58b2a68ad03b9d43ba40d824f5eb54b77770c497aa61f57ed1d5dff8084127d418cfe8e6b69afc5cb01aeb8b096bb6f308406fddd920ee59c033f5cfac18aa720b5820b89edc63324ebdd4f57427a5e91b6a685f755605e58c7636d3dc2869dbaf84bcd3825d91873b451653e38d8960b0651e1e369884118481fbc14c4a4b0cd831eed43c066e28b4dee45ffb00517888bf9499e397482af9003e61fd653baf2e3b93fc3e0106b87fb051009f30641d18b411fa811f73cccf1ce8aa98fdf5de9e525a465d4bb6aa7a1f914df5595713481d8e103bb1b986332cd48099dd43c3866c586f2ad8ab158ebffdfaed7a16dce67af865d194b3f591e2e8af6727f8f8d0c6940db6d222e773c343ef79be705ffff8e8a8bdd457dd299965c4426680490e5d6aab637b0dd11f9f08095fecebc287272b6e5e9bd821626bbd81574c850e6794def14e277bc85f011a9e868cced4a5755bfc973a1497587d3477f2c9edb6940b0da665a255f7c8213f96f603c33e3f6094ce0c99d1a8490ee6a3f07aa665d21911099784a7c410894ab59e32762ab376c4fba86b6135386140f58d7b80253bd23a909719cf78d703c902b5447f6e71602069aba87371be5cfa8b890134422c11a3fe6285695355018d1d95c0d39c25a950e1a6f73768bcf5c670c43559e7a6311674eff089512fd0815d1a88946579d555c4f09b2d378965034e0822c64436e19ce7105c02d4c2d128b9f1c72dc4d30440d3a2bb0d462ad01caf3cdf6a06af83df159f441010e69117e7ee76ddc4bc95a7f8786bf1b83fef361337708fa3c3db42352f98e2fac9ff97b8ac4ed1fc6b7969e3ac595dbd8d4182617ee6fad713d5645486f09f2b35bc31f94fd2ccb65860e9f16f36512179c3b037b25abf0595f72fee07180759a58c716ec36b3646abee47e33879f28cdfb00b9cd6e73dcf3cf4638055bf4e46728784b42736f32e2839054621e636d6bc5f0e891015603581e50f3ac4783758521859ae1411bde5d5b938a2dfd329a2450088f43b21ea6e8a9b6a2e59da30109c1e102d5a98388aa7b5fe06f89a3931ad907860f8240bd40ef8374a6a2655399cd69c5aef74dae80580b56d7f8cf00ebb06de5283be26f38f3bfd788fc483d6daaa0f301510cedcba702c6cd643935691f783805308714d34e68a374c4eadabd10d492ce5aec61f2bc2ae86c8d038830cab5975b0f691166fe0fde8e17c79e45916b3fc18ebe017f559af4e682ec6edc426535a1d7f9b116cc45f43c2b678bcb9dd1eb18f415568a02c931411d6179e906e90f8f91a186f5bc61a2570c837216822f89b0ac8858b71d969e6a6c5c634825e91d61c8ee1e6f40fb1bd713f4e33ef85d64ab12fab59dcaa19b5722669d6a00a536a49de6280fb8619ec8cb8e48c9c1172d8b490e773e424c5982ffc6b9f56b402564cd89c5e97162fc7f6f41041b4b7227f4c71da86331cb5cfb364e503a3f466bee43c9a8125722550ad77b4fee66b660e258fad717f294492bff4df499cdaa2222e11229321df52f5474b63d7051273ac5ec610ae800ec151fee911235df395c1ac6b4c088721ccdce284545fe145174dea00f2b9cb699410a0a7b699176b4f163cf3557a19dc8959df5fd1f8c3baddded2829154157afcb88b8c602c828decebfe7fcc0ec7eda6c487b459fa81c9537c314844d6c1cbb5d54143188c015f807ba3baee2d2e1b1b57a084589419ae2979c74f1441b87ba8791c98d38e4616bc509ad8864db2e0f695f7b47ee5631ee381d4edd529588b5d017f448a1cca992855b84f093b7ea4d9db24d4f9a4cf9095527b6456a85d89ab0c4d0cb0e9ff6aca2ed173568d703ffac658cebd128c5908edf887b081b99b7344aa783a0b598d5cc68dfe53b2cfd0ef43ed82fe5275d57d254a5ce60e759c1e31c669418b9d12151bfc7c05b4560714c345d163df281b05ce72b5dc924e4207f19a7b3f7097fbdc0e1085520ada0c75cd3678b74b77535f0fd3f554cdf3fd4760361296db626d45a3626db2018fec0ac8d03a91da64b0f59a3f5ac10025a6015d35c47c4be03ad5d886de2b9c06076b43bd3f1f5d1d4fb3650179f18f471a4613696051bcb9e15a05c0398e64259db727d946d6030d2a2ac46ef3c7e73f79ba650fb7b9817d2cbcf552aad4d96f1a69fc50154e184202be9e35737167ca40838a3814e30ac794eab96e776a6ca076bc181bbe06ff0007e29fb3ea0be8b2480c81a5fb7ec0a9aa564d54a1d126f03ca3a5b5a630e852415fe8defa7c7e8a9f493d3b96c8ca067a56007b71ffa7bf55bfc2d4bc24da29c5cc5e4e606fb4f7bd96b4720f7b47a3ff79f8db60c4eeb2de123b0d99fff5c8012733972a202688c3cba8fbf8eb7fc561cbd55fec76a033dce568e482b1e66935e1d034073e90962f36e99ae4524279bd851d363e2fcd0dc68341f2cf945b7393c7615abab5abf8cd23a24535e6dba9689afa4bb4ff13009640fbe1407dbac4a4edb74f6ecee55c5740ecba17b3d89a5df81ea309f21ab6e4a8bf05f50a4190846a1e2531a195890514bd5dc5d93dd071fb7033f66d5eae8287941bc37ee629c7ee0be9981b48321a9ac4ae5d484894a55aa7d8a64077162bb0fae675fcc9534bbeff952543a709383d06e831ef6529d8d213b2d32da737ffa2de937e9eca06e0d0e5f481a5cb5f06fb743afa57f7581f54d30bb0e91a1f5a882f02baec8b6e9392f862b37fb6ede646ab5b0f812244bbcdc61c3daa6f0200517fb61a1aa97a85b0adb331f1041c4869cce4a5f61b1a859ce4e2e3dc93b1a14b1b7a7300c8f607831f2a979bb124803b77f1406880b05ca6d807d9ebf50bbe861857038904e9c969533328b744cf7ea5cf719c86a192d0ec02ef5d83d2f92419eecc48277ffc2df91de0b0d7b78b222f6b7cfa115cece1dfd1a89badb31ad78e6ee74ece8f2e0f9acd52a71040f348cbcb0e8fbd313ba5a4b932eb4ae16a0df3e01022d712ec9ae42309b168033ceb56d67accab62a5dc3cfb08a2d5911c3c07a9541f1a6f5a291facd222e84827b12c8aad341cec2c4a1bce6824162f866780f7b33276b17310ed0cfeb5093db3392f71f8a669d00f478ea5af5cc6a5c17b5f8457f6197979725db4a70f64dd87feb33788e4fea901fdbf28d8b14548801e1610bb7cf85d3b56544b1db6321f8e133e7e529ef972f9f5fc70509f9c9e4dfac3a981d70bf70677c896a5fab3ebd8fa3505f021e3d821cd328ea665c496ab58c1ce0db366ff7e318f81a363e2db972e03eacdb24f2dae43440e0ec96642af4ceb2b33f562536517bec721c451823d216e793995545451abb2938fb2d8b8960616a922cc521b7518d03fea512abe011527e0c076a82cf8f911066c68760d753d12170483c21c642ed52be840b41fb2cd1fafbe1f89af3f9a9e409a5bac5a7ecbc585a01d8fb03588e0fe3d4d4b007775273dc0ace1c407ac552be27bd53a24041e6904ce3952","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
