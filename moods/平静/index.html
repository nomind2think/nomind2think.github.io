<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9fbea7894d5c7cba936415dd3942eb74d449c8aa59ffde4e5132192523bc2e182e45b8c0c627349c95a9951e13ea2438f1522d1a9ad47a99da9cd5c9e2fa0bb5675c07974439568e153fb8b1336bf0dab70129b2526dd09385b4de347014cc19e25560df846a0932450ef2845d1693299f76f598695e63baa88d276bc62946bedd4c0e10eaffbd8b2ce084e1138a33ee3072d7e6dec866f5970434da1a8e6ff4255f2cb34f579a9136c1a1739d6edbcfdc6838d885495b1926cb72fcd7a4205011b8bc845b41a7f3dfb314d6e32281fba46cd73500c40fd7feadee958344c6fd4570f49d39743bbe748c11de389649b345712f478ae0439d7dc069ea74181c5c0f85d943c37afa4fb0d85456d12371aa6cf91ab562dc03da58934856720af4b104e1c6168b73091c1f36b2057fd57fbd19606039748c3786583c6df39f2c34b152fb7d057c54b4632c7e445dfa4abcc8dafac0f53771b84a8e28047e039d91c731a43c3215b8a257dfc22135c88427bc3243866210cd1d88880bb36029795f40b7f2b195dd7ea1d78cd4b8ae6cadb3039d206da317ca4a4fb50105838b9eb501a6c1279d15630d907802dbd81f9193454916df00f8759218cd0f07627a06a4d2b4120123ea3c7a5e8c9b3c71e6a0f436263b5465aaab5c287bcc71eb8b373bfb56b463e02f22ac2eb4a52dcd29f71636a80da0608d484f68d8834110abfffe61f01287bfabd4e2b0c53f64c2b1654a8f442bb3f4c4b13a424d60400f759c38f46cae65c284fb71b4558c912fa12a246864472575949e42c2d291b4a8cebf77502810aa0c4154f17c31becf8edd201372cbd7011ff68215ef44addc7c16a19f16c29628b00f8fbcdea98349ca70f6ddd6d276d99586add745b6dd7590f1f993b7f2d64e3cce5036bd78945570d1459aa3dcb6b14fabb8ff80c6a7a78783195f73e6e476bd0721f6ae7ae7229478f1d72cae58557906ec46c31ed517bdc410fbc209f7a2cca1c826f51b84b6e6384ec32a7c768edf5da477279f6391419b520b3ecb4f3cc1ed0a7080b9626dda5e02d5ca06ddfb3ff7fca88b8c9bb81bb67037a60b8f5c4f7f8ba7d3c3524fb8337b56b674a5996e288c46860c24fb7c5d573efe57f1c433cb4a091232aef9a25954a8c797f5f506f50368565be48e5ea344645b147bff9208e04f3e95e10ea58ecb5f072e54c5399a5bdaa11c5ce5badc832a0f877cee72d7983d3967ab8a450e93a9f7e879a41c4c681e7618c593b5743921a51c3aa3cf672e4bb8dae2937a565ecf7241cc1688be685b14a385e18daa30976526aa3aad04aca7baee2facaba1f27905c2c122d8bfeb7bab6f6a05d409a5099216cb3e46f6c30f9c48f696adf0f5d41d2c9d6c1918eaa4eaa4514ac68f293071a6c710b07f1dedf59486f963e495f76077acbdb8d8f9560b23cce2c57f5197d133d24b35c794d932796aa5f666bfe7dcdd8441e2d3df5b1a8bcbe1689217f76b78adb996ae15c005b6482144092ebad6af85d2d0b88b44f618d111aac3e7ca187db079529d8ad95336e7f74fc21b6b2b04159c4140c32ceadb68c44c95bb17c9368c093b1e3e05384d82d3603181b8db279fc9d73d5666e6468d80d167a2d519b7f17bcfaf51aae0e6c43bb80bcc3d23cbc7e7223cd6bf49016a03b9f015ab51cd974462a57bea2b8c891662a39426c9a1f2713cd6f286b6d12677c2896218ce7d0da51820de684a898b0927d2877e56dea01f5b8328ebf7b6243813760506b8bfa1e56622651fce921a771f4023b992e47db822abe4d1f6d55b547a0d1d6ab3d50dd7649e8ae7d6c00fd9b48734879537e2b3acd74ce69be2c302828e0a44ae3713c9b0b4ffbfee43da069661ae4f9733866cf2a215ef8885a840d4444efbb39b169d2c70528587523d28bbbb836ee45cc3c528e67d00529e8cde2d8b3892e6dcd4be54e0184f4eeb076f17c42e34d8126a05c6bc5a53e228923ef19b51efda8ebd039399794752fa9c6538a5362e36e84e374aa8005e3ac2a626ee6832f76b08e10a0ad7cedeba0ad402accfabd5520c7378d36308f70cbf840514c743ca9cd083ca7c3e9a6e7208e046697eded84ced064c28e5672bc0de97ef92557babb27feefb19e29096c9a30d4f0d88779adb1d09e251807ee32d1d90274d642b5eb8d05eeb38926b4311e1e88cbdf0b23d14287d990e1131afc38e19b14be7bfa8c1ad09a3cd8a47af015ba51875b71be797f5cb261549ceecebcb3d26c9cfe64a65569af7886ebd802ebafffe3fd84d4fb74aa66c3926905dfa020463d72c41e3c5c63cf1d1eaa243c399390f96809fe498241e9c9ff9914e3377181e566d3a722d5a9a5e39200a037210dc9b71d9b05b493a08d4b6f3f6e4d7de3740b14f9114dc2d885a690f40731e668ba1c2493eaa3db04f4a312db7a724e7731204d8b3294bcf81c55176a0b1c1a5284ec5f58f743c97565e33c932edfa01b8351b4c5ed21f627d58d9f0fbeae25cfc65b541f946bc9867aa1d8ab2a197e036d1ec83eda64879f7789949f29e10e2490302b8cda7720c748a3694700f5e2942cfb00c412cbd300824d832909b0399e777ec8ad191633369e79c9effe1629acc2588d71f28fc0b0fee8d779ae0f152f2198defb62ade3462b838c18ad9032893e699d6da58833a02fcca367745307a1332656f1abc8c2c62122a989f94962bab2dfa9fcdcdc5dd06077e1a3e09aa5cc3c6cb4410c7adad6f288b70a7a861f536ff0918c17407f1d495cb8cf617dc7a82f87e383f03deaf9471315c007b29e4f0f545e3b3dfecbab0d6758d6d7e78d553f9853ae5902f7322f6e43629cfde89da895e96508b83c8d61c79aa4a04e15c94e45111103b7594dd2b34a24781c206a8f068e132cedbecd450bd5e160c81e3cb7008adf7b3aa94bcbc36a53aa8d70d4fbf23e639ff01fbe0bda679d44dd096ac647bde6e60905e1be2b8f7a1cc87404935ec9d23738a38584ccc42709a6e28437e3efbe42e98a150444390e3a700f546260a30f780d0674f15d926d9e3ae5c66e0681198be3d5ea966aaf25b86bc636f9bf03df9b57bc197dba67ea80ba197d941c8895936d8e22c2a9be819faec1a47a6449c0ac45d8d6455b006179457f2c0d2786134f601855e7d505876f38ad083aff9bdc25bb0a59231513c7109294f92fd4a6802eeb47f3fe27a3e82a7d805bafd08c134e28f34e244a446b08b719e5b37a7fb6e50479c0cc91fb75de8deeb240d7c8a98425018867f055d59cffdf73abff21ba545fa4ca05b2fa05514794c456066ac017ad576d0713a0ef3651cbb89be5bde7aa57f512964c567260061f9f39874bf40a8b65871ee75f89b4fc378e635c0cd3b4c5e6824af8edb1b34ed7bea30a6747e4e4e71ba1a410e528406fd4ec5de20cbf1a4cea035df78e74098155199fad7e27a2026079dccee43921ab1e55f51ca501cb39a50bee2854eb40dba4812c8002878913735c57676e9857a8c8bb3de41cd1b87e0ca049099c22cbb3f7e7dd7f1c3dd3ce0b36c4c8f9e71f78b6ea86b6b2fb390527ae8cac8a3c12bcb3845420037f9c3fbed7fc945bfc9c19d625b51ad70db497fedccbf0319afcefd1e3b874cf1e4dc53a6227a1dbcea422676a0d26a08557c2ccf2c4806c83fa46cb24fb897316d015ae783862f28428e12b22fabfb1c7905cb6bcc040cc9743174cc44257d01b7d2412179efd42afdab3cf12f79a25a94b056d50f29bb1f235f286838c352c72afc7bf051bc0df4c9e052e94de7728fca5182681207dae30d39c5c3c274934c601b9edaa469f109ab455a1be7557b224facc62566a9e1a68a0e65799db1a9a70e44533d6653cd668bc9c5a3613691b0bdb86958670dea35f74dc0e3d2c67b44a36ff685dc14dc93bd5a9b328604de3474987f8823a2a946b74b12fcf247fa3a20bbaf9f7d2dc2bd0bb94f4b224203ada71e7bac8c8813c437300517f9a397da6a740f34d60cc687b6b6ebd78c5b07ab6a87dfe9bbb327b3744015878d3fc9aaf16569d7fd70abee693e161943e6be6b176c69b067601904cb432fe07030a53b6cb2137f3b1e9bfd06fb7dae0eb7b4e775dda882b124cde8dcebf5c1276b0827147878cc2a8930c563ccb3395db22c13d37f9bac1a720b72223538bfc5a545213c6b343cd4652bcc86c5de49bdadde466f99118e7d6e9868b087b754153db6b05a31ebcaf3259e69a38100494aa50c0479ee35e81b5bcae26a6a647a66a1d5c0684e50fcd9ce7b01ae5bcf6ec514871856101e244865bd2b9f53370ba01130664d673b80a386511d17a70e2b17a678d12f6d2a5d73d52d8e9d4dffb70fa215b0eb739ed94f80fcb7bb3c10847f01221d918f06e135520bce5f64cbfff391b2970e945f9486e7b0fc544018b1a4cd2e933272332395be807a36f24db2c7183967bebf7e44dbfc31c335ee44a38c052d5e929d394d9c99bbcedae404dabe80f44188b440491ab25b54e66d89e9de84bfd25dbd5f38ec9b65f1bbd2c96b3dd0688e5cdf3be165d2b460a7544a425f8abbc063debb2ebbee903963e50ad48759ec7ba70344f4093950e0e84b564aea732e89ff1a46d4b57860197658324f4353032dd2e33f0a6040d822c42d3cd3d67b7488f3c550f501816de89a8e87c8e2b085eba2747367b33c10fede5e175a7bb5625e181ea077161b242fddc60643f3df68e5fb109961ed33be7939a6dda9a52da5b0136d59c557a5395eb9d36728fa70bf988aa124720af26e7f1e0959fb32197cba75c14ba0ade09f8df21841141571c24c21a70b0d627b592f5d2667b32a93a41b4cbd023241751e0fef5428f131466dd58140c0a1e07528330f44ddf78f9e976db049439eba49585eccaea7314dc12e019e7c0e0607fae3499314878a131b111a43875719b5a443da6493a578bdc127ac5943eb55d3a99752c4b4f375dd7d5575a228c9252abbc14d0dbb1649aaaf5ab7734e0bfccc150cad5a227b34279df8886c4af2210d6a359050a939963e77ddc5a84ea1ed33540598e1492ebd56c4508e06e6370ee073318e3754bd4cbf420d77c31563ddff5e0837a6cdaa80339a75ded74739591b3ae2e5348ba365b0ed518e2ebb28bed625d229343e69b78d1651e187912afe7817ff2f337a3c121ab51beae7e23a3961f26ccb74245942f09faf671aa06d5cce4f40e3692ed1b7c18ecc76a1ade524a39aad4b1fed217bf983e51be5503a975af3b9ec9c6d59e0d542703d1a6c7f9369d7362de33f3ec6e650990e0040550b12d0d99541ec7b49078b5d64f91b3cc6814dae94fbc2e8a580bbcb2ed9f347810c64f55f5593c66197f2f38f77133dd5a30eb2e096d88df1aa84fc1db4f2dce5e7b3831c8b27c62e2823a9539bcbe0f345e4505affb64c900b92719194e12dbc3e26013208c027b797bd4ed22831ebb7035361b5cc9f5ed5b68dd8d2317cbf1cdef724a771c408323f3dc05057481c9fd36c60902ebd7d95401502d7f6d734e5d38be3c0ebc97922b084574ce61d5fcc88f615d408a6d73539fdd768101b4373bb6a0c679f38e652b97555089c15fc05cfeff66aa9f32d675f8066765363b50e29407b036af2c3fd0deb1cb9fc12ec0903a5f8c9ddea9e0f4b869ecc4b4e17d6c1e881d77185ac8201bd6d668448e85ea414209963e1b7970af46b5159042903d8ce17069974646b52c3855940e0efdab142e57fb4ce9df91b2ef00eb27b8f6f650d6d427afca7441ce9167e06408aa5bef6e723c0118e1a346d4252b2522235c13aebf0422529b99b45ea16e35847a887f55e9348244d102161bf5f6a6838c4933bc52fdfd76403a37422e97236b3be45aa1de52bcb24b58c5ed8c632ff4131e9854914054a0ddd94e88282d8ea23763eea3a26b55b8ecf5be63305c307ad3526d732574d126f1d3d8e336f864e9b72db1f78a070e10b36b35a20ca23004eb504765fdcae32f9efe0279a86496b5b9a216c751e1ea91d64d204480f8bef48f4036542bdf52648c80685f0539ec316d40ca33539d31c3779f0cf7cc3da55ab8a6c1bb29b305082fa674e449438c42b23f68d86e2abe8ea06bf138725cd1cff6e98c61e5fcef11035395da853629923b9f8166ff1fa88bc9e46092d63378a8952b4533b967d67e9129e955c5aef3e335b7fcc9860a0df87e293fe99e86951baba023c72909a3052899b95164fd90c4a0f31f435bf2fa6d2155b0f1e28188766685625b3632f2fc0e3444c896f287ac99f5452fedec78503a97b41343d9134f5cd4c9e7764a3460df98dd89bbe3a8b73c87e38ffb262c390cad98c2009f2803ed978917af4e0c81d402451cb7e170cdb7cb324416a512f2faa268379e816ea8ab75f5232b9d1842e55b4e72d9f75bf98f8849e06c2694dcddc91a8500b3afa38ccbe3a595370cc4adcf6f0ac36552bad4e95e7f4c6a2eeed831a5c6570317b1465d5723aa92481a3a19eea79716212998748c4d6edb5abd5ac8ed7656457fd00beef3413f4c1a1cf21b0f9659ca1d8772312d5a1a329e7e8cb08ded888f21371a7d13d723d7c9b9aee05a01eb6f1e29369a9331e55ab8c1ff3d46ac7eb71c629566c1524beaf7d2a53c417d1dff7b99dc097797369b1b8b75f67bdac3207ba7ee2b80b13e233db852bca1a292cf903e8ba1d016bc092ebf5aa36d1b70dbffe5f085933eee274dee3a8bdb9d541b23b3d9bf1ab3d4e1895429e66e3501609cf8c58becb462f09967d9209dae0ee3e41337e9979171062ca14a5dc74b71b862832ab7161250d6ca43360d9b86da2b998bae239ca9db23b5e6c53437ce230ad6b2d9440d215557b5aafc341008708298cc4384c58e27770c4ac40323b1867026b2080afbe933e98b4498eb7672531b37c602993c80bed2f5c52eb2cd5518147d939e9561c422770c403e356dada183eef1b913833ca9c6d30c796a301c3a0545654d02b54e9114fad9d3771a844c392f4771fe6cb9e7d174175b3c1d1804b4000abfc4d3b99e2fb6a1cf7cdd0122cf02d077b1dd0d8cbeae9a40b447729738f64a664bb2e3f0be8b292cc40d847d0992d532229383fd1c9be9eeddb2e81649d7f9662b8e5e9282a76fa6ee99f9b53398f864b4b635e8d684e4facd6b006ffdb06a590e238fd70a128cc21e9bde5efbe33676bd65804b7a81196296cbc544e85fcbf2b3787dea7376662b76cf1f0ab53049cdf849dc9c36c841357f14eaf5900a1e545d7d38087a869959ed2e79ca0b75c9d02a8e372d66988a854ad45a87ce3076d4977aa1b0582b9ab0678d25be556d3360b90abcd232e6049026c4f9877356998bc4d8ec34ff050e4c3a677b48288f4d0a78ab77b19b2ffb001f27721c7308878d1ce396785ce336196b37d8177e634468374c969a7d17c005473902e908bbe56299484a1d5fe997a2bb7b0cc34356ec9dc5a4f44fdcc78218f54f4eeeacb4bbca41f881522f6df96d4de497e337d2d636890952c81fd733af7dd55add6e6408baf3361dd1bfabe2ab74d39b372e733870eb688c2620c8ec97e81a747eae857194176811b29dac3c019c938a0e57a3c59144cbade29c52839559f03eeeb474439384d0a9499fd65e05109551d4f7715eee6b52e9a42f0453dbec57f32fe812675410036fe61504a50a132cccce67e8431352920890dc07a4c30b357bda38b1dc52904ae9ef6c51293e824e49f9a9933108774c2f785448fa2f10767d6d6a2644d3d832023354375658a0b10e321a5427d9ac1ba204a308c52c25fc8711598fcef691b38f7c38e401388af104fcb6668269f79d9897b26dfaee0cba42fbf48e5af6f6233f0b108a97c14b35dc15f7e2dd97c3a17212dae8bf41494c1976349272af7c77ce521c0158f90ffdb2587f56495f6ad6a5ae8de52c99c5823e4c47823e3eaf62cb8428bdce9370f8916094ad1294df5b991c46cf4ba022c3317de356108de2a0c45acd7dd302a80af0c052a497335b0e0e436ff7e78788035581b2b43a64aee007517d5ba634682efffc6c12bcb2c2d794c1ac9fdac0d0af9c4f28d2fd85bd895c2961ad8479b82dc3aef19a13ec4c88f1c472efa32fbe7379257a3360f33640a93eb89548c45e00bf428283ebf0564624df1fdd637bea02b247531a2d52ffc16f1cb500e82546c8b49e22c7ce7abf461eafee85a1b7dc3b3da03008e97ec40bbd8d68a5c554355b6c7ebfa1438d0b5fb6db11d1b861d946c8998bc6c856f3480188e93f02355d256b293962c9d6ead499d57bbb8b5882f2fbeecc965e90ba12265ea372cde0dabf7683b7ce1cd696e405f1270ccc4a036e24ea6618eeb2b356e575044bef1872cb8f1407bccd317ff3f8b5f22efcebf3eab2c7c43456a4426155d511ebabfdf9c353baadbf357d1f8db9ed05b5b5160aafceb939a743fa77e2cc09bf963c9a1f42ecedd373a432aa32f66fd0cc8bdb4de817c8f045ed6374895b14db3cb86a88c732e1ac0c44dd4888bdc9a883b2d9d4a18d9c428d87484e9c8d7769e86cf08dbe0ad40d80a2fcc232fdba67fb69a25ead863d6da8f566aaae51e5be344e4ad657378055a553d525cadd01e4c72fb9a4703a1bf3c81d9ef3959e12639a9470138272b0fe6528fa136ad11748bba6eb43626014394030182f6d5a5ed43fd4b007766fd1b51d34dcd3a9312acd0a57120714747467a85d1ca46056b4358d079d4fec39fefe5273882092b740cbad6ad99ee42e80fbcd4ff6ddafd20726fe05d6c3c2063f5aca1eba4b41bc4affd8f1b320f734cd996aae0266518ba1bcdad9c94561a2e4604325dbb6151e7d2d5bfa5c0d3d8f18b2b8a699cea827d899a908f59726dd4eaf174eee5a691ba3fb2eb850d66c9b2b1446dba2f5f1615cf1c73a9eeb4316d8dc102f650ba103ffba37356fa14e3d5ca24783fbbf04c16b10e7eefba5f8f3764c045dd47ee621054a8b906657cf325d119bc85115738cdbf068ed32b124512c4141796c8ac1da834ee384d4161c016ae86a59f6b947040c893e84746d98447061f6f3d558338378fafccdd340f97b2528d74718fabf95232223e0c75e6e1db9f0b05f512194ed323e43d2421716f3039050009a7a37bc3c8b17aec509be909b615ec4b4882cf2fcf2e37806aa1e4fac2755fdadbeff5382bb919cc9db63f073f7504161472061f2f3f36167fbe3c7bde61f071c210b5f4a5fd0f58ed9910f1d094cf01921834ec135c3fd480d40e0c28acc5df6ca2743939cd7989f995bfc7fb524603bb18de843a40c08946f0655786fbcdcbbbb7f78f8f98da634d199811b2e97d61d3b5dba8f4ecf30acc252a2c6c0f883ec96500c3d33ce125dd6ffea0a43c3ce75326cf1aba2719b13493f6554a3c2a2cd65e5ca43f42228b7fac6102b0d0ff8c39e5440274106d174b1b08a557dbd26581b388f0090317bd13e8dd8c607216a8100be89f537d05b09d74e1e3c89c5b5c7b673f5061180d33d716027d7b0c833b6284e72473459f75571716eaea92b75a6caf9054866fc16763b851c83c6f96996a9a2541152acbccdefbf5c765c3b691eb29d8a2f12835920f63f736d415b88c0d55dcf7f49334ba549b49e2f01b2f4fac97f58870c7d65c680594fedf208695be30b61330d35c0c0e1143200039f908fd253d4796f4741aeb692890ab4557e6d672ccd42d0abffa1525aa8502bee76af8d4f7d2ca2ac7ad052835b961504d6d8dab7caf4f85b1da9debe0a70801f56127da06349126d45cbe812449e43bdf49bd8ce86815667ce33a30ab5709d3b03ba47b09a83e7f763c8227c17d65a4d58ccaf8ea3f9b234adf45332c60e01ffd6dcc8bfb49ce968832a60ad717a7fd2ea515cd3da46432eca6951edc78c83f97e3d595871eeec8e640ef4367494900a3a6a99a81e3b229e6d8bd948680103001b311b32940212abc6ec84b9969b35a63160500d372e86c2620a0a38c1b2fb59b51678026ecfcf76dac8a939bbdffbeeebd5b7a8be8197b1d2396da7b66fb2478137eb3e39fd8b322f9d1e7b88256127036e4bdf351d0ec9854b48a6533958742ff7012637a0787cd0766d33f3c655a058a1003cbf8d9af854db0fa604f02031edc83953cf63e0b3c48127bf35c68a115d071e94e0532110165a1765116c5290c8004074259248086c91adb403ce7843c14ee10f110109f271224305b9604ff1841b45919d073e6e7ec65df845679abcf2b77f915a02b158b8766f0a65e1da1bd8bcd7ed119be10e8ff78d42deeed3df39f24902afe8f5294d71bec3128706a4517a404767a86e2ac61b27878bab9cf9c86dca9de650684e2e75d766eba162ec2b40a901831c375953fd31e9d377cf928d22eb35b72d07ee36b112561e52e7dd187617d3a83935e2a66d0a4566e0e591a6db981ba27684d1ece207f5292a111c533dd4af6f850dcc234e2929d3dd7358b7dbd6d66400ca3c3ef6f0c700edffc619c043f937b7c5e9090cb1f20cbcd4d2c86efe129ab0717c640c9a5b8a994afecb6744466926d5838aec65c8bfd23b01eb064c162e3f94651912c36aa6ee21dd17b316e01a362c3b3407c7a2078c4f28a6db7a880e6df2eab569b0235b08826a813dd8c108d4d0d722c3debe3f0a27607ea1fa10d143fe8be53b07320eaafa5a7399e750e82218e32d19360a1143ec511c423243939fba53412b5c99cdf98a03e8ce96625581b2379c35c27cffd82189bed00511a914be4a227c3af89e75150750ee3fc1180ab80c967fb22b15107a18b2a7e53fcf27c11c2d1743c49f51f3ecee8ef7acb43a5a84ad975f2590a4c2d98308a37fcbdc10f945fc33dffb33636bbdf32b69ccba43fbcd408f6f0eb8be33409fcc2c2a9b7416d7026059d43a0ccbb427cca946a3c4062608075824b74423456c9a022eb748d2f5f62252bea356871ed00404a100888c8bd43e7b3e1fab7632f4ed9d0e34c14cc97e43777bc136cbc04ceb496587ab9778e3b1a929ff65fde783fd9a21c001a6c50311df51d0947b346c2585fdedbd3e7110c52a5c1418b2de1880683fad352b1b776fe96aaa8955607e76480fae29309854664e8d2c73d5d97397bb8c9e6543e43030c983c25e351e8cefda34584ba54174b76cfc14f6c0837335c75475413633adb88681c15c8c1028a1dead01a938d655778812d94b2d8cd88a29f69dcbd42191807183ae435d41788d726ad09b67e2d445b8cf88f42a596d7794a25a095b9e37f8a8202b1ca0814f602e0466c677e7324b6c261de73caa3bab100f847579b60d9f80d552da20c03d64ac4c84e34c1a4118fee16fe68444b9bf249f6deaa7f79819c124817e573656de457fac60a6490a746fd35c18843025183942495c19f9ecf5f686ddbc1a694b49ad5d94f68109448744b9fd8c81ac68b876957e3936cb82e920fe06c9547d86e89f0359d9ddba68e1e1c853f3eceba56b10ddf7de3ab75589e072744d9e58cdd6573f2fc232dfcd305b90004ed3d93b034c4a26ed0b141437903bf9326dfcf3b1ceffbe9b2521cec27cf73faa2ecc48d80d2001791cbfa8c08ae1f7c7ff4d31fd2d5b65334dd1d624a7f41dddf3ac9bbe0c93b6899a1ccf7049063181c2802b43d47ed38855010927481959fd3101917aa933a991729276e7620d3d92d2981c2999ebc856b9c184dc7c0489f10e75df69f6c3324344d57c49c133d6a161ef4a029d4f81e3c0066a7d51e27d54702098d1fdb1f86e408ca7defe658a0389d90da54a822978b9f8eb57651bc8142a268d49ed1880604346e4e12cee4359fc719756d3e637968d381b8abfbe035441f7bdbf02dab70a344d04112294afb739293fa831ea032fb84e835157aaf2e5158d2710d65f98230880a8ffa226ca2db38c76d43257575345fb402461498fad5124ea1fbf557b13cccd144bc8e6a3cf8eb70b0442f4dcffee074a5db9eed9887249c8f32a9ced5df63b2f5f5d7dced89b112eb43d7112ae46378d83afcfa2218e536e215e79f547e0d6491162f12dd78d1262994e4a918e72f1383a4c079bdd29da18ab2dafc89640768809ddc2c7299839661ec6e96e32c1b0ab297561e5b38c4a69168f70a0834e0e7550d60b53c0811881f6b767edda83f0813094dda895248d563f467d4dd67c911ba4ba0add8407db73c1c93793fc6d2bb3f47994ff3a04d9b55d434ed1769d1134b8e94accf742505ae840b67abaca710ec80b818d0318c276f71ba9c2ace537c6c3eb9193e9bca1e8d0c0553f0382d57f92a2aa1fc4ae5bcb3f155cad4f58496fdb544c1895e5ec957d8c26fa87e020c742960e32cf36264727da70abd170336d616da35a1781307dd72dd54e1a7a9c23795338906c7f7a633fc741e1d84f078e2acb5ecbc0b9ba63f99fe5a3cfb019d1b8e5f9ace5b984ddc0b712a1c8a7391f8ce38212953dd38352ec3467f1d4b6ec24718e67ab3ffff88260c7997c3bb2c7f8c53c02de1cd82981d3c9e35b64b2f73ecbdb502a2135bf145f32ac2971b9fb484e578fb5fc080e28c71f2d5c800195cd7fbd2317244da8118467d3c1512d3c854cab254275ecfe6d4558b01420061eaf3aff69c3f443a9687c41b0a1914344f8e37eff9722cf958033d1446da14240873108c5ddbfa9264b8ef738a5978199afed983b4455f5127812d7d1f8ad4426d2b549fe321b822e19e5031ce5ac05e8ae342489aa724e433c22b9e998167d4dab8c4a5f23654bb537fbc0c86a1044820e7f55220301ea8eb0c3be3fd4ff080d55ecb9a3bc909af812c7ad1de19c96f2d33341c264ab80f08d34f8024a22beca46cd46fa663d20d66b766d5126213dd54748ae289c8fb494b5b50fe748667a408cb9e7bd8e6fc877810a6cf00a728a2c28770d9be82a0f0d492aa958556a4db6d6b87749f4f1e504c3ede3b4095ca13220835ad4569a16c5a825b359bdb061739e53abe9ced2f3f5f000e0f3d102135ebcbe6cce5f6f6ad792e3c8834890bfefe72839f5280902e02fdf9068d7b099ade60f4e15a6991ccef5a9a649ee4c5d114dea8e810fdc3ac021c1ac537ac3acf02e9121f6ad8d856cd1b82e76562f541336ad0d00584cda7dfe50ad1d445581aea403a31194a8473d54f57f950da2fc31f1372fde13843c39431a7a3319e3699e26337cda86dc4dea705305a9560d6868f86e1588db95acd81107bd31a349c0f1483475ad5d39a48b9e4d1d07545ecbe774b0eeac12442990de0f86cc82f7f6f1ee7c6494336f19b2f484759608fd5f7cdd4150d7689c1f65801ad25fe305c36cadb3f433c05e25d35a4739178d265253bffff09d95a46ce7b1a40c13783f0118587555ccfe21845b9d0e300337f867063b702141d37629a546d801a141faa21b0a8d6d6b741c26ed2557f5a737f238e349b4c060934ce476acb0b85a782c0f863f221aa4c6428f169a92508024ea6afa684b7ffe4a3231dd20099e6e5d93986e3e82b2a1093829da3ebec6079763fac91a0df05a4e5778a6b2144cea30fcde5ec29fd0c86d1637bcd53298d8af586ff27dc403f63318792dbcfd55de9868ac1974634d48722c87067598f9a2adbb367c569410e0706060ba9a546bfd5d7e23cd6e99ead7695dee90f18d4437cc4f455ee862a18566217af8bff4adfb6073fa4653a1b38ae09e27ba19cee54bf568d326f0f4a2dcea9b2855563546d2c00af3ad388f03d24e8143794ec910dd95ddf51b199fbf4958ccd389e9d65f8c32c50666b7e11276ab07935346fcd6949416aa7442ebe6438d0080e353085f617cf83984dd70d8021f74560ed6818129026057a282d7ae72569c8e17e8e2c58989231e79f4ac3ea2d4d42a9a32dfa0a06c8f9c0aa303874ed8938687e3f0cd4c1799a3d6caa41f9fe55521833297e874e05d1b69b4214ccb0bb4f06dffc9e22b6e9f9f1a47e27f8fe91976bc8aa58415a41198bed9742ffa09f89e70c4e096cd44713987c3c73995a2879b6dc95acb127fcc1dd3000b878586a95e4699d27557353abfc205755848708a8be8a7bc1a6519741c996b7460b0d925a5d8f341bdf96c3242ec7f35b852531fad3b5441aaf401dca62526187b4903d8abf015fe97d396c1299e1f677299994e128e8c5a0fbad2c03217b990ef2fab7a8ad1a94e05d8a9d249417469fbf13541b0f7af1809548600771f2a080afc9c09dc3dea5aa7ad6844f721bd8ff992a17ca4ae445c331eb2d4674cbecca6b1a52d15132c0783252f354c3b391831687ff661b1df4c2dc7da24871073b387924e6a647d17693bf9fbcaf1fd1d9fd4ad391cdcb20cbd89f05a42bee90d3b97d5cbf6c50f9f5965bded1f3799b1b34424f7d64f29af71d0177631c08bdf3b84d14ae62a4f2b61a6bed0a8d45706cd4eca2f63796fc636962a98d4adc13bc11215472e8bba131945b408fb2495511f1152a2b1082c288a350d80742ff99b26be33ec758f5fc37225a1137829880632f9c5bdd3cc984da7a6f01ee034598eb74c684d5fb518f06266eff81305cc94852019047e71def6ea23f06bbbfe215251675157154794d5c7b3ca85de9326d33b199192d63b0c8f9c0c1bfd9626ef9fe0739cdea796050226a36b0479621e67b3b874450b320b11c57da791fc2a58a8972496e07d355f2736a01b0ffeea060c697b3ea98b4cefae7d709967c9d80a924f99de5e3e6188799045fcfcd9e57ff9208838282d9d22b8887fc349494a90c31b8dfd9cdcd4d48c2ef0a75068be666cb79560d4319ac9f8837f97894b6e9d9bab646b7b6fa51282b1a5c0a61cca2a15436c97a606b02dc71485e58c7256850c37fdff547225904e96d7574330ab7a986ce3c34145ea0231ce8e47de2c5e4a382f68eb9be37ae3d1ae943182c04affe14829e97e2789fca3e9b53a706fa4c5aa646deefc799ba158d36c2c0d5e1e9776c3f0aee302443953064df4b8435d70c31f490c063c29b145f5f2ef1aeee72093859f6578a761547b72c8434cb38a168c354e4ef86d82452559be6b78f662218bdb78f362d1f417450d5f9fe610a39cd67157b59e64e8eb42db2bafedf6e26e4b11b4f5bcf9012abe73eced9abfa6a1871c95f73e4da3519484d5796cf8040331d0671e3e85795a1917a2f39e6662e27f48a6fc68de8813dea95c4a3bfbefdc8fc80e1f12e2f422d6aab8c5dc83d1195aef43be9d9695a6ac7093e9560853be0d08055dfd7a902a2c9de7dbe13f6e6d4f272dcb60b8f24436fb405449d96b07253d3d005cd5b3823391c0888b28254d5cb977b539a7967f1ac53226efe70f67090182b4784c3efb1eb7a4881975ed98e00cedd4f2c3dfcc0c03bb8a7fca2d1547fd133afcc9b5ad68553f3aed72ab6e6206cd9a80afc61f2e73522e889dded312467ef95c8726d95d0baa7783b553faa30f046a9d5476c5af4728702ecf512a2da8f4ff98942b344bd90cf146a95f698cccde5d1018ee20bf6cc92f80e55d2a5ed8eb9c7676f8c23f9e07ae597b5f319a27f0a3d52efa6f60a27e231e4668698bde41f0b1c43bb38fe9fd941de8151daf716da4c5a32ff2269e541cf39151046076e7e231cb31622239575dd2d6884d577ae706f416e3844dfaced860fb36c6a577726902e647f2cd91844d084973bc2735e2ed3f00e8fdee1a3e62843072893aa29628c757819820310f0ac92bcbe5dc5f390c6affd9366b271b81afbb0e9511d7d414452e7da3a506955bb16a4f715c003f5ff0a1389112990d2742707d2a7d565869999cd92705ef0d41d328218b490fc37e64202e6753cceea6d7d63cf171287082bb38d7c99dd4c887bcc67ea5abc228fda3a2daeb48450212ebbb621de636b2a9fe779dc7c594a942310e89713e3b76c1e3208c2e724dd1165cde629106146bf06132077cdcedd672759dfe707cb2c9d56a42bcf5e11a0fbc0e4e2d4b39b97b2b13acee566564f184a1814badaa8c281ddbab80b226bd373deb57510ede94f8207e7779ff0c8efa983753c403caa2b71193a8683388dd96d776fa503079513bf7d11c97c93d3e9fb7596216486426ae6ca230cc21510f3f2a8b1cb53b0b66fb01b0508243c7d13eb788df65a05d018bbe25c2e36b2daf262fba1fc7291bc74d61de95f4d1cc71a6d6cf425af84fbecfd30d3b5ad2467a6274eeead7c63f79190e892ea94716d463c2388c6dfb86529d0b7cee74c64e60a0fd1ee3f8f744ed52b053f1039e4cce3931b92a0d197e5b36cc24a2669bb9b159577d02a7c12dfebc1d3802ee347ced7932abf4df8210366ca200824d30f99c3307a2c6880d65d951ff3534f37c51da8968dbb08891c2edb8a434a33e2ba6f8dc8968d59ed9a534629d811b783b627f6581e9185fefe12b0cc5cdfc05e4175b94859180caa530c626a87891a3d18d63a1f630b17ff90636ff68cd8ed2a289358e552aac997be8f6e646961dea09f7f93eb3029568759544816b8c01a18b74b814e7c321a12c4639a1706107c9acb1465757c44da5745fd8e478d5cffcedf9acdddf2afc160a16c2fa91e5ccf1ba936cfe5d4b168e5913a81493ef832e35e61f9dd60495a85d540d60998fc396f168dfd74f7270174a002a86a5a8d0f8baba8c31e8da2c55b309caa83a9d0c8468a9f431755df9fdd3747c84e3fce9d6fcaabe616788883d70990f3410ef6cb32f36b28f208346d1a0b213d05afd50fb99325b09da8e48e65c258165d3781d4273e7c92a5a34fa758455eb6bb0268de51eeca1ccd20fa35b2a5d982601b72939b8892cbc1a2994ab185b42e4b81d832a41cd592317d18170b1268d178905f84653e6595284b452a265c20b75f82f29b33b13ac77a1b7a3900f4f02e550a15fcdd454ae59611be02dccd642d498401fc8623e852722659901b2bddbedbcade37fe017747ae12bf2d824c8b1ac5bf3f1a0d7d34440e4f8d4697fdc1d64ed09954f6c71ab1f743e03b6faa39981141585b71b49bce7aae60144985a439d47eac06ea44decc582eeceddb4aefdbfc1e3fdc0540c72fdfcd2949de8410d4b24d3020f22911b2a05a7f6189c46b5f2b3e94ff6563f544d76b727a6e9a625bc1bc018e118033b83f38304e918be47a86984572b0ce3a82505dc49ae255918721cc934c7ea364e56bfb836b2be790870ee80c2b3c80b0e4a2825246a608ed4950f9354936d5763addfbbc4ef28c186800de8a537a4df7d4b968090b1a26b71784588cbdfe55983d104dd2f9c7dd9ef92a0bd69730b0da7b32d368fd2dca0690d09893465955ab634d03442f0e8bfc97c9bed03ac23713a0b07a2f8ddb38ecf75fb0f52e9506a5f4daa7d06383843edde6e3950b3a30d975411986c3932c5c4056095e4b7bf1392318bb1eb138b8d8e2904a0dc5a12df09d9d63e64af4ec4d1f6dec23565836f049cab904359fe5d2de674ad147627da0e2679954805b45cbbf4dd6d955167e41285b8f61c4a2ba05a3f03605e0a67edec907b5eebceceb3c3dad89391b5204d80c775da78e52b81709a831970a61373951d00fdc4ad2272f28c9dd0df7ae01f996c327f644ca8813d3aa53ef52b75991796f73f797b9081de97203faa66d96910615e608b513bf472479ef7af0300e19b66403cb4f9bdd63b3ba2fdd9b2348f494e7625f5d7d7794fa5774cd68f90664ac4705ba382aece13a0fa48d11a4a53964ff5438aeb0dfb7970407f14bffbe0638ab4cfd1844161a30dbb313e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
