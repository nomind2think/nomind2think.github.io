<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17b974a88892279bbe79c512cd6feec8ebc7a69e915125a3cffedad6a4f8a233c507639accd58d485199d821b2d683bcfa6b83c75f9491f99fb94f0f0924f5db4baa5aa44e017da580ecfca79138f59e08cb343f108906b17281baa05f9401bffe50fa479f7bf53ffbc7c705a1d66e695cf75b539ed449b097c1698371c0c2b480d7142f266017caf7f96efc9b8b2f58e9354dbfe9e7776417df6fa054735ecb868e7ae0915d0118490c4dd290e59a9d08002546eed7368ac52ae80dc9b23f94fe9d02bd9d29053b3973c806615796d686f164684cabebd6f85cb7671958549cc426433085c2eac1d5c2a92db7bec7eb4ac884a8020d3f49128070a26271fcadc962589cae558c0a19059600cbeb50bafe9bb61e2689befb21f66bf2739bf75248ed38d39fcef606d5d976054b71e9402b911faaf1154555711f0c834ba1365d13aa31aea9d69286727e6510e468f807abcb8c63eab25d07136c8e32ffd84d3340ee7f1128f4a71e40e455d6b4d36a999ce9f20e1e6fff09a21cc1bdc337135c15247f511f0c4682e43acf87486b50e4da7cf169796089ff1d41214f2e12bfad640462adfa0da3cf9311293965d1f912599a93733a2c6077c745c6e445e7b22b8a4da1d481a4053d4e7520be295734aa3fbc6cf83cbbc69ac2239b0f8667c9e8a51cbbf2a4acfde8e7ab0921af3c42c62badbbcb7769f50047f9bfdd177fca79cf2906398cfc9489e4847966704d162f2d9cb926ae1430d1ec03d477964caca7df8e2697d9b82d505dfdfd1d97607a05ba59be859f16dff8d25f51452f05ad42151b867976f7fc952063c8720ea309f185158970dd9b4fd62b84a6d9b700912d87c251d11c37d94c5725a9786c950981f2a9e7269ca02bd6c3403b86e7cbc4c672a2064e884f4c4fd1b60e93967747aa8f3416eaedde02de10a1ffa4e8484411461d5683f11ccbd689b9bf7a5007a9a21cb81a14219e5dd670142f99e65caea27ebfc8b8aa1e48aaf4f7a70f0cc1bc3aa9751fd4708e1f620d7148e805f2bc80aa50dfe5f4cfd7b012dc15b9553cf7a81553891c41994ecbd1b996630145cf1b23339fc29679c4976e1825923c23d3fd3d4efbf4df5d3fbf8d51e02ec1387955b665ab04b2148fe1ca89031aee0da917dbf018a928d4e34c91e144b704e40255ff9fa7ac02eb07987df1b383b4b20a7c231618f14fe5820c7c42a74b1b24ffa5851672cb82615b3c5ec8d6500481ffee4968681be42f3436a9f12c5484a212f6ce6d72fd37dae0aaae5cf706d919b461daca194b0e2a6139ef7cb95080adaf2ff0a778e2deb99c0377c958bf22b91fcc655d3e5842774ceae70339541f52e6b4fc0c6430d6ac9f73a507bcb0558a8610e037c3525321c2f5aff061a5bfd127964319f9d4509ffbf10cc28af02c29df128170ea5ce0e88c2aaa6bb2e2e5f6eedd32dfa8eb59104e391afc71ef7f5a5438c385ac9e5f651b392f452c2afabca956c63d817d3bd3631a71512f08790b686a2cc906fc62cdbc0899fd42ec264591dbcfc613eeb5058348f1e20b5c81f3dd5d24f9e7acdd90658519be0c37800cc92338d7b1af86915a0f56fbb2d13b50c2311b795491c221e3e4a9085029982b91916cbda91835d020b82e8c1696496eec835b8dada794e16319b0c117b22ec985e7c6956b47ae5cb56c759ab4165023eebd66dca314025f63c6661f63465bcaf372956927292eb040e54f12ad6907d8a32e5892f146bb629f4fbd78ab3c8eb0303e9b7ab6b4ba94dde28f2fe33749b52380e7e5d08d848ffd58331e66734452bc2f1b08a5860fb755e7327f13ef00f8f90abd1a08883b3ed25e363a2b96f00b4d85ed2a2d2379068790b33c5e11fcb0e9ec94fd6aaadc4ecd9631983d184dd1c86ff385ed8f0332f6ca705c6a0322e9fefc51cea321c0cfa006188f66f5a3a96202e45a0c5a8334495adc385fa0a4876f3544020c3f39a1bdce9c587cfbc4274f35b65d468f29cdfbe49f9350c8a115a808de9b33f05ee5fc39ac7d80c77b92b1520110c881b028b357064378f34f6038d6eb45dab86d76c57e449f4852969bed8a731bd0c6b75afb849ea94a63b6081ae5592dd640aa7c40ae33cf4e7bb7a123764d59ebb9ab17abae912b523b9bf542ff31f40975de09bf786deb4529fc48b95f06be97179d65cea94c33992ea886cc8eecc99c0bf35ad3fbff2e9728974cdc295a12012850527ce67515b68cb317844fd9043257f33d0aa6c71bbd326ed65bdf43a3d30201722d0211665c45d7bef3e8b84a28cb8893ca12ed549413061b020b46302b83aaf5e623912d27f3cc73a01217ed0a62339c59fde4284b2bdd74adabad53474a07596ce13e7623907257f6e7932d8687e79f6d5fe87869d2763485609addc4e1516b87ff9c68226470bd3c9073836445d04422d24604e04001d759d4dca840224e5e2e65068e819813f318b6fa88d83bb841b739969eb17bd056f9df1f18f202fd6a5cd0dbde2f1bd3cd9e240f5234d7ac96c2e4323e8d120d085e9bdc99ef3b5989009ee5464171d666b55d3a29c3f6271e6a13c8a2d405dc3342d446e41bb0f7e81bda37ce20cbff96d513fe127cc052fdbe3b41dfd28300f37a3d410e90185a20c21ff4d7eaec6f9840c87b824d9c1ed30d2398b49bc7707b4bcd1dcf73bb97cf205788dbc8f89faa677799aa4a91c287b838567bad3002b4bb80ff8095dbb19ee08654007c8ad59046f3a52d146eaa777e66dea232475ea47735885176dcf074becf2649c8853817dbe27695245f963f8360f345fc5f44e3d223ca722d4962347eb70b3a6cb0c2bf544e053c5b9dc51fc6f9350f4a61e63cc42c7133125f89dbc5d8af9f21c30b286cb0c342c46de9e40382e7a593c916bf3183eee1cd972c8c1bfc615facdb0cc3475377797442ea9b66f2babbd8122da787e4f7840d6fe465e13513d116ba3191c7819ceb72355e171761b355cf2f399a3570b35b6cc784373d1fd5fd64687337a7db6ff8d28f058b7c917246d7b08451dfcc5d6fb0034274810f6dbcabe2897c6d945f2a070d32bc76f32232ed3fff38c945351a8d250bf00b97965a50e1411371d27c48f4bf8ee236ae35a55d256f09de0ba07889f664b6ee4685b3d0adca78a27d5d72c70059e92bdb53d6f1e00ee551d6297d5744740bc33e80ccb59194c69d054cfd3d6641c46fac54f22def7ad266f4a6477eb698e91e7ac9bdd1f6ea0f156a343efa75c7f8d6361a08f548b363b7f54ec162d96d2dce2bf4682ec9dbc04bd86c1d7cefa5b74aa9a50ebef2098080351f5abc86bd381f11af6a519ee231321fd0376b5ccadb0d9cfad698df6693da1dae722fd7725bd7c1f11ff523e8e17718cf8fa139b8cad056c21730fe11002fef9f915a940abac13eb37d146981ba9593caa5998ac40ef38ddc72ae5021bc34c45beb6d22e8b78dddd1ee304a1d11db242f535c03667e62aed7b58dd4c0f491f3f10b28fd871037b6a31baec91ea1ac0f48e65fd94ef09fbad7069d43afadd7edf2234a7ef72b98c7f0098ae62b565300c97818cb4d662d8418cbf53ede4c1d240edf346760f256cdb8253aee1946c373359920cafa69f1d65c225799ba8392ab544a2000249ebf30c289d3b944becd3242fd10667abe1fce3453929e4f0da25d153a7d9e2a04f1b6d1e36ecc41758129f84cf0da8d1f5c03fa47f8503906be1d013800a04564e57f01e2b7dd18838e10c05f2cd23456df43a39b3dac879d27c3eb5b5421b701c781af5900d7f637b9c092341da9b1ebc5af48efafd169ecf86f13333cb2641b1c872f40e9ab9cdb85865375049eeb970c41c62e8d714363a1929932da364e4349ec88232c1e72fdeba76af899183d8d71277ae3f8961195f44ed4d48eb3ba49a9f855e2a775daec234a9e5cd9cf7f6f6bda9c087979e9bd678b83475acbb4cc4593df211777267962d01a48da5dfa63b5e52ad73dade7a3f1c86ef29df7128c21136fcb616e46144c7447b92eb539e9c68cd031291e1fa57f46ef1c97d1d8c634378c5ed84119764559e124e1e0800b0289b0f1f97b215cb73589c09e6b66a0614a9a827d964eb9607be5e3b1adad0e6b2424d8a5c15ced81e13080cf2c3f6cf8700aae4f341f38fef20e947c869ab3814f6df5c8f74b416bdb322ee54ad6e9b0c752c3719cdeaa219f8fa6d3b6dbbec0c6952d9047bb3534ec2641f99abd272aaec335104b8fd9e9724be5c1d46fa289a5963f1f1803128e122869cace90125817a9fc9518f59a5bec7cfa2b2f2a537031bb50a0f350d20ff6dc11b8c5034b751af8c0e4b359afb3ff63770b8eeec8ff369fc3b8bbf470a64b8890740c573a0dd9a3ae98121874992293b5e8e7d6ee9929c57d54620b8859bbe5ea8cad19755638dc147a71321585a68c1bbc44c17578dcb61802d521aa75e6bb37349016c0ab679ea3a72e64f1a194cca1c3232eb525e7f2fdab4f9a243f5b08b8563525cb26723496407fca27b4c18668fc11e85f85412c5e114cb05116c6e183930310be5b9349065bd9fd64d4d8dc91aee75169b02219512d0d5d21b275b099b1d30dc52f69f4522049a25cf27e20fd7500313743ccf67a270a1f842035afa3b564408709b3c7c462435038bed2af0ccfa3ebd76ee84589c7f4bee74e6d3d5a5987105f531f0966fb7e4ec2ecc99dc569f30cf0f9d418e45f81b4bb72c450b8102c520fc9f3b19b4c2a68310adcd40933f6201e2b7a0d1a347a542500d68d2ebcb51dab570b2a0da73528bc7a61b5bdda711d5614c81b89e1cd6c9c8da90c38aae8e9068c5c26d3c7f0c2a376f5c43a015acc0d3c6dcddefe64ca19ae8d2df169648d664de73a750ea5f57be75215a4b804430d1069ec1d0b50fa1e9d6cfbf84163561129f6a8070bb9c9aa434b467fcbea084d04a903ceef6c4c969a496f3bc17b6d8695d8f4eb7aaaffe72fbf8fd7f8aae8afbebf49d971bfc9cfd63df61a2450b09027debdf840a4395f94bc9c6e5f701c41969adb626d68ccbd3ac0c51c0969fd1ae7f4cf61153783614b7562460bc95b10f6107f22e0b7ad808a49c68db0098c244e66732614772a08bfea818354665d8a7ba4130081009aa7eb92fd81b8d781f14e097baf1fb5a879bf2b2bf87c21d55eb9a5c7bed30c75b5f70b630e23485fd76a4de10ee29ab2cebf97192622a573cfca9c0bab7f9a7d036f87e2ef0b90e09894560c52a863ac29a8c7d242c8b31eaf29b61b5ee25d8f25bf70e300d8f9ace8bbdfa8f260cc4e0ed9b643b6cf0083c0067587fdcf3fca662bc660f99059555f670bb9ac343893c6548132d940ffb8e59af99e24662878bc647f1cb5ed323898047d3e0519544576b51fd20b4b5bf5cb2566948ee28a33887a9742fd81d836b5b46ed670a62526731a42d0d0657ea5307bd0090767925ce88ca526609c0f7e9ceb6f767b102f6535e3043739e288c99a4593a35a725020cbfd4b79716bcaab283172a96e60b7ea1c98246d5a4e1fd3afed85da0323e0cd0034ae5f9d90417d8911f3e7ef49709efadb3469f8f64e4abf894dda09ec722f21e282fcaf10915b4cb982ab9460ef65de9f4fff6058595caae792edbae421ad3d6e8b4e97525e13aeb80a98fa917485f0621d3878dd38e7dee6b93f28e7f3a0855b0da167c0091557f4abbbcb9331a4d508aaa9fd887df833631a46f1b9258d96929b3b4a365432e2c52e30a1d3ccba401c5be071682344069839b0377df30e92d1312fe2a2ff1e31fc62992e8d1c366a92a1fe042b46ed152eeb73f323f5729c13c553492241d25d3416c500aec2f0de4486fc8f0afb257d90d7520a0faf42d1deedcd12a027d94a14279701eb0a650ad26656cae4f4814bf5fbc3f7f65a7d189c18e941df7305c593984a9f9ced917ee6cd6035196297768307c83c88fa9e2cf3dc388d2dac4437b4b2e0dfa5bbf1da5dec789b3933ebfc08d0959c42aeb2b555d2919f48268937c3760d5a7eb3b1d0b23d357dff090583d46c4472beaa747c86f6c7fd2545547e02f395cf43991f38d43eb4146b28de38e3978a1e07bb805ab2dccb57487e212ba11940b01125a55ddc34d2e29939c12c21187e8fcc27eade9ba5f5451fb525637bf15a9c4aaa873df953310306dac8a7b3f916524b95e5b171a21611c21a5b74a33add76b196e0b911cb4fad89e67ff917ad24ca13a723662f54bd6492e37ceaac26444c8ac943c6e13506baeb66e604973010e8dd43c3a28682c49e6c20437d081f0caba7522c4318f67823d5ba0227f1c4d3fcd3125e1da66d11c1e7ad6d33d89d4db62d8a08ef859ef50cd7b2b3d109ca211a29ae9c58d1a08e8c1269b5509dd92c6eade72483cbc2c3e9fe953c3c3dd28cb9b4fe7872159f04ce4f8bf3b1f4881b0028761d4106c0300a5619b567c5f1cd5bd7e512d2ed9fe79c848d73d0978acf41db4eba2664abb9bb2a62297b5022de002fdfd468a73cbb7d8cce5c8240fa826852dfb95d1d0038ace9e7ed4e534a9e57625f2c1ba5ed3127896f14b1c4d390428670585b6dada79c92a1f6115747733075621f52ce4eff2945a60138101139842c9acd639f95e038179b80d072658d6a986414f1c118ef4c37f8f6793fbe1feb08be7c764f9f1991f0795b02b587d429cf7c2c2e6a369268ae3ce5d05ed9707fdff1cf6d1a830fe0ada1f4869a8b91a2882b4c3cfeda5af0674e8da13038b70aa28a4488c523513df8b9102be73dc9a4ac67fb385146a1f653dc0aa6a86645b99b44358a282d11b63de65dc06d17dd11c55ff9a2729c79a645ea89fad5c40bc9f005d2b124102aac5598b25cc13fba4f22fd80d17f816acbfc5e8f7bc9c4dd540f92a55b07d056791ebb00cd734a48ef60121ba909b347008432edcc0cb21df5efff202a91756f9a42c00c40056c74eb9ab3e26777c7879a681547cdcc65ed9abb9ad98c5d09151f9369442eff736523b20cd31a82e34c2f85583dfec70b4cb35b2e1f90660b34125c30142b5e76155c25358d84cb064ae00f0fcaf51a267a27e2ab3846c1ee9c91bd0c27e456b845fc2d24a670ffdadf9d44fb7641890a7282dc856e868a7dfad67f333663255ccdd09dee982fccf20d12fcfa4bf3ad0cea0f31c2bcd2c8e41bc228b5d8eef075b0aa030073b9fb29c9a94ac8430d3703b521bc64e8320d8b89f51f6df0a4e395ebfde2737b4a631212ebf2808127a9e39e85d158552961e07597fc8c78ac3aa5c9687e2b26c2ebd695647aeef7d13b90cf4624e20e9a953cf5feaa8a6084e781b654c89eb65bfba162bb2849ce6d3c296df485ce068344a2adb3bf515146aedfd10b2b5f1794029a41f16b10e086f8c0963cc10b3f1ef2763a3f7183361849844082d424f1d23166231e6eb693ebdf799da606497f1c57b44b6b39c976f702a555900bd770c22ffac14a7fb0f11ca14e8c70def13c97252f1c8edded86b87bb238d0dc27197dadc56792dedbb1b8427888524d87d37b2069c80be71b25c230ef17c70ea9ef25e132587a861d70f76bcdfa91412b5262c72e40c5e723f0a2bbc52af8250ab8d26d6a3d6e5cd087d0f1421b1f494dccccffe2e3b56a138bff21a0fde8a8e9753f4560d58e68749d5eb6a5c8df32f567ffe2cbc790bb520013954ec760364bed96b404e525e7f89d80c6c8b6dc094f7f2a430aa8edaa4658f55a9c4c1c33b5eaa77177dd624088533327d2dcb5025614b8ccaa944eca1016c79dedf859ca951dbd5fe715a17b343758c6803b307659c996574728b900f60ad1f842b05c1d5083792d9c5120b00f5066a6ca1ea491c2dffdb7bf2692aeaa7f5b3b09ba54ecf0b6e6050e7b5297dfa81990d1708d53fb601e560bb394ebfc28fe0a1d929375cdb83fbac28f20744ad7b581fe3260bb8c6b7855064f2aead56b2e9fc528646c26f5fde66644cedcdb5bcd2ecd9d80c11be6ff88ba2052bb75970c64e4821a34a194483c776c7298e080a19fded531f7e7543107fbf8aa36860cd68e42711f3ef60e537325a8a475986dc1b19d0d9e5ef6dc65a14d18a39622bd60264de31dbef3f6ffe9bf5628b168a25080ec084718a681ffe3889ec0a9c60db6e41845fc20bd4b1271870c8749306e4940a7eb954c06a095626e939abe3641d835a0b4d732990ee003d950336ab9937145faf751d259f73482776ef0d2b0ee3c0e2b9e088f6013bbd2f9b11a302a2e226ddf35e15d4dc39c636eb4df45dd070ed6ba0b1e3f9fb3854d5a5d25ef9cb1b22e1edaf2a2260808bf483e154c126c6ffafc07d1b1674af0e553b1ed8b9e8db8dcb70c46aaa56926915050dbff61295fc8631d1d8f2412c0ac5004bbb68fe7480eaee9dbd02e8210feb49b779d8c19a1864f94b715650891b0b26da60fec7507e956e44de0980bfd5e9f684125294ffdc0dcbe6482af0de8709c132d91fe9358941c7ddfaca8f8b4e2e17b802b96fb16fb073612b60a831cc34017b564deda298e580eba5b827a885afb2471e674d04a759882ac123d3c442a3816b6ce2104a1ab946e9381a444695de07429a3e362c2704530d644a3cbfa9d6b738f77768bc25b22739c87304dfadea3523da72152affb9e65f39e6c4b62d0ae2979f496d85b6fbe3641e2e0efb6d69fdc4ec9eabc45951cf826a45459e68d80caa5ddaa5785478e44115f5174ddadd920608d5ca484d6aa0e77227dbf918d1905a0ef34f7da884c0d4f817819fdeef042f2077c427bad0b808b083179d60d67a3a84c64b69ee6e2b4d0e555ab2ec7c5dc4ab3c44aac8ca7cf5026084a3ece25e4ba5edafe1d53f6896839fdb12cc17e97855377104d65389d8379c6af5c06b8107ef5673ac79298735dedc74c838dfd8d01a4ccb48d95f88c1f46bd895c080e827e7c6a33ce3dc996bae96c3cc9b4b32884304f75e6a5245fa737b26bdda977dd0adc05af8cce12b4f9d6a370820690bd553761fa940d2da34311685ddeb6026b345c6d4fb22af7f76b17173874c5a1573268faf1a6d512762b7987617cec355b259c055618e6bd66566ee521ca5e3682f37867a4b03df0260a94910e64433d2b0eb90c0d9a18bb8cc13a96d89d112bebbc76a432e75109c898b6b94ddfe002a6f6b5aa3bfaeb7cc448ded26ee20474e73a0300ebdfe5adbb2018b7f6a582b96595d14917dd3f4295502ce721c06a53824625c9bab2ffd9dffb1cc104cd73987d19cefc4f1a4baa4a07842ef07ca45e0d38475ebc298584af23e83f9b2b6b8683edc5c811d16200c5682ab2a3533bd427a35e7487995e9afb1d2d91d9c2d9505c2fbb68c0c2f3ff7d59bfe3f68c817f00ddc0d002c5c52a3a533818a7c1ba93ad78555fec55cdc629d068ad4fa2def9a4688f9cbfcd4307a3a7361176cc8c28e4ce6f2d3553fbf2c2752ee2c00060c83bcc071a41b89ebc87a5efdeb7b0560db7c2dfbdc7125bb4789c63f2b6ae5afde0a283cdc1c4777af141516ce9dea82a0dc44a0d0b459013bbe6905374bf404f31b28487e9087b4dd33d16a32cec5fc28cb8b08a2319a3146b4f235269e0ef8c1242669a3b893299b74312609ad5cf50a28ff218e178c0475e1b9a9b52f2516be394888ed047b68006040a6ee752408bc1c8004d7303623ab30088b333935bfec0ada4f51cb4daf70dd0e1f391a6a868aef2c8f7660bd8806d01c5e801b32d868b5a3f5ce6ddf043836c5c467aeb2aef0bd1e7e7f9ae0da8eb824db945f188ca4d010c655cf44b33a4ef7ee309af885cc9005af0fdbf1596b22e152b45f2fb3dde73943ed4cb9c4da2a3726bdda0462b12b84595d0340c9aa7e52fab4505a2a771034b72d70363659f4fe04135a7ff048840683801f5bbcfe5fc7af2b2cea721a4ef0462d49f43ef53371fe9526d5a374356bedbaf1f4be5daf6f10fa95c336d9141c34ce8b5c701346f9ff07f966d56252830e0c09ae5833bc797fd85d9062e6c8422d287bc5941a71a8197c92c98b65e3d92aab4ab7f0a14461366d4705313d68915332cd0ab51fedd337520efae032816660f65d8c07e18172fba3ab08d6f32cb890a1e6db8915be2e741e81312b9291cf66bdbeb549718891187ad005216e436645cba69c152a35216ea7bb168d71660369f6bf6758f3451b9401bf004b90e9b3cdbbe9292049bddc2a4d4349652a5a73043ae1ba14c9d00c3a3b469456b55dc1e992a64f36ead87e8d0bae8a00e19aff8ac4a915b9d3cf9f1c4b8b33393571a4c7aa95310c7a5038f7d8fb6b814bc46a0243899a836dfbdd852553c1cc9f3b21985bceb3bd337d4acedb5c73b9ed0b301f45ee172d54bc688e30caff9f3f168073eeb83c92d7e7d469a30116c6cdeff6746082404494bdc7378d497111362e189b538e0ade06e575839666496907d7ef386bb94470502effd27d66d07d1a6e4d8d14767b9a205beb7f1fc8a6a218709034b75a8ac48e4b6a7edce3997842fcd35bcec4ef98140ad2de5badd57a031516376a49533c97110ad10a7d9d38165ce646bd8fd869dff6c8626344f45c05b330411d1520d005538a1bc101e0541227bfd43357a85fefd18ac9b4feef4ce31ae9c3f416163b0179463e76f2e4c8f8697771b0b947ff3625a41f93b1d7b539c7510f6faea0fac45f4759bb4da77ebdfe25a5ca3b75a8fa4305b4fad6e26245973ac80eb731e1ebc05188003ebde6b123c8bd84239c47ffb2920ea61e651f1bf389de475196cb89d92a2b6b506a381e73051e8593d69f5d467f7cb21bc3245b3b099cf52056cad4cd90074c223e47e582f2d4f66644f55abfdd3ea8dc609cdfeae5967f5c3213ca19769e79cf776e24badb8a6c4a32602e8a8f6dd2695e8056182c269e22d893f6cfcb4ac0d94e95f7f53333b7334edbddc92ee9a6735082d957bd1620338526f52654065e0886c739a7f15a95929523c387911423ad49293a005c43e44cbbf95efa8ae6a09ac598def3633c1890415a1540c316cd8d6c52435ac5ca271d22d1b152a5db1a155784ffa0b208296cb2d34a375d1aa79eb42db8ea365deb22a2c92405b71bc445ae64997c64b8efba18d95f64c455cfd873d2c42d5f99f9a27db885dff22a6aa03a51e7975feea8907c3adeadf452c72e90cdef83d8727eea456537df37c4d6b8bff4e1f34e1c793012f32aa8f83bf9d9f08f511c339702a6036318d2ac7102d7c17bf784f5b5b19b98243e2534799269b629e73d19360428ff231497a8aaefcc54af58ee31480a0b53b846dc0ce3063eb69ec8b2a7a48a94b3aeec3d428280609d0ef6cef9bc54eff297fbbb52a09266b04d8b22cd908c7dcc47f0008943e55f34b567de4329210fc0210015a863c63c1f4a2854c9ac8b6fec2a7a4070ed385368caea88d71bd0ea9b635a20d28817eca7e376ee304e74a65714dd6f9560f15dff43b777fa367cd3d68ec19fb59bc983006a4d4e26495df3b4cab2cdb86f1a6b6c07bd06e5457f76263087a298209996dfec5d5485c488b2e94fabac266e7c604482cda6d05c5481d5da1cfe729efc7cb0b2ffcafb3b9ad5c951fbf3947277f1cb0a0fd9b10fcb77531dd15713b9c35018b4fb298954e9da28d9aee8365e68da9d3ab580bf51864624273e38c9e0ce6ce8c852cfd8f6b647c3eeb4653548cd02a5a6ed43d69798376c5f1ffef36cf146f0743dd1c7ed0eff45f3162a42819e4c96ed345ffdde80d759fd0f6502152f7fac04ff2532893f7f355d6e1e469913981dace52d7829b92f27fbffd3bac1b7b747ada2414a66ad4ace76244eea8941edc8df26ef41ffd503982bd3b4eca43b73bf1057497b18a401abbccfc5df252e78f9ef1a1a0348fc8d8c3600d85ce23a7073cf8daea80014698232f55c6aa13be5469082695f7dbbf678d5ae4e52f6a6d3b0cb73060747efebb9344c88b1dad0d15203a0730f95f19d1a1c3c7dc50eaf84ac7cb944e57692bd50b10db9b8eb08dab58548e08a81cfd7cd749cb5d2a0d8884c550293bb67a6583e8f294f319660e10d2c3685a620b7eca0811c8d5467fe1aa8df4667ca26176bf1f1593956f1543eec5c27df0ef54d118af5fb70cd108457982ad1a3759ec1617cdd8a6e62bc146a8818f413ed6802c2e33a322cbffbeb942ab4734a2499a124d54f05097d48e5fcbbf15dc0653d9cfb4a5649ed05c212743c96d3a1331d231ebca998b2d77e58d88b5198b938108915c109c0a574d1950d4e3dbec392d27759521b1245cc2a9459b72b5ca696ead3171e647ad44b6ed6729586dbd9cb5ea1450a01f7301c59e8bd54d1a3f72e8e93dfabd0b4ad449764c636c4296e1f5b59af49cba63d8c4ecd709a76187f3832fa6593368d7b86db98e9b0b15feb0e9ea305924010a8782b6d1a12acb13a5ef390b051f8df91bf37ae4b2cfc8e4a408db4e46300be3deb926c2ad5d23e16330c327baa89d6ffe49ae59e50219d898318f30e19f11297f59ed9354d1cc4ab76ed44d968f68d7ce86df0f3d4f32eb99daada3b16a728cbb844eb71cbc63a04fe49f66ecfbfe4e65c16dbf89828d2a169f26baea04197dd7bef3207f58f810fae7002caad22408678fda24718477ec82dbfddd74bcec786711642a78d70c274e4599914a4b4ca4307b5092408f39b7b61e6961cd3d52a528c4543328c08202ed888db1f1eeb5575ab24650195e6c2859a6571151dcfea65cb6fb6bda8fd15bc85d64d266805d187d6fb35031bb6d3708e7c5155ea736c510320f39f301064e6774e434dc3908bcbfcb5c56b5495919575dc653e612658dbfcb4a3c2f5778bfea40504e03437b1e2cfc141e5b8e5e9f62ebce0c3b946c98e098caa994bed5c10823b9d7b19a23c28e1fc208fbddab30fe8c413b175b14b5773a28fca1da9516242ca3f47456a0632ccb52eeccc20b50d9e68547d57e7bf5576ffdedda1243e5713a096d12c709f8005d7d76dd145ca833a2a8d5036298d7a0df262630bc494fab1569318c0b30b22ccec3d14a3129041a3159c71c24b2fcac14a25b3f023e51d551d139a5fff30a32c48dbd1cb454aa2918ea20715051a22ea07c8f2ab5dbd9874200f3d11d7bc1d183e1497b90cf681ba4c5c3cf7855fb336d41d404fa851e25495a616fdf4a2e06a07e9f590006f0c9e2925b0eb21d8c7857dfc56e3c062cfcc3541210e150323f1e6b3d3854ebbc9f023a9418d44932951442fc9780110a63bf8fac0010969137dcadf2be12891d9f5773c3b69133450351a4f3f2b527cd0f0b190cf12c721c537747ebc17c754c2c6542fc66966799153ba1743785eadc3a20846d1d536023695970c39bbb8d9f88881a119ed1b03abbb469625e7fa2cfab4e54987b40e9c50cf1d56e36b6958d360e99c8e337bb0c2264af2bb15682ca29b7473f474eec50f695e071dd2bb7c848598ed0cc964e0dfba0e025673ef97d0e7a84f03ef85d22b791e03c05494e6e0fe15013b34517d2735d9d6ea489d7ceeb2a88fba53b133ac92930b553ac21a726531434a018c68bca7f966ef451b7909393ac1146e8fc71b600645d230d6c262ad0a160d1586bd0a0a5e0abb70cd0316329df09a1ddeb78d6a09c5fbe07e6fb4505ab781d3b7722d5564761a051e95d8fad07778e1560c45bc826cf42fdd27a268f6e14c537ea717f883f46a635e4b3847e8d48c4a0ff6a5687b7fa1100cb6d3f517c010d844478601b6739ae1109ed435002cd6ddd9c8cb248c305e114454e0af027725c806d73995a5c79d88383697828bb5c27ddfe665cf3647b5ec4b9f0dc0dbca1e823fabf410ac9778721daaf39b9b9c5a8c2f9d2ea3727a0682c01ad24bcf9577862105a8913c75a8b75caaac38dcca66a223e7192035eb45e0770b06425fb489b5053aec8549f59f6c38ccbbd4132715b527c27b22a42b540d5d0993e68149bb2bc5239ea16834d627c1ba62c297bf7920d30695c9929bd4dcb46704a72686db68557895f4fa80f18bc89cd04aa65190f4e86c0765a99def8f95a11c3f7a09a8cfbd58b3bb882b07e86a0945e1a962e9039302e594cbe3d3d6333f9a4fbefc95562aa721d9a746dfdfc4d1e4aa6fb8824766b510e1f0eb238cf5756642b5f98285e8e76bc61f1d3fed8e4f4f3b3e582687b5c24f8d90cd2cbc231c323401e0f8a05f7feb0348985fcce7fa999d8f0b9788db30d5c881d11613d04c7161422aad7d71cfff80ec662d20756dd0a1ac1e84d9091f5699b27c3aa795656c0bd62313405da6f07169b7ed10f30aa709245f0aa577700f1ca8d763714730e77024dcf21e61785381b49c59732af4d5f14ebef43dc12a17257df93c708cfb2b31bfcd99ad73ebb64564dd0de01b0a16772d6a70ff78b077d129ddea792468159bbf0e7a9cb05ad6460780f9e2fd533d2e9ad845873dc196a17a6bbf44c231b7b2ccce89d3f83c00580a7417d387a400efaa15dc5e404f969ced175522249d876af9e206821d619fe113ccba777d0c4e8a7808dab9e87fd396947ac78ca8ae6415f1f35fc97b25f742ec66f8915ad915bf0ba6d3d2526679e8b858d570a232a946a0106da967734db35ef6d782cb9713a9b1d2a8e9713cd8a4086dfb9904a3850ca203999e8b122267163f43eede54a5501ecc85fc0026a2abeb7bbb383871c9ff607f03e67c316b19386c479ef9a624058ff8f8dd68ccc3c042146d2f337f4e2c7c4cf22682d60eb0dcf376b5b7205df02f18a5b4efae7df15cb7f7462ddb1eb4a99e81b7fa9a39e931aff897f3ba20281e22685ef1b384dc7e31a6d92d001914166b65b51556893bffadc959326c439a1ed10235b71a1733b239d260cf50cc2737dee637f055a41682978fe88cb2f90854235cab50d09dcd8be6ec2bca93b9dfa470cd404e162d843ca8a4d3081b5a5aff75690f5933b783d3730615a17e215fa419e03c91be6650872cc1c5fa21e1009c500faa0e36fc8f44457aa5ac3cc89af9a27b5b21e8858fee4825caca5c1ac888a193c902b2a7fbbbdd1cf820064c5ef2039dcf71d59a01c262aa7c80a925d2a6aeb846c7ff79a5eb6a77f159b393dc4d594149b58d2ce2ba449c47a65d862ed2e097f1fd10518726768894a8482d95f7a2795c4bb246bba9366ea55dcefaa82b21ea41bb99a3528665958593a53d0f8a81d41c7dad2cd149113576cda009af5679305570010afa26acfa8635d0c70dd4ca0103e38acf813cf615bfe4cf852d577659445caba5d815e1b236b866c3c6cdae8c44c79de3d5d4f7dae08a8acdf5eaf30df0b353958a8257aafb7d4a80610e469292a5af6d8de7274fae0515b0548765cae90e7176311fdae03d98b084f20ceb2c5b5ae8bcdcdbca636f77c38b7e6cdde6b55f320ee20aff545d703c1e8d2a04157bcefa0dd5c2c13e82a5d1b95422473fb3d08d6385b3005fd187af88dae13fa7e774c8ab627d1c5562dc4481cac2cfb2c4f477bbc512917bd10befd123c48ce9ab33f0e45d7f0143bcdb23056bc6eef387b39e5a001259c4aa5b8b5bf3c4a5a2f64c1399f8ed6a2d78cedda7e21635e55ccb79b611c8ceda5fb9c7f9870dcc6c349588909ec007051ff264571c360295c5a50cc6629de3079ab4223fb4afb8e16953f9a14350de4adc5734122eeb6b7a57192451e05d1888a8a388fe8b71e95c82d812f41158758e232b1e847dcea98c661929229b4aba519bad1811a41920cb30323ebaeeb720e9199f21f559873a3de35c9e08ca05ceb09be886e0dd1b7994930219667119ba32dfe2b816ca786171e6c0792dcb7cb14b17e8e38d9d2e9b64a76af92b74f9615ba686b0a9b2bf8fa1b596c285183f85950c1a0faaebcb446409ba00a5c812837819d6f1cc08bf0a754f09fba6809b7b02c18c0bc357d66027678daaeaccb0dc7cea09fe52878fc06024c9abad658ca3c339527cae5bd130f321c7b857c995c6f9089e7ff303acf9a2f4f234b5c11ab2c131bb2e2996d69e8b70995a9b46eebad54b6b20c22178c408214560830844781161597cd384bce02580aa190121c948758e4b5b468c9c86c6a8f5b309c3f526aa6042bda9cea2924a8e49fd5f7fb53701d0f4ef100f80e8f131583e7c137e8cd0be14dff6253400f92e72d171a33061b70153beca206fc04d6d41b5305a88ee05c1724b350595a2df1762aaa6562cd8f7f4bde679bef3dfa0cdb1b6b350e45061bea3d8e2909b16d3904be454eb61212886866db5eb1e56dd267ab4468dd1ab3b6e95414d49d412525b06bcef414dc92a4e24f9a5decd58bd33d9947616b0ae41283f9ac36879455e4e8cbcbc496520c5a9a1eb3046bf8da7c37f7788678a7cb947be5fe86b1d074f62a242ed28c9fb9ae012b53efe6d5dce060ed31d011173586ed62d5935154a48087ef55be19a544d3612888d62fbe31eebdb384f052102b21518cd1cf48e9ae500a1e6f925bc0a4038d78100d14799b831e4635ec3c47ed84e17542ca238df805bfc98337633e9eb71c4f1c8e70aa747e35527b155374b593cbe7ee496316850544801db855f6d4edb55d963506d77cce1ffe45e0cd836c341b450716d3476896e7d713a223771fac8ecec90d112ad823fde74e192c1c6a8ae4c391ecca2cd59ace2128c11eafa478e9f5f57f779b9c946f4d5eb5a8c329a6cb47ca4107ef0606da2d081b9f2468fefcb2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
