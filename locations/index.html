<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc0302a0bfa15912585227acef8c8847e8ca035c9cba37bf6a75f0a50108298d6dc610cd4a2164bf1b1ec8794d82333c61ed18668586528b7040b4f332c5c44de7226bc7c9ca396abd49c91e9c951f9a5a610692ce6ce254ac16c60b5d9b92a686982043870c4a5f371a845939664ee81b64ddc2573afafec60fc6e4b90a4068d34b6e8c25cc5d182df4cb54a2d779e73d2ba1e15bdc3532c7b183923b7ac0bd819460fd57ab3b72c5e4af78baf0b346b7c4b3b0bd558c0f99177f333baae2caf19ebc02221044883df458787c02cb31b74dfb69be684d5e9211978d27ec36c1b7705b14eb30b4440e87d18e058a71a34f81ce45e42dde49ea90dde175b00373fb79b44aacf458287aebda84f97ccdab8c6a218880a7f841c4511780fe3072174e5749d10dbf50ff53c72d232b1edc9839c022e04b8c298088ce67e58515f4368a3161d9b2527ce6d0dd0e48f67f1d40ebb31b6a53131b77d4b46fc39456db93eb9cf959f4473c5c746de75a366804b652f83f942d44474ae78af042f171aa6ba8d47c46b6349655bb45ca5b94a392556874bab06934aad266d286fda21ab4cbe55a8369a8565047aaf6fdebf054f28c7fd3fee72291dbb4b6f1a18d1d7afe2bbab9efed94ee40e51648520cd9f7b48ee14c2f4bc41aecb463d9f7cfb78d69d78ffc28f6ecb57c838371b38d3f12dface4f2bf75e265ab16fb1524b0d69c3c75d7a67ed5e26fd98a783e8c929ff85407d1a1771fb3aa92a3de969faa6f4cbb38936ef4bb5958a84d8385196b0ec33e738396fe4556610c13e2fae736909361c37fdf3faafb134882e8a5a3979c6c820e68edf080cc85c4bbb1beb49404824e0e88518d9470909782aa6f9b9e48aacd221b841287f7fef1e9151ce750bbac379676049ddb0eef5fc4e47e35e04bfb32bab8b6d70ae515e5a363dae761e1074e0670907369c85ed13c56941d53f374ebd87cd6bf629aa19c2bc23366247b614cc5156a31b94a55210db0ef09ed6f4fc6e0c757d57b2d83241165b58b8a25ff31209b8b9bfa8addcdff18587df78a815f55be090b66eb6b79cf5d7f345cc8c3ec02af922e66bfa9ec9d047324f7b43652f4622d8131e9d56a2bbb4508478f2d6f2a121471124ef9ab41de6ef61f106cdc00b0399fbd115ba6377a864253e6a604466867d46bb86f1924e3d49348f10d406e101e8fa4ac705e2fc996e445e7bac66c6b8d985b4993ad1b7dba1f442bcafb4348bcbf685f7f9cf82588cecfedc670821b02bf5dfef952b8b903f59ad1781c03b4909a395cd9cff600910840615e6e8554ec6edaae6b5c62ce7b9b1cd712ed19d6b99474ab9cc050c3d3fc8f49489982183f863177d58cc67ef1128bbda8edf644fb8a77bcfc8031f7f26adce176e403f4de328eceb3ceb1a1f9007d4d612bc6a80473de51fc88ff43d84408677a78769319f9128dfeca2ed4f40b72677cd3fd8382b4078ddd3685192cf235511fb0924adee7cccb9832d15845c25a02dfa0bd2f606a4838cd819a43e5a7a334d44431011104c02a630efee24f26e43db1d413a70a88767c9dd8ebf5115512210c664fdc810876921ae08ff4f501b8135c2dd4216fa4ff9817bcdbf4216b27b83c8fffa1382dede652ee00007d91da20b22536510e9d69ba8f48432c1e8176b434332bed640f74a64dd0182bd4a8798a51f2afa9b583bf8ac67685bc7dbafd8a637d6e24f6a92f68113267baa86dd2de505c90207f077d8636f29221e6ae7bd1597878dbd1798eefef3453d7f6a02b5cf20e89a40d4a907c7f1c45cd76a9cfa539132a04485ae4cf7d54ed93775530cac0b1121773a5ed73217dcd01e3e613304c45093cf3182f7ad3985885bbba68e082de0bb5f0c5bf757ff0ba0ce9a2c75d28213daa0e9bc9961788c7a90f6d58b650eb6fd9fee928ef9adffec502d24d14eeae703812f2d2360bd92df7a7560c66099e60762ebedb53fd2e5aafcc03dfae232661b21527f773163f7f5d0e6561006b2d679b762fbf37cc991b99504b6483ba1fe4e5d9e3460dd159a8b13a0a92b183fe46e6624fbd4a4fb1237f4db373b60440d628f81c4ce4bad3ad41b0e4217efa35c962886f53bdec3b5c8627583b7df23dbf4255348041925d79ca7aee9f4616dd7e41180f4b7eacad3f581b51bdcf93336561eb5e26357aba604bcdc358c29480818be58fb68d7d34ab2e265a6e0692df6ba0278f3e72b71693997bbe089a2bd0959daa51d144e4ec106786ea859894a389f5d51a889515d425873c62f6e0237c4038cc2b3bafee6fa2ba33d2bfd435642f3f0348ba1c495e67c003fe42ab13a3e65a7b0129db3d9a75a5cb16fa0c06f0669f1fed3f2c23b71856b672cdadebecc7540079ab279835e9408e13541311509b0379a4216f98c214e44648b8fad4b2053243f4d009871bb3039d620c5109c5edea1708905a803e2f5e40faa2d0cff1072dd1e61b8b4ab9823b55488c10f4df2555b64a04f64ef0eb1980d82cbf9fbf11fa995a63ed81fc89cf6bdd61a158801f9f2b0d91000097db897b8ea0c08159a74d3f5e50f07fa72cf88b94a07547c582711584075a259fc6db7c20ab9fdc4b21d53da8c0d5f66dd295a6f4dc7937c2aef1851c9a1bdec33fc2190de0799881458c048ed6b6b44ee8b0111035bc88695181bbfb964b7a8aaf2283bb71c15974970473501bb2ae6e7724693e05546f75d3337f7899ca758e706f56c2ed6f393f1516571310b3a32afb34b4170b20291e392f17d4ff4801c3675306888fdc6179157d5f9be4c138af1323d69df684d02707808c2dd6973dd1736bbe061c060102f1d5ceec6667f8f2769c8b5f3fbe4847d919c8d544abf11e8543dc1408c60f183e46b84f395da934972dde408cf264b23cbe2bcc5f9f215ea3f7705a19bd11e5e01ff927c1a6cee842045a233d6ebe98ea04190998276ee31c7379c45fc9401a49415cc9f34ff0dcacd5e1f7c7635ee29384fdf17e6080b0c103b60602c2c58c7091286a288befdb1a38875d1ea792fbec1fe898bd6765d3277c59cbaae404bd8b1e6e62dc11ad43bb1078b21d6ed1c84f576cb46d67655563f54bb698a738e078416192166743f98efb7f6f692c38ffef3b05c417446e1b3f0065c85ef3a237b6de2ccce29a0cc32586cc27df82edbe946191eb28cc6bf06f66c5e1ebf6ae644a22175452176984439fe3569de1494e919319e645974d8be1dd3a45ecbf753761b1959539396d9efc42d89ae04d38cdae5e4e9b298f1be7ab0e0635a8fb81bc7e083fdee01346139a24bcd5c3c15f18a8a729e7ffb071170ba260b1fdbdece62df7328b928d0eb32bad00c04f0a5f8c5424bac1d35badaddbfc688e87b75d788c6067aaadd7ef6bcb08cc09313b0e33dbfa15eb1eec0682a7dd52148d1971016868d9a0abd6c8de04d2d87908cf636225b7bc906dc8366d62a10a677217c16db125d362ccc0ba67bbb4a4789274497dfb595393ad02f3794bf2084ca9ee2cdba64512d8557909439a1a5ecc9202c9af77d2a6a46642173551c23858e247a52f7a86ec8fb20f3f64d844b06e12554764817a1a148ba7fb594b7170aac3063497907cadaac27da589d30dd1238fbb699e8d3d0706696f1da18ab80591ac5a7822a3455352aa47e100fcc8db74e3c4d904775fa979329461fb5520b6fcf4367446e6c42ae9beaeae39215cd9e1739bbe9ae326e2226428d265ce5317474cc433be5810ae2b1dea06837fac1ef8535eb0221b8731a9bf85d0ebd3c3b9368d3b8ff7033a70ee8cdc08b4b1fb6e4154541a531719aad4688e13ac434e2b2ca0d2eebe14e7d1224b5c1efa1c2c2f3493a72e269dd187e8421e2a1df917b2da6a9b82a53674c165fda2ab25fcdac6649568f01fc87b7bbab4d1c571e55084c8b186f80f8e82529d8f42bc24fed647d49ea1f7a6538b6582a0ea31d72034959009dcdd4e57ded953702d776a0ad8d79dbec6c3bb891ecc695b55ab527de3b52278701e179f81ad631fa01e6ce1d32a0d80d69d2aab53397b4565e14ce15a9266685808f235c8df2d8c5aaeed6edabe62a58600e0d2972bfc92974e5815400cfe3787f9d23c1f6de2cf6e6d6e472aabf9379174680e1f9799bbb5ce1b8e5e094ece45ed4159ccba96d51b95a8d302251b611963d44ad03ba7cb9317352704b644c389a7fcf3d1a7211f4a0d93b854c1dc19388fde82f8d6b2ad1f4dbd85420d88b1d31fa451ddc987ec69871a485f6f442f06f7f87b3747acf87676ccebaffecfbc7480ed86c933b70286fd2bbe33e6c14263751a61f876fe8588968517cb8a58d4800eed94ce09e34b11d2327b5f7b5adedad5d2e6911eefa7a723cb4632ae43cdde16c50758e98ae62c4b812d7bd28a243a650a333417039bc9687c879aa9bd18ddaa69c1c2eec233edc66b88b021944688ce999ce68dbf5821b33353715ec696740a270da9dd007c26cefec81472b90fb64b53a8fb0901fcb4520adf0c3d469c9ebee6b51d5aa58dca5b97e7b0561c32e4d4664ef0dd8e50cd37399d67716ed337093699a1d0c7494e13763b96df3450b3f01c7f242ce1a8d07e88f05b4f07ba5158f442dab7930d61e612578a7e7603ecd4fd8f6480b522a37b0a3ef6365b4caff57e4db56dec6f930a74d4aebc380c651504bb1f50b6ae0b9e41bd8c3e33e3cdb46ac1ab72179ad486d1721d25797fd3a7db64c85b84a65f60ca5261e1aef76861753cef26739684ce7aaaa552de55e7d0cf64bbf2a3f6bffef647a4cbfce46fd7216a9c98aa3dd3a3f7a7a869035561d06758a97f3931d22e1a5fdf863755c78662dbc014e0d2499f4e777b57f1d1d03926d6f6e82960ead6c195325761a5b8822c05f81618a23976e50fc988873138cd5fa90be8839130ca6d1811c888dd75f7a6bc5f7b8096e2e0d9c94d7cb16c569996c795b011741592c1873b05964f0947dc3c1ef5297829915a388d37e23895f06746b0268536827aa17ee1776f7a7d442f201ccca892de015b480ea9d339f99b1a1b872bddb5dc856acb7c88f7d544624cd23a7418122805d8e4000c525307eedcab2c385521481ecd1dd4991503d31cb665371aa3c0c9f578838877ed1760d9d1648786d82c3bdc65adee0cb60ea8395f8f93c06ed80be1c185c56602a4668c3cf099e2939b922cb12068c958bd0cba0df7c4532098eb57ac012c3aad8a47ceb01d620ba7a1088d448a2ccffe4f21dd0d5e740e9cacd0e8ad377f3839609965d5e705e0f7d010e7fac7d6818b7ac5c0f1eca698e84a6619cc7d510d78f78ba6095da5148b64660d2977a0de3cb469bb0f8c1359085cb76e22d9c011b5515bd802b3ed0641f0df14e1432df5d335645d850bad5b6b0c447d5ad858bd4edd92a92dd0a1b54a88d8bb12efc0a6e66ede7bda51c3c6e07f1b26ad0e033970a204b61eb7733073ac9e7124a2654e5702a23048b5d57db3b7cbe088f51bebcdfaf51ddefc8fc2c39e717d86f77fcda3b911ba92f935d4ef61022f5877423678f1fef7b86896dd79bf4e2d1b020ed9ff5fe763d9963bc96044bc2b15b1eab74a06df5bb7924a836e6d78875fc6db21151c7fcdd8ae97ee1c64e31157339f3cefe6809fcf64bcc92b6059c5898ff4ed61cac5ec2e4db7ac88b41462802b6c5574541a24bba926a8e197b0c358d87405cc93d82dda7d7cd42b92143e461f93859d94445dc1755ed8e8e46d27f4ebde77bd2b08b4132bbd821355f0d95be663f58f3708d39ce22955af4507418fe33a47436f293c311779c09aa56756bfb3854602d6ae6f25f65b9811c77c0827e816ca67d8f38f97906b9636426da2984ae807e94cb64b91fb0dd91d03f24aafe3d0b7534fdf1b0b7ab9eea8a3ec0fba63141d41d817c3feb7284b92da30e2f70a1891233b968473d165024127bbe493e2a2794784701f4b00d068fccee2664277c2ee86dbe678bff31b2b29b1ef55214ae2726c737a12f02c138dfd1d30d39c31f3da0825bd7820d67674a964c8ea9c42228665fe1e7cba6e7e0829a7c6f04dee9fa95f7370cee3984e22571510350a69990fe989ea673a8cb58c7844b08d7437b4e870f2f2c675801bbecc693db482fea0757ccc90d6d7a47153f4de57261b192fff0d0c7de942af610586439c8d756c930f5ac011f829c8b72a04581601fb47902a941ce7e182ad522d7b38b92526513ae7781d13e01bfdc6cf1d4323b07e6c176db773ab37b689039f0c9d117965d1f5195ca2f9cc27956307944c15be95f5ea335ee5fba4098fc19307b10b0899dd38e1961381830a29df7d5bcefd4bd4ccde7c3b9013e7d8741c67c95a3c282ad2430909cb8afc76603ebbc1111865aa772cb0819181d3fb44e8f0a90ac507eba62a9b346837d55065f2e2e6fc9e8e651ad371fcf8f9f9ae03d6a27037e3af3c5aedb8237f6b48fcbb244ce470604cd357349676f01f47f758ac399a9c455ff908fbe9934fc971af4180db2caabfefb8aeb561c7c3491bff0d5508daaecd48bd0c649c3dc18ba8026c244f115e113d7fbdad2758f6a8b63213ff167c28797a5a63df0d379d67c36d929152599541e35932e49f11568627eec6c8d019a632aab2d1ef8357db53643e93e2614695a8cd698478200712dcd820026b0ad1a2e25ef71931b64a1bebc34e5388ac69ac803db3634effefcc1633643689f1a1976e88a43d4a86bd5c267bd524bb28d7644892a3c2f6d806503af1e9c114dc2e9b8c8557b2366e6233a062f75d8b4a30d0cf6378c52692fccc5a8db5a94f802e73a2814b987d6859da61d468cd3579e24a6b66e486401a22184ca6fcb94cccade6249d59222d7641dee2e33b8d981e41d381dbed1c95a792571dd16daf4e1829806995c4e22188958b5485081de0c6597b499998a1b2e335109b4e0109eeece305139768495360d8fb055c0a20797228b319ee1f84aa66c234eeadfe9100b49c92d43197f40474486eb8012b5c116a6131eed0f3f276a5a5ff39773a22d8b945007ff1df589a2dc0860e230b2cd91d082d0c801241c1b6f424ad98390b99c1e443c339d0de7c710da5d1b7047983d34b9bb9a55c3ff7d569de7fe04412d269f6150a9a7b49309c40a862c0b984527cd0f1e1c7b92105be48d27c3d0065d3e63ebece4b7605408aa4168e0e83d0004065cdc1df8027c63138e57eda5f74040dff88ef1f66e34e153618b9bef4972161b8a14623b19a83799422abf7ec50c2ae999db6b921cfdd167aa869c1d8aa1ae2e1e80d3616a78af815d23cd68fc9da76cc1d8d6d33431a7ba5079bbd5f943bff736e9aa4e31b2962128c4633908ce11939aeb6153de0096b8347fc57271af73b2b640fd58ba9673509300d9e4607174a025b1e0bbf738bb6295d739d67f93bb629a6b4e601fa7f271a659235485e6e88f03561aee3fe834dff502c52eb636371764bdab36bba9ac62afa74ebc343a5fcab870d5c95d1927e4d1983421d2f68e6192fcf4d2650b6200f82f131ea503da7f3f40a542e3e9a937e11fde91754bc60655787f18c0273aae3021959f04625630cf658197c4dc3666aa83ef8ddf00133bcb51002a682b54c7394a2036a1a9b2a2986ff8d11e807b1081fe62e6e1d958db0faaa6696dce7f2c34bbf55778678a0ba90b0a0666b6dbe549f6126e403f3b4cb69fc31c92be86346742c3894f8ccc9afb92c71b03c2e269bacc7313bda133068537e52d54cedc03c0788e29d75850927ebc085f212a7524666481113355e584e8cb1f0d9592b8933b82474c2e6075876d7d9f8edd71d2f6dabfa734bfa2da2cbe2413c61f6d5505167b4d304d44fc9a3ca79d7be13abc3ffe87e5115e99388773fe79bc22558c8dad11996af1922d085f3cd06196784401838b950ea1ed2ba51648a0939758582f1ce5c893ed2a9a3ac3e4bd600165a5678cf4a12c03d039bb638180a73a261617c6a0b22df154b0d7ade85a206073d15a3d53b001f31e14619f90b47a3b7a7b8776a84d096e25e83625326762ce480c72a551f581d3966d649666cd129c09e080c0df308976a0e1010dd2bd3c56452d256c7dd9b1196da3478f1e1cac3073e164a33a39963137218c79ec6ba3ec6ddf239b8da20243476772258366e42127e0bade83ee330cec90b7ecfad377e1f50dd4a7bab94067b11aaa70cc7692f150f0b4deda76b1d9cee06a4dc6cbdd94180d9b85107e3b8ae2f3bcc711af8cbcc72930b458166aa20b8ece46c7b4b7fbf7f31e9927f1bc524e80b071f6887cf6b6c993603fd409384c32a1acc01d324d12bea83ab5ec2fe50b67bf5567e24a936028428505b05ad7f2f629ed8bdbb8c4ed73d356ea5ff4f1ddacd9b44aba235614917498119d9aa88ffca495d8d4108d83c97d3bf7e11d8eaef0115ee131147bcf8e65f54091a410f8a465c0a7f17d8a7138d3df78463ee34374b55d714593532704bd2e5c8405de7c5ae299acedaa3f8249e10b1e5da716bdd3d7506d905dd85cbb026842067e8a7b3dcb5c310c6ba27afcd699c4a6a0a8ff8592149f777676e92fa863fb11ffad532fd7e4c8075a2f33ccd4efcab96f6b78e6f164b84ddfbd2d669e60b114f878ceaa6190cc66b29f5921d5386ba59de29aa125124287bc1aa96f7b735b007f6648e860512fc756defd86662615596d14d2743fcc0106bba314151c3c8211e23ed65a02fa8c39cc8fdc108e334990ec6642ad9fa568c8ccf5b506a57855f25441c1fd6f32d88c76af95a0f0bbeb1cad9996a8a6d0e90c7030f5fb24cce764e11642560ab12904771c50305c491c70868c51d76fefca2c8a13ef0a0ab92c16ca3ca5b9ac0598e6cb9213853c89c245049187875c64b0267e3bdcd58321b8e3f57e51f9836234ba02c277d71345c5b1c1dfcc14f9dbbf478d40e126d141855b2cdf7ebd1fcdddca767cc9ca3e3b33e5dbe9b9c4902aa4a8e29eb59c0ab903370a3bac89083ca2bb2b134afb90b75e48c319a5c759e28a9c79f44b888ab39afce7d1888f7ffef30f07aa6e8e9974bdd6b652366d011b31a7f4ba00c427f7c2c7680a570976d36034c7e1e70d9954f29d270ae6c6a382fea9ceb801044701c9493dac96bb76f6ed70bf6d21e5100604da5db8d9e11ea1d8ccde2b76e6c7d1de3dbba26a97e08d40d46f952bafa5954787c30330e7b0d915aba53290dbe9be784fc4910b6155ad5b0ba6238db14cc81ab25671f11ba199c90d69c23df3581b152542e0e679674dce3b522caf05a5b42c94915cba318cb66224ab05d24fec172704929f59f94ea13fd60c4310dffb4c8d1255c5948d8e3141855dd0e414197d8dcae43b166215424340cddfe2dee6fc92673f76c06d08c335b7cdf04be44af9ee765242864cd0dd153840a4790f66401b9a8c738b9d01e87aa31babd6afae3dcd75aa3ddaf771a33ad7724d0a2ee52e3b69e2eea024487813422bd9a5e79857de110522e9dc04f1b621d7478a0dcd79bca9c61f6de3341c4a2c4d609ebf26de5f41891d17e80748085d39b339f5a1f262ab92a9ba0a90deb5f68f663d78fada7f56863612032ba04a47f2289ac9993c99b0dea6de2ddaf20b109dfc98d370b935ac3047efcdf5a30c582f39879d2066a2db8a8fe1e8a233e5ae942bb47bd995706ff48c85fe7f2dd86ecc64b3ae0468327da1ddfc1ad06fe8e2f677848ba62d5a321fc0e00c3f588e75b0facff53c81af67e820b4e87a8b3ab784d3ccd602e2cfbf39e0b8f9daa1b9ed6ebc631a48f7606d8bd116a48ff3d42c7b3cc3cfbb848cc30b7ffbb83defc758856260e49bd879a575284ab97641009bfd5d8e3a278961b23630a8eb620b6bc587036098092f9a1060e3b4a676428cf26449cc3328419d245fde9","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
