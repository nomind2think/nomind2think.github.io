<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54df47506674bdae9b6bdb749897e2aacdd8c59e0345c04ecfb1a3b45500a94d5c753bed4aa9c55f7beffa4d4eba48d4013d5ed53679bcfe45f5e4ef2b094c7fd74912bf58e4bddb87b12687e5f85e35bcb8dc699251cbd6f9e1dae59b726eeb198f60683582bffed33a53ac72f437c4f98a832b84bf561370f0e3574752275fa03a8282ef22e792be64ec3466bdbddd2b0f02d34aa4b6154af4477fe5f9db21a3ea28250ed4e369556af424749cbfb7299761be6a6b987db4a382f61a1b57aede40e8538245b0a1d82f13cc5651cf573f3650d8f1f4beab56c3f5542f90da2f5842fd3a2e2d7244a4ecbb3776a3b02ec7849845df3cf2b9d82c30476127ce7a32e918328a8ce9ef7e349c116ae6bc9ccbe6f3ea3e7be7d25511f5ace4962110bfa0d848a8c1ca497fed3d9e3d7b4d44ee809d1e7fbc804f0adf65b38b65f06694b9eadb769e12ef7a801e516ab8b1a0d39bc26e1b4664f355ec26792b6892f71386fa49481bf3f9c99a494667e12e07297d0e0b49fa2146378843ff5c6789af5f31c1fa9faaa2fda5688e6ef4801496651abbdf20979adc9293c05c3b847cc6ef5fa2adb8492accc114f793e16b61d9157f6b27e3153fa1b38756dbf6ad8a4ea7ab76c8489f029d310010689720aa33bfd19266a1052d93bef6e24d0e449accc829267bebd4845993c493ae77b90beaeb922b32d4fd05a0095c9e66145f77e674ce2c8e4aa713a5155b677449555da9bebf72f1c1db4ea06459c712530eafc38f788db49584f89fa8bfdcb7fbea2a2e747a58b9b8cbfcf5a5460a556d15827a91282ca290408253aa0243296026e7f77aa7b7c166a27d7a3d00c3c854c96ab4fc2f73e860eeb64634bc2bf6236979bcf9c19718ab86b86728b2ddfd0f408cb573d96328cf159a8d51fdd75b763b23f8de330c7d663e2ec3c106936095c1970159e270cfe08d3971c1250460697135947fb6e786455802d99de01632e13caa970f348dc9cfb72219e61c44350dfbcc7fb19201cd50081cd155c40450bddc1d33a995f47aa8f43b7243dcd9b8d72bbe6e2bd1377235f76cbda837d57a813047ea4fae6eee4678c9daa6646cbce114e95e5b2f00e8e8c2d62af65ede92911e7478dcbbbd982ec884ef51ea89405e09478d10315dccbb23a40a5344c530ae854481cc706db0bd7d4239d172ce92e8dbabdbe159efc5b672c6c0df3127e24980c8366316787ecfec3c5eb07e36e457fc61060412984d0962c3d7017cebcc541bc9b774804d6f29034642f16a78e798c8ad6dd8635288ea314a1bbcc64a5f88db4e67057a33f71c741b5bc8dfd82a0667487681df2739914007f185d44effc6f43fa7ce123936ca75a0ae783cda1f5076a71caa3a26918c3f0aa7ff763b415602d254cc947eeb41ad38ffd61c919e8c14587b4ce5d7b06aa56e88f0b4c2b6dba450342409b849b58d37e323f23c0769f5ad781d2f0ba30e3ddecc8254f2df8da61db23fb1c09e4e5149ba274a498f7711d852798a4c4ddab4572cae0e8a69991a10025dcc12c5f3858109ce65709e1de7dbbe6726f52ee3ab26da28b8e9c16e1e77b2a552211d0ce638a789d01761c0cee7e8466dd786db20acd6044f18cd56df2cbdbc880785e862364c34c9fe60a3c05287aa6c4c5ee8c723d5f954e7be6bb9eb4310b8f7a755710b88a4e7598d2f311dd5d6df92e77ca233838ebc2244487279c597eb26c884d93e5c8a9d41316e749ac96a8d153414ce594cd828f2a4ed3347fbbdd32b537869d4631c1d3a2205db6f6167569c86073ddb5fc95f68be7d2b4be1db1d047e78e5a1db85417befe13a5d333f151c6ed53cbd832fdcf09f571315289040c854ffeed75e6ecd05750e65660c535daaceac8a28fb923b7415575c9694076e00410c3172f35979c3b26537653318e49ef4211f400bc6b685f25ca1f0f3f3a905ed4b173dec48d8278a6e8bc27ba9847ac4de0381dc4e09ca8d1c74453f84a8f5e5511586641fdab3bf3b1110937e9ef62b3d800d473d16629366d6afd7fdc9fc78dac9cd7ab745cabb4f6cfc0c3289f77199664dc87a66257cea8013a665817a138493ef42627d97caee5f306d29adb4cd9ce6fe7a98bb73b8a0fa7dd1997832d3283a5484974d4676a3e93f11830b9c89c52b0f5114ea201d9342c490e8f4282dce28a2cd9b4bfa03fc141f9755af4537c424f78a401ffe9e0b3b5dee600ef4e921859c4f785d93c23f00be2b99243bbf6ac3b33a5272ca8179c06733f5e87fbbf289cfeb6351a41ba5bf2b04c08c6e32b765bd38f98db492bea460669abffe429779411f8a8734db96c18673cefe2382fc9a255745c18b2e4775de41d4913a5bffea9b856cdd6526d806455c287e0d71bed887a2e50dfd51722b6921dbb0fc23b030977ce82a22cc33cca1b2f442a66a06241419a1c143575a7abb65ee449368f93b0b9fc9c9e85a0fe6422b2a1d18e7ba4deb0dbcb6056d5e5db6e5e53828628455a7223401ab99ea09ae329e1773c62ab97e5c94b677cc97d4cf0ab4f82eff38fe8ee05b9aa97e4d89295eec8ad27696429e03b1040f6071b81b6ebf58ad31172dcf01dd96360b32249da69bdba74d39eebf2878bae99e1188d4fd2027f2874c86dec0ac09d8e2cf35baceab8372fe2e7f5caf5fc4efc2f814ccb8f2b7b34eeb4ed3f1479b252a0be0ba3144921a6bfd5b80fc01c84ed8e48879a7a7eedc1ec1c2b5d205bd7a39411c869bd7018ce266145e844484dcf82678b3dadd3236c95e1e6a0295821b8ecfd22b06dbafb0775d05b22cbf83ec4a37339fb0f167c83e2ef0ba19cf1a4c0e25fc201c2336fa64c3fb6bc82bcd73c408f8395b4b18fd7573b963817f54a9a0cd6d25a969c6c68851b10540c3327d29794af1b7ec8623cbc36f933fa48dfcd7d7ae0ab9d66c134f920ae08b9e08a260b7c13b03315efc62c672b3bbd0f128a26b673971c0927ff14d609a41a7a7b1e0d0144510d66a1dea38c802eade05d901a13d39c5f1f7aac7bd8268d046ddeeab46724ebfdc4ef7574741b1597a22094e072c8de16dc7aab1f9f811368757d8f680f5224fac78ff74ae9b58764a66c859c9e9dbba46efb9578febfb94cbbcb363d939ce4edf599f49ea1a86ce6c28c3554b2de2421d1bb2c55d533367f07e464dcfdf17feb90e41f38f5aadfdc0264076b959bd1279993e42ad1ed857576e42325c8baa3d109954df5c8c084d5e1dd79a88bac189dbe6848393b82eed606163682518190e8a0a46cbe42ca59c5e9edd7de097ce9a02ce239583f50ba807fc3f3c1080cf053df58367471c4d2dd791ac307a0e5907c7440bffdd6f7d7a1c51f292d05ba1785a674bb78bb55f55f48bae6f8817d0f83cb17a98b7267f33642410a06fd8d4c75537ad743b309e8275763344c33466d21747f1229ada9abc4c29bf051089fe5a69a7a6c6bb00b29b059ed106da885783f2317bbe7344b02626345f24b7b06b4c09ecf1e267a064f58c92136ae2472b3dbe81e0937654622587626259d9ba7a738239c69ab8f423e298a76c9d919b0a6934d823c01cb1b74772f32af41a3a76d8ecb51f253c00485fa4eb47f9083151a361d4ffa11798f7cb21ac7ba611d74c2f8e902c033be4a807ac996b4df68248f0114ec0e3672e07f07560c4db1de49d2e24f687aa5cc2d3a4c7f859645e4615341bc7c14341cf1c448d08aa866068b07a980b0f8b0391b6956d1eb8d4d9210bfb216123e00e22ad1eaf2d8ea80d2119ba5ca2c821cfaf0d459801994fc44b893bc99dc884039e2482d09acd6e1bc295bb070a2d34cedfa9be2ae5fe62e633d52916ad7ad48052213118b59bd58a16776275d463b2857a8744c2b8dbd7c2d5ffa4b445b2797871f7f7e9934e15586f4abe55f0bc943533e4b758e4a87e154118dbe3393d1f76d66067a477de1b460a9b97a55a5491e0dc106009a003f5823beebbff4ee7f3b9877df5450287e271fc8dafae80c6a2040f6a9a4da984baacae48f97afc1480df7415dc39aa7d85866cebcc06e4845883b75bfec17af27323cf1081b4a288cca7e58bf466e47c59b33649a225bb7c6cbe7e07f097af2f593427623fd9235d5608591ff0d2036d39ae5ef13e8881d97d9b167d32eb1f8a0eb699d74a0e760ef3adc1640b385e48823e57ca26a466f891e0e5513d063ab2cfe55949e12e6e551469dd1384d40151c4f4f3d16757b7f5d678fe24e7155520091d880b0e19c31bec62b3364a430eb0afea461ff65f087574fcbe29e3430642d9f7ac19ab97e6cb532effe59be25529730ab7fc774abc3bae347d771fac865f6635c8843cccc605a82d9fe883985c28e68b3fd080f132e0cb38bcdfeff85bcf3b23d4a9e6615aa421dc52b3038c01227681f876d12dc0da5702f9e6125c5dedad5b748510d7b38c61b4c0492636debcdb80353e3fe6a377050efd9d33a83bb7a7ebe8719a9739db715b3180dbb792befdb61cc34cc3bc77c424a9e18a58e6d2bc8903f243e1a905710d30068b080c0baca0807b326f768f65b05b2bdc4e111b456913244f75bbc80ac6ce04853209072848220896ab43aa1916130f21e65df1ac7555d2d6c8f14242e91483b73d2cdda274b3e497bd0cc16def2d05ff49d47a288e94a692bbcb0dac6ac8c9a9a5028134e2a0d35a1b46d5945963039ab0dee3de0940ec3110edfa9d11fbc01fe439debbcf072f10b4e4bbd0018327334cf2c125afe5fe2d049bb53549d2e6717dc19784bd128267d1b6e75e1c5980900d2de17465d9d4bf712a0b3f2341d644d6edf9474a044dde5b16d8df09bfd5140445aff173e6325b8ba56a0c72dbb3c76eceebda7cfcc8d00a35541323495d9d5ede1505905ef58aa28ca917eefee5f8be5f5190e0b92dd49642422d9c1252079e2438af0f479bf32d781c772fb783520c285ff7de82f510659def13010a9cb34a804293bc217293cc36fb7961fcbe913411a8d5036c6a5c1d96d795d9841dddba18af98b8bb3c733d13f009ca61f77366e370e98f0aa06a06c3861fd47bf27a268c86c14414274f8bbb14f2bb1be6322cb6f095545b0dd2bbd78fdacc1f816546c56152862c49981dc0a9935da80f2c74a8f27ce541fb63964cafe18dc4f58905b6a8f77e8d20ecf67c6c47a2ac36cb2db78065325eeaf43ac07fe944f35fc23473199b685bce588760741f4e169d6cb4267e1ad3f116e961b1c4de0317373d47567a2bf1ec8320b9397fd6debb4088448d6b3901c3f51fd0cab8c12039d0465a118a47826d0a998832bb0619921795108a3b740008006d5ad3eea86af180fff3d2daf9bbb092de39665abbfe2af439a5f4bc1cce64964028aaa23fb556c7a8ea83a04759ee4f2d395cbcd3f5f1b5d57470c55200e0b12130f941608d1feb608b275fe97aa22e47741710cb7cffeffd6291bc11f644e327f596dc2abbcb8fc3e3cc6d8bac77bee7206e935615902b7820b688e3dc838a922f6573330547cf3ba0d5f74cb6ab059a0dd1990dd1854d770ad13368252b5e65c7e43ba743b7c28e7c5b27ece5e9866fcb36e0069d99db5f7e14080d0a08a69b26e64779128bd509339fb327f200388d4bc78367985fa71651cf77dfa6edeb531235449e45e71c92bd39a85533f5c8eff2c15f73b787a4ddc28bd153de3a077ef593d8e401b4f541f6466cc82d2b8780727ab1ac9dcefa1bd729cb9f5bd5f74aa15683d5b28241cbba2a0375a467b37ae3d84348ed0936f01672a0884dec075de933b439c938a2c91d0b051de0f634e37d0e55ff4db33421405d34977f843a66a853ef030624b3757c5a5e276fdc34d129a0ef068a753eb53a081863a994f08d38e5aec973e89e1e7f43e9967d6a68b80b9e18c6080bfe6be542b1f107f8886eb8ee74db0671971d43e244ea6e9d74bc337fc66ca515fdde5ea892f53359d3d6ca1b7c8888cd3e653a10486be270572f69108df137e0e55ceccbe67813179c9e38e1216227d2c88f2c6955ce0049fd83c95fc78ffb8e2b603bf5dafce05ef5022f8b57f6fc7122551cec4ff05c9d1b3905f2672545b6c38da8230e3d7b9e603393deb8031627cd95216848605dc23d4afc2276b85e9568d06ab2a09ebddb0b8fdc6c21a67c698f8acd39b3f8008466bdab5f3fccab86b6b9bec9569809e220c744a2f5b6eea32b186b8c1d182054fd3f91092b24fa0ad242a146cc2bbde63de585aaec0e5d24c8f5c4379dbf648b4a873c57ef70680cb6cd1b679d8faf5c93cb65b1713a95fe630c2fe768284843fb57f032b97656a9167e1c6b97270e5868c4b699dadac0cf5bf063ffc7f3881c074d7f4fb55e8819d503ff0aa4921217e05337750a41ce87e01dabf474b9ba85a740c9849642a515b7e08bd31d436e6c5ce9ef58ddf796ddafa0a0e1c35bb911d621d4a79b31b1e3cf32266b49466ea1560af2662290c9edc5f446259bec0aeee2ec9a2ebd128e64743de43f3d51c372fa4cd443231fee51081cf7e6e9285f6bc90b801bde431021e4858b4379fb1a627f3a3ab7f00a9270d363ae225104d512887ad0cc5901b920b7264d15a99c200971a89eed8a72ec932bebf0268b9b214b2c7af8cc86c62640604eb49f35f2004def96730f11455df6aeeb4e3242481dda3ffb7c6bd03ffb62699e5fc800203ebdb302f487505ba95eee6441d153aa607ce9b790c8b123b9be7ae3b2a9616dff0c8571fcb5dad1e66084ca926fe2caa6fed28aa4a814d295cab6301046b68e3620e8090d2b8f8a9c10f950d4569c529c6274dfed2e9032998408f832fc73bde9beffdb1b86235b9d497b2c4430afb38707d3abda2f7dcfa188f78edb9ca1fe51cb4cae346c1b86250f5fb5ac29c595243fb5af5681ed7faf315ab6f60656eecf5958d3ee92dd0bd2dcf1ad4a7372d767c8624740295cc82d33b78826a271090ca900cbb0ac1f9b2474f212d44eb717d0afc65c1897f75f4e0a113364c0a290a222993908773a467f501387dfa33efbe83b929d163d0ad90201930c9fad57541ca50007360d1637ece3ba8c0ab1d6160f8a73a78b51223866777407928da0723f558c55b1a79023fbdabccc86f61ca97f39b44d5cf14ec4ab0bafff886355a599a49f30ffc8fc028465cf8be3f1053814cde11ff433a0b980493af9d33ae56fd03dc72dad1e26bbc2d140dbc98a4f96547a80147b6c8e4ccd1d4b116c13af275c85eda058b15988a663e61f30441302bddd2782f3d39d8447a772998d269ed4e3a3b88493121fb52641ed5877760ae7570aca286f90354ddb6d34f8853d597ca91a8a47fc3b0447d80ff81b52a8fa6a4c522da27abcc8196d570f0aa3a2758e2e12981cac363f3f5e2c45fec5e46f852210e62e1a8dd33aadef98dddbca021ab6a5d2a1d1ca546742ea4d0509f6ff506943c37fe7953e37fc0115bbda4ca3c077353418d5de9d9b9ccbb3ce0b662742a175ad24913ce452352b54a7fffa3b070bb2d09d68c69693089cc6970946fe27f8e0633b44931ee28da86259567d1a448331d8ef7d0e1852a7b816b67ed504569cbe58f1db1a823a9b5c8625074f0add679fc47b7627cad30b5114cf266630975e6471852eaebd58b50ed9f506d85af32ef3a53e2b719189e3db71a60f842e7af346f099e335acb4833d795ca1f9bde835b30fa4c228a4dae1586243f2ddee5af5570eba5780b69742c0ac5db304be7f1ff4ce7f65a3bccb34659c8322e7dcf43d3686847f6f214cb0ec6adfdfee34f1031c45787d078b5bf65795ddda051d769f3c73b5db760157230fce09891a5df0a43570191602653e65fa8bdc9a3c0839be40187872978c265cdd8e177579b3a4e31db3a8c4031d070a94bb8ff6362e0af06e82a9860c2fc1f6ab1d482e4dd443d16da742ba4859d0ff06e13e6e6c5d4cd035702e92755363a4dc1c569335c44cc8be736d19db4baead6d86758215e2e8e755d2289c966298991ab8af88551fc92b6c667891db881d7a22fff83157a72c7822c46f02de1a348ec3ea9641dffbcb7baaaf718378ec76777faff924ff83521b5fd117738893e0e4d1e12a4472d951a557ccabfe5df7b1a59e0ee0ed897a11e2ed0ee80489a5ee038a5017da0d398df251fc1d7df3001831383151b3aca2a27d4bfafb1ee2c62bbd7b469cdfd07135b4b4232b078b7686a6d358fb35bcef9cffd11186f94ca5920115c5d6403984fc6950ef121adc34204d60b26e4f7b95cfe07f390cbeb0f620c3a155e102e728b7e29ff069de60df853ac90ed86dadda1d1009a5dd2e9accb17c40661c8002bde3ecf28fc4390a941e8e125755b685e2f587f7657ceea6714bc893ced75b52baa4adc6373d7e5b97978c254e7663f24a5ada4d874d1a164a5bb09d194b99a15372d297a0e22a6603cab8095ef93e234cc66df3aad28ee7cccdfca90dfb5df2b44d468f0e340f48394fb8fa2cc036d36515af900e1f90522ba4a0964b35c418ed802c3ee79b30bc8193fd138922113f8515894405ba0d86557f9138a1dac8696d4e61223ef5c34b561434d98c8aa4c50aceecc06aae13890130c9062e383f82a5d01bc6619000782af79f49580286e9fe25541728f182246d9029a9eb303436c47bd74b96d6f80ec51d057a134d18387baf5e28077e9f1e25676631491bb7171a9d16bc6c007eed9bcea0f0c9db1b09a6cb5f0ad82e251061f51eb74ff897d6bc9c9a5bdd023cc7cd7d01a86cfcfe9351fb339259f07a67ffb37e3a710cbb3d29fb28a496802eb6b085ce172106bb6025ae6617caa88eaaddc42e1055a193390e0ac39500d9ecda192ea4c93fd20e2426f9ff9781aef4321fbacc602ee1312e2810404d58437a859898053aa0fa980b3ec7c44893403a35e20313673883eb0da0edd38f42825701a72d576e21feecfc1b0aec286241857d5abcc7e5dd1b07e2167eab4c6c4a8628e1d57dda9d9c89e46119a3f2d329f44cbc820a660a614be93824822d55d53c5b52b4c96eead45adc9214e414572ec07abf18e701c1da309ee3ae2e145d4ca68c23c65e0e2618dfb1f2da1fdbf6bf2ee826e2d26382b89877b76f7890d6ee7426971b1712a4701869c00ad0cc96c2caf68324a0b0970c6c95303bab71c728d097c6187fc4f565ede85e6e5be41aa0628b576e683ecd82d431476f26a2c1748eb360fb9168c2e9378cf2d113a6cd5a54cef3b05016a054da8445a33c5cfa7d74444edf9f3260eaaa22dd1ab50c2771c1a9eed5bb2c56cd9358026b3e7dd3b93c7eff5e2218c4e3efa0644424915d88c60d2f685feaad8d8c5024dc07d42719c3d932f93fa0ef4c42624fc720493f21d0591725379a823b37425a177ea1c7581b79f8be90fa4f334807ad158aafd30919d4ed4c57c217264b5e206817f57b1f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
