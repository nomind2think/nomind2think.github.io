<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c1c8f5f4a5d98ce5c59e8a2946affbfc867441f58eabf073e820f6564e751b5de6ac5faaf12d9c9a74fb18d19358b96317a981bab3f61fa6fdc1d9433782d11a48d0a86dce72e97eecdd9bbe7dea9fa55f547d3e9475d246f0dd5f89261a4753903ca03d47cb2434c391fb08dd57803d359cdf1ac4d61a792c4a90e7869af3d7c8cb83a1f794a5503ab64e361bb3a89c0b8926b10b115c63bb65352df26185c75808b97c9c8e8c3fb6d173865921215c98a86757eb097db3dbae0696bb5b948dfd7a9306c791a86aafc7e602bef74fb65cf9fcc1d229d7bcec0fd84103c1e9f4511b36eef5c5f410c1ed8ca9bbf0da7a465da51ac6b1314cd15b0fdd0ee5d8f959ac8bfb60d167ef34e7e5e4cbfcca6677ae23b4cd73b9979f56c8ac61b7479f6e5f48fe02c34f3bbee43eeef3ba69b015778e046bf6e6dde847856098946e214f0669eb5fa43899f8f07cf35291e9ec0bd4d8356ca580e93dfc479c6cdee4ef147da541acf3e2e476768f1a5225d4daad7592a73625b8447c3d3784f9e9e7bdc49004f1fb767119d179c14fd34eb727b1336eccef3043a9a268936020926e6ccaa398004cedf1fd97344637a1e6d063a72d082084ba68deb57e8ba3cb32ac5b57ac594329972c45f5d7026af45b28a1d38b842175fd0a336f06e8f9c845416c321f24f212f93d02587b2c51d93c211ed48b687f5843830543ed1ebef18daa0490177f2d0928b9d1d4cd5ecf4355884ba95925a2e85434d3bc393ee74e5ed4501d3311b8a2d773e09a70ca679f421763f784af1d7b1a6e8257d601b9845553173cf3d649085ae1398fc290e4412ff17d368d65f41a209042ad7072287d2a5804ea3dc335a8d714def37289ec7b707ad6283956980c6d03e1c3440d2395d3da750ecda42b35fb3d4fc800aed31e6cb8d48441efb271079ed20b7411156e6f2af38959913a028e4b34541355dc173e8b82608fccd3ddb8622c1faba5b9029a5eba18b8f986e0e0783925baae2b1358afc4733ec98eef52c6ebf08ed81a902053feb7e60a49bd12de0cf7c531799078f63d163e191d456461bab2c23ae954eab59088f4d610a6913a9e4f0bc1844fa3c66faca8191478d3885eb30f070523f002eaeefb4aa1a7f430272da81b68ffc3e16288690de57296c3630d07049dd2ecc5d13a18e3b745356e793e832f585408e3ffb7ce1297079f3c8a8b7e47da192d0350251ff5b9708671270979486c50aed0199ec1853cab60d479001aacb99191df6d2cf09837850fd5eac11835f999bb697098b882b7e8a2814c49be568a252fc4fcbf0afaa0b0483153f555c411784197e7a9a058baaeb0fbb1b21ee29c89efe4a2ffbfd80352933659b5ddb8d324b2f2dbc6c7414bc568d1bd6f6dacbb02965f9a93eb87702dab31a57c6fd85a2bf76121ac627f3137eadcd993eb2f3384fdfc12acf002d5bcb2351a70e6526125aca7417c33b4bcc74e9e9ba9879e40e97f4043c8f28f75d4d82bcb5316a88871ac5f44c274cc132592c8819b35740916486134ecb599887f4f4a9e3a5ebbfd948b304801a10b8aded1177fe03663fd59dd4010ec18c51c5ed17e97b04bcc3a3ac51a571e060750539cab129d1067ad5572ebc14948fe9213256361aa82b09c25f8d363504c8a45a6a04bf812f4ae2eee0add845e49ae117a6d063903f1d59d3ac80bec99f4ff2d92271a75c8e4f8eeb3d4fd8fc82c6e5137bae751c4f78a8c028fa757f9381e1e7711aff26dd5ce481c2731864013be06ed4448e1f37b375cff7f3d09544c366b1a1b5c6373e6a04f484e346aad36e52de3847df070276bfa1de7b1eb5bcd6fe63546a34005815d62bdb8b4a5a40de09fe557051ef4dde4d29132f693334012d33e507244519dc2c03b6a6b1a0d64eb448234c9ec23fb3b5c6056ec799d74e84db68c7ca6d1434824ee7df2188cb171f9b7f885b764f0696412725c1578b95b50669654b4a7e47f1f5b1e8a72c0582b4dee2bd57544886d58660e1e5c854948e859edecf7dc49c4bcf4fafdd223311e14a274483161fa60d47c303146bd1f9b168a01bfeb47a18e6da4eaf6a500970c3d7a6de412a88000225e176495615e721821377ec50b1d55f2aeb5786d91ec5ba92751114c1e9f9c3047fa15202375782b7258fd1573f1509d8e5347756fca81b0d3a14a0fbcba0e44f5b40f00a29cd6ffcf6c956d6a4ca3a5a937c141055009cf09f9ef800fc536ff15abf8ec5e0ccabd170fd11c01aa2050688836106252c28778f5e99102bef823f8502f9fe6460d134e0bf0d7467b50d1763873b02076410dcaf82a6502183480ffebbf2654c6062e22131c93f279f89693c802abfc54f1de0fa42a699941680938410a6954c06eea3dcb858663947e725597b8ad9dfe7c4518befc27181010afe43594190ee2b8da62079251bb5c29ad9b446c291b6afe8a311162fcf0249ab603752f2bd4fd4a2b4be292a1e43260c0df9e2919f22210db01799422dd6fc004cf49b76adf6d3008ce7241a06e605bac5824e1be65af7c870a45da84591b382eb8a9da3f79a995dfc47ec35104c5c54ed88fc5fd3beb6e42ae3fea7b53df05154e349b4aedf6e8eacf7be5308759c08d4a7755674f47341b2b7d54cbd3ccef22d1b38ee8b4cfc160738bf9314f5b769b9ae40d0cc29a7ebf4be7a5fbde88f802c6127a6a0e9a0b637bda5f31a8f057ec146f2ecffd756f37e4adce6b2097d1d82fda68dad2849954b6b13e12c1e95564475956905820efe37d3b20281ee07d1945a2145b78161ed40e26c7589cc8adcee35d3968f74d4a2f3781e92ab189f8c7bfe543d29550d46d6b3df52ddd6bba42118e7de4d4e62a919e85e0082ff5a651efb5c44975099f7cecbdc2943698453481ae21a1d5f70236e5dba5230ae9f82ed502b7f4babf40728ee225ad6fe227b393fb8319cfa12a9169e6a7b03b0670ec213df0d4e347e4fac902db77fe4c36b80591177e4c73b21d1edcae9380e70c3c0b9ae9cd0b0f58220c505d1530014c62a1af90d22984dfb59c7914deb64bcfe7d065fe53c5def69ddddb70bdffe73f6804325ce0d9dc0e7a409c196e3754c1d446fe9627e6f6d1841d53ef57c11bdbbd8cfcd06118c3f01000006e0504b333b5b01e89b6f33a39ecc9dfac1555647e7155c137ad7b5402f1b81ea7b5235836f8c93a33d23e53a71376a494f62104207ed36e89e41bdf61bc16c5af92db065dbe35de717239114df68fa1a2446970bcff649f38e22b3384dd2ac01db82104e512a31bacd3ab398ba707a82baf3132e1f5df1c9b4c90293826f15e841bfa15aa56ce7cd21465f40b2a5d4887fbf0bad862464eec8cc12994f5296091a28ab101a0ed52b40da8d6a1592d5992cf7b35e93a1fa1802ba78c41c09eab8bebffb5c7508df1385082e4b804f9616120df8a2b96be31ccada9e342c2880d8c4f24734051f55e14530d80b070d4773816f213fd51466bf83ee69591fcd9c8a5ea07aaf068acf6a7affe3fe74a3edf85fe4ad7151667b4250df7c5e4a8085ccc63f1983d5281e349cb0d2b0c68ca1b50147ac8b382bf7398a4c0635ff1d310c192fc016666eaa9c89a4e42e03cb22d54bfa4b97d75b1ef0d195c3727b57e20866009b03dfde4123f09c2cfd60b700794dd17ceed95710c9b1550d5f933c487586fac4a31124af136fa9ddc30c8b4b0fdcb025fe2c0640d8ca56b983823913c7a6b0ac188bd6be259d998ffe2d931b722e5613e29eb220c41ef74c52738bf4535efdde6fc9d04b967dd543d8b3a99d6beb554aded192782122ca06df7991738ea942b52c04a93e899a8a351bc166b51816419e923fa50014094472827c9052ecc1fab53d06de147a079f67e4bcbe2ddcab453eb7239a1b74ff2e4fa3b12a2f4e212f472160b6342cf772f17bfb155b675bf20bf802735f832e109c029ca51971782dd2f74d6861394ee19a9dbd6104d633129a1f18510289de89e287876cda1991212c7867e7e49ca67180ecafee92aea3f0118649afdbb60f51e23bfbc175df4d02edf9f5abfe81a032e6ba201b2a80cc24a0eab0c70faf8459ec070e9e9d6f37e287140c88f99b01e94a95eeb7c90d72963d66c62b398fa387c7dc5d8501778c59ebe0eb8fd1335fd40d8d998bce0d829e8b746f3c0e8fea82ec59a94a6ce27df2f9737738007fac98e5793cf560336e9f32e4b527cc30fa8ebf27d4d8ad995dda3a476cb2431065886864d89a60fb493d4ac9ddefa7b3fa82273e76b9030224a22786b990bab5a44b3b6218a3d619e26e4459feb7d7525266eb9dafd984635676b049a09d549c95c776e5043dba44cd9a2380e80f4fb18ab34fa7b1282470581a4563124c5317cd34ce3d0c01c78f35cc6231850891543968ed0943e1cd6a73f2de909439ed370dbbe55448329c4ee8339e618b8c479d6e4912f009300967b7e1f73f95b1e31c8ad71241a3869674af53b3ed8b537e06816a22edac23a38c88cd8c2c7eeec598137238e87fbd2339ea8ac7d9ffc15d13978d1e9a7246abbf1d7e63d7241b6b2ced058996f7137ed4a3536f60a181eae3a8cd16dfc7e605333c3cb52a8a5b6c6ee7b79555fba7742ed2fbe6687bb7fbc4fc831e47b4d3ffea1cd978736f9eea9917c84ab33c86af6e84f7d923706cfd2b71323d55900f220200c6dd00c5861caccc633451bec67d2d23b3c101b81875875e8842ebcb53acd5d9b6e50bc4bd138ee3eb93ab1607cac72ac65dd5f32a2ec103e3f59cb38bfa19af14a6fcd67b543fa25d16bf892de1eff7ebc67acfa4906092d8fa41ca0834eb5104532d61646ee472a41b411c9b2f10b359ddf99e10d4c10729c81b9c0001cfde0b63e816dc70df107593a3386cadb653c908b87021c9e650ec0e4e9cfaec7fd2fd8fd5952d144d12c2649a10a93c3bc4ca0b5a73efbf32e9d633a407baa3a1d2d8783e5dc192afc2488d02e51194efe0bfd42429a8775f963799ad30e9b0375bebbf4b496ad6bb19877b676fe6f2075b40ad1fea65a4b4a182a2aecc0beccb1a2b7e09578c7ccb926aefdf9be85da93e10b87837b5c1712d04677aac72d33f72405bb6a43f413352f735899b56c6435e91d306dcd26dde4a5709a924602819d5c714454c173723c17f41cc139cce7344d9bb3a840d1e9a5dbc36a8e8346fb68019378040bef609d308fc46053d31d88e26bdf59eb0f175a7363f1c994b0f7a5c7c786aebab98d0d2b6f5a5ab4f73ac81f3944849e5ed16e3a85bbf5f31043a030a0bbb64cbcb6f4421c9d9fbcd0d245beb6420cccaab64733b7ffe3b9a43979bf7bd135ab2631873d7b6040be46eec40a4b4e77476947e77dd804770dddb869a0ad02b1e45aa4339571ebed8c936f10a308358d6c5e2486cb25c0ea4c9f27ee1002affaef665cd5fbca82e27226cb18bad5957df657e18f0d9d24095043fae643896c88c53d004f86594444f4b3ed74f6aa69d577bd5e16ea4d28d0e5f379afa888c0229c4ad0c1c3536a045e4679499f262394576ee9be69ac7ae2b11dc41a9af2012e4dafe2468b9c4be2ce34762be629b26eea014372f280e15740c8245a5cc80986650a652853c11839397af6322ff6abd6113221d5a36de949ab7f356bb4590ddf53aa8c276550296c92b9e90d868f0c8acf9051d256cefdb9ce21b12ecb0d8c1a1e34d8bfe2d2febb316e20b3d7d6571638a31be5a91a896eb1a48058188663be9f106f1f6a83a80d209c8b11c883d3e54ab9dc40827a72b6a23bd1aca89da973c33009dc922b53213c1304a79718e710ea16a1614f28e77b43c0d6a77f532e2c4a6e7fb2d3769078e3a3f139d1f3a02b92a30b9f18fc2bce6b9daa863f4093c6b394cb96d7636c6d14736cbf0fe5ca2c891bf800708022f9904ae52b8e3ed7a564d2979d07a5a346f0db06d59f8e22f2506afac59645f0a5b71918f9bc319d8327ad2c638d4f6df4d049b1551b7cbffe290d77d423ebd568e281458caa1eb771277ac24f248fac86eef183b23745c79e9e70c5eb4154cd1ca7c3d870e1d15ed4775cea42af10d0ea66d54c43d1ef991ea9d99922ff482232e2a8b2d0fc48934a5511f07878b935a19bb67154b4dc75f7f486d73dc4d7ee27f81799209ed5e8402f815aef1912e041f9875b9fc7f0a0b1006423fa26e88d7f08fe74a72f2371507cb886b6d6a26101cfae8e88b6c071f910827e23210f6afa91802de3eba6c7ecc793a2f7e86863ffeedc5f87a98aeb4025a94214843123205069ef09c216054dd60e8cbca591a32504dac3df8fb0774b0412bc6770b4dc3293fbb179f6d2835d28971ed6898d203b307c16e01e98ba18e923b6f8f18695ab4ce1e8816821e6e981aafec0e74fd933b9b45bec70a1a59bdae1fb62649ae2075d273e240f609a314acdf7d184e1053f2b177af24164c87fb53bd889fb4da546f545b434c2f447ffa29e589645c691d48d094fff82e567f3a8bb16c712cb7d3a8add6f7039d1e68a29659637b5bbd1fe5737a4f61d59bd397c57c5895e52fb57464d901043a0538ca4d8b58ea2d73561068dbe4ca8575a785aacc402e8952c6da972eb67f1dc48bf5bf65f2898a3dad97685dbb3c8d473cca1830a53f1d5c362133ca193b437bbb1ffa6288ef1e39dde79f2dd7bd24bfdd2a171fbd0950f9a35fca9c986fb37465fe9df2b598b5ec74f9337aafe303d22dd8ff9d87e559ff60dfa7dce1d16fbca2f7e71a2d8ab25e68af8a2f6666a50f34ecd886dc088a03d60bf1fe0420d7287637d473822863505031af533be7f015e5f8bf13ef2c1c6cbb20e44a388ab26f8a8c8a9768cbbdc773d7c7112cfc087a3a242ce803c95ee9e46934147261f358cc7f72efd35990f35bc9bea819f0646164aad079fdd6ba57a12a2b23cff89d0a340fad3e951a061dadd8df309fdb5783aee831d48b0285dcb974bbad9d514e17b03967245a563a52ca0bedec2247f4acf88d07f784936207aa7ea1570aacda83040a640727df42968c742b78aaaf54d6863b8dc957f0c5cabb83329c81d6343143637285951e72e11cfe713c56aca17c2abe6093770e45aa58dd6b1b90b84ac48a914aa0738dcbf9ba661b6d38d5cea0e632f53143356ae81a6a98ef9cab956ad5436e40d0bcca0d62e307677fb23e07e749d2012b3bed2d6d75c27b8c0bb2f5769dada1c87dda36edf1f6b8dea1e2f05ef27aafde9db2fb60633cb93d6f54f27d1bd0435485fa9a00aa8c70bcbd9d7e431a095976dfe68700ce2f236c08b78cbf26aa725de810ec2bd2c2f3750eccf54fff5a0b99fb3ee234f931c0fab91eb14210b741ea08a327d21d65bf07ccdceed3c5de82e51c598e3e31b984292bda12bcaf208c3790d1c57f906126664bf99c0d44452cbdb445f11b4a814c28b2dfb13e4ae22e3033211ca030ab18db947a0586387a9ca85d985c553516c5709b2c4ab3ebe4fc270f25794d2fe5d60a9a046c2946aff3803e4cf85113020610276c92e0c2a87618d00b15567d4cac4f5b9e2605f431808a16464ab867ec721107d4ae3d31352ddf78a8481e632eee0b16ff9fb4248f33b3061636f2f5b46bd42f2eb5495b0f0c89bf38367e52c2f94518e414168833394f87e60167cef6994a528f352ab93b9b33982526bb28cf133e5bfe4b12b742bc184290cf529fe143b9da760ec73dc49c5e823cb5b119c09ae16374077fa405197c5c955a5d3e7c3974c2c9a27f148d3c72ee279d4d6b56641f7847113b7215ed31634f3e3488c0e1766899ab61607b871dfc44dbdc0abae434ea314c5c6f25b8cc2fbe2533fbd6af093def95627968e9807901e37b3659ed7859f257d89a94ddb7700eee1c2e7889e3eca9b479339f655b138c27b5c8ae9b6f5a8166ea503d2edcd80cb9e159ef2289f4a1b0eda6ac45f593aa15ddd51ef6c1352dc711e5b5c616b1b0315977457143c444da70c46bad9c69960def41f8b1365ea1c588d501f0911e158e6533bac5b0952add962cd8177f3fd933b48df2ae01abbe1f1ba2746da1cd7974cb9f9724fea60fd5a0bd7374a3bb474eae7b3ce50fa2a202dd3292f6bce78d2ffed8aaa2d1b4ae43a6ae9280eff9f8e85c40ad42e358db3d5590c1270d828686449c13f4d86daa3d60757e5463cb8bb94e58bbd03a6de498722e95ad74c3f4bccfb632dfd4817f7aa98db8077128b92f005420844228080c44f210b3e7968dcf466b1c39274621631d2f9c664d3746006ceff938d58217ed2b37d0451a49e252cd7f78794a088a9707eb4f05d18aac5a52bf5689796e965ee0b045c18c77bd3c4b925d3bb18fd6580f00a78d10314130706dfe333daa75a79061d5cee2b1565f064f4e1f4f7653269c71fd96cf519155b316c0ca8a7c8a9e996044f606137afdfb574e655b9a913f59c821a2b1deffd1ae681b426d07b371361ff4650b1e23599f53dc93b3a998726efefc2ec187fb9483e7607296412acdf7e0a67c3e557cbd8d2b4f4714e0caaf4f12403ce5c6f972de750317d544c6ebaaac5acb8ec3b2ba2ad7fe674b4c90b950d32104440ce7682c6fde779ef64b44da3fd4de1e5e1449c9f20b44c9f06dcb19776c88c1ddd9a017a2ad6bd472260c46e08e08adfc92407588014772410ae99781256c766f5d21c531befe5e7bd2b8725082427be91289924db55a91ff40eed720c65247b9106fa57920e1c5d90beeaa28ed9b85cdc5720abef5023ffc26b1d2a5d69ba32274f78ae91b1128757cab4bd5442533294b464b5755ea4e81ac4f760d157bdbbdebc6944f4c5896af64de62ba8bcfb1f316c9842f5ef0d418e272972a12f89b36c15dc8db44fb96f0e07e7b0eac89828e2896b894b45097975cd29e67261108902c20f293207912b2faf75f11fc25725b9166317dd76a6064f6b60a541f29c9f2884c3d78b8c0667f7133e87f9a46a1a444963472693e1066b763bdb174275800d050d46fa2b774f44989d7c9d70f1670d323551fd75e1190a1482560ffbf868bd5553f710d1fb9227cb07e5a3d8ea1c8cda4877260bc7d6f2fb77e89a34ed04bbf7f83aa142f0006ee9a351e9f152d56a8fc1feb4ad4a83cd6c039e57af911d9dc7245560f507f6ef2738837e27efd1f0ad4d9406ad78c650de5cd7d86006c78313e6ded97057eb2ada5ec7726153b59d4ae64add2a8ee23cf4307a00d2b9406e60a411ef479f66ac864f942432aa6aea94a01bafa5abdeaf28eb1defa0919957a7f82a517d855b5b1a4506b6adeac0f0129f2a0ec440c67ecd430d96e18d3330267db68885a08cc5a08431afc595d728e0c9cfb85be338317e8bb1d230133df97d74f15a73aabaa8a0a981a79d8d8ef794f41a38a36a9a93473f343ee1f49c205afc11064d0a5da3653b6a2f7d6571c0c540f80c3b1846d5a13b7f7be785759f2bad98f4b535837c7b80ab1a01f863ba06758eddfb54a16856d7ada6cafb3d99a44344202621cca319187176588898313ea410433dd457ae036c9c348e38c85667345376de5ccc7ad355aa26028af7475038fc42debb08afa55a13504764402ae69602b264d5a3860a18e88309dede20d406cd85b3bd65d321fc175738461b1041c465331681da2007dd58a7746237a1c52793615dc8a48d411783b8a8fcbbcab851be19c55a81312a86e4e2fef0b2114656e46fd4e03c0f20db524948b64a1730183a341cbb68fd3a995c9681a00a8125648881552fd78a8f1ad1c98b7dcbcd6e542adccc95b490233c7d3a57f0038c6126ca19c1103ff02a4768f488d78c9273661f5358500847836dbfea3ec85013edaad9f35a45e94cb7dff3f803909aadd95fe49996a8077b26d2c80546c893cad1c38572306ca22a82544e066fef70b857f210e6b7db27f5296e4453d5637ad1a9e45ae2cb4de6e9cdb9fcb54d44506fd2c4c2b363566bc9335ece723484cf3431b5311cc9cae5290db908a21ab25cf0f75602d4f16007456be2b4a6bb2f7e9e60a9c4e04acc834411ba95a43a3b334efde8797571df3b44e89d07b640ad5ac44dfa3366de5a5b99160100e384a3c233ca812ca617adffc629328825a7f87dd62d4b777117adfaade366063a4b8039e8662ccb2e402296b92681c4fc011636293585f9886d5a73e2ea4362a33b2596e01e649c8b47f1297e61f4a31407e7c059bb55d5c16eda92d3ccec51a6be5b5baf7587f974a311512227d1fc4e6627950ad8bcaa146b8361a67a952b5e80f3883a027dbb1439df3abc242d79c26d9a1bd015425f8c78a48ed97c70f9b790a488a0d7339bfcafe8369b188ed5db74e2b487300d276aee7b908a748e4b9703e17467c5a2df6593a00da31054f40c2350564c94a045ae134c91dba6369acd05751b9379d92762dc43a78ef74521f1df9a66a9efa78eab1dc3718b6b77cd0a4ef1e2e6bc0d2aced04f9d9a6ce35be1fb3fa7c2504fcb1fba33b8939d491da1956c5ecf238202115f3f4790323c30a221b5832ed5a53279b0c906b23a10adb36cbda912415314e44624cad71134ddea7bc7d143ff0cef53f3bc02f4c37e499dfafe9149519279de6d85e5197f49f5842026322251403e33d7bf35f081ce25af4c569ca2fe0dcad610a0b051892fe19392f065d8bd584c0d12a98cb1fd282b3e3e5834095ebc8a31a9dc0ac225204f30243857ec7c21d0744b4aa711675b1873a78f38a1626b764799c455ee8e32c4ccabdf6831b5f773b0e860c4e90da1e7d759255230b91ba9d6c9a982c06f44608679e46be1de3e0edfba94c9ea6f76944380118b0e885d3697ac16dfad02d9efcd56ecfcb2ee7b5f65941ee1ca062cab0c2c25d0d999542398d4578cdc76070f5c874beed3ca028617c60ec6b5c18844b43f29595f64ccd0fc20a8db123e72a4ebfe5a08103d53d0152e5d282ff81d57ad48f21801dbd4c9263be194c0e1dd62225e7748c64e9d9b351406e13e7c4ce939d478276abd5385cb39a48e1da3ff7395f9a4e912d424637d09c8ae464a9030f7eb3b3e762a012902c63fe56872d337e90c37ae4a486be02aaa336d8f23f05a9434a8eeb108e5be131fc438415fb7027afc5a0c18028a0e86be8ebc0d161b7833a10e9966b77b28aa7314634f32568b1f87fd473d5373a80549e3e0f36be4ca6bc19fe5897d194a382336659668a5189ef91b8f6c4a014adde2eb7156f90ed2562eda84f2ceb1b2b4aa19f1665a7c64fe686f04f2d94cc3707945f00e0e8edaf72f063d7013c4fad52f93304e3f61c6d8357c380d0455bbf5eb9a023f2e92da4b20c64bea6d4bfc70ccbd197a1906eb2f8274c80264b1396bcffbbd23ea6784148e645035ed0fcb795ed1ce81d6777e5bd3462583a1e38330acbfd653704c1824412e7bceee7c93f115fedbc61c02408061fac8422c49cdbadd400e83b53ceace4ebe16b7b3bc389f5eea6e023e64c87aef864cd47a310e8c5578480cced4015934a147326f19742db474ac4878b11b2180480777592eb01babbccd34560346096fe2683bd32a047ee97faca940ff817b037be1f59aa8f2106a46290ec1e3b2ef24cfb4ad8d873cad7b350dcaf1bb6dbb81cc05a1bd77a2758e97608f1456b599440bb8bc32a74cd8c965680736fcf6aae5da8639946f94cb01636f6d11ea8dc63ec7adfcedf66e57930a644bee36a0c85eeaa05b1b5ed0aa3bfe95c17484d87cd9ff60c31f7b97301d8576d8604467b962ecc01b1cfbeddde9fd29b818204fc643aa30a0efdfaa9c08436694ad8fa922bda3377ae70d05cec3c011b78e60331e4e01a66a4e568fb1d414579d0d5f686d6d4f38eefc6008edd4d1e09bb610b5b1fad9b5c0f976151a6de208319101f592cc1be379d3be231af64143fe04b932625828be491ed4110632715e5243038d8ad29d3b140982e53861b4121015b5ab70a06400faae48b36b81f821e529d08c97df1435b904d45876288c6b8e47f707004f42f2417da5fde65424104b7e89192b28b49eb6c78db7210661ab2b94c03e07eb9d7f4e6a2d935dd37243aced5bacb435e5b9dc78f2b708e73b4fbedd0caa8f0f553a1c016ae7096b0af0265f58e8975b1bd6fd5660cc28ef963b6df5571f6183497c677c9573a521a2ed443c3325bc81c00a44167c31264734889e227645d26a7afeba061e649b31d519c68ec49f03754ea0f9c61d82230ed4771ddbb9a78e1dfe226a00bb0361d8aad6ffaed5aa65064bf42d7d04999a9baaac1ee38ac3a316a58fba0f9ebdcd10e3791df32de9a391990fba2b4d15d45c2b1d7fa2a3b513f02da5d769ca43e64d6b35214bb54a65e298e47e2d93b564b9d8011b0a31c4d3613055fde2452447457692db683c272b73e6485af483191633c66813bd4d7498b36a27b7c2e33caa28a5fa290ea52f45dd5aaa34990364779773c051dd467484142b668ca6e9055056716364f5960c28924e5452092fd61e0028bc68cc6ab11aedfa37d617f2757b0f71c5f4158e5d57d1be445d9bf36a7d17a4bf4c440784753fc43adfeda62e3f56b39f5ddbf9ddc9c130f38b42d31ffb83b47365d1fd92c198b71140c2db5bc66804bfae52593989470063d85e18dacf96d58c06b5751b3ae6913d4458dde93a65ae19fd26860a6395541b070c12ed5ace8ba168c65e59b3d925bd205b6d1d1c42b86ec1701797d8f1d8f3c9a2beb20eea333a95a8816477cbca6f2fd3983c5c862db5552aa63d919f3c920a738c496a66490a62b38d0d7f64f680311ab0a41055316b73b27e67597660c7101176e466598cc08c18d574c6193d70ec07203bc1a2a5972ab957b275848d8963e1b4de5224864ba7fb2b04c5356cc69917d5696d56642131cdcf0b98c4f66aae57928514d62865b8b1d70a1314892c701c788d0983e99f03698679ec37d37062dcf95c2ae24e011fcbaae3dfb00ddf1419c4559c048a3790eb5ada34663dc5e3828f934a37fe49e74252fdbe2ec8c18d9612b65c8cb6b03aaf32f7c1db2173af6958c4442850d3d8be18347fd804a95ced99ab175c6f2378828301453a982d7484226ed606b6535f1f33f969d28fcb73d784e1e51dc1e3eae54397c3a30b34762b32cffe5b3ca25e500c75c43dd184a5ad0e301db5317b79b389466b4c46203e68222dd745773b925f2c4797338fbab4afcd756c437b2e5922cacbd8c45a7b269007e1dc457517fd7117fc3ec4d9e38820c5604298422ef4c5b65ad868bd3b8deb613279435904ca3f4f8c05f6d3f91a6a69dc6adcb3ed5721b7b28a4b8440787f4f64152ce788910021559f7c8106d7a270b368b5037a5376a4be19b5a128178a39224c4cb250c88d40fae15d872dbb83bd144d0976b0d127b3c7b828aa2bedd177dc1d0c19e504ea90635345c598766947b5a9b4b610ab8251db0195e42c0325a51d12e9b5e60d257468062b6a8080f5f2f24300011cbd4007c63b805cad8e881cf3e13025f7215f8062c0f350beabeec92f1009e33931227280886486a527fda2a29b4b0ef2a4453034c9fb20062f535db32202b06a85a21e7caa3b5419a3bb80b43e64e8819be4734f098681f352d22076e7ecdf15db24de69e8e9d98ff6c43e10b14dc9d56c9dd8fa69a185cd91a3b5140ab89a1fecb2459aeb72bd760f1393574f1593b1d54df9a69bc85b5a0f0377ba6fc5af27da2c89cc21557c3ad305f479ade5985a3c5ccc2e43f0656886c81378fee0e3934fd863f87fd0a880142f3513aee322c42aa1f9d9f245c8e21a3a420c41d6ea3aee0ef55f1af8e176ed6d214b0978e32b642faee834926c88c36fb2888d2162cbac0de9f1b1699288dd4fb4c5b24570ccbe7451340d29b66dba01cdd2a5ecee2c1679dc2d6822cd2309bb9c6d1fc2bf4c152428788272173b5cb07b0f6b3bbf50593165825b8c83375eae21cf3ed439b5e208b50b4741efd47b79cf65f96a19d6420b507e9bea9c6787e0b361203723154e6c91c8c09920ccdbb17d35a03a3a18a1c81932eaa407bfc447317f2c379d9addba64e3b5f1cd5cc5108bd1e06ece6f174c67bb50a865040ec77461418ff1fcd24ffc852a6ea38087f695df2b5d133b43120893cde5815dda393325dde30910bd5c0e7298f709828646d0fab4e7772d86f4180c831e35e1b4ad03ae65982e75cbb48afd3b886bb20f6246a523d872b7d170cb31b4ce8611bee5ea3ea7bcf82d5d30335244606c488c296504fd1b995f86491f76ea5b573e8fba1e8d224bed13a63c94890eaff3571edae3cb77568250de8b95a60cb95ebee1ecd0dde600ca4feff5c299b856a9aabcda2f10981e3078d65d3c387656c7604bb99fefb6f3253128fe79c8e04d102f06ba5dd2b2486beb4eb39548021c243576830a269d0bed3cec7e9a277aceb4713c3c2c2e3ba2470c2ac5d36ea08df992c2f842a8e5345b9d09de56db1f8d07e28548273cba638bce5eda7c5c6bbd6a6d4ffe4d084ca972f608d483350546bbc8686c2678f184139bbf021a0aff920f32fd7214a8fd7e54bf4396f9f6d45fc7a8b60cc1fc344115ce9a3363b6a5d52abb5959178f81a71b004822c94673e8cdfff1ab6557aba8b1ae69b753933767405002536dcaa630c6fdea48d1e36055507937ba608c1e4789126f07504396cb8606d3c982982abb8d1ce058626f4376b1942cecaea57f2e2f1ade9ab1fb97334ef5a01f1dcd523f5221aa8dcf104e093710dc60493ef83e9cc10232dba1f1455b929b05d70ba6cbaff1516a5feff5f32b58cd80ee622146e0e811431cdda29ee6bb728dc59468fe1314ab09e421b47ca72a2a8a91c313386b1b5c094cb677f315d9a85c10d06fe737418010cc0d2f54ffde114a8a94f465a596b0a07884d24a31ba6896182cb87dff807e17efed58fbfb93dd9f9d1bd66d90d03f13e2be0da14fc376e2631d8a6acbb91a16f2d5ed95bda264c891478102dc75b028b7656e72ba2db72f6a21675da2957eb9611a79eb1935a41c807e4ecc5ce04d7790e56fe8283945b05c0cfc8e9878530b6031e7ff8d43abb0b3e2ac807133bd191074eff8c54bc3f317a641cdb421342cfe599fdb5a9592f2738f74b0702f61e0e68927e503732ddeee0827abd2eb9c29a9c0d420b3a6c8760f41ef9d4aafc5adaa37e7f249157aad370f199dc704ec157273f4e7c25632fbb0184d1a65ea30c678a234bd9b8d5a96e6f914403a2cf8f92aa3efafa81546dda81721ffcf20c1504842d0052b88c3228b320b99df7190d1ebe61c8c69174da62191c3e44c24efefbf5eeabfecdfef15a7f16da6d03d12eb5aab721f74c069929d83b4f2cff42e10658c4447fcbce04f902fc39fcc1c914256858de4e523521b0b34ef2c54a5df414e7de39d50cfbf43196e32b80a71b3bc8b8414f4fdfc681198257f4dae20e6c085714a3b4775c36d5cd88548558d77f74f7e9d729e39de176f21018e51669031aade1cbda7b92cb304ba9c4e317f9c9b7b14057addb362dd7a9c1060e289114afdefbe21f209687ea0ebee3d6feedb37bf11ca78fc2205c64685e3bcd37a84650dda13aeae6dc2a97775c16277d209b86b6df6c3f0457d28170e7c2b4371275fe2903bd11c399f3a0a5a39f140ed18c7cb4a5ca31fb26d762f5711adb44f288ffcc70edbe47d8263052e6a293b9a40bb02d26c7bb267af59836a1e2c7bf476e2e97235becc555e15f06975a249f1e4d2f2437e010892bc4ee3d1e6902ddcf6b8574beb06affb4e256bcb5a21fd9a3b165dc859114b69c138fc19a18655d1ff942e8e7f8c6b6eacb132fe2aa5fd582ba241a84e7cbdbe2a632fd580fda4511f54de26cc19cad10481d29f970f5a6307b26ccb708716fec42c702e33a07f34a80539e30ad904a2511f2152d4dc25bbed52867b9412e642976078e2dcad4b5785fe2f3f7d290f9edfaecaf8eb7044fba80e80b4b26123e3cd32946e52ed41f3e8d45c0568acda63100290a9a4147949e7153c331f32562aca8013a0344649aaa6813d48ee2b57d474fcdb227b3bd5677ac56c5757ba6686736d5842ace4f84ae41643d67dabd82c69109894923d6cf39ded618038f6e82e9a250b5b62e1536257d8e9d6e3f38ffb6afab3afe6aca6b5752d15d11544171117152a9cd80bd3fb9e8b95d351c9d6c86c4e5c552d842c863d988f7bc450c4973305d5f2f8e7ec35db46ac6165a91c613c8fe7ef5ed2d0a578d6148f6d03d069658c8263fd8fb8f393cbdba78040950747af914ea4409fa189b3b700cc17fc85a9e97dcb95cb76f947d6089aa9fd980038ef8ed38b5320f4be4877073b2d03c1cc0920fc9a9ee4eaadf50639b5f86fbd7cdeb11dbe1f045c3fd637bfd20601f0d3e8aa9ffbe75b179a207aa4eeed55cc7c8b4960c5aac8fe574d1120b8e03474164361899bc530a036b4024b7c8931fa01130cb69ee4507344735c431816359f95c80fd9bc62f3b5ad99cfeeb5332139ca812e1908833f2833e39949f7a6024f81e1e36bde2d7282707f780044b177ec3030b0d09ff8e3383dec0a07dde9689e09f591a2eeac32cedddc06868cbca73905b8c1158c0d2ebc5926de408a65807208b51a83cb5fcaaf8a466cad757caf2dd917b557d3073747086a677c081acf59a87c5b3a9668861841228fb9a034d86bd7a223ab12b4ff568894a9e240c5aaf113006f6ccb0b7bc12498ebcacfc763a5d62ef83b11d6d1a4217bdf46afed0c5d2c7d40121985ce065930044531936879412c5e6b404a7142b5b69ca3addb49bdf24e4187920703e1a62048419b9673e203844d4c9a280e4ac0eb0f51099b666cb904d3335cbf7f4d9bba386fad1e22826f8385847700d50a4ac6c4127badd6a5e4d87a4f0269cf7202ac5fe517d7b6c594769c3f85b4db56b79c2929a1b7d4f5d5f45dec3cb2a0b872ed147019875cc99d820370e995f70653ffc11dfd9f9345e7e37b0cbd86fc63ac8c4b4eefb8ad39f2f9e37e8ffaec7026bc4d2f94d29c8a00ffd9a4762db8b0d23cd4880da74d907ec1b5fb0460da8bdf77b233bb4d80c857cf4c33568729647bfffa7f03cfb10d1ac0343514b2b6e978484c35e0d20bd5b8f4e2206c81b3538b40b7e2b02edf32b66192b3f42b80b45d72599b5438ca3e33f0a4811b9e15e4dbed0015b2eff50adfc2a5ba8e4e03824f3e09d4aea244dec70bb87c879591bae0eb28459618b83500c626630d2727be3f6491d3bc5b096eda56179dc270a7afdc78bd32fdf9e0758b3d323ea45566eda1d59ebdbfc110b22832cfcdafcfae6160b77ed2505f83061a7e21fdce9cfb8a01eb6b722a4e7d095aab3b86e05d7ebc1128345b25ea5a0cc586dc223fcd0f78ab9ebd2065720b00a533994f98b7b8e6edaf7c4321ed1ad3a08b5a8be49b745cf098ca0ed52745f45fd5d6ca3be3f11b9ac7470c64801b004a892648d6a88b0f8be27466d882f38e666623fcb1011cb75b2a8b37272262ddf123eb10210cb873c0f6feefc78bb71fcfe5a4233e3fe93a1207a7ae9d09303a1132867cbd6a60026742cc822fc435d2a3508fa5cdaf35e45d53bd429a585d6347e24e351f9352ba2cb16b9afe4246b5cd4225057412985466c13895ed9f4b0c8599f8e2ed488dd3eccfb7ca5b2c7b5ef9b021b9175e4cb176011c8022859877ae5917da12d1fd5c3be8952b1be459fe3dde7a754e7b11bbd321da7bc18936ff2e4cad78f42a1f70e883886075efb5fb5f508fba48409bb73675e2820f36a63976428e6ab30615c5667a4675d25df546eb6de17c10d77bd00c725fad037b832f56c3fcca4838ede4dfbaedab9095425874be10c66178ca378dc112dec3e075215e09793895c33b5f32d8eedc8cbe083275ac18f0f9ca486a4758cda84f5f878b948db0e9817588c2d5014b5211de9bcc7707e2a50aba6915e68b747a52b936207bd0844f3af71645b0385067d995274cc25b66f5b76e3f5a419bc4c9327303093854ad41ef50c62f1608012073678f18736f3a0757db24920e81814ba9ca0378c199cdcc110fe67a1b255078e91494fb177a8abb9d233b7e85b0981ec84a9299c352b624cac5012e70c0cf38e25d28a45e1a93993220f1dd91ae17227143213aa","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
