<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e236b7b499523edd3b86a4d29b8b06eec2619f13526bc1b900af61924b579e108823b04d5b358303acb2a4f2ea263460b031fb3a7b6492c36b80db4fce68bfa659c3053b5d18727631a8c6a21971b2b1cf5901894f055147c5527756add3e93c469de490a3db405c9d0742ae1ead5e3df896db850b4f38a50afd497c0c2511bfe93cb2a12b35949cf12ac74527d230d8989fccf69c069208d4f3172abf294e7bb83435628df47015edb9595405a697ef5925818f282c035d1e8eb32552d02b15eb2d788e23e48d849f2d62541b73519ede7e3bb555d559b62fd5d51fa21d3ec4c42ec022d4e760ac3828bc4d10806cdd436137c6092e4b2a83ed80361f07ab7d394f9c09e95e7989cbddcb49d6dd688b6b5e9e19e88fba191d21aeb4eef5b40b940f546ae3ce3c5f8fbb5d45d1f9ba64b8b1650c196f68204ac101fec8dee36706038b34776e5e968e6177c911ee1098437641bace709d4823f3ce7019a9d07c06cbaa135f8d76f204b298170c63f6d3463ff059f0001ce2bfc35f5a34f306bc48721b4b0c8a07be9daa7fa718b92bb0e58a16cde41b72ed792a6c5d413a7a9b54e782eda0c184641cc9f62163f5a6891ca436fbb1da189ff3d7085e8f357cb7caa6f36d38c5a94cc5bb20b653445ab8c151ec3e1d053500c3515387e325e88c3503ba2b9f56292ddbe0b2a26d90a56bfd120a1977975b1e943f3ccf0e5de113a558fc75917552a5bff9b914f73738271aa080a3c31a88de1f357bf3de24c1de36ac1a2525c7a0e32a5e544e92c3b9d1500b75baa88133536f841e30858421a6aaab81709c24e51cd68d9a87a624a7285b8860fa9baeaa2832faf614c5b750edf37a6961bf3b930669bcb008bb8f1cd46f216d6a09ef4cb45f1ec7f9b45ddb9de02e71c8ed608fe86c13daee75249d40a0ad268d99307a922aa4b46120d67820d2845f164fe5963010d1ce72fe81667e66c3fd76f92404ab80a594ab77d79c044f5b104320e64d4d9e3fdfe7cf8e8536e17d478974295dd939cdbf01b5df9340c378fc3fda6b70ed45532b880e1522b78de7e13ba268947b8f146a1743690fc561bf2dbe9020f1adedf11c6d5575921a15bbea66aaed855f71670889d1c569c0558e8a88f0791b24faf73bcf21a38f1876a491dd571cc07e6ed1514fd99781dcea46847825cd5cfb4763448847b1c7eead846c063102cbd648945a429ed495f8001ce9c0193e1d4c22b7eb08582176af7735e1907203b56ef0c5893a5b1a05847d9733ba4b2ac745dee70dfbdbd66b2a6b7952d2bd19b413ddeb09b53e832532eee2ed612a852d3d95655ae3c4326c97926d859c45243e6f7aea476b14b061ca21e7bff1431e947a088c66bd269e7b4c030c55c9a64e92b9813357c730f0b9bc6d368bd1fdea86c3c7a5891a1e44e87f3364f2e7faeaab6f5902e17516ddd5abe511d1cfb605814eb195b11ddd614923c9df980aae9befc9a5f9be4c258e0b82c4fd8e3d594aa102cae0a12dd2f550812bf112e389c845b9a3fc51b61ed753f077e8a197cc7a2444f3120e0f90170ff41af60b8dd81e59dc2963cc4dacfba06f5bc5a6d30a9bb6abdfacbf710f3a6c60af454b90fc4db8694af2a7865bfc69a76f4771dcf9f7fbeb94cef4489fde2b80ec92085be4ff2764fd304d47263c137ce956b167bb1e4d7fcf4c9ac8c270284e772d49f1d8aca3375b1d402b70b15da1cfaa3661913fd8c3386f291cfa3fd83d2c2e199abda0e862d0c17bfa930c4aec0dc3139ac7528a48756e9eb621ffaacb86f8b93333b8a0b2a4e1230dc0036ca1816e7f03757351fd5a9f1fd0cf22c224597bfe33feb76ac96b0c3bd14e6f8a12bc148f7c7d4bc9ed6077358fcc9001be68e8463a0de6ca766fc4cac9fe08da442337676f9a9f0814b18b2f974ae3dab8e707b899931ea3e97968e9733d2655dee8898c66167ca607fc2bc644134245fd18a016865b9074ae81d4d79bd9128dadd81dff487a52f47ba11f8ab96a666768fc4b8975f7e5a5498fb459aba46443de6b257f1b465142c1588db5bbae546b400981e09f7c7c0e7eb5f97631e0d0b011ccfec5f2a2b09abf4b93186146fce52f8160d721171de5003e0629a23c72c47bfacbc6bb772c35d5b1adf982034950d69eaa7dab2502eacb113396d04c064bddedd2c7467e0678a5a537f8dee2ad313f8b97f33cfe152e3af3c22bb63e7c72fe0f2d2d1e90f4c586a1f75f3bee144fadf0e655dde5c505cf64c7536baf179df34971a7eb7c09c7ae6cd10320e9b137292b49b8e01de7dcf310b186b395375eadcd5ea7e8cf068b44d60d2950ed93a4595147cb019caaaf06e77128ae0843f9c72f531e1b148c41d7df3ee9793a608d50ec1eafcb4daff26ad70703eb4e5e5551fdbf7a9e9c761fb4396cfc8eacd7ff6e806970555f1b0c07cd31fc12dd9c7f874361bdc0878239212edb3d7c8b9d9c5e9ad950c2c2b6b80cd44cbffd8472c8b125d516956a576eed1e6cb1058caee005379b22785abd1bfd46fe46bd9121fcd54dadd43605e303df47e918734d115a040cc513ce4613f28c5064335d4f015f11cd0ba28a4af2f2b08df42d1b46f1454541502db32bbc4f32c9a5caa1c99f91026127ad508bfdac01afbcdb56eea60952550471b445b2f032e16070f0d5c43f54515ec3406bce7b1971537aeb64170599d6d75dd1dacc7eccb1b2f4cffc9b8363ab314f66388e6904505f6cc78592ccfc9af51d4554b0d225078134dee2b3b815c244436697c16dede51c43ba306b9330e2a370498861af1a822e8960959ee0325d4e54fc250b40219445bc9ba6efa5d9bc16e672b9efb150aa8d8dca0ac15e5a971a3125b02e3df5473d7636481879a0b02986762b308f71618b607437c077809c3d061cc16bab3d89ae1818ab085ae666a52e66a5d31327f8a61a4b25fefa86ebec78ac07ed9ed649912ac08ee456ef256ef290384de0839738515543db3a2a6678cdec9facf7108cd5d2544f2778ef2d40b1e5228cb369cbef5530370c9135482f597ecacde5011af423da893c86b91a304ac23c18c5152f297f9c8bff4b2bca9006babf1692780a271999a87d7faba2da40c48ba15322384deb41b20bfbc8dd68204651997600d2136ab64573ec79b3521c932da776cf678ef1e0032ba2636d07c3bff9889950cd5d6959c36737775535f4c1e94e23e57bd5a404ae801aa188b3e36f921f667a0acd71c0588979b8c4c5de1db73a65727ae3ef0f63ef86dcd72579768838db3f3f3e6a8dcf03122e5d5479cee3e69460f729a2e592ebc7c1417ae29af9208644350f29e5e1d6cf70dd847a473f542f5ef4778d62464b58302fcff8c85114570fba59c4b2f3cc0d46aeeac6e637490cb015b1cee606f2f21c736b822a6f798bdbda89a41631bae7bfbb77cc45d1a488e9c1ff30aac43d35870bb7b6cba1d98899d932b99ed25485098fc52a432445d2a995bb6d43d70c478fe71e29b42e4141a335752897c45694247373b11c4dfae96c6e6d904aa062438499350b08e9915214a8d376542a897656fa2fbb062e2d6626ade3bcd93a637234898405fa354894268f6fbd327675d2df61dbe1b1f4dd3b4eeb735614a4e3808f7c97ef18b00270cd44816c36899ec7e3f3d4c7fdb5054edc5ec4f7afd04490cfa636375baca0612440617eaa5f45b155c2228abffccd0615c3e30e02b962651748deb6b9cbb23cdf6915cb8515226a41ce9618f47de3e6786ba25840f69ed03f423e59075eb30f0af32a4011a85356e8e7c7e7d73860311a25113de261f9d36ff4ed5249949f521cf35577e9a187124213b19be9e08892cbbfaf095ebc9b222e8af3d96525ce68afdbab54032790996d8fa9366fac0d672992a5c710b0a8da8b5e130ff1d78708dc2eb5db60c05cacf3b19dfbcaa544d8d9bf90f737ccb66b1696508426b5faa990f74d296b0c305d79c8ad768f1899dc180be09b0f21f09e4af53aba6f6202d014f63a42f216fb0742d42327846aa69edde82d2e2285bcbc9cfd60fdf9c3ae6fb3183c375c09a9e097d046448ca6bd4f309a7bbafcf85b8252386f8284b276a34d6ab2080d2e1147fd42535ae9a80c1a4301303450e817fd24a9782e4d848e44ff83d24cbd5c8390d78d9a6d7865c61a439fc740af540d73774977719760541fefbd90da4c4fd2cd653764c90a79cdcf5dd6042ac6f475d1884a54a23b2fe8f6c0bfb8b9401785bc9ce6144d96c3389c3bacc043d967a94e758029a9a7d55b39b5cbb9b7bb6c9c3cb0b932cc4307922c9232c08aa32d0028ae31aebe7d6344742c3bd5c991b40453303ee539de4c62a10d14730566f660ed0a278aa82948e9a92bee1ba4e93b83e8b8491147a5e2cf0a5e5ab2d50c66dd14181e5efcabc9499a91275cd9068155e8ee7a6c15a035b426de4db782fefe161c9ecb0ba339d002d46c6b2e253047a010b9a4103a2815460e67c956f64ec6a65e14d0bc7e72efd945da66ac30e612090a31957525bdaff94fd4afed02b8b4b50ef36f396a6336c4c0837ff7f8598b8ef9aedc27cd95ab7d433b7592895c2c6ac18ef00d3e1d97772d792913fabdde70f097c63f7436a5e813ad1227a11474cbf93c86fd4d559d1f87d69c70e0d2dcaa2aedf0ab444704015cf63827c3894315c62c06f4266a325b1a89ba7718e06820d2c72b09cd3ce442c613e01e2d50579c97814e023afebf594f70d9c764b5c3a0698cf365d62eb828db947180a46ab26c60c0fe4ccd93da255db6a29ac2b9ae884b4989945d2d44812721d35d307c45883556a5c67882b80c8aa0ecef60668eb292a6013502e12f047689b0840eed25e4b04c92932b0005071bd2eaec5a1411222a20032f572bc0b8c639a09aa722be36588e754c104cf464e019bc25a66b712645695da0912ead461674ac7fbb8104f0839124fe15de81e5a0ac9c53c0971138d24ebb4a45e20244ab6cb7acd45c03c4cc41ac716aa7dbc1ef8288c62208039a5803d18412df0183ae0c4917f77bd1c9c79e61f2a15952340de2af18d0b8c639d1f01f7515145861d5b0cdb866906449fd8542d90f05589e1a1ca435abb742d7cfda89844eeb1eb356307bc0689411df3d046afbab315a9f097d429af1d351ea321b48885ca6b06a0c83b9433e1305d6201004a36760361cb812f77de0604a862a3257cd7fabaf3cb83e4fd652b4eb53e1aaf1c7eaa4d09365ea20bebaa594cd9b2411964437b87c6d72b0c68605d4aa7503f3312fa2019a60d63c18f60214c70e0c0bac22469489f7e4e20d7aecd05d91080c465a90409608e2a878c9c0a01a39ecf8e3964a5e0b24db2e81230e6786ff5f406a11d1848b7efd2677652ef93011749c8b4bc5300f885347f9da76be47258cde3e7488705351ddcc2a8863332e5ed288b1dbbec056f1a2a864ab6eca35c2877b3457aa7acbd8278a62a9094d31d6b2e640c57d0407820afb609dd925711acdb3d368968551d0b2bbe9cb85b83b91ba5c90ec8a4d98255a5b78a11db3b596d9241d9f56ef6589d2f9a82e64034e3def13b210507f8651dd9cd25417a4d187fdfa96145199451feb64e6765a68dcba334adafd28741965b111d7b4754b33c5db406d39ee9be38bb96aca625089dc26077c02691118ab975e415f6ab169212c5970e3c975a25893ee7cb6597c3819d4f4d508d101cd47eb5038df101d53d958a4f9f3bdc6be90c1c2e1276259064199f3339262bae4275225e53dc99a9e668885d8a5ed57afe47eb4e91584cc7df067529046f11d498acab0ba73cecedf67e6a795feb7d3dfc0eecd1bf6cc4e3fd84aac67528b99e6fe19c586615562eaa13b9d72d2913120e03c685da031306f2fb8eee87ff789f94c3c0c03700c670657311713041f87b65646a7ac748de5e43a44fc2af8a14b4babfe5418e62c9a1f96a55dfed62f5bd6d04ed899b30ca59882f0ae86417e54d65deb5bf0be0705d6ffc29be073e93fd0c9fffcb1bcf09d131bd2f7494d6826faaf2df12ede9b2f0cc1b6bfb397c7877819ce527965e62628cdce02ca6ee1f4b7a8bec21c5091b3f46ca0bc76d92110f3a822eb2bf466b8623d35255993cf0395a055c573c4a25cdeda8a5437f43b038ad307aa822e54be2d0f4e557aeda1657de0222ef7a2993f2b4fb4dc30b4fbcde0912cb1539f7b45f1430254ada220f4b3c7aca02832f5f371c7836737b9ed4118dc92dc13ba217bc39e0a954e79a5e8d24c5cd89639fe9eafac3d51b72ec120839d92b2ed5b2e72aaf794e3ba5ed3297a948814a4159965d102645ad516c42d744d2529d1d90dc5704215bef42ae79e357d1e5808e079997724394bd8260405770970bf7d1819925fbfbc55d219480c1aedbc4fbb700112b679f65b8f70c1d51dd504938dbdec1fc7459159ac56821098d316e281efbce300576602f5f0e7c3cb47f1bbdbfbcdb68306690ce0f0244a5a2d1cfca34f72beec9ba97cbf7efbf4853c613aef2c89c13d80e23a70e78e1b6badf7af338fb9a40da644834fbc6812fef2d3e018831ae744f2a643d2f0710fc117ed68a97d42cef10e2faa3b0b3b7bd3bc1c756098581bb12f60252950cd69c9a5823b6c4c8f35d2a96b8398d05284b2d362e54ab2f78e03fff0963f3243835e21d5a33733268fcdfe3936df7eeea20e1f4e8ed60bc93d933be4a964d4d6681f0a52af97908ddee24a4f8ffc1c20ddc6e2fa6247d601d2eca767a32e0861e6fe97607c235c809f6b81310da7bcdde5e35c22d8714623b73594d609b792dc74e0b464d7c336680dab764db80c16bc9ae364d9b01a10fd54b3ba8e766f0c23800df8c12e292eaad13eea92221f25a2a10fcdf7e8245197d3d0e74bd46baad10e23880f6070419eb7d931055776b05bee3c0c5accffdb707036e2a7135cb3ade85085af9da42ff7a8b4522a4bbc89ae968e7e1bf558231a8c9a7bcfbac351178b70255b5e9b713bb26f77aad51e00b4bd78ca1bca5f1ab92ddbf9bdc40de6b36cff42fa1891f550e20cdd891e6b1b2ff7e817516d198c70ceaa25c64455dd96baad6ca8293d962a235a6d62402f8a32753751b2248591819642086912bf1ecef793830b369db2aef180d2cbc67692068bc739e605d2d8d1a5566bf38080b4e612c773f351269b7ca3b9418c3116a2402c45dbedb4f81daabd423db8a9331cf2dab09bdb7d78733f9dd3024d6f175b6f1ad6618dd6997b674d166b0fb7841938c890a20c7d46461c7e69f2b3646c0fb174339bb7822d55f4c2f706436bcab23861a7d2c4b2af04c2e9a3c18e1a6848deb558d25a96e3ef1c1ab66814e4398cb4f7d04232e2062a36e3877920b4e8f29c04cf673faeec799c5e4e4d15d654004809aa6882622086e983260c17519d7eae27b82eb969779210155bd095bafd3f6850ec7e3ad9d44c6a94b690b3ac02083d709bf01fb0f95681aa89825e26167facc37d663c98f75e3159ab153d0fb7cb6f1a4d02a6ea30f522a07301d16aa4e94f9384bff152305173d26357bd8b32acd13aa9b8bfd48b6c7c4c998b62925e8cd4dff4d76bdfd5c5fbc845ae44e9eee1c81af42d9e066fa072698ed91600b0a6b0e565ce60a24f25a627c03bf6227a54ef353ffc91adf754383167b73a3f981ab5ac2953de488d36639066d9fd8247f25998cff75e40345b41031db5537c3a3a454031058848eecd5b60516cafa90b6b141b1c3e08e42ceff616ec65d48a4a9a6085e92a68a4f9a097914ecdba57bd5b2c0e8ad943bfb0eda2b7a38a8c637c4534e4267c514f31f142c668ec2f66fc3e9ed2b1a3fa47570677baeae5cdeab02408b22efc5e109c9c47db786ca14d3c1290c55c1e3ca11f91e4e7d813705a753df414ace9b7679f6f703e4e1db8877220255b6b56a14ab1990dadeb40fb354debad979aaad5fd72b852260780d7fbbedce74136ebf191701a6f5a595e7fd72b340764ab48cf350d620cf7c6eef3d3d84df346b72f7ec10a9f971cd00e780f7ace8e9dbd087e7a5caefdffd4b488eaa584a030a4dee4a76daefaa722fbf48bb3e0184258fcfdf981fa84db1bfa99a83459d28126b33bef60787ab76ae86f1b342cca27240fbfcd1d5319c34cb555f9b9c5025935e0f07a3b5b765af60575fc84f6f683692b33eae47d74ad076f86738c67805c149a3a0eb9ea2dc6f098bb1a63cf6cdd7188f5bc0dcab277c1a3e12801a5962af17a5494fa9667c4dbfc223a5db23d18971d448efa5f0c1879b7aca543c955417a8e2bd1a1ef2bc03871cfda6173a9eaf9e4154715962ea06a4dc341156480dd825837b03217741a42c486a3bd67cc58aaa82004c33c2a2a39c8ecc0db311cc862e0a16e0b0e7ef5e386bcdfc0c9d2dbed01bb1bc00248f7411059866d6ba2f751ec7e0c6654febbabab14ccfd005425ce6121634db7c0071a4a54bb3b0b76ae91348d18a3513fc12b3420fad5bb0f1a9b4c444633fdb9f301fd19b73464004e8ba56a283f22732fda443ebfa4c0721d6c79cefd34d112402d015d59ceeb3f93d9cfc83f3c4ea330e615945672c0425e68baab41a141a09f01c1e6f0fcb8f34cd192b7f42cb6f3fb6d31221ad7c3480683bbb135200337c62ef31ebf84314ae2d23c6e6ac0c7caa76eba817a6d786fcc8d6862b041e3eaefc27e047fbf2cccdb00c252a14854a1f4bd3d19002b832c1df4e7378d662b3822933dbe44fef0d4166487682d21257d2fb814cf95bdeb8fa720b9b26095531f07b0b4a1730d503457c087e26c5abbfb1656e885fb5bb083022fffb1f545e5a47328d7019522096f868ca9502d18ae3db1fee7bedf55e0ff7b975049fb2e1b4ea9d8743b6db33bb5ec5e5687ef539248239161bea7d00644639f74323f10a873eda0c694fcd85966a296639bc36a0c276acb20aaa72bac54a3e9b0585849443a2a71903bac4dff7d0a7f9ef577b23804cdf44992c0975b7a3662df909c851f3887d45a1dd6427cc7b91da65f02b798aafd65f4865b73e41498c21eb7eee0d473a36cdd27a48ed0d1bad3008aa74830d841b6c9bd367d5a39821b0b5fd28855308f1f6dd06d024b1b2b11353c3f31324a2cdfe5e5ae746921de3b1d5027268bbfcaa1975a13c1c3131ecc5a3f2b9b72bd38a37b1a2e73d3eea4c914da6b2af18b379de2cef95d9950ecd0740bc5e7b56c4b904acf9a9b755577f03eec0daafb7421d90a8474918e954126a6edb0823e855ed0c70504e8c9f07a0140eaa8e566011bf83c545b0ade5ec19306e990ccbebf8fabcf18e2856e50521b7e7accec5e602338d66837862c7d82d7c8a1acde71b9575b1e96bed6fd2f66d75e36cbbaa5a56462bee1c010d9e63639751a9aa3fccd0e7960d2403aa74d2f6c2fdb41f464d95e3dd97fba7df55332df5b06bfa0b77bc22b99907386e938a62a50538f4365a068ab7270679063e332b7ece0f0245a74124a2d17eca3a7aa3387e140b69eb2f28818b0ef9ab8390f89ef1845b3faf99efdc47fc79857f8979daa63bfe176e6a51ff1e85f76a1a9be1df58845facd7a3ce19fd6d6040bd9e87037d3aec129c9f39348b9bd33d21b2f6fab607b99d3486bd92cb10406b20d02ab0e8be6ac27455ab132457f6e3fb47687eef945b8463772f3a14d2ebf7d1bf7bf3fd9cc52865a8358e3a4696a91e626bc6e78a801326a0c860185642704b8a98e8538f8b391d3cb7248d44e1f51a24b88857a0f828d745a543ff938493d854f23353c0cc2df1dfeefc8d6b70ee82c03f4f44f8fb71f48f60a02f7ca574c1e0d07f951e6f5f73126bc2db581c658931bac6b94adcb2eac1f1278e7b1004b609cdc212fc749c08c9e36936b742b352cfb6aee8d3347a8ffda445c1ac8e7ed8ef0b7f137af72d8f53b4d5ee339ee11dbd5ab84ec7d11566f26a7daeb84e5c23ed2862e73cc2a1dc3f4836a620ce4695a5f4d863eefeaacc4f774947ecead69c4f5bd2ef3e1e5cbfa61be1cd336a5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
