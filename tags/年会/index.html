<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61eb2fc2ef72b11f02f184ee931b55fe15f30fe1c68ecb4005ffdfb6e427060f35f91d9a1267f79dbc132061a3cc34b34896c59cda3dd02e0e42dc2ae4b98de0bce96b3b1f37f86b1244907c63d13581ab65746d28a6b3c8323ebd277dfb3b3381f2c077415e5ba443af391b91ad9b3c1d7d980106efa7fc44edf0b68957a6a7cab37dd7f67a27a52fb03aad77c048cdace30dd5157d0951f23ec69701ed00db5dc03b99afaa387de3d817d88a1ba06c9cf78ccf263d1775e241660f647c0fdb7431926f6eebe06697d03d0faa7e4a0dba876ea35ebc5e0028ac742a9b735aa45128f69e9dfe6faa16ad5b44c40921410922018f6912bd5f58ebd7ca311ff6f8b73882b5fab8174ea94682b0634af4eb19e0d39c8655f0d177a629d99ed3ecf952f455e4be9e61c832dc2eab084ba84d9dec8582b34751e1ef5af3497b09eefc71799d4fe3dfd2607e7db0a466771865bbe4d06a7dbece71428319b678d62e189c95381b56dd394c64850139b7b97d9ac8247958d2ee1b06b37019fe9a936f8849a6c88fe100001a5908973aae221e33ef13bfd000e74a3c9a09d799c9bd118d1a7ec572c107cc35770a73f41cbc7b42ec04a41979183c4e4c9aef3bba8b05de2ef3d57b288fd83cae7627b1f1268b0ecb755b3c06fdc28c8b17a937d1bb4cc1263a03a9c72492d8decbe9480c4b7993ab032ba02639d516514534e34c6a59262ca84d7f16940190897bb5ae46f095a94fb66edcb0a61da4bb2b1e3a56ffcd9f928181d28c506d2e5bb030d6e04d385fb1e99327b30c87d45810e5a0509a1ee8652ac73e0e5dd9e9c39b6059b9e02bcdc7f9a19e001db4e36a8664c6eb6947a87d8d984bf6b61e0249217bef193d97f81c3840fd9eef8f9bec51100c263a7e52a8f15f93960390b931a60cfdc3fa1078643d65100eacacd8208ae8d1e2f86f63b5c173b9f2abb9a80a5a18b3e13e26b30bda61a3568a95fa33af20bd50e17ac9e91e370a23e0240c9f68c1f3e80761609a6aeb8eb18bbbfe9f53f03673ca7dd955fde3b1291fc8a9aa03dbd6d14cae23cbd80d78a81bfc4db0fcf155922685788c2f6307632c5a4d38389a9a155dc3c9d55d306c96d1765861be93cd8b05fcb1635e8a4a1276b5648a9f14d7b1dab92e1d41ba90712c3bdce9f92173e8d26a441f615250358c0ffca213564dc4c94dc4f4c59b59cdb09b8c9cee754e5f3542ded5f8b17e8433209fe0e5c526f23aef3ab82edddc1861fb0495d57f78437eafd371236464b23a85b7d931dcd46762524caeb23ede62e6c28966115c4ebf48baa67edb88d417c4547796a231decdfbf999fab2b632ff8eb8ac2b5bbcb6bed26cd2e62c428bd0f18bc7ba0c4a518c776d7a843d52886d1c29c37f624380fcc0063df694b3f6982782b1032e9668d60b5779f07f9fabcd0175d6dfbbb006558f409c64b6fcc06658e47aadb2be74072c4a12a9a8d70f5ce2dc29c70a989bdb0a5b3c5b4e534eddbf4b46279e0ad5a85b837417e0c96b3edf82c0c3c08093840e09e6a133c8ad5b01794a6c6242fbcf91ca3211369103232621be463e2fe91209e6cc2b807225e735e35b05030aac8c011dbd38ec82f6c992a881cb8cef4936ac74a085b5359bcf52d96029859b880e98df90197be6c574dcd943c0fdd15eda8e9e9b4ed87e0d5b4241345731ea977ba75bde2da43f7051f378572bbda401e82e9e9dd6ef7eb4471b5dc665e7ccc083d46fbaa5377b6be0488a42b41357c1192e1869711a7d6faa3196a484902d38df5c4fbc3b3c5a8170170399ddd28fabd8a5ac7a3ee423583fd11e0a8fdddd487ac0ca22fc5cbdf5a240bea9a9a495b06b4c7b49f97d0f2e5e4db111f395354dd42c4d0ee0012cd8ffbb7e413bd31ba3a53fd83bf1dbe3fdf11c2c665c317ca18db6f9f32d420662fe5915ce3d4ed869531406bcf10207acbc2006efda08c4d44a0b917a79ee096a89aa8a967f6b159f5fc0c0335b840a032324249e3b45afdb6c5d725e701c4a39d973c8a760517a706c8ad5912fc837de2e1ce0c2c9fd55bf37a80342bd730ae7147947e34568847581d5cb1e22f78de6a4a1650f694fc098d18134ee715fbd0c4d8fa4667523a7c2d7de15f5c1197c03f9719b2df896db07553182a60d771a359ee93479213b2cd9fda977a7660abd9676b2c3792cf394adeb3c7dac42686af56c30f9be66757fc16a329f23183fed9862c7736aba68b13f52a26753ef124ff5c8ab18c4f7bd22cee334c36357f158fd0632fb7e567d829650833b09248481d82bd12efb00830627c57f9161b9c5ee22c5359d214d8248b7bd96abbc09ec9fc46415c96b69fa0f3e72e20d0d8243fbf948b390f1e89bb64bd3d2cda2649eae8927f05c4297fdc1626d1c579c6891f4f406aa9e112ec5f1ab61d3adbcdb3f5ecc29fc6824d201857e14d5ad53b738231b1ae466b52c024f080833f72730ebd969986b38e5a02602b5b2d27a364892db7873697ae56df6eadf98a761edc079a8be0fb7232eaa661bb1e6ecb60dabfb2537ca4dc890dff33cb130d4b45edbb97c4d1112baa59efd3acd363acb97db1a484e73fe79c01bcb2c7d3bd999e2f70d0a94986ba7986a3836a8154631bfcaac5e374cf74880e986aa705ecc6ad26feddf8c03470dae2709f9973303ccc1716f969870ca70961d461bcb697bc9e43929c186a2bcbdd7f41e4c8294bedf936c87b90c73216c4c444a5ad6b393d6139e1544b35d5ad4cc5e8b0e06701e218dedea07f45cb6ee175bd1c61071f3c1025eecb79cbe037c7a5f4dcfa2492eb0577bbb16906072258c50e29f5152b5190b7028e665d9e84bd9514aa84b33193953ab16b18f52376ce40c016c8698dd11a8bcb7f98b04cf1df08fe8234e46bb8cc0b460639fc8dc3ae07353e4b81b0f4e630218083ebb88263fbcd63a123c6d9aebada9df5e5332f196f585ed40d12e17697f184306c524973e623497062a0b215075b92cb1aaede1a60ef9fb4b0e533ad6a92b28778c37c510b47046bbd28cbb0bb8a9d961b46064e5794be45456e996e5d47a3862db61063b2919ee5ea9188463a7f31ccc963c890ba81054023fefb2ed9a5d7f6abac94dae1e446bf37959644407af616d1f21b745dc732aa5267432889a3f863c223b438c45321677b8399fed15cdb6ca78861eadcec81f2229ef3645900526c00ef404dec9732179db916425fd6545bf647d0a5fa5b7a2214d9d1a5be772eb63d5c2357b2d04cd889ffb7180a9c7dd4a0694c823415a714e4a8ebf2f149f150e9d11540aeb313610a5115d87d164028fe7ffe8b5ce610a4063521ccd151e96ec24fd2883eb551000c207a166ad253cf8cfa5f48db14ee50e054d096633ab3470cb60265261af79c31940a117f6f7ead01c4e7857e6538615572010c41134326835a7d2b9fb78971320dbaadd0c7170f9a2bd4609c3d33a94aac177b6ace5dc5e294d276cb1c4e3e048f1870b37adcbe488a90dd86c87d97c7f6ba1beb86064b2c2f6fc1074427d826003507fd12c1fb3af6a0c1ec4aefdb03c6f7e6378def264c89db4e5fd4fd863b53252882a2713022c26b17c0fc0d0d10c99ee6d0cf52c5f61780a3fc1147aa931389300c2aebd67e21d5bf25335b2af1f4906d57affa12a8de5cc2759abcbfc033eb723c3e370f785a6977e520c05eecce8daa2c987050dfd1cc87b66572b63ae28f8ca444a4385f2d7e257f12230dae72a765cf429eecbff294a01cd4b1d264280eecdfe8c09596f8c6e15ddf9613fac017897612e2b331546e9cb555c8b16fcc333c140fe2da292ad55b83ea0a17f05203f4799bd28d1a7095373622160d4984579fed74838d1399fc8a84d79b84175f159ac444ab02bcd18b551198b913052cf09867c78befa2f21ae4d7ebb61e2c489f2ce6f12bfb3bef3625c18d1107d8c0f83dafa8e85d5a2ccd052c87d7e8408cb48a1a49a8de05737fb2fbe926097b0370a654ef8f0678fba9fd29b3e85e9d651fcedb3e5f5050e87ecc8706b206bd2fbfaaf9726fdbdbc1bf11117613384844b2b0df7e14c76ff752cf08076a84767d79b63cc8731deb24abbcb2c8d84efea299ee136189d717dcea53af199015e16c4994d3f2ebfbded02248cb4e6be66f55e7c1305b9b3715739aab38a0fff16f45f28e09645656309113b5f1f5a4167cac23433bc36413b6b31352584ceb060a627c3f1985ff01fcb72faeded470440a1246d61cf96f767ebaa73d820361d225584c035178915537ee0bc5b6067060652fd24a1ce6175286aac6742197c9aff27dca6312d09940ce25d2cdaef49be1058d2adae36d4c7b9a972da07fcc4db66a4cfe9d40ea6f734a466250358be5f2486acca77c7662950f80582da81aeaaf1dd977a613c31b09d1afff4aa3dbe13592e8038b7894deeb7f06f5452fd2dbc32135e35a26eae56a2682dbebd5f8d0c7e78afd95c3770cf347d7c6f8fd4b460128672bd56055974d0fbe2d9a9debe31ae70b5580fbaf2b32c36628ac1ac5f303005e7b540145bf7425bace8ccaea47814d3915bb295b1145cf4aedfd168bee47fe2bebdcd47b1e09329635e0c04abcb19facdb424f03da8f894d3ac9f73027f298ee113a5f686975734562882aaaa541f84b7b4e6e35eca9f75ebba804e01d46d54c809e3e70eba518739c70db68a8a0bc786a039c9e6ec9abfb0c2d8440e5b755036d6ca1c34f24596959390de8807d71b9530fec5e1d1ffc730d71b8936943c015fe89c4b12fbc309cbed5a0ddbf5e709aaa3c7ffb228af99ced611371f51537b5d1963aebe2465bc7c684f9695f3e3211c90f1a01aa92120e90974a8c2a16bdb0b4d805735bafe7442354918443a9c68625cb8d628df27b0b150c2169de88765e9d6c728b39e1d580da71abb2222c71fb7abb40ee003ae9d15c9fb0ef2b8babbd9549969cb63fde21daa79fa52b0022b959c01e5b7244e72b666ccda70a9b099c8835c67ddebbd868c5ebf2dbe259d3f721e63dea8b2bb523ce1528b2b97f4dd70e5c5d0fb3b5a3c04ec5c01341f5bbc92851663a879b03962e20d6688516241a63d73ca3645fe6ea39f8c2e603b5f8402018713028a141463f7e603c22f89659c7b50c8f467c634354b3bd2fa3b82fdbc1497c95c33ea4671a9da4dfb53c20060465eb5c18e80d38cfaba4c2b9af2e5ba2c2679e217a877f272bc4db0ae7a80d9e28d6042aee580cc9efea9fd47925bc53bc324fe0a1b8e3bf008cb7b7c2e4dae6c44e1ada9ede8a2540981f4212a82e52fa25a7e522dcca69aaca4b65db68f7f96f6b6fcd2cbbbcb04a4a79beda107b4d76e348d057ec8753de45fce949f94ad4aa6cb84122e31647a169d8afa3e147d7a79700f2597a931e0720a9be4764011d8b518fbe524455bf5620124ab74849169f9303d2f22628dab75eb8d6b1b2303ab8f02d893d29a222ee5a09f96683b8d84b8562c12641ab22a50d455d41bc72992b676d56f7449b3ae272fb722ee06cadfb32f9926901d81a9b6630576f6e1b30437cb9a34bfdb05e8ec9c6e3477c13cef3c91b1c8525bb33f3ee061c7a93f8de4b9212dd267d254a17e279ea9cdb1453e5bb264895db27037ff3f33379bb915eee4b785b39a083819635d9efac3acea79bdf5d599f5a8890738ddff14a82518f96cf9d4cb8257d372c732b8d8457c2e4b0dcc18e95655f38f6a4c4cb65112ae66586f2ba3b289a2f1fffcccb6cce37941018b1c74623ee4feab5f4e745bd881b8543dae41765c3b4eae64d124f676037133d7760bc3a3e83c37daf8a2ab0172b247a30d0f427425cd75072f37413374b6e64d675ed1d58987d7fdaddeff91cf43c45db687c1f04d3caa54ac199e694ccab3019efd88ffe2b5509db45082c2d966dd96371d96a605feace8356f1a6ea9c41f296d264e8af590431165d883d0781cf69e62faa536e7b96b4680bd08be75dc6e7a3ef239ff4c5c50d76bce5b4795faa90490af9c9accc7035d61e30f30a2a4c3dbcff360daf5ff7512c615bc711f0349ae783258b37c0610507f9601866ed7794be90478674dd1ea9e1a1eb71a24ded30a196218c102c46e1c55ba2c648babc2bd48e8c42d03db71c308ce54e2c7088bd4730805db46756842f3125ac6731b0b7b435df9be9c759e7cf3d35a1a602d4ed9494122366f2c3b97397c2956f422b91c1b5822acde917a533729f448ed46c4a7da36b1940fda8dd4b0fd576eaab04cbbd0b3be5ac16434a059ce4d08c4209eee7c77dc4c1e486ac5e370e9d7d346c75181b14c39d3feb8f2841a0bb15797789e08e28945cabfefd99915430f78f67d49b7c708aaed0c6417debc6a1a1238b2f838af1fa4189e88b7fafdbc2268ef9722314f773cb2bbd02b92f537e791d645b5b2b738b71272a78206a20feddfded1e123dd45d8ea54ff6260566ef9de3f209126652987b240d8ad397b9a5465ea1f3a5950ddaf852645c97b2a0e0c9c3921a2cfec413abab06dbe12c1086569f7511e19ba7f676463794f3eafb3a56596131826c279c11e111d34784848962dddc11acffb27d08f40ea4e6ca20b458a20b97b9071074100453b87db7fac9f1af2ff95540f2367d7d06156d0f08b4b9a77da2d74ee57c21fa5efdec37ddffaaf5ab556ace30c4c3c4717098d15e6cd3726f40c17e61fd0bdfb8e5e056a62c648bc122e26f4eec6f5081808fb038d336c9bd251c6956d9e3069fb5319927aba466690d3ed989a468da5f3bc299f228bb354d5bb88cf563cbc9f771f53b9f9364d1408ebe984ff4ca5daaed19aabaef0e8a218c75168b7112d2dcad9c8bf7b7ce69347694adab245e6b6e00258f5031df829ab542af410291d733d9dd6e0a7347dd82bacc96b20ed561bd41d34ed10efcf5c598dd9c58cd477e78390594459da52cc411dfc959cb77eb7cf229019818d85e194e7097fc5e46cf363f16d8bddab2fd2d9b53f1ebcc1d9c1bb0563a4d85f249286e32b52f1bbb6d0b3cbd9e156b6b0855fcaa6a181792065eb8e4ef934d91ddbd5167c48b483a098390a0f48a4fe2f20fb67607edf0ff9d8beb3937900c121729ab0d9a0e418df1ac4230be9688ff7a258a03a11001c3451cb798c7eea4adab01118f7aa854b5c1194ba1ba0ef3151a8af7e034e7e73a4dcbf108f923689d3a745f33a6fc1430546c7082a4ac00624e947b6e18e996f128a66754d66bc1c32f50c8932366bca2ce630fb501652f880987587cd050e6d922942dcdc21b01187f039166a68c2dcc6c3b98edfc8184d48e553a2e0fe6091d194a2a59e5b885c627d611ed9f6b10b32db4482b63d9ad904799f57abdfa09038e186b9200f3b4afeaa9692abff62d461dc48b844d9f14e950b88e3dca325f4c0a80bedeff51004bc58ab3c5b73db2696fba5738bf15061eb89bf5401c8cd4409a94ae84088a0ce3ce8d96a265b33f5777556f51762ec037f7cdc5e3f629e0c0082dfb2023ef7bef7d0ba44933dd4cbc2f248330fd205b64319c878e6a458f1308fee5b6a8dec9da11f3dc80f88fc87dd10eb879001428555c37e5e5d252f934e010bc249b254a487702cb6f00aae4d0a174497b9bbbc664220a1bfaa232f37e80570e741a0e876c6ab0de0135074514f84db39351c098209aeea71476247eb8a5b79165b9e41da162eacabe1c1fa72f8b5bc50ac18b2f425622bc4d5fd92b27ad0aebdaefd8763dd534831e40a0232b587818635e965e4d3b47bff8e157787d573c358cffae692a4955566f25fae445ddb17c7c47b08de0dac9be91c9ad599f88c90524b833d4b2af1f51d3480ef57953c66e4949730412bd85c6f688a617884266458fb8a8a718443bc4b18ae88504e0b85f13379d50700e365b9f2b3732664ea73e8ed698b14ab7859412b95da2623f729e08b356c32d79101caca05ae1bcc0109310c3bd1a47d450ac077c4945b06e7fb46bacaa9f86800b1ae0823a0c5443c5f1c048e980d0c1566cca3bf260110fd1ba3e5dd0194b4543f79feb973c2f80c12e5ec59291bc37a9cc7f66fe23ed0694b948cec600daf38e731b54fa1f8f0abb14d63149043c1f55086098a6dad50ced750e60c4d23697cb53ceca20d3e769d69dcac75fbec398fc92f3dc5361c51299a6aaaf4c8829de25b29b4eb7ef26bbac2c46d7e99d118a0817743d46002f8ba63c3c1fb98d4e4c17dd5fe57e6cd368a9e9677670e4ebc6acca717a6e943f1b3254a03547b6fc75c02fa0b7206c92be81f69ec0b368b591cbb360bd561f976222c580be6e46cf252241304f718c9b8168bb47c84ee0d17e33f61dfd02d6c39e6feebe7884002af07c249d21f4b1e409ccdeef6ebfd12b6721ea736fd4ed6c9e4140abc3f44ed6a0647551ab86b61124b62d4aacb509cb96864cbf82d4526f9e3270dc0007cd6ac5ebf03593edfa66b2d4698c81c46c70d92c5a881dd20a8b34564a752e606d847edaf0076d9151a63826652e209bc8f924ed5dbf174caeb9f01d65e660e0d55ea25dbd9054bbdd6208bee87cb821425915d13807181eb22bcdc1a8321a6e62cae5730a8178212d96047f6d75c905240dc3796ca2463985f0228f7c689cf1d494ff093180e8e955ad7085e0af9a517e359c6d38655a25628bfbd946f73a68fa2cde8d24a5793553b6f89cd220935b4c0064b13b20b2380c694f76fdf44976a13205d22c358b21f8710bb0bb0f160c7b7c4f8cfd5037798f938378c689b5a07a479f08aa09232bff41b55698c33c3b84873c40faa28d17dd46b8d631ecf8121ad625b152e642f9a97d5c6f051fd9c180fc0ce80636a7512e7208c96a69a3068e0bfb023e6033e8287fef7afe0799a1e95137e15ff4a089919134483b79adc2fcafb9f158c9bb21390e85adff7b9b308cc0eb46daad7509d77da66a5967567a2f03c31ff2863f8bcd895b46c57c46e33180505ed90142e3301ad0507e0ff32f1bae66c1ec60d0b0a2daba7cfe22742b54d2a60c14158d2d8d862c822032ac30a7a7786eaca45fcca35a7ac8e7ac8ec49a692f12658e0d1ac9eb94c95e303dab5b0445ec77e7615733b3dc24d832ca0d88d2b30e0de154e66c951c03b192f061496dc6c8aed79cc9007a62218f667b478e73729f1d256337b44986bbb60d8d75f110bac6b8d8924f383d45f57e6ad02cdc5db91522dfa85a163ebb370dd7c9b79fef83368ce34b98ad146e2065a0bbe7d09bea581d1b6ca69bef1c046e0bf019a65a4f8b6f957ef86bf84a26b2de80c8aacdab22c08e8787689af3459e1e108ceb3f82c6392dcf28484912eb170c33eaf00288d481636b23bbc1b985e4f052bef33be232bafe39d239aacd206adb311b41b55c4f04b8aecfa5e3246b8d4e829d498505978c4a67f14a9c70fe86ef7a5585478030d3cdbd54ecefab1b2c75d1a137e2d08e3346f9fdda88715f5d77dead70f1ff26f163ddc6ffbb6c24cae8a5a8f56b1af154ebdb1424e7f093736cbf2b9c2ca47988856210a6029b1ea73e5a3b90be437beb01ad4bcc3b392068e474c4e806ea4c7a85fe268473ff4b2076662f468046e95929ef236fc2e6656aa87d3e27171df274514dc1caf4db3956175e198219abf333052590a165302fd8599fc27896376039d50f84df425e2a5b5a024c977fb1bdf6e8267148788f773ddf96e09308ad58d42cf0a0571d0f54c358b61a4fbd96daabe16345ee93da7397c89370e93da4a68c35cfc9df06e015bb26d5c10641b6202bfe35067976a91b25cc42e0cb3a50a71e0ecb75cb4fbb5248c2f93bf419d84585c397f9c47c009e1f48251cf624d8076c130bb6a2e1432171634ae3a943d74f07b4b8bdd11e83dcf3a4277fb4958293105ac0c977ad1b34f1882f4b4a097e6978ea8422eb46b16c58818d269f870442f1ba27065deffa899beb96184d8babb65ea4b73c9ebb144ed1554f4bd747b5ca4e2e3fb4bc1f8fd7927f80855b6ee8b26eeb398324596ea1cc339be4148c10b5e1876ea0dbf5fc603aae52fe1c6d56f5ea41570c241fe51459142c0a1d32666d24f61d196e3e54cf40a4124ed4813264e5c7b0d926ebdfe74223d4736d09a36254191ba2ef0a8d478948edb205eda967d6e28d82caee41dc83517e3d5f5b494983e181e7c3dfb6a13fc6515431eb80e3dd4506475742e44d38879952c28417b1e0d16e1c98074accd7ecb27e2c125ad828ec36ac9bb546f795e4be178157d5d72effb06bc1d5f82fa588699573548405b20b46c69ac532b77f9b281bcfe5080d03a3e67e5fef3cd24f6dc3c92135ac9dd86051ed7fc107ef6f245331c2dc12969cc21ea2b23fe2a3e038f0d156947b58f9b6216907b4b01639abec5c6bd22eaef","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
