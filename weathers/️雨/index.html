<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a3691bff9f988628bfaf3d92a9f4f76cbd4a83c194fbf3409ad3be9aa934d1f7a3a3d027af8d244303e6b0fb4f0bb9ec3142a86e813de3a7fdc01552831cf5e76fb2c629b46f0812c33312aea9b00521ce8253082a442459b59dea9ce15cc609a00a0518ca30f2c16e9b18918f0b91d224e1221a5f44dbd0ee29755cb5cd880b6aca077d2b99e5606d820b9c77c4cac0a9c80c92d9db6c5b4ffbe80817b36ac229bca08050eb4a889d3b56d6a60f1d8c26e1913b4994514d0d319b6da51ee31510cddbef94def9d3830276defc86be4f530faefa331b389ef093a4bb4306b99ef8f5a89c3e8cdce2aefcefcf0a5e0e09c45fffa86172569de55d5d9c07524ef38a03cff3f66f42776b6348a2952bb639048fc2a196a4bf4b81ec044476769747865c912819946f60cadc230bee99480f66b7fb724183e3bb74eb273ffbf308fb5cf1f13cbc54cb1726ccf00e19c51b4f3d54518e2613289245de7dbbbbe03dd5bd5cea509a604ec391cd553f4a5cad08d962ac94c714abafbc0b737c5471b51a2dabc81f46df95d451cd7369da7c3f3f75da340ce1a8bdff1c199269cc995fc72ee02f8c878bd48a03f4a59cad7589460adb55fa4d85b141ee7e3e7249826c39956720ec4673a8383b2f20d855718ffa624e8372076de0eef869c07519aebd30ba69d71d2819ee54c5daf5c924f6dc71b7f43db42ee2134bfacdfc3444490af7b6e0ad4a644645cf703b96cd77a2611639c8a1a563512e519c1da267edd5c504d7ae5feda691751958a6465591f8358807679b74e3858c33c6548339c87d5e503dd244989c43e9b763c9786dac4ce82a732077f8e8a99429919559f434a28a555aa432f0519c0c7d730758d821a8a3efea6c946b4824f44bb2bc4f239e88b15b3d91f0cc7ed64647a7250557f8a03fe1eaa49a6ba23363ebef45592f9e17b82886c91f857e8507dfeb98956dba11a41afc2f62cf9a5ccdaa535ab405a19e0d20d299bb1f6cf987c5b2650b5e5401014e8463ad354ad001ef823d152c53e57d9973e7e2eea570ce0f564e9f79a5b6d002efbf79c67d972792d2eb965db58a2d13caa2a3f75dddcc0a3ebf5b399eb3ee5bf3be4a57b4f3aa4804a6de468cf48813d326c8128072ed1812b8c19e5dd07adb0d64ca9823281787163fe52dc0f1659d6291322d3613eec60b8c194fabeac8abb9d2df068a90bf4e56257f7eaeb008b0ff13ddc3e12396728ec0572e9a6f3db51b33be254882857ec1d3739d94c73978eb79416fb2937ee3d7b88a9d4f108bdb5762fb43328cdecab8f58b3c6333b617dc470579bfeee1577ce366ada91a3a2513308c0330901a9ef8027f416e7620450b1c457292f4be8b9cd9734b7661aaab198dda73dff376ed2d6c45cbe5f6dacea4db480ed2a00ee88ca6a9c30c383e40d2ca86d376a79f7870161d33dcc13e653d69aa87b67dc812c7d09edbadb4ffb93aa874d800c02076797ce41da5ad83ce7d4cd7bcf8e7add6cb993b6bd8815168ad79616c103368ee3a4c1a5608b87d729cc2e9c99aebac14df7c51fdb1e553c969d47d60528ca96bb7bc5e16a7b5041c55eefb0af5037051efeb47b39d59b300877d2feebb0433495887078fd2aa9a54abed725f683a63a294f3629fdc7ce7132d7811ad1c71ae79bcb49ebe476d18cef6a7238a27c87c1330e34b5996887b14841ff31db8b93439be0d4114ab046bd2275dc3f70b92124f5374fc404dc4312579f1983d76d63ba2bc458fa3ac86f8247785ac933f81cae5459affadb448c5ca2249db22e6e113241f9e0b65c77a7b8c07e9ee3d2dba9e2f295c1135892e3971cbf038e50d8c53fe2b560e9c785a733cfb6635fdd9c9910e50e1d3741f1d8a5a5cdc191504f75dea13cf8902f4ed64230b2737cd7c61c8aec05cec55902337744cd03b9b5a986662a46db2d5d5a183090153ac68ef50a179d47e4a8d59dfdd0f2e57e1f22eb57b126505cdccfe515855cdc0790d4ad02f7a94e1f4a97fe6e68cb68e12221e2c226b56e140b9269bab2fa440a6c64a289c324a6461fe9d5195be7f7b0f34488f3538a5cf914be45e1a1290a0ba9824eac31469962f6412c50bcf35bc9d9deded38fc0db51c50489039ce66e9b22185e3c518054b03b178f0b2d8820efa9c47a15a316da318e217e7b5a54c2d7324c2e26da3713885cebbc5e2438a9203bc14ac9977ece8dabd36f4c1f985fd0dd9a39d504b147ac96df747ecea9d0359e66bf685ff57fbd931d678e08c7527e21d248d27ff5188ca494038b7e38551f2a215010a40c75091e89ca94b426d1572071cc94782494a6c4ee7f74f738f518d3f336c38dd0382a5cefd9fc1c650b49b831abd960a00dca01eaf177faceb5717dfad11ce1f4b7b7527d851a96af1f2c95028bba837b517004c8d1df00b5652da91bc404aa689aef593f83644fbff9b468a507168a60d4c128b4a1371648360f1d27b5ec2d3c675202e12ce100eead3dc726c8390ebba0354ff5c1f04375bf57219970853860dcbb07702de0b3dc8f44f3c303416bbd12ff2ed86659c515812da998717e2dd704fd4053f1080c1077e0d27e38d24f1ad09f6fe2e3b47abaf10290e9c4fab259d6d000e56618c64d7b88a46f654d27415f2caa9e1847f9f5a53c6d3619acb3580694560d238812b11f089e482a2ab2beb7bdde39f999b2db60fde8881a19eb814e470e166cebcbe3d24ba4ad6d84afcd9e4c2371bd57cb07ae87b3aced25faead7179fe134f79f5d79b4771cf86f501fb80ec0812e8e1591f0f227e7aa7706798e2db8cd319e3817ce98cb48d1de25cd8dbfb71f8eeb461fbdc71b908418d020ad503da07a30b0d206e7bb5287dee5727c3d6f2d5b5f5c8756087df8e7b36c21687b67391fadddef58fc7c3bb5e42bfd8a0e184f9fa8d621ba8d730a92102f57793fa1be0d1a7ce98e5fc0095e1a3ba1a99fa1d9d9bf759807aae7cb9225308ab5aeb5cd60b037f49d6f5557a188e46ebe0f8b476867853343e1301beb21204de6e48c79c83c0096addbf46e2b1e2729560b1068c11187df58f656b0cc7ff6ac21c57f31156c342015d1666582cb883d848c2705201d810fedf71bd959883574080844b1e4fddcb8d41903604e35fa7583217c3c673545441de3aef00c33c11abe5f726ded1967ff973d869149f00b58d78445ba3ea81e68411384d236997528aab23842bff3a8ee9992d4e205aa5f53c2a78a2faed6848c393de5f79e418830feeebb8e49c7cb8f7634482cd2d4a0ae2378e85ac6ddb08e856b2c155340f8da24ec8e303bab6b84364676b0cb77d70f227b8eca743e2dcac5a9267eb5340b4f938ea9e8815d2378461ccc58a4d9e8155bb311cf24bad2c428eb3773ddb8523eccf85b3c1ac1f5370b14586a6cb9693d26c11f32f2ecd29a177bf387971d9ccd5f7b3a3b1e87faf4d10b8545788c7b2888f8407a20883c83e9963fcf8bd8664536eea7ce391ac3a1083c31a307ac8d0878d5858de0f0c664232452d8463f948c803dad50e7642671cb5cf3296ca50b893ca1226bf4b6490acf350122963ec92d6422df5f306d4172a497fb326f6b57c5ddfca8994755925fcd9966b1a81237ea6d921e2d62a1e6402aa77e3f36376c4ec870de63a06ad4ecae0a497af11cd1453af154531f2cd6e3d06925f63054372da27cbb8b6a442c0b4d13a9c6911014966f7acd1a288e2b71acc0c614473600ba7adaccc6b3a30949b8f755b15a53f3cd87acc659b942ce488fdd14735ed967dec1f9f95be887e2d22aabfe0fe1e0b862daaf201bb74c76d5b8c1b867c6465ee3846140db0856f9c3ed7c27e73fc5ae51c129c0f8c460a3b96113bedf8f21d97ed8e8021d4e39d65895dfaf9b89aca021426f873a35bb39bce55585a9de65a101ebcd5fe5531832595ed1d64e98afde4424fac0a0b4cf092156525368086204b17558ee8c6c72ffbd371d93c402b4aa12691b4c1b31698082a46922191dc19250b8c7dcfef5cdd8d08ec3cdd21b4e115f5b2cd219723061a27eb174cd9635df2b709fbbe1dd6f44604e9144ebc89fe3b1e34c13330ca5a52bbb243f355d9dbee98b85f383c5a2840ed3ae547cd902488cc7d067ce9e3f5ec8732cb4e45f8b34c168af4d4a22ed00890b5534988e74db272bd13d2c0f964f0bedee1b709e969456c3cc700bc5cf3894fbe4356fd993893cc0f59045c9eedd7cb605d0b05696e64611be1e7bbc421b3f9653c06ffe67ac1ddfa211cd0d1df97de30ab9dc675c74cdb2c07571d517913ccf98358d01aee4ba2c4894771f1a437830fc7759776657f5ded33bd8527579a318f2dbd38c4b1188d9a5099b01809fc153907f07f0c86501a59076768f098bc2c7b3d0934e931bce7c61c35b1b4dfcc3098477b21c8d60fe1546c57b669199bb7cb93d646837a71907b6a37dc470f5d96539a074d3a703397231800cce7729536a8800bd92dca92de5642d69ad5b931ff7e833465c34a1b89e04d4839cd40c1661a6df36a680919b517c4f7a8a9c04335db936500ea8965a41a096e666ef71838173ff1792b5d286ab481948be0fcf5ffcaa3ce3c8a5a9291e3ec0c09dfb77aacdf5d5eb808cc7781c7823bdf7982c69412c3b2eab90929328c1b86d3bc62a451f592f458acd45d4d6ff5f1099db35f433b491d88d3202d58b20b4d172120271e3107b35e943e4d2ca22c19d83675e287aab686bd16818cb7ed1551150c80b6e081772fcfc708948d4325fa53ec69d14df826668a45c757ac9148adcb43de969293fa13e3972cda3b9fe5ac64f266b5e6e142a005cb9234ac4f968caddcf7a417ad41b57d2aa9cfe8d606435fa7a5c6abd3a749ee2f56345a4356f6b0a3a17cdf6910345693f7524c9acdf59504e5bdbb13ea6292b89aa32707b19ea8d874933da90894772c901d21307aede3b3445f6f7d685ba99c308e9d9ea9921b19c832a3179cd3962a97e7a29d3a11882254e9609371a237cf268d4a5aed9a7a4922420380998bad77dc85aa5edd793a5cfba8d01f545f558779cca5c099672334e60e5e96a6407148a82a598216fcddd7f369f647a82e71f65a17f411e01ce4187c42f3ccf9570c16b9357bb3adae2ea78bbda6eee8eaa83a48c29a4f09b3c82b8cd7dc3d9b0fc630bda0d21e5504a14a2d1370131c040f285bd233a992818cf52b5250849a92236def0d18d4049c23f7da9376d8063caea630f0210397d61e57db395f62a35799f6edd600d1064dcdc5ba3ae7ac3d5d0d62f369fd7e8ccd9f4d58d065aa0b420106c6e68a69e2752bbc5943b230c5ad6d533f904ee86343131529e4dc3769966d0ea2f5829be86d1e4e5515cebe5c97c8b1a36d92e0c8b1c8aa58c24dbb0a80b3c30fbced6c1ddeb1fd78179d97a49cd14c110acb58b5a0875def14d43b82d01de56fb975c573eb43ff1744f4019c8f057c8bee519af2e513d31ed93b4006ff56b57e6328c43fc83c4df576ee1d0efbc00a255bd1eeaab180ff7f5c58c6de99906f081afc93b44d73aa3d613610094a12b3f6faf43388aa71ff3b63e957aa38728062ae63beee22c1944f069a4d1f104fecc27b43ee2abb495007322e95e4ac2e81066f97bd435aa17a31e4d363b965a55c1ca6c29cb5a3e15e9622354129745ce344fa8ebef490f242774dc11dfd1b5d5bdeba79331d825f4ec4d43a788befc22aa9a509ec97266ae5efca35d9434a4806efd7427b558dfc4ccc675db18342a6f0c807712c18aa04539d97810730d66f0c77f5761422a05d906d78409977152be4a0d1e0cd6178ee98cfdcd58d5db5d60b42c5235d04a9981dda657f80fc2e0a2604ce4353e75d016ac8e251232871650012ad313d5c06c0d949bc3a7bf08700c29dd16a3db911002c97ef4506f9c42a108759cfdf8885bcbe96ac4dce23e00f0eb8d51b2830b37480d03eb2ed0363f0973b883c764bbc3c298e07ee0e3b9eef4a071b9c2d4894d5ba77d0efd5c529040bbb14e0fbfa2651d16e6241d7069dfae1a90b8a54a056370d2a3944256ba96b0442d31e55f09ff359e3c3950e2bab91521d2a440b1fc1e793b8292b931a8bb0e97a9c1320380f748169207f711756ce57411bb20d226c891ac987b568fa31213d552ba90606569e90f17f309495b1880a34936626098d3c26d9833bcab10062017208b10fa2f39aae293bc4bccbc4b96526906bb1436578ad5c87ca634d5224180948d15b4cc6643246e653aaf0d878de2a995d238f73f99128730bb38096786e2cec3f3ebd4409862d6b04e54ab04e2805a63263bb05752d27a5de23d8392b6700703d4d13ea7aaf5cb29bc72d2b77a6c6b42acf424bd3ab781858163d9901910504a9a611d3b55283b7ba88b99fcf014887db2c6038b2ef2cb8cb17907889dcbdf5c407d23a639b28acebfc17c1d417c994e33a30d5924d5e36ded3923e67da8f96017b2740005039096d55359623a0c7622acbff75b4f3a29fc1883aa5c79fba762c17cb328c33d8ffc4d6effaec1838351f51a7c671fc0ae0ed4f04edbfc92f695224ee6b8dc74879a2d1c8ae26ccded26fbad751bcea002a67aee4036c8c4b0e8250282044712365ccc61eaab1c5d2a35e5bd5e5532a42f6b219b01a5924274a5847366a9e36ee1daad5f7991fe42f599d0cb06893eb5e7ef1cc5c63a4482e597f88dc697730bb9e0b209c9676cfc088dec17b0af598fcedabdf13ae29facf0ab9d6de3007d8b9846a4d7310835bcd5b1115d6442a485597b51c2b6f30ceb056f257bb9e5a53b53ce19aa22d2c1fbd6090886a1f80991f0f6c94b92c33670f140bd2836f8007e923b826b8e43e233f044263affd6ba9881e49e55917f479fb0354fb3d6816efdda5d64dc95a72654251090e2488c6a9b64338d3689ae6a98525666128b59ad2688caec2c5ca676c7123ea8dea199b4fd9db07d52f18ce6d8aed9fd587560c921e491f48bafa1138951ae5f3192a86c8c8c9d0a91118c30b9e6f5180fadfe61a426630864ad8381a858859594b4c7d2b2c4ac6d13919a067fd3cc9acb2e404ddef7ab391b0385fb75962790e7c8d4e31a1eaa3c9fde872307ecb2f8bd4b0aa955cf4a9efca35844c767fe63fc2fa13f6f13dd61ca4e79e929193701d8850d3c6dbfdb478dabb857414cc5dc32e9044bebfc9ea307d0a81b15f97672d4e5a2306e86030a2e4d0ee7abafa7bda7acc0ad37cadc5de644d8dbcbe47b0b8590756d53172eb76f76f680988ff2fbef9327b4c565da4f127c3d198a4524b4e47ee7f2c201042a59f52f802a9c54d0fa1f6b3c7e6fbdd6f3d5b7d78a037793ca26f6a706c957ef0e2575c6a368efa63c826adc7cd9ee4571acf3d307ab651f1cd12d8e6e64d69107dae9cd2381e55279dbf2ab879adf71556728b1526d07f77cb38b2e6ae7770cad40ca3a4dc3f2f26e9d7205b4292046f6d58b1f92313743f15b9bdcb4b985bc9ed52a6e45e9a42ec9bffe324f431edebce57efce0585cb9fdb98ddd78acd7affd8c35297f798d89be0bd4ae05c431ec3ad209cdd343f45fe5995457b7c49d2348d91e131eaa905801820312b9ca56a81cfd4b2ac9df2d04ba31ebcf8657c01cd976a0db27d96ab360284f63c3f6a7af7ae277e4992b06366ff64d50e8c65c60622d1f7e3f3d67eefbd19df4535c788ca5027ca45b3a69820c66b32a67526a64240e34a0c8cccbd4a4362d3f2c495a20c65dcd3dcd3e468092e8dd547c0b8db9b5f38cf4c1715dc42da858a729b23f0f79d2e9530f3d79d8d83fbade3680a6d8d614ed7778ff0665ef4ae28ca39c119b3fbba92f113b7a7d11f770e516d8ee7f7c2ff84fa8444b1be5cf3392dc7742408b69faf1902a79e0d68b16b1068bc3feea00aeb7f058a8bec7500066b93801329a7b7cc1987ecc195f82c66aa86b29a50ccfbd5b132bb5d9359c69e26bedcedd2197b781296ad920a66a1de22f670d74f2f7eb8c2d10203f43fc310059610e4a0a5ad017aef719c069f5049aeeb068c5eb9de4e785b0639028d339d240a11006088024b6371bf9b549644ca17ee9774f229654709e2558fc38891592e94f3c624603292187295eec09536110ffda86c9b727cf470783be13a3d355979d41fcf499fc5e19eb887c3ac6cfc45888bfab180e6d31fd17fdccc55088cf07098684f5cda0aac21cf96937b1510dcf66a1f058003f573e8c3ff6352dee433b26f758af1eab6ffb639b4df6c6af6a20109bee3c0887a316d5bb23b0ad937e24f810bc8c90e6f14aeaf41b1a69331df619856433225a57a058a01b7c2cef98e6dac6157c049389ffe52f1f702a2919192a9fc1e458f1f1ec4d06a37a29ee221c72abe1b803cac0f503b4a0ebf4c43db7bd069e604497a19d9d8400d9031760eb2a6910b9d277d451be70e9072fef3e21eb2a42a80c83ef0d536d68789cc409a4cae5c0101d14fdb5be5c7b5c9732b9937a677be1af96c0c19e2cb6c0235847c9e45c00ee5ce1c7803478ec51f24df2f4e1129659eeaea26e458cb73c7d213f67a0f330338c83e13cebc55742bfbd71022c3a827e4450bb244164816ba2c9dafa64cd5abc56e247d74de7bb14ecbd0ba14e5dd3e011ed9f36dce669646fddf2996832901e59bd2bea940efceace3874f1c8a9cd75a5fa95965aa2e3a6e1688de9f85ff23910a28d5a64ab5533a78c8b0f50aff33db2297b2396bd7bdabd3931185a8651368d9019cb7b0af6d8310e3bdc65509b5712225abe5fe1b5f607ac27588b73cb322ab6b6b82d7e0dac16b90ff4f2d7f74373ddadc93e7ea7a556f3215dcfccea8124b95e1b631941adaba1ce1f6a8911b5ab6dfa520cb126d38b841ad178535e9e1fbf5fcb98653757b2ce30f45a2b974e4a9097a5c62b104f93f1457365517d544c6e157955a31aa6201aa8831fc8cc8db5de290e8ee26b3d925a2cb4f3320b18f65ebc22648d58214bc1a21b861fd5916f6cfbc5e1e2b5f534d943bd4b38f72dbc051a0fb10f96eb4e55280c0a826ae98556591cb1416ae189e2c7fbff9a91fa91abff0add976e008533ef9dd6bd2617c142ac462991b157847501d1f7dc2c12c97631b402575b7888cbb98df138ffdeb3903d45463788967b8d5af510b9d3e1374807fca552b0cb83e1e51ffc57809aa0df765989bbfc57afa90c2f6f92c6c5a755c2888dd4c416589cc4358d5da257b2eb72f75c81bf14555cfcc11914cc78514721e55dc953fbd5af3e3dc7c47cfafe9656578744f2da2e067d163a43078ece95407fb0fd48390efa03b4574c65f76a186f3e243f07795b3d3267cbd67b9f617fb5d96413bfd86a8de09d0bdaf51ebd4922bf23f3dc670e909de7a47f237ba5bd3edf12bd62ec9a192d54eba02ead579bcfc67452c67e92544ffff2804adf35408a275981f03c685d56464907fed2c7f5f1e1db7bdae8c4b2aa386e32465f841de607198bd6c6c7a5917d6d598f2c9a0ae95e82ca0ce9c9a4cf8a3a0911e3e665440a5bd8f48414763941fd10a1465c7de96fef7027567589896005f8dccdcddc6510b420b1ce63de89bed09083ab9f8dd71815409b539b32bfa3e62aa3a856ee29792839e665d1ed2a276d9486c5f429f63cbcedd4db5c5b87faa0c46535e1ee55835017deac4e0a46b180c2872c8b087c22f78e66a96aad3708cb9ce49d44ee9a0f67d5221156afef135b2900fb40049971e7c68be00f9dc28ba6c27734cacdc6f932774fccbc3795a2466c864224be6c016d002b25c5137b765494c86f8d2bd0f9db64806a95c7a911b5f4aa890d84e1d13e5cafa5588357679204c137e1316114a406978abe714f9e96066ac34f8cc0ef3cfc935a20c173644aa9953b77e1729c7dff80c1182cbbfd5f5fa49c58421058f4a96b18b2afc073edae6a47f23dd5942d8fa6ca799163477c70ad1bd3fe41853099c2b8e8395f95cff9520412225bd3133e449866cfd4026ba466a502f72420d5d743d5d36acfba9ebad91ff5e011b93d90bacaa188eec8e23cc814fba66ffb30919a33e2e60ec0bc1118310784fcc7725267cd2d662807effb9591917cc9fb1d01fed3c67410b20b90f9f1a3d2d665aa94b4469503ff1b623bfb5b4d0f20d3feb8240ee8cb1687eec09b1f95eca297799cf17273c4165771e88204284d4d78fe28c6bfb86d874789627eafdba9ea05b0c9806caacf0c4a93bd45cf157f04b2286b13abedebf9e13257a33d2def738343838abdc8b6b534c014b23f4d01ee3e00efa64fa634ceffeb646f4323821cd3e20c70f1eaf774c0f9be848cf5f2ec8606a48aa71f1662d822ec0dd07c1010123e19a71df7119b53734484876fa8e59f386b186db29e279224c8e464d4c19303d99ab9f44620456ed5a1c7f4918a49d19e1140745a2de698a61ca5c58723a928e36337288b1549e0526b02f9b16f92c292429c6f553e424b969b768c99a0e177e0090389733afe64dec99f840169b9daa087c58e6e916d3942590616c0ca0c9408167c2dd17e43249c5cc1d3d4e8cbeccd469233ecf8d483ca63332221eea2f3284a18607e70acfee07150eba11ab283cedec5d301af926619eff17da41338d700326bb263ae44386f52959a4c0eaf2554a58ff1ea319e1663076ebdf72de092108513b0c707662c4743e2e47d62183244b8c908df92e9b52f10515a594ed03e5f77d5079698353bbc4c0cd76cf09e6ed23063b8918149c9e9836aa87f43c956d9e7f73f5cfc1339c1a192651342bfbd23c502532152dacee60d5574258862cb1c2b63298c9abe7a276f49f368eef4a7966ca0813748bcbe4e499281f641f28e12ef9065ad16f95c3ac5daadc47148a93d47dfb4fd5bd1a7cad1e80b164cf892e632e0434f89e455dd100d437fb8be4dc3563c5cbeaac49d78a09207fb4c4488ec6e8fefe5a3a2f445022b25eea06a5ea9fa1dc82cad8d982271e9bb5406d18d0da8d5a0b96fe96975529f9afadd883682ba4d9ae114658a1cdc479d78e236902422cc77173733c1d092ea87aa1b48ef7dce3336effea82a9b0ad0c8dfe100aba619550b70f80d90dfc979c54753e3c921c5b5fe489ba270bd3b01bc89af4a0c71711f4778c40d89d7032930c89f023e9f9fc1a6083b05a7d0bad1fbde08c5f1446557cf6ccf40e4fef5632729a2aa69d43fb9866d8c7c06e5d472200a3974b1fd614ab60f3b8d168f3c80a10acc3b16bb667d236c67a01e90609b720b22f1045b6670c73efbee48795a2a7e5822ab41b2933295d69ea1f67a3060d299ac12ceb74b8894fa8647e5e5ea8000955dee0ea0e2f8db43cf61dc11d918dc7bbc1e8dfe58cd68ac55218301bf0992e1fec0c715679a39559d68c99adb7c7d07ee1a5f6ae9bd9531a3ae1eca6f4158c78910b73387ff062222ae5398e14f1acdb20004591890d452570e70c362a406d391f63b5edb633d83aa878832684f6d6110df267ab4229e916385c00c8491b308b1b794bf22c98fdb869c89dd19e517ae55259d1fcdabfe79a528fbd3de718d429850676d2fbe0fe47c8d1e4086d4789b457ffcbab6c5c63c1ada4234d60b143576932ad49d55439bf328db1062c0c162e11195211744e4e870195c3ad61a57af2a9b307d89916655202764985df2ca204b36552ada053e42e62a7f9268b8c5ab3ccd0f2b00f4900a5564411f467dc343452c5f2f9d23e0070712b96e9f1b8e6227615b34f113dc2cc3e1d4812210a292c01d4b0cd6bf87bce7be73d672a897e980403928cbe42b2f303d754a6228bcb62f7058d69027eb795600653995ec09de046321346203e3e3c7315d7b2dabb645bbabd18271936a406592fdb8848a46f50e6804c85def5f8408e6e520f537396a527e92fe1553bedd99f7c423414df7b09be6dfa108b08ee7ead1b3e4df55b661517890d25a55310a8360751ac1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
