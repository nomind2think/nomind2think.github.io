<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a9c75f9c3256524a3ab625a73e2e076447731accdf07f296572bde0ad5d9baf7ece65f0b9c65c5ad0061eae3e54bf057ff12dd35d47d7a868801f137b996b1e013d70ebe3ae3b4eb9183dffefcad6e65431362c424127cbd3cf093a0b8a555c7384b97aab26e7f5ca2dbb4013963de45abd5fb43d4a0afdc12e4cef6cd623ba122aec7f59c85065259787abba2fe1be3a8868abfed1208028d531a1a15c56d48a05505b2903940549005e68de37ee1d1b381350953e44fd5beacf05f577444dea8bfd7ce9a4792549747104c6bb7128b3b395bb68fbfc9df8c14277d2ee4cda770456731711882e40bb2d2fdb693ffb9080ef0da447780dfd828ef87cad2a5f2f56edfc5ccbca1778514c2865376e95bdbe4c064c05d2435972a60c720ebaa2c328800e0bff723563d97dacae279762cf2f7512ac1267dfe37d26c0bfa72498c003902f4cfebf30fb5aaa108b51c049c03c9e138cfdb8c304d4e416d5e7cc0b967cfa8156c82c7e1abc30b9dfdf33a1fb994e0738b3094ab5771df0488f87dd1479dca5ccd70e1e774ae18934d56e2ad41fbb68287795bf5b780fdc93f3ec60a4fc4c9dca4f4651a2875b88cf4622105527493a39a749ef2420c51736ff44916cee8e6b0040c560af481fcebaeea6b6c586f2f325b5568bbf49512f70a3cecb42d2c5795cddac95b892d93047aa96619707256cf0f265b2c339eb7cfd9b70ba17694f1af2894de72bb467d1fc4e8ad84520f20a85b822e3edb67b7310b238a817947e2ff7eab9517064bdae6d565f94ada4294827ff47a4e6a5fa3ecc10cfce3c4e72135a867af7e31365dddfa77ff0882274f9bcb5b06619ae0d5b1fd20706f6608f1d876f578c0146ef8e326c08d136e1ca9a99463f516c538123fb321bab5651c171679a8bc60c69508c8c2b5d4fa5630e9efccc4901aefede219fd2071b70a58e64fc12a5d1806892b09acb159e932ddb54493b70cb649ccc698391024f4ad42ebd2931d80823512b9ba48c6f0cc422057433230c1c36da666821b1c72871ec9004f370745a095865fce35e080ef1509e2361b65284c869ca4cb945ac15cb0e925d1e2a56d6f6da24316fdc499ead3f07891caaecb23dc0d0fe69fe77f736675027c8c55875611f6e8789356869703d06c35891a52f49a6159665bc7a2d7136cf9d1a4079d226e78f6f22c489c2d1e5bffc740b1dc48b2ab602b132ae20ba6ab3d49bcfdc55cbcfdb5c90f1bc5e0acdca25f5a5579997c7daa1e91e67ae5dc501511d9c53a757bed9e326da884e35450f913423221e6096d2a413c56d16b8334e83a8032120677e533aa1e7c40e1cc021a8d0270fc8040dffbec15a3aa240acf0b9af25dc6a8d85262d79ba11ad5b2eba1a07efbe5fa53ed6b64308189625f44cee22d9c670ddfbbf2bdf1a09d4e47430ed25bb00e1314790244938bccc642a160ca845936085e4dce0406af7c639eb59c314dba2ab55b121fa97b8fe8d45eab832e17874befa3e73e1ec5936c3b179b0895ab47ec549d163779f8342a18e5da5b4938b164319e37405523fee0fe7401953c5eef8c89823da928cddf8a837592c13260bb4767f3b366ceef9cc68bc49e68519690c620cb5c6e3b70343411b641ba9612acdf0c5d94445ec53c2c1514a1093982f4ac8f06ea19b5099824b2d2288046596cffd5428b22945daa1f725455100df8daeb280199f9cc3d518fad9a85809835f2509dd8b1244ddc07b6b90c8dc6e25f7fedbb882ff56541a96e4ea2fab1d64fa4584ffc0816fa04255b792b82ffc260300451f59807699e595e7b1dbc97d66612fb6cbc17838cc9aff5cdac8bb1b6e84c717931fb9e67ddf9ceffde767271dbd403ecd9f938b55cd5c3d30b264bcf179d3bef10e146353cf83fa7c4cc993e02a9219adc46b7aeae54da1008e56feb01efcfb3f9f148d9ff0bf9e7b166cf482681bf1ceeb19e5361fc47f61f7121642a608991b86570975dc47c49f01cac267769e349c7d140d5a3b4ad95cd029b3edf3c653683e0b86be8863ebc01a389a7f395666e32d7a5a1617629e794a0ab31c9fdad0273548fa7a8c255801edb203c6fbe82b74e8cec495283ab0e3b5427964ae9201428ec1d00664efdb9ecaacebd2c65e2532947fea529937b5799a9978520a504a742898fa1034fc9a10e36595b12f334bad3233f37b86b6a4ec65425c06708789dcfd5cdc236db13813288870874a260dc1d037cf7a4f2361ad1331f2c7556c88eb40980e327185b1b7321c423f5c7fac6db293df89f0e2f350f4b222510bda4b16686e0b95e9abf7cf5d5953ac538dfa46930a0fca8df08f5872c7bf30c351717d63767a48f45d13d6e3f296d3aeaf44c2a7e7465d8d537a7b2dc8a3af09b9ccb8037839a8cb8421e4e8efaa63876af934443b72b4fab993b896af8e2615775d8e446f4564ad80c5f8abf7debbb6abf81b2342e96f96f9961aa7e5831d65e63d841f27ada60d825b0f8c60d52fc25984d49ba595fd56d14c7c359408a126f9e0a4cab8c8064483ea0bc4654bb8886fad5d794404b5d5fc6671527bf340c124fd6bcb1b858c587701281b618cab439e558b5fcc7aa4fcccf938c3d6758bf24a7edbe03ec3875ac7764bee5fa525cf70212cad302e806e08c8cc142e99aa0a269647fb5c58abdd8dec28bb743b7f82fa020671ac6283901ec8855ad93a5b681d0bac4f7471f11243b443862dd785e846907d81ead154633aac59f6125612512234ccd8c3a364a99caa94b4f86e92e761cd668c90c241aa253542d3a1a8c6d673759997c5602e64e757dc04a6ab21269127483038023c267f2900d5cf0fcec9782221f6b46cfb78ad62e7080e046f31990c712613f699a49fcbe2099dd60339bb03f535dc53c5a5e2a814b0378805d0f1af6371cb912a63a83bbfea738ac6a96f6e6be524d20e37544a386a7510d76d91f5a26bb192bd5b4a6297982e9f2a91d5e45c3223e17a55f73845caae14abc4802aa0793470b33fba6b0132ec6606169bcbe47f1430ad6f60bbcf11a8ebaff77caf568ecc2f7d57c0b194cd5fca77d752701b36ad03f17d4178055685ab63e44683fcdf9d133c150595daed0e60c47f2619b8095d33c678a0902cc8de187f0fc5874f65681a889210b04412d8fed49620580ced3f3eab7e475adea8aee758839102eb344cb1fbdf97a67556ede854ddc288c11ec4410209fe81299419085ddd8a845f19a152cae0867d0eb650451f639770b891139fbef55afb4081990f32e6aff6817a8526ef00e7bce04080116a22cabf0a1aecaa4ccc8ea488972d137736a8baacaf63c29787dc8c8e309512acf79e0801eb7746fbeaa26b03b5d70450a8a1a61c0969339e9ffe77761169cf29cf4cce7cc9ce36c59d51b8e2e6bb4f391a0b307b37a73912fca6970953670b6a05305befcccddd422e7f82967115071e8df3f5b7623eee3e0f1709e1f69387f7f121a6e1794f645c641058e8fbe71d952fc82c25286b2ae61cc7c8a54e7fb987ab69e934bbc3aed3969b8c00ba2c625e8978ee0283bb183b72e0afcb4b2da4d4b2dd32c9860e47908b7e7628d172e9fe459156a21e8993866af13718ca1bd64fe29a9f76125f419f7009a4087b477f0879cea812180a0577ff8d548008db0c00113b2e8dfce5e147f1567be599402b9f08901469a0238e9ee1f06868ce90538ef1111256d9b1ed58b7acea41a0502c1aa3cbfcee541e4d1690f58ef24f7830777dfb332a251e73c06d9f21e4e7ad376cd07b4db18c4d6cd4d348ea10273a8f978a2cb98df0211429be5f5c5143c4f21670890b27eabe7f135e8bcae3c72d15556520571a51eb24dc7ff9f1238a737aa60f3e57a2d2049da6d77459fd3c78769c8b55f4e58ba96db65849189812132eba446b04791cce9076eb56b5851fc170d76ca58505e30c29a579f0bee754c3f8242903cef5deaaca9b7196c1389716987f0f60fbd40adf388f3293b820746d9ddae57b451ce2d731308a563b886ed3fbdb04ff1684be9faf686903d3ef94ed804ac7511f9ccf2585108be329a527061469414c491468c1e2e0e74f51f59331353c4413f16b6451b981902ca3a0e9563d49a57547659e2951fe6a91bcfd0d5f13f5796e2e540f4b6bfaa3f849463ed1e8ea9d5f49c24c6ff03ae7129a1aa761cdeaf180046cfac133e44e214841a2ec0aee1998166d23ccab1ab3cbcbb9228bc4a9ed8fd8b7c8d3dcf4d949b4588e765d375424c29ee32810767b7d54bc938358f080f56197675287d7697c8f857757ca7040a9e08b53cfcbd651d0f80ff00c9b7b4fb1502f350d179cadc6da2030821411fe01322d35ad6b60a7d851bc0b62a2f91e9e87178d2a0c05ab5a81577f4c279b5682964fb4b2d55792935619910967ca7851cc47468834f24898b2e4e90a64e8cfc6f97de72b1877853948f1715bf74ec593ed1a39cc9b00f2059bd96b67d29aef7db4375c45745bbcd020a01ec6523057a69dfa188e29e1d5d161cc3d41d5e5aa57ae8f07d4827220eb47da2cc7ef0edb2c69ca651f0c421ca5093ee95525697af7dcb21670c53a9e5c3f1e95243c41ea24e35cad1a0e0e05fd58eba0df404dc8bca55a1992832d20f36b87194aac63e28e4f8bd2a755c0b37cf515928bfe5cbeee720f27bb97d6c546e57a3b7e53de27019df3869f9cafcd9273a1f3ef4084e8fdd2771764ee6ae0d082c50da73a89c93d1394ba8ed4c2701331cb94b30c5e941e7aea808f05dd61e42f343db1077b63a442e6b21852de1e025ad049a975ab26d95ed1dc9f9356809759486088a0c3106c38ddc64109044991f6e4bc4f6c0b8e5b5624abfa95d3e1b6ba4a1e9f053d3ea4da8047f3e720b41e9ff407b33b28b48c01d3ceb38dc1aa64e954fc21a2eb1145e32693a84c70c66c2333355eb5041a2a476eb9b88266f44f5e498b51c3c2b9e5d4ab86dc21be403d9d5cb1b025253b82ee7ddec0ade4e866d8278f4dec9ccd434c8472eaca5b7911e7ce6a40843cc8c9813735d3cd3669037d9c0261cbc3923f0db2f9fa154f06e64eb618b25bfdcd4255cd5383c53c599d79a989f9288f8e7170cc296dc1b9c1ed12704c118c470ea17dd93e1b1c5a8a605537fb48de8ec49ab5f9a60886955b195516d3d47c3f40ec206217f64fdeba1bf3cde89ee7dee51bb1426554a6836069432b2b02814fdb9446952c614b9a0e3502182d99a4211a970031289bec41d437a06e494acfee464d7a1a28c73ff8d7f0d8e1164e6d9871af61b631f2c4dc034f681ae2e59e7d0ee56ed89de0845d921fefa51626624d5c48d6511d63deae2ffd28a7e7061ebccb6d15667dab0c02b887ef4e884758bca43a3d406ad72aee2500522552a5cec607f7476502480a01259df4d161598d5a17904a143d0b3d2cba2d1c7f49c856fcc9445a5a8c3e8a27f83aaee871524bcedc9b3508500540a0a8e2835ae4a637e63fc5353a8e41fd14afac3b14bad82d01bc474791f08e62b7cd5d1ca2d824de16ee16a023ac6e5ad0e5fb207f38629c253c2b19148ea6decd24db8062314503411548adf01c01eccb2a28331b5d7009a5d329b9fa622e6eff2ed66f02af0ebcc43598a0fafa1b21de5640e62908623d1d35b931bc0307e5cda7e41bd91e13a7764b964c8a23e44fcd520296427f68ab994c2295fbfd5aee12cba0842ce07b68f416c4360e0061aebd66ea89c87aeb454c6b4ea6ea8b7c484b43eb11bc87df32539885e22e48affa67fe82a4a4c15ac43576b11310594bca69a0acfd16149c894877f8d910f6fa93d389f7be27bc028eef7f7adc194900729564ddc3e4eeda04f28265d2b003708d11f5aff8ae5f55d238e9027bc215585e8425fc4314a0ec44f73a895c85bec71940067e86546ce0e3c2c8fe214e13136f5c81a12ea39e91a943ef2919a19318ba6564d434a1c13bc9ada178e9e85e6a5363617ef67558fbff51bb7d3d7077a4913d5b3174c6b5c5cff39b0d5d8c2ceb9b7339f372c048a34a0c6801c8c47f2f1e62b6a80d658d6d4e092e2369d0921044b0e936f05c594dd8aed23c0106cac54b0cff9990707d1fd5653656d13a37f4b929223c38f3bb5bd40276e36c798141e6ed550592881790c3459133b325432cccd2ee9d38899fc69a8a59a6d7211097b6ba20368b3b4f762d1ba8b53764ec7d2d0921a79f5be636a2e7855d4f5e1aadd238c9f3bdcc3a3b7b6572faf013bb68e11380d54ee063b0083cf8bc9c27f45692cacd2db208e8358a86c8553a6c90df093b765cc14cecadfdd8b2d3d0aea44f4525cf4d7e3e1ed43bf17234804c1c7278d8ca11f6f368795f9732effc8c769e3ab6114718c03e338eed5ca7a2f0723ba8af705edfc7434e82ffc2ba98f1b8fc694b144c75a7ac2c4c80233dbbb05b7c8545808aa2ae557abc2e59935c393d2881c5b3d4064d0abc951fe9c104a1eee6f19fa57225d0c299c8e0993d0dfe0d5b9da87012e2d6d8a561f3773386e6a514448cffd0b7de0e8a4129caa028cd90defb59998c1d4e4fd93aa0e584a3d3b66b9ac321362001dfbaa4c1da78ef272f8c39a2b47d6f3c68085681f6129ca5bcb77bcf7ed7027ea5808bb123327c85308ae167e6828f70328c1dae6428e43338787f70e1c485ae616eeeadd794b9f139491cd8027c660dbf06a28b999ae693ed47fedba4f378faa5ad1fe6e9fd42f75894cb92ef8f73c339cda86d32a4cad344a4e8806dbfb9aa11767543c9d019f6d0ef29a79b2a529e6d5af17849175c7727bd906679513a4025c8fbe6b6527b1c943a761728df7a4c2a8b61624af9b7e8248f0fbe61bfd6d9efe59f89ed0ab22c31bd8ac8847a9bcfea4567f1c5bda6fabfc6e830f84e79af4fe098ca3597e1c16e77117edfe76900e7e7e0634a0f34167f65f0dca659de17e573f97dc882ad3895102fefd7b46fc909afa64bf551734d7b26f3a9d4ab04792c8620889a25e01bad7d2f55125cd0df051396601633f1d699cc5686a9c70d99bd13ccb534553ea94183355395646e7ae442f23b61c72778b1505710208e934c92f0ce2ce7c1ead9f0424f4190658831443966a08889dcc87d673a653c2bf95ae84de360e016e0037bd2e6ca5ffa31a87f961b0a95f6a45f8972edbda8ea1de275381e9a244e006d8e4d410285422d6a4cac7e69928362ecf55ba729a8d05b289a944b6ac7e4462b8a95ee7bbaca744cf0cc45fed3b997137fa11e2d1be718fd47bec039e38492fc7cfbc5cecceb85dbe907918eebf0f73c683356e3224f2b58ab1825222912f389cfe1e168b81281020b3e1a198e8b7858fa3d441a9c9013fdb32c8bb73ef7f59ff811edba5f7b9a7f1d663939bb31985d06bd7561591cffc08a47bef421d451e406cc3400ec4c1fe9581251d49719719e440789ce37ab06047c21f406c023a38ced6d77b7b86c3319f12006bd6d2a97c765c37f9416bf85dfd48e994ef2d7b2a4034322ed44aaf26ea3bc8f778daed5a5379773ba0db92b4b4e23da063dcb824581b4ed6f4c331468e8ab7617401b8c8cce7b90d5628637d3ae2ecb7d5aa8664e9c28d000377c40f2d0773d2b5eb2550cb2e80e6655e11032cc9d019850b80500bbf1517d9270547d77cc107b478c5935bec0c3820b33efd39b26ccdc33360c9386bf3ea6356abcfb0c8cfea40dc25f860892467c907c73dcff18c4006522c58e080e0d6aec47c522f18b96f34228a68ea3ee49ded425559339cce779088bff8d1d0562db96dbcf6d23317f2aabbf274ff1841217ac6e4a916a15f20c788cce567c7a13c0ed29025d911514201c595e7876faa9700da9f6f755a231dff2522bda33031b9c906c1b417003bc56fa638e61f93a194623407a97bb97e3bea015728d413456b1780c8bfa17a226da9d0a8aeb3d57a42a73b63ae12fa66d81da2c624c9e320432848862be8fcea7f6cec6032fe1db7b34f358d9d155e94ceeb19dea6e2648be71d28194b0c3c5e3171b48cab5812bd036853290cfa72106b25c7a31a39c281c6caba292a6b76755c3980e27f1d8558dd33f2ddcf385b559e519c62fa76a56d337cca0ae06368e8ec6a07af78e3e93b2f406ee642162174bef58a09c674ff2e62be0d8c95b14a17c9dcc8a46e19b87888982e6ebaf85957d066efea227fe6610aeac807c91fa786d8b3af379d186a85741d2ff710280c53ff51760e5bd8d1e878f2fba499f289d446149f2da6aad74007ca9fd11aefd285c68308da41f198a680e5a513b9181a765ada81db7907640a5f1711f31aeca0980c333d5a9a5a199b5ef77758844f7329b18f963b364ad8019c9e8d9915f30eb4650386336d988be57863ddf256fe2e0c463f7d52a932786d2d3380c7bb1603dd4dec29be15896844539a23492c50cbb8e9823cf0c674a4df9a66f924cf87bc5440a3d859d5f12ff5fe7c43ccc3e2ab1210dac24e4b768c2c55b67e6b59130daefd034bf27999f4d835833320640b148f91d52febac1ea01e704ecfc42639bc8ec02658a7be6d6448ce0c54831d8de80d40a2b0c08273c58cb1e273e99a2513970dac657296164acb47c62c43ee7d18d145558f11d2ce485dc45e1fa9e9cb8f0097f44649bd315028a9a86411bb2a6c7213af412e596ff524f7fdd5664805c34291ccd9f0e88068492b0bbc0bcba72e849e95f90015fadfb04b2363897e81df90002fadcfb5b998bc9dd1bedd161cfbc55b0cefe472d8603e6a8d43698968a3d68413803da137a98484cc71ec5e6331f5108817a5496ad7fd37895b87b6ce03b376f8d780a0b7fab23c645a54626e628c3b284d6238e1b3a6b58b5b3ff8b5fc2210d02cd251861e35b04ee04eaf7a1f99db6c187d6ae990897a7985c91a69fe2a99e4bfe8640d1640207d87a3ebb70d4d378a11ddd944ef78aeaf668b15232bd8538b9fc6d938d8105fad7aa45e260d1401e53c2732a23be6de85ea414bcd93a041e820de24c57b921f230d76b07b5626bf4cf95180f9110a8b4192bcbe9784cb3233ea861533c4e0e089a8ec9492dda2a1c0e1155ede18423ea20709e4235105f80a6de9f47698f2a6da81da3c02ae1baeff571057c6c310d789fb5694190b2827e697722b051036e7b377dfa9cb6abb3af9ad7e1af81cdabf2e5d9726ee67e8d9239765a96d350d8f5a90c2de9ca2a3cb6f7f5691b1d6e0bc56ffd2e17ac5e68341ad37fdf4476776a124498869b9134273b43ce452b6f1c25c9bd2706a4b06be3a0f4e5c4b11f7952772f48e8e1d837941c7738a3f59e8fcf4598f984c6f65b4000d7278e42022d66d7b6695b34de451e0b26241c6399c4b427e59c0b732cd4f24db214fdd040cd0e3667d6f8ea03d85ebff64cd3ac9138740597db6b8896169906f68e900cb222952ff00a0879ddddda6c7c136c0e4cb04c51bafb9b49c281a6681353ae003994bfa2997926a88fce03e79b76e1b301b28ae157dfe279938981599de7a11c0b2c350eb724d938400fb561d673d2c0ecb28d241e3d882d93780d3cdd6795cc0a40f26ec57927620f8500bc8811955335d0d09bc92344072a35154de76976701f43153b6b3cf3ed18999571f02ac09f409da68dc1e2a6e7ae60c0b3e04a6a144bbc302ba81afcf9a5c97f4df316d1b7b77a9a179eba25f89bd21509ed600c49bf411f6c40e41d903610dab0cdb51686c60281982313995aa3b2cc77cccdcf7078780bd38693d51d146266f9cddec43f2ef6e7e1fe556e935423ca3ba00bb08443994022cb02a183bce9772b7fdf97d921fefdf5c00689913f0cd811023d87d60aa168221d284d943e5f1fc92ccd824d848ee486a1e6704409cbcaf0fed7da37519d6ad402d86e30f7edbd81e42d230a30bb41f06197015c9d7702524bb1948548c28edec8b0e5821295ab352cc110da8b156829fe2f2b5ef13c9c8d87740d32d79462ded5d686c33ab500d21cce678725b054872b3f11e37d9740aae878e6dcb084784db0a5fbc5c1063e027031588a50127be5310e7dddc67d28bcbcb3b21e1df03ea92d3fc1122c6d6c8223ef761764a8b94b114841542c95ffaef1d8b185cfc2a7cc024eb199db3dd9295b152449c6388a3c3e781db3cfe40cc94b50e24111d7f2008de0e1b5ee690a4ae699769ca0d16ed96862682bd5d63d0be5dab7d935d4345530c5b8fd7105da5c4010d388cffb4759dab7539cf086637ed1ae5b15292a0900e746bb3f02d1472cd93f4fa59fe4fd134a3ed36681f76964dac1bd4e25a9430ec51410a22c37b75c74771c3e81adc455966b1d81d44a798cdd23efa87fdb72ba62d24ca6b021d5884292514626c0bf5017a7720b79275be99ea7ca371092fcbccc5fe5815a213c07e0580bf39e6df948aeb35f872f49af22b508132d172598673f4f2aaba1916b5aa563ce3d2855faab52da20049735768c598baf3e90877f40d0da883df142c554836a9417b7b315d8c9dbb4f78bc0923ee935eb760f2215a39b6b73ef52330067e3bd8f011465105154865189fe86024b8fdd77a8a7eb90512030f717c972d3915000317f9cba9ffd49d1031194051cc0f572975bb54cd7195bf414601c8c90d87aac21da8ade87ddcad458d2ee908adc101740645653bd9676a85f32882116a5a904ecdc6d38fd0ac520624f35c4ec1e21fcd6e1fa965abecda4b15ca2d74c09da9c952cb77655ec019fcf12c0d5e8857f64ba4cfcef89807de2b5f57afc9ce0a50e3670fc509e9cd7aa566645c377c63327051ccd7f2d83d58c52479e261a34da4b79bcda650aff1a92ee565714530cfefb6c854ec306851787e10f3166c8aa7ed85c7514c376a0761b8f9710010ad9e8f5b20ac3c5dd1bc9c2811eda9a01999887c15cd92f1f11c03f0bf13c85490d7c98209f85251c5f1f18de1b0c47e314da34b1f1a6767543d96d869b5a01f5251a2812835bc6abd41205464b60736d42ecafd049ec06f11ded74d5567c0410558848e668f3341ef5ba8c82c572d092fcacb4b5a6030dcf9fba487f1bd59f6f068dc6566a82aeeae2561f1471d3cb59ac7f554feab628ad9fc0e80eca116cc8c4d286b42dd873b23d992b2ff353fb7102cd7d747ebedfd9d532648a18f972f3c9679e58d708d40410d190f3a3599c344ab96b017d3923cdda2519948bdd74e8d06f64d465064204720aed455b2632018992ef11e5e3e861b34866c7b7c6f9d119f8db3b145557fbf109175c3a79de0e20752abf9c0392eb3eb7c69d35970eda47168f81d81a1c2f9d3baf51ff29f92e8070142857d52b6f76e2587e87b2bfe1e8a692f8f951ed036f16511f0ee39b30686afa27faaefac957d7265cabac43ef6e5979800e01a8b74ef46075aed45182ee8409bda77431b7b899c62eb26f56f5af9d46f20ccaac9d1642a12acfdbd54b26795a29210c365e75f858f028bdccce099bbef1303f8605ed0ee3c4c5cef7d7f9feeffcbb9631a21ad21c9b9a9b011fb60cb28ed44cbea3f5034fa5cf3b60bcbdcfd18ba8c1d356ba40b73ad8928137138d37cbadf0d72c39683efc31a7332735e37a05be4b0d26bd448f7333e341b5e64a38198c5bd2d971bc15337ad7896925a1def6c660c4753f7cfe9e77e64ce10d5000a2a9f32ea2596c50d3cb931cfc5725c77a9941f210dbbbb6aa7989f34684aad367ab2954cfb8713d746e6bda2d1ca71a357b40b9af437275f12b12b3abe53e1ca4bacaf927fbe9289ea0fdc1be4636621ab00f5e5758aec42ba0e48122eafec714d15d511f631fbfec733c590d95e4093fe52a9f6506ac468b77906fcc747b4a0147a361e5b5b321ce3c769c99954bcd8fe95ded14839e7b69e78bc542dc0cafcb4f77c58863e46694f82a04354f9e1826d4f0e3d18076d65eeea9de56f1bd90a77042faf400abe0e8bca02b538c55a5da1aa852dbe38d636e68065a14a1d81eb3008736c6e6ff43dd77163e897dd3c47b91973e95b09a969e78ed6e47d25ea5a97031b696beb9b05fde9c35e39c00002ddd95380c1670c4cc8dee9b6e4231056bf4a5d15de11175618bc0eb04356cfd174abc5a2263e17b61d3e07ca6e3e8e465a82fe377b5d01bb9c774f17e3af5c894300ebc9efb61a466c33d95d91486a04939f6b2391cf4e11d0f189d12445ff9df7672ddacf9b8c9e628b28692bcd6adc96aa997f7230fc259e7ce554942dfa3087f958a73027ae4ea392cc3e217138b4b51849bfdc0192304a6f2b2c59e43e387ba1c35b021cc5244125b3be04243574c22fd6fd423bc7b6e6cd722a420f4c9be05bbfffc4f805a0699ac1bfebd454eb76f6cd238bddf6b94cfad10ac9f1a343c79a34122a456d2668b7cec8e018aa4f6bec712ac94ce88d0a26e183bdf2feb9c51791b96c874b58cf9c4fc8b2ddfed75c92a22736ebcb574e3a4e49c884c8fdec2669f8a4b28e0d9e599299222a2e1a5da658def8347ed3efb7b5a5ba83bb418e902f1841e515298c9a5af320fe076c57cea2b13673cbb986e3163dc1558efb7a06839c1cd93ac9dce4a61c0f956df62cf601cc8178553f126c95685c0cc1769a30f313f061eeec9623e4a6171df799c8e99cde275b6cf31c2ab5418613c4ba88dda0a93e293a56b49d789daddd770b7c407575281ff7db27b479c46e82d6eec790b8f1615330bcf070b5c91c6d8d8a7a886a24012470045c33ce9f77b2e1c885732b669f4d669ba8077f61bb5facab15d5d0400c12218d86af325f9ec4d0431304f5e2581ce49a27406e56bba9b259b21ce47f579a192382141db122a05adbe93175545903c0bf121ebdca7cc4aeb409ad7c58985ab308b787ddcb61dda9489f88488a3651fdac9a08bf5f8dd7a389c6b33db55df0122066c262c94b460c3604a4f955681a2a471f741bde4f8175aea2fa12af36a76a6c3751a1c1733c2099aec1353045df4f309db19f83159a880d3d2bd2a96127bc371d6a25529f18257eb55d0cd076ea5410ef1b49604a0d1c1bd71e2e673c0ae787b43b389a7b5f99782fb77ef170593272a724506e299ea66a019cf05046392467103fad0e32db7f68cc0ef90ead532c13e661e3043eb8ea75215ce95d731b704459b9c62034825afafaedab7c0c1f9155fdac3f51917ae9fe5b3c4b8613707fe231d94672b1d3972c212d35fc3b06e533cdf3a25f94425c19dec4acd9de2e95b81d61202cdb706c7fb3db8b19569fc2808a6b73d59c926f5a6b2ced1bbb74f3b779b53ece1ec990b8cde074f02068052c24ec873d726db51571447cfe13f892957bca8ee6af8a2fef3e336de9d8ded91231b105a9f9afc4c48c23421f3d78477863d066e7321d87f75bab5274e1929214d0510f6001157a43913754df5cbbe8ac42669b2a2056cd4c47a14987f1ae36456533f171a8246c9574ae5642f9d1f78e985ae9a9b991f0cd2bac5a5cb9c30d63549927fba3eb1a4864e6e1e7f8900df73078575bb496e2effc5a259bbf81dba81cc2faf255ec19d3b1b6f63e8bedb2dda7273586b1e8d312a05c1de78514ecdd54e42cb1d1ee36f4404b8f9a677107a3ec227b1cd72bb1f74da1d2220b9c037592b941da238f7bea18684627bbfcd1c3634ec7ef566df67454a7a05ad11cdc4554140fb184ac8cf8e4445bf25dae82609bdfd125c78af983f30ed5571a6e18c0076121301a5d5b3a10a66cfb5393d2f2131e3636d9ac05a3355c9eb43c2a26ab01f2dc024bf85580dc35ba7e4bd51635e6286c5dac23958a0264dbf230bbae7cf3c5db30245f4c8aa8020e53fdf499510d86e68faf7617763ce0c3e942aaed18f54b2b96d7667f814fe0468c8a48de9d5af993d774f83701fdad763d5d05326f5f545051e08a25216d9c6349c29d74d8ebee6e3d46a8c377d5cae6791c23dd1e1d9037678bf74a83a7c6dad6cb7b6d015228db383d893d9b2cbe07e88592a539f29e67d351db9b717431f038f4d72f9e8e2b44db3f6aa886f3b89e765d06aa78babcaee93ca47c2132a0c1157faf7147e84003543afc2746c399f9f58b7ec1648ce62b2c810fcd6ef207be05c1fee06198844f43c8d9649bfb050a3c12e9f07a5b9e23d069ec9e2c569e1ae849b279c03e707e6048027652a476785759742b7b89186e7bf0e38d4ac25dc1fa27a8980f5d16f9bf0b0343931f103f37fd17f1be7b95a9f3cf5cc2a5d399f5355204b9be33faab9847fba0993b8111ce933d2054b95d1d072efffb79b123aab1310e9309d0d7f8f6aec7e545d3a8ee5d35484a3ccd1c1bdece4fa72f8751d21116070d7b1921d44efa7b891b599364d8c6365eeaf540f196007969ca31209c73bce87fb9fc4b0ca08fb769fb4857aba2d1075e378b7e2516197fd6f8c7a602bd2c89f304ba2b8047a832edacb75ff52b597dee17d298beb55cb8672ff82f640d90ef692eb0bfd21046a46824f542a4d1b4f94eec518b6e90c36e904004f9c32ffdf4c3d3c11d715518e27a09ce007ecab2b4c1ad94fd58de153952fd5ee75b341f5afc3a161dccc3ef89154528ea064450d419e8967500f3ff19fb45e394c5d2118e7e8f328a1a737b8fb9e18e28a0a84187e9fc1e73936767da22c5a8d3cdff3429b6214f5575768e2365a263a83d1981e29829822b01a4f978dc8dfa0df6ca12c599dcbc54d0e43c171395bc5d4a2051fa7d88558b182c4812ec6581b774eb59dc9e35d6415b753a9f0812b0a5b5b95ef3bfff18ec0c4ece0dee7f4c5153f4bcce360643586db5ead92c4e45ef44b8f90543bb17e3d70054cff9b7827a4436432a3375f52ffe008da7a42c58402b053bb29b624e6e7ca14d6238ee9db1df913e9910031e18558419446feacb7d4ee5bdad688c7ea40cb3e271068e5cb0b1c8759c26c8c10dc67533e4858839370e1ae41fb702ebb46f93ceafee7dd47e7a4912f03c0c93ec3bc7e4d0e76d872984581570ee70efdd2c4e554ec150e87febecc54f5acae7da4ae86594d97e18476b5f5e2cd1a01433518320aefa0ea494411387912ca9a3f853e893a8c366cca832074a7b3bbc7601c3f0facb56baa73cdf85874805a95af995e0d3a2fa74dbc2d04185764a24990dc476d4bbd107f97e3696b3a739a247fb8bc9214566d4f05cf17c898c3fb12eea9d63a54865c5e06c843d0019473b900cd05b967f37d4d1acf309cf9bb6a560db1b15b698e1915e3ac777788d73ec4f14fcb72e088d16d51dcfecb3d6847a11d58a18c555032b63d7aa3fee08b16d51a510bacecee011776cb5ad5d6fa4b0a535b6a59a6db6ef3b93a066a0bf1dcc6a1ab63ae5270165e958c381089b016cb8eacff4607d0bed39904ed115a72ed9e59f138afe9edf3279d0cdad967f9ad9cf69457bdb835f5c066153a07d0739c3a308b8aceaeefc70c9c0cb8e4d17ee72fa78c391734a53b8f2f0fc2c1cef648ef78660c225cb4e6d87bffae74c513910a5dc698beb369f9832e1a719f0795207ba36dc085378bc68076878d1299eec91a0b5d5b11d4c34badea0ad30ee55dc59b7c5ae4db3314a7dfd8307db58479ef328877b51c0f089bc8cc5a5a939275133335395339709986b42f5b9a8e40613f0c3333ed4a012f2f5c841301e819333c630bf17a8cff75e1ee5ed3d50f209d6abf7bab489917d98b9b2eab7c886c5009e27535f875186896271159689357729ef9bfe091bfc0bd8356da187465540163eb67deaa36a134dc93478666c52ac999e51dd9a818c6c77b9d5fa5c91a8888c8a318c4c2a67d1135b2779481985cd7d0921de08c88df21f47c49676b65f0d1dc4d300338a7771a0bc978f5d439f4ec75df261392f96ad330ae28ab051914c573b8e392afa0d548505bd19c96a38a936b19ddc7267c756473242c216150f760cd07c17b9f0767b513784a76a08887023e47ff7ce40a6c9f16cf2b59472b574f990546ce8902da5dd87430cf9ee63be386070b43f47d02f9066a76159930aac1f587a93f4eac4bb5de95052003adc64a67512114e97d38919d226ad686f71e838fcc23286b9329d24a667e5d528c19c6d57d0427532513975d098a03a5871b28bae325456c0cbd345bba926cd7d43d0dc320ba23569a6747fbf3519ae9e29e10107fc966624c80e67b60bce8208256fdccfc0b15d49e2c4b274b326cf165ad12d955ec4e36b95f4d04f23e432497cf8cc5b46393ee7cf43f699e521abaa0968376caafdbb945aa4b5c4230c1b2e4e5cff89d845187dd0526bf86b97fc6343a5c9cc1374bbdb82ee2ae9c7caded8c0842aa1cfb1c4941842e4993f38a02e8eafaf48cbf6faaa54710510964450dfd50215afe4911fcd6fb8b701e1a82d072c26f6126f8fe27243d7ece10c57a9521a45d61a43f2cbcd98644538d70ff4048000776bc7166391e8125bdf53d1d04ac34bf63822abba56a83a3452c47f46de62bd2e25e1f2f9e7f26e09533a51340eade9dee8926f7f1ed3b0f7cc6b63964d73816586577441758d233713dc1ad33a355774906391a1c593d33ac579081e8945a3ee1274cfe9da785b6659748779bacf281b758e4e56fa0827d5c563ce40e477a41922a341a8a4b887d2914c3db848fc8f1853802228542d8f8b6ee2b6d29651319f763b0be340046c0142dee29732692bf5ef162250e626e8055dd1fcd9a8b0214b053258e0aa4194a093009c003c083a07a978c82d5af2740b74fbe9a6be7f563bad8c7bae36b280428365a752a5dcff3bfc2527a82a3967e8cf83b2f3200fd5da24d0451aeaf90a6c30dd2a7b1bfdf64d60633585c348708030be1651cb9325957898b6a1f3e558894942a9c31e0ffb30cf14a629436ce22937d11c86ee68e551176020be3de2db64151a187caada49dc100d29f3a38b63e715c8e24092133a07dcd4bacbb87dc14a0a248d9602e996d46a20c731b7d1ad0b26dc95730075422809cfa4187e3695c303284dee504439a5e4d61207bd6074427e4a19611662eb8c1bfc11e3ce25f85d691c333ab9a0f09708cb697d5cb73f96ba431fe5ecf58322e973cd4b1d2d1cb376b445bc29f80cbed03550bfd64865f4ae4be20efbcb19379cf5e6521a21eaeddd060cddafe8eed3605b25763bb314c15e18b919d9ecd07320a85a1453a22e862855ee0b857f0f2fa6a8cbc21256d38915438e7997949e6188ac50cc15834c021ff1327d5a21ad070c978f2c9af76496c4777ca62168e102587d9209f43a2e6d9712895ecbb268055200a0167c7b960cef3bb7f098ed153473113a7b7046caa4c0227a90712d9809f58f49e34a777f23e1db289d517c306687017ce5c4834fbdd6a53b3dbdd5a93cb3479706402b33e936d1d820ef9d7f0de2f3d651204622933f29dadd5908240a2227162d31b1148b4cd1ebf1e5e0572e5e211828714372a5f0f1b8a495c5b4afd101d013e6d0a84a9aca7d6d458f4fc96eb70b628004698ce3c1432bdc8361c862a2983ec00c210cd7f1b1f03c8f519bde241e51e38b554949e70d9f46938332e3d4e140c6476a51136f61db7842f73f301719a7c258f328c66e90c4b77a1b80d6ee927f06d52ce9be7d56e54789b52d65d65ca4523296f24369a5eab962187029aed046bcc8c7ef3bd4019c93e56d726664db1bddeca21b3cd1613428c28974aac26a72b01b51053cb1607dc003a9a3459d1e0be126a94806b928d78bd8973b3191d0cbfbe74c1c34cf5a49e9b731498f86a301b7af5d4c36e2435df9e9507e04bc54f232154ea979e77695353ecd2b830ab58689ab6d3db7580e5160ff3000e36d8324e0a48995855fd95895c7e8a5743ecc3458e0c6bb7771276d8d1564e78dc9297dec573b6dac3a2cc83d3c4c4f66dfc02c4da22b5a9734834c89163b213b5c59d650310a911a709c0037551d3477ea8ef887829e162a2227cea5f8bb27e480a3aa751022e1b60824c73e914a2ba5506ced06d4184d78878d2208cbb6a688d179842fbf397261643a675fcff3e2dad1fbbf98a63f4a0b957254bcd9ff076df0b40095efb2f9a0679a1df35995da607058f7efc0df5a27fb484d9cbbb471f1066134e8c8af10672fbe7595dfc16526043a3ca68f629b658d2a8bf27dc5f23c6967b96c0cef4d44db46f5591501eedec3384879fcd9c582e390c8a937f49f6dde63ecb9d998f1f7a3505610046315abae1e598c96805dc0bd16f177b30bb148a16ee9d905e63793b0ee13902f458fbe33c409647ae8345963e3e5ca82cda7c192bd39e0b3cd69cf929f3ea3ace412be20a996a61652eb23b14a99b9d47c6864ab0c98f724ed4bd75f509ed02d3a255dae9a2745bf30df5291c54816c0767fb7b1d8efdd877dc3ec352ed6bf7c37dd1291192653f81d3128fe0613c59015c0a60d5c020a42432ffc11ec4efde69c84e081ef9c42d6996513648eeb226e8dd7bf940f0fc1818813baf19c64bb4d261cb6617e580692e53d33dc763f67b7d906ef2111992fe26623666dc03bbc8c844478f57e8fa65c6e1beb9c000bee96ec786783efd03826cbb0aefd13dda76800679b329b1469eebd8f0273d4e2cb04aaf23e67c63e3b0d4ac3ee094b2d51f8138ee7cedf3d78016359a34077c10468a1afeebb683261c72c5251ce7c0ab402ee26cc5775cf732eb73c9933e80852255621074ebfc09e48f108c3dca86c79431f0b3a1c7fd8d0be72197cf9b380a4ad032ae77d322a658616dad38f7eb3c06ae8ff8a535eae590d8be9c91a55cf18281129f03e2a35f1404c81204a71b71d919e7d82f4ee5aa0c37cd801ea5313d699710badf08b12911f5d525ff9ba7ad48d1adecf72e8816b919a0fe755dc5d565b678533c02e070d066ead9f22e4d1f3a28a630d89e87f0e816177f0d7a03629aae296f8012a75a6a4be0717f7ba3ad1c2bd4a90e37320dee1e1176419824eee89a89e118753be150caa2ce60603362cb901efc3b97c5801c3feb289310b27aa3e0f49f55a3536fea6b4176d93768569a3d870c68dee3b121c1ad966151aad784bcc4d66494592c3c711a0a0a5a198c0845f52c500a65f02e1fa70e7ef754a600ec41b50e15a4a5287b785a9ae1de6c6db67015fd85475a20104772f3efdc49e2f10b2ae83cba89331fc0f08cfaf0760c2f95c9e0219de10c9950ed835b9d9a5de96302f90e7006868dfc2acb774b6ecfd59a3339692791c2d3acaf0b158ca6f3b4bdc67f4157c4c8066902e9f72d9f3585c9e72362ba1368cac5d3184a9113f1ba4b43c8cace70f0e28b6cb99f99db8d13df9a4cfbb51dd8f9b79d853b6a1637c84fa869de2a2bc6046b02ef38a1409cf2d147a1cdadf3193c829f9b506fd76d5dc388ddda2bc9225453d28d2d84220a0544c021dcb7726bf40135b33f7bbe6ad7005232c6104808e4c56bc9d58bbb317ba4bef27602126d76b714c54a628f9cc6a4c5ea0f42bcecb3de86f9f229e096a6e8d4166f12ee2b264bc6743fc54aa6b3d404ed2c60745119f8e20f9ebc16ff47bdfd77800fc9a6004e719115351dfeb3f833ead193616591e904909bcb56cc363118cfce1cd6f780c8c9f07b8ccddeb48e92097a464d9438344ef33f720dbc7b7ec2ec19b61e5d819fa126b27dc38dbe3911f4f5658e835ea0af1453568473f9a859a7e14a8d1d67953c59130a9b04568c4788a847beb4e7bfb0c0bb20cde0d54fbfff7c439473dd5c7fffcccd3d627f7f6fdd317eff7ac06b4cb9117c0fd7ac75ab778459e19919f5456c3cba3f19c10578197570ab896a571bb1f3c49a06ef3bc2c8578bc28d4dfaf9867c5cce6d935063c2f419a8269c1babb2684f4cfb1f88d0cd3134a6a2af4dcb6aa564786097afadcc9dcb1f2fde389482dc334f6ff5af89aadb4b3a83caa124557d065431401829cb7cd2b9d5a65298eb8ea93b128e69ef3ea57058da3fd1031ceaa417ef3d6a7545d76668608a650444e48fb990cc978832e802c8ef6fa533af954ffe72e711f5f1833d5e5587bae76784f80c70a02c412cf1c62cde35e9ffe1baf3bf24726ce48eee6b7979465b704a98e425e16eb5f4f0bb6dda445c382d72af2df11a0fd57f729217a0487c4488cab6b6ef93e1d07d9c1c6c3cb61b61e362542c29e2a5b80f6d60a0c2ef5de2ca7167f2dd9c7774beddc1ed313714ac89a0f1e82527054a8b4eaa39b284dc35ea6037726a24a9e58af193143792d40054c69d0b74cee53726fa5956340a1be493fc323a06ab3a92474c34b3b5e5f8129f31497cc4804e51c26a470cebf90ca4dc579448d03eea4f3555ffaafe1b6b3afa98652d044c8777bdad9e959881045f8c4ca9649325ba9bcf604fe7701b5267ac835b0ce411b994d17456c59220044cdaf915269af05889bbeee9b3a36be8c1a61a4941c2dbe0514c322a419a4944f19cc8a41e88ec618cdf729c4df6ce5be769cb711a88927b88c792c6f6a430699738b1e791a36214f98e3e809276682eca6f9c89647da6cc0c8eff5a19383781bee8cdee78e18e060cb99f5884b4a0b6a63cc9f496ee6ae595ae876ed0974f16c25797ed1331155a565dd9a5ef0533b0487c3c7e6587c6d0f84637de16f8f6b2c50fe8e9128f8e9e11c93422a19ec7f566087fb49734609ba70f2cf2293def9301870decd7056b0dff74815c50ce5df227613538ae5908de85464e2e118ee2d8a454abf7f40efc601f06679c062ff4491c5bf947ee92a3793e88b1a504faceeb56ef6df2221b43cb0ab27894ebb3fc2cc996999a0540e2e32fd5e2cfff3fe2517d03a83458136b628e44b47de8c1fef57680936047aff557b7e527ea38130ae9c67deafc7095767c22aec09e5c110fdf93ac70d63a7a8736e165d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
