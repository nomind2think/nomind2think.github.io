<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24f7acedd437e21fb59f1142a6e341ea77dd29ea0f18059bac5a95274a691ed226e29a884ddb75629cd6bf9f6d2a88dc70b952d522df467ede02fe76a9a964b0e475c5af12491b5d673f357ecf4a904589159a28fe7f1640afd0475ebf36588e0c9ba9260c5a55e6a431bb6f3a43abdd1e84ea6556398b47877a66cd3fd0ea4488b448b58f9edc063dad7436bce694306aee1f189f94bbe3039e3da2dc5fdfed068bf847717f2cab40621743bfb154cffdf0106ce5d174c4a1eb08ccf4ba4303334c2fd0470376a3729b8d7bfa91c0fac8e0768b57e04e96de7434d4e11bb2a7022b9f01a228a032731dcbd696927c76b847909fe00369dcea62d20c124ffc7dccfb7ed5df8a84ccbd0ddab6f1dc2d1216070d6e8d92f966852ec4912c8a32b2b8a64d9fcfbbf98c5904926f7e377caaab99104c5b10955447c12de1edef950f2c8290a2689ead602138c8a908d858036be226888920486b1c0056a50c32a61b38f6cc28be3c7173b32d409dcc2075580ebdc44bf1c816916e5a10eaa128f44e21282e1c559b21736d8582c6f8625eb7f24e2741e3d527703404c4aba8917eaa7ab90a9f6f2ac35515c153c4c31d3ca3ac7aa67fdd69803df55874e6263196ef7f788e9c602796995a179d0a8c9abb7a39a9af18e07eb1d4f9f018a96f52441ca0a374ae5dca60c5ebbbc2f4528f8a8b60305e0aa638a626127483a6da34662deab1d500af4f542606edc8bcb217f3c9e7f4fa4342d50f600493afa39459ee10dbbfe9d1923ad5d43efd41a6889a2ac0c6cf4b8cd84821c3ca1f3e052f8fb1d46c71880e51a7465d9c25cff39d0a737f2cf24370748015e089842ba70c3bba4b58eef5b384ed4b0c975ce30657c7bcd546865f021d4fcd87553839c54651ee670fdd983dae13f2e0479df66e73e9ce0b4ae776528c76b14197fb7427163209e91cb70f2024ca58e440c33c8d02dd3ed83847553bd779fe7f9b8c4129ff98d22749fca7cb9d7912e567953b1cf3238c69478b0ea65153b5838523468dc38dab0d7b0c0ed1ebd336166c1f9c71642e2a4edf0d4c697ae117b5be1bf13aa4e33e5b5790a8b58ba9da0996f8a08aa71e21304d52098c33dcd8c06b6b36fe2e997a19f71c343a32001b28f7fb6573f1a9726d724ebce7dca54eeb5d57bf6e1043edb7379a8751f77c7107022419cdf693fe17957af6e7f8001646b3ade1064c511cd71731074eb27b3adb506435a9e7cfce375077a2e4850672758500bafb5514194e65eb45b963e524900e8aedc9f959e5f212e8199be3044668f7230c4994c38989bcd874ee69351be7a8849696cbb893b6c2e1e45237a054f98107797d00210a0915a116d7a14c682be6a07f2cc2fcf6c41fc6c4c7aa46aa07d54adae333864113e5b5ae3aaacb6989a97bf958b0bd8b8ee7afb33eb32dc60fd03da015be7c495a6d90c87dea344b1bff4d48f6a5d22faaff8699e881bac8f9c21ace0b87d337dfdcbd12366097214b7fac92ea4b1396d9c33ce5e52d7a5c08e0e708eb77ef64d1fd7495813dfd1af4d18f8709baafc857f45f3a99a6a28a04408c982026ba5b50d81b2f17362caf516bfccb88dc8f163abc88aa33cb9ac9bbd9f9644576d053bfc4373c5db23e70a21d861f350cddad10f7fc965c6a021543bac4f88c99add9654dbe27a858362ce33f5e57e5c1ef000ada5ac165374bab901fbcb7d99aaf6a9ddcee3251ffcc409d8e94d7b2a48c758daf17fb4e5f0c58d5159afc270f0a3f4f67462eb3fee03e66ed248850411c87bd77745eabe1c8f3a2008afca9052c6596a4d9a90ce35db03bd4c349877057bfb07b57bc2ecde8136002b486ba5c87750b6d794056a9adccb103476dc4bc3c3fdda6bf100358094e2dc133d05f08cfe0c45261869d06e2067c90e68f4550e305e3cc4767458f7cd88f27f180d4b249dd2c8509da4d6e27077109453fbd908d23b396351d72d75e40d687a23b72048547e0f8531c085fc02ddba4794745b7f1140aa48f115df19a2057a67aef14b4e9b14a720ef677864c3682700928e2f5c5fe5dbcde3aa14a58abe80459b10f54dffb5bd93d09f6e018e8d913f3accd5937daa47746ab906cb57d0e7db6ff518252fa59f7929ba294d71a494d8d2a65339916f3b06f95de34d4281adca27a4d7248d7d37661f3809bf8d2f7c670f0819c5703fabb8c373e30387d146e2294577a8928ce47f35efc7a4eba6704e7a82c815c6d6b49f3a3841ac68b550eb13f41b999b01021a1d9ffdacb2e8d7dadc8c65fede903715e606cf576d594fd6949d90d2e35808a2d16eadbdf8f6746742bb88e366bbd7729621f2f067457c276c65f873fe5ce85edad81201eb8da9c0180565953adc6f5fab6d1abea201947130e82e26dab7214cde73b400ccd4014a92a330adfdf0e2744e10335e4e98f38f25b6c34f8ed5ea33184ae664908dc274d44adf911a49fe83500d09aa5481b4dc1ec307f803aa6eaf159934fa23647ffb3d3b34e6141c21006db505d6a5aed0ba67b1e652aa3496fc3680dda3cf75093063491840f1ab177a0e72f86dd426016de9a1e051683dbcf70b002104ddb12a4434de0e9ed35385fd8fd89163ed66cc0f72ec9e6810ba69eace934ef39416b6831eabb8c076152060bd79cab1dbbfde5327281d4ff53ce013faf2f687d76313856e1d9f941e6732b5f8ea7136b0f664a7923939c56a141c47da6be24c9ef422825415a485b2d806c473d8b53759debb869e4d9ffaf394b32a318aa5615a922cc47a6e6c47bd908e81343f8953ccf67617f5d8b48dd8273735a4b12e1ff6925894012ddb7dec5d5e6f5507a4eec4155783783d628f0e3faa97dc799131a71a2c7614e4c33cf42cd7053f59f9e54b1751c151a39f9758b699d81b7f96bfeb00b9842694997de3697672fe5b746d7f17e390ecf3f3a35e1b4de9443d61c553cdfb5b6bc3abc3f1133796d397d8c11ef54c13dac7c243cc2c48a3aaec57ad0165f24975d76c63b9c6cdc9513e424957b9c1d34ca70d24b69d5322f12ec04024208cf7d35a0e6cf07659b0987aee3c2810aa180c99372654c035dafa25a37c1218b0a67782b213793db3f699328693f37cc9d152f92ee4e94ad5df2c567c777e7043ed360ea6bbaf3a7301149fe59691a66b052af39e7273e42d7f33eab4a5cf860dcc22bdbe0dfe652baa82e60e5ae3e2f8f4ddc4d6ee8326b485fc60dece711d8463886173ae394afad5e3e68ad23fcc166930cafd280993926cedd39b12df56127228790c5c6cf43e366ed09e4a2e2011de02e740d79615efb6d82d9f8cd5ed5c1f38eff4ad3d5941e1f0b0c877f3829134d2bdd301b49f46ab6d4560af1b9d5780164649759fe9b42c8ebde3dfc885e2566df14ceb3205cd9fa94f584260de68c60330930a9871a4c929fe0bd65e3aa46efba95caa916ec04ca925022bdcc5c179486a352e4d623df9464aedf4514c48a7ede1659ce0a517c6d5e532e02e56ac6a89b92ac4fc3bb8e178dba808a6d8b42058979f7a2aacd79e4a2cfac67ce19acb6a861f44942b8465afc6513f8e6c2f17a2b0764ad14e69fd02d09f490467652f0f5f2064690a683a1028bca4b3922cc85ab2a901f1d1741d0ed6bd2203f47f432c6b5ffb516aa1cfd5d6ef41aba73b8a027637e69367163ea50d9ff74dd346bce33e58d2e98efd8508a5c76f018f1aae087d95108217bcb66a0ad1acda93abbc0b612d0cfef641fd62a47c362b70e53abc84fb8923f116d93490be9ee976f8bedc9173dfec382e9140a008323d6bad9f7b34dc62534fbe14a35388f6b59780ad568f7dd59a83e1f7786e1c0be4c659d3f6cb1735b40f862c6c72ecc08b404c0abe0d613980725090c68a055e424e95d7f4b139d322b002193de66d0ef96e3812bb41a1957f85dcbf72cd4eecb7f939da9c257095d6ec117faaf88a824859e69d8a0f0d827eccb0a111f254d28e541956dbba0fb655e31fed6a886b0bea72aa4c68acdb903b9cd547653adc733626a486beb18ca7addbd2d30b7a0052bcfb4bea10d0c1aac2df2f41c9436ff938880a82699c1efd71361fd4368432daff7e9436d698c4f74df5a5f2701b41af9db6f2b70109ccd4b5923b56015c46549a71872619b6e3af9768785280b8e191f881d6f5a9740e6ae9ca9b62f09e2929fe0fe645bb69681eb30d1dea9e030a203940b2c7d31cd0a87f2e7010b09359cca932ab68406d4c48074e39e0e52e0e80b139d9ca643d57daea7bcf174a5f540bd48f57e03a247d152ecf4b0c80777d00df56c6ef612579a35645e33cad525625deb08e4c11f8e3b1dfa3d6837d83de554d8a4af4a1b06dcef4f8a9263ac235058fb112526cfe52624ed1b12da0568edb0df9615f9181c7dd2f7ed1d70987306678c33a09fe65c71e3d589dff394e5db412859fbe744a5b8983e20080ccbb0ff68d695e23e6afe85f38c0053fb4abf0d4e54a91a3b5266dd4487745e848d87cb034b6b30e595ca0384430996abb7dfbfcd91d3fb7cf5de6dccb01397c1e6f3783d8f9b5363d278f43b3dc30d480a3a0695a883c90e5a6a78be43588be1c569646d6e10a87ebb6aca3a1eaece5f8e68d0c0bb31fdce22a255260a0f8476ad4475d62c7a4d4786751932e99c4976958f3f8fa6b3d39a3f5224c581cce837efc355f0e4366e4f34ada00af136ab177a5c586d6a094af27fd6e4cc16c166fff264c3a143fb39ec017e873348b1e82fb5fd9321f6b1ba3ab547f6b3a0c6679d02a5c145bee77ffd6f60b535d4e3b3ac3e75d40be4d7fd19bf41a6bd6e234e60193e6692b36fa5036a465b579a13fb247e5e4450643fe663630b194e83b59b8e1aac51e6da3b6f348c5ba4a6a829b8266538b01db94fc924fa7e44b64d60692f4be1cdc9009ba98c15ede50e85e09b67d34263b25c0f5a3526ca18731ad073d2c5d6e070d0a503c85ab78b81c20f6fa7857d36ed69a8d6bbd6530d7416ccc5eb657411f4ea3d788b15707b5018d587738154c3ec78cf89230b1a92b2ccbda87245f7a11866a1f146ccbb35fb19ab1b76a5b667620584c536cd0c98967107310141b142620c11920276cde0e702b1bae3fe2068657577becc6d66169b7dba06ccbecd1a863ea64c68f05a002a7d336adf2463c2a353d031e0add890108748dc79c60ad39bbc4b6b2820894a410ba79e2e74dd7919df853a4c575baa9b41751e4f74840ee715511cb18c07d1fa26b7921f99f949de488542408b7b4b458510c92b75c480d411cf6ca556c37208cf6c4d9dd1741731ef059d962629f693f011db7fc3101c7d98e5ab50aa6281dd201c37232ee1391a53e86c101acc6517762c23c544f2235224d49b64c609ad2360a96aca7d5be33e01da6e94229c277edf2a639a2dbe7e04c19ac6f4fd024b8d8e8ae1abfc6e7c4c1e3f70fb42d580b53c8242eea8ac7b2f875b1b4836cf637e50c7fddba73b084fcf3e047fc9f3ce84ecb609044f426c23fc5e9f09d1cae635a063fa6fd46d95594d5761894e6c450e57ed0d87ede477b7ae834a1e0d2ac137259c126fc091c049fab99326eee1a8bacf006ed8dda0efcecd225cb4915f0f78dd6e4140b82ace467166cdf012d1b0ba9b717dea8e4a2c576c217762dacdd8498a369d96a4dbece6438341b51c833ce2d483502923e4adb23afce1ca34093051d53b73edcf2a4e7e9c2a64ccc802ab6702797e66b185b89e86560b3a6eb31dd1938d986ba5bedcf618ef73f30426224ac82d12d3a5d3f04531a2a3fdca12efe67e5496247bce9fd868de930c3c0d2e59cd3ce9bbda259ddd5ff1a3267789f5ff7f752ae5d937c479e782485d6bfd23548b371e0db8f98628412d80e12b6575d61cdaec9e69d044feb264e42145d10377c40aeb4303f63166484111443f46b7e59c7eca8b67db07115a7d01f9dceb42d02356b39bbcd33343899dcbadc4547dadf51ae570ca760588e3b663773b111fe397ef78280fa0f58d11a24a93fca90b4ff6c20fc1881bada8a656ec796c6f95c284549561b446ae8a7cf18722aafc8c0e8fbfe70b5481b88bc07930f4a7e14238fd548186fb9f33d992b8f6d6ee067a88b8d316a4fc36de20f0a2e6355e8c744d14a1bafb694949fd6086b7a0c36ef82eb206493b032d48b470291c2566a67b2695e0464a89bc8cb38be103a90f19b7405988870e9091ff2829e5af84fbb90a844288baab55b2de9da796885dc44181c45bdc72fa78d10738dde778547a7cdebbc8cfe418d4d756cca5e3cca59ba950739c8d0b3170b84566d69b350b573bd44eea2c4c6ab72fab14f86bc95188545c79de595472bcc4ac4976465200e93d6f89a8949a0cb22bfd42cf92a16dd8dc2ce228e13af15d1577901a561c3a15c6a733df640064cf88da55952e1fdf4a3c223aad3edc4bcb8ae9b8e209c7755413eb6827c49622ba060f0e8b6fa60d83d811506d2902cc24702aa50a4d2bfa3266edc1c2d6738df357d9b0336f3169cb0913e94369c5ddd360894bd221fdbc3281b32720a1f47ded3b989a12350a11468d87bc5f19373c0362ce533ff9783c2771b761f0997364e283679e5b4eed5f8b37631ab2157309c2590fb9003d4b80a47e121c2e4c009890f7a8080cda1e8a28fe1edbaf318fc3cf5722c95602a02e600fd46a0fdd8f5af19f51c45672a77284c8fa70422c2eaa809ca43db329d381e0f2d582085c63cbc9e2db1898f58a1b22576deac91bc1294d16a7b482cef3f4bb48111b38c838a5b9337b8fe9d447523048bd98dc731b6fc56d9c27c92b8bcb706b83550e2f09d8437a352d454b1d21d6e088afcdb0ef5bf627761c395e3cdefbbf48ec046ce2f2207dfaf3c632efe5fb1276eda5964723e5e07b00931f50a8f2be1d887bb068594b6c35ae1688280730f024273cb06825e4d0405b5c708303b7c2553996344c1861d3ff859843a343ced02154d7e5210a69996fa292b752769251e6c989ac9d0b3ceb9f3dad03a372b551391c3d2d9666af35c020a8a8084fa8a70c5518bc5a0d669cf547cacedd228167e1177a42e8170ff4a3ddfbd0721b19b2ec97031d021a7c790f6f6781f7c4a3971450769bf24976ff8dc9017d82ea08f41fc39b2dce998b5f1c75099f0538945c40ed399a43621604afb0bd33744e6333bf09a1080c1932d940fe7eacafbf8dce4983a884958b8ad9a36420fa1efa5a56933eb28564b88687bce95b4c018e2b375512de3daefe8acbfc033758570dc6a6ba97167243479a974f81f36fa9087673dae0eef9e7770eac1a4b2b05529b02e7ed32698f2edc75a8c330f5cc904bbdd82e9edc97eb11575d9891384eecdc74b06d2a40e6e98bbe5f94cfb5c63a2d0a3089e0ef9810bd7f1560493fba4d35481e989ba7b018aa71b97640707bc0c529322a5bffeab2ddc85910d58f14d0c0306f84fa106b7fc2da491b7a1cc2e97a144772937cc48c097d6e23b6f03f443b8101a816edabf410105453f49be1ce6f74a8bde849c18e26b51962e1354544ec06d5d569292c944b5d5fe2126bd14e9309bcdb029dcef91f100dad4ad653807a7b79ec4a086e89bf37a3cc238de1cff7db06b07e2b15d9d8fa7b5aba31f1d4b9d58daf48f6eac8848014e93d95a24d1b08aeb02c1f16afbafdd0bcc0f5981a2d2d1b185cae7c9a812e2e5cf19b60d653a01a766b2555de63ad7af02cd84346db7eed254512d93ac044c26b23ee25925ac7d326397103a143025e5bca5d8ac1c4dbd89c81a2553b69cc88d01d445361886acce2f8a5d4dde327f3ba29ae9028df771c1f410b2e6175f1d14112d18494528fe64769a9509dacc1c2834b6487fed3fa95dffeeedd65963d36539d9a955596b7b7708e041030cdbbfe35ec101682cd45ae45c7104014aa0950a122a52248feded07c3adfafa04707f69ca44709eca198f11c0830235a9792c4b2b6fb9e819308396ba93e6214fd168162966f73780e036aa7d4502dd835663fce89b37ba5ca6767f807f8c8004aba73ff46250a314868f92ab2f189f0dcd49228d9a0febdab35069426fe35a571bc698f22afa39e8f11039bcdbbf029d939bb3d35af1973cd92f06aecb64b4396d1c05b886d85fcc07cee29e17c7ddfbc934ce84d68a0a0c1461e8e947244684b0c64829cabe33a1e079e821b8488386e1933319c4586236f9344f249529f1a90a86f14dce9bd5c896874864d714951214aee382628c2bec64516f17995566b9c7d6088d2d976ace23d2abb42a026ba8324f233d6970ca96e5d7dae9dc9cc2b16d6ec9cf0807eb21b21ba28e84bf4687d18f7b49fcd5d10bef6cc80ec7c9000051b2d7196d529748295ed18c787dd2f097b899c4555446e103520abc97e82dcbe612d0f738f679faa19a85c1b6c7c04af9eea6149513a65df363f22520e1c877f3ff1bf6f87537fdae8618cc210c10b210041b29323796270ba3c808351369405ab99d03fc50e20c54546686107fb41bcb3ca91428ef003b0cb7048a28b1b42ce70dd1b130ba6cdf5bb39895c071a3e12652288934ef8d1505128d50a7789fa9e36fa5de095dadd43e4ea8b0e1bb5d30a2e075b458de0aaaf349e1e491ed762a02787aca62f1513908fb47c5660a875dbc0e25d414631943bc0c1f05ef7351d7e1e93c7905af783b206f2d8fab27e4e9294a5d434ccef55375da1874269ce60f04bf7753af44cd10414fdaeaf17c41477efd7eabc24183f8c25ef7122e8d36d2f4485e443d902778a013173211b67e9044fa0b1e15e8e2f9fd3d94c2d95a5d780a3daae16ba32f1a900e8f95c26e8b945a96c55e7a22b709d95e7f195afa86d10006113dd8f293e2a988662d14008fe5ddf18e00d6b7d21080f7819eb1fd78e5b53a042b96199c37b56abea113f5782e5ce7f2c4b5984ba71fe5cfb4133458771fed386a75d9cbe293b23cbd8bd56768b7b6ad7da49ec2b702bc81be798096d8976b9639f39944a3e2460198349e8b0c4857f20e6a725ce55ceaf17f51e0e32802863b362da8d333e59b565c2d446f957a2f860d06cd8be7945c2e86aa54b7321d1fcd2f25a708ba89664c24e74d67c1b2e19c62294bf0380e1193699f10dacfdd78ddacab23481044b6707cb0641373cecd1c59218ab279fc9351346d881370f6d119bde44bd1a785f8a987df505b0d31f109dee073d3c32fa95d123475e0ea62d95bd0f49906597daa7ae794f6b3ce12ae6a756b9942a9b7108d8061ade68ec6e5b536f7cd39bea97f5099ff25348614e984fe12312a24f18ca43436f78b115ff97c97e364a0b0c680d705dea54857df5202d4fa0a49576c302a209dc8fbde5d8534e72d8d5437558efdb874051fe7870d8a841a334b30b47ba25d8eac36d4f1d387f74a574dd0602092b3ca5fb61d2cd8e6df81ed1460af3f9182b1fd4916ff9c81ac73575e75856530a309c58cf6cdebeb9cfe13a5fe5400cfb4cbea284c88162de5f6d611f1e8aa913d1293ebdafbb72c3a8c45bf1bf9d15dd9c058336aa2e7dff67efcd7a0bb78b72d74833bd63788b768a97c936612338adc8a6a84500b90f30edd1ca77a0dcd4c9d2231dc4ef6898d6d466bc5d666498d79368564dd88fa1d277a58a68625e54df57c2084e27f0152684a1f8b2a77af1ac560ffff66f31ec55a94dce0ff84a00aea2020c8aa19b7fc5a01feb588c69c33e10647cc58807ee4350d5250f3ea07105ec03cece2be71c705bb5fd56ee935a6d36062ab3ef3c8833171ed99eccd8be8341be59af4da4b76ec618ee784c5b7c4712fb182a03299ec1e26edea03dee44e02d6ef2c0a1af41d5ce77aad948eae86533f3e974ca941c1ef55281f9800698c0c4f774b50811a5f277ffa01c751c423ab6e9edad15e5b545adf348fc5df3d30687fdfbdcb29407d19864b3811a603dce8f892dfc6b2560ef19cd2d62a4ed231201bb4b1a374152dab4f38fd66cae9f7604bb2baeff74dce6982c54ec33271474077ed26f575c8aa33c91708ffc4bb9daa2b7d66dad956c01bb0346285338d639437e9e2d35a9ffc6ed9fc07bd30702a18a24ecf95b8c6e052b56f9aa8382b28dc038c4435a568aaf2104762f1f1d6667bb2c1396854934c3810962da18aaec64f11d92c7607d5b28a8106eae710cb65f330e0e5642b12e8196afeac8e3f3b3006866b5cd072e76f81d4e748c693f3b256e21eb6007dddb28325739fd05df13fadfe2200494c5070f8c8b61171f5ac50d8a43d29dae6490dd5f1765596e5fa4f8658a3836dd6630cdbd0f854871db8294cf866a054fbfe1a6c5e04c55d285f975ddc0ebebc3ecfcac8d42fad82aadce1c71af133d6b66bf5b4f0e7ed0ba68507c39bcea066124d7d9b40502143013798755b5c61ee235bafd1a6e59f3cba214a542031d26f02de7714835f42c1a008c96552d86e969d76684a7974f9361129f05bb481f78c52ed7475f056fa247bf80ee06157ea616cadce36ed72b1cd7e2e302bf48f5a45d0cbe6083aad8a0f7758b9e69943eec715a084039bb41cb5e6920f9f44963ef1e6b8c705b05dd0a4c15491add8cb0b3e3f7fa0a56262008e0b2a6cddadb04413d953a0421cd98c961ecd2f97cbd5ce55ba5369333bd138ef4fe534bf826a8860ab651e2dc05cabef7cdb84101e707d12958e8185fb9b827001cd833e97281e96b75b476ac33fd6f075175cf9fc155a89c68900695c85fc6baf24c4d9e1d0653e50641a79bfdaa9c7802b40aa88c2699ec28e3afc00548e1478dee8f3454756f0e43d35852129d5e8ad50b9b9ee1022373b7e0e298143b383024e7b4570214a5a5d1922ab2493756e43ecd1e97b49ca0d6d7f8121c451f1b2e0003b04fd1b150ee2b8d3420a0dc51b86aa9146df2ff6c3310406fdb212bdff6f8bbaa547a3e5188b04eb0fbe2a8e533561b2dfe41a78bc44d9870add47a07bf16a1c6ca8ee8bf5c560eecc1f4912f08133e696d3eba87ef4e6c8dec175de00997b11a35c5aa8ccbb7974c9dc773591abd6864adc32adaabc64ad39adad12339bc4bca0cf656c41413015abc004d46c0ecb978bc9a3d5b845b500473f827c70bea61e0e972bc2b7440c28d40da0087b3f743e95d73723a0743ab8ed97eae017d8e8c0f5874a626c6c9aa608a3ae3181c9a558c4a34982db7017554074b7550e74306ce40caabe2c0100abb1d0d270a7d8f038f6efeaa18224747ea11a18757291761eb31d994e3103257510c1cab0342124e9e681d58717cfb14303d709362dfa2fb6da8a847c3785259e4e84c7ce1aaf24b9d09a579c8ef2cc310c65832ce3412cdbd6d85d9d710c266aa03436b66dadd02b40b5fb26837fe7bc54c9d67187794da2806e1dad547289b9d726c0f39ec47b2f071cd5f9adb6a69c24b26d16519ad16ba58611f94dacff863d08595176dbeaa7bb2e750a629a7a568a4700da1ca8a257915d614745100ae2d6203055177cb9b7687e000fd99434332d7c6107b339c95c6e2b70bc48ba9115c9fba7e929485c683c9764f72258add0d976f3593a57cb516b916694ac923005fc80f9b1f6508b360f3eb925c7fd6859c61e52d47b5f8cef8c5616559da4783b0933ab037a92f40190daf41b4e58b28e4cda34ba3284d949a02ffd94f51f1d8d4c79b6056c5699a0342ac3dcba0c186b78cb4fb0e7564797ef77504ddf23d5edddce86bfb29cd344e0bc1392020929d4c216d9b84e644b8c6825551d928cfbc5647b7f5298660d530017cf5c5e14052478f2c66c318a99bbe47248f70b21e54a068fd6f39fa5673198ebb0a54a913fbc5f342dd053c79a00709bc94a4b6d13685bb1440c282df2edf3d000d5551c34216aa2fd4c65b9da7196f621c1baf1fc20e564709d735b3bb40f55b2b297f96266bbc9802ed7ca7e1c397e82f3a120b55304e9841117943278872616d1e75e256df73ad9f7b8de0c63608d1bd9c6ed98d2dccaa6fbd1e8aef99209ce0fff59e62eb49c6fca62ebe98733183dfe8a26ac9e47eedc2115d59586d68cf863599583bb71ab2b0671a04e0a49138e4a346ed1b009998c721c16e3da0e1cd0e1dded29a18e95e5b1068f50e551c8b21d5c20ae6f35bbc0cf5381518ba4f013706eaa5c3717de70c71e475733e588f2cde8b669db2eb8e74864137912908b6e0b3317c9d798fe7d2563fb1413eb41b93fbf20fb9c0c132e973a2cc636990ec77b2645003752c6ac12e2180ca328a463666fcba0df6739b047a8f9374ba291110cf13d575f88b8a1a501ad7791ed76355f81dd2319f2c8b2681d105be44c2c37d82bc3d09993180d3938dab038962298722f913e009600192337026e74429182f177ac4037e5375f0437ae9e27b262f0ffa683175b1b5e79a43f7890ba15d9587cbef74f94289af9e98203c221135b7081b050ad9f79f56d6cd850ad7c7fceeb8a3dcb8dd710f02207cf5112eb5be9b5f9efe0d046e52e81e1e33a700506cdcd0af0b4ab02147b20d3fefd56da482dbf5fad40091bb0fbdb6124813bc612573b46e650400c20a2290c55eef0de5e0a22d15e4509dfe71da10df9387ef7fd076a43b40902fdb723942be7670a41e23b88003b53cf46bbaa23a811a9bb773f56597c3415264e8720f1c59ffd4d4695e11ea23ab6598f16224acc6a0b430533d85bbd8368bfdbcd315c39d3f3856af43d945460a68960d2371e01f8334877a24618487b4d9943e96f1ccdd0fa94e8f1f2a12b8e488e3bcfc58d162d3e2db13d2f46047f8b0d837e9d663c092cfd60038dc8919715fe64014c2dc25c486295a17c3baee0bdff87f8bf5ea506855ce1e2255f1747b09e71cc9f8fc7480c0c9184120e84b6010a22f7b24e9a06df2b7dd1bd5fa713a151e15c16e522f56cf081748a82b784863615cc98a357e9ce968ae53c9160a05eea880639cd15c7b7d175771c26990461199f35b68058ca9de3ee1bc10376a0b1303be3412a5eaf124ad2a360cb7d43ad7308fdc0c17c2cb41a9c51239daf3e90949a163747d068620877a962455bc14723e5fff3d8cd08da58aad0b1dcb440452d0a3d86dd3a677f9b3a2f3a7720e11a168ca6e3f4e391b39b711263737e47dd6dfc3cfe65650c86392bdcb69d9e03caa04b9997a6f9c108c7c85886a306e3e7cc258dc0ad9b2bbe0b7b2ede6fe819fd6ac40097e6fd6d572ab6d1455b06a4cda1218a9dd7e4a7d2fc14f91d50c680a9fbfed21f134aab9d51bfbcf2f04a40357257d076ee27224b0e0c26083a1bcea6ed3c0a956ceab1d371cc0d18ce9b505f20a4541719241953d78352d2d715ea8cde75c6f7d4e2cfd6fc3c8c25a00b78e54a83fc65355bc677d69cb5497e77424dfe6ce82f3dfdd7d27c5acf69a5ea28e75b65afd2c015d88b293f408cdf1fc8dda0534a5040fdb14c15b6edb69a2e050a65a7231aad14cecba33025c38867eab3788626a88edf09a0d78b3e68a47e3e13a9ad54afa99a186c158b82fab30e672332b697fe576596498612b1b17debbaf115312af602201a11c7508f784cf4b82c0e9a1b047d1b42200d6ff0bf5623b1ad93c19ab68b7a4c087731edcd0cf9dc6ab9fb321a57a0132a275ed6d524fcfbb3af26d4518e0c0b7d7bb56b725776818dabcaccca07ae677eb87943342f3c11ee8e1317cfdf590f975c3baffd1ef5795848ccffa527cb116e46ad6ace20ceec911f2c40e86789d9d5f241e404b8367936291f529df392f9cf12d240fefeb0b9b665cd5c2f2fc5e7290c8ada22ec14c3631346ac4d95bb4eca79fd75c136452367ccf98235540e047e59a5451a2716ccc6eebefe94b636ed2f864f60422e0c7573b404f420d1b17430eaf59566a9162377bf430f3973e0f2473e419bdc4838a88fdc1662d74b64a0c0161d21962a80db893f6f4bae49da468c196c57670be0f126a30ebafa3c89a6cde4f1f7ff0e69bbc2014194ba538751fa63aa4684b12daa8a40fb54a3a762d944fd5349d8145ba4d11d17a29203edf610997bab4aeaf802732a2bbe2a0921625a9926b4833716466cb46bff8ddaf87ec92c176c5f39b086f35c5fd87b77db8712b7932acae278523946a2361ebacdc72a20df6e99882ebbd1c8b85d92da4f4747014d03a863695402a3b9d89b7c344c98207e6fd56adc18d93d6047f4f171f82e997d88d83fd690402b0aa53e5581534b9f84dbc33a9179d8406179d8a00b106b383d4ace273500c8ef6c840d56c32076063dd49bd5668152aa6532e653696876ed297be9442b9316c5938225263f8277e39cd3283ce30035ce64a64162c6b26bee2729b298f12b8871a388af6af079e9f4b49d3def3c416e442a555181a0b1a89383a925dc7faeb9b4ac675d8f241c35ddc0c8c7d796c489bd64062da06fae753b5f7e45dc445c6ccc2ba00acc1ed69bc355515462ace3af34f990c5235c6bb9a70bcc2b29a91b0ff30ba1ac05610990316074ef8d06fbe2f6048be636f2f2ae01c582bef99cda4beac3b398a3f629f7785bd8892cc8362c236589181f34dfda6f8b4763277b514032cf36a1822a112be0b10613ec1992337c2cca7c38a613382468cafae86d0cda69afbdafb316cb82c17754012c5d0ef38ff8b18037f09bdccf47b81b4a030866a1778500569fa462f6efbe8fe61d0c28f56e1811e4e115ebc9add2c472f2a8f4b49e41c213e4eaa3d6bf2f7c525ce34a053e8d59e99ca758fc4bdfd7299cb42ab75803a5b742514c3eb7619946e62db4b5b35749df4ce04645416571cb200801e8eacc4fc56c65b4851d4525ec30c7dad8d7fda9dc90d2a055d20f33b6f2d8387cc0d80d59fd91dfb90a4bdd47c8da5dbfec259bdda5c3c749f7004ccb4429987aef335e3c1b116ee598891c201bd94145f3a2348e142993f82df32de309c44d4868f41ac979bb57da87b4e398a45e2bfb8f0328cdc6a8570aced76c652aecdddf1087051b7cadef6032690a062f4a29400127399dfb1e71aeae985b5464fe4150d7dcc87235e07b356cbcd936128043b18170313f0ddc681ed3cd232932b2248588daba7cbb420b06feb18834a62ebd2c6d12dd1ab4d88375439a0d89b8420ca0e70b55d9b540b22bc64bcbca2e033f3a847bbc744caab49e92dbe3ae29fd1b694e7a627b45f0c861129a918639b01e71a51d64aa268dd937695728c6b4d3d5ce61c4da1f734398be970b46007fdc8abc7cc0a9f4aeb84d55bd76e697556210e3b8521727202751924bd2ebbd0a35db881387c1088456cee87caae998b49896a1ca97c9cedd322f3a2bb0d915cbb68ad1032759aa3168e5623a736afc43ea68feed4c6a0ce41efd8d03813a5c51353fda0760759c2a0dd8dca9d9845fb2bf1bcf07eecbb759ada060a50bf484795e3a7fa7328f6b1f3859158293778031063c6f84086f354f179912304cb698043d5f7259b32959af78fff7550f7a2e5fca3f7385d5b7b116a63949d12ba4b84f0572126e0816aabafb10bba436f611e74dac99d420f2c6686fba138bdd340ab2cf3acdead4bd7f284d2262091e72c438fd3ed7dde0c31ab458984f7121ae85c7b9c8bdd272628eb3ea9f3385ddf1a552a4c302bfa5b9f1ac68c1535304c2ce9d6ea49994c7ebcb1e50e10d6acf483e876e8fd937c2b1afa215abbf940a25d7bffcb33dd53e2944bbc9ec3446f34171761f06cac12f628211958ff7b844b9f83b2296feff4aa721b3d63819de0d2c594ce4b5b2183221b0f57de1eaba4d33bf2723bae1255735833192b8b6d7a3400466fbcfbea4e41e5538029f40767ff55669af264201f00e72c618ad2ad82b96648e7ae0fce339bafdf1108ac6d3b8c338375120e0f21f73e1f7d379a222a4173304973573fc69432634af73aaa2a25bb989e14df5f49e231903810c1d4e8d99872ea3762dce5e3b2552df85fe96956c1b79a24f5438c0477a598e557ed0b25c4657027a09eefaf9aa348ca9447502ebd669c3d1a63a40764988ffbf507ee325815d92ae3fbb00350c3fc8c190831114bd839b54c5ec6d958b83356ad4021a8fec32fb0e13055602343052ef28dd34725504281efb71f0cf49e073c104280c32a421110a6aab3d3161e73079484a9f189bd36337f34008c8b76cfe956f7af88d4098d92c20e9b68aca5844332e54df2d122803f4ce5a69b2412c0944a2fa895a88fba0a2b4a6e926a22a1c20f24e353a74592d463c19498172372b9cdc5f9788ebfbc1f80f32f279686443359ab782e4e6ad36443bbb54218aea4cfb71651d76c3bc9073149345754d5f8e0344a5c118373c9d41c52073ec7732245b3fd6197598e767bd49a2131c829b9f0effdae3a7b63c45b6a8ceeaf1446903429f9463183ffa520d2f9394f2c77725d1d642cf73c85252e0a99499b32dffa794bfde46e28fc3fd294e374e5504c7b4c550291ce368c13d59961bba6f67ba3d75de0b5ae433e573c9f926ff74243a0fe33702973d76fb30bfe6367e2013909438b8f71d1f805f31c2742e065472d704e5f4e511ca710bc6da5075f4ef5c0e7571f1a1961d2f24083dc0f0ffdc51b792cab81cbd09c869af15b60045feac33d7e666b1b1b56463b9a6c6bd97221a9f4d7277e17fac55431e941e1aba3c9f0f788fb0acc93342d9ef1a8148a8904bc540ffc252d36130708f0d906114d170fb752e5f611a191b47f89615ba9b2cb0958d0d1e087dc96980869abcaa69432a9ea26d5f44971512a4f46e55fd75064be52f12fd3d7714b480d0002343fb5e25e0aecbdd4198b704d8fbb301f9e6881167b73b68dd5618744053cdf75acd4f728fbfcfcd1bbec2176212d5e1e80e77ec86a68672473fa30f58cb60fe97f4593db315cdab09bcda8319560667b27a0b8598e7b7618ce649f0b9d0f375e5d82a6661fce6e6b8374af2e863500b1537950a985a2293e1c45e67bf955a7c4e02e7c43b7f045de84163567371a6fed2dc63d3e580f762287ad55207f281acbb3d2fbf613475b938fd3b50117571d164dd7aece60be5e900e515881036defdc6d7d1edbc4a16c6637be13e1477452e02b3c09ad10ea1b39fa4ef91c52f0ba0397ac68a71c363adea0b02402b84f293b6411813a4622b1776931e9597307b716f049fc56351c5e7c9c8d42d414d85f7735984828d407f0886f22e97776af118ab8cff33349316b66de4cdc785ffdc18786d4181a0f6550fd68393951f48b20279972b7635c90e05a2eb792f46ed8ed9eec27d64427dfb07ff059469abd1b1e2cb48c6b70a1e970dea5fc806f491a1299802b3a38189d84634c5cea962560b901d39488f4404fa1b50523d6a29e584a3e83bceae74a3e3090d190736c13c1ef840651024003c6766cdd4714a33951fbf5f505a6438ecfd9f9032940111905b14a272af925df7e6e363e6fe338e57ff558dafeb135a3bbb949770d04d2631817e14b8d4b21aafcfb117a9347b3d4aef1f691d4418009f9cdd131f8d653e501fcdb5beabe9f8ef0d02181351c5742f35241f22be38dd6b34cf4284ee771a7508ac17c8cb00de4790bb8258b23d8095f93878c6e83229be9ef017fa9a0cee2956b08177fc58bedc7596009a8649359b0dd3f08a8e8a37b290b0eb9688e101b41ec42497bd06b630180a91350db69ef0658a4975037bfc4ef60a55c3e3f9c8bed0109ae1bdc207fa78389979c2da08dff9da9ed5264dfac87916d03212de5a871b3d590a3ca08886445dfa55d211917947a656f0d970a0a4e85b054ac6c3d9d2ae1fdbb3ec195d119e3953c318bf70f2ac74565ef1c0ab78aaf643998f18f9617d74674f4c018eefb74da5e8e421f629e6017d09d38521a59dcb3cfad3073136f213dd393752d742389a0b30d73ed20c7a66c52f45134f9c3bde94f3744789b4510fd4c203bcc93df1526f32933e15b5ab9b2a84f58ee08f8c00c49efa98eb672ea45b1773fa6da1b1770db2d29ec35e2a9c5165d9fd49a592a34eb2b5be7f6c2cae26dfc36cd5950ed56ae880bb29db81d19842a356b344a8c7225caa91de11d7fa256580fd11fa84587a1336f54960d4911e8546e8dae7f9c11c2962f869c63c4e5105bd5b2f562ab120385a596cf7eca56900e6e2814693cfca7a32fbd2498bc291c9c02eaec61df14ed85c968e905fe12888bc365065c23dae3aee82f37e81c044b2c116a4084a602461dcdf3aa181a0ed4021cf58cffb6c5e7547801878760c44be7e03158f24dec1687179c67ca61d4666fb57364995dea65c73b33781d7b0b6e0f70134d8eaa1704b7470749aedf4b61aba9780c415797538af3be7ced15108ecd278e9ade451155776fbe197a34d39003cb3b792293caaa41792567812700cf1742e5062467f6cbc77fe9614ebd48433ac3ef4579b555d4379424f6e8694212b5184fb23f30994324144a339844ae07bbf9dd6b70697a65d9a02b556b1d36fddab5f100e2ab0ba033036ad7235b0fbe7f2860c62875f0da1a506fa62ede5492caae839ed5ecb34cc35d035c1eb4cbc3797d6d388eec8e4b2ca52ab3e66a4c7ca4938f33ec080ce33962266238e64fe7c2d32057b06fb990669834f9491c5a1faf86aa911f9f8a2316f8aa8108ecad93d33167ea67fce76e8622340995c117c5c448193a1685b980af4af9b6d15b477bcbe748fc2d74d2258868b6cd0b419d7e6155f5afd4d73340acd15ddf96c134ce1f7cf01507fbd4fa191e74c163dfae6a4efe1cf9e79589855d7d8f67622d5d7bdd1ae1b82157aad08d5215823178da54869c9d3d068ec592adb7c801d9dbfa3d8de393a4a361f8eff098bc2f7115bf7c68f31a9e8eb3a5e82b00397e3bd5f9732ba62a85adeabd91a138011ed77edae65baf4bc379068474dae5dd4d4c71af20eb99f609ae2b16cda1b481500eb288584c6963515382631fc1994630cdb98cade6d412e49a05ec56d79f68","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
