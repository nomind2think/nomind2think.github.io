<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3eabfae9f695d41d4b5a17fee2c8d260e502e2db89ff764b3c4aab1d953c8ce8ad70ebbdd8de1918e35a409406b1755a0d05bea9a13965d2caec7b25ed64be1d4a7e2639a123234499bca3d669be53c491717b06bfa20adc936d0bfab53a81e318ea149ba3cf088bedc691012fc2b7f7a89de8c68cecedb8fb12cbf0e241a79517a345d28cf270555dcb040843012ba9cc82d36efe1f6f9e86f04c6ce0a8b6793125db386e7b38e63282256f4c6db1c7860c8f06641670073fd69614d7016513061906e99f438a152ef272ab95ec6e6fe5f9163a4adfb5c177c7382976581da19476d7c16a5e9af7bacc78c36432bac35f1baf97e9bfb46892ffb28bcad349508cc7ef63507a286f1d6484e7cc070d752fbb60c04016e68706a4bc1a5c25ff8971afc7638da995cea1886838afa2d29c37fe6b453bbbb2142d923afa0d7423e6c097e2bfc75c17c244b785c254d159413d1efb63ed96775001771a39d94d1a43c54253ff221c5e9487ec57c98d95236c3e2e50a84a1aede1e202a86cc0a572c78489c42b20ed4582e5970dd617d1167f311f780938f9c00aa430605a892a9fed036801284c04ef765c5d2df52ae242c93e54271d051d51c29d9a875f2983fae5f17af93340e7edbe0d6d207c692bfe344bd8bba48f1783feb4ff4b451d32a7d4a2391ebd4eb90dc58953780087adb25444ef0689dafe22407f0146310e2f0bc17bfd4f86ef536086476dc74113180fd7c6eb24b0259a5c5b86f405c1b707f056108a9450cc3a2df1d51da44e0d351e82ce207f611fe622fe1a18b0a8c7b7c82c2cc8d64666eb1ab8daf7a0a1fa1627f3a6bd27228de0e9d6b6d149cbf913628e2c3ee1894246e8397de51d06a95c3a74ad607307ac85ede7c98ba06a7ace0a888e575fef0a4e7ffc6db90cba2867bbd0ac252d08567e3cc7e804ca2369beae88784f5419592c36a7c145fd1b951ebac8c2146cd427f84b5b1359d4e9d005fbac623459175d5b1f93cf091becead0962d20a3dce5a698fed80b89b8998c554c1fcbe007d0f9f3292170f5faee6b16a53409c3cfb5e0350c7a45aab2e3bd691f1bc9ba23bb2907345b8c5b85f23971725240f7ced9f62727ee9a72f508a1d2bbefde2f705fc03ae8440303abef16cb86c6198a5b227a8ef1168fb907f341ca33ef48cf964cda1eea5bc010a49a4d17689b2401585b53ecaad05ff438cd8f349ea71ae4f757604b7d27d26bdb81b8964d91ee5e6733b5525a006d7406191584f9284fb5756e457339e3cd6bb91bb144947734129d4f87428997543dfaf5a2c0f62ae4272d29703e071cadc232dd3741ece644a02bc4159cad3d451282308754062a73b5220faa30b38541c188b703aaa8141b4f926303eb012092e385eb78ac118593f3536c8c93ff9f776d1be727e41f0af0de578d5912c2e9ace425d9c9770eb7fe60f4dff8d7e2e25e626730c5e008f617d3deb5dbc3a3c21744a1cccdb35d4a1cfd4e07a7bdface5950e9c1255e199d0074de28a69047d0b22d1fb6760f9a4b4eb705fde67ad25039c48d5f29592543b08800a1046a8de8f7cc1d18383508b6ce212dd1b6c8a1a3317d8ba2238e86ba130ca734d973546d15f8d22829343e4da104bf831746b4b1428e08f97ce7925d2e8873a0d434e84c6bc4613f6b6b9a058d4d9d88b8f04cb148370574d93971757f032ff64d045110d5d129106d804e7eb60eb262bddd306009f1fea3d7547c5f8b7ee42b136e148dca72d30a5fb8e854d9c788f76b33315bb32d56fbc893ee4ba8894fb0189abea2d1b62f3657054262bb28860a36293a16d7de6a6f6416e0e9b670a55890ef1ccb7001e38484eea87f265285bed7a2c3c1d3f5d349e3cffcdf943eff722d9246b368f6aff8494618cba0c86c9af1468419872552072c826b5b0ccf522fc2aa6212cde311819a57361e532ad7ef109f789fdd44278f7de612da53b638a581ee658e9a47de6c6322bf733fc3e5b7f143f7caaf2d7747f11fe033cf2f3ae70010d513afc0fd8d51e244cc2245e805204b60241f1dd290e426a45b0b090df342d6293ceeca63f895e38d1c242d78f235fc067476ea02547c16d0d5aafb68dae36efb76309c4887d17a644388b20668c8215d69dec56ab925cbf633ebbc208d4038fe5c2ad0428c5ce576c623af998a432e7eebf1579b0da9634eb7989915aa00feaa40a8f9f3be14aea2dbc05e599cf2d359bf85ea6a09c22ca6b7ca26768ff30148dce91e6927d4b47ca3a3354c8ecb89d462862967e610f80e1df9f62d7f54df6cc9d7e1ce5a477f7f93b972a0084f8df58f740d61259f7784d8ecec59eceb5eb16fea13c38b875bd512b8f32e7543456da210afbc452edae8664315473080a1e58f40d35a50f93fa3bb84b5d707c4e3e1240c79e77f99f993b38a5808388455243849156d42e9575884401137454784116db9456f95ddbaaa1e06d33723c5c2332a726187c640ba3875419dcf484e295705406ba037fe395507e50cd177093ca40a2ec6f74d39e8d5663c5e1a59203b878e7fb5a15b03019e53ea9a8434fa8a2885e72d6709d4e397ad0a3eba324e135f978c8479c3b77e0c6de993f6ed15c75e026b6480b8028850602cf5b20970783059779b9ccc033cc7d78b194fb434cbc172e40054ee3a5efbf57bf80abe28af9972b9c4bc91c9fbbae5558b928a14d7ae3421ae82f24eda7466a132eb97dae6fac97894b01d554ef6b0098f36cbe3682ef7985461973878dffaec0fecb583ac86513f8842042fb50f244817df2801ade67aa8e7d9699f1ea2593d2f7bc4e76c5a2595d6e3b434f60026d1689e564d0b51845366b5cfd71b6ab36033442429784ee77fa0f07e61d2fa0745b5d971985467fc8fa378e36d69caab23860c9c02bf36012c877230416a8030ebbf18cde6c15db8def18e0359255fd25506a6f82e9ee34e51f302f1b6683bc7bfb5049abfadad5e3ac3d69bf740a2a8ba2a13e8966d30e0bb2cf05d8b6805e7db644e6afdf704b53f965cdd8b57c447501deae2e53149cc1ac9f9a6747facca54186bc47e76f874b59b114549e33fdef7d80af6be03e895d4c1b73c11c4f33874d10d900bd6aecc09275576443547854729536862b17e88488bef0982bb1b2f9d6cf44b889a5b44b644e1a396546008d3e8c2d6fba2d71568c439dc59e9e781c72ddc247d82375c02180fe3e53fbf9bfcd29ca84d998ab041b85a36bc5eee3f2d995461b7f16de8e414029a71908c8840ee6f4e7b178ce3d0e422d78858eb0391ed96bcb370d034a8baa2d090a7b43972a6315e5201f5b3d1471d7ee68958fdf489af7ec37e8ed542dec795631b34f733ead7aa951abc587cba682a5b3a44c751394e7f460979db49954afd944abc85ef97e33f2c2c2f95d22ff9c27b9d5379835bf8a14e0550a60a5abc34cd900409496da070690b0c7a0c3f4d97017e013595f7b13cedfe3abd1a086638cb778f202d7bdae0b94fae93e757bfcbb3f17630593261d7bb56c6bf887dbebdf3993b2e50a3fa3e13e3ac5022af20892e2eeada9c2b21014034802d339af6712033258e2d2b87759af6ed94ce575d38f0454ce68307a5a9dad878645d1578336bfdb83f2b556e4c307542d536909a40738d68a946cdd5f410a7622bf7b4c41b8a6e444c78d7367e13165d0ca62c35ee359d4ae60d02f3788189826a2a958c790f917bd61fadf1bdbac0112c1bfa5ee7ddd5b4f7b2964dd7c32a5b564b4194a1ebddba0165a71deb5c2a3ef4cba41203fcc34d6c4efd16ccbbd3f522d4663d2c003cb772cec2ce92be5b5c8dd753d3fa71373e51b2b91ba7a3011742522d496c8d01f5ff7ce0456f0aed3a29997a3a88ddf0ce5f3ccb94982ca9ad66493151779abe42052dd5e6ddb0e10a19396f8f5abe1b480c7d1bdce416bef67f652d8aa34924c6fa46dbf205a1a2619f5f749ba10bd7c52c2b75b3ab7d0a07fa8715491dee246d1c4577debeb547ad5f5d6e2d961706fe036f1b292858be7f06d1b1ecdde235b468a2cc9bb0c9a04c40edc8355e01154cf2c2890bedab7188490b4b17721307b746b0f49d68bc1b2f4af5908d7fbe14f7f0e1960f1fd8644edf76a3492b91dd5904c745cdfdb98ba174de8fa0e16586fd3e4b4a923593d49869259b834e871bca52292251391790d3f09df76211945f277c2b78985afedf4730a1642f7a1883c5cabddc28dced549202be3e9c2c027f125f08fa202ec349beb2f40c8b0cdb54f0ff2056cf23f23254c54919dea9cd4e8b0baa2e1097b14fabd838a87c8e1f586c7d8eb4cde5c7455b8eaea113a310e6d2fb27f76b2517caf47887dc5a22a0a03e14e8d909bfcee6d5227fb97ca25cd83f2dc446b3d2c6cee9ba19309ac087af14334f7a93ceb55c831881a1cf11188c4ac76f47721d2f16c561bbb7dbb88aa91542e23917395d8f882674433e325ac52e5813adbd170678f55c856a9ef12d39a4ca29af9fb327a87e0b00b49fd3b328b0df27b2ac94a206b5856cb67b5c12f47c0e0ce3c873882053367e58ced42efdf0ab1f638688dbd21427604dc3566d59ae204286207f0cc31d0d7c8be8b9d2b7bf9f06462fc19e473b7f382756f9c129a96d797ddb2f767c2306544a89cb6a4d00aaf0204e8af0ba93f0d11046cadba53d15a82f2ccaf1397edfaf556f795595fd021a2916dcbc6251005e9a4e89f0e443369e73b615b512947c9f8662bb3683fd49af26e2a996ef657ee2d8f59fdd3a3d90bab4f1f3ae812a755a72b86168bdcae14abdc5f7874700100f614e9f5674e18dd83f67d9159e88e957063c47972633cc2272e4c322fb1c870c7719343a0228da0db3a3e2281821b6a36456b6981b0690ed7851031380a3bf2208ad6cd7a0929e7cc836d356bb2d503662ad4203191391b54f9d671f28c8eba66ceda34ca52ab012d6396e9f2d112b7dfd3400b7646e18c339346fb539a284fe19caba0386004bc7e4f17d0a5f939e4b4018f5c3112328b1802aa82a8a1b489ecf0c68203f482b10773947bdd75999c7f21d0e555e9ca6a3b39cb01cc38e0c518e69fac63f5c0012c5c076d530622a219ad54e938571f226ca6012d7962d09f42095b81e9cf05db83bb122a1108f3985bec5424a753bc2e119a54ea94dd52052317745be218d113ed33deae3e1c70dca5117484309a64cd734d3abf9a607452fdc9efbd4145d2241bb617afd8c3df2fa887acf7a3504c56b9e337a07e202da1d4863ca4aab6c75b7b2fbffcd31e0ada332e871f5c9a8b1f299b9b05375e9da923cec9e1ad714d6d7fe522ce21d72a347b7cba5d104898660fcd27b1951019285903b855ca6decd7e4db3f480609877f8881e214ce54a44f26921f102448e4c2874b0fa0d8406d97f98fec61eab29eec36b8b1fac2c30c4e701a8b12711db288e245a79c64b4ca7163f9152b0ae9e4f543b125480fa694369d26610bb3cfe75cec018032c8d8ce62a5c47b1fd22b67d67cb8750d744a0fcbee9a4ca8d38d16ca3dccd94e7a3e00a18a666f4d0cd08bfdbe55245f9858e66dc886c6c96c8772fb975b94e0a718d4b7c65eb9c095e2762adcea3d3b8def9d8c07bb62a0799193150c0385a98740107619883840086c999766f331d119651c01c109a16843251e8a3ce382d078f953efad96106f29fede1164aafd9c993483a0cfcbf2b4d756c75763586ef6623e3022408a6421e86fd12de9c6a4332b9075f1b32c6ca17365f8a4103f352d716975e8927388521841be524aed817dc96553ee8a0a3b3976bb3dabc20040611032935590c2be3628d8a179e467d944c6075cec35f2cb5cae075f2adddbd785bf0bab6ef41f9076a110d32cbd8ae2399e69a344a9d5c82117120a9aee732fe91035e1b852db34ebfcf2f294666accb2a1316322201163159a471a0fa78fc3737711168537e44c32be841a4072ecd4bf99c8f28f8e38fda4af13151da3430ba6675275ab52f3ce6bd1d4a560a9e5e44cf3d29973fcf3c6c611097009a6de278154efc2a6741e148272061877f2dceace18101bb87cefd8a1d2c3955b056a315bcb6aca2341cf43f84202f1db82d8d504de7f2b4277b7e8caf88c813efc7e1410571dd96fd808231e0605596f84fbc3a59f8a5b05c18414442c8b2598198a6da84007c5b81b2023ed3ea4a5d03c1a6f0f5e8cf081683dbd1b591c8f98cf9ca63ade0fcb4d68aa414e6f5535cbd1bd92d82b1d38fc50d51c682e07abf67dd265158fae385c2dbe413053685876b5e2463fd8b8346d73bf18518c6b0a6934baa0de31e31655ff6a3f0def9694af495766ae5203d61b31ce34f046a346d8dc463e747ab6780462bc65218bc35e8e81131142c9086a2e3b6aa32846d15ace35582edbd112449f0e05425a2b9356274ca62c997f633fa8fa87c223169beb90d49f25adbf2601b69f3525937626723608cdb8bb74c53f5d8fb15325e24c8d881d5fd298df944f78c891b0543ac071abcd2f47e4292c2039798875cb12554780a67f13948a112072c64799872e02340ab44125135f076ce14c9bbebc74cd2d9e535b79a7b500f4ea72863792c7e06505398443e78d5675e39033c58217af4a1f5dfe45d260e19d91d568d6d4a48e4868d979d6a4d45c79ea4a29205d48b4f84dc340b5dc6c3095b64bad198620c4893c0dbe8ba86afcab06bf0652b7ed6d7c68ae6598991f9accd1f6e717ad84507df8beee1a0cb4f1789128393b053c17ada729c6cdd8988296e4bca830ebd963cea0304fba549dabbc7d271b96b5e1111674567f5b63edafa9cc1ae3114372d299178d92944050ec3da06bdbbb79ef8a59d7d2fbefafce8687f08da55f76d26ce0163cebe9ad78cd6001b147e6f0bd62c088cacaa40b26658366c6f0cefb7bb4bae5774fd0b83acc7eabfc76678cfe5a1f9cbcd2923e2b719ee2ea0e7efb521640c735729c44783ae0841744f486cf245c49b3c49d0389c2a17cab8b108f95e87b6b2069e94de30747884c48ac51f133eb50430bbd729000e3b89556f4a3c44c8f429a89ff25af76d57db4c5eebee01a4a57b572dba13cd0ffac4ac59e69582909f04926621dcdf91bba4e8319810e7ab0118b2182f0ad15e930f2e6da081d0740ea36484444b751eda6853ee4fd38b9e68e021c81898e952cfff286c8095150dcddf73f7d8392811c98252f8d7035c134c81b60b7dc5c9139b840d98f54529ad2bb74cac1d4a01c6c950f0a950e495c89f1fc3314cbe3cec891595e29f1d40561f68b171a596e295e72cc2f0ec5e2692c1d27489f2a933bb6d2686eea0ea36783a5e3b1297a5862d48631623efaea29a082c0249c7ee12d63b7d683bc8a1b54699f14759f3d467eee6070cfd82b9e888cc1ee186883d596a5ebf0c9545bf7f4eee72bfe26bf941bccef6d217e68f1756b6b93dd711f6882544e565bb658d190c32346e273925763b3e13c5f867c855c5edba86e73b62f6850a3118df43b6992693f713c2d95636ff59cde3d4464dc69f5db5f84abb0c55032ff17cfee263d3fbb1ff1e43ba67d0eb4b530e47999ab930bb54c1507e8ee59937f267d6e0954f929f28a1bc216f1f8319dd42b90f3956cf2983f51f0a60e42ec6359d0755ce4ad7a5c91a426a36d4a263b7ee953b63b8227abf64bdd47547825c5824fe0c600fba424295bd70c6945ae87b4475796f4ee1c8cfc34ccb6d41afd0053ef46b26b29622339cb614fc1f1a42532efdcf28474b5dc087bf0cc9f203654fb639fcfa65007c66f384d13d6fed4ac6e8bc61ede1da7b5241a694fb112deef608dd2976a0fb71075de9ddffb3f25990874dba05214e0f504f975cce88ea8eed230ff1874d1b8c2f0016b0c14be8f1f7371b8d4de6eca0a737a569fa05b35baabf24a843c3e456ac8f3df607f8b93910681f8165bd71a36880c90ee6600debec7a3b108fe0175794dc9581f307a894aa18f3af50798361491fe3f726240eb83440feadb2aba0bc7b1962b22d0bec20daae4bff57397897c4da7b2c223e6e63f00126e09f3fbe9f863f3b6f01d218eff3cdc6df901fac111b57840625b0f6e37405cbfc0a3256fc0b68def3231f1125fc7aa7dd0ff6a5647188ccafe2cff972a02bf2394ed06ad370b11c5e19282bfd46670bfc3e960efca23b8d5dc42b0449786496fb5c1cfba29382fc6ceda54c2490fd494c166f9e9fa56fa6e1eed08fb24a23e2c2f54ce9ff9f837438656c10c06a7afc57e2f503b8c990e1a7def187d233747727ce1329a93cd9e781b748871a234049f86c0a1453339c4fc221b8da9b2a46a7e74267ecab53524696d50022c7f2b4ca0814294c8ca98dc9a1c1f1f24df86d7c1cb085b0715973db14371825a6b1d301c267127376ac7aeb3ceea80bae76a53ae76813fee4b181f881aa454ff7d830bd0c61eb82fe0a37cb284b5ed4b3b500c14a302e9d3cae90d4897813b0962cefda8f1811f634729663b31f44cfcc20e19ff6229e411b84871dee5c407a17439cbde0360e2b8dd7e13b17aa57a93931cae0a45a4de90d324c61781468dc792b13826b8759677187eadf66744b7b882b7bcb9b19fe44424ef9bb06bce6cd494e3a5419591e560ef8c35452a5d129fba063a1cd2c1ab2e0a86bc3c57c6d7ca3f2cd090841bf0aee493467b967b8d7ab92a0d260e8ed59da08f7d7deb4405a95d2f1f0fcb4e9311ee2dfe8b8eee9f906b276efde0d6d3bbc852e495630275122c2367588c1bac9493636d92e7b04e4a7b4bc54d2d3c5d2029f42a7b7df9f145c3b4c51e183730f74cbb0d61b4351d7589277e1918ef9682a13f60c48132d0c73653b7a5f5d70d54f57ab7c02a2efa39cc3143740416a813eec1a203ffaf677d9cd7923338afe0455825eddd4f926a0746163e872faca1ed8ec6c11a2b13125de79382f5e8725e9e6a84c32c0ad16f04e7c233c56ab481d5cf44129ab3f278085e323c82e40d1956d8a734505c40d08fb8da4fdcdfbfa8351dd0c5c3107f88b73d16e9904875925cfbbcbfe579a917f2ef2dd2aeb6fbee0b8fac380623b78073d5ed08caf12dc991222ab6562c39102da798529d387fa4cae3fafa9276b002e259151b9df9a14f5a22e55584a400c031e19c44fdc8b5fe4f7de94e3414105b88fc827d2b00daad048c69712ae145cb3a55f989f06466130fe9adff9cef20b3cb1142830747d0b8148a766af18c6ed6a94","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
