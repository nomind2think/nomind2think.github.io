<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7b6345b9fc28ae590c12dc5f46da709765e898d431dae6e780d2c7f3862242ef84bf56aaf48c8414d8e10c9462f057d5af855330ff43a582aa845e8e54c1adc0daaf4c7ab37de90e075bb28b222e6702584fe2ad88c73b14a8d39ceadfec1451e3ad1ed0a948107cf34fe2a03cc5a9dc580deef30c9eddf654a5ea7a265f21c15ad49fd3777d1fb10826e5e3c960fad2123f2ad17583a96f679b9f4f424ecff2b4463a05368de5b8a4142329c831818bc128608946f8aa562bf3f048f4ba1787cd2a0b708a6eaf9b91a882898c4a5e34f7aa7709f1ee58adc165b3ecb8518dc1c88e27a3044cd6a73abe4dc4b1cdc48d29695a6f95026e37a7b7283eefe82f880712b1ca453e6fd34ced144409423e38c37a88e8c69b3dfc71f41abc367e2a247e9a23a0e3545564fc2abafed0ce50b844449f6c69b4f047e19cafe62488e6b91088cafab975498703c7e684d0daeff89a81673e3f8b97981cb8e63649f7de237d72bbcb313c67cd9c0a053f1a510a01c6c51f161628f0fe4b5c44275bfba176ff61cde0c8a47609bcad798d7f9179a09a37e770630336d89af5f3b443f930a2a6a60043debcdd8994b27c9eca313bb56e7b62387ca64897fafd90c41e9c6b11f6efd55f92d15620f52a0fc852d5135ec9854d57aaaafac0c91d0711725cbc883bc840613aa749789ecdfcd1c74a79f91a6b1aa4a34d8b9b62b40216e4bf47c9f94206a0ccfd388bb0a7bbddf38ed6cc12410a67667768e5b2356b8401db9952f788ba608e631993ae9f45d14ea36c01c73106a76457810ade28663479c8913e3997985bd33313540276088607fc286b39922bac2287a6a4988669c0344197dafc2aaf5ed58509c3a5bc24340850363629451489a9c8178d82d8a4bc998d8b61bd9630d31d2d1a3415ecfcad4ccc9baf77962ecbb734916b0f27d9edf703d3030168e5b13146e11b76385891acb23f8783899e37d4bc29f76d890bece439e5fe526f06960c51f9de552f61a201dc4ae57bf6cd3227cdcbb65ee5a222ad930eb8dbc69e57561ca0564a6831bd07a40ab77827c90b2273201090266b6e64cdbc8c6a5bb16353839b77e9dc88709c549bfc92bf9df7f4db18b50a385a5f56e32c080cba2253776985f5bde248a310e34211badaaf5f52cfdda86196a2db514d0715c1d712c2ffff2e0b57bc844ed2336c774f2a9e99de4e56fea93731a6636539da2ac0fa776d4cf73e24a394e5d53917b7783ef35448192e0a2e36f7fc9ad997bff3351a9516ab3980e4e03b92117b3f0760855b6deb867edae71d5027353969883b2d7e081d3499075112a07e0e7db133cec5551823b37d86b8fc99a5a52b229cac615f836c6cc128705fc2efc4f29b6b988604db514fcee3bac52ad840e8baf573be4819272b4d3cb79529f0444c44f7150e451bdd07d98b374a011b32840858970378a4433ea819ddec49bf5176b4b95a82f66708170e4414122f5d0a76f5ad8b06cdd70ba6d70faaeb8f9f4dbb2116e9e48a235d9d9a49742f8e5709a6e6dfadfff3145adcf392a290c8e8abd4b9bd24a3d28aa810cb84967a6f5e059bd3e5ab4565541d02adf74363ccbd2cc48a85734102f830cb1775147c502d8bded112a900a3dd7f3bd1212484567223be6364b3cff78d8d417e2095bca22eff4126e214bf3e6e17588ef63a7dc3d0fa5d6f29bf67a8f7b780f85ae467fd4bd762104089d4b08596e528cd7e38e1b2dda73c93be843f1dfe4eeefb91be4118c9c5166ee9a635be66fd91e715ef424fa0daa98ceeb5a34c4662665fb782f279571aec42770a20f2e2a1e8ef5b46f614367d02a9dd12973fdf0b63bca8c7d2ca98a3f9a6f9bb54fb4c992f101cc470d37291b8b7a397d45d7067d27b71a18f04568089ea65499f5658aa77152315b6e812dd7c8804decca6461cf52271c2d0d8f3da442cfa622513c4e28ad58d1f86c78bd78ccf57c62b245a7a162ba0e8bf779a677784398241278027965aa2db2621afa497adc93d4a75a92d7a4168323224e8e06369e57a11278d83e3c6ee220d0b44631c6942984e3325c4465bd090509b373a928f2a4d4c3c40f927dcec35ab58a28ee6772b853f282db1f042686bfb22224e92bbdacfdc5ab7bddb7bd8553ee8b57e79f4b9b53905b2817146176bf9469353fab2405308c5f24ca7e2ee0f28b23372463d33ea3d5fa39a0ad4380d1b1376057dc37392820304ce65b3d245fd92a35ec7a513f5db113b442646c729d7db8a4bd50361f52fb37765f2345a55cdfab85d5a57fdc5a6dc4e3f883f690ae490a2f7a787812e9d5f0e5839c6d3c415ac9bba3f989e497a91863fbfc0da125a348a7e98044016583dc90cd59b151fff729aaf32a0eb170203e91a7f6ad7f6d58a3e3a3193f20ee66662f485866d2d51ea050e0ee4298d2cef4d8737d43dba154206549fee59230708fc3c55a5b07f14c20c062da401bd97181572fcbd0020e000373c65239747e104d3febd8b2a6e019ff030a9bf071184216e758eaba0a54e1699f6fe2a7fdfbbd28f27c93d732d46950c1217f0f63f03115cce70f901ba7be362d504061fb0dac1ba783af12700dc06c87b053bef7fe15aa22079b2ddf65a65b06b649105924c2716cb8473ff251edf5cab5685cf3cfca9a97beac6ac7eeda543d2b1b3f4118697a06aa647298a42792f324c8eb6ad98b2af9dcbadb881cd890cf8db8c5df3b32978c85986b0f7b3824d9f65991f53b62ab6b73020c3b3baa079ddf16501ce0354ffa5b31fc7430cd43ddf14a6414c3e4d11c32e157c8e9ed974b86ea0a27f22ac14f2b339b61aebe9e24fdf54ac35e4fa2f6ed492beeb3169e3da8a2e44fdf6912971465971b804f5533341fb3ad26ead833ffc5b16895c539937a613566dd9651e15150e803c2c2c92f8e297c81f2c20932c7b107217bce63abf14d74d65ab890fff8465aaf5c98d84e6b0a583b55734bbba3e8512f81823ba382044b37d5dfd3e2724cc980e7ed4616c057d80cefe546bf9e78a740c6b7716be5ac103a267cdab1f4ed00e7f3f117151ae440011b37932210b14e5c91c83e500eae16bc2817988e0f3e425d923afa8173c473af9b8c3cec87a7bdb7b893aa21a334d73bace4813959ff18c5448191aa01ad729d7d2249edb5673abbf8e6e2cf6eb003b60f340db80febabd412feae644f7af91a12e5b6ef8440a20a5a4f45ff3939b2cf6266ea60ffb8e1b144615e1c5879c59248d62a813be9515ae2d7e4f01a00e4f51a64509986bbc148d9f54c5655427ff15b2eb4cb220974511c8be49038c74a89c30c0d752c363b4339794dd4b543115c121f76adf61d53c16cdc23a7e9681730646804fe557442649b9205df169a2e4e74c9d46faec7ef2d4e04b0318774cab8196accebd1b83368fd365921b51d1f5d58d280fd95f74c1afdae55522733f73efbcbe649a021567a1d44d9ed2a3f7ed04a69d3b2cd8086b64ac6b3a7dde8d15f5cc80c8feabe05856681ac5d28b3e76d6e3e10b8b7bdc51ebc49d6243c157f2f819bdfadd1f183f125117e0d920e047e9a2f8954fbabdba9a62775ed16ebeaa82ae0adf20d337b44a4189e4b18ec02a0717c068d6b3f13a1372eda40f428ded8ea44b08df365de8b12aef83cf296000efeb3c92760fdaa4458234416d43606f9e7daa7e437e966ff2e513dae2b8833dcc843d79d43698ff27026e5e40866d3859909afce57c3378fedf6d6d51dbd6354a261ffd9bda5312504f925fc02870a8a96fa6661a90ca24877cfb42b28c4548d3c37e23e976045204fb55d4a560be77ee7ea49f72078c7bee6920c68e81ca8aa4708d6b65e2410b012c1ffb1ac67cebefee3a2247aa9b3ab96599fbaa68d6e97cabff99651516b0bd5ce994559c0131d88573a16f02f0d8c9d4880fe1084d2b107f0d80901de117728b40e1c85576b369791cfa369ba5c37a81a413c40bb2b30b4c3d50d2b785fdf1b4481edcdba8b20fb0bafab84b4982203d4ebc919ca5e5dce9e3592bceb6a9ecdd1d5c91f21aed5dc64c5090fc2d23f3d72c21ef3afcf2cc980f6b35b17bfbfa41055abb07a3c0c49ba16bb66abaf90c140010310c15fcacdece3246259e4f456d3ddaedbfc430b07a18778bb92fe33d4e9f401b00dae35f85a636ad8b9107afe3d3fee780433ce82b77d86252b5a1198ff45389ae28f0d371aadbbcd9c4ddcd2b4c430de9b384bcccfa44518488af0e43a3ab976af410eaf0c5b9c58ca9d94044a3b721924eded6df43a0cba18fe0202e4b0ca7cf8d4dc070e7e79a84c58d4b45057b12f9e724d471f588ca926155a145411a898c7559267034406223eb35b1faa84030bdb4325a668720f783ecb103d81162650ccb57160ca40c0f36804bbf2c93e1978173972794e96c0df9d70e448d51bf2b1deb98229c2bc258bef15278ce65a21013e9bfd009ea3cfdfe9e5156d8f764316346ef544aa891780cec4bb650ff10d3ca8801770437a6f59ebc7c7807a4bfdd1da2b6e7d175fa51f511550e2584bd93e76250b36033838bde0ab9f136860d5810c641b0d9c83e7391e9c415ba06b92184986e8d0e04945964ccdedab0abb33cb448942dee965b56bc113c88ed542438e77fa41af84418d332b8ef0723a4ea29ee57e14ae11b745d5768868949772ab112cd595dfcddee166f43ff49ee9029b5fb3680490a39eedaf474dcc4b226ec7ee49bc6baaf77e5d89d75f2e4aadb655df262106b81973fdfd8bd61acfc71cce7a717f98ddafdeb43200565cbb777524dcef68f6da456a1338750f93476ade08e66c764b0d6e6f89701d06d8cab5358f74df0d119f514482bb8432333965aea30b1b5730992684fecdc748bad0d3695ade27759573f9647f0b8e1a650cc0885dd321ddf616071ad689f8a412a83da30f69b76b1977abdf6fa08e959a88ba71697d6e3cd556c3f69700fb37f5df2c0e101ae1f5fa8a59368e38890102a19bdcf8e87ebe69358869fa480bd6dbc40ed58728e738a45b1196e8af1aa9890325034b783283dede63b37dfabc87eaa52f33e9942ac2b0ab49152f091be1c0bb39b3f06803be8b206af91755973c4377240904fa007147533b443893edb7eb5036783324d44864ef009fafea67002ff8b3d8f49418d4066d3042710b019e9c1ffede596bdd6708d2444d3607c8d3a38023730246c9fc7f4ec1eacd0605ba43ff64c7ea0295783b67722dd823ab7ad2e42e4f95466e7020315b3dd62c3fa0a1ce14becd650cd336c118279aaa6241b62f9ceb915127a28fb56e1f45bc5af6bc1fdf2168c1bf150ec44700ccc4cea40792db0058364e1dd8a1ded58e27b5505659a5b934c26ac02309ac1f9893f0b88111bb2a04bfeb9cc123931e827c98f82eee75032e130ba0f4f7c3511f1d3d1e73028b77e1f17754ecd795481eef6413342cc0142bb000b766efa931e5411b3f6155d6293a686593524f613c4fa75e11798fd708e7dc8d4d4dd320500425b6034a57a1a6da081174e834e483f7437ea421cdb1849e3b33d14b967638deff2d35b935b11e4c52479586327ab53d9079425de52a76287649a1e5f8f3ca15adb0f9bd1d0176bc208686406ea3ef2611c8d4b3a43b8b112ab42c0ca7cae34e0def609c82981397d4715e5e1e59a77c164c4d2d8fe1ac3addd3644dfcaff43fd969d6b23a5eed51335e16e3bcd9200bb47ae225f40399e23a65bfa60ac332888ec3c0883c0dfbbf0d89092498ab4fb97c9dbd77bce23803d391364ae6838c51adca24a69c6a54d789167b332f8ff30bb176c3f451987d251ca03cef724e37f9810118e5122ff9f8dc9eaacbcbfe6ffd7dcc1a97cf341a6d5cc4ce59315520bb13418435f74c87a53b62392efb5ccad0c729d31cff255d0d0911a3252aee335a1ae8879776e12597b3a72263456bd0a8b9cdc248e0e53e856bf742ceee81e61f1ed4a8747a08c2c8feae236aaf9add2354f23fdf46b61d8495ee66a59bc735146734bed949df35de2376018ade465c549567f9c9a982610ba4329c86b5e851a487588795dcc24c2de62a2e7779a2a5aa9aec1b0c1bb95b0ffee9dd5f352c86ecf36209c285511de992543cb4e9cce98bbfd2d32d55d6ea54864ee5550e156a0183ab14ce039f73ac882a81a4e93c509ea8b02fc1338f97703e3b740490bc59eef4dc229120f2c3263b1125093b2c9c7f5e80010c9135b896eb268aae4969351685b615f9a5e700544f614f130312bdac98c0564f519694773daf448d4879ecaea88c410feafb4385a99f4ed8ee72a124ed3c165b4f81c11e0c9c22a465ee33809c8431176ff49bf973c8c38700b2bec4d05e89c3c1f7195432b168793b3c73208ed2e909476566c913ed3f42d253c2389070440cbfd1075cbc9826d05e5e2551421ca1ebf4bca747dfcf8270c5fa8a0670bea7b13108b5dfdb735a61ea04e17ca2d443612602da333d360f7d9ecc2543ca7f6e7d8ffb7264113e84fbceb89b4dbafd68510b72b3e2596955116ee52e5f8910b7f828e51f71ec9c5d60b82b609349062f4b5e0c39d1b50bbee780b3f5af8f20e2fffbd1cebef9f665a1197bfe210d87cc4cbdff76410e5d56ea177f5c14b30c7fbcee4bf69334d4a358095f72e54a876ee325c1324cac9b3280d45b80bb272e41a3022a4a9999657d0c2929a3838d1cfb4ec528f3550e6e6a07db3b5dcb38892df950f7eb3f81f844124e7ed6152058b7262777a1904f557d994e90891e1da2351f161128c1e4c30ff5caf6218d626498b51ccb22a2dbe7435ed6ad336aecd647aff1db5240111d398c7648aa44511f1240c3e2f9ca7aaaa8dbc76d1c73d9d458d0b0b82027f897dc351b474a933395ac21a6140c0452090f5730ee2b4b9dca0845b4d86fa1091b9dc8628f26b6d4977810537d47294fbcacb143b236bc72c5f8823d89ca5e09c2b63ef971533aaa49b324f577e8d0f19ddfd8220032e5c24f9e5dfd6f7602c7760bfa322675ca50611dd246dd32e26725a27970ebd79cb1f1ecf463ba6ae54c43dc57d8de2674ce8015f7c298dd245100cb2ab5e2716271cf943f439082454e47795f8e4d7cfd167c3b48aded2ace2e5b4ae68b15c69b20cb894204a6f0db5c8ea3b689fdad7a71d94137385cb74f050d4dfa393c68eac7efab9d0ef738ceec81c219a7e907ee4e5d738957c3f2ef31bc6d0e4204232d53bfb7a9924b0bff78bf40f0b655802dab4dd3f7040485b3ed0c80e6ffb87eb4a1df316b342bcf75913ada9e81616755195ee75109ae9c0765e266e2095d52a50c77a2dba2a9cd5938e403d4e5404c7e33fdc8d4739f67add4cc648be62a5bc212b5ffdce55a314c1a4d56e17e9adc1a94f6133fd75a91eab491aa0ec8e9133122b6df7ef701bdf7ef7edc87fe0664c763069cc56e3120f0b03213f265d1d40534271c4cce9857bfb28635ad7f70afdd1bcaf28dd34c4403ebca459b0e05c658bc5c5812261105aebeb5a22e2516008b5f328394decc43e21709f6375f8358000dfdc775c6018bbe0147e86861bddd75af55a9ea11997b4687344bdc99d07a7a41150aa3cc1cfa1258d5b6f4cb6f26436562b52ab58d3b5a4ccabe918f39d91a36383fde999e0dd1576248374801e56c17ee35f83800f020f21debc42a39ff8e8bb160d6214f43814c1a66f49c1d2caead0af54b2ea0ab4f6dd2b4758d9667743d1be92c0213c633d6baea8f3637cd7f6dce9ec362427517e103b63257646f520382760c858d9bef42504bf1f3ad59fa253219e2e190c5c7f61f31c90aa3166e71e364cf592c9818e3400409bbc2ee27bc52ee6999f2552eadafd429722f3031d7e05a42d790e2a6c2efc7c549caf8f6f02842182975fce89148cc27449ee173e0398200aeca0bfb75e2ee510b6b380c0239e275ec582cfb1e77880ea29a0720dc78cbd32500dee7bbb6bc95183d568629ae6d69c437fd802f6c962a1e73a3d286292274d77db66934f8196619d33513d4c679f4bd070f313ef02af6bd6d62ea00763e3fc1bb1654924419bc0ca5054da6a3086bddf3c1e1a87f03f946fbf68b72fdbe7f019e79a38e6ba6f4004bc80d2042e677a8d88442f72de133b290126eea3248470f9a7d89c4a65d6df245262d1a06c1a78da64049d5122c42afb48472cc6feb4b866ca56f136b89dad388d779e9b411bd933d7fecd581f639e24fe9f0e4eb9e2f964a51708a9ef11f24086c1005a2f5b6e1468799a10245c7a0fdcd1c28035da63224d317899e8f30e7e6054f5f5451adb0a084bee56a95535e4d7c7c8436a324e36f3cfcafe0a7ed6eb0cf6e3b28cc8e9b487a42239c251513b00b384f1fa06374bc4bd96e6b3aab888017015f16baec2527941d604f7140c457ca60fff2959c096f02c7f03d896df0d65edac50056e233b176c26357f6c66eee3d5d93f7794fcd0072daded61c65a9408069b8277301922839fa08e761899df669b430ac89c0a3429b5a7542c3c481ce2ed5c683cdd11468ba45f2d684086ac4954b283fcf4a21cd37681603c89d2b54f5e24553cd2cb990ba1da811d12b8cb37618ef537b2ac217a8c6f7e13f2e666dc25e0b3cff9111059f5608829cc88fb7171b150d0aa643ade1ead1f7c33e6a77e8b79e79ced103f58f4daa33225ccae949d3e555ee16917f891cec4f962e3a9bd7f019c6c65153ee1151899b7a2db0babd58af2b8509523202a9aa3dbced8df53fc276481deb53541047d431d5ab246946d9c7a4e116cca299e3b14cefa59f116d493e02b2cbf3301de6da7b4fc6ef7d7499187ded207d7b5ef8ddeb82da1877f0f67f0e2bff537182059b8b21a695efc1cf4c5d9e1cd877d87bd6b4213baf36d057ada4f17ce7eed47330c23351dcd751b58ada6524cc74c5a9ea0b168c056487fd2930719015e313f9b7c8f2a0a8c6342d327f584d8d31449aad7d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
