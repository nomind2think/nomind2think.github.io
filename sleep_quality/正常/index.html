<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"baa9c8f2425c8d439803a5d7b4664fd486603dfea3a262b6f51aede9ae69db2a88913f5c9444e0db4bd0ac04e4567954cfdfb7eec3dcfaca76ed58a616ea1acc7ce8935296c8706518a64d9525b78c97eeb2cf9d6faa96b5566688328d59bcee0442aac6d935b9e9d77329930a97e813b56b45416968ee5ad01281870b6871d6c7842f92f03e4cd90e7ff32b951acd11c5ceb5e057625f3b65dedcc7afa82f24ff13db469775e7d0890899a69952c9d800fac2280bc528e51b331fae30ff34a09553d78dac4d8e7035e14559578b7f82d24410088b7f26bf5ca5548b6aed101c1b6c9109926ef2646dd3533fc90a08d5a6e8193275ad1a3d524290b4ddf149f930f0929806c7a8586b34d260c46608e71d25121a113cd928f70fa75f08885ab2f2130a865b84e81287b18e0eb0b81016c54021c505a7c9feb09773e3eaa6b9a5a69840ba265817c7dc595fbd3917fc225b881b3e9c10fcf98f5e4ca505f047961e05a1ee8bf701f3bfbb6b383c1aa9496ecb3dc10e768252e2beaebb814528e673d26ea026d7f18a8f8708119930f99ad5684c2f1d5770576bd06438ea646a22c08896cd61163957641841c1220b4e199ccc7e1ec3067e6b4310494a818de93637dd4a653682b58718e52a63c2e1228f9d297b826c45448ac126d77d35ede514e7ef5a542aa054e5e8aa25f0af3e6902a1660d198f63ab7fb17df1814cd7d98cc4c57339f37936105f8c49ab7a0b8f5cbe0bc7d8fbcc09748e345aea69a85747741950daa1a59be9477672690209285b9204111edf2e6f9d08d6888935b721abb26b9fa9dac0945628d15fe410de9d7eb971f6c18f9c754591d35355b9c9887dce350a84fa5a38b358ac68ce9570e45da2b48944711f6ce4ac74f1ceb31145faeb056f2a6b192e3736d801e65c48ea37787cec0a17c0f95499c81b5e29cb248922af48690fce2337450f0e0032fced839bddc98b93f9ded8ab35cf24b60d3b5233626151ed1b75d65d6391d705d90cc6a1bb6b34d7b83c8b8a85ff69854d1f8b821b53709bb3f49db1310212ab8da620df142eea8a9c34bd945824017226d4de3ecb26d6cff9ff355f89044d02747736f6ba8eedd2d5b6f1ac2791e276fc074da0f61e02227c211e9ce8893b921d80755954779f47be4496926e7ca2c6f53990a15d5bb7133240aa06600cff8896490e367997378c0006ec81fa38cb68049649d25f99ce4cdc01191e239052d252e198f2da71337af9becce0071fbe413c8c17ede442750e6e462a40cc51f1f559b29f6499315f3ac609762e1a53538e798e4153d51782a1e3dd582f5898d8d3eb5d0fc9ba22a3188fe2bd8ec470400882565b3729ffeb405d85685b4a6b7f6e55a2fdb58ea077d0e391b67e833a92c0be3cb35d595df995272f2cdf26ace6152eb5140df290eeb4c32e016b29c865d7ec5ac7e45f9db4c4e71cec29df2bf37d39b9ff546d23077ca6c0f7a768f8bd9541fb09d30ece22db244666f870ec2d1811f2ba566ef9ca436a03c47bedee14c774e037b6870314e2dfc5394fe0157e4eb44f784fae01b6feb79a9b06e1ec29576e1371dcedd52fd2971f8fd810b6d52a4bd410c1f26bba6f2bb08653611574b6c448806dbc231f78b1d5546fe98734361cf7fcb229d38e7c23206ebb13b6d3592a8bafbbda4cb95464afde47b2740f62b9587b74ba7f10a44f489f4a5c7078fd0ed9eacd7c840985ad14adb4983a6ffcdeb7dcc0c69f2c8c6168db1adf675ffb6a8e798bd539d0ca63136caab628a4090226def13b35517b150ae192a3b68012076304bbd030bf5ba1a7623336038d50250866d810c244bac4d4266d04fe5753f99273cc2b1482566cb66ae18442fed40649603dd1c00612dd235951e5e681bb0333b8243d1eacbadfb02bca4d67f6694f9563f2793061e861b6f5c88a224ad2833ddb1e7bb5c7eaa2d871708025b447a38fa38e540ecfcd2e2c7fb2c46fd2143b19c92155e51f47915599996e5f5fd2a5dbd1b6013652d31420711e2912a8ad3bde55a22405c3ac579291dff7b680e5be8db31d3b2a3591ea3d48d2b12d80ba020233e0e298b9983028ed370d1eaf21806839bbeedca6fef12f9fe6d0507ade4eacc95b3a320460627bf713ffb70b3eef18fd8b2581dd0885c5505847be3c1e79e3e417b876ce66f4ac35a998361a060689148042754097e448d62993f5ee0a05580e6bc4902659994761ddb5dd11efbcca3f805a0b3dc6d4478be75d5bf248b53304b35699dc95e925d1f4cdf525f132e9a961e4dfe2dad5b984b2a3798284e194f5bcb1173453f6e0b96821089946872befe2e719678df74b189810e713a938ce6d455600c8ef3364181998a5212ddd4cafd4c2e6d5b8473d5af4e49771fae4f47a822c7af23a414e425a55f695c06fd57e58fb5bf8821b4860a4703f6009122fa8cc567e9146a715940e1316e97c52f15cd85bd4ee0cbe17dbdcbef427e24931719b5abdf2c235b888fb8442fe9af1adc542a10ae67b3ec6f7d614fee7cbaee77ce15c41ff1d0ddf1737d742c2e01e852fbe2c821d2fd02f3abcdd232d274ffe1c0ed40be7883a29134652bc1f139ef6adecefddd9c82e03afed8514e5d3d504b647f32e72094abb9a973fb7e2a24cc0e344e813c19748179f71a8bb19a5c5b16e1237e4b4a091d7e8dd924018c005f6842f2b14d5374c75c49995c5e19e1d2b418c18639b3f5aa27c08254488f6140eb53dc6cff536437557f32b7cb41e88030ac8f65b2b8e6e0ab3678c74372e93c6f518c5668b200ec2c80a409a7e62cf61d4d66f3d66e7805485937f85c46b47d4cad107eeb17f1033c568ba32db650d9043ebefcb3f2ce1241de707b726ae94b6c75c0c969c419a60b0374eb0948164b8bf497d9d38739f1a2eabf62907a4db4f7ae92b9d3c27950a4a9e7b6918b8d5dbf14f25be487cd73bdedd289fc4ccce07480491a031afc79f63e449ff75521109f8aeef8d5d0eae682ef6eab6cce02573d8e00e3933048888e0696b893d330573b5e7476caf8520e597b4946e6a1dc721337122cf145fce2ad58088e4d20112b2f11cbfb28a78aada27d68532da410038a3db4160b6fa89b61b88def2bcda907a68c82d070ba5ec0d0dbd7e02ab24fda1c832d3bea193657448335277b420e5b33d6312a84ded6f3e456191f44875b9ba978a5f5a46ad4674685d6a3c100171ab8f199d4ce2434880ce3016e6c91cad54c2a2be7428f0d9fa301502690e1a3d073b013e0bc50e472065c5d629f9cb13a6a89f8e2be0d1f24b9dfa968e9a3d3a9fa5bd1916de4c4971b0b9815dba4a8827861ba03a226580e993ab0c6688eca2636040399b5b1e3b9d9d30162f7ff01a9178a89be4a9ad2c348d0d82b23bbe663d53ebe534b17d7d6e189b167a99bf40495af802496f7a1352e96352743de71fb05c2fe41f21edcb8947e80da372c054e3742166fc561cb197e4e323319d95ce5b0cd9fc9d8c35a1c2d87132835d01d2e16ae535bc73e3869918ecbfd1ae8b6e97d74ce7163c3461e63991bd33c63acd78a8009e1032ab8b1606c723794157e5b1fcd408a52916bd9d617ae253c6d3ec8b1e5b13d87867560d3df0077d48d5d09297c3c0e849441099760b4c70f8d844f2817a012a807233243a9e26efebd7d3683d25018784816f214adf033a8583295c077630d4469eeeb42a36932e06a56b4ef06a61b4fdec431475b29ad4ef6e2c0d1c15ceec4279540d7bdb67c9bde3aceeb55d9621e6754b7e1942059534cef99d5e873f246a02ee4f709a444247782f0b9e45018ec4e81813c63446460da1987a3766d0da0e2f79813c8117ea080e5c8d354918ffb28b86b8ea053d904a012890fe486319ff042f5f9eebe68d9bf7e6ac44ce01433b72a5968ce11e86451316e3214dbfa3f8b74fec83bc8159615452f44f5deffb8157b9812bc628dfd1b36aae4c6b39eb28afc1d7698fa054f83bbadc76ab71399f8b90f50b29b0ab254b5253f350f87c65fd87a948cdce563d6f05d96d7145ed0a86b160b5b1f75f900b979623e68565a7439b4124381e32db27a236f8297797a2fdab8d19f5af44ac604140187b8e9652cb1102760e0246a9a1138d23a7ee7bd3945b48f67a78d5b48ada5d4252c6ed67a34f7c8f2236747e5052cea92dd00ecdcea9c4c366aee9942de6139afbea27a3e6bfe144105ea699874bf5d42bdb111980757ee4d44f163491b8df95ce19d1c3ded995b134c1d469c16f4d05927f0ea4bf3aaa51075d5c0e8160a3b5217893da25110a386c27a6f1547d12843d4a31e642e02608861a5eb5e17d33dd05ee5c9c08e38146563a5a1406b34abc3c554d2c3456c426296cd26ea887f64618cbfe6c6980ff59422c6fa26ba825890257e94b12547333ebfb1c904112d643784776f51ba5fc355461fb46ba8af16db827e0b652a706dfc829708fe142494a55c4565b531ae5114d080193d2cd19dffdc3f8683168c010b227d1e794e924cdca2db589a0475c3cf78bd6e0fbd4ff80beee0f951a525c0b76780a65ac4619bc35ba48e2ab2f9480f3f8b714bc736ebb8dbc963acb51d845e063bb509b9b4e0eb0f6b958f6b2f500b2289e770ebece21b4a97494a771d4928fb0f9e66e222bfab4d6c5f2dbd839b05428220399db0de27c72293e47e0995ca79a01d36440e9f145b381797d37123c1648125fddb1ce256fafb182b1ebf7fe79626e40368643df06592cc235eb9371ad4ed34a2eeb13c347e675aa427658c0fc2567840aa7ae32007e71ccc0330dfc2cec81604b61f6306806351f078c52cd570a97fcf01291bd15a80a15424e01154f3b91cfce109319556ceaa6578da4835277cf25994cc6b2c443c85ce82dd42a845b0eac9cb5a0610935988d06b5931e85b77cc131aab419ef0dae4c41d0abd60da18587ded602bc32c26d2ffa3e55331ee10726cbd289bf57c0d9758d58b11e824d9c0cfcbf5aedfe20cfc841cc0a0ab8096df9a20d246b75dbc1229a2a6e6a44fa9cc64cff2591684f0dbf243e9312397c9f5dd83e5b7eeaffea1f0870018707dee20991ed19fb7c141e7d7ab306b1bce490cc35561918ef9ff0ff7900575d1e167813a3fc08a98a1e054349a5af63d8a8de2792cbce01170525d6cd0e6feaae96db56c959718005a41e93fed29cba9596d2b385cf03ac7efa7b398f056dec8b8c0e662b989816659698ed7a917e0ef76e1c953a02138bcac5ac02de1c51fe39b6606032197a2db8028f7bae8af3084020db13eec9f437ebf1391f5a6078bb014e02cdb47ad8c54820e9eb877201ee397b23a77efbc46a27e8461a7e892625453c64a52f8eb23b4b07fce416ad67948dc2741677eb613b92f05e65b651607ccc1f8653e9ebf70c86bd4a4d66d2ea88ebd449d7a4377d121c94be01d369c1724a061fa3aeb780e915bea771915ecf2a9b5c8516ba2dc4e93330d246c4653cfebbf42b3c194c540b9182c61afd64d27270fedb5f5e74ee73d49d3b530679c4eee7b1c53a70c63cd82db4668e34234b743f8b5651063a1ad406ce7001cad617ff9c92266d6684bb56d734f618afc54800819da2610f1862b75ce309542338a1c98c74d00c7512e290a90f54789e812f7571625ba3388b4ed21eb3d1350633657e1592c528ebfbb8593101dd60fa785df43319f69d54ba0069fcf3d531271c18382e18ac37434da1ac34eda668daaf4e0b5bff318194af5763f9b0923c1f03f4d55423cccbed3a3c5b59a809f988110360f1b702a54061db9a113ad91e354e18a6c86395eccee07e6fa9a195b42718bd1443ccf063ddea2bf23ca8c9a164bcebb5faff76e4512e24e171f3b1b57bb66435699355dbfe812e412c086e029924c54ef697be61c29a6c815af56b0399c2ac775e9abea0042d6212308b1e5cb165773c4e8a6e554358a1ee79180406b6969b7de5aca29c01a2666227b0bfdac3ef6a7581dfe96dc36334e49e966caaaea824c6cd36ebfe874b5e5d5411fc4be9dac8bde43c39504fe407565dc6488be96f1dc05e0dc46a77e14738b45da1722ed091dab223c3ff718f0732b8c8fc3796f00b1e55ebf1942e6f902687f1a44b4d4554731b3caeed6bae03f922c83776c95e2b7112c345396dd2eaf79e9bf5cf027806da943e4a7df5b5edef4d795a7ef89653b4c612dbd9e5c37b2da53cb288797c60878129647712591393c9014b10f6b286572ab7b2e71f59d84c056ad095e4fb0528e6fd1923457e6d31713938d76a0a275d70095461e920ae802589c3f5d45c7e07239f93839e069a9a5c7b1350ba63081cc34c668cdcce1c7c57e575f4318efc4c0ed159881527343220b6aaa3eb497960abf7a02769bb037f80a1694defe21e7a42714936ae7fdd6d17006f285fd4b5e5a1f7ad294f7f94aba616c7da53e85ae4bd72f1ec02dfa11b3aa51b98dc9f5dc11138a0969cde2b7201cf0129250dceab0e62a0b9497091f06c227074bc1a69e809c92de80eb33e8cae2dcdcbb21b209814d1c79a4f62dd648ca9b255cd8fc2bbe8ca1ef3f50fe2fd5a602d6d42978464ec16e210bac046e612d622bf44d6f82ec9b61f56e829f17f4ac28067d7cc5ef5669bb8968d4bad538a4b69fa87cfa9bf67440342c4d7c31851f44583ebee80b54bae91a5de3908032fa5e238d727a7e39726b63bb58463d3aebbe422be57e3b87f21c75f974456d406aa2b5882fec7f132f182c51803ceefa7acba8cb2b06b3cd396ebf565485e41e599b1eefc28f057a2d8cfa312188cca6a31ca6c09d9eed171f69c17b93b8085367bd617fbcdc5ab564b9c983d77732e99198b49aa61928fbcc18baef5355b9efd1230993e031626c4cb94138135d856532ade07ff59505f217555dcdeb46ecbd69621d0a6e05118030bdc51779b6318c18c6855f1144c7b38f0e4deda985f33e5231039826c1e271ae9a2d8cf3c1fbb65b153d354237be676f019bd530a1dfdb2d03b2ca0803cb1c0223296789388824ca9feecb61d71bfe10169f260be4bd1690c8f067a2bcd611c90bd034f7222a092872698e3844f21998789e5de98e0ccc96e54fdb6ee0ccfe586d7e48da63745e34c4b2beb3da2a9a0a88c17a9a5c901f77b24b5f28b8930a73c114f9ccc3100c12d62630389202c5f20ddab78f5036d48bf1cafaecd6cbcd17f8355f1a013e2df8d78cd568321e8231990b46eb286b61cc2c0de9e78323cd3b156b8e6fe6ac920a256034032dba948a12db8a552ec99fecbcc60e80ea189d20c002e837d6523a4dc5ccda3d14173a62de7694c6f6d6dffee6d384f8ba1a224c7941129064bdd4c55246f74ffa22336587ba9a2bf1e2d1772885a16912e9ce72ccfc9dcd6a8dd0f11cb63e707faf14a1b418ff06939a51b0bd2994a339080890a77d6f39695b48582f0da9431731ea27d4cd5cf1e7a76eaa5bc3a7e19366cb9b1fbe9227e0fd697289862d0650abdcac8af46fb3b1afabc924d1444abb4801ca045906a23e4638e76650bdc7451df79a33ff904611ec2e43f6a78227f74313b0eda851bdea795e0300e6ed5b3852ba36c9e721817ca2acbed8d31214563db5a44b46700ffa7d5bceabb8c725a4aee3ab2e85d4cab736ef1038675023b0d7b6a0e6a530f89030778f37b321dc12405d8576c63bceb084b4944d8877396596a6aa77af17e314b4440012f9bd334c1c628b10dadc7da14658c39115c510343d981ee42cecc6ff7c100b137597502a0c49ff9732c2d2f9198c38b684c384da45c416a7ebadec7a64e638481469929b5b0e0e2d5bd92f83cf8d19222fc2e38745abbef09808fe0e74845b93f2e88a3e2d0ebac551f6729b48ba2fee15ab222d5d51bbafaa5c36e4aa4f3204a3fe2c3392db6f524c3e44e154bacf811c35b366cc2c5a45d3617230823947efcdeb16e4561db213d9e4b4c040208d1934b227adcc3f66f22b3f568c45bd5cfaee039598792641b94c3bb7fcd0af2b2818e0a1a00481a14dffa4660fbf924819bc0581d2d54b4cca34e4706d83769bc4e6cb5ee212327fa48cb6194a2b43d688cadaf1540b58c513ea582a4fcf739eea0a4c8dfa1f954282b688c14c787d7704628659a8aa8cc40eb91aeb4979b6d442223f886f6318fb90b5ca4b0695b25922ec09ed9ccbe35160346a87b5c6bf881f0e1ce5de65beebdb76be3eae7b6717f93048564309c706110f36ee4f084db535c6d5346c0ee106048bee29321d1174bef6563ddf341555501d67374a6667dc3a3a616c9b357ef86c5afdf1cb38d5200bb9cc8613911d514fb9b12770cd801bb5c04e2e0fdbdb178515d8009f47089fdf7f8aa73b4135b3a33da84d6bb1b3d53544f66482e59f8303b2f74051404e5508089f8c03b3e80c63e268a8589772ff7163572d614692a53ca14828677db7f7b0c8a42c37c3c97ed98f60b5002aac8c195eb986124cd5d376938a95ad882291d0e3848160aa7cd6cdd26b077ab9c102918a4b1482395cf21c23c4b33204692ec78b3657852b7e02f7cc6206183f3829ab03859f0408c27c3ea767ada16fd34dca1f81fed523efd59f39a7b10292dba9d9d619f0ffad458a7968a0b3d61d6ed3a90215c150d63060ddeb79222807f02ae68fe2565c4cbe564207e529cf798090c448d0dd4757721ab19d691f1d61e2e0fb9c8220935f98ab2be3d0400495c78423deb1f50e010ac6473a86c680c744bc7c3cbaf8af12d9d5bd57f0dd045c0c358ef5072b0a16f1560185ec294a08e8c4ab9ac3c533a8719f7abb2ccf9aca107239ab148aca6e224ab4560adb4ee480fdd32cefed98245a24fade6d63aa77b99a5df902df6c83d27dc0b47f89331ffb777db5a094c4138ca5ee8ad87b2cbc3908c2bb9fff78a010bb1595d2b933d803bf4097ea39312ef3c19e67e9a95f1f6a44fcfd6c4c3a2b03408ced876a4932c7bb15f57bc9ed0b0ba9d24dfaa11fbba844aef253b73196180dcbbd34e6d045b8950e3d5f036680a4464d6e36444e325425ad469c76ebff485e1d76ea8adaf878df9bc69cf019ceff26ee7e41638c2a485a847e27c97d816bc1119f99ec8d50130c3c1b8bd53735ef7daddb6f0c5901beee031d861cd1373f1e75d18904f5abe0a4236b4fea3adf65244affd1281a700c6e7dd22dded3b48980e7d3634ed14f843af6b52859696e4616b3b8216290d100cb74d4a0dd1dac97807d6bb8f4f0d0e48ec638e978d14fd65d6b08e0a0f15893e9de2d5c9e9e9768799fbc18cbea2cdbb4541209343098abca08e97b2c02a28fce9003063088d272cefe2c8951c3604ca83e91de50e5513aeb2e888fe4f8cb9c5096ca144342df7211e093752cbf40e7b7aaa351fabebb820dbe0a3443bab69cedfd7b15b816f1a5aab23e5abdda508a0738f3af1bce01f9b3b4d4b24159766cfde33c37906fedfe5b35be36eb2a0882607f9a53ef6a3c9a97fc886ff8472e3245d9724ea9f1c6add8e4f1cb7b43d7447c6f1466c19397355907d415d3043f9a624718b826ae12f50e706fc13a970fcac993cd7f8619d7eda99b4432b06f9a8be2a12d057c94e200ca3bd1238f20973121e16566d47ecf48f264eea86e80c7c5e091040156996df5ebf0c1ea837c0fe2229e59aa3900525e94ca6295d723f3615bd12a9c272fb7b79729d5889aa42945483d49d02092fe4210d67732cffdd99a3b9335544ee24b7b400a63537e16ba3330e2fdd5e98feefe6261d4b78be9cd78cf4db5f12a27fdbbd61b902962dd107a189410c8b42aa7211518f63963bd1e08e86cb0a2ae13046278e1443b0c207ae395ac373bb300d9414eb14d934aa0b7bc3f16116a08d4f334caf9dfc2b468a9e0bd5522018abbfea4067668a06d3eee60fbb82991e8691636b2820621efa64dbd6633299a11042bf4023e34e0e4ecb178b69148df4d39467dc5e770c6a69615d7ef1627b1d40f3a076a4c28c0d095c1c936f63e86a8cfb322c8e25692e100443042f60459387cb04471ca80fd0ab03fe033dc1bd8ccc30b96a28c10651cfa07c815d867811b6b2464eaa21aa05ef2363306631fab6382c2e08a7eddc841eec537c6b07a147c0e91e331efec1d7071232e1e859ed3989bc1062f56f2eb1c3d6d97361dd19d42f971644755a196afd951f834033d639e177be313af6867ce96396d87c30fe77b9668531e2d8a05f60055c2ec57c3e7af73254e07da483d3b4026c5d82f78212091b0759e775341a517c5fcec94064e525a50501a2cbc2d24d3286d15c02a2e3ec39d11d32bf07256783b012c3b06359dca2528909a33b1483b87d86b3fdb6363fd8fe26d20f9c18fe2a8e48568dbe2d6876e303a81a1a25d4cd7367fb17ce15c6275772ab0b4468f9475eb24326d156168de324b02ce64a7b1cc22cbd6d4912f4bcb85c20b4516ff552e5f2099e943b07ceae863053ca501ea88e3f78892f0d7e070f7c08521174e427fbafdeee7de1728f8968d26d619e87cb8529994fbd1e29c45911874504faf05ebcdc3cddb5cc3f6d1a2c91f5fb2a97f2208c018e9abb53f848d9abc8835648f4604e2f886f6e77e31ca585c5d5d0dd84eab30f3050a0e01e22b21631ed83d100f7a036bb92ab1e55f18dd946ee277e03477897e835018e6504122be754be0fbe83a0c7b3e863c14535e358866d32ba68b10f652da4b0b841df53d655d2d6ea9ca5b0f377ac35768e750884a104358767c1c5b973d3fdf8e03e1a6a11a447a638d7e44752ca3e588f65cc4defc68116f510c31462d7d5af25f7b00130e9427f139cf9583098a1d67e709f2172c2bc329e4cb81f6fe044fa8b1510d0be201556c1f5d1590f8ca71ea269ed3ea6a4c975272d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
