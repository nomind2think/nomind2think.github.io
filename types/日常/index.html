<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f027a230399583ebc58d88062ec35100d28eb4b4058d27a164672cb6ef9ddc78259faa71e5e0450a838a1ff63ecec3b2c4b36f9c345dfc7171be118f73fcb5b2db7e098da34ac72992c954ee047a486c1b0775826639fc63cc8eda1cab749221081dda3a9cdf574e770cead9c19fef86a1247a2add2b4aca7d2a553ae56fcd140dba157138a3436d4505d8d5b904aa00f627d6fa09add310cedf08345f55a0f688691f8868a3feec463b057e4cf42f33e19b503bf01a5d45e4a54fba271319eadb242b45a7bbd646bf766fd2ce64a137a4f9d87ca5df704e6eb6e297e16e6808f073732fd8af972199d5103fe0ddda2cf07fa93fe09eccbb4874d92f692562cc7c62cb58a6d5a213666489819b16dd4aa32fd6229c800ddde4a79f3fe2b611e94b7196544fc3a36f40be7f7d915a98952fcfc0bec03106857e6b668f88c67e65742a796705790fa93c81fdd21c46656daa31e362aee9e3718a61e3f37c9f96fb017dad83a12e4664cc88dd844ce5870661836791045fba68fbdcbed1e6cc96cf2296518daf3c01c6501813e1468ff1371fb7a9e8f7c348f9bea7d84e4a18ddbfa82d6ec96e98187108823718c6bb213d0bad644e6817da798907d86d32f897e4cf51d2e4082b69faea75a87c5ce60d83c33746a954984444ed8559e05ac40ab1541f4e8ff432614b418e7aacdd351a4d768ac7a509731eb1a42130941eae06da386ca57689f70b60170feadf75ec4dfc5db3c8f1fd9772267255467d79aef29c33c0c5d77f1390f3e468cfc29837bbbbc7fb0bdf35bf6251fc05d6f2d61b52b6053fa4e0b153e3c369cd9bd540af6069ef618ac82bea3918f33278e5f1c213498936a36ee230d32c899a6d1e649e9278c0f93ce3eb7c0aafa406333c78c67889cd8dc5ea9cce14457a7b1c946e5b7b9e94e7d3029b3e5237874319c5e25e86e0e1a4ca0b4208bb8c5302cd4a1e4099eb8d65e62e3d68060ab928f541386fec32d55b715109b2ea3d2fe98fa58458b57158d888cbe1f006012645f6048e8aeb6e100fecffdef12c0d5496786da0d079199ef879da2a8c4496d3a006cd4a227c8eb61abf22bf31b017e7fe00941770bb57fdc1659dcbaacf77b31d6b4b9a137a059a8f4eeeaf23961ba117fae596b8d9cf36a7265c37ae0f09297b0a1d0cac6f4a2715c93fbad299dcfd483f4bd60c2a2336c8e9a640ebae4364f27fdb67595b653a81f19ef713040e97588e51c3def58e324bb2269c2f2cb89f78d6354cca88fb84b2f039ed960b6ae72446b1f6e4c81fed1e44c3c9ac7668be3eb235c9ab3b715eae8d6adf0b91a46f82e4317b1ef5a51a9e71a86bf0cacb98382b9896802de0d543e0e8dd2071a1c8704ed19ccfdb9e35e14f5bcb213a2266c95bf0edd7d52720d70f224a9a0b0a02cf0846d0f992ab9ac5be82c7cf0afa457a425b85915af1ba1eb0ae4627fc403f386486fc73c3a48634474c4a8411dd9e0236b86feca433e162fbf49b87306eeb1aab332250a143a5faffb911cceff2b0392e2bef62d3608e4082084b01e7998b2124c202bb3082e11fa60faa08005381cd7ec24ff7911a1fa686befad205197849e0de5fd9db68ecbc0c6916456b0a4007bb41a1d429ecbd963e0afca7285fcb5573ca9aa4fad36a7708884f8adf411f513bc924ff1a89b7461afcb68da2b674760f219626dd31c9bfefde6daf1e78452a2bec0c512cf77104152d2f33c05300b1a0c6ff0c99b711998ee69d0dda5b0e52c3b7597865c062f32869588f766e6dfa3363f2b36ccb48c950fbfbdaa1a0321c29b2625547cfb1b81624a6023e66f2b35ff9acfef12bd658cf6202c895e174badb2f4ad7fbe041eda7181108c09f2f40a875fdbcf12a718d6bc33fe958423f05dea3343200fd7c750dc564e15f1e88fde3832cbad67496976f4fd82a508e974584b9d581e05a88baf78ced48a4e224a44b4f60279abce36f3e12071280b0906933bba66150b11ed9d0fc8f61ca4b12c6bf7c3ac30304cf91992460293ae47c9b13c8ff7f364d181d78ec7f2839288cc72e77225ddd021f8b19ebf38bb663cd20db9f2c76cbff0a688c8304b52873dff8c3c885f61f5332a45ad41b2445619ab8384ecf7ba7e37154c0a990f22fdbfeaa00507de1ab83ef5b9c6605343fb63934d66a2f1ed55eaa97a7dfc53f51b5bcced6c142d394b121e12812f9e935e40c64bb8b35d3441a8052af1cc42cf1a3af4fca7794d0f1559b952c906c5bc69722ea20e3759f0c40bd933d5461c3820d39c2a6ad8b5af04413241a207ac44f33b152e7f464dc14ea121dba2700b2af494dd0feebfd5e15a0dd6814d3590c1c6491ebf8f0d2eb118c61626c5750555ea3048302474397f2a76c8d22de8cb7291d0f8ac7275367bb1cea79db761e4df4b21de13bd24375fb43b4d2ead3270d77f651f432457729bfc09bc69512379aff2c0ee0dd3803dfb05b48cc19aa98b9cfe8d6d26ca3801f9e1fd80179d73e98e870b4723df8401c8bf5c0335ebbf76a09c0d9bb596e058f4c4878dc8a1d86a4f840689d457a2b9e04bfd0920507f1375eb10ca025959c441f85a70c9d9b360ae4e510a38ecf94edd8209e798a758454611682324e61e277d7306fac33d7e5f1c693a2667e923d47df78d46db756065cb096cad0b2d01ba3b7c16ba876e40c2bed49d7acef688b567950f6c809c1ef72abe7fd08bcd4cf9632edb27b5514102977aeac43bd34cb56aa5b204e728c03f2224ce6cde9c58a9c859a8dc5fb42d17d9a0ebf16287d230866c3d35c8408f36b7d10366bd066d5e1310cae63ce03a40d953ca4ef3fc4b496d72cf1b82aca115400a1a2142614a2637192de804ab84a7ef9f20f19ad7bcb0c3580f86f67896c628bef9832296492b39a2609d9bf3ec5b1fc71da8d725db0bf40ef6e98b74ea45039f0870c5021c70ced64cce41177163d6f74da7f1ef2e26dc6f10c1ddf07def3a75c31c93002325952e441bd2a00e4a03739c1aadac0078517b435088d7bb0f585d0ba0a8fdc6ca24f809e162d0e4517291c293fa60fe54ecdcf6309170b4bb00f4a5ce0fbd1348aa2899f6ceb52b1da398aba7f3fcd546818e15f0b463ed84b8230c038e02884af60e7ef0909ca74201aba3c1b5254bd40814cdee99be17b0df8b2d573ad8d6d2ad4a471e04f8cfbe30a69f3e3da91e250b338638b6d8cda0dd9bb80b1b84c4aafeea9debaa74100f66e898484ef1ae53659a5a7f9c3c21277e91529a82cee556c2b15c3eeaa827d4542cf08bb75506a5c9cb9b09c84aa4982d97314d2b74aeeffa6d01c9b3e712c8d60f21740ac31e7a3fbd1f8d01e65053a4026c816a9dcd31df0e53ef5a98b0a2508a69464b49816e3c2d49705dc734cb410d9700b120c1f914de3b61bf929fa2c75e6b627a12d1ec291f8224f51a888c7521cb186a3d6347fe8a3fcfc2d8712ed6106a7e9441554d0485039fced7445e8a5df1b5a589c44700aefc6182da9916cc0d23483a4a94de44f1ad65448295eb8cbafbf6991cb08804fb9e998d7dce33b66c7c2a0b0197b95ec0f00b9e23ae32a95b9c3bc0f33c70b4ff61c55af3a4db643e219732bcfe32dc3d480be8caa221553bb47bee5f5a67de3ab4feb1a5e1f084a6aacc1acecd77560844b2508c4a7c2fa831cd1e3748cf4fcdda7a5bc47df57a1f35f30ba1fa57ddd55b8f517f5c3445671743e51bceecde5051f99a3ddb5a1bc4818a0e906121c666f3b5c022dd7bb835fa64000a487329ce892edfc2b3a192946301882295d0bc1e1bf923f471d64edd935938aa018395b07708205ad59e464f239743da43717a46e40e10e6e52237085e6b4ddf6fc7817175122cd98550b35ad2c0f37ecd6c9fdea1ff82611f04ecbf7a704d65dbaa34ee69060d64234e2626658a11cff5b83570eb676b5b177a57484fd2c1bcec891ebdb1567f1b9d2056162be580d779a67632ee0e88aa95574e51c1413801eb38d20e50789a3067668f12e3ef597fb4c7db9e3929eb2582b66673c6a72af3376decfd012d7ce765e499a147448d8104d52172ec83511d41e5710e470a7c97b7e1e01649fdb41e798945dc92b33da21451db3f615dee124851affd300488571b69a78bd3103bd3aafd74cb1e11a0640a1b91cf77eae2780a4592674909ae982fc6366355cb66fca69d64278c423d3a3b654460b6adbaf261ff03c49fc5cdc30ab5063d7288aa814e242634b6ffcbb3f1da8d8a466e062fc93f82e4b96cc93af6a206deb31206d24560e0a0eea4c7c17303365608d553098cd80a1ba929d0e456291dab1332416318f437adb616d6b5cc782e87adb7364aa2f7082bf7d2eab9c621f09455002c3a0503c74b945b2497bd9af010a35a07e4edcda261c1e310c3faadb8015665fd009bd36030828487cd634a7c4181038be3ee5814c87d37cc1a74bbeb11c2d1d596d9789b19004eaa634f035622b957e1e303d5d9bfd8eb9a664ef705a5333bc98ff9f286358bf75a5ece080ac4d1f0261d51c46eff5dc2d667b687b296b4c709d3dbf3ce5cff9933caba0d4eca800747c34f2311a3dcce90b5ea84a20faec15b614c1322948f889727c2a92f7d852e5c7079c08ca3f8ba1b213fc4c605342f4450519b1f1ced7d4c105603b9bae6c59030b94decff97e5c370493919b36b5d32c36460405aaf679fb0295fe3885ea34854abe7bdbbf303ee94ed6d3151f20603a8cbba64949cce9efad1f34b5baefe54ebea5da82bf4ce9ac15e4a63f093b075531434febb861e120778b45168fe072941c5d7ac1b1f93f8d5073ff67d900d1bd5dc7aa5aa91de9ce84a6c23150c08a38c8cf0c89b07c17294037c2ad09554ab08a1b04eee168cf30d0eed9dfe1d2a09a593d1f1d5a92336ff9ffdab02ce69914ae5bce4ee29dd9e7cb3d903c262610e7e021d6509dfa69457ecdc755561788b4509687a48563f123802cd9fa12a2b2c865958dc510a507253d1e29b42b86c2c3c7dfdd39f716bb0d82d55d4ef1982ef8f64064e8edae8acfa7e73575f5a5b80db3bfe3d4e8817cd592743f965d3ac484d085efaa7f25887a9acee29d42ec712af8e07e6d160e3ab10dc2dd7861be0601cc7c300afa3893b3a1006620336f771d77aa1058d28fa4db701f37aba7b446043d948ae0d100f2f1424cfecf0491211ffc7f4f8a5e14ee61dbe1992ad7df7b4b65faaf476f6cb39ca7b5a37bfcfcb237fc41fff90242d2b5cd23ffc63383bf80041b8748f0d87469215a4e9eff8a4b5f3e607a4ce481ee76bdac4ee040c7ded4735de7815d40df0519d2ad6f038328f1de4e7858e87d15d14541d56b89fb6e5e92bf3119d9e1e0e22b81621f2708d416e8160042ef5eb0a7a443c8b75394e4ef0af745348cbf8c1e2077ea3be10065e43be67d743daa32f487913d85942371444ae0514c32c584ea32e80aadba270e9faae0c1a4c9f1b2d54bf164aa8b40b9d950730dca029142933e287f4a1f589e987784381c17756e3122baddca96ba5a52d6234124059cf516bdfcc29ad2223869c3aebd1ab0b58b1c7a977da6fc6c731f69f67c1cb28c35369ebf7ac64304378763743bd58e35befee63c12540df4afc9eb54367d2880a14129417e67ef05ef1fd2f6a003f840e0cf3c56882a7e0e352a0e8ff86c41c47835a286643bab27dc88e7a8297d8123f88c4d1fb2bcc3296fd5ac18d66a799ba3125e90e96a7706a59d091a2fcdf01997a01ebe32e547f09bffd14ae7b901eceb1fafc2793a981e576be4c268330ec8615431495c28a43626f6e6bd5649091bb6848d58ead532ff031e57dd14a053ffb282e29fc78a8ceb305b7c20ea302f47b87f56c027a1144b4db2c56ffad6129eecbbb609ecc03817d74c82994e08e9039d2231458f55a8fd98b75c3e6aaa7f18063911b7134bb966b4051a03c3b64f3dc8d7fb86159cf07a3ccf3baaad34c8422465857250ca5fab16287e5b857dec3c486fe03b6f3d40dc4c985283cad995ccda79ae712326e4a56bf0f4138b5a6c84840098a37ec5643b546dbe7a62d0bd0cf011fb576b2adeb85a40df7c99ebfc321d592373547028e6100ee5b1c99b0e2f89ff348632c641da65068b04eff4043e13d9f5b9338c7794f17cfaf9323546a07ee57670041a5a181649fbf067d80444b1b63fc72cd94627ebfd59cd00a31f4c734d1eba55c545eda6fba254dfa8cdc4db34fa5f9509e9231abe5d7ab60959b06f311c7a80b7705a6531c7fd579da69aabecd5c50d5f138979be9d2d30d645200cc8e137c799859590cf2f544bd6510023bb976c02b1ee20f5f1166104943d8a02f6276626064fcc8dfee72d06013adc2d0105f669b875367c4d57d51de3830ff7a7b0379e99badcbd507fc24cebe309f8de0353b927d79d567a066f24580d916b462052825debb07d3a3facd6bd03501dce9a909c99944818344ac20616e21578234d88f9019b5d3b77f63695791303099eb784e506e8f7e647d5075e9c2d404b615a1da205a021b952d770316c78fb50e0e399376816d5963fa51acc102335eced7beaa10352d947d96393a9198699b21d18f4258a61175ef87d1a2ce61ebdff1686764c0a67c5ffdd16147ea8a81d6d946e9004005b1e88fa17e24a89da5c1e8f12f751d5cd08367b036ecfbb2e8e7b1219a3ce2b59d97dea531b9f9c0f9cea2a719969a06b9241f73c9d89624b8d192af95c735cf011e5467f83230bed6482af19220bcf4c7da7c5e066ca0a1ec9409bd1500b19d310d99f351e85230af260da82c05b0179fbe767008af4b08aece1733884806618645f28d803797a9be66dee812232502103beee6d5f1078f47ece2377e695b06b9aeb8f918f57d8a9d95fe81a0c701c9a3eaccf04d9a1075f069b8707029ca4c1a9772c9a69637933886c3eddf2c20fa8d13bb8a6f3e36632947fca665a3f9329190b3365692d665f46c387e2eb457d12d5a52f834ccab906ccd731ec29cdddd7a300c05451577f1b33a8cdf31ac0e79fd8f693bf01a3ab42337becece854ba88a772e9321b5c9d05ceb0727603b626260ce750a2264cf748dd2712b8aed532d028b563054ac6b11bc3caec7437f586d92050686fda821cf27d376ba3bc21021e08c3a19446794cb533ab28068981f013e5303aa6d3cdd08f2746ebb0304977a54f41d7eb741c6e4e5a55fbfe30de2655bf5f61dda40d9382a12c9113394f8e2f0eaa36ec36d463974e1bb24f32ce8f6f42923ce45864128bb6a7081614fc51201501409187c27e117562e8dba2bd2b9987f64d04b2be29a11f6be865645f245e36b40434712ee2ffbbec4a13271b28d3c731c7d182460b902bc9d7b674ab3fbf03e0591c07ae39ea1abc9f5720f5ecd39fe9bad5fe2bfe1536ca938e36af80547c7d47ac91a206eb0df74924ae04d6110d3f5929912416b9a42e00f3a6797462d2fd85be315da2ab39d0656816f9c291aa66f05664f7a86a60e26cb5a7da0610f084871b4cabf148e2ed0adfcd5177d0a54b4cc2750ee77ff6f4a0e590d044c5ffbf77ceea7c7b926581f2eba67c1745f1f111c062aa290e0162ee0108ac13461ed879424e81bff72331e6afcf433f2f16843ded10944dd3df1358d373238b78ebaef837f5b1e087afbbf920348359b1f63ca2f1ae1a2c0c6defa51cc9c42cb3d45e3c9ebe56b466b90a9223212f04350e53610c829209b51509782dfb02ebd04fb7cd7f6fa69e110ce9845bbf91943c2ac91cd0fa7a00c9d58075a204a2fcd1911224b9d58210dfbe9caa380999979e4a6d8819b3e4f36373579828404a95515a82b4395def9ba50034d2aa2118ca09530f541df8b5c2ff8ee471087168d50fa682a36418d6dca7534b836aa496d1e1e221d3481d8a754c61d94b2e56826fb5bc487bb432eba5fca699db7c1a7172a1485ee3ebea3367c47f1c0b78411f76c717f78d72b9d875279c29e04cbb9c607da13be9c2f6594bd3eb1196802d557401ea8c65b55d118eb74baa1cf1e27190ef68bd72ccb863bf115ee69993576647d3a91725d0210e6320ada1898fce857ae5b84fce3daa7b89c847eb738d6b256756be6df9ae8166ee9b781abdfe2cfcdcca6f6f5ea4f858acf7e16f32e5118a99f7feca98d502229f2244aaeee058b2f72d85f963d2c1e4262432f45c78be4b76dda95a8a49bd919fc1ac720e770851febde0db592a0b855fc8701b72a5f0834ac2dfe081c14275c00419111f05a907399b690fcf9b15b5482bc0c6be75213023f7c988ae69e70b8f2b922c2b55ef06d4be80bca130e695dfc54949f48660c0ae182b7e1353267696216752f5d84df3ed8d16de85bde2d141f881d392956d8d57d506cec78f2ebcee51f6b81ccb1af7cdc74a1f9d6dba606a41da16572226c0ab17e1025627067d0d9e16b47969a68119c97a4dc87c15b49f35d3c84485f6b2992453d8b28ca20807a5a434a18cad44757de8da0905aa9a726b6829d512210237e262bd69211ffeb00c5b9dac4e7cefcfa10a6fe62aca8201e16ca8694849da8df75a680bd8c45360f3edac7085cb4770cc9265e884b19de098655558ad8a04764f6ee6d1b7c26b05dcddc80b4b952f10ea9357af87aa327dc12029676d7db50a8398c49c9d862efbd54e920b89f29505700a4f14cc81aae6a5683fc97e680ffdfa511337770d8ff532f9489ccb61c1a7f1e2472bec4c3aa1ecd67d1505803876f7ea9113ba68d020764bce8e33897bb9d69da6f20ee9979781229ec7add204fa1b7d6bfe4b423544968efdd53c880c1ae9caca990576437f1f587a4918a90f9de485e8f2dc15e7741766f1552bd3c10fc66c1548c98a4e1a8329428a69e993ca1953256a725a79f133029a1876427e99bba7b006930716d0ab59f12bed8887d47f17056f6e80a151f03193fd52b8d54943b62445febad8061d06ba73862460b43e0c45560db8a40cf61692087c7d201ca137576124ebbdb6eb81da408c2ce5576b545cbcd36a76f7937434d22d09e6058fe722b8e0645ee85d03a13679fa3a1fdfa69ceeb090d51b618bdbc426cc76e8e45c701ef9416277a5a7513bdf2bce7d737ad809a896d1f39321b4108407b6ed2b6a13fb0fb90e2d0a0fe47f7663fc210d53e737ea01aaef207e96c0ba511d4fe278aac8ccb3dfa7f2327fb770e1eb4e474606b533a8a004fa8be4895af38b7f7d9a9f5f33403db197e515751080bf771d7ca2e8bef75886af2022bdb7988afc1a74d103844833c2d423757442ebc407148627234e35bf762c192b99897cce699cdf4d1f00b5605751b9946b298e4713142978a4b71da7a4a1633902629e8539731eda0e06f3d224852c38cc77afd25c23d4ac649b896652dd903d84d15410489de6a9e8781bf81d3a96f6968a5580b2d22950b4062c6d9676b60246cf97f9d81a698c51002c3dc97651f8aed916db4625807785fd998cd6f2c33126df7cfed0315dcd8e95491099e5d77fba901c7c7d5932386df45503f2a8b57ea755aedeff2c92a404fb4d268c6b275d5605b35f73b661ea89308a341fb6bb3d22a5dacbed965105fa2b0a3d630c21f9d8f167ab71da2dda5c53c6596537dd5cf1827cbead8d2cd9be1ede3b6728b9b5b04925eb73d03a9bec30e600cf97033a1b4ef357182a4f6ffa626020e544df0c5faf87994ea982ae4affdc6f20f05dfaf217ac4edee7ae820cfdcc7ea5b853f8a9472294c5e297be239a5b8b574d7619dbb969f6f37e3ac43fedff3f08fd2219ebd9253e359e0d3051b4bc3c37a8956b08e8af6744b726d5fe774ba17758b8cdbf8528b8c90259ac6554ae27c5fb7f44b5126a4718d53abd55c03863ac42f687235aebfddef62cf173e4d8e3e5bf13aa3140e442ed8bcc773ad0705895feeadaa9a3a504b9f61ebf4bbdfb0fcee18f572799585a1894930091af59aed069018ff16e7fd9bbbed9534ecb85b004b7f685fa0198286744b6c08831fb1d392b7d4c8ef73fe116210035d7c91ef501484b49231fea9187734d7fc59ef8de5b72b12a75518a9c7bf6ccefe87fcc36a0d0c92cc84feac498778396b8d1e718778de51e4afcb2b60c26b2b792ff0e96c086816608781b5f43f02240d80725d43702734e58563fe25fdb32dfe3fe399864067f2ce11318f69003b0e6fe35bc665acc6fc0bb5544c2fe31fcb2872d12e368789f4bc753ae04a4b9332b07e0db65bb3f4208d58446147e45f915fecc6107f10bad913dbb7f116306d5899ccfd2d3ed9d5fe870b2804d617a7b837454a3b694a24ca9dfa05e8697def345da57f9c690cfd5e94c9dd45386f0dcbb0b967401ff8b515180cb062f20879d141d4ac66f782031dc308fd930ffeca6658be9635020a90e703cd047735c206812bbe41e0af5ab7262dcdb775964fe01f0982d44f05cdaffb65eab37f5a1c3cb8bce11c9fadd65d32e4d6783252e9591fa9af3149813b96f9e59073f6228468cd1d105f18a17a1d3503482dd2aa6cacc6b0c046e1948a8c4a5214036ec80d4b4afd7e9ad34b3760e36f662eaf8786fd14c8e19349844b2c28ef179785a5b002875934636a61b93c24bd6d1fe27a9c84fb91185baa1b9fe82f84152156ea67db6a935f6608df20c8a141d3cdf6798c0c5f124dca7e3158da776c39746275d103b6f296fd4573639a6cadda8636147360acd0162735599e7a0b5405252e5aa934403e92fab97f1efeec53aebf3c3c3a4a0b0121698b6a174460704a4c15022029ec2b13bdd3c025071ecbca857f00f1f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
