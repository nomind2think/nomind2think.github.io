<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f41375e2b20dac77b992e0c2eb1260481f0269ccfe1ad7a300aecd27d1413ca8e2e5b12b7e7d6ef93eaa4ec8766f397e6fbf7f479c50f02e72c2957cb3926f15e4c7ecc08fe22a275b77ea33c14c642842b308fc7886ece84fdab5b5033b02f8cf93b2eba507e49829fbd257e27cbb1205ab84ca588e245ac2871060302c810a540d618f621d45739698b69ff4d67c357754e7ee9ae2123b095f7a158d08b769d041d05098bb8fd2eaa9a91bf988044be2eb86ac15d14452912be8492185ae53f95c1df0aa3cdb25bc7e658df8ff83deb7159bbfc58a742f44c2def79d8b0286355eeb4e64b55d2d70763e0cd4e11b1e58077ecfd4da2f9e8b467a0da63cf363906ed4ac8a2d9383465a48109a70c05d8922a88b24e7c6c0971e740397a1b4c626e66c62705a7453efe6aee920cec3a3bbb0fdf878481543c6a5326c814bd0e45f40e27a7e14165024817dd33132dd29e1ab8cc4087947f707dbcd52d36429ed88562f11b9a13b95f5724366c89b395d7831176ab1fb0b5f4304b4fbca4e98f6b5d049c593ce431ca4038f66d2ccd9c2c60423d4e6124af6e4dba2b8d7f4ea7ecc4612304d3b23754688cbaa2688a57c1d6a71c85776ca21c8ed4dbab9e3be49812d34ab8c590bf83c88f3a91350bf1f786047a8cb0d92468b8b39d091f139562f034228edbb554b3ba71ddfb804b389ca25b33a87a67e8f08e2721b317d821718a3d562f7215cad7ece733b0efd55c71b0953e117f70a14c24d645989dfe746e65b5784cf1092a8b3119e26dfa53728d79a1466143f20da912c95f0c9eab38f3b9b8c685716041d6a70108e2998a873fb1092a5b3119d4625125e7009559f82550b34a08b65f14a5346e94e72c169a8537fcb009e00b7d607a5670fdff694043ea555f9c3965b4bb51142e3774b78acd12553ed1040712959f47839a6e92c368c41a5c5a181411f57f117566154c2564a21052bf0560596fca48da3e56fec3bd63f150fb36621cc428bd619c67516abc4bb3abfd8f1550ed5d985342f49ba83c6b4f52ca6198de4fb79028f8248ce5ce98854b43bef8a9f021f688c2ababa460b81032447f837702b2ab41739204e4c280d2b85c8a2ff290f47b024a9ed729a6f467d06e896cee48ad31f2ab2e8006ee40694e7c2320c6132e5ba6d7cf0bf13a86846919ad3edd1526be58d255e80b913e5c27bab395077df8b39705505fb71f480846354f337952b83a5d740278523a486c0baf9c78b00e3fbc2abbbc36ae032a3cff5403d2c537fb20145b809f299b5cd0e5cc4f710ce3c1117cf71a40c11dbde9918aa39a1dd5e23ca45d2f623955d43ea7a9ae45cb1ab067c6678b6127cea7e92d45b5c5df8d1716e9be327728fe25b85051658d717d91be9b9d5a64ab001119b5e46eaff7671e7d40bccbfd4a51437a77b2a33189fe194c9afa8c120446fa920e248cc8506ee8dfe4791f22063d905b8abe3e77f8635c85afd7ed4213ff39634a4d4321565f5011d3504f092652e2ba71d8b41d49c5a9e4a9ff5737086a377397c29efb2dae1c7d68d1cd08565c6e8e40d67c7201976cf90b3d0e0fc655459b44a1c1b66466e169aed163d4301daab154fca45435ba20e91e1c39519c61108ef19a579710bdbd7d5eae3bc56f99af6ba778552bc39fb9e616237753e3166a4d67021b625c2133ad99d883c128d62c583e3abe8d3846139292ee82c545efba7dbfe7e7a9137f42336e7dfa8e9ff625d870b4158a8f80a982c18ded8e4e42eb473b03c88f32c5d9f4a8b0d41a302be486efc329ee0847e1d7e9e6d299791a9b6624f61eaabd573278bcebd3b90297f4bfb0e7286bca3e46693186b02c39c3fca5f2525daeb9f25757c02c4875f02c0681173bd1591bbe033ccc0e9f571d9b9b2d6cc46abf598be908c1e509fbb7d0b5a68435c19455400ddcbcb7d426d39ef5787156e4b2740e5016d1b234a75065e8c366a8ea4deb82a17463bb5653e9b31b7de0596415ca7e962c4e8d9e249c2778eea6bde1101c7224c8785b8379a41355f640131a9843658e387fa1047e66e4f32889262cf928cee1017c5a7ad9444076bfc297a120a6879a19d657921035ab27a7ad23e6d5f2c51888c8322108c1e61edffdf944281b5e7773e5f0b4b8c61150e21e884879f3c32604ad0601f69068693676eafe9fb775df1847a5f0971da77839745fa18c7177d4080038f86dd03f6e2ead77e39cf20a63bd638615763f13ca96c577a2e5ab080ebfe31e6d256f683c541e8198be383b027b0c163a65197c111855c00fd7d0a5772534f775f8e27b697e37f1134b45e6a98cf3c0d37124de28fc7983be30c2e29d48bbe9ec886db3bf900255bc3d27776b796e43f4a1f39087da65220777c3cbd71babe2f5669832cea9cc48834d939711a44b7eb6653a1a9d9e8e0fbf779158a3f1248a3c8df61c96132ca40cd4a6573b1efc0b4bf46372f47e33a0cd6c79987dee2d56ee22780c6a711fb000a9cde79ce1587cedb24551ae1b1882c141f6f05087bce8717c4f867509af63b7663f2d6077cc62308996ead95e6dc015beb400985dd576053c31707513021e726f1a4bf6c9504c7ad415a21e8083c3bdf3baf69813ab874d94d49bbb2413979ead356b77f792f383cd556fa1dc8214f0354c042b051c813db72269f093a0d21673e3b44c45dcf53627611c041ed659733eae95af377a3b6a35625d7bd87438d79f3b938b696f109c9914fb6eac2ff9e40ba3f7b34a639e885bf41a57ad013f36862d204204ab91de6bba7a25b526c9ed9a8366a0eb989fc390d6f406fc531d65d83f68a5eddc4fdf32839c4d1feefebfec0468be68f4eeb0bec82073dc7361325cb5171516868ab786a6dbe710153667d4b128e0ac2e2e15aa77eb9b442b0c8ad4516c137b35e0441809a73e5dd483ad600a99b9d738c9e638f5010f27c6acfbe9139793b41eaf522279a772f7410db1ce472036ac1826195b1ba9007ba70398be23dc7fee65e3ac6d12e99a10d9c9ee9d55bc2dd52a5f0a986ef07d1c2932ffc38085a7487acbaa7bed255af10561904aeb4683be69fa1d6ee05334e7364090acc4d1e524849f8f969385658c6b04d2120bb1e1afc124239bd7197c03a7f16cf6059f3f35924a73e56f4cec697e2a89b2608d7b19eb8fc18631e7952ffdc8bb9880e1d6ee1739a457358c7e766a56ce2bd92086337f28004fb1b1c2943780650e8327d3e3b306b00ae5ce165155080e9d9c0c7b15a555799059880d346334b1d2b5b5a2f06acf9f522d5895151b42ffca30744fa5ef849fb838a449138fbbeb504c72657e5009a8e2a3ea692d43c2ce216cfd93adf8e31f1fc8354a8a3942d7e9b7268c817a0b0a5664ce1fa02d8182a8dd313ea671ad120a5c0686c7e3cdbdcb48cddd348899d65b2fd29258cd7fe82320ad034b8cc5369865851d2c30d75441d4e36e9d41e27d97072223ef9076144f03bbdfd5807e7770c2a2355558f55905bc23c48990d56fd427df06a38b0dd43e6a9d59e4cbc8ad68da974789afa6450aa2bc02f36ed60b91c548f489caf3d02f779bb4632967466b7a41d036e9c7646c0d1df0ef1ddd9b39a7ed7a81f9cc328e0b89718729dc8a7ec6ffc61b071034f98360add5ebc055b9d46f7eb1dee1d2927e8d65aad12d005712e5ed842b0a969c126e3d0da21017a71f156978f06e61f5e09474fb7b9eb725f19241e3b847b39b61b34afd83c861958437f3044a03ff9cf2043609281724992181dbf4e90e5967394b88c6995b4d5b608c46a7ffa4059fd2435977996fa0ea069928520cb8d8f6b55045847d1c408946dddb99a421ae6d6c4e13dbc59fbb91c0c26ca8b0a8d55e4106d593472a3251a264edefb34a5c1086837d0b6a0df85f8b9eaff04e608bf646c235064a0fcdd309f3c30ee68cc91b98c2a7d7a6bf84038a87ec67fd3bf7baa194ac2f3ade8746329b74c5585ab9b27529885ec735177b6a993089da58e41153a3bec56c7b8741160a8343c9cc56f4b85d6f099037ee78e8084e8b5f40ebd3cb6a4cafb15694b1ef2fbdbd8ab1923402ce9b0c8f589f796d7129015f86e7bde1c1b828c4d54c59c76afafc93a3b6b4d4134fe3c8025a3e5551be2d3a8ef766ae87fb96f25bd5045dde33ab2175a4c6fec824baf1bd3fb09e61c9a1e5599bf19592fc37568d0771af9490c97fc03976273cdd707d021d79277d2f53624d3191b5aa6f802792a5bb6879627999cd952b0500bcbbd5314e38d22798dfc2fb6ed98f66c7efde3c65d4ab6349a1c8330cc24321fe96a7b2207620394cda55f73871f295c40a776c8da7f724b4bfa8c2a4a21497ca676343a6638c708bfe149993312d48aa49e39f37b6759c5483bc46d0a5694f28c36407a5a59c055411dff1cbc5eefb93cab4f8fd15dba083c0e672d3056d3f4616201772fe21c72ecc5b6216dccbd4ddac4c17a0938aca0dc531e5aa7c68a468fac17b6919a774181812655272331c8135cb133cdcf4790593544c976feaecb341a90ad3af4751dd1f2dba7637d7a67315e25787ec3c4cc09bc57bc39c00ca012aca6e1b9f1e8683c67bba884ce11c0e6da445a37597392374deae54c2971dbe44990779b4139ceb84c7faaaefdc3164ed137fb68ce769bfe0d37bba2e8717c9e693a0fa35ea851b4781d37a18d12b06ca2cf30a3a6e682e252b7060e8dee2c0d809f132c400494480dad7817294eecc26fb7b739e45cc40c7b94b856d2b4ac95b68c5f425d43b9f10b9176a8771e41041c47f19b799406d2a7c1bbca6838d767ba9174020ba9cf157e79ffbffac61120119d0ac3cd4d80580414ffa2d5afde84fca0d6585cefdc4e4903be9efdae563f1e13e1b9286b40eba4d121b2ae37a53f3c84d22b960831d34392d904991d05f652551830ab82c03c5a7dc5c6edcadaabe29d5b417cf0dc55ce46ad60e204012460314826364b4aa1df699bc8baf2b06f0208cee2f728a00fcb2ead2d0d683f3b2d1cc6242f6615e4899b66bcb658138b24850a8f73ceb4e579617b942eda6414f8147281efc5581fe2b4ddc4a80c7dcc017f4db125c6657d640eb918843079b3f300377c87d4dd80dfd93273516620be7fb1dab3f1a25be51881501acc734e98440a327a53b651eb550dfbf36e132d5228227e12eb7aba53316ede7904faf43756b76b76955ce34bed40e6c8c58ed202fcffa87492b5398e6b6008bc15f9d3a0aff92841b31cf7aa6706452952dcc6784efbaa28822d6f9c17f5e13fe00e8cf6f3aafdd62959de7f0e80329046fde6e4afa845d3d948882f7c41acfd2ce1fc097ec4b8df895efd43a7024cdfbef98e34cf7ba5a25536240213de285421595b0e05d534b1284a469cedc2429ef2863815033f634a72f703233e893cebc5a21e1a639d2bc6ea6e6ebef738571f4a831c25033496382567392043579434e0b9b0201e945ad8281e55467ca5cdbe597610e2d088c9b46ca8f349f98d9ca711db8c13dac507121dbda2f801307c3229fc104fba9306b7849c42b2fb0b5d0e22878388831083ae1415bfd89bad59ed1471034b755afcad3af726490ebc9b1187645333d86aa26f03b0daa1c3efeae3aebfa94cc9538ab3ef802a5b4719c91c92917cf7b8efdab3f4b4fe5bf216c46bb3f4b04f3a0191093461e369e9c5f8338464042bd2df4a5470794a4f4ebdf300cb7a2ed45a209f2ed469224414af5c4d31a12f9e409ae428edd42a2f58da26c0d5fb7de99442523ff3f1564a45c2a99df0950c3ab257bfd0cb82dd722a1ad987d778c30f733433aec75cfea0d169c2b8bad64b2a4ea8d7039d4135c1271fb797e833696ac44df82e709a1a653ae0f3976c953c3efc9008d9c5c50c2f98e854b63c577d5bd4a28a91fef5ff4f3ccb3c7b6b08cbc510199d55245629bf217df1f787bf81915a286f6681662e097e5985099049254248c36da8b372969a11718dc9ea9f91fd30ab14802c069e74238ca01bb254d6349f3d703586c583007d6a4a8117d930d15365d678991e94ad481c46a54541cbfd71b98047c486835f03496dfe43c0f530cf59d697e77769982609e30acfacb48900f2228af40a8a5680d1b5219471bde4f6d20a5a7af302287e39a254a13922f915bb2cb245cac273798dcab395fe58d759e2dda8a0a8b793020dc3bbd735584ea920f68808bc61c5dfa54b4262d3ea7b9f1d4192f0b42092452efd4d202a668bd0b1910321e7d28edecc4fda7461539b30edee0374898eb3f74e03920b81fb15f6a942bf235de930bc49feb92bcb4fcde157e58634989df4780b3f7d0c12b8964986f03d657d7fa1a641ff0e8d955c3744203b9325be35e7d38248dfd9c0ad2acf9002bcd7c99672209baac965bf7a5bcfd5d35a847d0944f4178128b9fc846f51b5e679881c0a8a726644e155c48e90316bc83c71ed165469492139a575777d3bfe982be33edfe9616d9aa917ae895246570a87dfb4bd56fbe23a7d1dbbdfcdae7a76a803b769f67d6baf06c47ca12097e76d8027009be5255f14b86805593f2676b8d6e1e06d33a525c1711c519b6eab4f07b7d0e9ffca22402aa7165e87bfcd38e9239a68266d9e091a7b84079db051d257e6bef14071f474d1523c69f914c952a995d3450545a7be11ff870b475da9e90cab1f2c4d8e7c5a964dccb65a9b85d4e2f28210bf2a9a323fb7f2c4a6b57bc5d0a26314f2d87ee04542d699c1cd2b1eaa6693a0851138b64d8889c8cdf09f80f1c6906265802e63ed0d83e9a3bc59ec4621cf3db47074d9f6d5658700628f534a82b3a70c76e4cdfa10b3ea9944831d54984b44ed8bd505726df907964c21827ca91288a94c576d7954a4f73247aa29aef5b2f469baa1489d34c2cc185674d9facf686fd0126f8cf680eb4bb9fb513dea14bc6c044070ff94680cfd9665407b0a40137a9c9e770f08dff20ec59fc5c56fc130d89118024f5e131b713821b56b6b995bbc4117b84730ac8b3a445dc67aee7889578005277162da4cbe0f4d3cef527cfa3ad1bde1cdd8783ac43234deb3b281df8317ee2e09d174b1d0d2ea7a7c3049874d025114e0733ea1d80bc8c114a448a687f2e972b2cd59713535cc01ceff229b1808208468a23a78cd22492fc9e749d84eb4fa2cca7e4e4710202fcfd6ef1ff35a2d9325011f6d6f1e2a4f02ec712d32d07b44c649d23b4602ce58a97e82e36d4769cff0121a0f84d39e5175da963a6a15825d13aec1575fdf079fab1a991685db1a1e965b5806d93498bf28b9fac68177eb03ca832cc31eaccf2dd9fda9763723525ea3338aa4886f67914bde4d512de0a3915addaa032827357d11d90e00f91ad6fff91a03cfe4d7b2f14ef1a0b16c7644761eacc7490a1f660f7bd72abca58dffd20a26383a7eb49e7fbafbea3bd71e1d75ab8925f66d3831eb264839421877e74c3f7b809cdf71d378091d52e26973f4db8623fb036d7b59100d12b38dba68daccfd12a66d5620cd52ef254f34bf6952e95ad50229ed40252bc907f7d9191d9ca6757f2a0573b4bdf39003e90fc557f0963656d78f91f3cb53988347e174e9df3046d06475f0e47a8bb81be63bf786d3a1c1e6e33cb62eb1565125e0fc2509c0ff6e4d449b980fabb10dd76d9d4fdb5c1179409568f8c07d134379558fd4720a384a8c8b3c574b0d62eb7b088e368f14db3c4a61a8a5be1b737a955a6d0eb677b3e1b7d6218912fbace66dab60da3b47502d3e079fddd118fb88d947bebc0f7fc040e1552c5982f8961f17182d5da250be2927a6bb567663b2c01f07792572619b93092d6d1e3d4161290a68bdc6917ce43708c582837b02f197fef11f3df5bd12cf49624bca7c5ea8b1262e0607e84d756847d65365ca25a392bf8d09ed881ec7b92545a91767863461594e5d789a3a4bd81f5825ad7b15cacf51321d4be0d3a3324751548c0d6499397733149e7b52559189dec0182c9f42e661c735d37279190ee807c058eba789ee5042a99c25bed81a9c3a384c6cc4054d7889d371ebdaa4ac50b51ba895a7df06b0ada026590c96327aa0d122fff0a547d510bb3b8d154b4e32a77a1f9e61b75738bf339734ebb5165e802bfdb793b46399526c6bbb3c1ad2bd258ce4e6bd13c13b04e32dcd37a82d0d1db07673dfd0098713a782e26eef661d2763c66e1983ed37ca59860989469b3bdc0f999189459e5861841958dfb71a660145bf0f6e968971c914b46e3c6ffdc3b99c307a6db949f0520d8a1b049af3d99e5ead56035c4fc53bd0ce5065d692ab09829235b079b1f2c8484797dbae0822c2feac871c0f181402c8fadfdf2c8c94f89d0fa058fa4606c20585cdc57a1894ec851b890985bf3cb0880231740f629487d6a35855cbf7d7e6039a5864b62040fb884883c2095e1025db23e7aff286bf471664acd14e76215cb982170185b0e1acc024ec8fb14894f407f35b502c3b77c0a843d28a0cb4102190982a904361e4002d528c0bb05169786836bde2394fa16246874f095b17e842f0d40c9375acf6f0ee434128372481a6907442c5bbc285348bfc33a0a1f7cf02e0fa7ea4279c4a462b2d7001ba2642881ae4ae9197c64cb296edace2208af98529bdab019748fc3fabb6e482b27c1520f0e1a56424c6f462763554763f10a22786ad3ca68233b542c6552d8c4ad03ec369e50279c2fc87231e9c23b638a56743ada68367e09940378347a5e200df3ab70331804c926f2801409c0d1022fecd9d874fa3381523288ba88b3e73b20d692c88f0806c01fc0efa9c637ac9d59829b5f450483857cd4fc86fc6a21737396a578db273c4a7b083168f552ffad0749347bcd49efeaf97d76f1e1ed15acda779a9f7c379d12925eb1641bf6922d8fcbb617250214bfac398180c6f410a27125a7ec3cf69952224c161e9fb5beceb5f9a86aafaec0b1c16246ad7a6afdbfb1ca7e5716642a8c3c9dd474b429261cdf26bc181d48c4dc78d1e7c574602a24c6352bb21471416dd21769f4184b8e0efb2b677b2d896f4280a0e0e81de5c47e3dfff4999836d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
