<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a375599bb8da76042cf4eb5aa57d0ae3436493a483c48c0ff67b0de1be3a54a4175d05f38f20b339be5e54069456c6f7dbd52eb0f965809abd26e2bb86b2ba28e4af97a817cee56bf34cae3be5008f727d891c2dde35c76b2b796abd38a1450655307f07a45b7572ac456c227160e4cba45466edd8302a6031c574023916347cb1e09d22049434203f89adeeaf36431e075b271f2a9cfc7515d23c568f0c674949489d2175e13c43560a5ede3c04e1777f4c45f22a48c8b439181ee45b38509b9c6c576bbfd0ce2088620ed2de25c27586ece521ff860bc70f53aad16a4c20fb19b0a3c2dd0b8ee55b0b3202a671fb2d1727a9c90e91aabb456ba6e65c2db0de5a7940ad79fe58796fd36b7a047a55e0859c417c7d0960d78d2b7d3c53e2b484d78443ec868a5d0956c3263b40118fe06247c888093bc69006dae11c1aa804a074311796f3b08cffeb98482d00603fe82f1b57d014188a77ba613bddcfbffd1e2c57633fe165b50bac795e83d6a16e542aa05058e4c552505040e37f2eb1290a4e6ffa37dc7bfb43dc52a877410608277a88877e41d8346a77d53a177e692dbae4a64b6f1ffce0d48f3064c11d6cd0f614a6c8a4f129cb7960094fd9cf417105968b877608558f84ae42ad7f0aa6bccc62dca357ce11054ed1a1f97c69bfd59d2207eb5cea4e44f964f995acd3b74e2f49ccc5d5a5d12f6ac3b45c6d08c051e8c88dfe627fe9ce5be06271cdaa78f6bd26db556a31b58488ed8266402cbc744631d4d6d488d7bfd104485fb236ec760aa9f28d3fa43d6ca3b6e81385bff26c788a4aca3c99fe0a28b5e9ccf95ec4e5d424f764a45377b0f758770ef8af22f3778a7c2fccb34e87628a7d6d0d7796cd2740be43d0109c898fb326582be3fa04f451e3cbb68ebdc73b602e0ff588b639c47861dae7ef2685be9d14543abd6d8ec454304164d635e57c85e7977c7b0a37f28ce39133edc6df3890f22d548da94657d8f244776165606d665c78d34a69a17b5ff30a37fffd499ffd19e87a25c8b1070d9a9c595955924928102d8ef8a5ef0fd72a58a27cd7ef9aad864f1aaff7ab6111bd4618c92ff14ca02c2340fe6038450aff5f8e133be005afb005a33e880a00fd9d8f2dc6b4dccd7f471a99a245a0063161b6a7750acc5ffb21219916bd30245721a10bf99bfce7d93c447e5493f82edfe0b30ce5eecc4c6b5a67203be6223779177d36f4ba971b9728a8c567d9c2013c4ae6303001df37f14f746c772ea7c63a75796277d1fe1b41de9f06a3e23371db8317dc44424eb0ed8b7daf839d9de3498a4f07eef4a318fd9cc8a0c3fc3b891e6b232cd0c6e37276d60ca20ec08c75b91655ea230ba4263243547aefe65ad129b7662caf11724f90de11e171107bf8e697fdb8da0149d385f4167f1487c17f9b7abe7d3be87d4291933e0e73c49fd57dd95250beff136aa2750bcde69ca44d9b5023bf213d8dd10f8579b8a1604930e207a40650a5aeb96d47add15c4b21f16074226c93b09850d1393992cece31bff9d387475592a6ff7a8de0036b5ead95fbd1a86fad28e8e996b7876522ff47970a044128bf3798472e3f3b6402e61acdaba874866a185e74b58cccbb2e508eb061c3c9829d3c0a023500d94a157437a68771ee13f4e560db30ab7568d6430c9261bc7a737c3890837f7c56277f944b685b05d89080f08bd69030af9f1de93dd22c2c140947667ed00b772dd3693b77959473a503652364e2a3d1d983781f7eeeccfc9ecc0e5850454f5fef4d7c7f2da32b578ac174effdd866b1ba6335392a67efee885cc4e6686c7ad7b7f2b86a7570c5a2dd7c3a57441215c53111637a4ecc878b2ae5da6eaf70a14603ee41961dd900d36f14fb25bf0da828e442edaf53b05a32aecd3d3a160582dceb03b46f6f2fd3170eeb7819fcc2774f530a63425d57c71eb6d739d51607e23f8f37511271bc5a72b4e5bb360bc57478f936d9afcee1c21df01334a6806681ece5f5b295273f43377e5fb6ed04be55917f3eb8897872a83d4e1c9cf888e5d86b1617f039b3115cc81b217766640e8c1d718f2297f161261bc36d6970a4557eead976d7b98052e0e5220b979b2ef2fda3b196ed047eb6447094e4a1f265e86199d77df8be1fae1d34cc3770b9e798964c7682ea5660a8ae50d10b8dbe6ebfcd172db9405f6703985be99164a4b8b95c3a0c1c609f8e5179d2b1c64c744204575152efb8368e1ac8bfcff8cc6ac262eea2b66ba9983ae44c23321086f30b7d983fbeda1cd2fb92357617b4abe2a40bc020dfaf5ec36f41cbc3f4b896b7983ac5a11ff15705f340ebad5572c19d057c75bbe43fd36159be97a4441eb1bedf7d10b0e37af3e884c1d44d33c9a6dd80d976dd3f4be1be62573a03ecaa1c2916ffd1142869640744ac088c6312f9a752fd08778a326565e3c506741f8a54839417845d13e100ed71466e8eb9f6233dae266daaa5335111f674dcc0126b15de935095d17af0ddc43ff0c9233326afeedf6f80641eee27525866586733cb4c88a896435146a84c71856cc33bb6b0120548c22d96046ec56bd527b593cd7250e549be510e5d5cb3bcef43a0cc15730b3ee2f60e0325df4c4b0eadc83843ad285159040332af07ffb24824644ca933cc0080237cd590ac104134d24de77660a82ae93264a60fdd91398b2e664fdb36525ecb3af7b21d594ef74fe7533a1a39046be1466510e39b08b01c9db28993cab202e98e24c5e8ebd2d7e4ede92503c4792b537b3428cf79d602e9a1189d230a404c14a6b55f221e7863f24f1e29f3ec4170e8e6898ace85a54acd66a25773d4029f0bc5f63698d40cc52b45754196db03b6669b13c7206461f2bfeedebc16731d143e649c7c61744dafd6d04fbb8be016c71219da8d022095424f68615c0b3152c88030b56c24a8425c99d9c5b0895116da05e656ff616d98b712257857ef657afa7908c374cafb7a138a0a3e2de7cdcd28375fa869b47d35ad039ee179f5a6a735b431a48f0d9fee54bc991334634c8c169801cd32cd943b31905688562eef94dd27635c4c4488af63945b49eb28955796b893a4398d18e966a734cc73150885c2cb35fa916342f818bf7d066b5cdb58c789fb03272c2ea6a0dc94c14c279c2914797f9282f09766b539c080511b88fbc5c931c3fef962d6a48dffabd9bdffbc8a8863c279375021059cbeababfc124651251010325c097feff38d4ca7025dbdcd47345d2009b0332e2e2eadae200859065589204b5085d524a4d6bab06b46a05a119ffeff4862c67841999458ef1624410044b6f652c2b5b1fbc21cf4fe154ea96d8b82c54e6e7bde9bb2d6190b9285af30aa5926108be696c47b124219e2373a166b5e28d0bb89646d7a45374a69c93017c19a8eddb7d28149aeba4c75088a035e437c0865d563f2605d9a574f1797984bca9a4afa86802a6f8c60de75d16322edccc06fce45b92e7ac1a396facd46f2b1068e681d9f6ffc9973751588d0608180bbf228fc56d4eb7b809861b6c1d96c8c865ae1557250e19c0f6ec99dbcee6d8c495bf6686274c9d0a15911371a71362891b4c0f86b2b8480ab546c753bf88d9f606a02cdfb2af6ebd1b10858b0677d5416cbdc2ac21bee0df0a52d6c0f397415ceab5ec8814eb97211950ef6942aeb6bbee88f20fe58723942db91e56c66b3ea22831c8017856a126369c44b4362c967279e0680717a8e5e2443442b20f65fabb3059a6df744d8a57385493730cb0f87df0f8c5ca0119869756e26d624d1944ee2d7550a62e844d05f5fb1c799bbdc40018171b1da214a131f4cc2773c182b1a2939ca81073a36a48756516c82d6e0a93ed9e1e823a2a7c9fd3ed112274ad80501709991da3eec7c34258d02249cf2d7a34a820f6efe09883bb467495322e87d04fa8aaf7b66942af50cf6e18ee7b169856d5c898b3bcf5d2d581f46eb2b597bcfd073b458dfdb4ab0386d2f66c021afca6de8053ce7339959544dd3ac4894c117989dead92a16b2f3e4ab174fdd83a61469997deb7392be6f3fb28c524ae98d93d5ff38cfe1765252537a585a1af09a33bca09d5665f97fe73df0aedd70204addb5b427a0c4472851fbe1282c0fcbf81eb4df8adeb0d92958d924c7d735ef53e4ca584a1f0f3ba1985ff3653465df40df2428f30f211a83b833bd3e75187f77838460308e633bdb49aea6ebe93fb3bf8278a19fb4d15f36cb0ce7d942a8cf1eb61ea1d51f28d4b77e46efba59709148bc28821d3141616586ca902925fd213e992db6f7e251ad39f104fe3fdb6749a4480c42ab583f509ef1714b846babf2721df106fe9e918e6e7a9a9d8e9f17e9cc4e396e840cb0f60670da42de07d22d033e44ebcadce9623072c3a72366d551d0ef65a34d027296c01230f661690bbfa5ab4d0157dc1a197a985219470f45893eee10dbc9b37cb4d3bcf60278242f4633666b735b3ceec19bcd21a76f29fa228dfa9f868c34f1b500c9a621afcaba3ed07ad82952dca40229643f44acfcc9c496b406ad5a36a882cb1a5eff32b12b87dba4278a64905fdf798ff772578deb2e0fa10083b2e39b145c2f2c949c436e302d6936ef2a234c11fe375c5163135b3699e51132391882c68c1ecd3200001c4eb6360399b34f604e41335b25435aa211ceb884e0fa1426d1010e34a78a12efe3658c25a50fb614379ec351601eb3921919698719c24cae8ed7aec6c3f349f2ec6b05bb7ddf5b731cdfd5b2f4c2f1f92915fec234d492bc12f8092829a39de1c0784bbbb35d05ad6385f98e80758b93794fd31b3da66d71840267cd2f26a05ea6866a2f01ae4b34916ea718a397f54fe1497ed5a1a9fdad47cfa2d235c2ef8893ef241fdf882647cb16ed21617def04d621f3601410119bc67553c0e8800fe3c26dd388b8343f685c3f379688835fdab68790424a963ef7d6cfc7c1e22a978e64f174dffdb552ec554eb9e6d1b82f361cd5104674f71c3793d7314539a7f7792fa508c8c8ca0993fee81d9654fe0a730c5312fbda699972a3f2d50a3d473367cd281bb929816c6c7467df6ab01efd85d1cee84b7da3ab202bd2570317e8df8279815e735bf81ab55dabb4fca9d9b8628c638fc50c3e038a37413822a12cf25e4127546564e520963b8b8cf52369d9f29c502c36ce0643bdfb75ccebb9a4baf3f576afc9888a1e952757bfc8df403240a18a34d9b5f0f80ce0e55c79dcedd7a63dc2ace35ed53459f88ca083aab443fe1e575c600f91f0775817f8421a32f4689b9fb0c721f62340ff0b2ffb2fe353bbf4466789027ea33ea3860da1b1847693a3c44c274bde4e309ec75d09b478a265c30e5c1825148fb86380a56ff998a5399b1ea33a0ab1ffb374e4d5b15b74a25d77b96113282091bc2990567537f38f951b20a91fbb92e5c9c33aa241827e063963a0ca73bc6ef7b18afe8aa4d3eb7bb600bdb8d588044c632fbbdb89c444c805b5374fad4bd0153602395289db1db83f3b47b895b02f6aed478bdc5b58c03ccf1c8522ca5fbd2c1de0f357aa7f78ed05786874b6d8bcbdb7ea5b27ae99a575ddb735e40c2480ab49709087c977fb4c08dc4fa52e127210520a046f0388d0f9127ae0c1bf0d4812aa89e60bf14457acc62c763b381ed6c3b368c0d4bebc64892d50b62356a7b40b3714bb9cde0543da0b8cd306240b6039b07109519cf35b9a8f202c9a3da1b246879bf85ceec70723546811bd214d82210740e25aa6c4e972762f6c5cca312b9ec2aae575950da82d513810385ad160a06dd41c7f4757f45e61793ca9422aaf88ab246ecfcfcee281facb09748f1d5338d5d365e7d7c5e4c1ae123857b36e6f1178d6a8019688f9d74d90e5885a75ffc5e4a4b64ac5a798b61d0ffe4081e66c0015503edb533f47482e8fca745c77240cb8ac23db1d9f7377c68b43ace65f0ab29a335d45bf717d9c13cf70f40a551ad9f8eb153f06e708bd7ae9b3da4cb4d7220964c8cc26ba44af5cff38b46593a59848db9e39cf04ba2c564024fecd4e536470778d0cb143643f55ab77d1ac9fd48f8328d5af54b0077d7c1dd85f582c6d35b6dbb30965bf74fc96a21f9f9fa32fa1ea0473dc7cfdef33be890c0ccd9245aeedd4d375982471467825bf23b9d4324dd7d346afbc77c6a302891c7ffd13d07548bcb1b844e0eb99420ecf3af8ad64f58204192d2a2691fef4a4c08bb31688b3dc123864d57bb8529fa23cff6681ef72c73d7090a1e3e28c670bf03478a41c4e46eaf955e204eef08dc4e3876d29de64c66718abdf23fe0502b18850e874fb8cb522f3a3dd2fa6ac9fd2a0ad3c5f140aae20d2702a493b017d6743ff545ded095efa05b477e68afe7ed81c86456e2c2c837ea3bba279a1c2280870c6ed414af66b8eec1e96b030a81f58f468290f2569aa16a799dc47e81dbedf22722e710d19d3116f7a92ad09f885f575bd3f444c41003b3836bfc37f918db62aae35d42369a3eb8af5e09d0b9c1e964be5e4b899505348a504cb17e8aaf3a8234e2c14f2b2dcadebd43e98056f51d0c1c408f9a9c049a5c3ed07063c7ab31f9a0e964a7dea536e3c1d959050f8488a2c9b5306e60b5111e9f0e36fae7cae323d0c767e35d22434cc5ea96a6cd576496bd97bfda4a8d7ee6ac7aa843a43eb307af20d5c4b5cd729f324910df152e1fb00f58ec1667bd33c4227f8299a254704200fd860d8d570c0e026c189e0c09b2853589922e499d674063ee23340f3907524dd82d1ec14d96bcd8b9c53e46f16ce8d7a8ef599d00670c0b04d3bd8ce6f099e35916cccaced9e0a11d1fd4a280f6bebe03e41b1a9459762168915a0494e6d6cfeeb3faae035a4ecbc075d35191c436cbdb023698afe75bc0c1cf92f2852c3bdd92b0cd0504ca9e8ab3e86d7cb7774d9c4bc34368604978306607cb426a399b7570f03f52d993efe1f0c2f4dd97b4cde0e2414eae53adf36e3a7d68fc163bfc8fdada411a3e11ddf25f28780177d4b9ecf643d18c9041e8c72e358d369767b85c305118e2481ae4a21ed4dc3111b82d357a3cdc1c5273df02561d1b0403b7e539c6ebf1e8f46d6dd59999967ffe5dd8d7f8ea10c046214d9d9aff1388d7486f3d9ac0e905f65322ec0a00f3b95ec246680c2b7060f17496d19aabd71f0b32cc0f8b3b23873b1039a22a36add51ef57c0a84caee7f6f638d5a4082f194773b4b058ae63c088898d26baeee8d92a955559c4af2992db68db025b37cef544ff4ec1094516bcca052d9536fc503f0598aafbf30e41e0607f99133ad228a8b6d17f0bae521679dd0071f227c82d811854f5fe499bc6db82d4b52122342de7d727f222103713a06e55a32f0249ac7afd5ea664f4bbcb11639fc9f72746e423c50eb97e3b89ccbd4e26cd2085bab6427438715bca9cbcf8f157a901e959f3eb63a46a8dfbd871ace4c779500bf2eede6c0a32adb7357b629d18170e7345e3b2cceff8990fdf9a9ae2bca2802135d89d52aa74f5d1306256c1103ab89c75cbec25f41161d3c776614e913fc374cd805c42faf7dc93f14dd35020a3728c641d329afd2046aee79d05a24226d56e85a82751d9e6eb906005e7fa10d58fc7f585d8591bf18d821d42422e35676d4dabc72f2ada8d93b8c4807cedc4aeb10f7bfa932cd2bc4fea360b6848222e45ef61f17fcc91746c57bd712ef5654fa342908c84d7d5edbf4807c26a694ccac229be65183b6d474b6ec9bef06c5b0bcf8086dec88ac4191d141385f6f341fb6ccab9ead27f0fab3ce6228b7042fc11ce4cf68d0387b7d9ab1ea72678f8b3d0bae779febedd40fb93af6991af7952d4c01d62d8a0a0ef6dfb3c5786d8ef5350009a1bfe2411688ca228c7b5d62b1e0e83e3085ca5cf7dcd5b0bcc1c386e19d798f985ac7f40400741e3c16a97ab6f1b8fa6dba01e18384c45be76443daa2c37e236ea54612ee2776e2e4c81106087d7ac7ceaa6c7ebf610f1f7fbc07950feea80ff3ed32e7981af700b4f7db7d31d0b376d6d374012498fc366703a0183faf22c89b92d7e9352ab82aa75fb0b49bf3a3c944375e4eb753dfafd36d92cfcf490988858a1309d1f8f6d1f94a935a401d3e8e4ec45f0e1693aea1f8ef44f94b97bc430e008d9d3be9c89f6352587c98d1dc6d6ecfab8c12cb4b8c7a167c436789392ceaa4cb65f142d134f36eef5feb0442651dee55035db5461b26eb0ed47fd3384246b2403b230f5092b9a8dea84478b476a34da9529499f6e1069c544f7841575e3e739e66441b29abc91a6176ae8697ebe36e48b7d697995d5dc028c989656cac017103a74221cf1e66821274c7e37c128502f82f4d60fe43152e8cacf3249de95c54e15fb020e0c2c9518e35789b9c3198f8d02399c05aa130910b7beb6019c75f9b065531645ffe1231071afabf4dfd19c54f11b7e3d0b11777fcb1238f98f2a857422272fb0db75db600441cd89542f6312af253d28aaf6c21669febe2d6ffb19c91029485cc44baac7ca11fb366e726d627e4abbeca020cefef8dfdb7276a306a8d97260ab62f149fe131f65edfed129af12f4f50598ca76743ff51369d3a7f9a95ec47db732f3ec7f76494a9eeec9e96ddf9ac291c4ab5857143a73b29ac3a177860bba5c8c828988e901c5bb09a0f59909b23f14546cca65b7dac159ebded648c8816009ad8e4e7264ac8a5c4b4448753177e5ca687d1a9710e5015976a05ad7ae82933170a97bf5064bb1b100f28a9776c2ad2d265677c8c1c5687c05c33b3c94fb845ac91c63e4df1a7852ce9cf571e95840ea50caf85caa008cf6f9f727bbf59d94a7d081e489eab8611907e7f0f2fdef40ccf61a341a91b13a1661d3215ab11e85ede609b4146fc602cac8093902a571d38528d646b0fc9f53aaa7be465b5df29c4d52e736184c59381c2f67e88d26ad70da8600799083588836cfdc8b6eafd58c3546c3e04c6888c98773b93e19c950cf4615bf93545cc29df8048762605398525d9188e2731118fcb188092ca81056751c3edf3d07e860355bf759cf35843bf5e1f3b24ee85bfc48f58b5adf719e4b0ae19d8294840d7f0bc198e73199e9138fe567c850ef86d3820e86a0d3a6f38770aefbfe044b73d27fb810afb8832f20d113ac0ad36191c9ac3c9af7d3e8d5501aad56e133483307da13774c4e89eb50778b00cb2678a19838a3e8536a56cf5df0f6aa5d71a8566d29386c2fc0eeb6d2331c88ad491bb55d8d109aad7df3503ffba51ad274ac75c77861a117e92ec28163ad4768c5d72692fe44bbde5e6d656bd939fd91bdcacf0871a27c8236d837001c49b03c28ec6f45f9197ce62ccd91e1975985a0934b97154e697e4b30dd294ec37a2b94633f920bfa1a867","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
