<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f230434d3480574aa86bbc5d476657ea55cb8607ceafe1c5d78d487ec289c826dd07ecfb2669bd55e92a4ae68761453a9a71ddf1615fde91546bc09b274ef16b65af09067ac933d32ec9f5feafbc0a63ad8fb0ad6359708c868f9c1656cea6dd5ad7ad2e1075088d599c2e5f263f953fc5a8a1fecbbde0724af2f3becc7fb45a8a625710ad2543efb10ff4f2b51d3cd359470cf6d0d4292b8aea591022fcc67c86812035c4ee544ebde740801d76696adab9963eef0ecb268367f27897a2cf26a65d0cd256cdf43fbaa08d3cdde6572b6ec7ca3b401bc40afdf20f8bb5dcb7d07ad6bc7279dcd9c9491d140645a0562aa2fa5ef7c7f32ef609d6ca7413e3c8377d5752d45f61c0f0d81e59b94e547da10b62b6c80039bcda354537ff2d238d7c5d291bc174c76c23623c1e21f48c1d7f8d194b7046e1b418d3d75bd270a51220672e668d5476b9c20644e49774c9dc7514955afa5171929a97ef7d26fc53d6303d7d51b74dce427ab77dd0f0f725d8adb52d36b3861be05595ba3aa9cbd9dab8704e5cc9dd73fda6a878d53a62c75d10c14640253702097e809817954136cf4007cd60a66329acca9a8cb57348769183dacbc9482a8ad5c492f704ec3910d654c69c6d5df2085017fab72316a20dc47d00a5fcb62ab64bdf204f45ec325e22f7745d9a84f41d549fe0034878ba5932853fe4cd8d87590efc18de6799fcfc82e8ffb17881daeac2a6b2954dc9a7a969de013bac3dcee8eef1481d9be3b5b28a4efe1ecc362c678fea7f856d24c2296e04df519758e4cde0ec641e6cb2b59e16cb12ff0c10f2ccfdf3bb25f4293eb562d85c60791f0a6aac47abbcb4046c24926f3b8a45fff2feefa147dc4f6c302cd08796f964b9f13fceeda49bf37656617b75bfc800f6832b3a34a9b4228521475da04b95ce0f16c70156e3aca35431f1793290abb74b572b901ed3fedaa6743ddace362286b88a86672b71b421af6d95c3784db2920b5cf5c527dc9e8a654eb43eb038789f152a1cfbac047f6284397743fd0b1dba575de7cf35e8efb28bedca54c8d7d2f5a4273a1bf39646e31985ef08da1684c82adb5d6e8caf290d63e5e765d1b2b89339aa7be3b77af5970d37e122a5d0b6729513e8667b81df69ddaa032460f6330616d4e59bfab841108fca04a63cc27e4a32b2dada1886b35d40552f2c1aa4ae3b538fb7223c25767780ca69a1ef64ba38c55e39543a7db88b5a7cf3c4a5ef6998cae5ed2c617481595f945991f6c5dedee7a2c8a2fe499a0422a34e134dd961586c7a5d83ba4df3ef70b90940191eb0746aad57bb49270e8e28edb908bf062a7fdd02cb08b5ad0836a4430f6ce7c1f19e44d72dd84bbed946abcf00205591404662745b3638d79dffa32af993d3f640f1079a6ce2a4c832c4a41176f177ce8c8f053c38e7abee1ae778d5e7c0aa91595a41811069b1bb1b545f5b4f7ee760309567571de98b884aa86e2751e427048bde39d987d2a21f38df776d50153714ecf0632e29cf2077eca94b2e7080e6bf508986bece052120b65c3a48b0907078e73df45b9b1e947d9d0e0de7c351824159960deb4bb7cd88a21ea68001f2af9aa6983f4d36dc388f0320cf459a3fa733bf7ee1e6f6bf34f674cd277c58c40f1bf7ad415b065718cdfc79ef6ef8bb4ad769d6fb7e2c2ce2df4a3bf0d71a77ee3bc920ed6593ab06779014ce4d135949ad80cf02a1f4032bb6483bd612ebcd1ed6cdfba82b09af48e90a2689c442c2eefc89611924fd79c4aa5a820cb1ba784ec4b4453f6e04f469d22a8ed4387f94af0f7e6c625e5948098bff776996b3528d7d35b0c27c84593f079347708fd8bfb05e41bd2574d0ba32512e9fc988c327c78597598de05b81016821dec01e1510a0005bb40880704685fe5a5dc89cac0c8ae21380e95832fe8af9eee936a76805b89f9e6c344c9c62fe4a8d3b3418874de9286edfcb06f62c8a2b26330e54281a7fc9650b78c6182882835fddad0de921d783d9ea819e3e433a2454b1b36b567617ad7801ed11a8bd26eddee4981b630dee6064e63e66b0f0f9786d8915c3d4c886633dd8095ed544a851a3da01299404baeb1046c33dbff37d4a9d18994121f232900b36c29b6a52f669a4631bb755ec2467b6609b219efc48f6e2bcf135fd3add8b838fa0ee3fb45915215f569dcca1979c1718ceffbf81db19ab5e4dc9cf825c1043410357bd028bc91a9441da6d91ab2eebf899b109a334868113153211bc44c5a65d8a10472191476ea198a43959f0b9b885b38c510f004624a80868c880e5ba3c07ba366f8241c149724c0b4ee2566edba0dabebc4e0851747c4823ce32c9036c12e9bad6baf550d42ee10ddeeabee4cd73459c00fc70fd655619b4a002119341aa6e6579b4555bff4f9ba9d89adeea9acf02e4b4b1a1a9b3fbf04394c569aceb427816771a7dfee013b9f6a2a1d2e2c430b83b7757b6a5f068093493f04c2f959784ec49ab33c5834951aa86ae68432c9c5573598c77d4ff7cdab93329b6165019e566fade213ba5e8700163a3a46d2dae504f202604013c67814a9ebd80f30433e369bdb4d23bcc3cca0addb2d4388e1901edc50708d9b81b31041370c593623085123ccc8ace62b7f0d8f64fcd320a0f554ee528b9075c86a559f4f44227aa2bc38ebde8ced6eccde64cb7d0790acb857e9d8dad8e93f79ed946a188a5f6d76abdb90cf322e99b8647422798d13d524430538b57235c0c72a3f9159dcaa6c962bed72b7a1cb05ee28c36dcb155b3077438dd759897a14b5ccb7beac107c8409ce4330b4f486c3d0fd8a054bb1a4c2536ab07b1a96ddaf85609f05baace3857c90072be55ae1d7dc33ec652bf6092889b23165c9f0147f0581b1f1d8382fff884ba82d50d43c9613feb98d02c7afe4aaf77c5b2850cc4172233d33080c87625f51ae744ae5634f64f4126880a730a7a8c1180646c425021abc03d9a1fd0fd01d515af1f73d6a440ed1e6931d4984bf5597b4262b4700a3a9827f29caa4e383c7f67c290fa85aec5de914c0df63dbd2d86a0f3d3417256edd3bfab12d037b49277bce0faf394224c6e63de24cf67754f8f4a4f751fe5c14716f7007d2b8488a60c2cb586f3740fe48c92a98f46fab7fcceb6df88d13454a2e6eff37c0e6302a23856a28646e276f16a3af029fc016fd6855c91aee97e17c6a288573a50e3df67f61f7160c498ecf67e77d1380bcef4a169a5c966a71054e7e631f27d62bab8f93edbc4a0f7393964e74a92130f397e3163515959848f5de88f74122042da42b4e93f1000d624aa4279ee47b0084d213d248d4c53a9d3049b55117d0a52653eb3dab80eb81165b9ed60f25fa13dd45180c0719b1590deac5dfacdec5634ba191ffee492a17bb14bd287692a6b744dded602ff2f9e0928036cddbc204aa5d2ae23166aba2d283039bf972a56a179fc1052c83d4b457ec6f45911a3d772c6b24d8db933b51914137864768b8303d012ca14842009ae8f486412b83d6785eb00c5e5bc2e1dfbf51a5c86f29a3004af437720c24015c0802021b1ec1be0105f0121582641bfc643c77f8771b7a81badd53dc41a50c9d5e6adf3f3881a7816ab44555c980145e13832e45c67aba4cf4a754369c9b27ef9c94f1288fe04ab81ba880ad5e0eca85ada1172f7797fd7604d63d6e09e16191f86f8125cfe713189da3207e289f552bb31a60cffed8f3f6edbdd96ca3dd09641cb6d23473a0950fbda999565736228ad0d022246364d827aea1cde282bbfff138ea5b390780cebd1483a506359ed011d8b41ffa24bf197a3b8dc3fb7bb26c6c4fdee0567ef6f4346f9a7f4fc4ed0863cc77710f18eddc0d56e3554ceebc91f152609ad5b5338eb2ea957b01faf2a7d2c8d1b9f217a2ea15c40fec1ce4f725c7994aac94f8eec79f567e07bed27f613b8add72c24bb07b875edff3508ba32b781320053144681e138de6658b37aa01958a8e720d8ca6a6a7bacd529ae084248d3d452638e84e84b20af62297be1351373c4ab011dac00cbe9a403bb5735f7ea7677420beac11e38d7220a0c4e6b7e90185d0c41651e1c26f74b3c2f92bfa16b961930f63ad6c9d8e0bb47eb2771fa8ab21316f103ec33ec5f020bd2a9c6c1a43152cfb4b294c5f02a8c56c37ba2e558bc7c47fb7857446c4abd29d721b9b590f747fd552b733b4612dc79b5ccfb2a0699cd2f94e9fa8e2adfe62d9732f9fe0a71d91c5f654b3e23156f730d5a69ab27794029ef4170e24452e323eb2d58943b680cef55471317cd85806957bfc4d18c7443adddcc0d42d10a7eb37d2c005b5e2b38ec3fe1e9e191eb7e6380574126f657f0dc63907992b524a5d250ac39168d2c09002547e4ce0e8f1d2b61d1461cf7f2a60ae18d5abbd20641362ca8dca5508faaff17419a61a3f05543799000648162f8e2f1f5c243bfab7c18d134972fe12a7c42d799ddcaea28b51adcc78dc295a2714be32fd133f014a8986077dbc46927952d968ef8a904e241694529f8040524f5335b5286a6161712cc1b5b7fb3a8ae20d0f5744b94184052a058f83fc4fc875e1fce00d7891b2ce7184ecd8e29d26004f5a6ef8c5f143baa8eaba24d3e6ff3c13d72b0c93e3f41187a8aab9e8021859d164cd9b462096a26cbf4562d9649297c9b7f871432ce245e53d217c5c1796e56f003ac3f065871c8a5e140f94e5e89568f88d5574e457124b8b1a05511a52ce6a1b49fb8f6b1d09da811facf6ebbfb67413f5203d34e888f4d06e3b44a93f1a97f901e2b069e8aad820a391e4a68c9a560368c071a9ad861ef087eb0f7fc98fa4607266862bc6c5bf994658449d5d630b282bdb0654006664ddc7f25fcf4762c823e3fed0c396ed56bf4dd419e87c8971ba29d82ecb01518aa1a5ddf89fe0af2038b67e8f44c03b9cfcabf1f58b521ed5ce15d6aefe8e005a928a09f6e66034c205b8ac0b6a9e00ceb1eb65e06eb059a7bb80ff92b3b62b4f73ede1313fb67ca22e70731fada9e7753d5689eba3775ff558f49bec36bf0f07ac9d158b8895471caad98aa0d6d1b47fc6187b3e2400f5657496d656b90e7c3b9d6db21d028119eb56d90c136dc152eb68700b9539ffcb6bcbd14f0d597adafcbc0286da97e3666ca505e94c1ff6232613d6f26a822e3fc264bab2590e92c4bf0169b8cb6d376e35e9dfb38afe6484bdcc3f9dbd1f08a5128a6855d6251cff26b4cebc1b3868f924158ffccaae14cb7addd0d4ea76fb3c3cf1ef5706c5296855e404a431b6cb674cd70c45a12e9158fe457d8602668813118d0863b29244c38d1a5360a41db1a432ccdffb1deb6ce482a9ba0cfe97725244af9001ecc7d2c625effbe96d6750bc789f41143aa9d60ad5969d1581aaa5b285262e27facd1bca3bfe551e49b68659f2fdbe815c2ba31041b24100db44741a28c8ac70b8337638a0dfeffc86aa36fdeb9099ae27f1249533a714734a4ca8cf8a212111615b8233db2923efee4184dfe0131015e61dd72a30967ad07913f1b76900cb43871186c08b1161f9d1d7c4af640d7cef389fdd245773aa98fa91a75189d341f2b41e0fc07a4225f3611b55732e35d9448ca3004a00d6c4f8ca517ce8460e496d0286850d365ac724001a0a60995c8b9b61d1402a9e63c111b6bc50201c8de3b3b7330e8c8e6b5db797d1581c1cd0a6445289aaa33cc68ed9c1807b210c5bd23a58a91ddecc08abbdcd42fe8001b0c4c74c4f7f6d57b603ebb67359cdb125b26c1dfa49b18d7175fdc4aa9894d1649573e0674c64ba29906e27a8ca21f1d8bd2d6025fe1613b038032e18a4ca27c328230cf885ada6cbda668aafb89e9afa40a9655f902df2f59449aa0cf5c21c5a6945e9cd646b913015751bf7af91e2a5f37bd2d920fcf8c3bf2fcc2a74f2408500cc941de02fa50c65f529217001897bd80cdc4b95cb95d8e2803b0036cd8d247baadac82beddfee9c1a5a50367cc35b70e81d594e64972c21ac6b00e8e3fe69163629ba80e185130038c1fe7c137c169f17ddeb18a7c3efaa90253205a2fe7411babc1bed215e1bebc566439ed676c0d29595776b76a1e4c80b16500fece0b8bad2795688ae8324556a969ea80d3d53a906cf76f38fa4da3c1e34546ad32837a8741de0fd92c9f9c61929de0005d6c56671311be6024e8427c546eac7eecf90102db31c6a75b70bd45d3f88d67223f3f79d0c7b13587d4fe8e47e023dacce0dbae2bc6387c9997641930de1f80a5c96320319e0f985ab8cd228bb4564a2ac7f66409f41ff94bec3483a4c098aad324ef6b081875222150c0fce2a91f0fe0f1475ee1c850ff23454817c8859784470029f0ee83a44e795752aa558d1f46f85fb8f8d2ceb3c6d3712c8bc4a8a2935261f78b2abb5054d721cc091f19dd853efdbbbd378c2f277fee04b8cecf2c213cf38f33315f6259818d7eb2b4182db7a2bcb77b5d79cc5da92b060ca3169a18a99eb92fe5e423c687e4442a827e830c95e12162fabb550837458011cfa3eff14df51e35132030a639a2672bc8fd352566c9b17159ca017a0be5ba9d8452a58a526d9928a19216f049f1feab053427c4c9492bcf56bbde07742cf07a3916c0f9937999294ba500f23608df9a9a3b4e1d2c879acc89e18b7ff45be06bba822e8361389bca8a3963eb7a53d05ec8aeda02d4de6546e3f857003963fe3de864426c694a8dfdbe831ee25d2b26d3036c51451185f40da6dda0871789f51013cc0f3fed33e55aa0b08eae9b61758a3a0635f7aa7d790bf604c4ec7428f07ddb40477e711ee0a8f2f9a6bb9f0b7ccc091459db89c16fde30c1b4c8136e522f271bc877fc9a049487546d5f9e71146d7bcf04c46ebfeafda8183bc6ea11ca6a7d02f4082c267567f770a8b997bf9bb6d60a20957bb26a8cd7d9adab10c6ea054d20126842775f001226d09c92df88f8a82016527dd5de1ed9d2f5b719d0b1ac00d3cc8770e69e9ff00f180af2e0ba651ef2ed7f05cfb28289a9c3afb11a20130b4c54b3465f259a2a2f16d807956f8d63acffec07f3bb3d05193eb4cdd1f2c13fdc1f8f37cf82a7c370748dbd77add57c8d68493e0e710c0eb0ebf10cb406701a01f384edb75bea79c401d4068d65906621bdac2741767f4d94f990a1d060a2e68db713c5fde8f10f29162cd21b075d0017d3b8290e02ab5587987be3b4b86da01f8fcf4876a07e22cb8d309734b1fd839235e77da19c47dc6618ac2464500530fb83fe650bd3516a136fdfc66470f496bec65ef4d65da1bc3ed7e91bbf28e52f2144e88d10bc30df0ed5121daef1f5cc04784a7081f2f0aa1389b05314d4ad1aebc3493a897a5b851d260711c278194bab167ded9fc23c7ab1a50894650e859f9e08803974de36363e82bfa11232047ac430ebfe8d28a5e423b5c89ed283ca0338d500e3fad69cf3965a891fc904c9f21bec7b64ad08704efc47aa83f589aef5814af2e61e010507a07ccb1e5e9c93b2ce849ba04d8782667f5d3e4cdd0e8c0dfb2f68922e8d55060ced62a4777dda41ebeee298741e28668191706acd823638eda088f8158ef3983b2b2f93c3177c44343dbe2615890694037cc53aa14255bfd1f72c75e3810769d07006860dbdb9f891a8ed664bfa70f336f22d98f2aab2e85e62106f1bac691b971b362ef0195e5655ef669604bf99583585d9173776f8474a577bf7ad628ba70244c5b0ee11c7a4c46567dbe795005207a8f2e71454dcc7199462883ff6dde7e47c642fa4012c401896927fbf313553485f8aaad541fc60e8642183088232b6dceac9c6dfad0c63cd264460cf6f3fd619a84cfc282ea94f2df2369beced45824b701f920745b9a4918192949313e5d8e7b731c34e4477c27f56748c534ed40465c28883c43b5407d0339e2badbf2cd7c21f4afae06ce0bf8eac4fdc47e61aa20fc672c6a9ca9d98aa367267f33777836ee236143a43665b2818ffdfbbc7dc5f99df33d36221e2b84a80f9c0f21f90798646e5176b59480f4205ebf349087f69d562f009c4a8e4bf2774c30efe75de184236fda362a6e7553b5c8d47308e37dccf4c6f076495306031a81af65952eb84d386d43beb184053f8643816b6521faa3fb17b7c735ca4123563b7689801257596d788b24fde3714b9066dfacd622bb88b120e3238b79c06017f53499ed64308f1343a42c76f8531aca1e9d0c92bbefd6e8e526a16bdd39609192f64bc51919a66e964da1fde528ab3b782e415a5a7637e9c867b91830afb77fd638b5e26a2a1b5362a51a9182cd5c111344e0ba34551033266edbd165c4ab509854f26c561df10eee338c61c65f13d805fcc5a24d33cf5a161742f0a5ec84f929fff27b536464cb9abff7e1fecae6aab381503009d8f030c7fe00a272c47298e387ee3449cc69d27cf9db016474dd8bf757ce7db37eb88b78fe6211d04e45974f1d83efa2f6c5d8ecc688e7ba76b39f5bee5ac83154273c8febf2c0588b691a82c907e06bf8cb6ac6feb5fdc74373fbc015252b4bd34b1af2529c63fa9d39a416249daea1aeb1349186a66529f7337ca40d7a799fb5fdc38dbe6dd66f7561d46ffae0de63bf7048fc2f4708dc3db7c261736000e4fb4a0834253619f179975843d8027e434c3f5c62b5f9e2f9fb301a11af7e01184cd658a3eeb0ac6e3a1186416be4e35e914c1f4495688c99a840661dc276fe9a26cc0cf9eeaecdefecb9a9039aa65aeed7de6bcfa7e0ff609f9d8a976a92b5b57022ba431eb98c53d2330dc1c04646622c683cbb8273fdac0cda9c26dd050c3abe1cdb95a313fa3bb6c1af6cf92c6084fc1f408f5ac483211c87f9e75210ab3f320ea32c727077a8919703648f48949014bc11562eb613539199f5e4de7273faaa5985f978d5e1af41a2f3b4703e63d8cb6ae2e90dfc4740dcca929c26abe59a26d4eb7b6749c0e40fd9340b34d89d3c28903f94ad66bb3955fb4f3ee4f2e6c67fc287990504fb9df4a5e1a2504bdf5376f2dae986b18f088be5adbad5fd99252dd4553adc8215788bc2b8fdcd61ac752a2d2a4eb25e6e75bb992bbdd7f3cb2a3f279797b44c791f0172dd0e1e103331b257dddbab654b3d51d502de9817f9672e75f8462c7dc4bda643d9228192aa0b742c442464363f3a1300e3360a67dcaa9879ed1921eae4a8b34f542bffb1702a98aabf13b8f700514b35410d9f419a618a6a81cbda5017ccb9d00dde7c456025476315eb71cfd610ea881979c34506c7e43bbfd2d1e55f6b163d34a58a46970609c208fc734670703d8244b1a8c1449c9765c14a272518fac457f0ad7f2c5b25dacc9c2604cacd3011d118d6cacdb4ae6cc44999ab31a9ff3e88fc7154a8814275fbcdc0b97f8d0f800bdc5e51f5b9fe5fab2a8ead5a3efc1219c0fd149a763b6b1c41d0b615f98d6a976d56656eb7c1c57025e4504e539e16b1690d67e76f0cac1ca1511227b185ebbe8252b81cd860e102658f5962cd46bd9e49d20901547eb11dbf68709beb61f527dd5171f5bf96c037a64ab53d1b75101ec48349a07ecb373e31542ec3350acb742f2abf23166c0bedaa00f828084755e71d094c60cc8db9b808ea7cc8d39be05ef701a21daa7d9c59b1903ff5f46b1ed1d2d1eacfb5e0a5663c9e4d7a12c1b3071dd36cb1411c346238927ed33b3c39ffb2b04cfd2ba0294ebc2f74dad6f493d2bca5b327b3f305c0d9c657bd4f6afeb550674bd2f1b77348aa0cebcb8799eebaa50f4845ca98b02d3dee6e5ecf04d8ec76c88e4f8a6abe1428eb013547afc8929c853332fd17c7e62ef8fd8044cd9c1abd34561b85fa0ce16dd262232b7c8fcfba4b51defdc6da22d6dce8db777f505f72eaf3c91327a46cbd77e7bbc2aa3519369104dfc0cc759032b1b15502355e021d9c82c74a4b0102f03b4baf48ad9577c50ef2a8bfa334866ec1466622d561f3d2de6a797c8c65992662c25b3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
