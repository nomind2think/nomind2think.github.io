<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8bb33fdc36bca3b7a6a54b59412145e1697687b5cc13e13ebb2235b5da9a1757d8a03255fc9fbf2ac05fd653ae4c131e33d112365424a55cdfb82c5478a982b8414e81d67b78076db11fc0145e03539918704e8f585819ae6f9422f35f39c2a5e93a4ec2c42707e29f0ef36ce43bd16f7784408a2729fc98353dbb47243ac686441a8426c72651af8c64dcee9f7786439a8574e8dd2ba5d47459c12b2b8e74e5717323a8f417be7d3b05e62f7a90101cee36353964159150b3793b4e0d7512c1dc38f22dd7e91f99e2080343dd88520da527c3f26de9cfa06c9cf05b111a0d28c7873a48d4629f6f48eaf9e6bec40d815f9658580ccddacac8bc4ef53fc85924e06c7c7e85c47f4f2eb5e403c2213795db548ec34c6277f05a9decb2deacdd0361358c7ae4cf7d7b9eb2a3a6dbd3647c5b5c0ce5b2d8f5dde132ba8acfe5d47d61fbd88d279a920f4d1aaf0b2a23c1ca18a104bae32cc9844db164960a26c91180478178770d5b3847798975e5a463149249299555ac264a1954fbe09f92baeb20365a7d79b70659b187b2295286f04afbd858bb5ee22f965f410460dec14d07e7366d1c246d7aa938599506a370d6e56e3e9af8e6fe620b3560cf90673a9d94d1ff83450bb8292ca44164875a5a3d213053fab72d433c0960c3180d00c98e79be258ee0631eb28958456de9cf00b8f38e1125b78114ef62aa134e062deb4ff9dbac9c415005e71d21e94c12f4f65bef04ff0c96402ecfb0fee629b9fc2a1bb04997f667b7a12592bc7cc4928379eec2caa1d512dd38790dc7bb5e8f9c746d6e2a2bf225d6b44b4464c3ebcaec413617c701a3fe902bf89c18c6096813aefa47cdf9b3ade6cf071088d47e905668d82d954b007b08698a3dd0d6a7a0336a349c24650ec8407671e63be723770fd9d8eb7a4c3f1e8557ff94cf6d0351788a521b23d2750858d8a5c9a30efc6eac2aa71390b17a531f805924f99e44c1dc0737a82ba4172f3d25ef0ce2d2713c6418a599b90ea00f4dd4def7b36c712f788cc347a9fb8677a3d4f6eb2dc965bae5e844f4800edb44d9ad313c95cb7b5cfcdbf7b6d205af438a6d5962cf95032e896937c96336c43663024734183e5d4953fe77c67f1fdb26c7579b043d9842b9d6171b324798e3e129f1d467ff343e28a6b080df5654c0bc3a31da5326d2e69f6038cc65c0ce757e23a6a41ae4c6a5c8e96bf46acc3828e43678c211331f1d2823ab1b27fb1362aa3690c5971329909e689e8374f988cefe6a64d696a1e5c9c6711a70b6ca3d2b88db703b5f6152b3f0f2a30f2fbb2b4b9bb9850ab1dbd8a22e5510f1475e2e413625e2f81eda0e13caa959768985c188a0b8ebe717cc0980d89efdcdef98761cc53a3531995c98d9aecc1d8c9d43bdee3946fd6742ccbcd4e2733cbee7edb066468adc399ed042978f214098fac53d0211e7cd1d7b574e41fbbe469f1426ce66b6d6ba6c9ba90533a7839874f93b46a3e3a94c109bcedad937de5256e01ecf584fcf11273471a22e25d5d9b06eaf1e7d766740f067b29b90115e0800ab192a14ceb707fa68cf9f7fa3250dd2020d351e8d55cb158ad0c7222c1d0a01450406682da46ede43cdcbdebfa9068c7d5772faae4dd528c29393eababa01f645c3f3662793873a93efdb95ec840a4ffaaf74598fa166fc40270df4aa7d39b39f036080cfbc6b9f653166bfa959d6e3fa26231b32eb9832cfa816a65b05d3506a08fb689aaf1b52ea2871265c819f5df58c6af26c6786832a68e855c07833de615f29a945ba8ffa77c622c392f5026d9182535b05590807d450a8fea99e02c2da2658797a7ec214d71f2bd7e4b28eaad17bbd69a65547062f4503e0a0785a096c16cb6a02801497c411af6c54dbab8763e8671b9f56dd7946dcf6f0956faf7d90ff8b19a913bff9dafd9ffce535bd43eead1f69a10e79fe73e52607d4a5241b7786786b944cf02c9c28392cc5a65593f122d5a57ff74482fd1675a747c149f7f30b9c476da65d8db4d9b40201292da4a216dea9b51475195a8fea0b50da7c7c2a4cf79a0d327ec06edf93133a1f84998647ba48daf24df72e6cd04b73bd35a70dc9af41b9c757adc768503dd714fa1e5338aba81e955e1150008cf179b69bbdf0afbcfc0794b0366650e265cac5cdcfca5a44ef38289836fb2378ef9ceb7deee005b103cba7dc7183353e8c768bb41a75238183b9af95c67bd16cdd35f97e499e9e088b32629feeb5052e1734035d7d1b14cac22573c6e53476dd2ada9a15aeb6e32f9c476c5119d6839f192bc4c8c42732df59976e951c913782e35c937677b6715da79487c4f4df55eb2ac69201748ff67f3b1ed71a81dcf4ab99387d92880174920df832020ccf559c0f957987fced6c9940622c2617c4e0e24691932981e7ac3f4d7fc2eb2c6c8fd99d13b75d9c263b31939146a51ff0b7cbe89b0526805b8a5b0eb53aa000d3e6a2bcaf6fdd06d6fc13827674d31d28ccfc5c01028cd356bef7fbb5214b56b5bda0d0ad89c6ddb8374c05d7d684ea79c7f1e850cb04028df63ad134e39143c9c292f0ad61efffb5162b570c93c5d200924d2e64376b1084a91444f52eb189ed5c22de68e3267ba5186f113a39225fdbc947327634b132f2fd0a4ffb030271007336a0d8334408474545e54145fbf3c50b211955f00c81b4110aa12b4ed324d59dd10da5cee485b096076ebf44077a3239533009e7ec97f5a0dcb491a20a6a216fef216a714bbbebc8eb82de2d14c6d407fc8735507d8144c47ed549d93e7ecb03869c2ff75fe1c2b4108770f61d7bc580ab69175e29f43bc3bfb36164abec602129e77954146b00f2d3d3d9a1820298d3d27522a00392577423f761ceedbd68d1783cf3bcf5ca3a9bb60502f1f0398c7b1411d0b5e650a8cdea9d74c769e2d790a9339face534f377e679c04876e06c25d2f6c31b7a77b4528f769cfa8782bb58c7b07e111c83aacc4a2d67fe79595a12638a0cf05648f2a939bfb663d6f4d402062da76631ed4c3038f91d061559ae9d794c9766d069f35f27658dad1d65751f42c79d1c095ae614523f862e0fe41b05bf7e530ba4f86c7b328f0396af43e8815afef85638f887709f6a905ded730e8c518e6a0917bcf516e26d567eee955e173d2e552a181ace59a7b87a19c3037667bc7cab359ced9ad7ff3a1b1a8d032373ca87f347f2814204bb43b667c8ecd6e213d62d3f7737193450dcf25666732baf5f63b2b8dfc2331648c000c6347bf4c35fd9750db5954b07ca8e05a0a2f2e8e4d389f6a8d4cd09a4dcc435566d23a6790179f52330bca3cab7b793963711c62ecce08cce0805083abe38ecdbd64f28c3dde5d8d32e7408bc6545a0703a7bd70f19e59f7d91ff1c925dc493376a4c83d4aa92ce542a866da5f7e818aff41bc8587826719722e05a3c396ce13d813082e78aedd9e6cceab1c7c049879ad9d7397625f21733f7b0ef133875ebbf63afd505a2983d8ebc6b3eb345dfe2d6985465143194837faf33847327a431f0f19d57aee6bf37dc324e2b4e47275828c5110799feaa887d5d641bbb0d917263ba869137de2fa2378fffe311797b23421099f0a0f4c1d3f2d2a8c6e43d2afd83c877a890cfd9113a7eaaa6841397e62306a919ff5307fe61771a40b4ec74fdefe4fe9662545f28126e39fa1b84eef72f7049675ec6a9d5136572f04e3b732c1f30d0f1ec491dfc0c64411309f76c5acd84f5036546b49fcb5ab4f5b5c906af5d3238af58f079e950c745146486fd1d27ede6244030443a361a7f0171d83c582609ce921ea4e9420f4c073b264ad9ff9ea6b84730be8e742e2ecc9accfab2e849210dc265ad1ff0f8d897e93af901abf74e2c0a00964c2a50dcbfb606dfe7f79711d62f1fbdd140b901db6d661cf5eab4784a5ca6f53785c4dd8c4eb99cbcb15495b9a9e719ddb3d058f8384f0fae0ec28bcac133260d87f25485d6057cdf7af98ee76cb464c09d66cd0df2427dd635ba44aa0370c362e806c7e9d0b5befe6e0acf61c22ddf4488bc4e5e7c091aeb565e81b9510b784920e2363b9ecb86059395567a8c3d780f819346f9b680a2bb4eec5cb5a52e675951871d02055fcc299b13ef86da31d9745330a60617bfad12386aa1e4212991618ee5028090227298641b0cef53b3c5f33c15227777057f3f1ec2a9c4d3d4e87af224c3175423312aa5d3e94e7d07b597ca40adf22d84e52646ce60ed0c2e2fa2cbbc86813fafb775977dfed9c17e414071a8c86c8948d486de25e0ee35c2553a7dfbdbeb451fc838bbe8d91172bf6e674889858ed9d5a6fb25df7c3ef8009639855278c9c07bdcd8b7344c2ac4ae6d5c0f04173371c57cdfff3af7f88b2f85b920eec2051636f4417b9358f1d775147308c916d233aba51ba70248005ecca478f0ac225424e5d36126472a8d9c6bc62b840040bffb2d159bba1e54405053a7aeb4e4a48dae87fdba6ed15490b26b67bbeeab1d73584a0c554e9fda69973440a867dba0f98d39a5c12d3f0d8d7664f3ffa6750a89c7ab848065af5e0ab58f336220de27daecc7f7a86ab1ccf0fadd6cfb372ed8903b75225c11fa6f48b93ceb0e56b6c27e5341550acac11e1e496824fe12f840d851aa3b3c39163c668271fa8d4f05deb362292a3ad9c2cc706692c893167a9d5a0f661ffa2ecec9987b30fb8a88b20458287cb5616b0e4e15edd5c69702c53793af1f4cbf229dcee5da2c528c3aaef6cf849f09e5de80c7802adaba4761a358be12742957625246b2506bea14a98404bfb4c70cf495d32d133025cc4c9856c3f45363be81f541d4a6632879474a3c28e5eea935952add69ef4ea9000796464d7214c0a5ad67c0751025f53274ba7a7da91084e0c8c8f34a1cf0f36758f367390af30a8764c4b5548fc8274065c3c64444aa4fa770feae1512278d27a7330f09ec25f7ad53942aec2bb7f21128c837213e3370aefb3eb9ab509b5230c85c5920fb0c95417e91d0b44b84b1883047ec4653638cef58b7ce530d5d8f97adf37321dd8127ae7e16fde7e1195c1059c55db503e583f1b8a2c5db26125e5a7dd49eab02e2a62e9b8a0c92054853360bb4449f0eb7b08ffe2ae7396601690c5caabe66fc2d33f2ce108c9f7f6abbc232df084f8187754039206fd37918e40cab9e73e52aad6c9c3d388ec859b9f08f0df4f47a5b0182485c462f4d0dd780e77fb0db0f984c941fa17fca27d0f92a57736c9f8990afdf34d06edf5e0839cc08c65676ef6e89ab01f26f7eaee4647929b9d3d0032f7b90e6b6d951000ba1ae9a0338b58d0d459b69486661e7b997816f6ef3d38f74d662ed2a0d37a41d93d7f6b5094b73ff0e6a3f3719cfda7412e46b0fd8b4f76229c5b15a9d15805ca0304df85c7220a797733472e2e641b98519c23025fca6f38ca9ede9ec5f1dbfdaef7300fdc058a81960de97909fa91be4925ffbc0da4c723de98d7b3034d6f8fcc4581984d742bb3d947bc3ce964266e1dadc4b069733c0cd376016bd91c1971d7c78d7a9643057d1ed865190a338ac62ab395afc9365cd0d44eb4f4e09c960229ae305345f5238b61c884b3ff1b206c787e536912ccf078572aee5ce7ad478dcca7de129b73b8bfda130277eb42ad0b81ae41148a961bdd363899f5495b09fd9eddeb9ec7aef7eaeffd865ff3d283a5705a6d2bdba32cae28a6c6a6ae6b3177baa087b7d6f7f7d5dadf5123f079658437a32d6ff531f7a42e5c321a0f1604e587e9c44f6d4cc5095c43da5e64b2f720eece78b07604690c525119f183abdb2edb5241ef19e844054f595f6eecec55a9d93ad3a842d3876104e2dfca903280cd25f1d03eae316b7d50e7759d0aa2fabe315b20584223ef17be903840b36bb00f39f839879d9de2b628d386e1fca2431caf588ac66df24946105aea13883fae0db043ebd7a3cca6b86e9ffb72578d7c1b8ac8447c2b1eb42fa1b2528669d4c969c0debae07631e1af20415084d8dd045dce3462083443f61d7a2dc60eb8dea9f683ed9ab0fc1f84275ac35645dcbd3a129573b9362f2f7683b84649d32bdcbd3ff3c25bf9fe890b1c90fb308ce175b8f6e540ee7dd96811d9d2afc1a371df433f5936580806e0272a7b3dfeb4fd60bfb98548801fb437d2f46aba3c78da908fa6e229cd9719819f23e4a425cc63a1118e606f9f87eb3bd8d656323ad5128000813018c7183127f68b1b2527ed6b053b8c1b50269cae6c84c25487830c3b183734a336dba5a3caa7766454cb098345eacba75060bfb4e3a11c79e4a9e143f931bb15dc84684b7c00aa1a966c3d1c3494ff0768c5eae3cc8e955d4ef04e5de4a5aa6b816af8557df9299942a49db92f4495c8be9d8bf8f37949db74dbef83e62b3ad409971898a3d231a8bfec653a72f95366f46a2cb3c02e6f16dbb0feef5341b41b13598a2ecd6e45166118f4dee606fd44fb42adfe9904c82879b20eeb21d6b929d17e8926face2678c7b4a6f57e989aac874ec8285f4aed0a0998bc976067113c9ac11767a5f2456e08e98c8c4a31da3b700d0254ce375c7086b12565c4d7dc11b5a1d62dc752c458d00ee0bbd50075f0ed129f7ba6fa217a93d64dde7a7d7364cc4ef6619f527f00afc17f85c713c0726f45fbd7f1ed7855c240fabc9f4e3e9a9139b4340fac3f5f4108029c9a5acf5ae4115000d884320fbe643e2a6c800aab29a579fc714c3a97c1907d5cc171c4dffb5fd3ae0624bef21be1958b37affe4836d04ababd75982966a22bf720518fa408ab17b6242a5e24b29bb622eb11f114d0409fdc6f4495bc682daafbefdbecd177c60a1ca84790586ab75543fa902bd26987ff1b5fd6fd5d58335840ba987b3a7410adfa17845cfad9c69081f3c6a77704074415ae182a3b2a605b34ef55242acd831070a37237ef2e98be3e2677024b2b0d624e9a5aeab44552a1142812e4acd4bf28bf557c2b9f12a3a3426627122b889b4ba8483feb6f121affce339f7e6aec87abaf3c060c453d10340be654471969aa665b93170ab54f7d138b711e0fcde184cf3d5cd6bdca25c25e59e925ee00ace8b6af5ca3b88973b617cfceb42f231a1aac8a15f2bf1d135db8c95d7de1ac261e42bae666f8f7df5ca04af54d24277cbb53511597053e2dc5a9023af102ba73ec6d865e84148572a7be7f920882770e94b731698f6f718d2a58e5ce62c56e985ed7b2027f17da57b5c3de4ce9e144013a1e8eaa58246f7af46e376d27503d2d8d2cef1169efa177860ed3c6c69f4d088bcbb8f101fa00c6d7314e466e2bc1b8c2180f53a1a4f285cfaf3ba78aff5c821a909a381a8a16ee1ef9c5129305904b4cc265c1b8f7f52de2b7e2d694f9d378c8c5dd7a4cbc9fcd8ebe66bd1133f72c31da849199713e8c4495b7dda27253ca130ed6edc8293c5d444537ee81cc8d41a6d9171ac788d661ad52577d0cddaeeb661f61ddb041b1ab7022e6941b328da5d6fb94cad0a4987ce0e668cbef393bbd80d7b656aa3c81ff869c3c27b661b791e75f74f2b91bdd783cdc01534cecca1296b595beddefaf5968a2338e07d398c9ee3288a6a1ecc5fa8d4537cd71a728075bb686d8f75c10a4d0116638cb88d859464d7e6ebc343e54ae3d258bee29b783942119cad08d11f5a41a023beb2e861f6c59248ea650f97e7f242add479f551438ca03197572ecbd9562f45e3e7ec1deed898dce91f3dfa7743d0bb3a4291e18fc074cbd3b844f37ab48b3d9dcdf9c901e6bd5f89f5a8865ecde7be7bcc6b427b57ca737707817f06d9db9163048365d1a83d5771c4e6017a39de0ace8cb9d525b4d010fd8c2dfe15c71f4f93e9bf7470ffc5b2a02c18a15a60bbcc50e017fc14bef60f253e61b99c782c2add6f30e584aa7e738e263c0e81715427c7f206178a2671094c75d45fe823722d6cc697105ab4821b39a6d947ec3184ed956635e5f2272e4aaa1d9410696001d435c6968997d3e85221e18cf798557b66861c95ba73170616d07d1d70ea38fa6ef1683ea97e486591aac6e6a1e758506ea361cd1afd9ebde7c5428c9e801ee2b6bd80f136a010bc1a162d70ce6b28d05b274a5e0e475df806da9dd5aec6cfabf0aa3964ae314a1c6d8aa0278c3ae2288d4ea29471eec0119fe9948d9eb549fd69f8ec08406578921459089b606410a4633f450d5943c9fa1fa45faae862fac281b6cb6a309856f0f9d3f20e51b94db742c11213405e6048c6e032f5910390522b05e37b6c60a790087c55fdce961aefd28ef2c3a970822f11a7f74475c12198013d7a990a51cd78f7c2051afee8bd24edb8b2afc7fc045ffc81d475104cbce2fb046d985dcd72186c73ff8d9a6a118c13cce938fe3004ea8b6fc17d783e8651c12de2425fbc7e00a9e816b2ce97861e1907a783c7cf16833ef495c9405995875efa4f9cc00b5cf6bd1a353d2cb6278ef9a5b81dcb737b692825f7c8fdb73e5edb17fa4a67e6de1905bec3b78eec751d6a7b93b25f93f2e83594a923f0479795f73a838d3099b486531793a8131c66bab1e9b609c93da2166cd00b60005158b1dc0bf1eabb56b775dd74411c48b2201e8f5ccefaa50e7f062d6c7e451d109dd11f1c74c54ecf3e41d6af48f789da0e5e3dce449ceb95fa1feb49a4f7996d810d868bd6c3a46800b48812ef73ed6a055111e5c20e1b5db366dbf77cb31fbd9ad21f7b76aacf74e7a33d15cfaef8ab75bdd722245033b0c458638433631d60a1c61493ad678e8b30b77ad2cbc9636dfa1750897b228252f12287c93460ccca99df2f813dbd0a94a4e7fdbdae18aaa0e696072fef863eca48dc653e4a14f53dbeb4ee16685a305524ddb13f05c9a5ed2a023b39d3204f1d857c66def84499a4696b674f4f82d91650328ec425d8393eb2b96716015fa80ae52674b1e0ee2d77c69ab5e59e8be914bfb18961a3c6679418de78339888bacaff36d1ab5962c3da90527b8ab92190037fb1bf1a1c41683ca0c436dd2797e4f513ae5911b2f1664ed3ddc359e48b4f318d105fe0c1e7ee2863d2308f6b1171e2514075b1b21e585a79655fffa05a2193d31a0055e195cdd1a2ce6ab642713d6f18808ef6998f6ece2b95eb4d1251390d57f3e22b267cfe99009be4ae086d13b9ce36fd04ed46e76cfd896f6449acd0e85e1ecd75df9c1a4c9c64ffcd74a2d23c1f4e6a9722499b65b708abcdcf3dd71e10755b276d7ce2cdddbe6867fea5e719471ab2ff965a8236ce9c4be89c62355e41eb70e2e0f1fd72396e8b457018c66dc91d413da917c2d31cc2ef6547f8cea65df8e2a271e4f0b791712cb1401951e8661362dca8fe887e7bd86aa61fc1e5d4bcb648d72da6d0db8b9283a46b070fb741a8672890f51ba398bbf1dc59290f1e6c1d69f2f1cf8f3f4903d75a127eeec041a34d9d306615335d83589d1f379aa9fc35e1b7bfc5843935df87400434d2ba76073e27f870c4fc7c55565606c04f0ebffc90d88d414f89f7260c4fbab60020fb28196274377580b75110e288826046ddb74c4725ea58660cbe1d98a3214439e3d55cb70817b910a1cabc1ae0c5adab9904d13d26fb2d84a83c9bb1d51ca7941aa524a670473869173f36e04b1f35f8dd8acf945fae38e7d20c2909e249756102f8750f89ce69f078c43bab4c41fbf9caa6185f0e3feb1375438df756674f12f8db01f8ba52d7cdaad657abe38c1cd1d567efd21453bce691114c5085b37188e5da732f4423b842bf1ed33907ed83cfc7cbed2b55b03ab6f5c4fa3ba7ce26864f9a66cdfef7214d03ca1530161c0faa7e79ee82a1828f464e7adb42f7330fc08fd5dbfb4c557bcc362af74bf18e7b5869e304abb46f7bed645bca4e7b8fa100da3a01604936e0fe50082cca5f3103ad5239a395e409ac60630138bbe1bf97eba7aa6bdc0de8ed6223e4949395a11efb33ae72e4af59ecc5eeb7e106220710ea72fb013fb0a9848b669428fbcad9fcc6d2c2b5b4d43e3ff993e52250a32df0a00856dba8fb02f1b226e2f259f0997b51a4aa45ce984c8f319a20131bc71619789f94bbcfc5fa82f6d4f83359c14d6ae8fc70e93dd68460f0342c3501653a7c5f848f261f97fc667a0b22e2dc7cdb00a936346bcfc292b32a790c5b7383c61863282ff0a9a918fb4aec387fcc1c34e6f2bad8b99ff2bc9574661f6f681136bc74c8538e1ace2e6ef5fdaf7cd79cf8db3be4c1a983c71e48d980cb33e5f66d6f34c513626208385461cd52c7f054e6d5ea65871b0f2259f7a53c888fcedc4e085df4f287096c2c87b73160636103cac49b6e829a55dbd47cdd0f27135552a1cdb4d20d5962a7f5b2e14c843886499aaa3826e6c7d1c0b69f091d621e08cff469e9d5abe68c7756fe50c56859d4a429c3566625e9644de899d39dcd3a24a31005aad2a5518c05256d016adb0e2e73f1eab0642c06c0626ffca40af53967f736a955dc770ffb6056f685ca5020689cb5796ad21ab6e9b138d1d2a90989ec0b7c61a2205a6bf8efb85f558da745c54b2c3633ad820c383596a7cce3bce44a57f58cc55bd897eb6e653720f33eb8bfee1db15ad4852f4e8a65541c541dbe5ddf56e0864a06530bff21c146874263b0ab0e12d5e930ec4d4a2c302a4dbd0ee06c44c2a74c514989004b9a93fc1bc9a03ff893e0d7e0d15c28162ad8e37f74d85c6c37d2c6ec14c2a2a2ee85482858b9103f1546c180dc468c9b27932073f02159790ee5a98ae2faf9b64069ab2977be6e1c5af539a626f61be1bb36c0df2f4065613ae685c22ea66075a821381f662e8de27d86e37a81e3b5f40ded2ee24640ffbb97c0649a6c302b4f85ce1fe39516e8c077860aeb7ed054ee291a3e40c6afcaa2af473f5ec8a35ae43c9bd7aa527f98670d674c36a06731d4f9720701255d79c1d926c6b8eab52aedc77d0a4fb66b1abd677ad4f0533dd21b4132b96c65f82b78e8a11ce946fd76641b7da17c0d2ff6776b2b446ae8c9e5737f59e2a4eeebf88be058203c30f4fa6bd863928b158b1fcde3a819ec3b0892b11db59e4189b2c087af614f831e8658067605421c033477e146a3c61a437443c03ba31b1d7f1c4d4d7b75073aecbf8b0e691b11bb280bc99915230b3fc3111c74d3e46ab194033c49fff8db85ab4d41b03d8133852b299b861668fce4443c3fd64da2003d4cae5c28e8c7d5cbe7ea006eca847a6f638c091b98224c33a2ba8e9a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
