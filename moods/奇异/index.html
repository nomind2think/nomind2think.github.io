<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b4c12b6fbeff71591c288efd20ba73772b9c87ecd031001fcb214583cc058b010c5db2ad9e05807d5909e63e51e00c4f1ecb4c7bfaa60ea40fc310500601d694f55e8caf5290b17f0cd9c6bebff7819d35567ba167d98b0649afbaeab4f9827675e8159cd57128401135eea6f344de498802c00a85150448d9521991f818616904c7fa8545376a35a5c61952d160572bf5c591672ed7f5dd33ee0917e0286803f9b8fd4b3974750d2bdf459cc7a6385f1500fadadd5375ecc7133392766d413cd1a33b4c18ba5fc9448fa41f8cefdc7de0c985d3e1b544efe9a2bbf20045687dd37ff7972f1bbb2379ee8a15aefc152efd6ec0adc93741517f9f9328e46fb6a92de4c367aaaafce49795b0c34477cc0c33dc59f27cb89dbd30dfc1cd280856cd428afa652750e808dabb138d4bf84a3b8ec53f01c071a07b379d2472b129d075cd9c7d51c265e41b8032eb6185b7cff0440c000ecdf4af6b179b22393964109f96581d9e90d13383693fff4d5183cdb34c8e4e0d7b64e8996adde5b36b18599afe081fec89f551fac801389b32c2babb271f64d8e2117232cbb3eb214767cc7c6107820dd56d05023ae3b8ecd07f68b17c6c6f0a8b94a91c11a3ecda3868cdcf255589e89a7d857e9307b1c6deaf8c611d67495974d0da66ea1c03a55dedc55ea54624af963d1221d2828b1dc2dfe81862dee108b93127d2ac8aae207a5ee8aac68d664c41b526656f89461d545ba6b84cf6230e55c0808d39cc9666beca995d4c4ac68d66934e4c46c2ea1b82ba0de9dc91ad654826d67bb2b1c0e20db586284f9256d6108cf6a57a2ffb68714163d14f51d6e31f05e5e13b2a122ebc089c528d4b5046319d1562661276146253752ff3a635236b36a5ce62a33b39003f9b5f0509b40a3a2e801df6485b8e55be456eab0773ca09a5581946c4b05d050ba82146486e09d06165b64902a16f3b04090047f706b78b75cae11e66046486a6e68d327e784e9d9565f2d7a873e82801e4edbf6e1512d8196c012a6f045852d955acb6747d168a4976a87bb89f48ab1e43b2f9bc3cac2cbf7a9e3e3448577c524cf351a6d9b7c6ac5620b64e7578ddb2b2d907e4544bdeadf92b27b0623eafa5d48a53bb3583be11c768b90418b85f386a6bd0358bfc5a29f103dda9b6a0eb963bb9f06b2b791dfa0c8159aba13c4016b7a7787888004c62ab7fb30d5ae51a8c4450d2924e8a950b2607ec67c2ff59b0c6c3e334d1651568e4590b4d1c61a119fa101d8f62ae715f46773863ae412b4b467b55b5e6e08a765e68781e8eb3ed561b62e520a9b8ca33465fb47265d5f14419d6ea620320fafd740a7d6b031936600017a4042cac7886c1255d0bac56862aafe9cec959c39daca02da0504fdc9aee4699ad9c1d08783f5d13f7753f1aeed480d928434b1dbd7d4dcf05ced617e9e9832e6421c66b897ecaf9cf84e6e00b7f31f9c288b17fb781fff37b8fcef6c4fa070d84a54cff5d750cf261b1c004189650f44ab71c00d71385a1964d02ec57e24caeab5efa4d949c3088e3f671a4e1d5587187cf86b09a1b97ad3d032bf5a503d1bc9738ccc722a259aaffab1f456d77379d028f62d0e87515a5efe7f419b37180f74c8d412e948f3c68fd96eb5ae311c46b3d3439f3fa6e09b5900822b4d3b40fee6579f2353cf1987de464e26aec7f4cc5a33d936846a9dc91a0b355793742e4e0cb1428c0b9d1b9124242137fd3a9cb0d71e8c4ec6655368629b6eb91413656bcec2f4931885e294b92bf74ac18d034538ece7b92a946058a9236cbc9682a528e5a4fc0f75d337084a291ae6529f71dd44f675c1a4629eeb97f5e46b7c64bbc46cbdd188e0131af9c6b8ae4bfe15cba2d580d9fcd9ef42c43fbfedc7d8a87545acad49608ebe3a0b6ca600ed9c282f6c928dfeac826dcd41f7ac4bd1366eb1c1f5bb41260acccce6ba9502c314cfec765cf9ae7e3a019c7bdd7c4dcd6205028ca2246944c1c248139f662771da6a678e0c923c2ef4b509992f2e834b67be5e0fe3bd86a5180a8c2175945b4562933437f9f23eaf658d52e8df7b3945b3058ddf63f13402517b763874b334e3ba6e08d685043e80246d9df85e9e3d2f8ef9d97284de7c55e6aed1fca0ee049f2f4750d5d431eca1fcb0ff68c1cc1f63d98c118b09e4ed8513cc7e494bedaa6c67c376cb079852d09031e15d8e12ffd7bcebf7ce1d6d586f9c2bd14bb6c43c88c214c20b9160d7f9588c5336c3243f77bfc6a72b282275c55163f687fff679c7a749ac8873af65bbee11b58cc42961ee68456bb85511c545e480a5e932dd9104c1faf9595955718809048fb271a4966cf9af9315c70b3c00a97867fca3af013a8866b0de417c8338906864a14181aaa8fe9f944f71312b35235cadd35c4c713c5fbe7ef3ae32d661dea95dadb60829c2bd5eb6c8fcf6b4ee2463d3ef91675d773f9d2f7eae47bca1f7ff41ce9df5ce8dae149d7c4dfb8701cff1f179ace7619e1d753f37d6b3be431d935b34ec32100c6694be1cc2dc9d508d0f72ab15cce70e653250ba69a5be58b34abadb64edc4f7a459a1a78cb98d1dba72ac00cbee806eacc69d96e51f6548f52340036e7604267bd970a9df2ec1e0b99f4289ad376502f792c197ad1232f935a3df92ddbb8407bb81bd77ef9f9486ca9d24990f2d12bfa7a3bd4f4213764459f60387def5af41cac05725bb7faf7e962ea593982c3ff2786e7bc64fafe7bb2857c1d1250f03087762df7e1da4a8919dd679c037a550645b7026bde7c34bddd5efc211cb5acad8618d0f687b7996b27b582f3419333f4eda6b7ff5cbf69a51a8f8760d0a859f6764007e0c538406cdbb8b24385415e94006d8e5b338edb811207b184d40610b0b51b90e220ea96756dfe518c4bda1cd64b5eb5e21d36a8821cbea77c8821daea6ce5a77e58043a39fbb12cc1f2d7f0abc75fe780bb5b94ae86f8fd4c0d5f9f0cf5da3f79efdf9aa7760f9a30446f064c0d3c9b1ff6b1a55a66fcc52f23aca4f654f7e60f394907f1c8f498fb45668782cceb03848399674142a58d64164abbbe86791a111a6cc94a1a8fc970776d23006de01c3638bb2192582d7783457891f0638c228ee47d0591039191d9f72dc3749b1036954680938728c6fd633407806feacfe5d0c2b51bc2ec986fed43c4829fefc467a4805fb2b8a0efa87856f820ee492d163213668532a6886e96863e99d5b39d30bf872352072d0fafca626ed356f336d8dfaee086d50fec7c8fe62f2c76fae15d7624338c978e457bf7c3f8d0c94041ba2bdf18f67457897d3a4f016558b7f93fd6e31f946859fee5f95ecd8ff845ee71f73c072931b75a7fd47615415acfa0513cfc91a6292c52a6e2555a6e1625c8510a4a2a08a992596c83618b6b03674a37afe49b0e973dd76053098405a6144cd0c026d5841638c5da5f1f64938fde42fe293e815010acb3f6c33645decc9319ea28336cce6b538189ed452859320e2eca6da929421cc817cb1615fb8e044e75ecdcd1f9fb6c6046f93048059dfc6f40edc2079b244b678ed77787b44b2622d45104d1471c6b6d2032ce81467b979d892df076271d05050e30963439b7521f21ba645e719347fa41b51c28cb0f1397c74c9b56c17a498c95768f5771b794db255c44bc31842e3631ed242550c10735b30e44112180649b01c8eb8b27f4f92d8df5de380f76abe23c838e5a9be6ba788c76bdefeea44495b343bff96cf04b810ef7ab876826f6ebd16e95707be049a438bff58d6001a2e66b2f94f13f03155387a89ab7d8d4a47c5a16667966ac30644aeb0a185a3a9d73f0f198b7eedf1da09ee8488e02403684de060390ab0c5f97f1de167bd5f9b9d636222c20494e1326575fbd932186572e06bf5cb4fc527fda8f8e849fdf5854370e7becf11a48cf63808eb3a72f1d5973aba2b739629d8775abcbcab9398c621a76fdd4bde0b18fcb848bf18ca1d2b9dd2660b49661aa40d22c6b440a6347b3eadb6609ebcad5abea74c86362efb880bace0f93e1372db10479d77bafbb6da24e7869d907716e76dc3afd59276ee4e32aef7b9e6b886f0f0dcc73d354f3036a72928ad47bcd44fb4ca5153e9dd072ecdba85f97ffe35ddeefde6fcd15bbc44ae7a28426296f1ceed7c290a8a6147dfd446df37086448b054ad23e63ef7bcb5649736ebe6b107e6af7f8cc6cd5e197edba79ab943b437c375990ad68014602703d9301daeec82e5adf6089ac652ba43e36608667739a2fd0d30f8660b8363a496a2293654910d8ee75bcdc359998d6cd9182d81f069e3319db9a44d682303eb2770e76bd9768c3ac54b416cd33557cf412e59b5598c74a622622bfe2259f573ba7b99f7a94c94622b4c9ba236d02924633d7de15565b32e9e8852ea9e006335288baa979dcb214e873b0d1831d0b56fc0ccdb1053bd056a0ac0b05b3a4791d4adf7887051a9f2747c8eba6f983849f4ac98a53570df2dc2d1e61daf6f56dc6f8e9c960779b704f37ca4cb710691387839451802ab77c13cc6e7ccff41fd1f57dca343a92080e3e871c4dc3ed28c4e22ede5974c83e6684804d20bf0a6838870f1ae76a225de88ce67bffdd1de990bcfe4880f19038dba2e62e9e54b0b5342254d945675fbe6407e08c6c35540ca9dc22e5469850472094c14139fdf731039a949bd59f62da55edf35d873361f20db9bd1f63016169d71cfba70da3af924a53d64785b7c316c3831825583ad0bdb39387d45ebf1ef1b278f693d369ae1687aa8e030d5d6746c287914308a4d493781df240185972876e8640ba0b61d864621260fb786739bf8a9055fad6efb6eddd36f057b5982720a2290a56af43e6f80fd2e06a89361bdbbae44db0d8d4a235a998ed3ca88b8dbfaacaf93d2d0a2072b89afdbec2eaddd517cabcc1c8c5b0c999ded824f2a1b2eb8b5230e0ba8b376d0d3da4901dce3b46a5e9c933533138b90cd191fcf8277eebb384a9750665450d6b45ef6fe3b382616c80a4430c44fb275923365dd87194605c06706b0e229aab8eac4e24239833f26cd223a9842c505012d47637ddb3bba0a9c4e5cb7c25daf794c09dd77a7bbda61eeede3223e4015a2b702589c5b1f976b71b2154d915234a0d1cac6e72b76378fdeeda65d9eedab5b4b7c6c3950867e5d3fe7566994f023e4a99d2f3af431057c85015bf5cfc8402281f3228625f6ee0cf369724b4feb61c36c24394539542b5e362bce817ddee3db8d6dc9c3e1846272682eeb94eed9b82feae9541530f5cd53c5606bca12f1183dba8b09ca5fe4140e668604e817811dbf67b080a42c127b491cb763dc6354f1d7c31100f9d19b2be86d50c94a8615beb7b71504ea3863d3f876281ce9f26533797e2de9338497c679dee346441a4f1087284955a538e532fd5fe92bef6b68aa41253b5f2e8140375a45f22a81e64d9ee7d58b371fe6dbe9c450e9bd2fdd3a18390860d74e43ccb6460b3ccf89736ca2f12d95645c7e3cb63d91ce59ac2427a9479916f81acca6447fe065441c710d0b1ba34b600b3047c1c3f47ba82210368052d58e2b106a9e0ca87244d74eca75047f6918e042c6201a860da9285974f0b73c50e68aec94bdcccd8c8ff062477e7ed23ed7ad3ee8e321f3b4e7da3ad110d4bc2304037743fd17b14a6cf569027f2f39ff6021ad90e4dc8a18feb2fa89456abaade3fd4d91fc66a5b472e6e5153695d1e4fe3ee75a47f9189980cde83f775623ccf0c2ae9553e8e39ab1c87c01222993ba684a84ebc74937ba4ff28d6e0299aa1b962976fa6141de10a6310bc1df14711c994302c873b5e3572d97b6a3e0cdfeea11497d269a70f148fa327f8f1e22953e53d75f80ca61dca98fb31f69be911ed3cd79d075a31a7b51371d82ff141c208aaa3dfd4f8d7f3ff4ff1e4ae1bf087b17c923ea42448601ac576e839d7522eb05cde8299f6dd0027863cd06539760ace422b020dc051398318f94c6b7333f599e58e5551db36d3abeaa8a3e0e4948bf5eee066e9b6f602fcf584fd54ff1e5d5f9ba8d30e2fb5f2e9456b8026f8aecb89028e80983e1ac0340aa963ce206da367a798f1ecfc94bf1fc0bcdbacc8e50ea222230935414be6031fd7a7834418af75f4f2304c488089e371cf40b3755787c449cab7eb2001408d8939b31f8a6fbe8e01f5f94744efeeaacdee0279aa76f713243245b63540a633ebaead1891a146a4141e8bdbd2c433fa1ffd12b438eb9f9c988e10405065ffcf8e2c63c51791aba6d2ce7ab0fe72c3e431f2569c657b72a572ca62725956b1634fa90476fa04a41c451da3a04ca2158a69fbd16c060fc902d3df1e49da18504cb6f6f4a2f7aa4bf6e18bffd5016bce812d825cf22e77816cbaebe815abb842386b3669f6fdd3ae669794b40e350f676c1bd138c27a56d91a2f8b19fd9a3e758fb6df900f33dd3a04b1da6aac8bf6800d9c7a7f142481a672fb1175d4e6f9465ce566c4dfb72c3a650a8aca65c38cedd75cb943a5c24427b7f6cde900f60d5057315a5408302f9a29a376033459f578ecc5a5f8434e2f3e646f94a7b2347ea35480d65e323965363e327e81180076d3f51d30353117462d6870831c2823d9bec4022495a2b1884bb9caec0ea41173243b169d7145decb26949b318f88a66f0268ef86fabdbceeab1e650d0c9b3d42f0c61aa9796733443ac63406bc3dc8890c57103125b9c8c7236478f4ca90d39a99658a40cc8243594bd579d39d3d62a26d9952079c98762e32f963f78e17a1fe8689e5bc31b2c10826b3b5fd6277b1c2066dec3a2cf23bc053b385455cdc92cc0477511a7842221b588744f40346a3bada1eb2cdf7d6c9724feee97dd076f9587c93236d443200389fcf41d5a6ce0bfb586b6ed58b95ba5822d5696bed546f021270d39e63a1e321ceb17df40f2f3ac61ffaecb941062257d31bb1a56f6bf275510546561af628a7be3ed92111064ebcb96c27666de8dfa11f5b2c90dbe37c65f42d67f965dc72892275e6552b226a30498a6cee90a62f129abe91c0cdc90151c35ee7195595f6ae18e8b318aa2e671570e3cea84051929aeb1f6c3bc2fe5ea11f9f89b346c85de2d576892b9b3d57d14625159c2b11702c9fea03c32bafd81988b69cb8c22adab4b795a6a1ad9e41dedb4f31bc010dd9cbf34b10bbe41438b866fad1ba191421b55e15334695bfd51bcca8c497d8fbb3be81c463e1e4a9f851271ac8368e4562156fdf92f214ffeba44532d2ede7221cdf32b4dce678b6d6b92358a9d603f0310c22f0c8a51790f47c0b613d288b85e5a75351fed25f9fbba157ac03b4431469e5d4c5db84725c1a63892c4053279acea8f52add9db6b1006cacda9e3d8baa23b6e89f490705aa428a2b322ae60fc9501e665b3907c7f44780a8a8fce2799d25237c78b03ae72dbb0f0f32226cea425868ba54ae220607d052079ce5dc9696ebfaa25e6f3fdb9df38db1f2a16780ead12399011059881429717155a72f61e283cad2b21afd320dec9eb73d8c00f1ab89beef2f86661bcc76572e9e07909f45036fd0836b60f5f48e7b48860f969006cabc25af28ffee4a9af413657d3de0ed71b43f6c9b684c1432f02608225f976a9921f73d65b3222b3fec3a88171f18c1ab6521bc462f524de40782a8ed7d98d0e6c9ea32d2fcc4775774c0013bb3fb50e642cec3675da550d3bee1c9a39dd08481d24b2f74e058f0227a4105f99cf2823039972e5a3d5c84de2aa838e9339a1ed85082ebf672e8df7b5c0c1457bbfe3352c76616cab793add2fd89129528861a95d0a0b09835dd1eb6dd0c8c4a4f77e528660bbd4f54266f7e2ff9382e06715c1f38b021278b2ff1ed754a3a07202294a8d07b2bea3f1e682701c5a4b78d2db2233b8663dc02ce57d5ebde1d27c4d66c5c61e8a186919aae717048a3bd18e8621dc7af81def43579779f599dfacb3a3ab26f50104a28f8a00e02e93f9a579d5d738773b25e741d69634b622750a77442e27720a9a1a4e5ec5c4fb97fb6c717c2f785c2b6937e35ce5fe8299b4da5d567c962325125034506b2f8e50f27b5c67518cae4e01173612b778f50549e9847540175248775ca0492669b84d11aae94076e7f5255fbf4e710c94da6c97697a85274bf8949db775dd4119b526fd2a76616092dec3f8aad9188cd69d86550f4b4e15b734ac9c0a26a0dae6ffe209288e00f91aa042111e4419f95248766e2372c55af62cdb2ac9649b6fbca99c958722992222134e9b1102a4e9556f26498c4a95bc1a238d9d26871eddaa56390ed1165eff62efd483c2c423c0f56168efda0c07a3bc51bc083c962a20d3670d6b64ae87ecdf3deaccb373ea626fc9466dbe55637eea11c7a5db14f5222b7b0f03ca6585b4de557afd2003ac9465f1225f4311dd81bc5fa926fc83a5b700e00856d3a4f4e17a8f6904f382f5a57aaefc60ce7502d6c4a5cdb1d80547bf360f8d6c60e52069c19c4e3d984063a2472f23e251ce0bb6f03093c117bab127dc4efafa76703778e362d74c0bf3c9c1942005ab01e5842e4f800c27bd454148a5460824fcb3d18ee4daed63c2af8160013410f04782523c023e7bd36ea528946c2e39aebabb4ab45e08cad1b5c93bcf31215a9993f8afab1e5bc1f628e66c97cf7bea92be1af05642c75abc6f6aa59bebebd17f131e63c507971a1da0fbc7f46a624411ef9c8529620e04fa2b1a2935f66544bf375fe1a4881749bb065da75b020fdd2688ffd74f81f8a2b3837cccf6df790cac9ee445de95298071a6635ee92699b06e782af74a2d36f462b0d3337cbefeb0721b0d279b4b7e99dc4dce7dd6fcf00b90b37363a8bf1bf5ee32fc5130dff87a4bf9d45a2163a05f31db5748e11c9af7da9a5da5ebcdea7343f026f263a27ebe062fe67eefee4064ddfeea7e0b44e6bf38889cbb10559d11042dc95ba36c92c1f7c389d7b0ed486a5dbd1dce4f84d0c6ad6dbef9fec00db33904cfcddd75d70e92dc60a3a10b9fb20131d66ef5ceafc9ea80f56e8834b45ab1e5d2631a35a9b207dcb2f4614aa869767360e8681ae698013df5c2e4adbbfceea75d658981ec27302ec21a920cf7c0e522b9267f9d45b2831066e83c1042733f1dde0d3ac9f514db7cb92a136d23ee97d36bab4253cbf20728f91043e3f7666fecb26f44535b1975e68cf4bd55c472102fab79dac7a2780c4d49d297522e6998e502d0d51e6f646eb28846edcfb65817483a999fa2fd5222c6170650324f856ca1a6ca011e5cafb8474cbcdd630f6b44d1ccd997ad2c655dce484894b74129870b396ab18f8519d6af523c85ffd0cd006a35cc08cb76f1db29ba4fa7b81ad6c0c735a2b2782c4e4a5c712e3fa1bc15d196aea579fa59304aeee8866a3640137eb5b879a26b1a2a6d1993f3a1f6a083a5892cab8dbf64a91ddcf8018ea02b6b6c6b3ea6721547534ad7e7ae37627c3a1e86d884f9335b1b76c2ccf6e98b3a62b25b18a9816879884e3dc0e47b0e581817a76f84bbc335566aa93eaf481aed398809f52ff81e31726ef1042967d493cdbbc61cfeae7504000db426e84ff06051bc92649765dcf587df8d0c07570580b8a045d74438b48a42846c8a74bf3069dc6039dfcea0898b3bfcfdf58dbb9f262f98e4e3adde15833846a3afaddae5829f6410e46c3f7544c342082c3ee8608f9297cb0a4cfdb9ab184f73911e723c4572be6943553a0b3f0407ab20c7265ddc22c1c7d2b6737c008bac4f85eeb113c64d291727121b4d140af484860c939c88775ad6cec85da9f666460548183a11519f9e47a3194044643b7714ee418573208c23ae9672873fa3318ba940a2b17fc11b51253de02800471a8cf279422201e4affa812c1d5594c4c843b7d117829429c94b10dbe6c947ef0113ecb75f2116ffaab51643bf3d4140b516069ef1aa5964f410272833e47f35132f0da74c9e2e1fb9a8a3e1e790767f7e680520e2459a1c43ddca7ac7170befb75480f84d83fce707870c9128ab882b74d723c9e55df2df432f31aab0bb5868000f8e36cb30c8836ba1de43515c5fdfb2c2d3a68f2ab784c59eadd9155d3a6d9d39b6d4251fafa812ced4d812eadb3baf28eb93896eb7b554964836b99341d82c4b639fb269ad78a44765fe02b1574c0c315fc9a5b5440b024e7da25a0849ca4ea7123b0786b7f0b8ded255e7d2a153b22f561403e8a25a74587032493440c40bb61f0344be51d630f72243fd1715b70d907aaa068f3974cbb4a3c5ddfa847deaee345ec3e61586b167d09cbbbac07299f942d7454f86121e932e2be02cdd6cc7d04b57ddb549ea298e9411e28b7c1375ba4f4369166a9b363259c3d9b8b5b4d82a78750aa703ea67edc9eaddcac114410dcd892d4a6eb70eb37d3e4d2071c7a2631d3d01f0168811bb252d1794750d39959624f3eb7443de9e26a0dcc584dc271688ef926f86790b2531fc86c4d3c6b039dff7862750b1f9310f09bb7cc80406590d334f55c633a591eb41287f7e68cb6b169f2400777869f7f30e3265f43a1f1bc9c01a70aca34852962b976a30b969600912a6f48f10b4f040f71f6e9a598fe94182a1c3835060754723c4ae8682621db853e4b1895a5e4ed4ed4bfce5b2ed9c5890399fbeb43660c7fa4ba39600562a9daeb5362c75016c78e596e30627485091d3ddb4ce3dec93e07831e156a4fb758fd3bfbbf7c7b36dd6305291beaf9a07f709eecc32862","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
