<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b49c567f0407ae5dee8fe49ed05048d783491ded29baecaa5952dd6e40214772bb25ffc52131e964721bd312e67a8a5db0628c0109c33b5507e2d4cc6f22a95252f2eb08bca57aeda63300e341ca55bf5fccca65669c538d2cd5f682f5506d895a4beedeec7c6f0a5a3bd0f6c0f555fe4b13c8c20bc4bd85d753f450997e604433ab07ae470c65640557c6beca37eb958f8a615c31bdc52bcbf9a965f727173a5cd6ec9b680c5fc6cdba5e4531317b50c84505c086a6871c247bd93d66952ac84492edbebbbd8a83edd306e92eb6a6e59516662d656a3cdb9eea4bfdd1b341acb5aaeef0177ad01f2aabb77a862de0249d8a165ad83f97d21581db84b7e4750efd8e516f4bb2be49621ca30d0a2ec0c80b6c43eabce7fcd45cdd184dd7aa7c6cdc94be49b7568f85ecf75a44eec4b77b728d31e7d6f7ee1755f44043dd59a3c1d968dae0b641a9e285a10a7779a8581cc3af4a331f2f7f2262f1f4e11e396c7db3848cbf59998422f6e2648281a0d3cd98791ec8af1e0b7b28bc32b17ee04972d3e0570b4ff5e7cee52f1e36e77c5092ee66aec27283d351bcaffd1558e0a8e465f09315de52307d193bd64c0d2a508724b9f3a8e77b0f5b1fc5905978c83d4f3c0a82da7e88d9072b9f04368cf8c1f02552ad33f655c234d03bbf63c744f90a809494d75feef05ad4bd9fd9284cbc4201591c9a5cac78920f596a9fcf250718018291ae2a9d4e1b5d3e2e4ef746fd60ed1f7fe6e9e9be20fecb0d05466f98a5021157149dbeb4474fd52562ede34e5e89a3ec337bf38b6e2f486f8570933d19451a3fa9d8089fd7a9847f50d73b8120f56ada4ab87cf8b7b7fb74c8a9d3e4f131627c8fa3dbb9a1100816ad9836ea7c223614ed32dc97caa4f778b5ffe0817a8e3b53c4dee232d9dc5f900700d2b3e30ed1664bb251780467b04771c9354bb4c5bb161af74d3dd58545b337b17e053672caa34b047d1248d07323c240241c6ffa797bdb9312401ab8cae39417fe6bd43305b96a0bc24edb35ae02d7b30a76052d4bd70ec2a2e4d56ad14478b6a9d8ed8a52da7f7fb546a4695b0b5e00d6c1346031bc426599fe6a3108cd55042fb79b21c2a589216f73e912805b014733c12cc197b5cb54ad33d4e7dad40abf07e2129bee024e76d6205e7c53af145de7b61dcac15132c79f86ef4c4bf37b6d7a5e25d5216868f76b3e38aba11d4e06c6235767a0bf215f721ee253714e5679bacf74753a5e622d8a2133892440b82e49fc0004e22783df87abf6097bffb3ea5e59a4ae417944f1ca19cf239d445d516be19ac09dead7ec87e433eff22a88929b7d0dc616c01cd7875d83ccc3ac1d0e878bd4b4d055916d24433a21cd46c2369756aa9b8c87efc4217778b035f9bd732965e50403cb2a7c9e7d302318da6100117863ff0fb8b51d5559b29c1621bb455e09954e1a77c3bdc218275931ba4f9db1adcc28c71af1866efc1866083c2f93bfca45618ef02bd783cbcdf6574ce979bae242a47b8b454b258a94282672d02d5a17b7852c2001e06cd4aec8f5afbe2d5c20a1adc787e22395a0e25f74f7a37f03e83b8d88262cdaa77cb250c864078da2ef9ec9305e0d9ec77f09cdffb3d05fe0f5f9d5485b11b7c32a0f128546398e03273675cdb7c42f6962cf269b214a25527dfd4ad2b23a9cd83e0f41355b94a227c8dbf240a309f03e34796fc4a659f53e1890bd4861e399ae994390f381e3ae3c4c0c4ceb9abda313e8b51f8aeb47acd5f95fcaf417f55b52122c0e883cf79d59806d816666da3a3e6ba997ca4207ff440d7703e5effcce3026e23edca6006577bf1db173c9f5ecf18424876e1620f3ecb5fdbeea17218913b4bba639a1104c6f7b88ed39a0906003d50f492870eedb51a38f195f2057944801c0de00dee2223c10696c0859fd8a7a824e6691eacb384a04483aac2835b33512785b031ecd240b0b709470e2ef1c8ddf012998859faf3e5c623df51aa1c43477859d61c2b1ea288b1332ee235546ef3fa104d5c60ee6345967dc188da2cebb56a0f9bd4e4ff2767a770c17b493fee2b44a34a912dd3778430dd7ffe3347d2c9734112705c91c72be1ab647f6cf602ef507bf1fe2854f613933765871d69b35534f70dd32f8e19d03ab3e38b224f1478903e909dd93da0049493a0d237652d7493f5a74078bc4649e26cca78da5b5f64d4330c5cf5004b3cf1d38cea3f67f786a79725cc7675351dab069dedda08a6c9a7cb3974157d9b2962010b4bdfde2d33e53f3d28af9e32a50c29f474c2ac5f2a27d4b83dfebdf58b7c0a5a9aa862ac31014a435286938552476c5b54520866b80f83ce9f70fa2da21f61d86913d337c4e2ee37de3558bb7d35a7a6269a80af991299ea2b8130c71488e6dd8782e68ec04b4a446bf89a0a172dfb53e4b0af24b81a0db5a69070cc654739c0a90653818c9d86e9ed84fa858c86d9cdcf832d64aec807f30a4ed09c4294dc9f0ecd54c74aa664364e67243a24468d13f2f2fc892a0072dc8887eeed22827ab82ee0524d98f06d6f81156a9cc27f7d7b8e0ca45fe9f32c5603d9642881d589e60c19ba0ff2bb9047a81b41896345830fb7d26734b248eaa61ebbe103ca612187ddf7378396928d01a5c7004d4671256d176c56a7bc355a5c7fea4b91fce89344ff97d4b09d673aa3c920371eac67912df821240bbf0519f82db56d4a20fcc72bfabd166f9f78268212498f069ed3f6fb2372c84d51f3882a18c821b7a17c6b2753b7c0a8c18d002c4aa7322d2822d9cb02bd58854828099d4b7914d5b1c13b88c137ca3452ddb8fad4019e3dc6fd84bd65b999d43a28b6401f06d7826621964a0644f5ac8afbf9850c020d4e03dad7fac3a6abd2f686f65b85d91a847c004bfca47491c22bd4781ffb940f4123f63121e00e0ea895fb17dde9fbb7974179e67af4aa224d8e81061d2c38fee2225a85adaaf96e831f8a8360276ea44722f9ce31e6b01393db82b713ee7824e822f721087f63527b167038f6a564da0684565745439c0c15eed9dc6f90a8a7f7574a79b916b20d7615c8613d8195dd1a47a3c9c9c97fa960d1ba971b818cea64ea81732ad284abb907fd3f7d150c341c249d1cbad09953d3d658d82443b8bcb972658f341c28dac9602c4827600eaddee358331d986d9c8cb4e12ea5e54ce538429aaa490d86dc5d4f7d5895dbb7a2ac822bd68d9c4703612268bff80ad780fdc725a21e4072621185871f46b2484b138032eb2ebd71759f35cdffd1cf77974afc03c0014c0df8f9b53a6dbc961d06eae2744bb5d8da4748769bc641f81d8221c9a2b5df7e355aa61e064284aa1fc00daa1c6757a8117d91010b88406895d848f5b59eec36ae5aee53fb6c93ea889b03a5f73a3fdf9200200ecb1037550bf338968eca4700df8e67846e537973e78cddb6188e11f3d3446b76cc3d180e4c018cd51e60e2f0e6e537d83cd6411f7b930758f34ab917bf0db1ee09390ddb6ee9cec5e021e6705402b573ff58708d55fb63f90e477e87f4fd1b46bca8655e833c8676dadbf09378104d0eed0916055ba5b7edb1023599537834116441932639123614558bb8f0ee68ae1faf50abffc92597505181213d84a214e97d059266da50babd8f7cc6d958be9b1b21c3e4570eceb2d465f04a71dac197ed93ba6314483d39da2ea74219eef7050479c9e0133b09171d067e60a038671293c680f1d28ed9a0b89988a9971732e3f4cc9499528ed0d963d6d4883f3f4f4a094098de90571dce9d7389023a619a3228af70f93a87b747092b60e81229ed1d43fc1b251b510e0f4f19b2f8864a6c3c6d5a7af8d58d6ec37c10f74cc33924165e301a8754159b5230371baaf54d416340f46e93197c5dd29676951c063f71741a653c70742bbce5ab061beb9bdc968ca7a4231ca0a588810d91a37cc730e4541f5ade26fe5321d15b02b78994c85b4dc5ac6a40f8f48176c9e46ff5c9d3508e2d6d28300eba562e19a8d981a4ec0bb1c27291128e8a4be3d6e2569b2c06dc2d71dd92a30b6faf6e5552592d4c46fdf1ecddab2bb2f48753ceb9d99faab1661438e191bbb4fd3773bc6e3d2dd425c319e124ecc8bdf172d99fc383f9a58e761f2eb071b70c2c80a7461e056d2ff70b0e60e3fa724b65e0a510ddb8838081295fe38135566c2e12db03f4ccd773cb25ec88396fbb54d6759ef02e0b1c408cd58894d9544df09a19ed07427a723fdaeb5fe4b6b07721391205aaddb0cd398a95783111cfa535f48ff0b6848185fa852f03e57a2830d826cf7d2e9b2c456564b9b3da3462c958c117824ec45ed91c56b1529689b6556fe606330d787e833c28bf54c8f54e5ec4f4b39c3c32ca0028565960b4f6460c145037564eb199050a3d560e5d37788a9dfda6044985e9e89232675d6e83812929b1c2b4675c3e1311c6e37378838c9e8430cac5acac98136f9aa53bcf7f9cf39716d60ad24ec0372748b63f0a0e63c64b1f48b674563d5ea3f11ed96f012c3a2a340604d4a12e027bdc56e00297eda5feb7f2e475cc027a7465a39ad2c8b8e37a9629bb81491cfe1ec73269b81425328ecb1f48179819890f2c0aafe3b1bc504d97611174972b78a2a2bb2333cfa412badd894b2dbd7d2eebcf9b89021db300179dce731995d4e8f7cdb69bd35bece8d2df5932d0b8055a24ce4f99e4214790a6fdc51568f2793d8039e3540ec6473a4a23603eb74648e0a214bec59de68d8f73697e8732b7f5c322435d0339e21b80dfe3eac06443017bd8daac1c94492ea16060982deb48db0694b1a8719d67b8fc812c6c34ed416246d225b8db2eb20bc5c1bf8dce8e95abf8f56699958537341f4794e29be1c5097b7b0449b292ec22dfa1c020a8cff80d8ad114aa9d9ae254c06a5ee017ae94928454a04173a96dd1cbba64a1902ae453d104cbe56477038c1f0e6f8abb598e782c7df5de106ac429eb8da521ee3eb3d4e664859e1257bdd7e0596884564c10ab57105e53a28ababa79fab3f13191c12eb078e4bf8369f3f51f8d65913282f28f742ab6408d764489c41b7a2f2892be2b5bbd78581a1b29f7b95be397fd2e14a4eac4551f9650b181468ee1226e4f0a0ee4efefaa12aafd751afc1599115d62cdea631bcfd87392265f466543d899a487ba53639a6a372a8f1c8332de5ccfdb440d44ea4d95e3a0c08eb61ec50963e9194f857ff2f9fb1484ebecd64dee45f4378c7d5b0f170c5fd758b250869e70fa1b1de76ac9755a6f6447f0e1cf1fcec48b0d3fda815a7496b45af7b6ff4150ad7241fa6d19ff36f69b2bd1f904a1203b23f8b6def3bb103aaf3211d3f30435f780021d60444f60a24f373cc83549af3966b3043e74d6fdf49c7afe458e50f557cc54560c17eb77a108d3a2fc6d3bc1d5ec2ee4fd06fb0625367cb6ebcfa67bb4ff3031907dd0bf2b2d368ea15bfb6abe7ac916f175870e112a5261224e3e8c5aa8886e2dd5a6f1631d2de77689c67f23e5676fd327e5cd7c11bea5acac7c9eae5f1c8b1006c0a034177ef44c717e808dc5e11ae74b93c568ced2d6fdfcebc7b4163273f27d0d786a10e0bc53e6eaa345ad542f5652b5ca02abc4e60023eacff261aea7d7d3671a440030c41e2367d6c3e274c21559053c6fc26d3afadef4b114dc073843fde26c0ff4252d44648815643af2cd42c05b1b9b86135a1a5aa07c950f7ae1be3966f41b4d49c9638e845572892914dbedcb45dc6d0c73b09d2b5f57bac11c56e542623246dc27665409b4d0d5d3ffc655ce5f4ad8e1a6391084396cf3f2cf9ea34efe8fafa55f9c59d0d96c1f081c68535657e0ba93690a1b00015f0627813ca7304754185e5b0650dc0c021643dde26fb98c6471ec19ad4f64cfff31547564d471e64e2e0dc4c8e51f5be8076c70e59ec6d0820e41d998955e8a71c8971d1fbb21aa6c59aee67f63823ce60cc680954252c53eb1b6035053c17fd43b75d58987ac30b8a7fc31a89b16995574caa4d56b84d797a66cc1b0a5a3745e6b2d14eb2b80a432446a3c63bf114230696faf87cf14a2dc626daa2813655e2aeb99010a519555743545bbea45f79ed6b12a2fced4ee1cc65141d8546393e5826e06dc959d2d5578c816f0e0fd91771c83178107a593bc6f965d2017ae71e5b5a2d62a39738c004b509d511c68bc2c012695fa36e0017d382ae72d0584e28a3f0337e946a35b390c2eabf66694e32d19adc8cdc9a4cf1ee36b913cba4c016239a9a282b0bc86a45da28e5c3d31a3b0eaf8e8e2e424d799dd763ab946538cbadd05c66eba1204646a0316e0fde6b69ff61568052427d35cdcae9ad9a9d108a645e5dba61754da12a9727b85b4a98b338c92036e98a42dfa1fdfcb78cbe9525a9d12d64f3aded48a103c0d370c38caa8a3d86d01788f3fb0e52cc2a80efb9f969e139948988ebd756b9403ce9917906a6e7f973084067c64b7765134546366d169609273b13c07105e828533c61d9e83773b465768737fa6fb2f7002c0c015369ae1e713f2ac82188d0b92e77175bca2a30156c497041e1bc084b0495b4434ad71a73a236fc7d57343f820e58ef0496a16ed88c0e46a5573d19566d40b7b3aeca200bf59809c74f24536f73ee8e80394f8ef72e9ac16a244f708279f1759ddc5d3a9dd6a0b9ed58f6dd6b60f669f65863bc79dbe0c9a7f4460a726ce1caa6b35c1db51cfa5e4744217422b9f88fb98a85c1d3eed0dfc4474df586edddf050f51804073be8bc26c10b3793bb392607cae2d5284034f66be402f142466c135838a30ce456d6d73d5d6dd7a155247a91371edfd526c716e92e77071036c799b61bebd074b13884c244357d5c9468ad9216177d78f248b4ff8c2ee44d0dd69c9470f244e08daf94d48ebc54061e00c6c5477785da2455c9c4a083d79b1a7eb670746909fa03c4cc72d9297f1d0037c917781ef97702035a7d4c035a715e7eb37086fea137e8b8d19b77ce2819c83b503d5619d0195178dabad8f5c4a4d292633df0e261cbfd2840308fcc8843f090e46319dca6121842739b07353ed37ac299534f469c4fa4c0db452dd25b1f97619f6e78307df76ead04e2521cbfd3bbc6e1fdb49074e824e8ea3449ef00b7652ec3e18f27a9775fc96fd6e5950616121a434bca2dee85571ea461a1c7fb39f3399d01da81cf6e0ddbe7edc29b17561668403bf5b60af6e9b7760bd650774fc5a837c25916d75b55dd69ad94ab77b69c1e5127038685eadf866234c3fc0ca040d44eef2f7957361d5eb7f4310da738b19d30e66a3c74f03150854972b6fe3971017896280e7a4543ad9d65c493851e7564b727f72e081014a2fdfaca52effd3b3db2e1c8d0431e3758ce075d5a2aafe468e8ec275563e94586ced13c76ba6685324b4146e6178bb9dba8b51130a1337e363350662af84b234ac2157391ab61a8050fc0dd7fd63801a2172024a3d0ebd31a585664cfc0df1cd11920d224a68386f2e025986efb6bf755f0876c19c6f56cf69de53abfcff8ffa439dd8d0a25455cd59da34fbe7c39ba6675bdef138bd05b21419d7e82006486130e2473d070bc4faa988190ca764e60c651e36f97afef156f217ca994b65681004950211b054a73c88e44cdc1b678761389722f1adb1ca598868359907986b5c05a021e1137f575d259e4ba7a101a7177ef0c1b0964e5bb095a28e630e2eb669374934da514e4fc0cdec89eb90baefd6dc3d9329276136e7836fa232655f3f1316c476c41b94f8f38c2d1feaf9f9432dba8d6ee1f261bfd0dddab208d2bdcce546f15c887840105442382fba84f112969ddcdf9aed6a3be33e21eb60705c5142580f8238e61fcc57015ef34c9ebb8469148eb9e4ceb890d3e20f21be75f2e4f2677c210d376658f01f248361e56057a7bc38cdf19f8cbc8823b8251ca15b3369fd46a28bb6612814ca0d8f454fe5688af569e9fe85a73620a3a8a80ece3853d577858776b4917762dbf979d1bffdc60613c4046109d3f13700f7fc3de29545a5cd2d60e9fc58acbcb933f5aef7e462f45c90e12db1b39d1f492262bb0dd4549535bb9adeee6d5ef10c8d20d350ae88717de6575ccbb1f3188d72b0f007b3bb39b46192deb12839ff8ccb0c6905fa43c52c76d156f82bb1877f900409498557ca01d82b9c667734ce98be5b10f3a10d59a9e748620e61583703889671c1b4b29ad02a2d99c9cabd743fca895754efb8ede924d34c10a0ed92bed468e9b116df15a5e13cbd304a5a65f0357a2868cfb96460cc7798cf612fa5c869942876de91937ad7951fbf69d29c7c007cc3711137f65242389bb63c01fd81ada53bb276d38e96542cf378b52f3efdb6302a8a5ab2a1b5602057c72ebce13b336e448ec47cf8ea0575a4d8443bb5b35ac1130ca3b9e32860241c26bcfeaf73811c41f88a8f910a9356460bce51d539d381753ed149e274df8f1c9d72e3b702d36d4393acf132cd88cb9c38da9759fce7d9d7ce799a591bdda8c56cb99f48aae0d62c66e77301996a44f9c6a515571cb633191a001fb1070538716f60d64aa091456c4d056ab60f959cd0f279d58ed4a3847529e3c5e8eb3e8466e44e192366ca1ca08342f9aabb872c6c7c5bfecb6677a0bc124ecee3ea63746fee4a9db9a63c65457e6b8cd58a4256465820475cff9888622052ac74ecac3f91f564bf14484d136c8b82a95c096835101652e6cf91a2aa3b1024fc9fdee47e1148cb2feb0294d6de5eabc61495d4bac8bb902c82321792255957465d913bd088cda75901c065b941b9b3adb9e692a856412a8cbfdec47c8c6f09f77ce1c7a1c6e2daf07b4b543bb1cdeeffe3e870fe1238f0cd980c259e621d64ef588fdd753df10841413b0bedcfab7c127bd4edb5d38bb53f5a9ddf772f2ee265e4ffdaf64a77957a39c4dcea4a31eeccd5ed502d688df56417ad11f3c425b081576f58c0d2f6dd8ecf4a899575f59b69a5b3cbfac69cfd796723afaf56cbcb6660252be17f282264287b2723b1c9da90d17d1dc6e9048adaa51fe8e6e39e8026bbca46dce313f42956c147fc6310f896e7d9b430942c79070b1e921c5cfcea838a931d5ee0efff270ea884471de28fd149af1cee87d6a872d36c13a7426e2f624975bd13400d839dcb7df9a5774544d095f1c4aa750d59b12b2f68a92b79667db6825de2087edfb1b24e65f8948a8a4de667da5b4ce43bdd13670e0395487c3facfa4a0a783979392e37f8de672ce9a3f581f1309ae46531de1ae49a9437b747532883b4927774dc454311f2ce85b0357be35b8d9a89294fbbe015b80f46e24886a176c2e6c8ed9345b480c01260c752ed79164c37c77c7cbefddbe46c6904ec780feb3a1641b5cb18d1e2369d49a8487cacda90859c3214ccb9b2db9a15333fc566ec3ba96fadeed4fd8f4edb07887ac5cedd057c6e7a45b2ee067ab3871ff6f936476c2e9e95542e6a238cbc398515545d6fdda06b0a6869d707fa941c555c2b351ad64f6d3396d2b83078881a478d2ccd89b864b4b4333d98e5ee11d398c8c458f7e0d00f9db8893e548459dc39356e3bebaf9aa6b5df510af2ddff2350365ddc4de382d437e6bc2717c5888a0843b5a80aba349515cae0f0e30d03750d3fd0c92b3176d3fb504aed63b5075dbd460bae0c5ab23a3f836378baaecebde4642a90becf34903ad905b5135090d97ed40f25c9743ffb216828eb4f540cb92be9976c4efa18cd534af203cdebd96aa2777afbec7f2da909b677727735e243417acb7938d20953c26354b99871136e36b2442b6b18f91e696b8cdeb50f215514543135502faf8af10ac902c496742cce536c0669433d43213510b93ca93b6d8ee651f16d75f338c8a36093ee3bacef28b13258185f73b0c206f7e0e606ca4610d8105381d35b0ffc359094b765fc982542bada02bc0572ecc7486e3aea7752d6684eaae9f5f5bc9278ca2bfae6f994b31a886f74aa19b0925d604ec8056e234685b6bb12834545fe29f1dd5b28521cbbd4a341413c3cc04c492165872cda9c60f29d66ef971431dbd74555e0ba7a81b0defb40f350f567e042bd65e62720942a0052a7b4c066adcc5bdf5f6d3c3e50e899aabb0cf7de08746fb510f1d8834b6a0f950aba4d8e7fa105587c49d2b1421d0d46f1e42b4be8814449786519749fa03e67a8e148ddabab436468b74c3e8a498dc690819bc97358834b7375f07ac8340e491bf13e345c1cdcac44b3761b5b305fbf1a60b6d4e9c3c94a8447d6b21fe72bf3ceaea9987ebd6d1976d15d4de6997956c57907a6e16940194f1f344e1faa1452a5b334a0dc4b54aae9a01ab93a72c2e88a9b2760b722d9fee2353b7a67b4b93b9bd12c51744f69da14175d4e2255340ee3239c32037aa7656c966966925e9a07d6d8a7856b3d4e3d7cbb874288aa208bb3fb5adc879b1f47d0013e726192cd9207026dda6e1ad38fde3af82a95712ceb21c6d40481649bbaf2dfbfd649fa774c721515900485393e2e54967d890fdfca99fa82bd069849d9c2594e153855644195164e9eab1df6cb8113425c45420556971fdec93657e65d47289feadeac76f80b2dd3d5b1160eac6ef62e1f4a81c5c33ac43eaddd8edef2d35a967a24f7be0d64ea5a27f124ba8b0253b00ca099a0246395b947908234021d1ca87688870777f11ed72f1cbf46db65176942797522417f5c24ea42e12c0d6bc45133e1c0d78f23853a0b0d0aa93771467738700eadb3c6f8fb28bd5f0a33326b6c7d8b5d6951a1dbd24ee2565005181e3a00c042ca89688af846dbf3e0bb02c52f3bae5783ad3c2eb008ba394bc8136cbecaab57be5c5ef7bb571041096055b4e1cecd1906ba73c9f0f5c5909ed073b56686b10109a1a58c2bdcd6a44882aaf4ed027cb13501934d73e6299d07fbb498291a7b1fd3f8a9e3e77467aecd62af11a0b8ae3a6145f71bb19f45b045ba532c25cd3074b71312f0cdb89e52ab1f6f33e5024bd034993ebafa868f3d88611fb6638c0aefe2128b03b18bfab2f7ba5ef5942b124ceb2e9438d7a9c37e67379052a108c31616824af6e397c7fbe8a4e4ab938e0a37fc59becca6aacdb87894303f9f1a54104591f860626c82a9758c901aa5c9c282f2578d5a5b484001b8cf6a2c8c76ced799335a98dd192fe73d07921eb691c5f9115fc5a51292ac77040f38a0d2a163211242e52b1be0cad2655c7a470a4aa6549db9b3bfd0ba10812137c8bcf472b3078657423f7c585d17a76778944b2b3dff1c6c349cef672d1a3ab423db2dc5dc11b2f7563e71659343c08601e2d1a0188b061e6f55f9b0f1643603b17a3942642eaa561dbef3a90a36f2f02d76fa5c436f53910eee776389653bb8fffc9c6a1934ab48deda39f30b68aed2cc033632d40170e5a1b590602b0655ac1918c12079b7cb3392039289488086dbb278a073d41df4efd07318719863dc554d87920fcb9725b610c4baee22482f34624610b6d65ca9da6ab62699c61b40868cb2cbb51972e13cab1a59ffb5ae2b52b67f980a30ed701411c58a37443707fc66bc0a1ca935f9aba60b8ea67db33b1967a59c32171206f35e58b0d9699f6d55c2b2849035955bcb0dc9badb285dff5981e01b898a58589e638d1c4d87a4fad95fded6fa69f9717c9cd1d672145931e617373e89d1ba26b326ad0261cab57b1d66472999f77d8b1a2ff02fb53232f39df74942f8d5dbae99e91da7e6180868e528c781eb691319581ff5579d860527a50c30bb7e5c707d1fefa5eef10cac990eae736d0aa03d2ca5561274feb901bcaa505f46106bbb3370b1898f982e88daa6a2fb2e9e1414fb620ece32134c800a375b1eee5af2f1d0e9226449d8951f9e818ca8fe0d60be10f5e0f87fa8ede4ae9c85086d84f3a557ca866ce9b631660c723213f9d9404f49a931673b5f2338014a487e88e648f3ff133a9f0c4e278714655a726561ea474010c3a554fafd23124870de607385bdb21fad24c64906ffcbb9e92fb003c1be0be0073cbfa2057f19313bf895ea082d68641c9466432cd70727f0b032aa796acd5cd1600d12d02476d063ed697ffca4b9c3be151f8f2226d5d196c901fc909a74546e1c3a84b2b0ceaf9ed296a85ed70b54bf5c089bd84dbb0e5f31a71f261c30463bd01ca3b33f8ffd97788fb2d38f3ee448430dbce69bef5a9413e03e4ef8ef94e81b449de12d6f263ecbe2328eea0dd6122b3b038aba7fde9077e81a6eb317cc38549927b7584b990c5c75634ee82c50d92abc55d371faeac3facb551a9cd17e8dbea1f7fab18355ad06d46dd9c8d79850859d856b77d2725e5a81741bfa852a74cd2bc044e8bd71b0ce7d03d3da9441403504b9621ad1f0025ebc5f124a4851786209874268077d790bb481c617994053bd4cc4e55794873c4cb571e589e445df81cf3bd4e9c332720334659d5bde5c6f2eb95a91e18cadbe31735cb79c9821e72c75fe4e35f7d6b0e7600b09cce1be202d2ef56141cabfd4937797b64ce5baec7c9214116d03c8483c84e7e4cd0ee0756098a0b69769228ba4db976430a37ab2703bd5b06924b5086daa903a1461113e52cb98444fdc25821c235c337193354d7d9a72929c11c71bc4f0664c91f44cd7984e2dd4acad551834a8048360f194d825fe18a795ebcabeb5050a8b7e5e70991164049b22aae1662693193970273831378ab770d4932bd3dc84eebd8a8717a1f8f257606f9e177db9ecd1cb2eed0ea10e2c0b0bdb793fb44071ec6248c7fb7cc62fa85fc4b2204b4b43d7403535999427b8b79c3066d97fb0ec23bd7fc05f0862441d6d0c41910bb648e7168d8107736227d808812424c07bb3a22483aa1611c45ad93d9321aa54c99b65679597a526a4056a7d17a8c29675238ed0b8b8fcd2d81ac8e05948d111091b74953946b4c9fe10b7fc0f1f7696543668c8db7e89c4752f8779c882fbad2981e78ba526a3ad7d4b911e392069935d546923c86d58e3cf9c7a737ad8087c961afbe551965d7f93eb25e59d7fce453ba5c28abdb25b9b21adc7cabcb7d5e5ae22d8e4e36ef1b53327be1e0221183c8c4a65d77576eed7e385a2c2728093762a3371758a2cc4cb43ce442d48e04f57d6d1eb2f9363f325f9bc6f6f76ff6d2b621acdb95718d4ead8885b1809cd15b846c0b33fa6fa08e9efab509748695473fea43a2ef30bd3533d1833a8f2c31c95d3f1872e4917e8671e7b8130456103f8d6bbd6f02be74841f8061d225744bfc0abcb3cac7b89bb1dc6042a43f8589a9b9683fcce633346dc91094809a28d43f287176722978faf2d5081e859765bbc0d15ce507a8fbc16a639616e5c85ccd4d76b8e97b788c62df0c5a9d2c479c27abcafac999680fbd768f717d49d1427c9922ea0727d662bc2fff89568b412c620195349f19d2958815a18f892328deb33109cd4b70e7da299692c29eadd9896af6970972d30e637af918dee0e48cfdd555c09b6458df5c9c961a0349c2a6cae1114feb6e3106af4d4277b99a902f238f5dffc87dd1ba32d1851d32769d808bcb0f03687d6effacf0985064861bf63bbdc8af2b7ba9482a266eea9123a789f80af481c0044b0ecfddeac76394ee7a0e7195fef1b633d85348dd4859c208ae2a7a480e5119337fa52817a0dc776adbe797016c75a43a96f21ad1212d5414d0dd2bbc8b99e7d062822d02eab0ce1b646ad6c695654c1a3ab02f3b41651729ce46a6fa97f1de9a6fd6875a899b6eae10d57d37bab0d79e9dffb2726766d6b427aeee2ce8946b222006867ff5ff051c5b4927848a08d76d0dfb1978fde071dfd4ec1e70d78aea1441448687e37b5ae104e034854ac11f045d5c6a72eb995b85db075457c111ea40f8caae6f02d4716b162333250ba9bcb3742eb48aa30c405de3ab2280b1e1576ec6902d1494dc9c5f11532d6e4fcd357bdabf834dcd991bfa81d336e7eed1611d0347ef6065e9c7c7e6213091e81994b7d5223126aa12388ecdbc66bbefe95c33c3f84b6c154e3796c3afd108ff1990a7da420b02c73f76cb5efb6d2616bf27b72013d941435eb2c9e3d114f714a8f83c9b7f7e47c25bbee09614b80d1a9b16744acddfee6c7710e9f68134e94594833fe43ef84c991fd1ab693e5d90a0487eb9e0be0f350215818c0f0b278f602bf84f715a2e4e9ff2f9a842b6643138d833792e23caf87b667ec8133ac2d01a89289a78749c22ba8c32a7c8f2ee700c932aea84bd49df9402536a44cb7ed1290f392dd419099b7b06146737408c722ed45c94febae62146a45fd9b9f3723f1d76288c54111988d8e77b659b18ce9b8e4c430b335f586e7306760a44102f6276a0f79e0754373476cd687161e6c870d446e9110d97bf3954fce9d9d66c8e30d736ceb3385534f14cc6ce99bf43bb6cb3db8eeb6ad269042dfb2899caea0da5e0c594717d72be4787993d0cf580eaf57c3ce30cef027ebf3bf12d61b49e6c8f635d037829888d0d193be9b579c95b2def507d494c4445a4e5ccc9e36d390bb2d8e326f9df834442a8e090b36c47c48f3cfaacac839ffe6dcef2a4aeac9a21106fe72e4f908c9b1c5c6d7230ccda52590c2ac3b82d80ca4d8274f69cc9f455ffb2fb5ef5114f5d5ac3d8ad26255a369936a65476e8a9753a6390cf6963d576a8269602a20566511180413ab7b93c62b997af9ea789147fe22141f270a9a9c7c39f8998b613e73e577fbcd10c8538f35b89f1ebbd5f6666b459dbb6dc10ec165a43c9dbf379d502902b4fc1a1aebc2cfd55605285a1cd72c55b1d43aa0e7c63c37afd6752e2c2409142e35ba4cf720e35af8d585a15e2c59a4a4a612a3d7a5de8734f59877b3cab9fdc3c5d59568a5ae8d4557f20976c626340d941a101424139a582224b58f01347be01c4255983f9c1f2c1d57e9dae1e95fa154166740baa69bd00313441bcd418f485538cd736905817397024e14296e966f91ddc3c8a3bc0e610b32f592fcb21ebd37369bb7745aabcda4492eeace0ac629e3a9c449e10948d35f175d6292b5147643785ef1562522ca6c5d9c0a889373970d4b01b5b42da96b8c11bff028597680b95d0dbcc2a6d451b3652f791ea548e057b32e76735d0ae820295c706008178fec9b8c171308be8c9ba2f6281e256b384f4199686ab0e5d32af32821700dd4eb75419f01f98f81ba2c95743b36633e7aeb23ace99c8a82bec44b08b063c7127356d6ce97c5e01780c8536c10a883f5f1249d6a91ec4965ba7d618e1bef89d2f8845d86fafe7d0e9d20c85e82d3b76e9d3176208d299d4100752eaca4084a7257e6e6bcfcb9e23ea2c4d5da5c27c7350c9032bb3ff314896a72811f5f2cc933fedd029d09dd5b4ba31ff105a005cc50d9ae53874b91d453770697fd53fe81dec022bab37c6274574f23863862c884a89ccfbef9cf19d47dccccd54e9f14b05bca8ba4c400a970a56cc0b6b1fe5447ab8f25f6eb8c0a53467c5fa5947c6d1c9bbc8b68063b414731907b5714cb15d95a831b6c48693140f9569a82a1936e1d01ff4dc8f936e1f794bc5b8acf011699101c9a25d887c96f7d5f4ad3e633d1d6306466bbbf7cb76635bfa2f76084f559671a73608aa5bfeff5c10c43b6da9c2ea373e3a325f0b94cf1011d81f5d4f5af11eb283b00a747bf4ac38f711248af40af0876363c7488576faa717b51209065b674358705c5752dc1b95909d998b3683c1c0e050a0f236bbab2d4e30d0a15a1ae1216bca9db74f39f420784cf480c2e4c01614ecdbbea471f1c1269c2d17289312e01e22313ff6a3fa91aedda7f3c0aca4e0192711d1978131f709e0605706bf77fa9d9822f4d1d84721b27acc91ca5dfdb3e355e26989fffcacb6a3e71b5a5ee2e328b2d4e430510329b39f485b4720a6d3914b0e18c66376bb696a85ab460cadfa241e7229ecf3a2703de8fc08d40ab54bb6968029b997db28458ef0e0f75d98e7c9e4af1ebf153716b0b5db869a37cbebe95ce3b3ea73287b29feb5662c47417d66b95eb732023954a2d2b54c2fce745852cfa110ec8ab49cd2039dfd5fcec1aacd82c079e9b018da223857ada6cd2106b1f6c0188f5be46a15df41e4325100c8ece465ba14fffccf95e507d5d3e7cf7e4c17698bcbcd4af79037f158ef56aec0ef6bab9ffffd07ae8130dd7378ec60195253ba840ce355bfe40dd22e127a0dc767b859e4e4455dc469f4f1a0eed2c7bcc8f1d58e22e1f4ae37701467a607ef5007b2ee40e259d12236d583e1f87e28675cdd229d208273273e896e9060da0e79e45d70d3217d12b88e563881ca6e019d95f8c459a9c1599f249cf006b94f094fca12aec30b95702514e01c7c9055e2b0d70c4d02324465a658861f196221146f6ba6168b22b7812176b20299a68a7aef8edd883e2288798c6aaaaa08258d7ceeb6a9b940d9780265a3e30a4dc377aac84ee1e3e175a2d0095568023abc9470f0f7e98301e20192070e8a0582bcd4cd8aa1983515a03b59e2be396d80f660a945c16b736ba39c9572e24ca092c7532ca8de087db3fe0403b69307cd15e52d815c65d26e3a5a10c0036a6d9f60be5df00fbf68b5a1467b88a320b86a9d77cb1a5076b58593bb5d81f3535398417daad9bd808d1a805772f25f3f4457d91167944b93f4d6c207f651d61cb5399a84e60c9ce38e730b59f36fa04409563731460bec2593103c93aaf4de49e9f693db66d5fda996129173021eec49f97ad630d0549b4e1fc1930caea7b0d0dad4b20745af25f8cd690a17427feb8325f182ebe533f2760a66b5dec923dc544f86db76172ec5c4205fdc62335328d8b0a7db26575b9045264f1aa2e6858fb47b3ff5dd24ab76863a4a8427f0a7668d49f3f1a7f247f5c0a9327828592654070a21f5f3be581e7e6a3c7ac2553a70acdfdffabb8330e114cfce5887965f195c1a7e2b6a83d33851ac79a407b8c75e4a11e09c678bec34cd5d046529475eb57799789f99c19228447011f46c36ed788d33532eeb340a40b7fa139ddc746637f605d96709bf892cc8ff7ffc8bfc472d0eb972a21ea13a7b27eed8884ad1a583286d0af68b7303f4f98349054ef3a531714644410297848f3d6ffef17bc57d4b68943d9f25f6a9e0a5d0b1105889abb57be8b13556772904663288085af2c8723bd8232704974e071adbd03a5a245ba1c45aa8b3b009de8bc008544a836e7980fe395323e925876b4e053d3c0d25784aee958e6d905962699d65bebc0b9a0ff82a0b9a928f4599325f3955be149f0a76b895a559d4c02b4a0e79c9173693a0fcd7e2c53d808e4afb82590e6d0413077636995e18e79c7df47c9467ec608bfa62714b53a2014ee4cc40c52b3e1744a681bcda9da23fade260e643f72279001b266688ae522d9ee24be1bd0cbd2b5140e56bc7d703bac1b9a920f65092622655e56639f625d93400a5134c7044ddef51e6519a8aac4a914de33f5794e5da3ee8685bfe280490ecb54d427bf53ffa3519a564aa179fa982d7dcff03e42a006b679ed81af98dd1b182f125a81d01b13fd2371a157bbcb4f7f18c7dbc37c7e006342cbc00729500156383278a4160b4aec3438bb5dfc4248d7fdb4828d870462f95a78413f595e5125ec465975440875a633f7d2c3333bb67029bf43e79efd5888d69db89588b376d68aed547f7b5b5b82359114033eaca20f8ce18a785ff98040edb43b88cc86ce8fce01f294e6792d525f7d57ad2e4ca5ea8faa39fdd3bf6e96bc7b07d31fd883077c08970750fe7dc4ea4eb69a2ac53d17551d6f906680a4b11565e6a44681be6946010828d473d5108f1561c1a6f124b6e605db12e01bb7587f7b7e95f7d6c7e61c635ca6f53c0cbf7890c5118be4fe0b249e0e5416f7feb928d5601f264c0b621d113d04ae4ba61b70e00a7b13f3e208dae575b358f1b47898128ac7b777f63cc09b81f91e71bce4819312da46282a598582f77be67e6b33d68ef6d247f8072ce7796f8981589c0852e3d6a68bc4beec7557ca7edf20b54231adc43054a041ba6d59933a6c1a33946c702790","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
