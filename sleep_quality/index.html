<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8a4b0716192d3c099cdb849c4570f231542c89964833a84b7b04b93e7f5acd5126ab2345d72413dd5cfaeb99bfdf55724e145be06431b2a6bdad7edfbdc6cbb49b0110a166a412bce48148614fc9d38619fe145d768d89b45bf0e81c714322ba54e30f77a4afa75766c819308dcc1da5f4e6720eb090ae3a0b9cbe0161102ad770e0840187c75ab1261acec11fbdfc9bc7845292a44ff9acee26d8ec049eea857f435530adea16e4715597d81d529529cb009e44ab53ea2189fe0fd24f2f952e05fa0d902604bc505b32490d35378506e0d937560802b90ffdb9d453e564a1dfe73f9c9b10cc8c9841e52badf591b273d34e05d0abc4596006cf4971a66cc2f7304a59479a53d18172a31fcf7df63306940b70c3edad21b91e22084afbb5fccb2607334530d38c41cdc2ac185dfacb125b6971f7f71a2325576ce70fb12895a1216e71e7c49aa7490aa85c40afe091b676f9fbdbaf4b5d4f0b71c736a418f77f1ffaf40ec0867c4e089d06f9e663286f681fbbc0ba83575bd1222351aeef572e6caa7fc0a35965a16bffcd8b74c4bed78dfe24816354fb5508ddfacb535a1c977af5c977a8a854063a62f88013ce91c7c4c321b29a47624a87ff34074d64f5aa5f2c2bead4d2e83e7635fd4132ee49ba74dfb5c6fee2f25cce354f8a6ec9384dfe7bd11a0ff470f85116175ca6cc4363a873d0266033f6860a19f707e2e05747a04651371cb5f8ce139f88c02d21c3c0ea06eb13a6e14af266af96e51b8645ea328b2e9c3bd850a014d4219308906b90a5ce0fa9e49703716796c279d50afb63bfbbd486d28b295c3ae5dc302b3d97e1df7f56ffb538d3358c4fb8c844602c0ad67312044ad975bc00066e19323275521195d95cec1c496970cd78150a655b716d1ce4837794abc0286d497f24e770d30283749d3971a4cdb139c8bb0d8ec23567b5c93cc667207db256fee73f489cfd8e46077ee1a7d8ee7f7d1de3023e30905966ee7c0630a5e72206796ab8ac865e5539dd1c64eb64242c1f900c4285264a0d425bc3f811e8419bf5d2f8d31ed81374ff3151db3f6e1eede812ccdcd4d8fa9fd2597de30083b2d9050fc7898c7b07bb0f6d07c252115cf95b8f9219cdfa8ad35957cba691002fa77817e691155a11f37f88316297da2069b10807b107e30d6d626a679db645467975697f0f10fcb438123ba5b850a3943874e2b1b07e603cad51178e539b90ba1ff08a4e39d829ac9d084115e84d7bd24a70b88ce86070be8613a9a91b731ebd0e2e03b5d0474b03daaed6f929133404d83b1f50b8cc62d0c72a061914abc274718969e1e3c4b32577050d96c60e78bfaf7817c03a98306f9862911ba292c99409c80b7a6c3ebff5c6bfd628e06514ffdf22a46da0962283bec05c38c59306f3b48a19ae5f5002c82a92f0f633a013cffd054088c5eba518a9d115b7dbe2046acf62b0e3c8c0e7fb56674b125710f3184c6a2c7635b6f8434f0f5219c1db80b216e069befb036d7f0b00eb329ee35f52d8ecdd478712f6f464d89156cfba4decc44a9e2c8e4c83b2042da67fd312390082464344d77edaf396e6104a1f4289d2609258af8a059ff832e7c472fbc13800a61e3f9f414f9c8986d62f6f13442fbe3b84f24c64660c505ead2bbd1c0981e9ec4a1b663969a4879b74bfa460f7121e541b541bfd9e0254d18b87eadb6e80971307061742fadf0f7b7a5fa5bf4ee1fb4994d3cb2d7c032771465897b7867a3cddf38a1b84b9b6941acf00767d954a4b066e6ee68eb80e84340f4dbb08827f9c3919012b4f5f733ab05a55b8200ae5aba1e1f9e43acfaf571a340086d282c9a58526b63b85fe3dbda21859e52a2b79433fed9f8a63392c75f3f3baebea1db73705524916ae318e40aaab43a1fd918e6bae328cf404344e810984f0428c7c1f754330ae1110db1a95006dd9b119ed526cf4000ad3f053c2f9e927856750b5acb123f358acd36c9d5a2222456c8fcfa8e760bab9cd32b773a8813ed44a260c9d44079069bc730a44373ce4e5a5108ce43ced8dc5406c4c02fc9ca65569fde3e7840e98d607adef4568d079887a7f91a1e087b4dedcdee75ff6fee159113db9a247e4721749a5bbf0bc38c5091d101d3892c3445fd900784ab2a1733deab090893056dd8a117c500b00d14db418fbe7667d829ac30bae445a904188057a7d0a267b03a52a345c0df006c3c168494e79e7bc4aff633d8985d95a1a1a92ba9b65c898bf913088a5f81dac2fed4d33a9754eeb3995c1ac7cedcd2af291737bcf8988ba593bfb3036c755a9150af420b781eac5b03f1c89da8bc4babac806275588942371a994708a44f13d83229e021e513667a24a1f47f93289b7ff99722c54299988a7709b309341bb6c3bf3dd47a28e58629be76096fdaa4796d778239e23437f0c277f4a7803a71e9f32ff9f40037c1fa1c04e56017403b6d231d20709bc7fbaa18a36299612678576648fc77717c1a53fd9039bedb5e2ff286f44e82a30c43b0b8f82c8c6ca7a8719ac94c1983062691f9380b09453447275c1f0db011a909614bf4f58d5ba75a0a0578317c47cf2ab9ac4754645c2d60b0c3d4b6dd6e848ec49695a8e299c241842fb56a1b7d483cce5cad9750041b443ee8db8a9f096ded416db0cce9e02130cb60eccee05456f3e496cb81c7935b624f00c9ec75cf79eef6f18e4deece8a8a2b55499128e12b32f9268509a865a1ba8383a26bd65adbfcdcec34b5e4443723f2c588c1e6f1faae04302d95d4ca36251129ef3b4568b88071d5398a7ab96703acff104928e278ed5b01c7c7021161754708adedf4925c4c1b757445d99507de14b71de4adea50d4fb4ce660d73c73053815e80d3fa18ea50d62503ec93f7767f874459f9e52792ea641be3c9042b60c956396e01316854c14ddff398191261e6950249205f71ee4822e4f2b523484bf86f1f847138cbb6d8a69196664370810fd4943d1ad236dd1c8c5340b3bcdee349c0eebe632c5f1a537a6b88447e7a054a7d064fc5d050ff36a699c75e7d1ebd45b64179f6030a31914a287a2c0622010c76b223003a0398de22d8e11e98d782977554f9fa69d02285e5d922debf48e5f62a4f6ca0930aef46aac74a6155c48c7134ca4bb696d58daa0c2e206e638cffe6d5176964436432b2941be24ba6a20b8dc39c9639df7104bd7a3489c4b16685d9d84f3ef2688317974721eb4adb5ecc9107b0c69c2d28d40bcc95561a0a7c17732427cf5b588c0bf3a68bbde2f32cbe3b87ce5d5be33fb4ce33c769d800c7b2f9b621b625c7290968512889e18dbed1e5ef831b55ef0e09a98c03f1b811a8c5f4a14a0b38e5870429b4eea8a96341562697b645a2bcf2e4f22b282371d9ce2f14d2cacc509fb4862476559ca072217e9f1b0e3dcf90a84f41fe715ba8dbea3998bf43b794aa229739ea9eb07915460d600fad937e74a81e594c1f245e2b9bc1d40dce126ea49e386d11637b730c16315d8955f0defb8cfdb1ec1595570ffcbd25104a813adfb61714f2b556eb8348da247a0ebd1872259c29bf34375c14704db90ce8ec4ae2b1b201b278f4daae904753fa505628a10283d28e3e254cfc9a7fc9064db355628dbd5e39c5659392a46cc1031aac6172e87e226e165a765efe464231d797f2da6606b09acd4bab797c1e994e556cf5a26eb9eb6ecd3f0ad22c0c05a99120c91c847c3f88dc5884228f21687c353926a1e7b50df5bb7f6fec16d570668b7ef803467086ce4cdebd816cc8e767e39975a8f9cbada778cd41b2509df4bf0d7d5554173bf34814b70ff12bb177746cca318d3a2a1adabe4e704e4e03827b86c85709c840c1a00925faaac67a492016a2b4f5412c5771fbf68c8738b03df79c74c27c561ebbcfa09e0c2aae08bcd8116bd7a65a6cec7acee9932a16827cbef21d52f92b5fe9a44c31cc54dd45b5215bacf62d7b45bcca493a9b01302bdece4e159eab81d7828b87c2f186691b458b2cf816d23ee26ea0a4e6450fc329b0b6025319d1c80d33d3b3d843e96a4d1c05d2335f6270c82c327b1f61c18243523b6cf18ace40661b97a43e2e0e2c9f7322762cee34dc532899a5cc1bf9051ec0aa613c99cb3551caf6af6a984eed0a51d89c3169ed92dba0afb542673b2403790748ef8f05b0d1aa5e71b5070987c98016bc980ba5b36bbadb2cdb5efe021a9b54f5e7db325d134e1d3fe5be14205c8898d27f2a92303e72c38474f58b038dd951d8b3ffc6cec4ca106c5bdfaff1d515e5792f4217980e45550cf9cd4c4e453eab89396dddb4bd972a4521c9c2200e67f2c391f9b84533f1568e80e5dc7a378a4002327bd21ae9655da5db72a0b18158033e2bdfb28c4a1b369b281cb8683b16ac83759054f864aa769770ac4508835421aafd03f0e0598cdded1b6c7aa6ae24c6bf1366ade79815c2989ae818f4b83bd8a71e1e5347734724f87aca891092d7dbfa05ca407a8ce50b8866242993eec2bbe078bdd36e4263b5e34cefe83bd7dcf4f911cd86fe3df2643007dac7b9bc4124eea2b8be36e5cb5398b2a3af9a76a46ef5b3695c9f7b81c7eebfd830c751e9ae8a019df4a3fbbb7af0fabca7f3285a81244e7cffd1b914f6d6a65aade6b641d7d2474578e9f3d69154e25a01441dca47fdb7de86f061d1e3b32f8c41eee8f29e0415f602193d28e29a57589db0f023ee489daeabd8804e110ea80821abbbb0276394f3d9dafa11c92cafa409f31d4b5bd5a7b6cf74ca136cfade03f7798ebc8d8fd5674748bd7eb03c8ecfdf985846ff110afcb62eb75380924b6dc7f4da16f7a8160c7be46593aebb7b694ead10a6b97a9f02de6c01df0da25c1b0d7dc35e420078771a0be81b7321eab572d5a16f85cdeeeb57a7bfc0d51c2132ccf89d6d01e3d35ddf8de8e027d206c115a05c157e7ceba7308cbb8b2174ae3e20396dfe0e73f7e6d43ff399aaf8556c2dbd8aec4f00792c300f30953070576222b21fed78a82f2e52f2635fdfe31343297812ec5a1a49bb1cd56cc2ac69ae0857a26c6594d1339be4917aaa8f97110411bd0fec416de9b0529dc5af54ae54a4b845c28024ac800c8948131ebd82d25165d95a1b9eed235a2c96fd229e2e02910bd139e48315608e46fc56172e01b338d108c7df8ca7dac33df8db99e6a727b4106f5ec96bde86d2c285b16e1c678bb460fe7a7e3b74fadf7da605a1cbf64d52139971dc8b87f3ed9a71ed7ccd2d41d7bf5bcf08be797b4b1af9400ec2a3600356def4df1b3b0f24e2d9984337e31b212b2e2d9b0647eb7436b9cb05523140ed4dfe089c1eda9f397464443c557658a8fd80ddd74e94d02251c6a2881dd02a31372269e9ab9ee940ddd0a34fc051b2944ded1c85dff9945e1136886ceda0b53bed93e38718e30a0d3c349c18dbf0884bdbb6be7171f59ca8818dbb9364d0585083264c9869b0c651edbfefacaf0af371bec7b63dd32bab9168b6cfff0a419aec325f2fd5073970d14ae87f76f69f169fcdad9507611fce05b23752d36efbf9178241546126e07480ea32c0b7f70b61cf7eea2c36ec099072c355cfc933e07cfe54eb3d65cb6ffbff724efc5b62d20bb1244579f45cb2dcf75827a80226d6e67a30680dc6ecefb592bb1e6a99e7ead447535f000be3e1b19faa2f202c166a96faff5a1db534058238127d5cf782fc0317da1342ce801327244c760c01649f68c1d30191295e34f3f1e90cf9e6f34fa4cfed01bc4f862abc4e470fd52e13d84844e1c2652c9db213abbf0ad13064e6aea995aecee8a845d28b29dbea1d68c8ff1364704660817d95d58ba164ec94d57e15796d960a0fa1be7110914304f1d960d7dc36746ee1391b5419b50549aa698f535063870f34850e8ec8b324c06955f996a4a0aa58291e759b86ac63cbe51723eae05932f5de41ea6cf0778bf8fbe5740078d40081008d5244f15b87243bd047859caf93cebc918dd16c13dc271447411c7ca8e4b7c9d2c8eb3eca2150b4affc743dfd6fe3b3f86980b1ded2aad02388562cd8582f6d15f2a122b94dc04660231456916eacf02d7de7b8f836531113c35b2942dc53884a243a9827a9ae887241ae4912bda8c55e993b6a8fd9819e4e7f18a44fa3217963c6b536fb7a2f5f1f1c67fa79579ddb426daf1fa50564f0f4479909f631b6763406adef8a8bd96119fa141a12ad62cb56807cea2d789d9fae630bde2ab78ad061210d984db9a52fbedcda5b8b5372ff38aa5ba3914799676547df237cc3dbff9950c8a363eb5e9dd9ad941b30fb6d5719dacfb77b0fb84906d2a4c85b1ce0b1879244f58dbc79762d786d6d62b70f6dbb2bb328b977b1864cfdee1405639f64597d276a5673012652f357e5cd56c2b340469ebd55601a54f820de0d569b47ea7c8581715a72f61e74d142064b80656ed7bb166549dc9908ac9c22b417b3b90945e4488f87903dc7b3ceccbf07668827ef8cc1bd7cb961afd101f27493ba2a9408b863039adfd4d57cb6a8b56551a9cc75cffd8fa9065651221c8932d9ef0477b3e2331820970a881f97489860707d6340d76d53171347c9a04c42f1cac59f3e11ff5243c23a413360f1c3074dcf7f047b18a5bbee07a845c8f8a9cc06b21994d8685b488febe174b7d42f0faece876ccfef86e4e0f0a0d6fd66a76c3fb3f4283b9fe5d11d2ccb3d0f6ab598bd75fbd6dcfe057f4f668ccc8b8203dd678a5f1ae36d2af09431d744999f02400edf9add5dbb0466508bf0dc8986814c04975226dd475a12f5beb02b70a6333fc5d41a798cf9e3243daf95944c9cd1e1b188df3e60caf535ab0a4b5c049fe28cb1040a38ac77d50e67d3c223d979501085cdf153c588a5f60484d72163fdefcd8c90392f0ba7c5fbee5d48c793d97c089b3833df20f8e690b372d38d085d41acb656a95c4ad7ccba1bc2feb0d040ba4442459b3b58ffb2ca85d18e41fb51b543a15cc519090c0c1eb8e1a52a0d0f2905263e14c47c3367a3a632fc6ef111c4662672e7bbfd61c401f82bc5f2d83165b0af947576ba6c342e2600775a6787af4770dfa0a58dca0898f498000ec41993a98e8e8ccc02eea872f4897b07058243392e38e80e38d9e42584d593680778456950242fbf8986385ec3afcdc9283726189e9f94691ce774e59aec48907fcf0f65d2055f75073e4aa257da43877f1f0c5cd3f63d9d5175adb8e7defc7c485635f9adac99e86ef5cbdd10dd91b956c31add33e0cd2937011719519539fb8ff8d0d63f8bac6732d8fca36769ad90283475ce28911d288a24843fc71dce60e11d4079a49698c7438535e907839625463053c6951d9dc98bf0ead32dd485da46b24b1aaf7cbe4619c681cd2ee486cd013bc7a78b60f25e67b386ff0f18e989f43138ba4bc03e30b17bf904e5900797493ef5c59f0bc792e837edd9dd5b4f44c500d8e8c8b6c3455f68db96dafb5a25a787fa2d1bd6e3f3b8510af1657919f5cf951b5a6ae43468ecd6dcb167b1be3a2b217475893b88135db2b322b2cf9d0090d7a2bfd33d9955b2752c79f65cc3dabd277da33e5f8806fa95e3eac0b8f31c5839dd1c1f5bce07d8e5e356d8ef4bb0bd51e0f7e85d77d6529bd2f0d82d877658ea64751c537c5eb097dccf3bb1018c84dd783609a1c9bbb69a032ad3e945ecf3191bd9173d1a7f4d962dafa951fce4ba816133354f1096a58371de4de722ac706ce5a5626521817882374242401dbd69d4f2cb7c197e070aefaaa2a0a1f6bb773c78788488c0d777149d9390c636f9df9c5a67ddb5215d196e024ad399964573870fd20178c3f6654116a59791fe0a3520678ec42669957f139ae8512e09a5c29062f460fcdabbe2d0e3dc10b6213b979c9527c19921bbf8a0205141c0677ba2197d5d4b535e92251b5cd510abc527744ee6fa75c36ec31bc4368459e199aee908318f2c4f89dd95a4c56e39078ef28e869067798eb0822738b0130f5a6a415584c80343b2dd09e3e7097fdd4ec6afa2b9fa2653bc4afd1f619151c7522e2d1c0cd74e426375b0c5581364cc872e5482af5140e33ee48949e9df02ba7d9e68cc0c514a983542e7da166662be4ebf03c5c8197ee0b5916e8a84fdd42f98840b9893965cb70f7acc75f5f6e4af8105b26b2ca20ec44ad5542ec92af8b13960742f94a27e02e38c45a60a3593978aa0fa8bec7bc17ae7c494ddb435d57a90090782e8c96972be9ba77cdb5a1b3750e2752367edeb64fffd53bea3129f69ef3e95124f95234f5153c9793620e684cb7a6a42175bc4edd39d58a803909e4b5ec46018eb258c7c1f2ad3ae7f947e3fefe9c2d13676cbf5b26fe971c6731f75471720f79563b289ce787d21284e8dbabb977e230fcc16728bd157a4af79c88e724a7dd193bd70f6ec2738005f073e41317fe3a439f0cd31a84a42e781a4a04d06a6a6e79523a437e91c8b79b86e6c78a030b6f515d18cf4dbe4759d05dd3b3656243ab69f5df0902a5b601002cef728de49cfcdf1a596903f02565dafcfdc88fa3c12d82d84b5ae8b09b1c558cd299e38e3269f21520f20e8060252718eb1a03b0f7dc189f563758708da5046797d7e2e1657f686ebce095ceb1d8e13b592565db8ab3000b3d7f75fb22af5ea9bf35ec4b3b2c25810747e0413d27072c74a4871af9fb8dcbc62c820f76f85dc80892dce32e06c160e0626ff902fb50cc923a1616b5e38d2700e292793999ca8f94ee1d4a005538c6b902782ad761867c2eb091196d984840ba175256760e20f7de4ef66213b5c7f0bbd7908599417402f62951d592eb85a403d6ed2e92beeff8518a3f189c5638b00e9318290c988553de82436451c7b62fc2b378ca99e7dce7af1d2ecfe416d7e7567b8bfae99d951cfcec52e06df8fca7d8ec1fec499da88513161c0c3c9713af95691d841d7a698e9cc62a4ad705bef9406c7f847df712bab0b750d5c70bb8827aacf5765652ec5a79c105a7840311bf3df720d7007c96786299c8201c302607e6e47728d9e1eb2d274a368ba70ae6821682e231cb52a4ad8e4c9e887f38620cc27c53d4db983ec3ce13afcf5bb760f4b0c07ff37097084854a2046b16a9b67bf3929f774ae87c2193a90fe03c98345b9955092d014602a12889a5f063c1b1e9ad82f09e7274a914a7fd0b1a1e42c1a26917f560cd340ec695fc05196693b2e06462a11681f82bddd7e81ebd57183de54dd5d21ee6414f285ee32dbc997b2991cd0fa18378ab8cbc5263956135884e1603c877eadf","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
