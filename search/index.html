<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b739131c3196110d6de83e9c349324f1b5f80bee5798e78d69ea85c4256169a9e4a879111499797a3e461380d84c502ab6b3de817479518d2a69f5597ad0e61f123edf8e0c3a809ae5138f5156266ed27b0beab07e3ceb73425bef79ef6afa27cc0e1e865dccc2139ba556cb6345546b6408be4529839d23946df0aba9eec736cf3bc20b727bd934daed699bb1e1860c5791fff620d832c87648c398833327416db6c5c6027f16979e6b2cbfc3bc8b7385d854f2d4e3e8b4c0b6342ff1d201578e23b37c2752beef5c49112fe47859dcb8115cea0495914f4df9bf9715938ee7b3f9c4e43205533da41ee7265e3f78127d61dec7713b23a65c021ccc7f36e6428fa270a09f6c0efdd7b71f961e5aace535e726bf0a18dbedd343042eb940c7a2ab7e402eb1c16192e1f6d27e6d3ec63c43e09d133d5802e83f6c2d46e7fa7106ef820180852347bec0578c96d9303763e383f4ed81a5dc3342dd5a85cdb4b5d71f296b9debdd2660e1fb90d0c9dacd75deb600b1f070846eb456c0a3d557e4e2a299e65de184bc09b6426380c601f33be92fc8acc072cae1a4b0de33354993cebc981aaaf0f0405ac4a4bfe79ecb81ff1e98836614848e75cc944dbf03e5e10bc038ef0ac53c4ef2d9309f4bfc0608bb141e380975d010541e240276e61624b903fd4c64e7ab65478d338b4e0b21f83bedb46b90ddc88605222284051f38ebc3bdb3126ff2d01a66e301e4d6599c8c5af082af0e0282684e0628dad5317ab650f3df84cce20b6eaf96782316d2a9fe8ac2bf70ef117c61be0ef7b9428c7cfbb083091a3341b2e1df0040f7691c2e10ac07114098c1f532bd0c5a6e2fcd6d1427cddf3b8c2806c28f24979dde7474b063475bbf8faa04f3d102340a6ade5e1259967705fa3e9709eb481facd81972e091c1d9a9b27f635d135d3753490a40c7ecdf05f4265ee9818e1fd25ecfaa14530be827e993dc6c2afb67ce2cadc4a0f32b848b3cbf829882c98454e99462b5e0f17aacc2d07bc8f1d464229df132b4acdff9fc0ff69b62ccd1c4f56d681642fc55066da6864c85c55db56ea194e6233b69d149aa523f75b192567e6904a9f42d8c9a0622b716dba49b835ecc079e0f16d8f23b11781f5f1fde4d42c2d0154649eb59bea1c25540058226ae3e9de702dc42ea2411fe7b0e7f7b4c1de33da9eca95071acc5a86eabe733bb4c32450e614b85c218cb570f2708448422daeb70e63ccb0c64c90831ffc59aa226b26493df05db4abf57e6447616aea592ea0830f5da0574d326c321d4ecf3d303bd661f87d0ce6371047e9e004f81c6975665ce432d3387e1b85308d5a8683a2fea299400cd380fe1323353ccccabdc0c607b3862e1f98070fe587573a21d2d4c58531763d45f1a65fc93d0939a9cb09f8a5ea7d5ef74c18986f7fb22d2bf59f67ac5b4594ff7c82bbd8c59f594830ab11fc620680283533781d6d862a56412b1340f7750fb6a53787c491b8068ebb2ea879b37aa9c278358fb152d428a4c686ad980b6ef19c0c2d5071143dfabebaceee8cd14c72b34aa2d27840be8070ea8719030284ec77e01504e8302765b048d86e25fc9eb6c69b2c20942445f5d3501870680a7526aedb8eeb68b0470aa3196b102bedbb73a7fd42c711b4b7c4f8afb8d576488ed357b950cc8a4c52bdfb73f3b095eb746407637c9a467dd6a5c6ca1c698bc5fe1f3db3d011325513352eedd516225250f894cfddf1f4ad1e5b1cd7cfcdc510b1e37dfd14dd2fc9ed9fb0dba339ed119ba97f53b7e63bff39b745c8b07b22e711fb6e7b71b40d9040408a1df4a24ebe314a304af14271c922edfeb8c1edae9139a3487523a78294efe54b37f0dcc29c40bd9deacd786b42605fdddc8254b46f9a3f5ab7bc46f019ca8fbd6bf7f7b9595c3e5ede2f1a923e767bdeab99c6652e05ee734c99f0336aef53c08fb8b23829af8e5e061edecbf1d7ca37b69c3e0ee54fd5fea698922dd6cca3726d1c90a90d9ffd17d5b32faaf20909aaf7adcf8dee464fa437931a5502afe188379e41a5ddf2038c6237d6bf7c7b3dc442ea59422586569301c95b8c0def85d4081664e3cf530b9d2412a43ac2ab67ecac0b5292c370695cffac55770d601b4d26694e440a12510e46de42198684c998c123f786fda15e4cac4091067ca8824e5582e72efa4f26246936050164874e7486d9c092ddf483f1202ec9489044dd8bee8b7b5963f4b7aced7af28d953fdd0afded6e8dcb9c09dcde85afcc8ae2e83d1f9e2e14cb73f9ec5da4906936f53af7a8d7fe938feee7547ad10ba144bef161e4275bb7527240355e26ab7a0597c196d6cc59562fba8678d2eb1624abc839e411915a409a5f32d7a33ecdec202cb5b1bf1a2caff7ec6a1a21e78a7f51bd9bb9d4b54bdebdf297c047625d38718e9fc649592950cda71452cffbaf847a16b756828f0cc8ed44818d03e56851ad9e391d35569db95a1b65e59700ee1d0b8646322b7479d8c412a443afd757a9bbea9a35fc200716168dceb0fbc8735ae12130bbf0a22a3f817703d3ed6bc2c477a31b31f662472d29ff94bd46ba9e58bd77af3058dc39bdcb6d352eba8dcc38c64b27fae71cd767417c909c455421c0720b8694f80d4b88cb6d97fef516d6d389547147a2c7c7229104eeab31e3ce8a4b72c1cb3fa7906c77158657a74dcc782f35bcddb22a977808c0fe7fa669eb3bd53e7bc01e4b683c8fcce84c03b33adcf77d650da25dfe3c231bcf3b7048f101674f92a9186ea64595a35f8cfa08ee73f4ca1ca7ae1de4937fb7ef4300e07c2e3f27dbbe2b23a388f8aa8c23bdd5bd33cf82d7d34a5a07a29ec692ef34e03f34fe6fab37d7570dd31a013f130782bc5060bf75e93b115e18fe11a3ef31590d4c41e99d6612db76bc6a1a94c86753acd2037e37b9ff2bf46aff8ad5c08ea5f2b7e8f8d2381864ea1978ce7689728888b8b8fd0e866cc292f1d8f38528b43eb55b75f6ea8fbd8da9b9acfdfaaa25ccc280fc2465fccd7a1d1afc687cf0104776e78a771ecc4d18a4273d9891c509095fd0bc72ea3f0761049b06c334f0e18cb100f391ccc8320b4db5d899cff1c2720eb689b6254b539340258c4299bbe8f3cf9486c85156d6fb777a8fb89c213b9f22f5f7fddba6427ee4849c18ef64e52c4d6b79e9f54ab2fc063a978c140e6a29727d771dc17b362780c41355ff54a89e221f46fdeea1f1a315e17d67cb6e1a8f454fc2dbf1ac453ef10f40ee420ac5caf304258bab65fd78c215517ff19cd28e7664d2ac2550921eba259b6e0b53a8b23802740393c6cdb08862d28f0e4fa3ce997883a4a8c2dccc8d0274c2e4cac5fc322415fbddd7f1c21ea6a0092a17c3db769542d79da75ead0c3b36eb7acda72c7a669111c53acc165937ad82098d961261936f56bf0018d1e6e732812b1526765f4b99da89e3f836dbf75a49db3e668d1848d3f1547eda72905e0e6efdce840d5e2f42b6ac1fb14bb0283def2c3b2f5b4fea945a9ebaa6e7dead8be5bf34f636115c72a9699ef78065e42664eb5574d7a7d904b5e013c73125c6d5add4436158e6b5f578c011f22d3f27eb1a980def61e34ef2ed0c08336b7ece762d8bfc050d7d8d3cff17510496b87f74379c4500002b0d9439db0b76f1741fec3b41af96898680f6bb6bd59dca33538e9dd3081eb63a96ae858204edb1ca31f33115be769e89ab71f86dc716ec58c2211d4aa80c84c0cb4199bbe36a204af13876a69ed68b627eceaac3bec62ad16196d09a5eed3e9de740911e7a0d8c941ab522095aaaa077b0144d1c4fa3acd09079101b3f8b3182a9ee25487d8f2e5b5b3f364a48f76529c33c3585cbc68b312086df3f26b4d34d7895edbf29dfa0805772cfcca49e202c5725db2d7eda5c1e38fae05d465cc983fc12c0031a9a203b779cdd3b271d07aa15a436189e9cadd5e99c802ffbeadb8e75573f0d131b1850b5f723e1c8acdc1dac3aac9ebbe0248d8675a95f97276aeed95d7fb0d5a56986269e8f3da22347c4bcb91a5accc242795791e02f0171373dbc201cdfd4e924ee578fd586d44b6ebd46ea2d324bfdb2acb7699f3ed405ce749f45be6ba5333cddba32b8dd7e4bf84ca8f854a20ea7eef497cce4851b4302f8d599a5f26bc91c61639e903f76ceddc446507285dce8e1ac0c824b8118619a5e2e6943e719bb349bf260ef63142b1cb127dcafe00744ce93a4f7f5b2adfd0bfc055994e9d6f5eae4d376cd8e81f19ce366146b16d28a5a32981660ec44bf52e3d551dd1686de429599c6b644764f66edf0ef193e6718073415c7c24ed0408f7888a5800e5eefb2ec0580250fae167935a1f2d17c0fe1f6844e78a92e7dc9d2a7577b666246dd5695fc255146a86b80a1a0889ce7ab3ba4b52d73a90b998056e78a203bae6d4cae007b596e8e170f9baed6ec92e35c0184f0e9597e63b73449173675fa96ccf8e960bbacec4148f98afe817d42378064121f83d6a02ba9a45491bf7f798ef26b636e7ae5bcb28c43e31d3da8aec27a30cd0d6e1eec6b771d0a4d01db227be8f39d816f00bb24f7419c40e2b69f96dee9081b6767a4a71d5189a7dde4d2508e02b26f1023ae4b0d7f32e56121d598dcc6e5d2fadd42e19fe23f19191f75ccc4dcf282d7ddfe6901daa3d93079cac2381941bafa0f0ed3264a2c41f319addb60d8c874afec9e57ad339c97dde3649a14ea818c4c0aab5462dc12a3d3c5759d8c22c49a5f02628a6d0c0fcff6b5d87c72bcc8f215d9bc9bbc701f081ae0d9d4af2e80a2b0e89b07fe0b0487601457db26541543087d8eca8ce8b3a1b968732d21ad47dfae22dd0056818f7f27422ebec8744eda80ca12778021a6370d5c2d315052bbb20251a05abe8b030f73c3fdfba26676d0e6e8a4957aa76f6bd2b3e1b0728b174199ed53a6eed29990e8949e1b316770ba7fa7e7dce4b90b63c3b0042108a9e1bfcea794ea8a59bef419ba529c8933d71025c974846162a7e83c7f5926c862191214e123fa0f2a9cf79e8afb0dbdc0b6c4b111d4f8066f02ba1b7bc7f95c76fb0a17f34cf7b1c06218281283e9e9b4417304322cf84b5420fcbe3e44b5696031cb1311912cdb40342040cda81b1027a0f31bac4296abde6a49fac9d7c5a0f5128d9dc3fb6d83a254bda42aff398e168eafb12ebad4db5336dc28b21a62078e4818923ef4eb66a1ab2ea656b9013d5924daf7639496207e2f140d7d57ab07a9337e7a52fd2a80c4c2b4b3f697615a801c0b1891e57f2ed7f687ffbf28c2c413b8009d8a3c12ef4105f47f101faca986748a8de7a967857753f85575701d9055cbe0dcc34b9296f582c984eb43ec798845ac4e50ef44e95a254907710a7f9a520763f9f8aad84fa991ba9e9327cdf36dbc0ff1eec9bf8114e08526dfd90cb98d568d007ab261dfabb497c0ce7da7264e791cc8bedba0623013febd33adf13bec44ea7b8e3ebe16dc93292951a4ac6f4cfc8e19aa31395ce18a4d9695907cf199e6414d3cd4e371522b886b359d5aba00470157cb53a19f8aae84dcf051e963ea520a9faeaa69c742ae3e7eb943b7de3dddedeab2c9119470305d9fc5b0bb3572327b07391b269f1510906e3704b05dc354ce95a6b8cadb4632a9c8508f06d51d7787ddb132871e5831d6af726aab3070f91e05bdaf4ce717be4608582d524d4442d53f719be618006623f1f064e16df6bf3d8d70371c74c191439cd2bcd5b3520bc9ffd26304698d28c2096ac392f72a4821423df0710f4d741210b655b9b7c3602ec291e73f3016b009a669dbed864ea8ac8d63893bebadc28087ef51ff79eeb25202117a4f9afcaab9bfa267581e6aa203bcbb49fcfd4b216124260f5243c4a860aa736067fa902863749d05ade20b50ab9483dd10b44466064824464edcc9c93de2a514ff14c9527bbcb3a5986b4af6a4873760f40ef8a80aef3ceae6f36469b90d0e829ca4e045ac1ef83b3a30805ad4df9462a2a1db78a88b0f63861f2740944d0fe0a791eb791292a6d02199c2f092599e20b64c56b0c651ef79647cc06e60e253ff8e56cfe12c33c49a31e5cc794ebb5078f3fe9dd55ce2cfa115129db78b364bff67a0b6396c8094301ed9e140d95f683e3a8884b10d3e6b694c0bf785fea5c2ddeacad2b5c2e5dae9641908fa4981fdb112f62d097e1248badb2b7ec19b828bb0bd990dd0031555abd950e158081065f779f74d5bac4358f0b26ac95b12bc7730a6118360476ecb6989e3ed3d315b9f52ea5f1d22972199b2a5685354c4fe4376c6dcef0ea6af2b050672514744c6f3b25b7d9f81e365dcefa58b7f731d59f3db76ea68c953fea8b09854bd6ff678aefc6337254d19dfb5e3223547847b75ffd17947170fb916ad0baf96f1832d84bf7f6110e4fa7cea5f7766a2262fd8648920f7537f6547ba651d120c6639d1ffd85f03aef40587963c4fd9db7d0b0644dc538c9369915fa008d65696b5c48eb037d79c091eecd6e891644320ab966dda361af94bf352197c1e3e4c1ee84d8f03ce55602629e67d6698cd4a2a8444317689a00398a3269021526685d983091535f9d7f3ecc820ccc86db19b049eb96971e3cc8279b4ab1b096df3cca54a84166bc2dc34b2613baaa2a04617f37af1b356797b18c9ddccb6ae94ef45cd04e3f45b8acb96cfaed556d1397a508e7cd8a50bf777793282ef1d2dd6a79973d493281a7bd1d64220c5b3706138b4411f30abcb2674e25bf64d31d3c28ad4189ddd17dd92cf05fcc79d22eb8eb1bd89d03f4de52300097b839f5b1bd327917c229180858f4d13532135263673ed743fcc0122f709b8a0dc55c4ab356afeafea82cfdf36f7f4e1c03d722d6410c683733f8a66ef6e6285f6c272d7e7568c62d5b5139b65680ef001053c4b4fac41c4f2c1da091b0391f582e9917715484ca515f8365edfa33c3f78e53f350dabd20c6d56ca99171c77f75d00f30b83e260ccf648454805d0322e26abc1a80c643a77f62515133a55881f2ecc44aacb8efd95868f66656460847c222346a3f5c6abe83ce73201a54a2ad6089b9575b829971330c86001fd0d543244c4e6818404fc53ef32bac1152ac154c789964da843d5e74e08c85c4ba0ed8944d6a17991f15f5b9b8e8fa71722ec03576d89f28b0b68e5c0f7aedfaaca613ebe592405fa61c875e12cefcc8d560c0ea1113e8a7fdb915feefc92b95a18dc02e6968fb755e010d4128315bd7328f1618d80b36472549c84b4edaa036dd7ca138e98ca25dcebb14ed046cadc96507fbc53ace240a6e79b2a8146107f46fcd4f145031fede6c6a9b9fc31b1e6520e7ad935294a41cb361d922882b7c58b4a597c37d29952d94e5df5e69a0ea5a0cc46995c7d5e392358ce18d347ee099da0f72de8861d560237c5dc76792928638778d9ab2661bb97fcef8a0e24c2086c5d8f62d72d046c37ec03aa99c2198da03e0380e6cb0f4250c4de58f46996d5642a300dc82e1b7101124cd7bf5200c6f5a96a3446b61ea226f2a65a8f31041023ef27fd8698c7867d68ebc5782ffd13de5f120b1e8bcb113a4bc14016e958c2a6bb02965d1d4b39ecdddceb49d29911bfea86b1842d4f43e0049b65dfb47f1f4a1cc56bf77d8e33b0b0eb36bf48fe6c35f16890c45bdc88f41cda55bf256ca446adf6c20d42f53e83e2351912365b397e09feb7c32dde464298102a6f7e6929208dfa24d8a6f4e5e9bc252842e6d772ac2f5527017d536ae3bd9fb92733e13fb2e9f84d83ad2e7464c3527015249e0757e0215f93b8a328095f65386891723cfc86ea3c69ac54e1e35104a3584eb8f65d673912584d82deed1bf82092f67ee75fc87df0064c24b55246ae87cd2902e1af5990ff99273806308875c714d32a1da0e7b7d82c2e56dc3978ac7f39720debce3599291fd00cca6b06a3af75229ec2e0e4787de5ddb20f471e7aa32bd0f35646c147f9ce84407b3a8b126d89acbd57ce796090bce25110fc0f029116526852b390129d6ad9a7ebbeb015079bfa497cbe249f226f2cf086903e269938fbd99153acf5627329cf63de9a0010ab581097c27f663eae1717096f6058a2478765bc34dd662e5201568d940fa0b26c663d48bc94dd1aaf3a18333514ba6a4c1cba08c8e6726db6ce4c2852392f4861c1feb8e0ab2144ead10bf9f9b823f22a8a054462e6147deed9fa0628b080f133e2343c2806f10f8bb68772dd7d291a05b32028d8798602769590d550c7981bd35f2901e44b4e8bab303cb31d190bad2360137380572f394c255b51fb8d7de23bbe06f2de5900a53f897832e5698ad967f8c0f49e98794dd0dadef3a0d1eb8993f260e509e87a3aacd24d9fe96f7d290ffd9de00852f4c3df32336d1b2dddce8142b9aeb6d8d109c4ef96407ab76bdaedba102c3ec88da048ff011bb27104a21ce7d28e40a53938075bf402a77d7be88563473517266bffff4959a5d247fe11888f3284d6567869efb60b3514dad286e23d0d9c345a4e4bbf1126a3ab56e19c286058ec1be05b6b8f241cbbd50993f5d7240cf2b28298a5e2b5072179044836671d8ec94ab1814f1c51a6bfc11d569e409eab0cd92e4e2fa88b75b08ffb41ffed8fdc39ba516ba056b81c1605f764139b311b31e5f09cbb3dfea8eaabfe17301a9c027607bf535d4cef325e38f1a76d2d149e3952cc55b418bfcf5db14c23c8a07fc564ee8033c50495f01bbcdf1c703e7278749c8352fbd7d831c9131cbd6f0923a82d60f2df022416c0d407be0df905dfefb27ac5e1132ef9d98e0bbc3878ddaa528268b30790112e067dae21f6c40d7f7457729663e036a422526bc0970789dfe5c14ec9aa6b6d526107271021baa09bfa42344d2202818bc57effa735bbfcc02806743adfbc12ce00278b51aadc006d3fe3bdd857a9c29332cdea232c28d793ac03d196835c7ba7b2d6a0a353123361140b68a90ad495b095535dfda293dfaec4cb26d82a6b7ab3625bbb4f57312c4ceec5a43ea74a240839d8dbc3027f607c484e1b769f461fba2c571e135c2669918ed24604b45645ab01ced1a8f698e9aacc3733938ffbd571ba74f66a1b531b50750d72a32089b3d945f413b6131c8fb07a8d9adfcce586224277dcbd5d67938800b2daa9a8d01e39eade7f7729149753772c3a9c80347889d61736c461a9b0f0f409ab64bd1fb43b0e53d44978d8beb4cef25059f3d25d588ac7aa76b29286cd3f207d0180ad08a6145812492de0bd2505b85cc9a11c74caf78a1013a61492cf19c17c0afb3b947ffcda797c4c10ae3f3f48408ef96bee15129eb2c71a2d0db6832a89a3a08421b4511f01a9c0d2e86ed0911e5ae6f8493c4c4ca78b21fdc4c5ccc69a574c3fdf2af6d7d9c51dd6787bc0dce8ad4f3c9119990d936a03afa035d87bcafe567910ca1472ffde56060f521e48c1a1e8ae3caf80ae03ee5a239e0b86856b7d2e273435a3f7c3c72e25a97765ec61cdf542fc7892006b215cefe3ef4f14383a3afe6d7a51b10edad8ce60df3e43a4b1624c97ffb8d86db99de013f32850a44c7ac488fe3bef620d16c130400843e8b4da94538ee0cc5bf6575e5dbcc50c80edcc4cdbf9a3f8a925446f13ec98e5cf2473140e49863287185ea1309a6e85a8bee2fed5e8fcf879ad4231a0306e8fac3d30ee2b8ffb737d06a0f1af0015992378453ac893e2621b0ea873f34bec3fc5f16c3e9e97c0c3d332023bcb9cb99d19601de013b1c295c96d9396a9d3c03858688ba2ebd4ddbef2ae349ed1306203debc5a322be6e4fdbac66c032ff99f99bd76bac27ca83d8c8ffa83274e5492080c9981649fe67824110707b7aebef010c8963a5bd8573d246d6c331b0ae18f5c4dd6f704a0be4a52d89d67a49c2deb75417787fd478be62b7ceb7eb232598c68b0c6a747def71fe30fd671e07b0e6fd5e98892b50c5629f1fc870784b640dc5706b298a82726ec272ddad4022ca8169670e68a338e0f8e22b2eeaa3a4a51c9ca372dc0c0cffaa34f5cef0c0dee87ee4368751ab9d5ae783dd9024768114c09cf584d5b4e19219371e4a5fa99bd2b037b3d2545845030a0ddaf0244e60eb1ff7d1366ce98403962d9262bb2967d779ac4ea75642551ff6112c4ed2a1019b9dbed7a28841413af917f60a4e4bdf99f05387b6b75988557196882fe616db6d7612a7558d7157ec9b375839347eee3f6d987082b3be243154195d6126857fa192b45928922728cbb9c15f1562ab219de172ee46bd727bb838e7b4fda502f9ca49152d25193d332162e2690772b38e5df0d68d7b5d027f4f1c0caa3638e77fa7dc64cc7426001333cd1ca1ea78a71bc8e7103ba57e0701bba70ce099960b482306327374fb9b21e52ddeefdf8f03fcbc04a35a75b5f70e9c1947ff3ea40c0aedc7c75c4e498a82ecfb0613e420ac44f2a2fc6e21a81e63829e43d6a85683da4fb1dff9bc9caa828b6cdd4cfaed8ac1e5513b50e8f99138f960fb94c1e6587e9cb529ee64a24fe668c87639b969fec7f87c4c6e8012f82b2c366c047c4e1623ffd1fd32adb4180a3c6b4d20f267e8baa42af12aa2cf02a69afb41bb88b9dc25f408f0fb0d74496d9ca8256951de344764e53a275b78dadf34a5548dd3648f05bf387b304f8d9a5cc6e589a1f2a90da4205a0be5cbe81bb92249972ccfedc82faefcbe8bf03052ea80e1fcc9890320f42a260bdb8a8bc3721aa3b826044d2c289f74c17b6226994e65fef17e9cbc98b0b05a0e2ae49cc259f880d57f40e4fc73ba9e0fd63db6228f09a6af864203a013f473699de8102783b7fa2707c12ea39d36d9d5fc2304102d988f9566492e5039f5d6597df599bb78ff7bbb4e6377ff63df102607ff69e70cf76dd7a97dc3eda8a01769cd736667cd7491957bf1ee84edc4fe3cbd4884339068e9ee52a25dbe335f91021021577299a4f239c5ef3921967b2ab13a0930c969fffdbed54c448cffe49c545082793b8e7783ce5017a53058e52b5948ce4eb5287e2053ac4e80133e73d83873b99adffc18735094cfd92d27b11a2961d16df9d1ac7a8d1e5d4f35973a5157cd1c34c986a96b79aeaf500fe6e9cb2e31e0cb043d95ea89c836dc068cd856667573a4a1a70a91ef79805b9823e21bbfab7193203b4c14e0e9cd11a667acfc9c42ad7af24841f1890e3c83e81213ef2b6c4aa11f89976ed1f025359a8db21d4b04c99a1322a9","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
