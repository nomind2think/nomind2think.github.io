<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab572e5c9672f6cd3b9d75e0047378fd06afbd60732f23beabe6e862b8013772314370c98ab4fa21c1407cf5e60837534355659f2efe759685b39aa7ffa11a7c5399846e9d877973ca53adb94dcca770cf1117ab56fc87c6fc2a289c3c29c163a7c284c2ec583706cde89467ea2dc1d920613d828d6a6bc411d0c42c2670f912bb3e548c73b53c58665765225eee4a6816623cd0f6f4cdbfa85c8d50886b67542c557b826bda60e1e62c02f06c33e9421578f8548d9a5879ceca32e94db0eca446a3551c5f5eb441bc4fd1f161f2da235d8b4ac33dd5720fa5dbbe753c3a98c712ceabb30b871de7aa71bb948935bea170d7169ac4bfc6deed6a28869fa19e9bc88d456cb53d1f5514c947d6c4ccc3a438299b872b087e6b585bedbb5de72a012379c51f88472c0fe658ae94a24716d941dd56985ae89b16fcfa47481663e800f3c4420319659d24f4a31ef3bf23b3c97f439ae9f2cfe9eca0b3de6545d81015bf4a58863f7fd83584915bd4197949f668c3100b35f6bae1f8ba4ba89a3b5a3133c052c3c7f2ae7c5139af1ae6705501b3c8ed7254e7570a4801eb3630b2563929b34c7d51b52a103fab8768177c5e9d691245c14ea9bef80c0e83c9630c0dde448ad876e6d160296be9b4ad568f5edeb768cbbad2aa5245d4b29be0a5478170a5258558199e37716940c44cb43696a8b0eab5ed4bfd66efd8a34a4c77800e89f971f31f2a6c62677d66f416195d04b97d5004cd2c87f1cd19f095334ced31cda243c31c6c1786f20474b7487aad39f1ce0c691f5679125f4720420bcd453f93cb76bd0fcbf45d331bbfba222ce190f5dd0e5c28fe4bded2cfb66e31f2108a1594e3319e3ba04e5d3e2cafffbe6c7a1d52881bee0a108d7f5bbd0a1a97ff6d8d1f565f5721681360b680ccfafe1dc2ba475586677e24c0c755281f76dac212bc7a1911508aecb8a2d971e13766ef5130c69aa7b166bd1df79c74b6c72d8032903cd855966c631758e510cacf2c1748b391907f2a626cf0a609b5d938b34ba9c6a6d92e037dc36ea68dcb859c9807d1d2a71b846e01dadd5ba8b535681aed00f61315f8131f1269a706d87fd232608057501ca59e96a7be1c6e9d763725604dff6528179872e538fe8bcc418358cbbebb0f2018cafded2d506304d811721fd53d8174f9932e2478bed3b9cd72b067f4bce23f65fd71ebae46032efc6a1109c5fa514b2e6ca13b08d82c09f215f05787f6ddf56fb02b92bde81467ce8052a40ec78fed7eeff96efebd14ec2044a678d64ddcd6e263f04a457df79d1a461feb394b9ead8c021618f0062b2f4a9c1ada1cbf4338a9fc042f3e9e6e74e80ff6d0fe7eb1fa092907785589ad1ef12dd9fbbc177316a59c98909b897830a112d71956f84624d214e563ffeaeef1ff036b02bec8ab4e6a77fb11d8f51f5708305b26de366a0b175f25aec58e9ed3c2f9d0414371a7282a33d30f4c3609ab32986e4597a714e38530fa2d0f76b33b9424326eb6929327b4f969710b52659f980b651584eecdec51773f64b6384f90531b04c8d182fb535c9fa57bf201a8ef571076195e82a6eb0b3b783b85256c06ee5ad3203319d83e7e5f9475a0fdfbb54beeae1131f0b1f7f483417dddb20f85788375ffaf4ac73d7deaf6822de9f8d365c5a6f3f606a15bfa3134905c54d8b1f265d2f358f284dc5e4d10e8dd52e8281f299972d1e1eca56d407d6043a567556b480f8860b7c52b486523f9203a293aaa636e65ecd12caf786e80c1f424dd39ce7a81eb1a455ae5a1f70a315d24e572cdadacc78fdd052aa655fe69d15bffa3101d4f4f94e64d45b76f775e46575841df4024ab803a7089665457f63da6b9647913333a4a8127d456e571ab0601bfa618dd4a0bcd8f78d794e3ea1540d9cd9e8da2e1cdf10f982a28170e1ad5c450b4ca7b9d73e1311d3f733f8d978de23b401374d0d5ba886f1ac45152b0b65b1805e5438349e680dde1857a1bc53880601b8cd59c33cc6c30058dbf85bcf7c3899c944b0bfc3b14ad4d4242447f4a0d9f511528a5356f3a5c03d5d67c3bff380af043bf57fec7f68f3439868ecdc2ad2bdc8089d1229963ee552fdfefc1a36d71839aaf5292be410bbba96e51b2c7a36ff42ff8e63b5f3f1a0dc6825f768369f129c5a1f5bd8c61561b38a1c959bcbfd05743392efd71e927f02bed37cb002da70f21a0df7781f379fdef3028a64d48382f959ae93fe585d4b0d740b56d0aa8bc6c9b5412db03fd9b6b044a5c5a244963a6df015fc4d6cae71ce276cf6cd4edecfb2b0cd65a2f3678596ef827530175b63cc02451c20bbaf5e02252b57011e92a6c74d57780f2f8ebb0a85e432e5f07c84cf20d40dc5b892e8abb41de6d79679245e36978b3b840cf1ea563af92e5f86c750fecb5f04b1ac74e32575d264fec9270fd7c93a3caff456d616828712952cae332986c0be442c0e2d783623010200206c236a2b42ab2cac792dc9091f6fdc8cba8f82b800c5c852e4145337a0bf287af21c1355033d76d11b7f205df0fde9382d0c27e18349bbf7d40752c47ac95e3a38d0e972a763dfc6b6dbd494d9249859976aac1acc135701f345dd982de98d1deeea9c836e59248d1c33de333fdde2db14c4906856f2ca443937f1f243c75f2f604e0cb9b6519b94c07dbdd5176b96d267c2ce22277621d9b5987357f5f2b5ee697f4c3e08de241a4b5bda5783b5d0cd3a62ae2361c8b2b72143b4d5ecc3670abc99dcf777bd3423111bc04a7d1811dc544b11a011a201ddeeefbf7d3b5e4ea9c7b09cfc2472511cd9982a39bcfef74450f06c7fc9a5fcc27446938ee4c7b2a939697cbebdf36769a29bbbb10f3e144763716b7d360beac3d753a1ac2310c4c4e9091b1944dc8b6519135c811e41c88b52c3de718c5ef8238dd1c79142192e7e3af713e0b8064f32eb91c08b1faf10015d90e29cb997ee22f6ce30015f744fa402e03891d0f4507c60c4e6514bf357c0abd95c9d5ce596824236d6fdaa47301376c9cde12fc0831a9ed20b9c7dd4ab57cd389d8405f1c88d618a1e0418b1c03311f3e4cdd14e72175640e57413926f77567a8c44d76563f4e24c5067dbf1b871226823d6856865f6f2e367d2e1b4c828dae48ba9b81bc0f211572249b87be126d646a4bd20911a3705a1c066974e4d8b85564401117901b782aedf6c5df378ce24259c75733d6a62ab0219da744b57fb55692b181333edada41feb1a7f0ede0764197915def209671a79f5bdf3be0a8a3adb99cf8ba157f186f027475816cae69bc9953fefe20f1cd9fb8a34fa53c52c282136778b3fd92f247721acec951ccf8474daa4d843d37156571c038a14b34866e9976c37a5f511758ea13f16d0bdb392a5dcbd38b033ca81cfd46fe7fa50df9d10c725a50491050fe30cbd83eab8174b89565cefd4fe66588e7f9386cb8b4fddc616e9a2ce9994991b35517580ed7898839a19f9d3e78382c6a120e1c91633da8398dd90ba5bb21903ea49803670ded202e03109f8987a5c9cc40b3e2ee6e47a40de92dbe14ecfa152dbdf6697798dc0adf4ea416d6fc94aac0b63e18cfb1881c8e68fd50cb0e3a0ae2b550f8d62da23e09865a2d938965727ab1665b1167656642b2354cc176e392215acd4cc89e7db1ee51e1783131d3b427696fb222900139c7155deb3bc8bb4f08dd14f27bce5bc658ace423bd96721fd5533b3e3843b11f85f4a90e3b19f459e914834fe50ff29292b0163334c8f530e79870ea4250bfee2c8e35c5e739097f49414733c9b2009e2dcb8a566ad1a9b40930cb8696b7d4c9d72d95cf3078dcdb694bacf5063f53ba64a70c8b78ad7ce0da96b2c7180884dafc36a0a8afd3a52f44cf47fc8b5942fc5fc319a99c12595d465742ca385818b4bc8764d40a6e241336a09fca3978ee5a8714e123b03ebd1a689d707b7750e9c2ae610441f4b9ac0967bf005950adb4b7a1b6d212592c5f610d2172e3472e69045904bccef36e7565e83809e650032d0856baeab3acd932b4485e34ca3fab0f78ab9e93e14ae272eb9994fdcccfeca539bf83531aee87014c1d3d31a4cbe6a89a3b0421705e242fe2ebf377cab25a776cfa615800808a40d99624a5e090378609f6cc8aca9caafa114db906c5f35f4a5dd277d11e00f9804fd795172b5632d1528b08e870cbd6f1af0c0e591e2c5c4bbf908b910711a1803258ff8360b6c9c26f9102db7fa1f34ef84269e2c107d3d0da74a2a0aa0463c45c225956f5ecc2948cb08adbd7d7874b62a2c37cd2a24d7067c784e3031868485fbe12d5c7f69c8a9f2baafd0e111d262813b90a262ef1beca168a648dd1f740de34642595e165664196205243d2e63b98a6a63f7e36c722ce8b8e7e87a50f6cb03e548c3f3ff4a49fea371a89a76133b58ad833e94ffe3c937eddbdbf2b1a9b19182a17043b804101bafa5b4c049f2dfae88999dff1396fec63fc0123ff564535496a223d63932d89afe90b29f79845f9c011beb7c8a82b8feef197b04c79d87434ba7ca52ed1857929e9129b143f96f8a97b26c1f746bfaaf5d864786fbd8e34caa3df256b46eeee69134263fdd13b57fafbcf7e3e611d8e62dd4deae2fc623aca6d6eeff1333f3de699ef589ed2bbdefc68af55bdd88b3ebf1cf77b0e214d6f16c75979daf2ac86dc6a878605b440c02968e43a7b3c835dcdd3bb766090cb484fa3486b60cda12975c625d711022c85b8d40047f5df03d6cd4964771dff74cb73c0e95c0f5c4e13596d2f3e8eb697825494ed9acd38438ef995ca86ca650aaef089f66c71c4acb6376f8a78dc6b057ad9572bbfcd7d940a8c29e2f0bc73aa3bec8a59cc35047c7d737d7ea439c3c399ab5953cad6825595d06c5002b3bd5c7aa96973946dec5cd5427ce0ef2fff2586e60ff248469d2ca078b6518ef6e9b00e336fbf8fbf4919c8c538235f3ea8e15342c4d82bb12330827243a0c72e551de5cdeb2348b0a2a9502fe13ad97ca23179be523935fef933abca5ffc1ea45c9940aadd0994535243bf9c0c3b707f23ddd66abb062e740e6bacd48b349c5d64d297f176c4cfcef847413cde1ef4867ca0d6c4e0ba324430abe3dbfb036b63b5309edb2e27805c45deef2a520e9cfcd26c58a34c9fa7fcb2d697ab19d60e5aa5a8fbf187b043d7c82b25105e767c54e99ca6a655714ac3a02bfb7ac7ff75190b69430c5ddf3a506a8d80658596ac9a97d7fe696602359a6f974d2b3fdf56d7ee6ce14a6f1bcef251b42eff630e3c5c1672f75229585cc97ca518630d4b4e4d458c27f5a0c31478cbccbb9f80b8df0eaeeff3da3816374d5edfa9b25afb7fe98622e9cce10f420ea8c75e9dc32f7c156c632e8d37b6ef2d7b1a22fa9b821fdb045b61a815a3846d034fe7e80613e6f5995026aff40372b9e812fa09b5f5960d0f0b8aa1e166f128b861ca2403f57fd5e44618102f130229456e7dfc1b47f32f4d05f44ddc734c9d9e668214b41f5ce64d4f9a4237a8a9874299c0de918b5c4b2ac6cebba1067dd6f2ed1b72e6a87b37548e87b4b0440cf6a30bfdff9d0c63821c1b195db98dc8a37b4c8ced3c26a213f759d611eded654ee3ab3756bb510c9cfcc7c0adb9375e34ac11bb951fa2655e7c898b6f077242c4ba9797d86d153911ae68ccad557d58c907344e73d53063e4ea27169a09a0a23e8376f2c3f0573cfd4949806bdff7979351cda7ea5de3dc3eb575ce260b30cb6a57d2c42e8329279f0d40854e1ee1ea76bfbe9186a2cd5fd527385bb9ddb794c87be920bd39401d7241683c269b6b7e695cce249dd73a652d434404213b69818da6f8b113819083cb0144e052ddaaf755fb38a2e9b36ec006663859d68c101d57159ac29642569e32b97a2fda515c5d3fcf3efd4ce5570e2c75eed72bdfbb6cf714d39775c5bf11a39b5819582c71fc6e3f5be92c7dd83d637006da2f421c1d20756c46a4ab50f823c123db1b2c3114e5abdaa00abe6e52a01a8f6c8867663b885b7665c1940d08abb787ab24106918e993d64d6988a8f50d91278f0939b0124c46e77369605e12cedca2f362292285886a33bdf623ba7e94f65395dbc6bdc5f3321ce983e680b643f30303f14b4307e093beea5972be46155f3e9414b58723f7357b5770482c9f3e409574b226aeaa8674c2a2b3cd6b430b34ebe9eb562188e63d0d3a384964ec0c6b78d8def8dafd4d26ff5dcea639f7b70bb8948fdf9356c9666f4f22296c02e8bf7bc167776f3ff276676b4e78ae7926e904ffc0761026ffdc51ebfcff03eccddd4c361cd66bbcf6dea6fbc52bd096d33da6c36824a5fad353704114c2177d7cc3abedb621c3a379e3e52faa1b339c453674f6042d0f5b22e078f1793bd301c52b1f9e9f481cdbde652128191c381032894ded6405398c8623f91d1013fbf749e204ad9b0d0484400a7b47dc48b611ead1c4b37b35be77c2def300aaa9e4e87f591dbb5635ec626f201eb84839a8a1f3e99dc05ef302af9ee02227f4cc58054f5bfe0a2da79602ed760747ae9b09e3e1b7dcdf5a722a68ac91a14e1548832504983d03d4394d12d9a1bfb02075222b6f4fce9333fd85ad75fa9996cad6c829f0b151ab939e2e94fd587f7d506afee3b795120bc5b393a0f452a1c0487d06f379aa3466237a7bce273f98936fd7e8b63a3f975c331484260e6dd573b784786f63b402b45f55ed3a585e830084405b9be8688832b18d1b304b34e154ec7b4e235eb3d6e269b9443c082a84a8a49187b20135945927043bd3e9139301800e68daa12aa442606c836111a41a1d01525bc0dc8838ed47c48810641c80ce0e6479f81be21323b7d552ad141536e00e167d137fdc1127ec01a675830ddf8e06c3eda2fe6c56f2f0249659ba259d041a6799dad6ca8760bb90b358406f2221805e8e4c942210bbe756e645ef7fc3f557033d805219cc98dda12d4085a96a4e759a68ca1f890757924dda92d5718fa4a4bca31cd3f36899978e261eb307e6eeb2cf49d95af46476d5f8705c18d64d46be77bcf25449ad449072ecbeabc6e4bfdefdbf3e840c32cbfc0962064c40e8e541c407537dbe1290553ddcae1fd61392dfd7fefc96cebedc6ea8caf915aa306220b7f8bb8dc3fcffa83cc6bbc7d75adadb3febed41d895557a8ae4542d51b1de5237ffba9d3234197fb1438531c0d7136c7a3e9c31aca09ee0c4e78b52c3084c208eecfc4f7b49a00fae6650c1258a149292bb6b5b7e7afa8a9d0e4fa348eb95b80a4624e4fbac165e243910a3097bfd3575e752d17144ddc6882238baf109f1712594c95069ea6212eb6fa8a11588abee7cafc9bccf9330109e4d5175cc680fb4611070ce9773a1bdea506ce095a4e63b11d7251a405f761a1fb304957a9996ed4998e373d48daf08584fbedd2d044d034e2083b81477d6f011ac99aebc54b6a78afde88986b9da3a201bcd957d96efa8d9a1241237cadb1d40af2762835ee8181a3e03df6d6b6f49de42a556b320f984994bba9e131289870c058d004a8fa445f7fd9967cc5e0f3861f09e22b2d2aa5b9c3ee0de167854524e63bbbcf025a11688632d748beef1e39b8fe6dc90e6a40cee30b5a05fb28cf08aa91256c85c4fe6f4743dae7b56c4bb44ceec88d61a8457097f1368d218584c605e09cb67b1e91b5ecbf5b164fdf458cd598d878d46cc285c99acd9ee75b3715234ea47b724e60c701a9d9789f0136f087f0ccd132286c394c8c9444382ac2990ab1c72a6146cd644af49d34638e1d3e1c33ee45b31437ab456cbe69fc79deb08f71e48bff0fb5655234fea5f8ba9a7e5b2fdc1684888d216d0e01ecea8cc10952a78d9353c699644ee4eb7fe900583c1e33ecbac86632e4dc37798f0d56fa44448c9e0ef25f2d8badea6642b55d8ead55a5c033828fc132856801b8a5e96474459169f7627f005df012b4cc9b4ffe4d93bdd8d0e017257cfb659bb6eb7f1fcb00792357623cfcce8f7b231d05577c7146ca7b41b6c88c0c27953c98f1ffe3ec0e4b1b560a533d35003bf2289b67982736dc61e58e56e1bc5c1665fb5e1645d2fc9d7f4e0de7a9ff0cfbb485c2b4765d3e4dcd5ef71a54e60b88e7fad878407e0972f5d2df40093478d7906662585d5a71751596b7fc5f049da6962aae89db2c5d26b2a57eb0a6c70c13f46365598faab724b31ef2d3e841dc7b6c6a8a3649b6c244e38879c5a308070e9e63fd54938f310eab294af5b760d6152fb619f6082c3b108a977b2f734b53e64614230f10f85a4ceddbbb61b54d083a34f8897c50ea699acd090614a2a0fff7634c69c99424ada2fc0aecc7ebc7f834e2708b14ba80de4e24c30be2e677d2094938fe249cde2e4bb3b61a7e0e8a218c14f4ddab0d67acf51b759f52e090ad0923f85afb14e9a97997c0c8d84296ec6fd8782e94c1ce6d708558373347b1b8b1185e00d50069a4cbbb9cd674bd9037274ebe695c5b405b115c9f14aed3e916e384a0cd44453fd8fc0fe49341237fab6343fc5691943ae4e01b1e1f9ed5fd960d1809fa9b6e33d7a215fb0b55ca13a6ab1525f5ce92973c85addfdd6a1f8ade7a17cacf198809c371c0c1f54024f3d42b969163f7927ecbd268874fc4f4b0ba9ee79881d5b40e957480b22a1837aef38ca9901b8ad6927103f8fdb42a6023cd0084b1507712645a35339b93211b272101689fb119e71309a2ff3ad5218291f6f5fda3ee24df0b7e96888cb15b5e04f7f2cbfea28cd4259edc2134272b8d8507e6a526832505118f067975869e1d2c2392ca611d135c949368422bc52c67a33d1763ab68c17d92330e1217250b5ceda5bd00242597d1d943770358f34eab5a9d83eb76b3ff29a2bab4c7e550e3409fe75568348b184d8de1c994e1278599012b8227f2bdacc00f6476dfd5502cc4205d13534eeeffeacb3119e8d7a50db264427cf835cca78a57ddeb27425977d6b0466f4f5261b1119471895bb63d2bbd88efb9e1ac1bc9dfcb87ab5accd20bf878a784d79659a27d7c61946f76f8b64d981b97d5b1b883c38c4806295437d37b8338aa5747bcb2b7250bbf4a95a2f2d18cfd6ede05af1cced7067767ad90e6f50a619b3c33180b7f39fec449d99743b0a58a5fcfb4895cce85330553a6ca2012fdb55d046cdadc4345071e907e5c8bd82c070b2f6280296b4106aa6ceb7d6ed19f7f35d50bf7fc623654419a876a5a4b15e31910db3ad7e4aee7694000a054ca0fab9c0aafc14c2c128a6299df5a78e443437154b919c23d8785b7bd2ddcaf6e254398b39db7b88cabbc8aa5b19c821863e715bfc18b97251cac9f35319b91e8659a59b06be267a90e101e2d3eb67671303b8eaf184648f1efec87de82ad4cd9310ef118263cf0629921bf5e682ece847f17de696b2dfd6baaad118d9be96e487f51837a25b27743183770207fccb86266f68077a56a66f3a692c78023fc36e16df5d1f59659dcb64c89a986ecb23f0d13040013d132b46b84dfaa1faa7769dcc537b94f35974bf415244922fc6f62a54ee957142a8a39dfeade5fb957e0fffe4a6b3a7ea7730a7fa9cd13fdeecf59f86cd172bd45b3c8b5bed6e3fbc59934fc0ca1c87c30b66c5657c1098812c60c2ed54f6d763a1aa23e9a165bb25c438ce0f7a42aef9aaff5cd2f3b7cca0ff6a9227b5d1c9fc22c9c16b1fe8b4a0ede8bf9372b7b0be177801d648ea5aed376152efc1112d00c2b4b1577584bd12438ca4b2a88c0e8858ef7e908e816e004163d4dc60f2282049e75e9a7174897325580790ca9ca9e1197f401010bb4251ba9d0c1633f4c0b36d74f985bf6fdcf0b5ff9305c041b9ddccba9cb344558c4711a9ca872179dfbed477c89a0d615adba330a6257630bcd655ed2d369c8ff1b3f1f158c680bb46e201f1f46e22f3e3bb961c935818ec9f282fdbf4814d95a8d0033c7ba7ff2691b8688153ff52f94878b7786173393d560c560617ac25f6530f71d59ca2a1e369a932c1ab769dcbf1516444be7ee4f3a20d346ef9a1465d1bc8dbc916e87ed79106e4b212c2928709f1748473f2166a82c3463d1a81603124ee4dec70680da3a5859d39755900207f32404c50de79c886b493923e862e17b6fe33cc0f632dd10a92b421f71fd77d862f1d6924c3b72d6721910b7337709ee4600fb9d230bfe1cf69f0a505872359bccdcb6a319be2c7c4d6810968833442bb000541ad0bb3f1dd9bafab9dba550cc5056e540b1a1b09deaa8e09df499e1cc8d7a9b66abc97f0e2b1be33a6c5f299110224be6a2d79099954e5bcabaf82ecdb84b56f43c7b112687c0d06f03202f9138ef1b1a292a18c605deb1535e2dca502f76b251af996a28b72c2ab592c2b81d10bcd760072c3a68ac53c1ac55cbbd4a9ee0561970a99be054ff65b17855a9f960e4431cddc8edf2f8bffae36800a015d1bac161eea4c0a8e26dea962ac2eff1c663740ca8b6d5933a7a36d9f0b24434ce7e4fd388ea0bb2613c8a8a0d0035c899934547112e2f5fee34354907f44671353d334c123bcad76a2b7494d7c69b7ce692c28ce43dc131d9ab1e43157a2b7d388039ad8004891b5efd11aa8fe1bef36a8d78d7a2b2340c182e239b06ac8991881329dd88a6f652567d81e35b6d8a05fbd33b86c51227d7c82325ca1f38aa56dcffbf95bcf424db8e954450eedefe323325c06e035cd74873ccda5c0fcb5fccead30b4bb6dbc795cc504e81ec82befa78d781ef81d503423f6751e3a5e4139c9741cb1cc732dc4ad346c230da7a8db26fe3b52327b30b970c99aace48c5a1ba3bebddd69fef59bfcd5b34ff997d5d105e05ae36fb52e3af6aa0990e93262d3df773b421011016fe2bc711a7a19753d9fc114df99c8e30a31fb5899fca3cc0555612e183ef2ad1e21c0803fc9028149b176c39213a8ae104206a12aef847fdc6d050979c1bc8df9e9f07e9662893342592942cacc1442d243a6a1d12a7d2181f603dda020ecbc3b488119698e29d1331fa1122527c14680cc92fcb7df3eed7138f2796383a20c4ff0a4876977c2a478be359f2e9cab999996f42a1a72189d202ac3c3e886ab16c802e8539c6923dbb98bc5d778db7fa17e81e9b2d52d6ce157307c41423140e55fedb9d044102dff57bc44e2973ba8ede649f79e40d472a27ac45d425ece9c7cef29054d5ca8290ab16ad2d659b0cd2c4a3bd0bc33343df81f8df2cf4fb406ea9b551f9aa67c88ea09495f7f4f72fe1ffd9ec44b115a581b66209be92c769e9219ce8f4255fa3ee59076a5bf7283d8cccbe529307fca550335a0adef694c24be4fce9f341ae239e8d5190ffe178eb9e12e1f90a6d94934f6547df2e4805534c812663b03ba73bd4d0e5d64c937499ad13c3222d695bbda4d8f1b7c6f0f655a1a4809820aa3c0c0db1e3b761e8a18a95938839afb8c702b141e10196170242aaaf20f50475a83fb5a8cfd44ea3b989d68cefaa7cf96c8c2a1f708aab1dbd3895365c10cdc62bce559981feb7cf86f0f0816023e05230bc708ca836061607eefbc0e4ce60fca10d2a05eab0e7b60be1b32d2c2c19f5f5e9ed67e2cd01d9c4dc8820d9cf9b9ded7f7c7fadb22f5e783a1e0034f9c7b3e5d07cbef91fcd5043dbd780e11435c93c5b9adbb899d086b25c8990ae9ae58c6fd8ee1990933365c49105a1fd5dc5beffd4ee480f33bc4f9d0c5c8a5e042da4a5b19d0bcc81f9d8a39322d684bfbacedf9424572f1145cd48ca7b9391736c482f6f4bba4dd41ed303cffb50a756e2041d64de6c13154d21478db74bd3e43b12ed11e0feb544aec88ad052090d9f982421af0b1e89616995b9f5ab46de2c89191bdf2fa12e1c2cd9a9b1b2296ce2c5114abf07aac522d8400bbadf054bc85f762f8ad243bcd38e078f8e983ad4a3d4403d3e89e2e330727c47a64348adc60b1f9f1e1d0ac247e9b3c1fd377a962d2cd0a9eb1010e50f9fb06caa8e745a3286e524bf49e325d550f99641175b7c3c87caeb74492b0d333927cf688898b23ccc14abdcd1725ad3930a38045fd041b0c2f50d620dbc691e19778f8c953dae73a58fa895e91ed5974228f9cd7d525f41515fdc2540e2e3cb49c7138e6e0e5e76e1b3d348c13350c7eafd05607ba503bad47d85783e60403d5e081d890216ab01848d1ac09dd6b2827ca188e1c1565396f042f93f622ecbd1448718ad921b71a2bedbe13da7b3d9963c446203bcdd2c8053c796f05d33c51b53c2021f5a7b8967919b71e48eb23606e74f19ff1c5c6b23ebee79a7f636a156692f98c374a2f08996cc67b868f6547302cddc5d18e5d8653adbb913a589368fb03d78f43d1f6d8a2e6e8858e663925bb50d4b84c69f775be3ec71428c37db919e79b086f168eba41424b5e0419475997b6a6d9dcedbe785160e34a408c8dd45962e50fe65cecff867d2b4a86e84bf77cbb8adaee574f2873baa21cbbf5e309d7e32f0c29fa662374587ab74f28af4775c96a3a2e3cab5aa1d4fc05f7df0fde6b36181d4831b96dc7e63b5e99ddcf2a9cbdfa6e6ced3122070dd7f98f862e6d677bade9df0c7177bac8d07f7d5d840ad65aa525d052af837ff63a39d89d630f1748972e4e93c6e117fb5a2bfb2891e6e3051d538d64ccde9eba6953cc439707c1457c0d8a76f3f66270726f2011d562d6ef4aeec526372ac18ae0b919bc8ed57c819f3a756746912350c64ee8c9792af3bf552bdc54bdcf6222c36ea85e63db77db105d2023c4defd9ac417d48373bae071334ed2118a08de453889cfac3c1c585acbb466fd57e013c7d263fe0f3ca24c5bbb06474bbc6b4486073cc14381cd0374e14ae153ee4d894905ee835a6caa4485b11b5ac47edb406fae6a1ca1b79702c7397d8029aa207bd2c9506e63a3488e29a99d5a445d1d8d9c7defd55178d6eed08a815547d755edf9f031f997e0ae30a9617566e5a65a54b87f51d910ebd9627f91a987078420fd18db5ef4d3a42a2bcdd56be997b3f1ad6549138054f41750977b2aa9dec2d76cd4103d8af27a783b8200dff6432ec7fc5875b5bbc152698d3e00c26eeb83ce1c32441395a3a4f300da7b9f08f40c6d023a828b5a652003a3881906a78e66875857c0ca1dbf3e1cb77e5a52c4b82c3737332d51cca5d6bef79b8a368df1fd70f245fa41e613cbd2cf792daef4ced4b7081ff1447b538c3f5dd5f481676a26c5547639167d35c91154f25f5e52b80fa617d3d0a79ce21c611dd62d2bff95781043bb491d917698d84d9195fbb41c62651cd2d3c9dfea97196c2927bf54df9afef4d37b665f5c52875109368d47941c7c510e3cfb728c7495ae258192b5cd0b85550e9c6f8c08545b9114187933c39f7d1cd3a2d3b465b8a9029e67e3a28c963b265b6137615b89ec10a35870dc6367475457b929872cc61c5e599d4125a20958355f5217c5f91adf8ea188db81eda1f39de50987bc112c19451e8931037d43f5514b8257dc4cbd0a76779f00e8495cde079c65e706085f7d89929fc6f61f7bd2ce48a2e6c21fea44474de016275132912e9e22682a731aa969d04cb859ebe1e52f213f51123201aa48cefc50630d443298ce40fcbe070b46ca5ed5b5e5e9b5d32ff0d977a2dc6d963d188ec8815166a315f724a65359605d6a9c83c9cc3a2eea7d133ae6b88468344e1283b030a3f0236e740cd0c36702c6ec348a710e984d6dab4f49d081daed2ee7d6d98ec10856b3156dc3d560358b57b02e00fd4493f6bf231a30d7140f853834b48a9413e14d5cc832ae2da91ce19de8253dac305319db4f88f7b5dbd9e7b4312f1ebef08e69811a31b1c39d6db8db7ef9238c35dfe2fa3643e178593ff56c446512948d30ca16f4725c160132b8ba14c367ae44efa6e0b8fe1f22b56228326c82b3253622873a8433eb98c35b1410092ee1f2e8389f5866d4e628d8670474ee2ebae92e8e33b5865fd07738acc955f753417a53c0ff1e16f254f3f435f553248a32b91a5b60c9663d341f6e0c3471116ca3a2ebd564c0a6d1b20089cabecd30c1b408941d39751709123ea8efcb1937d2e3490a09cb68d75585927c01260bbabb7dad32cf1ff7a051b6758b61f4a7bfe1e6311aa861802626c5d72e12aaca8488cd4a57c84dcf747d7999cac08dc952d2474a889ecf17c18bc829193cfe7c1d53d015d7a17c459225a81ea54c9fafc3734c0949c543ec730fc453c42dffc9629b677bb39975887428101c7700fea0a9829c20c7910c4c921e314268e4bb86e25155fe056114e4e4f472ada1e083686962a555e74c47181c95b78860de6b67d2fec3114e95992ff1d7af91b67495bcaec122408b29b1fa725995c20b13b6f3c6d0ec7af6de4dc009095ebd97fee9d0398bb44b70e1f7a3bc9942a784ba8a4d324cf3ab2cd176b24e06ffa45450f3793d27d4bd3ab4788fe64c1480753779d1ffedfa9f3551792920b6ad115291e62172a9fa97ced89b09f479405d3de7d511938a3115f06cf84dd95fca6747f65c99b9cc9e49b48346d9d7aa8c51b8fbe5620d657936407e526b0108a787aafdb1c3240f52fd12dd5ddcf7a2eeafc0cea175ddd69529eb1d73af4508fa9fe48ee8d7e4e09045a88588e28ceb6a4564964e0798a9bc971f3921b0e430145913fb35c146bd4ea195925d66bf330c9a8d645ced32490efcc99b55e5e0c483cdd4c4d48b4bddcf7ce38be69fef1f7e2beacf8dabe1d3212a0c44e09bcdcd42a16c2e695cec97c620d4efd9b0d8d110ae0e8a51c92557c846a1e3ea3c88a1f56e6fdfb37e7e5885cf0e731231db064e6ecf481fd5453e102dc196a255ca7987370622aac443df015be4c2ee0a0f11c947700695bec4255724764cce899b4437df6441dbae0369633543cb5d3c40cacadb1c29d7fd03386aec48abd16ec64986334423add44f5f0e95fb59ea72e0a27a1625a26ae83e20dea5b8ec9d77efeee0edeef5382021fd7ca4ade933c04a96340192264848f10a33ead460b27493e8530e8ef894b2ad56c83b4c6d32f60203985d0e0ff32c40dbdcdfde54752490e3f15b38a757c4a57b9a6d4c28c653663fd75b4567c6a60fd59971868384042473906a9e58b6e8c77046b4772deee3b8f24d9bb1af1778e2a533d0823a56b2ff83111094bc872fb0a44f9a8ac0ed6de4e5f6cd934aefa8600db5bc20baf0ec1b8bd975a0538a32d7b2e6dd33b00976e2d1d8cdcf2a8cd10d6e2675017809775d18fe5b200efea1ea59ef51314ec821679e395eaa1cd008535f3af99292b1142fd33ea480a01f08980b4ba70184d7d67682c284f897aec863bef2bf4eb4358da2917347b6e87889f34fd7a10b1c116c6ec5c215f45b7a81caa4c4e8666d2b36995340a69044256cbb9cb2609d5f72ff19a4a8422aea8620fe888e0d39666a5334b7488032d13f3198564b7c1bd27b13c96c2c81fa1f5808e37a3a329124c7050213f4f25ce6d1b88bc3958f5e8d0b13ce7da75c43e0441dc3d6141cf2cd7bb2228cc1d6a5e035ce94cd2c38aa240c3932a762d81303e5611b3ecb96bf1738d176fe0ea377a83555a7648871cd0ebd04bcafdc641c7d7f18823b018931bef81a7b46db1a059f524838b92e8c74690e12ea7d1574253eb179afd1b4d0669c951225ce8841d39a307dc120a21c354f6978ae67e1704baf4ff892c0f5bbbe99203cd8ab371e9e1f1d2c89398c52ff30872d8ee03cc7aefd518240a35ed4169fd1d8de6af68fb2d9e851a19ae14fb5889a89fc2ac3f04661520ad61bff17a2bc19b777ac3b4b482fac27463251ea38f163bfd5a128c3d9610cca987e95e187d208019956f4008c4c51606c1584b68b10487645903b50166673705a11fc0e8cd23310e38cf59546e1e8459d99de32ac574a9474d4c966c53e2d6c81d5123c0979c061502a1ffc108442a2ddbad8681cb713d6926b5e52f3f6b4a483b45a5f94f11e11fcc47bdfdbbbded6bcddf66add62f96bb2b3a6a8b42aedad1edb27bda816708b8480408a844d0fced34e37296413af848888f6fdd7006d812f3823ad0104dd2ea51398e2f80e0a16590ce8604c0be116d57663355f85ce60777dc5bc48f6e1f8245e8c702346446497b728b1c827b0efd68b021adab42344587a1abeb5208884fdb7962d400a33b2be45750fe4532c8b2d1bdbaa6ff855bb6aed200c2b02eaf27aedce7721c6ca0c8ec28893f8dc7a6023743f3aeb050051ef1288db5cfbbb7af453a4e1866cb5384d32a9e73f2f8966f959f80900d5ea4d4ea71e5525c1957f67171b47401d90675c7c755399e350edf4670c72685ffc8c325b18912984d74b4e7b810bc2e27618f52f4414904cb69f8268350f3a22a7b9060dc1b65dfd64e0b0f28ed7f78997b4949b0493dde9298d51eea70381d4ef0db539582166820e77f3773c96b3e9d82049fb20759d45c83a1327c913c82a8e556b5d810063ad02508b61c3e52d41d7608545a5bf862f788aa12746e7a5c17699d881a64ea98371ff3f02435edb1de67a9eb44a6e45e5127007aad55a4900b9d90e345dc49292dda3a1da006403098c9fff8ae774c15a48853a68d863ff1bf909ae29cf8b57405266457e9bacb9e8293f1c9207f55dc8ada65164c27a6711a40fc29bfa0ffeda17bffe","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
