<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0f5e063b62313c2dd32cefef7b196b628968b213a9fc685d3d00c27566a27279283488fe6317c2de63080e673e1fe5f58cc4daec8167d29c40abce1b837f1010d60d21e0d9f5669767c2e6633602a49b814a1e15d0a766db86ae7576f84cb147e1a201cd44c0658d600b16fd4bb3f70d7f3b58f88ffb8a66cbc8c36ea871b6f236594b315aeaa338452f830bacd4c9f77b44ea20c491df75427da8aa6f55123a41a36e59b5ff15be1f4b3a2e0f0bcf9c2859b97360ec29120792f6308f809feb6ba1f1e9eca0e326f3e2bfc533f9d199104e7ddc4361e4b0e83f5218f28a898aa264edee3e4b4b78b505a1728a3b07de09fcafae606c4b0c644b2a8402178ba11da87b835861fda138767dd0eb9d11b7b32cdbf4882f31880574b29314244c51577084ada9344bbe239d14fa268878b596fffe7a77e44934f9292483fa2615b10a22ca5f09082d1f016525157253253742466eab6cc24ac73d6a8d3761003d548f3af90c732af5ad24c47d484a3af8c5fc29e1fcb051484020d50aefe80ccc1266b32ca9b600a0c1c759e974f202ef1f99439698e72b6dc2afdc78ca74c94c1f6fe4acf72de6693e60999abbc7d8a4eaad5c86c01df5436edbab78b6fe17052a62392ecd63c212bb63ff5205d7d60ee0b5a88074348a12dc1834e53242c25f02a57b324bbe65eccb7d724d1aee949a18f4b8fa43ddb8f80cc8cf3a6a8dc7bf0dcf9d49b99b89131ee3ca2086ed8423e381a1243d848263ded8cadea651b644c8d64bf3a99dc2959dec6ef42908036f0ca899ba79dc39f26ffef09c0bd6137206c85468dc832fd04c0a55e482798b26dbac942b8a344f1a79214d8ebf5906a409f0d08a288ef34aacb12ffab4bc2f24422b7dd06cb7b4f492c40c487738d1ed0d4738a521cf8a90fbdc81b9a8cb53c268443091b0c2c5cb56a9406c7d720021e1d02608f1864c672db2d61bce5bc0a301a7855a0fb6cc7f5ab51fb892fd923a853af2b5cabcc3b32f3b08fec754573ba2ef521d1ff60f8255ff7098a1270fc380f1737cecb2e45149538a35729b7fff0ad68a8f7f638353b18f03cf11b60598104fa4b94d520fe54512a54f59dbc28f67a2a3715692169a4c257e7a0c924788f646e14edc197cab4ae0c20fdf9084bd1b73bb01f2ef416afab260add2a6c57985a6e6be1deb2462b02f5c89546c56bc730e4d8a885ec8eaecfe2e5873e059a421c4ccdcb70cbe1b9e9091c7df206d57be5a48f12170b7cc215899bca5968518680ae8f9aa0cc9f3ecf253bf836ac81f3c6d0aa03974fa7fb8be12ae207c2226c9215f1d5195039de7a4825fd7eeef2eff4400e34a3da38f91b8c61e8ed1a603ac717746bc231c67af319a34ed3b1852ecc2d7fdaee8e43d493b5dc0b1ab474aee006e6495107bd6698d9797ef677520439169d2c4b28e6a8bcd1b43e2258f5775a5329b8787c6b085b811d8b393146f712c0fadc866b0b67cdba0522d634af039c4823e5a3706d22a24a38b1bd21e0609fbad0f311a9cd9cb43dbc6c13434c272b4f9a75676c09d75dee9753ddac4f27b5787a19066d1bd172bd47a22c801620097bfcf570d1480dc2146bc988923731cf24fbfd06f85ee0b11826ea08fcd9ba2c8ec4af7af347d9bd7508c3555847cd24cd328ad5f8011d649b2f9b0e4324aea70ccea2db44f3cea43970802e40d1cd654d6079f7aa685fa43ca4b602c80cd20229eb0527b02836b90e1fd2f0d318e0da36a03674a43dd42860e903978ebe82af7d2c4cd618e3a2ec5d9fd50133a9c2f4b8453db2e457887e999d958191394a0560b83b72aa9d8ec7096c591b73c145b6bdeea4d0e01d1dfd2001d5e1687273a4dca75453a44b07a2f7a3c37c120f6efb0449fea9e411c5d91cd6e3ae33fda5b447d4a7296654c7d99f7b6a3c897b81fb4df2205499b2ddd3d87c27156d61b10125939afa2cde64c943be5c7edbf4d362e218cc85c6c1094af4f05c3603c182eb5cdac7cdbaef1b85df407a7e523da517db6aa3feb219e1769f0517746ba1bba3ac7422e7bee4f21e4f5c313dbfcf39a560f2a431128063dce6e2d569124b182de80e591fb9ad0c8d2da676959826e43d93b59df51d70d6626e475d5462fbc85f4875d9286710ef92dfaa66b6e79c015e2dc6951d20c74825b9d570c68d9e260e15afd39f2b904b08c4b8dbf6339f21d3710b2d08c56d019bc0d387c54b83c5ba0660e37018c4eb1e3ac604f66f8b539ce775b625575d5c7498bb258f2ee7d0be0c7737a32f412beea21a2b92ed060f42cbfe6be94f518543543c684d53e1b7c8a52c740350b77ceb61b5cc67113ad6015816f5cd8ce8d877367a2eb8174ac4cea7636ab8a60b8f9b4e04702dd81e35088f285187f2318a01d842c9b166bcdfb58cc5ccf728e878e41745970acf901aba813dd49585dab2e4b63ac9e25bd6735e46359402699a7fc0115d4e47b18e4e9c063db675235660d4fa87336293741576082769118bc4a74d8b0e84770fa9a0a1203d5cf786833343fba9de4af5d1047a9221ced77177c61411260ee5b1355cd51f9fa0d3f184511d6b7fcf0a8e8b3aef05f0496f562752156d4d65b66bc17715f7e888ca45dd8a8ca8f3665de5aeca8334d537bccef12507ab98eebf88952f115fdc27d6f6d69ca21ad206502f35f30ed05d0667f446b733caeccd6eb3f078e2e4721a2b224079044187c3a8568a1d7980adbae62f26117184740e1b892198f27848fdf87bbce22837fefde63ed04af2b3adf182e0eea97bce9b3f95025994400b234e202c7c0d893cc6e1c23b428f438ba9b2d5a9d0a458b85cd844cb1674de91f51fb1445c0ff152ad4fd82b3115898efeaf88e485141c8211d8adbff05057f85cc394010492fc2e6d740f4cfa8ce34fe6a060d7a71386dbd77b262608e47f00b697341d1c06f9c734eb2c23e69c5be0fe322b8ba2f14f94c6a6441fbd7f5ae49895ccd0c6d5f42b265922735941eae92170d94854f6fb6cd9558c214cc862a247c7e83a92676fbee15669a54005aeb492dd0b7dfbd1ebac8c597e5b6900a79b7eaae293114e0caf4115f62026f668a25c8994fa6c10eac13b381b2f2a1578500eacd85101f52bb6b6ce0ff38de0ed6951ec7e2379b6df8cbb16d2cb6627f4a0399d1e24b6a85aa9a59989dcec882b5a9b8ae0980650f48186438f9b0c23ce1c435278c8a3c177a7b8c95fc090f1e6cf1ebb5fbe28c68a0fb2695ea7e92b99770ebacbc00bee3919dbddb40eb3fd9cea60b1b1bc400eee49b43c4df06bc324f9e5f156385508bdbfd140dec83cf2058bd650afec56a299ea19e8e7b3c2d01eccd36d2d239a0d89734eb7046d0aaced44d81218d46c178c7daf93a6d21620f80e6c4bd39f6bb8deed426ba47dc51c3e4536da7b7a308fef16af4dad7dae69dcd702607d115369f17853687a638f4845229c5c2fd0c0f3bdb31816994fcebafd1a0df0bfd9ee152cd741c2bbd46ae0b404b99630d0b62c9d195a899518226c65c2ffd077d2839cbdb7ae516a62cceb5e8a9289ffe3f49b7eeeb18e86f1c99fd2f3420314e3a14c84caf747d5019af0fff5ab0fd40110e2b70ebda420f7b55e71d5c598ef9d8efcf96375b469fd4fce7152b1d29d645fbac0274f003bf1a9896b0344f12fdb4780b009ecd84e742970738866a5c49c64b91593fa37ee5fc50192d3b2e2ce1c6135de1fc6a1d458e55b622d399a8e62f377807b7936d030949e979ed828b86c2d1672744aac84dc28111ccdad6b4c34b5c56c8042176f9a72377ba09da762c07935e1d6056b8f491cb0fcee66a731a4f82dd428053ffb8ff2237cccb584ceceff5ce098bc30d6898f94d44b15fc7040c6e1a276e371a311439496e440351d6ddca5a6e1571a7851e21b3f38ac1795264b8b3e700e4b26491ed7013786ce47a858104cd610a7a012e0de45a96747242d9a7559aafc8f4dec0adc2f78c17fdb9338ac3b2d4d8cf64a060de77721373c52023cd374b9a2f3d864ff0fdf07478db75ffe689e311b12b6c37f1e4f4d92ee7c7a969b4e1780d3a7638a56e37b53dc7b913a584e6cb0381215c8cb4e2ad9b254e2d01809d8569ace63f9438d1dd4262efd60a9a8d1514164289f2497c7fbce84235cc2e45baf658469feb1c89f42bbc60fb305863b381a97da81a2f3c5a3a23d96dd3199171ed2a2f25ade21a3bc77c133e127dfa6cd5ad5b4709e21c3184e783bacc7a897684402a4506639c460d7ec5872ce1d2ca6b2b0c599851444ebb2cba3dfc99a43b00880758413cd062452362115d06776bf7cea946c7d62fbf18bbafdde17cd97ae4688c4d323e5be9efae3942e03ab38d05d73e6307ed000cda807780531422cbaeb021c7f02114810af1bc655258c8b9e6f465700145b78ccfa821108bdde7b6f86311ed3d254bcd6d334d8a3ec8cbc0798904542109cdb81f487ccb981ce52669b636734e70be0d5dc17435256caddc00bc340cc4d27868d2f4a0c62af5fd7519ce682e17db13f7546f301ec4dd5b63c43bb1f6b82384708e205984cfdb8dc4c9fa383755f0367bc2ee13b5b83aa749c2e4781722e08745d16864bb1d977f85731761ff7a8b4a9fe6caea8d616abe18dfb3e5792d5e1c1355ede8f4b464c88f48b070c35c306c72ffd3658f480cdf7df4b2c9fc519958582b1dd99b1f781595e7e4d40f79b571a965fa4be01d3c2a50406e05591704dccd943c8bddbc719763e6c16341eab4970de078ef2abd7134a7ea5de3327becc04ecb593012f2425f23ccaa7f39b9f7f34aa1a29257a1a63c2e2015aa1f6531721601719bba3f8efe4f3bacb282fd576097b2528b53127c9ab4ac96043f133bb11ae3ac13feb834712bbcd53e1c33b8ffbcb04cfcb45585df41ad14990c9869d59839b6e2801945c7c19388db3ef95f01c3ec336023a0b53cc3746f2df9ce68eff784df7faa60e090aba925ccb87dd020a723fe4304d4f701342cd96aa5e302931474321f2ecc113c72b38107289560ddf0026bfa887fd9d2e2681eabb0b094ac1d5065b1ab5c75dfbcc7cc576ed3f92e67c0800fdb135d9d9b04ca3ccc14d8d503c6575f55446acea221b3bee8ab7415cc869edaef01655ed94544b57ce7f0317c19543e3371dac09554b372d7c7e9386876ffd56269953696100da2e1eb436fd471abaf53673eb659ea4adc13e8aefa869b8cc76fd461ef987b100d122065196b604421238830f9261d8dec53d5440f11189768f7f558881140fbb20dcb049a1a0458b3a90ce400242a3a3360c63db661e5086daddf57faa374023ad063a121f632d96de8190fe9ab0126849c912ec511bafc9861b85ef4cba2ddf52bbc93f151bb8d030bc484f60d8f15a2f8a0475669939aee42b561c05ad52e5f44b32b9f9f23f06738a77c1cf8a90349f7e542b3b30c268434c5738519b19380f2bb86c5447a9b8c516c4e1035cdaf569f91da385be7f54a96bacc4a6d7496ecc89a2cfc0d2bc4ea027399f4ea1e60e53e951a76457adadb2f91b4e6656ed4d0484e057c21581384b39f0070590625abc040ae21ffaa3aaa2a2bf4f23d2e4321b6ca332175ac68cfe80efb0369ed578ceca2611038496a0da0eb56f6f30b0d0c13033b305ce3eb747a9272cb33504505133ebdd0f95518907a56b7e46c9e018ca7a810b730a836c8fbd94921c0fe4f3c20aa28cf004a11f71d455525a2ac688f2d2e91a2cc70eb636540d76e231cc03e3d1b559292648839fc55154dd3d9481c9ad7d2f63326d9b23d7a0e53e53cb59cddebf9866562b91a457d3ed62daadeed99c7f9ac346f5921ad2e11808145018edc3488fbba698583477f91fada091a37df861e5f0b821693c40b88059aeeddb8082ef60bacbd47ccc118b3a2efa2e379f9accd1f1c2ac1d0bad25b9f69d490bd495829a474a67c3dc3ff3eb651a3da5adf06874918b95e940723d72ecd65eae65fd9d432ccc4c18bd548b1cc42b99b5608f0a4828b65e4192880eb073ba1b34c33ef14cf301dcd6352e9d34eb7d2afac07a1cefaebbab8b45fe82284a2cc18e0b1d4341c42d4e8237b863d1d7d02492a4ec296a700ab1e7ef6c4e0e2678cdc19a77e579f1114d6de52c7bf0a5e00f049eaf0c1cdd8d328fcaf29e2ab4e804e70605c8ec92fb4223d913b9f6b7f06bd06fc47473e465ce6162e763714a165d4608a69b02353d3ecc4205d0bc2dab521966e3557f62d922b3a452c698295d116fc4ac6af958c927eafd3f1d7b881fd92633a9032ce1927f97342e55173c88ce5f0cbd5dd3c62edcc0b69d687284232dab5b5e08df9f72f5c945aafee3782574d7f911521edd5cd8e6a85dabffbab9c6c30fb16a5fd9aba6e84aa114d526ae52bdbadbc0eeb0b8e2679360cd8c58d186df320aafaea5b312a85c9d101894b437b081c1dd165624f4547d8459f749b35cf0a28e2da9775c63dc2a21d08c04b08fc59efb47715c1cc8320ca6daee51ad81071560ffddbe6af8d396f6a29eddaed6a24701473a7d6aad95bc5e4194d09d5a02ce25c3a1271e1260a609da05c1b1a88a01181a10f9da3d5cc63c6ddddfa2e0ef3b537618e47438ed003485e9e76fc99a27c972af2ddfe126d3533eee64a1546be905c468dc12e82c4d76a63b4fd08db3922925b5b0c194a4f6e62b76ed006c6a076b2726255262400f02786aad4e50a5d64039bc157ab74a0b2607308b22ab0556511dcd5a595fc97e452fbb65e768a378dfba5a47a94e33d2568bcce8361d68ba23ca994a4fa2b57fe31d215fe69ff411e7a8c30090909fb6961bf97e27776b5cc370ce905adfad1dd05395997ddd55fd838e8b8d3cab0f3da428d90fffe9f4e4bb93153e8b802fc5e49d1800a8f6118da3fb8a8689a3b2009f2a45529befb510d9268527cd718282fc05ed8e0976dfb1bd1780d2fbb247c08df2427817f4a5d8896b53de8345461833b2808428554facdaa2b71e712d2e68da2a15815c86aaad3da873b2f980e9c08ad6846c055e42660564253a4301f28b5d2a808f5ba6689412c4635faeba404ad543eef503b79bf30f03c97bb20551c23f8b07da3b9a6122b38731f0013f900c14d891770e1b5790270efb897a7b6c73bde4754fc26062705b04d9607f0101254213bbfeaafd0bf201355a651df4e92b9bf63785f1a61d9241c0edf99552f7d0c70f7385b5a1ac067526d1b4321adeda0ba66b722acb756b8cbe847f6184ec5992cf3e8407fd72be6d792d1e979ac8831e2d2458bbd83d1c9b4c9da5026bbe6af68963ca013f1c88a114144b9658f0d48aa175569d647b729526fe288282f4c08d12074a7e7a5e208c84d165ff6ee92561272bad1eb2d65d22a245ca75080f43a8317356866431704361d18dcb2e1b8f309f1ac838b595e3295e7c8d9aefacbc02d34733df2b932ddc198b04a13feb5d8e7d34a58b397e538439cbb0d6b3c1cc8dd1816ecea1a109f009148410420b170b43e7e97b99faea6c801d87eaa2577166c3ff473f0b8ba2fea14fdb1c147b4a200c1f412136abd649a75966c4993461f12551824af58ad5993ff892b120e3aff4aef807865c95cc8d21db7a499b21a80ed8af3a00184d5c2fe7fadfcbdbed1e5e607c3a73821947b3d8e3fb57712b915a7a956b308337d3b06016c98cb3eb571a5eb290e5a433614e22b493dba51f21ca243322ec76480ddd6b33312acbf592431db797f3b219a1c368a7245ad2a4c9142576ca0f312d4c5eb127b5c45b2e7987286452d6f1d9f8f1f79239aee3b17333c7fcc3622e81699d309d1f6dca719578c05ee501ee6d98aea878f00d9382fed4a1099b2753640e3b588609566a87785babb15755a38911007ce806fa4a08d85ce27f20481be3a48925ed034ec83d74a98189d4939082ff6e18a3f5e04be05cb2a8001c154bfa6f97553910cf7071e44644eabf4163d04f9853be73fbad1608fe7c21ba5e3fb383addfdc7134eb89b1d1f68961503e452c559f7987162bef914eb43e25a27956f0ee32121483fafb9cfe05d3dc57e3d210adfe2628887c1a349161d53d9302d9b5cc2ab84e5a76e537258300a879535d85ad74773aa0a80b86673974d82187d92fb8d345f587ca6f7e5e72403882f0e9ea1fc2f702406d1d82b6662afd2be17d4984814b17145615ea0273ee42c021723840b4747a27b557fb08b1cdcbbdbc2c5ffa3faeab7c0329cfcfa778f0f217699a6f91d4bab1484dfcc60ca900b43f76fe063b134309063df136c5089e25321a2906eef4f183474ba2b6d3f452795a99692b40454d60ea050be6b862e17b06422b5f5f19a6e7b1358b7a1f0dc39c5736dcad3eeae36bbfb0f86689451af3841b0ec8e5ec4c656cec3318a4804bd9400f768097e27034fffc9c0286fb598087b0aa2d10a0c35a1a151eed22f6ce3220541759dfe64ce699ba35489cdd84535e4b0cc469132bbcff53c37e433c1639eeee9c1013e623bda50bd5a24b1e344853767e9d5c9b33722dfe683f24a2eabb21cfbedcf029e8db6fd9acb70a60ae14b657ee3f15d4870dc26d3840284aac97ec3ec5a86f90fe2a7213e3aa522704955d347a0f7718d06e1525cc9d8d4156220f0dd4d29b0e9937059b0b93df03bf4144e9997d5c870b81c07828b5d469e40fff507e038343db7a220356db53273074a81cc552fc86541d0b2fc6008ba830f8e63f902266dbf34e4b78abcf8c5033466f3a344f10e7c6d5fffcbe5da609bfd24e70ac65486a39ff77c84b424d6acf3d9d452e0dcbb0344b7f3fc9d29a8dea6bbab81f94cb19f6875e8d86afb532482de6f616fa1505f12737a63f9835114cbc10a91c75c569e2922375e2fd5ea13663767845ffe716d1efead9b3caebd37229648a98065c2bb349392afd9ed92dd86b2ed69c3050ca77f443302ff91137752882d3047f97ad20e76bdc9eb05557abe6bb2523f07e4dca41ceb319eb6d32bf3fe7ff50319b1aa848d619b974b125c5f253556e195efe976ded8b0a284949ced19c81cacb1299db7fb9b607c9112120967aa33732caa20d566872280587e3523998579f4353b38c9812b8a0b84806938ffed2cfd40053ef6180ba6e147026a0aea137166e0f303f4a5939f6fb8d9159a22bce1d310eaf372f3a75f42f91eeaac035027acf84bff3910f3a1dfd8856bfb0e2ac75691032f63da7a4dacfdc4c558dbde7c8a900d039ff2d544254fc71559b6864e022ed9bca12e843651fb6ded68b9539395d4b7aa403f5422835ca645b3b240f3a00b7f13c7a14a6d59bdf84d61cc877ed7f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
