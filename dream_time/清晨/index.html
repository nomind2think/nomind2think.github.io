<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98b8624ef0903556da05b1f422c7aec33a0a3e09623664972a189092916b26fec5d4a1ec77f0a5dffdb8d49214574b1afb71228ed003fe2ab222051739c240bc12f61ae8920c2b6a42f0328467e2957548ec7fe0dbb3510362e0a9c2291ae410cf3bebee1a5f010a003a4995131058451018d5a5a44fee4e1673102af8df2b2ac8439b2c19a821c5d482a7186d5f4ccda54e7cc05728ad6d84f50389a2c8b03cdfc72735eac932e24849125e6d83a421989699b18e01146c561cd84ac9e7e9752c636d7bfb1e63d5c64f891e544879fb8967e52df0939e8a01191c367695816eff66fbf5799fb8cd8310434aa396029d096128e9610fd7a6e3ec460eb9d558c1bc39dcdb984dfceabfc85043d8ebc7547562b8bd3a6c5081f27055ff55a858b599e2d3aa5cc75697e4fe4da519bea5215bafff94108938c82557420d6f0123992472054e3103d88cd36ffc0c464cb2fe6f4adaa6cbb2a6a8656201634fed5bfb82d874dcb2b68d8b8d764e852f35e0f9227c26058f359b39452dedb18d0978d1736517e64e7031c161164be1b61958818944fa36eb09cd60756ab60ddabb41e8a56b6518cd6ea40c22cc33a1b5d8928c8ab3c941775df073d869657cc4084fe206213c8be5f14836596a51cedb483c020ae46bc4dbdaf740534a686b6418251c8a3b7f43e00c6289e7815f4e4b421ff70fcd719ab2ae7f39fcac0b8ea1e650b9563858de41c273033519c8e937cb85ce4c3aa37d5706a87b596819eb8ee25a6edef6dda0fa293e087e322e2819ba607533aca580571aadc89c514326be3f022fd03774e5d9ee281a10cbafbccbfdf383231ffe7b26c8389b435e15d1b443e1517d98a5018135b61af2fd8e06ecf838d6a17b5649c3ca516d794489590acd4a31a0dd2885ecdb2da4c5eebb41f03ce59b8d92ac1b41b3e1ba830c48824acf9b50ad0a46ceb866690d6219500b4260f04361c987390cd47e7184901d2e22e01ac64e14a65e2b66079370fb5b8115160b0939c27011ae2d3e07a7cc3c8e7b686a25ad732d9b7ce2369dc09ba68fa3d475059a30b6888a280e9d9896ce80dbcf67dec65dcdebce24894bd0269f0b602a8335e4e1eb08554e4095f50deb1f9976ec2ef9d3e82d72e698b8b2978688eb28ba06b855ef749729c41a2ba088dbd55ffed0fd82db1d9378c870f985c97b8294c1b4bf205f4260046d337037f80a70e523a058252bbd2b06d93ca4bc84d34824744d1f71f32197879e0d70edfc0d8a5277dbbccdf8031c7e7433279cf4fe3b5b599a020b6182644567a99b8ecf966d4a4a5090dbd9a86d1a4d367e4cc649dd4bdc628c843e642eff8a169696aab22b7e6578943e2b792b3ae62c25dbbdbc22c88a14983d226ef433bc785ffc9322e434f02596274cf76767ac15e7a6307b3694af6372ef64a68a91340e09215b07dfd85d670b8e1353e744be22ca311b4493a3e84fb7ff577b19c2e72596488fc41ae40d0ea7db411d07cd177c38e37b7cad0d88f177d536e5ba2ce61606a1ad76b1d5864079be489bd3baaa9dc2cafdd3d83daf2354ce9ba9a2a708c6f79d85b4d3f3e06b6650de5ba673484f606c25cb144a961eb8a764d98a855f81df341a5605ddd550b902c724362dfc08e1304e685c9651e60cf7e56bb80ae2af2bf37cccd9089497086f1528356567032c7eb09c4fa11c8e1ddfb40a9c1ba8da7ae239b3bd91010d80937510633b9206261c3542a825207a8d87a11ef96c07170f0e614c1c65720c557ecfc0b383fad79f43a95db3e016bc9f361057b6697ad7730067e64c071dc53641a8da00e6724513b76960739988ad3cde99a75aa76c904243d1fa0170a9f5fde0e208b2d1f685b8562a7081edc44e957b268ea8bfe543ee88704959c233f8875e3dcfdfe064839df7ed9b685d22d150e76dda02d340434801db01ba7d04ab787e7a228495f9ed1a291b9743e35cd13e029db1702e5d8e932fa1343ee319ff1d66115ba47fbf2e1f6cd93ebd647dfd84dda581da83d7e62420c7f39092491f36b7dcd38e2dfea687046c4d4a60eaf798fcd5a5e387a978d821689689598ece7fd8916610dd9343d91ef79e704f0421ab90448c631859fb5ae2df4a8aae777799d9a8153d2a816d9bc538c21eff736304915e6b327ceb5c68005165eb7fe9797f133cb6b973fc6ad5655b885b7f98e0e96307a56d4eafd0fd99e9bb09476cff4920f91d72971e248e92ac86a45741a395a7c5a63db9642c07fd8aa6db17054fca0549f604072c238bb8ccd22a8be54324ec63da0ec3ecf06fd502e30a868a69359e9b18cd963576524a0de6b3c677156b87d6ac38a90a7fb1f655a4bd6948e8468d9771b46d37b4a154184df62c312cd4bcebcbac98fdf04bdf0211c1df9a238c011f224329c08a6ba1157f46af123059ae602173f0c24d1858430434e81a109b87b236c509026c473fec550a7d550de656138e279f250a4561517d3b84c98b91f8bf0dd5ff33e9b37257c22150d3f1b7e10e16a5d155dfd3e2ece6d0ff29d8958637ee3bddd32194da2fdb198c321fcdc8ea4623e88be701a092a98162f2055886bd2c9874ef95b4fae7f9a98af660616f897052560d63b6356caed7db09b48741cfd4634084ec01a9fe0756607e0e745f825c553a25b18fa24368892e1b81de5923840843b7babd3cf8dfee8f83c540b2d47f7789d75aa2c410a183b30591087a2697da3ff2a3b1add0f2646850f3dcfd40b5af71a86118c5d6226f5cd54878eb4177d6c7504c5fe539e66f3797187802e6bb299118a97c43dacfcca2a78563f6ae5f31ac3a30fadd78678f8a8a496f4ee1356a53f25c0deceb939a84af02db60576baa5ddc0f65e4a880cdfeece677e90819de4ffef7a17c846a95b7a4fa9d5372688f3ef41edad65e3645915ca005bfd490f028c197429a3ddbc5d695e12c7a0ec705d9742ff9c4dc479fdac11378aba5c844b4ac99c6f8cba4f38f0e63e00d4c48f595cd3abc86267f3b3f43e7b4eb7e5530a71d4082e05ad13dc88bc96c61133632d77b3b435942a698cfda1bfa9bcd5caaf445dc6825a7610145820c7429d40b93c6456713b6a00ec9be18cd335168924e12433a3e56a1a366c888c01ebc753ed588992dca227077659c989714f23e9bb9d795052019a7521e42d092a6b3447a0e18067852be774597b716206f3625817cf8a5e2892959abd4402b2b3dd7c86e014b49cc2fed54cd1cf602d6698914cb38cb0749291320548851aa9cd3ab36fb520f92cc8cb2fb95901f3efe3e92d9e7bf1aa9f5f91bb79e8a696c54a61fa326f2124355cb11cfe4a0aa1580e09ea11cbf555769460bc8abd7e8b7e8e191f8a54868dc355499c5760c9ca7d981e4a936575845e859ed8a0ae02098d1791edd00c64e22cbaed7d66f590f1f366f98c474677b553b382c95a1bb736ebdcfe4a6528722074f4fafd213e8c6fc7983816d88bcdd35d7657b5804574aa369b685dcf2815c6db9a6cc92df6ba8bb6e335d427ec0b5826b7e6907e3dce3b54a66a0fe07fd19874b1b8efd584ac9a1e386743966827aa13f4e069a93853d027832e461a4fd1a96ce897e3a91ac0e4775792a2d9f6f18c3300dbd21144c15df982819525391ea9487ce4706aa719472c64a4ae66fdce9e11ac1785675ceab230b460854ad255c3ff0216a54b9a1691a72b2c2bd65543456c292ac97e3125b4669722fccc452321e315c5e87ebde1934723858f937c92f0da011215c5e4cd66a7c3489a3261e0c48da52f5e3c2884c7bfe06b055e285a556a2a81938cb666c84c63040d360e8b92f40c39121f6d2203e9082198a51473f8d1aa3f2d8cb2b2623410dfaa180a3a54df6d375d890375d8d4933d855aaa4e568c62ca15befbed6e8bd11bb9c8076c33fd875c4570c55f403ab82486bccee3b2f5e5d0513f98c8a94eab3f94ad2f8efec799a27762fef206cea8cbb73464307a92afb290f5e0c012f7d7460d1b7c9e2455b9c9797c8066031578fb2a89f01ca8906f9da1a2ab12ef529bd2f364eb17bb5c922875d69a572ea08a59f61fd0fe84d28ebc31d4fd3ca377b4aa2c3be6f20e72c91f21511ade9026a5fcd5a116ce803830e6d8db71c43042d769a2ae9868c538ab3faf3bc81dda07ab5fe501f2321480d8563af6cd4d6dd599f2c01c96cf35717ae38a28b7cab50f1fd4469446ca9886a083043de1752e18fdda417af7176615cf88ef44724a7f90cb85be81704ac7ac0c6dc40e74833a95e9d0209017a272778e41197f909d3461a0356a5c662078c06f5deac30b0d07d9740d1ceab85bd2bf5b9974172edf5dd2b1c14744afef8c1a22ba11958755623d7fc8eba9ae3c7de8f829537d9ab2d6899d999fcf49085d03a4fdfc2e42c7230b921bffb4474f2e71d0d7e6171d1d2f492818a2ed10b7dc648de8f5f563619471ea3485da9a6342e4c5fa8fd26a440702870108395a264d5a2bd390228bc1e72ad809dc6982e49f6fd3b9e0010b4880876e1d8dddc4d8f0a51acc146a6483bab80d8b6dbcf737db1d600f8d52166ff53a8f66fdd0b22869f35a856d11c61e408362b1998d02a68175e0480c0a4a530a66810239b6ed3cdee0893a1ce70ccb55a7261b6653277fe4d714dcecfaaf47f468a718453cbaea120126a3fa4adc47ee0dfe2be4563d0b047cccb18101a5c909ff3df9a271c35c007c5e6655afb9540092c5c40aa9810f8765a77761366cf0ef7e91373d9267d347a9a4ba76d9b3c7b588468a083574b1c8b0edeeeb9377da1a4ef8d2367032d4a59cd2b35e4c13524609593216003211554225215fbb4cd95b76fcac90cfa6a602044fc5c3a896a8736fa0f1bbce9d62add52531d601c10b1bc4c5b29475529fa016d6a81b03ba0c4aba3f62d3721e46e20decd6b47813f1392542da888ee5d5bc51ee19960f4e60178b302d00cfe301f8acd76c84bc4d45845dfcfed3831784855fbfa11d42a54006ef2c63fd066eb58405451bac384b369d9620196cd9ea968fc9e1a00540d790a1222aac9edc88c3044b23183ead3c6d3ba1e1e312d222370f40d17a42d2b520e41ea8d26a8906ff5bdbcb2f7a49b8dcf29da4372055a6c551598b90951869a510d16683a0d033a54582784b4c30f6a0ef542310de9a4c5e9889da20aca3bca9e099b80feed5954ece35abae9263520c4d1838ada6a56f44f40a8cb23615ab6f89e56c1223efe23e5043874187bb533d0923cd3b6b8ee215830dc723d0694734c9774e3670c97342ebd0251dcc56c6da8b36c4d34d0ba8ca8e36fb88185a3368a45d441df18e9bb62ab22ca6c28b5d2529906c6b435a544982e5f429d66b129bfcbaeb92f3d9b65aecbe5dadab4adfb8511c2592b8629dd7a53ed0328c3458d274c6d869176a9e292170660f59312127967e41d07f42b6d7a1150a0312cdb9e7cf3a9a95708ada588807077aca85dbf6c135940821c05858a268f08c5ef41c8322601913bf10309d2361e2372edb07b36b927c4b862be05fdee9df842d69417030a3f4d0c1fd9bd5f47399b97ecb401d75cd92346b752c238bb0437b48699a8a859032ed0d43091b3dfb487558a817d1523e3a5273afc978ccbebe298ce1ca6930e5f2b0c4ad5f429ea1d59e711f1bdda91aa9c541148a8e267f2ca52cce6d378b5af3063fb7f90a0a638f05e8b5f87bb188769c211b223495ba9eff1ff2a0ec37ac76e74ff06655cd3acbafa80ca4451f04692879a42ea0bad4be3c3a1d7b26eb7d2ccec0dd3cc6a742efcf6e7ed8cb8f805ed45ff246560571ace8ca492fe98b92eb29f3835c29aa4893aca46552c21d4774ec15b1f5949c3be1653efbcf4feed08c60992076b83d95f398b91aeae8039fb63461c0e77ac36498c8f106a4bfe305ea6c6ef1afbcc79a5794c8728b08710a50f5f1a1ee7e9376d172c9ccbea6189da295e6ca17af22fefa5581986fa53fa84c85013f462cd0c4ea8a767b3281e968d77470cc243a808a8bc0f51710af52b658eca0f0b9d027e45df6859c551319c44f179e423dbbcea2b8237044be69d46ec775bd3e8e85e50f17f781f5318843a92f52484e4ea0e38d2d2c2711ed6b7dcf8d724a06e06c3bba3a0406c807a004f9bd54d9d0b138ee6a1cfa7b7bde3bed52fd2997f5c1f5ae7844a0946101479d5c2de0cf10636cae35ed03a6cd121012b3063205d90908d0ae4ad24a99fa424688749bf29caf3db70666f1cfee5b531d9af7a2ee8ac823706114e68b0571cc8f1a02ed1fad1348b8c0ce81c0cad959ca633a47a40d975e33e0bed7bc697c21f08c09d40e88b5645c5a6a68170790a7532efbda61fe78a64b53567009dd10e864d4c7d32b6bc9398acbd985e309d615e74cd35cefbe81f39c760c010404dc5cd91a99563b38c5b24372dbe6f3adb9880b20ec70dd7049d0c808ee6f8fad0c6440246ff3afec47a8276d62079e2cd8a4ff2a239647e8339e692f5797f78aa9fe48552be78aee55ffdd93f40b35f38b049e8c1d5e3f7edf01abeb4268506eb59e5d8483e56d5d4b29c56168d06a1041b3b215522884e72dbcc541f25680456686d2b8a27ae52154ec74510e16daea1a6871e4670a0b55a98855633b73e903a3e826d7acaefd139fb8da9e1fc83a8d0be7286da515723c3f2eee89ce60bd58f9cca6db7ae913dcf710997663e0439585806053bcb283d95272e02e22ab34a4b766a5f9aab6bf0ceb3f667f42473753dba168c92ef6856751a7da2d3f41a08ffff6b0fb15c02de16b687f0ec36deef17ab6c255f1efb2f63fc5e68bb4fa04e3a78335e19eed49b7e710bcc66ac898ceffeec25e571aea2123b3272c5a9a849381f69b3c1fc873cc486514eabe3a92a664277604db73eaa135f1ccfdd7a4dc975f54d307b64458baa7cca3ef475e2460b76247aab2455c74b79ab5de5e759869a5fd0e564765d1f5fb0f9dc5a9693f1cc8931a3531332b6eeabcef7e1108a4e294ea9784997bd49b8b3692b114ac23212e893f212ffbf1846c96dd7b44e6f462b77c0c21440ccd55650c09ef61233b8a70ab60138cc5dcbae82a5fc9cbeac8fb355093c1503167457e04b5293b930ac7473e777205441c5edb25dc9ac4ecd539f9bfc5172e054341b02adf4f0612955e83b587dff0975379402abfed6373c4d47145d727f6cbd4e6431ae92548736e6c208f51cfc8d64cfb1acd1554ebd854c927f7a6593687c7ec6483af342f3c1a304af46ddcc549c24a3e8dc2f24d54571c440e1fcd04ee8dca7c5e7ecb366631384bc51e9f85a6cc244f8cef38f93e3f87a8160644154b9edd1aeac534ae9ea4051bf89e6945f5c226116fec69c3e562e21c93a030eb1dce887a662d6407fc153b54167168aad7c34c109198edae35cc9cc03085937316be14834cffee39d55af60f473aef2d7ba6dcaa58d121b73f0e20ce57d5fd053b5b9400457c06588013febdc9297f30e8869c635d7486b4a5da87461376632b7beffcb15fbcb78c9da43a0c5a3673cb6dbed4a512e88a888e6e72e4813c5c8bcf9a271501680d51df7fb867553bb25676e22b5bb00c7f7dbb544122d0d764464eeba40683bcb38c56c1cae61908e1c654fd6ff596baa6079ad3b47f831d02dc45e433c8c4a6454633023ead71eda09c84921eb73153cf6fe2d93aa0087c59714f319f1cbdbcc342382890991e1f7cbba6626c4ff1481e0154a2ade85edb5113deaa8c2563e4e6f805123577172793011bb38172dce063f9ded691cc208e3a48101a20039f74617c5be3755a7c220bae1db49bd4f609a666d620f4b4f83bfe21e620bc29d7f369ba0fd031e9ed4c2472f5cf13068bdccff8d92b043e0d71a6f2f5584d00adcca88a3ef2b10a8bed30de2d58748f4b34db12b1f944bdee57d275882d85458ed369c3fb476365bf199ad61ba0d2e506dab47a8aa5458b33bedddc02af4b7c07b425562dea616b1d5891ce77fa43be58728e8b264bccfb899875d0a4a76d1f20905bce909f50391485f7001555527d01d9826f3f91ace743285802d4a05642ad5e88d7e958c11806823d6114fec7f55055fc4f8e4d7772020bbd41371c5c57b60d3f1edf0a6efbf434e07f85ad17524b125ca6da4eaac3b480653e076c808a34d56428971d903639f0827c7bbd468b563f5ca3f764416df9f858d46036ef73d255119acbd11e031fa731d6cac7339fc01c588be619a8456db4b894be036395897eaa76c92618d7ce38f2784e7ba64bce912308c31f3f1076ffd71b27d49fb546111581a988fcb1d738c9c025806d11121936b6499f3cb4b7db8c26f69210e004c9e54e9ce2fae23db75d6edf0fa5a90cc0b3cd86a98e184b6b7fa20e27ded99cce31d7f9ad63362e69c15f4d1195bf1506de95f12d4470a47b3551573fe3fb006349c010dc071c8330ae41d11c9498d635637591a9031b3fe9bbed33526fa5ae4b0829ddf0730c1e4dd16de04e35d13dcfd780eb950a28a18bbeb6d422140243e0d5a8c65439abf04a0dbe846dbed50fed195cdf4ca94c5471b96f32f52011bd4023ba395acec43334478365103d0e17a86f0b114ba94f77629b9097337779fcabdc8d488ec811a9c267b09b088c102a53111b65c23a5ff0dea4b2b1b2f88416d6659ae2c586c6db3ff760d4a918b2c517c4e8ae64cf7999accdd81d1ae7b0e8d421d9c362614ecc2ef33f083fec9a856d0ee3e64d8427eb1a4821deea0b5109e63990f90d58b98cbe3596b1a9b6349cc84776d449a8d7fbe06df2c58383e39e1a4fb4b1e99eccf516d0b37a8eccefa749877d6fc7ee29f5cdfa46e64136af35f23bd6058677f9e58198215b6fac28d1331a485331bb8373ddf2dc61599da717903f5229a5b2d8424ed82e3c4f15ec7d8e42d60c975e81b39b72b471e78ac2c519da18a2adc19d6fe97ab5bc2bce22d3123eea512a8a3a2a251969bafdce3580d9ff7761089634d008070bc90fdb8ff12b54e1f792f7765beb75498cacaabd5d9dcf7229d5c949f3cb483ec992946be15ca32e3a8f353fadcc0eeca994f5566e21fe7639558facce7ba010ad901817a83bb0a7d30551b09baeb9c5cd4a75819ee73f9cd234f2af9ab897e06b3fb38319032651432c0cb5c049e320b968b6c3532bb429ffce36731860392fcb2f52355ad9eeaf964895c61f06c7a630b87b89f194134a8914ed681de7911f0503326b6df9a5972744e84d6c8e6830125ed12e071eb05aec927945f62e24506186709601e64d4f46ab220edd704ae21f57c9e2ac9cf2a649d5f7d1082a174cd58682d99774c25c42d45a73a3c1943c1edf424e35c755899dd9cce2684ee2e62dd781954c0b39fba1d8807ebae9ce182174b1baccfff916183cb8468d0d03d074c86296fe9db6df52cffe6c0af115793c316421b186ac76ed6a0a9c870205ef6bbb20fba20d81175d7d1dfa195a28f91c9f65c9a696e04434a3b6a9a1a47ec9019f821b598e79c44dd923830ef552f4c0392881a68c5c72645f1960fd004223b9822130b56ad4478eda8a6245de07b7efdfe6faefbbcf32fd0b931283f3e68b4949f212a46e2b7c6b900ec75aa9ff8d5cf2949a59e1a508b06bacae9acdf7f00373aeb343befa57612e53a3cb00cc637f5d2d25f332af683f13c29d471f57689f2d118c6f87c2afb0ee7f5a7abe9128f558cd62135ecbf90a2a1488d20779805654e2de7af80e79f22a8a39c20ad9ac6ccbee1173f489f95e698bcb4806e2347e32612a447423102cfad7ab45c9889a06e9dcb54008b73ad3c4c37d162cd78a56422fee6de50e26c42d19faff1cb87ec7011542487424fa7ce273ab931b6ab7f302911c2349acbb36a13e11b9362d305bc87ceb22bb0d9cc9095b0b3ec2657d455d063bc9e5e8f14f3f411e3dead5a5b50c1d2d121d920f813101af344f9a591218591f51d00348a25373d3249d97f79d56fa7289ef64510870bda1399748d0120d4ae83d331e0ee36d73e5e8e7511242153e81a743be3204d0bf3cd7c58dfe2130b9c4157ff1d4b80c5ece28203ffbe22731b9c75cb4018f241fe77f4ec07fcaa86ef6b0250a369f5e3fab97fe37127c857bb0a036d6308feeb5c98bbeb40870c17acfe46ae1fa6d0dd7e4e8d75e100d05aee50fc9ea39c4a0a239c52570c032b7b44418b5febbc95b178d5f6f812d63dc68962cdfc7fe47370c34b3225e03621e3c9d86dc9b89704cc14534f966c1eafc0f8775dac1609d2b06ba2c836b08724528656ef9392588a5357945279276a858ac494aeb0dcba0281c53f21ed75ff78970a9496879d21cffcd5fb88ad373c40869ba1ac999591aac4778e6ddc4926c6015f1da3e6a5d35cd0abdcd34a613d2a212fb9f201ef9b2f6efb5107c05e6e2da36bfc508d2436ff40c2cd75e24ea4b7d6846cd9354c85915a3f3882ca865d9ec9dba1f8d484c3085bbbe39f13d58242d0c8db7d6c663d9ac7347dfe2a718b3f53264d7605644f3b06f332132a78d2dc34ceca7b771e1ff77602739cb54bf90f223907a283476283eff71ad06845c02e898fcadc53732bd2880d3199d30623728fee72e5877990a8954288eac8415942f600f8ebea884cec14f284719542d283d723d934fc984b0bc45b5b149eb8e5336aea45c9a6b74b6bddcd1dae5354ca4ebff95aa6de2a5da45a417beaa60815c9b1a45a06536e68fd4eb0b5bbf62f8b1801ac8ab2be95df33b102e0f73496f679b56ea5eb45640d110db1bf13d6800a7a82c90d3fd1b3a8ad63ca5e704f3f95b5cc5e45bed9a0bc0077ee08214f834c4f88b900a68796dae3e6bb484cd865","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
