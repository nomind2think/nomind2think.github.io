<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f82ee30a3292dce87df0be8801fb5fde4d428e180666744bee56be68b6853c99fe77503aeeca35e759a12bd8f084178d4c544000bc75d4a1230c08f2042f78cab58f3c3fc8eacbff3a9ca85c590ec8fa3ccd296d73432884eee4249768777a8c1716ba7d0f42f02b2be5ccac73f8a1c815e6750787c2aeabceab57506a5c4fd44eb845e5ac034cbdb03e3bb7c4db51cd1399186426c432458c133baad32c6f1ee17c70a619c125828327de8ed82564c2ae1ec470fd3ba5d18b36d3aa86541412d5eb106976f1e870bcd86edf156108fc2191817a1e57bd345f5d83d841a2d627c45bbd9fffeb22a41eb8a32145c5f76b332c21f8a018680e6dd016f500541928f123db3371c35c9e4116e288abe4de69351a09b639136044ad701487d51cdbe938b8a2c2d345946fa18f60bbed0aff8c6409bdb2d012627188a08d18ab4f25c9319787198728a3d238efc8156208c0169b67abe0530ba5dda91278cda8b03eb95ff3304e4fd185f3732a95148d5053cbd4d7d4e95117b60627a5639ad185d947dae471943f2545c9d0a7af2d878b0d2ae5301d45a51ef741baba4e466e6998237fe8b9db03cc1133c19045fb592c03820075a9a69f92838f778d388eac9f208da5ef30f72fc9f71a2a0b161746b16f9417a2e7ae3f922c38fa251de09239868468d778a973f7dcd05fb0e76dad2f5c49c53e1400d32e85310f69df4739efbf6e377a97ebf5d0b61dd99e0eed87ea428130b8b96796dc8a7dea39eb91d776dcf3302122651e84e8e149971eba9381ece7a3e451f541fe287be97c76f68f732ffbfd58f7529ad1368c204830dac2cb65ca8694c6568b5beeda27f6a60c2750cf9255aecf0c6cffcb287473b9b2ba4a036324b6a63c0b77ca233d796d2aa201d02c34d66bf54bf26119dd8d20775bc4a8d2f9b0511ea0dee5455fc936ffedae3e6c971263bc8a8bd4846cdabbc6e307e4229d05b0ada31034ee42a9bfe13f1525a41eb1c84630c3ca76a469aac7489906c88d5125ea9517a10e734a52950ddb025de55145d214e286945e32d7a7fdc1b6d2483179efd0d0ff81b0f12673a4753acba32b1e700cd488651402d3bdce76de371831914a1fe5c5766badb01f8090bdfd9f23e1d0de22dfc8b9ac57713d472d5f77c3843b4f384c248dfb37f4b9a872c10193f76f740278d0fe5a9c206ced8d5df44914e2f14bd0779fbc284ef5933f54fd2a06473d14c16dcb26a2c8671a2a3fa841780b77e8295dd1532efae9003536653f0694f4ac9f1cfb6f591283eabddb377f6df0932cef84d128e08356d260723bf5a01c11ded7e2864c1f39724afc7b789ba2757803423701bc29a2671f24b68d8dd41a58da33fabcf69af857d2dd04460b4496d4c43cc3f1372f3109ff0cded1adfcd3f7cbffda05622ef5f4628c49b646a4ac53ad6fdff315b08b6ad758bb342ffe0d566392b55e765ac4d784d00e6561414a2d8e94b99f19ba0c8bd89501e89bcf3647f5f4e351cfd5b7940c99b89051f933efbcebe0c0d8dabbf1f9c867f1f4e5639248af3caac0f7a03ee2d284582c9d167a6de67ce44cd5799b3d461ed0b7522c156d5b6d936eb2ec125b01b89b38d267107e50b2bc0edfc9d445950c415baa6ffa1b88565ee58c10dfb4b2b9f18c5d48d91f779bbdc2a63719e9ad7e6f716b2364c46b5c21695d346b724d883b30bbc7881aceded0d6253e83bf7b7c51e287d14b9517f31b9db36ae9c2e976ed7c3a0b3be7f3f667e715fc8b8ad7eede194341307992e69ef0769c9d6fc715b5ff6c082f5553a86fdc1c0d6e777945b03f1bd21a36cf13b4ca048d85f16be8167080109f2d004e09a05ca11ba9759281aa06af26e43848a013e5028948cff1d343a1ced8c21ce924d7054cbdb0ca0f8e4f8bb844424877bfe48d701fa330367181c34ce059235464d05437058a1c844649760c7b10f31f545a535d3debe5c0a07bcbe7e2030cebff2e521bc8989fba3f1d0fbc0785c1c6c9ed20c6ce4985712ac40dc6c2f235c3b1a159ec48390a12c934ecae6bc123fedc8e8bf8b298ea25c2d53f4e2c3bccf0fb4719cd0889c357d2207b76c86a806a781e0defda64e409cb242a92cc46ec246c175d4bc97b759e1d8e8ebf4db0d9f98fe481d4267ef0165bd64982db9d4b1cf331d7df08fcf445d65012837af4b53c082571a03f6de9eece513b12460c3924844e7bf916b0f75927f26669a277be23df184ca636162dfc68b09463169f82a9e8f554d7bdf3bf1a9d83fbdb4210e8188bbd63ef34a0239d263046c4d728f0a201895efbc144145467ee6a889c5d43bb58c450f06d053bdaec846d66b10cd1cb1b4cd45799e858c3f7b7aa9237e665dac07ab0a50478575f1853e5a9b878e0463403e5812d0766c1b2de260ae08f6b04fa12318a211b211621a77ae7f2d07bae308a3f9621a6f6684959b8d728aec62131beac28eb305215196041b92cf3a19ab56783a1f076a75e0e70794682cd7a425a01bb59262e989d0ea9723fe17a434cc01f2ec824fe07489e75926dbf246bf1a42f4e25a05421f0ba2469eb6620546ff086281ef8d692d8756ba0b70acc430acc8f24f3582b12136b73562c5ee3ca1584bd7f3a79c45ad066c50aaaaa6f3fb449a6753eec1b24e5ba2e47c2115ea334cba891b574aae589ceef8b9f9037f71c77f878b275fa1d84b592fb80b77705ae65fcab5e3b80624a836a9f4d7078b28cfe37354c6a7a5cc77212cb99e4829dd619dcc45705864ac7db7b8c24be28bea3ef02dc2828020184df3295e842aeedd6aeecc8d2fc0d6f1d1babd54e69e64619ef07d26d2c30c905d630be4810b6c8f27b195fc01d185d6e1f27096db8779af1a7b384b0440b161ae1e43d1da8bf69efe61a7a005272e6f3edc3b7badddc6712f3ba8700ad9cf872c57be70e76b9f712e0d2aa63d86f507dfc12c258d46ed432c4fbebd6a0b1cec8129e1c999204c1732c046e5fd14c8f33305ddf21a843e2110a1a712366fa17320e3fc32271a76e04e8b51f8a60428880a9fe77b5ee09d2219507ae59e76b14ef9cb0d4091f07bcce87685370fbd06779e1747e795cf5c751b7f0239555ccedcf56d27a4eb5bf269e9e7da99bc5516b3dda6d9b875d175a0ad1b6d919342a5d1c34ebc9eee9475d6b65e65bbfdd40ba26fbe742855bab93c96bbf87661c6072fe573333a002baf564cc8f1a7f498baba0e8cedfa66c8a84a4f7dc959c73f0bdc3727db8f9c9d4bea7aa2627f1233f90f68e0dcb0d6551e9b058130e8ecb32d3890b799553a6e05879ceb76984cd2bcc845874d8aab99d381bc1d7305acbebc82a42d315e96305c814ad924e12cf2cbd4bc574fada55efe047e482c6d7a9de5a3c54c222871a1217d184ea4b377dc10f80acb9574f9eb37ea420a3467a2eba30bb0682a262596cec28308b74a20d0a0c1899903f2e8c8a3a3e8eb90166ead515e242ecd9c95b37a18a76a9c31720961d803c6b98f79af1e5209956517c5f5c13a89ef25c0c7af3efb9f312709195d4f4029405430563512e13e81342282983c7a8e13620dcdb1040b2ace00eaedb8d40dc8516be2a51cb6232e7e19f799a1bf6f45597951d7a78c6765aa74974b98a4b39f6703870c372b80823ad9c2fa4b60f017259bf0bb742dcdcd944f9081d29f5c5bdeff17da43cbf7fa0f1c40296da06c8824ac442d370d53695978004e25595220f4691b02e993950eaeb75dc073a91849f0feee994dfff18ff641674653053da25b8a51f95a76b8380d419cfa24615f3a4925ffb019f18d696eded96dfa0b2564e8c20249c6fc55e7348dc61599949a4c8ecdb396d6ea0b1c5642e006a9b3062dbb4752241ae988bc7b1798a0b0c0ff0bed878fc1b5faae9575c4ef17f4890271e0b1833e576ef4197a487f38829bf03ce768295b2f83b16589ff959b1234c640e7b162c96d6a5e82cdae7c0c01a98495dafc17ef7b22491b47150d19baa692750d6c9408c1ee55f3d008417846da98e3f27271a23e210a7f608f012d13d53e8e33f3101b0e245570e36de5e1fb2ce5959894374952b49e1e26d6f9d0e5dccdf9951270f83363ccca8e30962bfca1cfdae7af84a6e4f11cc4753b4f0522b57e178d4e316a99e4141e05c2a1e2da6134f5d942a7e2a131b779bc669f646df068b0aa62e576aa71d88b6c5712d18f85b557427bdf616cfba76ac122315ed53f08ebc92b696e0a3b913dedf35d2ba8377c610e9db7f1926227d990dc8e283f51552d4af0e0564732e520251ef08958851ac439365ef4b733578f545e947d9c8a8a690e86ad8d8add84ebd928fc2427496c1b6f9c0dc9f5766a967bda35725393cbefddeff0aa3611ecd528ea9f2c2194de4a02bf53c68fa3c8191abff9820b223ebbdf30ad0dfb6f946ad24cb24512b8e3817bcc12a70241c40ab6e428db4d99e30fcce002e0ec4a8ffe85a82e5efff8f8a52a0c5e92109771a31aae831e540aaecfed1cf264cf9995ac789745daa20200507d1a9bdca17822793d254ec12e3672309e84016986fe8d88590c176ba88198a9021b2b188d46d68ddd33dfc6df9f0314fca9e163a232f561790b8a161fd15563bd885808e0610d61fc946f6ea31a3604dd4f49d4e9937eeaa36af3a50522ef6159ec59ade55789668325e29d5efc8b0716f2a62339b13e28a82a9a0659e6cbd065951967a59dfc405db0a3594b1ab93b1087d714f077e699023c931a724a78e389bd2962667e4a6cbf87396ab67cc7ff9907fc67435f3a8bb6f0671d8d1e2ae1c1770aed847d3066647e5cf2990bfeb37a76a0392b71467848f3495828e1086ad1d620f22b7da2193bb31148276938b6dc726ad4f7ed9feddfeabc44badde7dd64df33458a09669ab0caec5aa662abce42460ebdc14c759babc3a404ffc3a2a4f77f84953c013f02e18f12b312ea74bb53dd9d8eca638c55d1e33b517e4db39f2fbf6e5554b1c69bdf64b2b74b27c0f730b3e539679e469b1b39d376bc8253cdf3eb12dbfdb4682ece4855c4aa082c44b633160f1d53bf99b2a53b5f62370c30d02f69789a4dd151e24f0513b95d065ab575072a9982234d3fe3201641a0f971da48edbdda71113cbd9624851e410d32a0b7dba16efbca7646075a46cc11a682028fa850c28bedd6938b367230d6cd726c515808485a836e546fbac79506f2f28a7e3b5125b53086653a52707e7b9926514008663054595117e2dba6a5017695bfbba99560a06daf74115830fc6c8e3833d4eb26e3276b757102e5a2a23ae4d9e409b31938888bc97608f9b71bc33c1d2cf1fc1e96230b8a1b28aeb04ba00a6aa20c3b85792ba8f7a44da813d121aec09ba62b0445b869f58f5fb3f233c28560a8224798422b919bec3edd9d9ff9f5208ed9bc0176eb2c938ca83438188a5b56ed31aadef1787aa62a5247106e64904d83b581431bbf0e35df7d1de4232819055f63244a13a2c0b4644953b53353235c31902fca99a0a4215e5007e628dc8ecd42f40d1b6d700995725afe62577fcdac1c035bf333aeab29c584b67a3be795912d50b10f26b0ec51e20f4a0982331d649b5b4b3dfc6d2f1cc726c0a9c43729fe004b4d8ab3914cc897d396f819bf89acca6b67032be563188f558bce7e47b628bc42afaee82f0a241211e95f96f27f6d5b0939b95611c08517c6607f64710d396ce3ac2c45ccc5f184ab0879816ebfa16c7ffa1baf13a6561ca880f10195ac83410bee7ee337802626854603bcd7ca18c2920bb365387ebe03e8ea0d4d44bbf9db9b2e9c528706a3f3fa9dafbb1e61113976e2b553d38f07f8d3681d2048098cd928014de6618d0ffc942913c45bfaa6210202bf74603257223249518906f91553452977baf59000c22546ae2bc837d21bacb04eee9db5efdd4cbd26fdfa30d7dfd3dfa0d80affd37e060b2110101377ace1adffd18d79d70add584196d6d5923fe56ff5029c7124226df1e8d491f28284afb6b2e2d7c21e2325320807084e71e40749274150522ee3addc21c1d14ca17792c4cb11731a6e6d86d8c17baeedbcb8865db5970cefa883b0d42bb8d9445784178bbc1e82d6f28981ddf5261789d6dee8d0341ff52ad5fa0b8de6b948ac33c6d839be8ce7c5047ec4092d4d85f4f064611a3e82b4d2ee891ec9ce9a4487a7b8a1e2956f4d00b3a4d1f7b6f1f3aaf283ff657d74b5f7b51c8d54d254903a139528a8822ca26a85dc9e93ace5a7d430cb00e14a7c122ffc43d1c9297f106d0a89f990bf449d44241e1f59bae5f0eecbfe45a492f8e89100368a77d750868fde5b7836d60796db10163a7ddf787dc188ea7124eaccb138a2c5c6ca2e4637f35f06ad4a8169c35f1d06bfab824b468c0e92df489a89c97e1fc867ac77f0b98b43d33e93f36df72e54c57a4e3490b773c2b863a9d09372ce59ef207b8d37fd3fbaabff4e7865d390848720fc9ecfb8edc56faa0b78ecac0414d0c029298aea10b8972819128820e2e53f9d714c5ab2509881957fcf4d7c5d5842e39f8438dbddf9861bc292ab165c6de2c669ba1320093aa469c9c40df3dbce16dae36fd6106b57140d83f8b7ff488ab70eb261647d274b08fdb52919bb32553e8792b0edcea1ac92b9585de69b75f7d698b8419d02da3a6cb5b6f11ff963647e7aa25cbc99516c3cc42170af1b01600b80998c4186bf0efb43b0060481e01860060fc5f7762af3478727b897e5f38f1a3eed1cdc852c56141351562d7e565d46f034366bd1a3eda05e45aa24ae9ab33adb08be81ac72b164f3375b22308a4860030ecae3c86ee8091ffc29614066dbc4fe3a2dc379ae6285ec117f48a4d52709c4caf9981771e6d3450576c524612eb006fa84063f2cdca1a53cd808d62779b6d617f8b8c239670c801a85e8d46bddf4cce63f2a5f407a8ac31f9421c36c6dc99f95eff6d7b3441c53ab146803b28cd68d296ffd749b2745f864fd83823bfac21c1a0e5354b06c6842e8689025285b629c635ad8825a5deb600ac14bd8a399a6be81869c5bd82eedfb485f025ae504e627d116c381f7f663b96e3f8eb8d190ba5bfd0a51a20bfe209812aa0ff648ac0ddc919388e9ab10acf6f2061f4ec838803cd71ed171b6fd6dd0bae5bce4844cf2f2a427f11b80141053a4287c8f06f084b89dfae81500ab0d8868548fcba37261be356675038ca02a243c06407379ef467aa32bfba8fe8ba3bdd247975fcc073e241e987eac08017eeb36aad9512fc220f433ffc304966c7ff67e60fc1d7ae65d6f788b79e66c805bf664e51b37f12b8452e8cc3c326c7cab3e186123617dc38f828d1a08adbe830b0ba5b81d7c79be162c19c686964790811b4b2b9f1736031ba1ad3737497c648b3920996a84ed63f674d8aa68ab95bee13072c2074964a94183a2723cf46b12a0fcc3d28faad6935d5d2ba782fff614a6688ca01bfdab57179f3427f83e855e781cbf8c473ef760aeccd13977295cea4ff17653d5786aacab59e655e6e445fa92249874950923309a18c2a7112f66dd691e92941f01a99250407bcc7612cca3f56394622e67fb5d0d4bde41dbf6e52cbd0c397e40b365b1a7ac4961a4371ee0b5d47e7bf532f625854c6a0b30a73c63be3353db35d7803f4b85eb34714cccbb521ff6850cf0f469f7b0d4ea01f0d6e790132dbcb00e8429ea8162504b688902883cb15044b8f68b8948d69fbe3f8630fbb6e80f3365e6cc0ffd8bdee7db292a25ff7e3ce72b3b841f6706325603b2d1ab8f38d45de178f454c9147019d5e40cf3bde39f2e3eea94e4f49a1af7503ddfe1c1f018920b1f814d359315520c90af7cffc12ac5897569842a268f666b54ae625d2d4d50ea9ac852309a345c036ab0023ed96b034e009680769256824b4fcd766959b28bb705df8e6bf7ce8002a9f4394dfe1b6c3671490c46ee66285078de40c30caa8b0c7c8e2fe9832a9deafb95e51a5fb9d0d2046dcbc7eaeb844c2e3f6a45e4dcbfe405206aff0d9f9453a2314bfcc32941f1b1db8af304401ecf6ed58f8f539ca0e384d2fd639dafeb2c2e0f9e7924dda7926fc04d122b50365d21ed0ab15985da1a5539894f4fdcf6803128e88426dc7bd2f40c110518d938cf4c5e44d31163feba2f0eddc27fb8a9ced8cf122a392237b6a02a5c4b3c71bb4b9a9e49c8ad58d34841acd6fd38a2e600cf7f1b1fdd2617b955c455edc65584cb308efad67e14ee25f3884772762de2cff1889a2450d6ce07e243da15ea92afb548ca13dffdb7cc6f1b1e0c3d72f4a42f13a58151f676cf24eb88103fa58decc8b09b0c4f58fe171e1ada19a2c82799323a4246fbfb5c9e705cc803226c2f8d7efbb1b496576d47fb1552bb316a5ec6b1a2588c70cfcca8ac63072dd01c5fa5d2a2724bda3cac7c733fccc92dc51358528adbbfc18d2657ec343cd44613b9d0827523a0dd805193e6c997c7e9ee0ec5b933129f77c9ccaa52812f16af0d9f066450570d1af712af5c10696f07c3c3c0800bb03938f11a7fd97f8d899514d52b8bb2e95fe060558582eb98997f919953120b64c4a4d085e00aa46d0730a86398d607a4d423e1565262a929148e73d0227e913b87176dd4b39b915091a41ca811f938bd9dd1f3e8507a76c2b14f9b3f8f5555f4a2c98b2cf81ed4193de5b5048d37400873a3d0c72afb67f32c3d8241e31dd3575721ba9cdbde6908812974192564878e5e2c212f4b5665dd2b39bf6b51677695300f47397178e0e4a563d9394d02191963ec5c3473433765c54ed062495850125161f5f32ad467ccc20e0a04451ea07a324275e59826486f67f4e164a21acbcff83ab6b954025b8844cabf9859e374420465d8feac6cc0d2613a549ce185923ebd0b166c7924b35bf699f745617cfc97919aa5245ebeb9da3ad0c31dc239a43fd3f6586b9297a9dc1723ffcc354c3ba90cacef3cc213abe20fdeeb831f38f3d099b01a328b61ba0b4a05528d7b8de838b432ec824ff38e7e38e4e74d9099787dca464b050e17d4bc9cf1a2914f09bfd57c4d67ecf58997061013f61ae27111fd876cc8e7182308cdd0a2b3ce7dd4743829fdd8a1706b1d41b79a380c2c335d11f564f494b4747c8925fb314a17339993f7252e47c27d962702e34ff0a1ca49ed59f663a1ecdf57323a3c42d4cc2ce9d93b7350efd620f4dc5b149b10288da1b1c2782117e38d2b2b48e6ec8c9345069c1731273edceb7c88e2317598f313582a077e395fc6f38cdddfd28d6d5ba60afb7088a663652d4df43ff2559bb16b5d84abcaf8d97a64bcfc6003a3679591d6cde46ee41b7725108b472198bc8fcc080fd3c0277350d19b7c706e5d7120cdd70acae2079450e6fd83c5b78090df642e63b28d2d812cdfc7ad040728563795506098ecc6f595d192fded068a077f9e0600178cd3a4903ebf0cf6be4d13a10bf08aead26e6061a72ec55522cc55d8381a0b9cb1c2247426417976ca86bc4b005d3b2512e1d37ecc83d254e36885b923f9302281d18a0031c6fd565656fe9b4d79bc49c7531753b1bc8eaefd510ae44e0a5bc14aa4e7b06d5fda8a4fc61ce4723d42eaff5ee43f3fa4d75c754ff13ebc81edfa8249c8719c04c2afc9f1840e0225f27b50d11f0b739d4c6a9795314766d1a7ede9678f4706c86587a64a0ee9cf8fca86ab1717d82e3191f454b2243743907aabec08cf5adefa3d31c80baf56bface355c58dd72d545e3d9817813022d3f44296bd5d1efeeb32a91d373eccea2480665deaae28c7f312d0f2adcbeb7d8311f6323bcd778404215ebdc9dc313af5ce1e24efe4d7d91a204f8d0a9179ab570f5812c54679bba60f2d729e7dba447327f6b4529541b8804974d21404a106d986f40fa33f1bc86c9ea16dcd83cf79b88be041e960bf31f876ab2aeda731ce2be580c8b5782bf8d06a2a60fc98cdcffeb389cb075be2b08ad222f075e1f679741180030bf865e23a68bdb934f4bb472ecaab3b06d990d7aa29ede0599ff7c090cfb393330edf590a815ea44ad3be776a76a61d8c509b9e6809c7501fd655016f5e25c0e252977d3de08cab1c018083a741dc9abc5ec517eb4b586a9b400284bd7524d571108382aa5986e4fbba34a014cc49997b1e4b195a8e71bdfcf8516b46030568506d155582bef7afe3a5fe6cae16035bf2739a031f60ba41ea6f3416f951acb45b008a4ab35378b998d052001b518edd3d2f9e77a4bb9444ec9dd518f27f36adb1b11fd70fa4cff1b7dabaa2b37ce76c430e6906706d3399960dba5c678fb40df93a4be914fbdefcb124825976c885bc2df164a234039131dee73009ced19f293589e5982a98653b5103a5eb5224b098ca8f0388eb50d18842b469b5f576ae483eb00cb0b7fd5f44cc645b58f33ef94ac6381da8644493f440855e1d06d43f309df55c4332f35b8ad4a6530d4194e70b3b3aef76d9f213d0e270b7299a8062a6fa492840858a621f153de09d30b26d27571ac0705fecb4782e1be7681c0ef66681d2e3d2db6543142c2cfb3b049940cb6055aa4753a1870d2ceef6931955f6bad6cafa3caeafeccf2d3fff0f9c923176be18170c4bfb7ebb217d7706cb7788a4bc2aff3c878de738033270033c6f8e1ca1c919403af2156c496f2ef2cb06561aa09acbb3e8bbf787f70a36be8303dc952accf22d08195075ecb731a990f9f925d4372019614c89fe8c2fa8c5f05dd8720b4288f1d90c3e965bbe47ba9e6062739c2f216aec399d316e4a976eb0323d748ab26c1df815dab5904759601e4845c85b00a11b59ff512e41808470ec148dcdf3c78df3e4af6252361e1375337ab545438d83f01a6040db786d05de9fe2e5f2bc0e760fcfba47ef54e447911bb26f7e561e93a6b1dbadcbf034ab6da67e6296043b3e03cb049610a78fd0ccf7987b6d5eb33bdd302a902ec5e52c5a3d30c0b242eff0db94299c29aec9e5f63a1781abcf4b9c4ae275580225ad33ba62575c6344b198753d2a6f4499a94f31a14bbee90c1088a17da942d0ced7f355f4432a395d44f18d9d5174b86bab0b8fb335e9152c338a2f875d0dd8558e4ff3da91e975c3e56856a6e53fe113d3a6fa11f447f5be47d1ecee7c60c501de6b7a52c4f5f5544b1e4e31e3110c7ca934042ad4e20983dfd0f62bdb3e45b54c53be688bc3bc58b3d94701296b0419a75054bbd807925e89acf052d7ab4c608fa07169ee9eaa5817fbc2a36bce685048df7adc35e3af92370145e0ae307e9068af971322a2df2fd7b8fefcceed8b720180b9b1b2526b3bc92be93637d289500570e6a7c7d0e0b81760ef6e7199aa4e2258aef9091319fd3eb32f048a1bc74a5897cd3eb399cf7dc8148f76a465fa270aa236385d3e1b4d057fc64d864b624747ff4f228b443c9816e5b02ec44d7724859d4ac79afe00ad56ff466b901be9663a1fc842961de34f054b3fa203fc8f72f8d518cd2f286aa3ad53dd4879b9a9cf482c278d0ba058b420be8f2395d8e2d46775cd9846ae5076436f4cbeeeb9ad6c2b0179d66a17a753846d4beac1aa1cb2a6c09429b27b3ffb63429cd40b767296a7f2a5a6e281bcefe5af475f0778ffbd784462886ca4ce716f4511c41c0f160981d89fcfc093586223d13a51f4c276fd92cded6b27809c743318b877dabb6f5281cfc8873327c6d41fced9b2afa19e2a0198acd61b6a021df7729e24d4dd06163d4aa62662798743040ba79c0f4b49439da5f3d2878b70eb6989f83c34a93886878275a54dc45d0858164c6609695b71f32667b89666f29f85393b4c9b250e06ad4e7d736cbaa383716ad20967fb8e188d69c47c2861029ca5b3b1db46c2fa3072b3b7d3bc281ee63ad9b4fc23b569399d03cfc0278dea88a88bf1a2f876be26174f82eabcbb4afd913c38d2895274499eec373f0a5760681322510cbe9174b992c793972678a410d98ec7998683ec8fc63241384ac82d19e453eeaec378f75e68f7f185659265f13a5ff67455658817a62426d59c5d5c2286debb68c60e366e9bcbb9c029636a6605c73cd136915b73fa78ad13fed91e1708444758bf8ac279299373c6f405c207fc69b9b53b4705a9063384521b25e5e5118fe1c14e56f70686b1f7c6e128fda2a27c67846af221532d55d85f73cc37c82c1d17d6273443ebcff0c35a6d5264af7eb06f549deb392396a7158c781ba6a24a11186ccf6271c64ce67bbda0f000168f18f6ffc9be36d76cb0b8135b5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
