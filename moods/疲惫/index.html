<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95d0b9cb8fc619fb4a90c57301c646041d159a31c026f24573242b50520474f763c004994427011a7c1d0c95c1b674c7f2322c4edc487aef8572df98bb211aedc8cd981d70154658bc016c9ff6af7c1c64f883be315270277a9137bb87e812ad201baad3247bd173cc5c6d04767f0e693580d1574f5216fcfbad01fcee6f127dcaabab0fb3abc73c4b0ecb57ac7fb74080285bbb484f214b7da963e5eff8636613685a179937190116a433a5cf16d65d59346d7a717d97c6448b8dc0c48867e51aa8003e71b574e6e56f093e28b3785021beb6577b412c23339fffe40964f7968c57907cbcab86bdc0b47a8e270746f8e5d370d262990ba7b22e361be9b55f58aff82cf5449da4246fc82bf163f793a8e235485009701e58ec48edc1869c685ccf1780dac0c13defb70d8b6e22554d9dd1e95039b59926840bc95df8a396049cdfc3010c2676f76d5788a93b9d97747ff0188c2c9d47aff6f3f68638a5923627f48b30b2a7582eaed58a8776d639f6686ef48e00ea5dc967a5b9340c855e28b801b78626fd786d8cb061b57c13905b433485bc209c511c15e6d6dc541e0ad61c38fa9cf4d78199c5abd24a6a72e385c9e6ebf708c4c676d95d8b7c8387db1f442c30ed3da7ef83e6bc6d7345392e07942e5ba4285830672d2a7e7e0467234bee2d220621cfde9cb43e663dd6adc419de9d76d4d856315af3da0374aa0654aee8844c5294d74a23e5830b1be17343fd900c579049ac0c65d7fc6fcb813df40f39ceb70af83dd4c7b627da3f2c85a4457c59a3ac3ce8bd1745ce1c11c6f82ee6f4e802a60f52bb372a153e207efa788e07df4f3a6f41f33bccea9423537545a60dde9f3d643f90e7a0c7975172f4e989b63dff99cab12cf54c10636318ace11f367ba39e960466bcb101186bc9329d219cf06bf4481f8eef6ed838374362852810660b8be8fc41e86229c979d6432019a44596c922fc8a012039d6cfd7026560455dfcc1eda04349d7ab53e3550517d73e2742e5c66617eb9a7345cfe6fc2821ac629326891820d9370f4d8378387bb6136b242d34a4a7ee3751c8d6fbbe89c8d7926d2ecd02155d024156e56acfc27566ee5d21c844ee922e1506d74b2d67126c422926b7279a71413f15df81bb190e1e344a751aa7d418366d72927f8ce6e908e40d87aaa82177c65f2cce548a0f9eaa5c01d350d8a6a995ecffb02c34fed7c307d37228acdb5f1a9bed888b945d876ac293e002158d4330270bb5b0933e3ba7e1e4f5a7a081c24ca808f81c4a5fca22e2774f6a68b50e60ad9d1f9e72bcc61f07feb695856efc5341d71e878379a7afb31a21d81082280970901e8788cf96935b268b8a6474e14de4a91a5a342d0b20180c476b0933c5bda26e17f0aa37b1c29c43ec0e4c5323302fa87b23a303456b8a55312eb70a5e0e4260446bfce0ac2bfb8e1aeceabdf46d01ca03046d9c9f83e0ea94423b8a9e83520225e2c3b0acda01b0351639cc8d838f6e4a45d9511d676d0cbf6dec17759cfe2ab7a5449647957cd2babb7176d51f74958ad245f266e26c6fd0992bcdfba81e8f1fb01ee89b7d49f55b98750ea9b8a8b72e83318cd9bf0e415a257efa332f31aa970b89feb6236ea6c221586797ad9e30d45971a9672c1418bfc0bdcff747acf997d1becc2b27943cccab8fc403622137d1a5703c96fe777f2a03389c00d45a7636a80dd1a467ce8e5f858e69d92b0f8b49e16d2f211ed1968a791d00bee950a213a0fd589abe4f2e75776e21cd94c0f05061bb5ac2c7915f49460c25f50153a25d98d46478809e4ceeb895879aa182b4bf221d802a00dbb82a361c5b67b24dafb8c2c910b7328df69d896ddf75f575be42dbf8b8e663a1b531da962e89ab1e03dde2bc2ef0bb7ea88a9744a6a996c946f16255a6c1df94377d82334ae757cf505783c87c6f75129620dcb173cd0172ebe9fd9fe79c69356628bbf8f4b24eca0250028614d28172b37398ea380e12c89e319d450b1e4101821061947f15a1c59dc068d1ef4eaf3c93b761389bdb2e72f57c13e942211b65c9cd44897b2c7bd7e4a78e1bd2545c1100065eff520cac70c6d7f82d3647763d73b47041af3c44f71d33643bb3f251b5edd8fef2feebd5865e3a30576ddbd2e57531e0bcd3d48e68db705acf133a222618e4c2ac3b14d957bbf8411219a5844572ce37edc03595a3278b260568c1c18819b5b78415c890607670e40a140800d0a63b8e02d0b6709e7c7df06e46368eff9514ff03e28a3061eaf5545c61f52895467dcb5a0961ed1b5c963978a8fe3c365371f6f590da050330cfc2470215e8e0bb9f14f4cabc054566d402b38fa1fea2a9b7fd9535e8a4e5880124d5278802a19a106705702ef2e1253d715f8f6cb1c1a0f7338dbd1ab3d4a9508bc98a312f38d2c17f437da639a19a86180fc30b61921a18ed14da1bb0ed61fc09cdd851429addc404d29209c1bd1855ecaf32adf63ad5b00a2897b35ed6e4593e7ed09ebdbc8cfa8ef7f0b734ecc868309d862769561276a02a53b1f35f0c4fa35db2b8c495ba34d40eee260c217e9de703c068732a43e703c3d9ab52933373792291b67e346c1ec40fb27befc51066a86341cbefdf77c3c96f2424ec5855789992b002d836d5f79873112084caa32b7699c596737bb312312599b7ed4f4ec6c9d5333d3e3c01d70798be8dda1096e660c9c4af910ac086b0d4645330178629d7c1d9244947da4ee9eb16b07300a75252e41d7c6e25ea0cdce384b2be49cc97873bf19de60cfcbb233cb5df747bd30957f7a6e8d7c855b337275b2e533ecf3d2bee07b2c9a24ea7cef3bb217a7364d0758198fc421499ccab42a1ec409296354146a56efabbebbaad15ab3bdc7efc261e79707ca13d8958dcfc9c346468e2e5e49bae0e34db8b0a6a40a56b77023d24c2ece3f34e15363a1aa4342c437256c53af2d2e71f31e4ab9c9b892742a84fe5c375575be7763e2b55b07c82764cb695a74592f3a911d99d87fdb0c6b9bc973097bdf79609cbecb1e8b39f961cdba1c606f723ac0efea3bc7a5d922134d5054625b48999c918fde5bf40698cb5461c08998831d136f5e777e53ee09ebd6717cca34134396d019817a1162849c94d4330bb08995ed1324ea995334caa813ce186e69aa60f37db0a2a54dcedcfc66522e8ccc57aef419d52cada3435fc7f4c4032d91e7ce38ee6e15e2ca8f4e517a54968c3800e9d3c7bff07ae1ed6e3ce3307d248064139bbffdc548dda862593e91f8dab5259b28b43cccc9eeb976adecf4b9acbf63ed6fd19de18590058ff35a4f29d5ab89b48f5dcfa0f5c3826a9e45b551333e1f62e8b423fc0eb29ab121eae09d0db5e2cd9324b45820b32c600ca45b1e7782a54ad86232692d776c5c9272312d15d97758b33dc581ba2653d4a966f2c5636d11a4df7eb1282863d95ad60ba4a3ae59e477a352107b97f2928eb3f4f7d10860e60a4b41916f751c62aee571553299930cc0add3c791d923677a1c8bd3bfbd329e2b5806ad05c87c7ab57717d17375ddfe8b87e2604949207d8cacaa9c56b8afe39d5584ef55309cd6e7d5116247452949d62ebcef94abab92cefbca2afa03dda51ee352794522ab1cf7b29379c7bb2ee92b1d6d30da49ca7d1027d8f58388414da1b7d0f16628e11e8f18164aedd189d8f347a97679181cddb5b5ddf6135997a25a914ede49135a95b3db9571973b95a8ab68f9b6b0842f3eb79bd33e830b7a0d22db29826408c2934069c96d70335284dc7e593601087985827d7a1dcb9a36b301da561cafd0de138afa214c225fed3d95e5638facdbd5f1b64289faf79c727e2aa2b8798f1feb7c5f799960759527bf34fa074fb7bba74607825551f8ea6c770f0956e310c56b6160fca5e74e2afc6e8c7bc1f6bed09cdd18e669c4edfc327d9ab2872ea6f6f070578cae17606d5b0c72caceb0d104408e8d0988e5eaff2be6db8310f9d27cf67656e041b11f743105144732733d84d1a97e3f8ca94cc1eb797c6cbff65a89a394517245729a2b5169a3b8164213034dd593907f70426e7048660b95b65176c5997d36a8d13ded2d88b615df89ee1bc63c6036c364cb1d6f139dad870a9e363196b06e23aee9782d08a1e9ddda7b594873b176e5686606bb3a8f7cb7aeefde5e81e3517c85d76c9370a180266c2cb01c0d5d7d359db6da8aa2325089cdc52d63fba28d4961ad05ffda31b9136093e0d4a2cad03eb90b35885ba09e2eb4175cababf44b5627b32667842285aace13f38047c8c9b4c832d9c5b6d6f7a6ac94d06b25f4236f3ed8fcc74c03d1ed7884de324afe14daea742d9a80339feb9c213b4065d6788e2738a5b9467931ada3d929dc3f7dc86e0a8d8b27062710a9d9103801a0f2a85ae46d9cb3ae5a1513b37db253b187cb2738ed510cef1a11c555303a512649a6581368e5fbdde4aeb94fb4317a5f5e3173c41b0f114407476eef5f5604805b432e604462ce703859da534bba34ace1546dc8ebde20373161aa34eaf784285e360b4ae47f25075d8ce0a5919469bb13f3fdfbb919b4e9888abc5d32b6da011cbd66e463bc3be623a2d036686e9154aff2ed4cda5ada1c13f496aaacba793ddf0a67ca94923384a54cd77eb1b0ca0c45d04da56c19fd784887217fd6bd4532879cbc36a78e82706063ba745baac52f25f41035fe4585f929089652c22737bce1b427534c6357c7bbec6baba96bd851baef1af0b192b5d4024169f1c8b5bf8d4ef7bb3daab34bd94d56d6683b69aa2a92d78bcee746070f993a6720ca5b6b90cff123b0ecaaa139edb25cf22fe8c998c6b73d3d46646841c765e59418fdf24a9db5fa8837ec1d91cdbe9d53cb697151b7f90ae16f2dd0f11401f799a3a4bf61fd652b93f82773cee4710d45d0f7e4746a5f9e01ca61e6c307b2f3c98a5d40c059caf325a4aca102cf1c8f78d7873607f0c00e3e52cab14cd2c411cffdf5b5fb0e4980dd8fcdd3c7afb8153246918ad95bee7e8cdc2971d191a273cad1ae0c286cd540fc154fdae59f704577851215defcc9d944e49aa76bcde2a8214c70a7154d9341591bc567725784f23c81d067d47e4aa4a514b7ee92915d19563bd698fcda35f09ec221b381a27eb5dff30a0363b014b954213811e5052ae9350bed34c65b784a1729de3d384963bfa2a0f11877d54350f200340688cbdbc2c4a0af853ee508c83c166748f3ab96bb03a9010023bf7b7436e701cb8308f94aff20b15e14ff6c556f97458ac85972351db91ec866c435fc24bf0d285f0db84bae0ad203da03232ecd4927863f4f8cb06c79a8d0c59c880dc7891040b4fb4ac8de3c9ed0b586c74af47379d4a7de4ea185ba0fe6f3bb85bb76c92f97d8db046a8414925974116d6b22632d6494c7ad3d84fa2643452268535ee379eaad9be6b3486fc9d8f6e1a12d22b4844c8ddcb1655488593dc992c6d301d484dcfc518b7aafe9d9e77d6e6879e42ac2aa7722eb217cd30c8d0940e9236703cfe385b73916ec1c132e824d202e6c5d4ec7ff73258f48c34b09c402981fc14a0abc60023fb5ac1e348389dab5cebe3f1a31840d5165d84f33a01883ca08c2fc73ebb99a4e005a7581b2a40d6bbf6b85eea0b54f8c773a7267e08694c05cfad5c179de9ad771700c989331e2b982cf00fcdef9335a77b3165fdf7d1e40a71724a2ce62dbeb9d6fecae4cfab9e7a7b253b00d90b5afbf3bd32cb132b80aaa7d416121396a65d9148c58ab1008dd4a1d5e43ef45e52e24e3ed61cafa53766cf61a5147688fc589423e74d41a4706910f22b4377e7dc13b933120204a55bf50a6d82b1d5f3d9465b62e08520439cf553c0801d5eced703289f5993e4c9ec32e6094e6720cdda67caaa2c1fa90efe8464db5dd781d78334edf570bafb6b19759c12e97bc1143bfa765e10d93e7a08c1a66fd969095b16e15c142f6e9d5ef55fbbe0de7f0881895410bc85f782fadb65f883333ae90678099e2f38ee9864966894ff2c1d65cf9ce168e26b2b223f52587cb94af37318f3872211522a4ab7e21d85b464e93ef44f07aed3cd1085425142355d32c30fc4686ea921de5023fd909ebd2e66d8d7f9eae7042794d560eb42589c227193bb2481062961ba36f714bfb5ca090e952ece45e5ea69e3d74400b163bcbf91da928bb809423ec20cdf072aab33390dfc9f21a68ce1be2e77f0e8e4f1e4020aea2ac65dadce1eadc3e377a53c0574d7ff69b7897881f7e488413822118564ba76d3e7f1da3c8ced4c419825f537f4b9d0e2f52cd039ef588c04f01c6a6bd72ad77f9606d536e72714f8b9acd1045b6abe1a23928c7c08ee3094bf8bdcdf06d22b0e0c990d2f00a854a3c1e06cd9ec4ca8b808b539108e5c802e103daadedabdb12b8012196c0473cc50d46204b08ad76239c4b88e063ea93d8ddd9831ee5b31399e4774362ed12e66e1f1335f870cfa99210153a2c8c99cc90147febb76a23832f3dc19623dea7b4fd0862c94d59d46a8d4bcbff17cd686e78c6f0dfe5cdcd7f42a0c4cd82b4828392b3735c187a93cb3b3d0f562414507ede660db63e5ba7c58c97ca4e45bfb9e521bbffac6584c747e81e0b7a07e6a1a19248e728fa2d5fb51b9e12c6cbcb3902bab302c48364e950f310ea4b2b3e842a47bf711fc06a0fef6408b0434d34148c2eefcc74c5ede62f86bb05a46a1cf81d0c5ba64c461db2367eae340dd6d8cf513905c71b1f3d78d17ed5be3d21ba0239b131af4464d71fe4c9e1ee948bf586df0d35044bd69a0a4e9c11779dd2fb6074b59c7cce6f02c13929a0bd887625c927b0b79514a5ab11fd4628f023232e65145a2872374593737c46a2545f6ae0c0c8b815df3b482520953de42db8ec99b8fab4247db37a24669cfe7a9a296447f3e23c9fa793dbc999406fd3b5b75369d292c34cdf7bb674f446c92300c1ddf3ead5aedbfe4ed356a4bb136530c9c9491ec75464a752494b52d983e688b1b3f454ef4821e9dabc9b54d9aa8090197dcfa57a88e5bb75319dbfeb097dfa04ce8fd007adb8ddfb74fd14b9c4811f3804a64c018584aad42daa9014deb088b45ebdb14acd9535ae6c3dbab55261baed30cfc9893f03fdb4ac36ce6eca723e5a5dd2315db48f34904e4bc9ccb5a243715ded818918f4af83e97fa3a9d35c321c651aa2c70cea4e32200df16576d344a67eab93d43a95ccd32859cd68737675bc608b3a6775639be98456867c1d27737336519a2dddb5081e72c8d1f5ef49f618bece8694fb87e0e087c6235c9ca57fee8f5b8c17716a3ceb72022aa5c68796fffb0867980fbd1ea6bc3c14719d46c4ed46e8c76bcb138fd9374b4c841c05612ee4137784b45671cde04fb84680cdab84efab81309ab392d27c0d153c790026d7dcb30149ca34686afbeecf2d7dbf350056bba1db043c20a95a888b09d360fbb299e78c3916eb3be5c3db05ce8d3979ee3468980f899b48f8431b753c3ee4899c8337c1fb9f84cbfdfd71ee8b6efc494324b16bfc60e07c9c41cb050491befaa0499a474367c3027db8a3674a35637525b86dafb0da8fee5897eace9b124412a9e669ca4cbff001a726b2081e9c25eb18e5a11f830b5e9b93ebc317c19e92617b2ad4898ce5a7c7551690b3c84887dd82e202bd51fc84af6a11d506c9c877cd245a620f053e035835fa9dde5b7967d7b6254ed84ab9b680aeeca369489077322fdd4ca57b9704599d2f87090770b2601062a0baefbe61e887d0f3f4d5d48defff184d55e2f7783e82c6182264381abbf8134e154b4b678d01579a1460a1acee6b241227bb04d663ac41aadd5858c7249c877d37357b4a5046b0697f019e660593ee3152fdac112e3e265bcad6ddff5d35d21abdfcef41991297b1a460497380856193da6dfaf3bd05199baf1860a2942eae8161976cf53b9acd3439024563ddd776beff1dce117a60e66996afdbc6e891a2f05ac459149f930e5b7e573855fe4ba36ab0f5d6b46b60d1b734a4f383dc5c1cedaef5486fb63bc10b00c2e324be0e161d317e919ef32cd92fdd48a41de627516e37dd9261947e04dda509a52d274337a7d864a2e5103dce81b331093d2657646d73d2cee64a4b1946fab7e867f0a513e2376763e5d739ad6f6acc89a06fa2a2890fe954d6ecf78be5ed6b851ed1746964567cf974f1146304bb9de3933fcec224fd5716df555ca1784dc323a89c25a548ef700aafa834df70bf05f15f81f2a520f92e5c8f1f08a6ed54d6f821c121c4cd3b9627e13b57b2676789c3e950348f002fd544b7178d5ea17c733b9e1c88213242a16193799fc33c3b2e007dd1eb8e2534a13a7eb4a0526be58788a4b95a17f4e0c27bceba0cdef870b842915e8cfc9a7c8853f1008c22a7dabecd3b541bddb30113f73bd817cadf9820ab39be7b58e0e8346c1019b1d06ba5fc1cdafb9502fa80dc420d28bbea880e851fa1f997b4d240d89f3ae90c98e3b9030b424f6d608eb2995e2a580e93be3609c5ce12a98be71ca0aad2d63ec598516535cd34cc83116ec74a7301b52223859b4342222c9fec9af597e852bddb777ed9ab6d2f09c10d14af9c791030bc6a84dd44bcf8ed74557edd3d270b19e6fe7f23d435413e5ad4063a68d9cf0e676a15327f0b76e323d6bc26ba996a94e2128fdf8db7e4364fc0c75c579f1ebcd5cfef1b86c2a50dc1b9ce5e2a82eed36faddb4693a7ec2485d5bd2c4e09026f8b951ee0e2816ee9e2e61a27a515fc8308939ff3b080a5d6455f437ea55a80fa68c354981683e444378e50c234da4340ea4d3774957a2843d3ccd2b4db18db2cdc2e438f448d2d451bbc297f6d1b87548a0ae8f7083ca493eca93ff7b4bf90ce3854fe7ef08881a3727b02c3f00b702d75d29c5189b01783ea741a9a1337f3254502348e32f5959c3092be94f7b2ca524adcd32d647816198b3c56d04a21eee642a5dc3a159a506d9f1a6656be7c802af43d3543a66b845d9255b4389c24afe1734c14f4eaf01351de4e6a2490be33848ad2db5cb5da78cdcbe97d6f7b96ca8748499cc7b1817d861e1709fd62162aec1e2be4b6de34c83a7a39d794f0ec4cec67f5ee612c33c9e6862ea55e7c2290059a3b644a27ee1711a7a9cac19ea2b866d576aa16bdf7e18987ab6bbd53a7cf66e7c9a84ed7fe8ede4099036d5fde46a52ffa4df381d9351c8d4c5eff59c1724d2e644d6e896a537010eb6e4a7f85e325ef6e7bee13369324feb200472928b92cc3a87797dc2addaf7aae83b54b3a70ab38018060c2d39817078260ce73c9d88411b6da794c4bf2e8e66a086ac0e2b152adba7eeb1907ad0b34b396025bc9978482ab571b09761a211cf79b743ce85453937909769cf414d74d19a3086f07e9975c1d8a9d56770c69db670ff0d601f36c64e65374aaa15242349e19dde21aebc01821a0073ec67a1e4c6e39aa468fe09e17d32ec8eba4cbce6bd15bee53648bea761cd0b78287af10ea061f2ab4fbf262edd7b3d62a555fb4cdd734bb39f74f04cc8be081f8262dc7d4866568fb6d6dd6a5f34aaf2bfbaffaff273de486099e8319f22ee978ab66854f0f3392c8e31847b9949b6a17f658b335b1f997d62c55433979fa8083fe9b684bdeddbc0a57e5b7e0118440d181635f56465e6f281fd2faac01a20a955908f998391f238d522e00b7cba312d02b4d3d237cfdc6799b190410b86b6b71e03c54ebca7ff92efe0a4afd791b0eea8ef4b9dff3d86c4c3aef7813af71cf48872a1b4761e481583e8916ededbf44abfd4471b0b68209e5b7f96ef860952dc6b9515c11be1f92e517e3b9257c93b09f2341231b94f5edbf4bd690f0a20d82bf4de3a9c1cc748cb443eb397279f64493d57da36608eea76545073c22d706f4de9f615ebf56133c2e03e8c8906aa235065ebf8515804883a8cc97bd224cb6a9d17703a94cf19fae46d0ed1440dfc7f97308c4b93b9816084b3c1e1f8779db6109e1efcdb89ef0b331b3b488dd988db9c4f5e90970b0b9172c06424aafa4a963eccd11eeb96d8aa3f610fb02822d84797b76f75f8ba92de1c59be09f49f78031dbf53983c7a1cce28af4b85f87dfc96407a5fec4e054ce1c072f122cf6b64b5bfeaa9ae490f76d03e3a9101c4c9912e09e8d55ae444cc46d1a1493a292018781342b80899d43e08dc3358d9db722ea2c7f47e1155b9a55890f5d439de5a9349c3d901c66d01a23c256b0ec60d89c565f493e36481e2af3aee52e70f9f3999061f9f83b3fe03df48b03355dd6eeb89d4f6249cd83594558ced6163a0d6f392346360142e8ad21795075b12c19e2108f3a82e9cc04dafd2482abcc45bee02329dfd0f39108117dbb16503bbb5b817eccae8f5f126dc58fed879b67a78d775d57c7c1c0ea0b8aa75ec81ae4c41a9a5489bcf9aa880923b02289862d5536b902f4c0309c5416e2c50aa01e2ccc28ae1c5e8fc8cc906ad6e0bd96b45feb51181c19a5439681cf68fa93f99231576bd87c7bd138d890e40a794acff3c99930899a7b8f9a045f61fb6a6b45c38da06be581b797eb78d8653925685255079360cb59387e909bafbab1c481c857bcd372e94d2ca024c7e9efb5b5a95763dcc786d039ae7ec71ede0489f252953c2728b21b93474e6bc546e7b58a82022d98f5166b4d334f9404e2690622648300a33182d5eac166fa3a3ef7f2226a54d49f7bc6d033626b885daefadf13d28677d9b2d1209e482884a11d2e0030ecd86bb349b577505fced2e16c434cc5a74c3e8f03105789d3078841b00d4525b34d4120e0fb174b98bcc138301e3b454945fb348b1d9302f33046591e7f7720a1b1ab784ee0829ab9b6bfbf251bc4a9f46829fbb6fa5d7b3bd906c6c206e8239d563c95b2db57d7733192b7056d4fe03624c80149dc184a87b9272e5b343686b58a5d7e03b770a361143a3b3a1533895c91b7ff30b0995dd53d0ad99b0fa9c764b7ea8b8de84c0b9e51e6559eaad0efc1a437afe0a3bd7f8f2f689996df0d69cf119f3500eb9185a808113fba2adf4bdfb8d6bd7304134bd642687f7a111e09cceb44c78cde8844219a2f6939185b528aa04351b886bda23ad94b61398d00d44016571260fb55220e7cdbd493720c917a61e6cdd7e0846e49d8a22af63262355d92e5a133f1ee44c3f7a478aa82435b2a233817118a52f6d3192752c2f2a46becc189fafc52f63f18d470e7cefbe451456c3947d6ff64ccc47983b3ad7f66f9e4acafb131996f2a12927859ca0a638526c4f15688a9fa46e9d74796b6911237ccb4cec25c96073a5f1642bedbd5300b64eda4db71d741c378f047c1f9e317bec1f856b16f8c502a0e5d0e0360548b7934a9dfb9e8bdac965e909378917aec1f018a8849db5421c8240dd514fcf6f69c0aee87d877bae360406f97bb1760527f693226f3b27c4c65f27c117badab6f2355ea642c8c1bbed128dc87a310327887d29a96b3e6e9cd15902e5a349ae6cba0c94830c2e20c7b75140e9051aa19d308e36e233fc04ab6a9144892c461fe9b6b951f3f23275fb2b5a369def44b9898866cc34ba22b90ddce0cb890d0f100fb0507e38437fe7cb1b301694b0a9bd0a3060a3fa05a2e04842efcf07b991cccef40564d100e20cc2267505faae983bb1918e5c69b4948f6c763446c1859e3b9a58249441ac0bceed0b6381a6c2f95535226af3982e1939d4aed6378d5d8fbead8216a349f9203b2382c87f0ab9cb4af6dc1ac9c903e95fa6844bc75d633c3b1c1fe917651ad8a8c01046364de585305cc0f536572bf614e9b0187117a8bb0f37feb9e987382eec7400affe5f9c2141178d0125bc966a2f0d3acf31fa8345e3c660d56861b2c77371718149da9e6629bcd0b993bb49b9aa3add1649c17734aaa9a6faf8409ec845d6d66557002faaccd99a707e05357ce303e1ed853fee30db39c6ac6c4f8e83381607bc0f25f3cca6d38c6a1b425574f46107936bd01d2dd8a81f4ff3e8550d7dbdb36c076a432e879c6e9d4837d3a935c62cc86d684b4c1bc630e06aa4ea6d7a7ba4732339afae1ab26d8d1aad2ed8e0dcfd4ce5f967f58b62a65a52c7b8c32470fa1dd4a437a8fe6ed6374a3c37491a0da219b3410332c1a636093a561f35fa5786141967990a17ea7ce7a8be29f53bb60c78c38be537d7d34ab84361933ed80d703b78b299c55cd7171148ac7c3f3ffe46c98f64e7d5c7133a57c2fd6975eeeebf489bf56fb86433bd39e99d5c30db777ae340faf044c223c715e7da1a7173d6186a60cb5e729b57dc64476799da1aa08a5151f300db33a9c9b83926c4bd6a1fdb27f1bd814bc7d78aa32112f4b3a550ca790d0978401be0d8533d3eab6e806d619d9e6515d648586bef751629110cec91dc174ca53d5a5421d03de8d9c8680207e98133d8dc6645d8541f253cf48b024ceb54e7dea177dbcdb01409bd09896dfa99563e0ef791447b8ab264de6e1ceb996a07d12c24679674726e1c8d82db2be7f19aa21ad6df1c1dc684edc40fb74421a2951efd4ff7d751de7f8a40f351d1ebb6f7772a7625901b58d6e6e4072dfe7de0091efdd9a5109723d59bf628c731f6e98ae1911e2d9702745f69fddc807e2590d02d44e6f4f1448b4cf8960698c351cfd868167e9fae1d9a30f28c6fdccb14d411bbeccbd701c231e14f14260752c99ada7020baa1afc283bc1d7be14a7eb813ae38f1d21d97c23f12fde417ea01b46d7262473ba1fcdb2e9dc89da6d3aa5e84a0f847d0af7ef2485431ed89808cbd85ca0bc4974e2aa297e74b7596340b0a78876720a9100c3e18a995404fa0f9dc3f7b045cfd92a77dc20abf7b0a2781fbfa3ad1edf143265838a1a6852d09aa78158706b344f4ac99b4059832eba4ce77b075cf8e842c40515fc295534390d21a3acad5d606f4d90614811618e088221d7fc23805ac690c06baf3340f92bf23c297b35467c2e2a61f4e20d7cbecf513f1537d07726a98b9289d016e760e18bb2a7b702cb98aa496f0bfc6d7b883f5818f1df33a2f3aa64be877555a3bcce9ce3b00b013c57f7476dc5b862b87232b09d35321cc784423d6db4ea63442ba560e512672f1569469f8f4e2d520abb827a9ca70a0db0a14a3c6d2d63203c6da854d79d81f8dd6cc13fa356d8c13ad13b3c6270efa50b8e1d8655103e0a355da2bd02906c8030098ed48954a8be376ebfa0798f9f693245babaefaf7f391f92432378149df41f7f0ae03fdad764de6c2909ecae48386ff9deacdc40c1339478a216d3a31ffaedac45248d4ae8edb266fd1a2311ff2689fdbce0e59c60afe3ffb9a0d89a6fc9d551e61438ccca815414758dd866e4036f29acf4e67f83ca82a4d364e2b2dc125a41002bb95f6bcb225d34153090071afc6fdf134a4aafe9bbabb613eb52e5f2996c9fdac838aad7279cb2f5cb91ba8d6dd7e109438589605f153393220e133a36325debfdfd7e1c7e0ae4a7969407dd6f59037952f80943c9ddacdc166bf6b157521954f21954e3a5abf271ca551c1900eba9f399dac205b848a53794bd29de0d63745e00f5272847b3be0f46016c836c21cec57be723e8226df0149deda9426051daef276573147146fccc02ea684bd594068b8c2d0009f6744dcd564ff1367986918ec228f6152bb6e93e660f19e884b22c14984031f760c6f06553d3d3383c1260f26886af1c362468a667025c1b4c4bf6b519e3d43421eb8dd98fa9cf3d578b112fda5e296fae29732f8cec7f3b3775025cd883fc0714090651d0256e6187b59ad7cfc4ec7707a93021ce1783319a0bcd31a0f9a780e3d335ce8b03feb6d4b159209dc439d8cea0c3f74865f9435b9bf9aefc56faabefc2a6df21ee7d35a8f3d5e26ac81a5b6a290847a2093cce6669aa28f3519088435ae360de647036cf1e1bab6aea10d02177de277579b7bcc06b7e376c45bfe6020da6124db87c4d80e59b8e73b34842035688ba5297ce423d5eb2d9099fb6b5c3af81e0ef87a274bcbe54780c4cbd5c1aee9678fe6c4171c8b6203833fa9a83af1bc79132d9cde17386d1f7cf233d8c5ea946a3aa904bbc5af630a3b225dc4c600a9aca6d01b8e80ef2a454ed1366d9fbce1471100d77613992fac31fcf2d3f07b2b339eb50c20d26e59a2260c6f28f451cc85001cac3491e3245b7d3633e05cd19795b345ebd0bec1b099dbe379c6c72ccc8b402998567a1a0080301b8b53fa5ddcc8bd3e3970fc9d4724a2ee56599d6452988a61ea63e688211e873fb99ffb51b2960c8be6a96c066f0dce863ee10f33a9dd62a54940ed1a6d4d70b9f8c69c9b5b035c4c769b3ec94e24b36c28a5a828dc92f7fc2037d6c1ba6693a46f4e72672b2dc986df7f7d59e2d1a6711499cf5130f1f282c9fd7d1fc4920e28957eff33316b7a470d5c1333e615d4b0e7006d13590c4335d16309a0655bfbc2afbe433aba60959ed735cf803eb402aabf4f2869fbcb3c494a8548220e204b66d26fb6ca2d3807e0a40f8f94b5ccba749756c0904097fffa8dd75adda57a44d773830ed1b4f2edf2a1bfba9aba4d422203cff72641a201a1dc6c9ca509f37b152a53b3c1201e1c41dc14d88f8c2105a3e096cd7c60d8c56ca5dbf9d18d6489d3e0b5fe3d6c2e6e814699a09926291d41b38e07ce222017b71766c12caf5d88c6672fedfc75330e4d57f3ea17432d57197c841687164f6304370f3abd60f5ecc72b23ca05d6dedd1278dc980467dbc84ec2a9f0e5d829e8fa3fc35fff08934575f25498be3c4bf580920708c30436af6a7027f807c2f728d5becd75e952a898ae3324ebf74a4b5f6a021051713f10fcf0bb6ef24b3c865121236fedce04ab4b2aba668c8259c599e6c5cbf50d1e13339b9e1a0bcb1dbb0a9d3c6e79b4582aff02aca0de671251b816975cb41c3b93b3d311c76a2d5aad36204d2b68dfdb34c030c8924fb104785f43969d0e1a535b2e524704ca3966552ff79682d39b794bbe180abadd82c039fe7912fa646bf7c685506b92f48c4ee2f8fe56658e56f8d92bbbb4beb19d2c74144e556cd8e42adc5161f52ad60c5cf7665b573a2a1fd4233f913afca6ba037ee63748437e4ce8a25075cd8180d0b38af1953f3d402f01d8f2c9b9c2ef84fd1201252f5dcdfdcb6b63037dd81da4564e30c73daa23acecc8b5bb8978066f3ce582da210661e401bbddcccded58a1a5fc9ce51461dcca0f777080280e8adf8740a58aff5a9533caf0528ab5ee91b10d7645a38062a4049e5b4bde9aed783c7e4539e49bfff105ffc45f7bc63b9b82d1968c3b346ddb9319cee0af410efaa13c6e2f4a313976d5ead15bafcf245ee36048735bbe2601e873e69302daa3ccb3e247ac38dba15f7aa70daa4f94088ea65c6fdeab8adf9aaf4e85451d1b06937f10d2e9e8d074c95d9f78305f6f6827618c50dd2af090a3c927228af1fa50acafa4a9a945d1c80309875c4551bdafdbceee5b5eb8dcf171211146e9b0e90d9829880cb2aca741b671fcde56ef99a1d18901fd08120840e5a89c91354f38f2136501a4ae52fe442c76dbda0c69fde5319310d67a087a9496ab72dff545789eba04e6495d79b80768c507894dce78e86fc715d007d81e453b2495b572245adc252f685f336241f6bb6f46a401dc915c9d59465a28ad1a924bd462044201d345465517096531b13782e2944977a550816957577a979d89ecbf267771ce2239f50b123524cad7d87254137647a7f9554a044bda16057e71975ad31b37ef3e70cea79089cabe32bc44761917738f01c319a59755a0db4b4fa9ac0a9429cb9681923750416cf12b5404a89878321a47bd5e22d1f450bf98e06e8476c6d74c9f0bb5cf77c6d72b89038f7eee68e2bcfcb827d15f81fb7df1f997da95f388276113949f2e3291e88d43fad0e71619efa1aa1c1d025646223dc020b57b9e1d5f036ff25f9cc733cfe8078751a425be7d54483af6f294e06c998cac04010ca0103fb2491b9255e690381d6c572efa0e238ab1b300d9dd3978cf80470ecf26210cd8222d72db2a72ffc965643b4afc94433db4bd5fd32462fa1d7bcec332d1fd628d9055119b495f84f18aeb1d88dc66784574d24cb7bf2e7c0d78352be670c699f623006d49130a96d7d728cc0f57c4d18558de75e12b9eeeae5163c88b5cd10ff7b0ac85f5b669aacccd166a161c6f088892140f94c120f5c3f9f274bc0c9effb276a8a39363c008cbe270ce779cf9201787d8de07349307109aa3e6bd6b2405b89a55aad0e3ec851b0245367c4a11032d06f0f93d2a6bd6f41e34c4d75b1766c741b61291d7f5b24b38b8d89c1ac617466e509b8341c19c60624f2d8ce1eb943aa6365199d0d590a2ce2a4b34142a9b0ab95d35fc97983f526d5433797fe448251fb32a7ba06a1682d678ed95c045001b09e4bd220da60bdb8ff71daf2844b81a30c7afdeae8fc582b2800a75aaa77dedbc7e746f6c6093a9f835317101184cee9fdcbf36eaefa2f67c11731c9977cce0fabfcde4e8aa6df93acde890f8b64e788f8963b173d141658b1d7e80c080ecf2569cadbf107cafcdbcbe770db2d931e059cfc0341d4d4a6569b955f2bdecc06a98d5139cd341f7c3c058b58da9fcc30f206497af8c6aaec7ab0fdd4c597e80a37f7b69d948fe90fcf6eb7e8768cab1b9fe1d54e31ff889d4f8fa5cb58e80b0b3daa5742cdaf02fcfbb7b2e1d967e79","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
