<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0443bd649b6bad7c7196b9fd89ba5369750340f16cc0530ec8f80497c5d1357aabe72c4df0bdb7373c1b5f5bb2895c2e99f6f281aa19c24057c4c4040fabaacccb4f387269f7575583ac2d1cb913cdef2516b4bfa5be0aeb77dce7897e071da1c33bf0aa198979b2baa6c38fda03a25d4e39aba816a0579d6a49398caf1c89de051e3889767b97a9dec5eba748aa4a09ebf75ff10c6933edbd9bdd52ca23c5305e46c9b71b60e7fcef3d5461171b5c4fde4fe5afe3fb9754ec69aba4bd24a311505f72b82ef1b030869c3f07460698ee0fc424c26664a545deba85dd562bebb786349d579a4b0b81b72545dc68e1bae354c4d329032bbc744c234a7debb1de15aee84c7911af428f1b7829f2a740260b4d470aac3cd00cbfa70dfe061970334c4f3e9429611b9d2599dd7869af71ba002d7abcaf333b160a9f7d752f03838f366057c4c41ce69a88b31c5b9eef19af5ea097f0837a34d0fdc41c62e8fa866b1b0e4140e72f772c5d70ad29dde02a12e3c621484def7afd77c530797862d0675300d1f11dc1182ab9b0f3f303be09172c83b994836d7f036ccd2ba2733cae166a3343d0ecfa8875f53a75412e4797ae067cabe5d1813d68d0a04ff4f0d0dba4acf22c10654f37083747bf5b3950b61b64fb1d3f9706027e20984ce1ba11d9d1fc4643451869c1ad6191a82ed18695059a496a1d5fce6c0845dc50bc820a814b73538fcca5d18d9b0efd7de1daca55ee8ba47aac3ca7724a8316c55a76a9b58a16e8f8b84982d5a31316abc189dd90938910e491c574f2e2d4927ca9cf08130053ccdad235348309ea82cfcc7e6e8c75c20f854c690c1809c8429384aec4d8e2a55432af7584bd97ce8aa88130f9aa814e2569a29d1224791bb10b6b9ed11e2fbfa1249917d18535ac63f62d130678f4daa75ce60e342334eb44f2491b994629fcd36924ea92598adf180b988d5d6e4791964ba5bd10be68439729f554f140627d9e33cf532a3191e4823fc39c8a99669aaac59d600fcc95be409cb9f87779ed2b31d458a0d93b72ace3295965d37bb3d13e378f4b3d69168e41b9f0802d9a4501138a163744cd98efb9447a8e8aea2427ad38665b39f153958cbbc488ec3450f5c921c5572c83c9987eb3e93c10676793dde809eb1c7ce20c8bee9d51caac967dcc854562a1a2ec28d8d911197b3dc2b9633559be43557f12a9ca2fc419100fb334bbf6095b013829412a700480c8d2300ede8b39f8a04471d598c445b0137f0c0b7774b8d6c6c6b39563f361feba192b137be80885880994f1e2c0dd90192aa16cf6a0b4040e4b4f70c422e1a259567b086008a0d32bef7281e664c6ac6498b61cae69be9802670e01bd9b803d18aafd15aa2ddcce4cc29bfbae06864c64c86f47bd73dd8b84058ac0d19ce9850cc2f09e187735f6427fd9b15ece4b74824b0fd6eb24758a1a0c7d5ced46fa0a65023130665f6204120e3c30cae0d27fa28f92c9cd6aadf59584afb648dad34cf251d3169ef4f7a5cab0e75406df5e83314ae7568f7d310051107acb6afc2dc310f2f165c574d89bc85c65b15b9d12a79614bdc162a48ea4b897d3d24c84d25d2b1e01fa44ecfb63bbad2fc8004f3046ffdaa6a6f7f96b2158e5d8f9dcafe86f151612dcf335beb7159a027059dc3982c1151e1b84bf1d6e0d08c17472c2a1e47ecfd8e698e5494eb9b2cbba8ef333b8575baa1b2d7bc3e35435d7fc2f20b251e74233b9099018189ba90b07abed5e3d19000eab2a671b64b4b1d51385b7d002a8b80a6575407949e3acdf6f06cebfcb30e8aa77d299febd6e948283aeef2316e88be1d33043eaf69a5f5b9ce6968c5f72acb2ba2cae4a096fcb20b011bd27da9c077660f9fe89aa1cb2d6fb7756514197b4e78b103669694ec80f26bcf8ef7918a178302fe785271ce6b3e605f2b47f8dc3a5dac0977269bffd7081cfb7898053fe5e07cce62d17b7c85253d2edcff05391e9866508791a05678b2ccfa61140086e874172c47f276393d27d49a35e1f81a1068b2520b9513ab71ad12424f5e9b1bc08c459b410a36875f8b67d95d794ab44836b1aca27888c1d5038871b967fc210fd6f38dc91dffd1d33d5713e5d336bb8a8b3e66b50c8b68a4086bcc0cc85d6eb480ec809b5f4810940d49b98787e18dc3c860eebf69ad09e4a0b272425be1f61ae020856b6ee8c08136a7f4c5874e8a05ef3b6d4fd9db30900b7c6d7f966d69a43e746518957633490ae3469d127512a9ba05710d5ea38e2dc1ea4f15f00aaaa73e3b42b17c1727b470cc30e213075405e6ac119f0da5072a571eb27f4548589158e53a3d98f96ec96a2380dbc2ac8f41b5090c96228e5427d58f1f670fe9f7ca3f173894a7047fafa627ae57445132564984566ba9d8e4cfb14df68900c812d76f27bea3344b29b0f9a992c0d9c4047a2c59912c1eafbda7e819ddeb85e0514fdf7ad7fea000acf3fda6cd2aaeab3c8d78c6eef334c61c4eabc107ce6ff7a71d8695535ebe0f3d492ec1384e8ecc39b8b9292e0b196a2a64d41c09d34952cdd96e39bb7ea415542579b522fc8211bf806f5ba73a733d8f0a5e026e7429afcd958ae5647707787469e9236c50840d1e44d294bcaf7b9fc13596bf704d534c42353dd1da5062a30c95699559bd61bdd7ec29a8c9ac9bf273bc95532607adef81954d72003ea8eab34c255134b7aa5d9f52878b17d5d5c73ee30b82dc3317071658a9be76bd2f82046e53aec1a1e47888df5461a1c1e9f4c1cb1a82fe3537a2ed0edcaf2ec5a0c9d26f8b5e75cee031c300da91ac31b834cff39fe4ad327ec619501c8311fa5224bf056e45dfcc8626c118fecbe7347f0b8302d9f08bd9e613522324fadf23be3db4b2455d46448edd10926c8bc63f2d609d14895c40ad5b34caff52841161c0263f853088c2c75406477decd625294427805665f56405aa185e06cda9770240c703f654e43bfcac5aa147e3317767988b6b17356f9ca541ea03b45813556494c9006d3370d68cf89fda21b83893ff3e174c7fedc669d908895ff7c88848168364893d9c537dffc92772916c4382152be792b337144c5bbea482c102661881e8db2b8edaab27c280bb16ba8da816192b1c20a06c5bf7654b5ebffcc17b4cc741d3da45a2b8c2661f47fdca3a7dbf8a67244890e83792b2f5e9441be32fa16663d8df4f254b4954d6fd0e091341bd2e5663fc8f15ba383405e7eb36e330b615e688121dad01f28fc29fed2574aa39a2af9d0a0f08ac42dfcd2474253066733923b4626343569d60e1b802e073d851f48e5b0a290fc8cd3e3cf5cd52ac880daf2d047b089538518d9eeaffebebaa1299a180beafcfcb37968c7ef4fedc8e42e571bb73c98aa6fc9a54a2ff1757d5b2de5c5134bae206b32dda3c2d550651b03e03fcad248c1eb29ff7e6eed32627b4e625b5d384708a234ce41a973ba82485142fa78edc20bda7a6d5e7285ca7e95b27e2e8837e6f6a584afa403757e95e322398db2727dd9566b8f51818914adef9dbdfa20eee82eb7a06c225c6471ed73215eeb2579be5b8460f51524177cfc7176f72fdb3f762207803daa717f34ad11d0f1439087d26ba5b37ad0eebbf207eb2faf65b4e4aba00d146f03df1aa2aef967cd0427f9c284405d70888355c02e80b939c2e784989234f2f38380f7b81a66d3d413aaeea80e6fe662f3440a58d6d4bee9be6f7eedd3f69a14c7f665cff2b2f458d429708e3d65e5595f0130ee843fa96a144e4f0b04f344497e3b4ba40782e0895c44431086a5af3a851ad757d99cdf91e0b19bfd681fbab96b89043710639fb0ead831a8b8a77918242c588b2ad775d9a3ade7cd4774211f7a4781790776bcea876f2549a64734c305f44cc4c855ca8500ac23fd5a3ac615a7729d91f54ab45a7ad82a5fe485671e1fc712f27a09f97231f94134a16ae6b5a87e4fbc75a80826206eed072b216fa1e2581719d3eaa8c33de4ecdcf1316887958ee73892ece7f4a8c4408fcff545f7724cbaa7fa4e7c40414b16689d19736eb9ce49d186494739b849a4e6decfc30c1b84ff538fa65792f33624842a38d0bc59a1360052dd64ba795ab70576ea6c31b972e7c751b83f5dc7b3a645d1d1124ae6c92a64253dbaaff033411342297f40e9eeaa0295d976fc595a1e418d7e236752167e77f28fbbcf09a0ce86a380aea90ad8beb4e1b02e09183ef9345c896e0df3674913315a72355952e4f4fb0dc36ec2d03b4f782625c6dbda964d9b68d7a48af94c5e9a85490bc60547877fd12a0712e88cb17eaa6e9244265622ed9b07eaebc2109d5fdfc1acf3daeb697a87c941596bcf68e5dc770a797452fcccdeed03367b0bb8beec93e31f45ce4e47e82c4a11fb6cc6a30ddaf7dee116d81ed90a5d2f47ec6955fe908398421dc3e7036e24ff120889f0e24fe53a0f709610ad2246233e139b6712a41146aeacdfac6b63b6a8ff893e0962370d104f931394bdb553a1bbc787763550d36db4adc5a7232c4d3ab5a7a1ef298e0cd61de40d73f3a3e1e92342e97a61f17d537c426eb56cc3c5cc6e5de705d4a76d03e48c72aa2fcd8d0b2f16e0a34a10252e0be9c9c40e86d9b6f25cbdc47af13ad2e7b5fc8c2c252684f96d2e03cb2c0bba3cd2cd0e504b7b9f8a996820bc3e211d3ecf4d3188fc2013921e1b8501e52fd2150e1679abf1c081ed63194fef27389ccb08b54de4f3065e5f42f4dd6ce2fe76ce69384c612f10fb39d7362c2ba04477a7889c9b8f6e92982e1a4b812b7fc9a901976008a6f93879e7a9053e924f1874e299e964390a4bb34f8828c9ec7ab4853e2a745711aea0172702387a2af8213147a2cd9dbc3556e9b17b2b69d2be5154ce9f12162dcccf4f183678f5610d67aded8356e018fd15410131b64e2cc6057aee3f9c9e191d2c3e2c2a26661d35b7ac9a625f27c53a49866464a6a4566cdc944c41e4e7a84031738979d9f42efe6773b8a00a24a6ad5913ab32404b4d674ea821c9ce329ef4262a8e974c35333eac072fd5539923cc43f725bd574f3b5eca1d1f5ce52428c5ab2273d4e09619a6fb5a3dd75755dc120adae7d8dca528fa9e0c9b7f9e6820338fbe497ae172aa83fb1d5ab0b98f01557783c259bdd9d12080be8b451f027750041d3b3c8c5e67940dd4df506d13b74dd1d0fff2db3fa3ed800a9db3ec6c054c66e63e19b884b2334859e6033ede9e8fb84154eaf6a7adf77687ef9bfbf89f873775e4ecd18784e490b34176f9c8f1b56339affe4402900f110ba15ffb789aa46f5adbfd7f8a5479b775cdf6422ed3e1bb551eeb62725c90bb0a92c181de380b4241fb6c15ef621f3c3671e2bf6f21f2ef3ef92a8d5b297611574f712fa7b9b872b5cce08c2b0c52a7625d2a653ef5cee08080a69333309d98c0b7c8a375ad5b6993f1c93a75b808d73fe9904c5aef2f09e13e351596db1307eb286c62fdcc9b21628c999deab7da26d0e32dd354750b4579068b6960dcf646ac3d0dad6099e11b0de9956a009d8e3304cfced3be6cf912738ab543afc24abf15e16950b1fb6ebe4a1dfffe0883a460202b5aa38ee043a983588d4ef773a7d61f3475bb03b5ab40a341c0cbd8b5c965d9956d24988592fd56764bbb9b029f4f152b1342cd964dfaa9c80ba7f2bd2ceb624acfdbf17382ec399bec82adf92eb24e0bd7e91754344f6bcc698cc0965c52924bb79ccbf16b820b7702df2cfc2e764b886bbd902bb7b7e1eb267b50c8fcafb1d2f0bec2066fea30e8b5110326254c801ca6cc2bbcbaa4310f7302bfb690f8b84e2e6117108d984c1a52ed8ec6c6bcc0fbe8d9babb92307ec892d1dc32ce395b95df2c6e37d52039b36179a3ffbee0d41e9b615fbab6053cbeea2cb32e5976393acf77e47084bbb00c4945930fce108063931d8a650ea089d567bff526a0e69d42013de6bce88bb841798f9532b2ff22b3c9c7374e0bbb241338b3b7b12f6b7959a83d29840a4ff994b9d8a55e28823436794de4171679771472f9c6756efbd26cbbafc50bd0ebc127d0ebe5e6b2ed650dca985453301e938dbdfedb4e1b5642fa7cd80c49dffd61b308448c705d4656cd66d3b4dbf35754291c71e34cf36b618ebc597840b4aa38a9400b27daa3623b9017813331cc16566ba15bc861850731b2bfd1ba117edeb1153f1f32e5cced26e57dede1161beee37fdd3d89e9d7d293226667b1c256ed78d909e9c96a5840faf1b064d2be666d7ee9c0f181dc31d4d1ed89d6b1b39c43800f31641c9fb6d5b2504d3555ef88132c7a9d889d49091f78bb6f3486016595dcb4b73a2465e1ea79efc7e9ec0a56f8c9851ce5dcb5bda9c0d8f7ed139087537e3a4f0fb90a31a558a8ba54a52f3419a4e960e6a76cbcde08a12357bc1f1173a6003db65920fb2f308c133c301f0972ea41f3ee1f0bed3d520931092ada6b8ac091a70ab304b27297c5f2605ff23add910f804af273d66b73686102f7ae61ed6f84cc31ccd86c9f3fec4546eef5c5651e1e702974445ed57d28594b0162f4766cb70d335e99d973d398545dafb286f09a54146f0253ce5729250da1ac5fca16fee461c75792080aa333010efe7ea46ed77f21ec47911a6c9879aeb68feba3bc8243fdc5cfe89d7c29737d9ecd7eea6d6c5eca9658f198dc0cc525f8b8568656ea13742bef6380a2a7501726362bc3202e3ea526c92d1e4ac2bbd3029df0bd739c9adc34492caa45fa46f215820b38344a1374c6fd1d4f0ee234ccd59af6cba94ddaf968b2a199ebef8abad6d6a9e31ae4410b520ce77020fcf3b3767dbecc8340ff4db789c6dbb42216129e11e559acabf83176beb9ba4c34ea546f318c9c80b7bf2e96e68c2208f2a7185643c32ab664476efd31b6b9a31574049a3384a08738dae7190b706f82d080be87c43bfe37e3270bc14d77b2f7ed070db1665d34151180237061dd362bc54fc0c259c2387061ed8173b582a5c2eea17b40b2992df559f2acbac31c6217bb809ff015700ae438fc836d20f93881918b5daf7333a9946a8f148915011522303bce6d35052b368aa6d6f7e91028cebb953a6258f1f4d92ca19f30d91db2ee190e0c62a569ef9118dd46f5a3778cebe06fdb8db936a745b5c65ce399711102aafc8b878edc355c7c5ec91d2102575d58f11ee1d1e9a76bb1302f11e1f776f41706ff93752f970149beb2df418fc3cb41f917ba18aadecdf2cce1281c24bf6a41fb0333c8773486469f8f05e926974347d48c503aa0c53793b3221276cee9582f0172955265da8743502db81969638e34fae84d03b0f0c04a9d03638615ed19de604d24bf056065ecde1a844738379335a4594c454d7ef602b3ccd668d26035a1ad5b43dfd6f5f1bd7b81779f50d5ba404cc74df3c6ebfe7785eb369bc64d02210f3b57a5ad988abd6633776d74a221571dee599072b7506b98a80804e851be36d2f9266e8fff313a570a633cb2bdce07cce60affbd9b335885eacf2c3c17a1960b2e27318fe580d85804165816f3e40d741971a497059ea8b5ca865d9c7437b5f30bcfdf594e01c6dcc774fe7f4e72d827349f84b373d720eb2e60904b2c842b63fe8faf6fcad274b1379ace1e687e7683ef2bd07b9658d47619361687d4b191ff5e1cd0333c8f56a0a5261c795a91006ba3e8666e5788dde86c12874ceaa0135fc6da1d2872a2caeb2a163c3d24147e5f8e97b2f3784d90805d37ab6de496dacb74f22c5cc2a833cd110877b541fdff6df0d59d973b5af19dc7ad83e001a9d532c80058c5b6c83fa7aa77d84988a0b44e388530fd2d44011c89837848a1051196b03c0a128ecf410e109d2d3128d8c2b1d839554768acde4c5e03079602732cdbe6ce7b66af0493aa0a040e4cbb2abddea9f7dc76877c948293f135d1218b1fe750bc6d648ba1d9e7d12389defb1da73ff9d1499e0a561f7fbbd7a664f4e7bca25efed7b89df4c0723ff1a6f2e3dec148f1651ae6ca97bab335fc0766860daf10b07a0bc7c20be2c20ddd64877ff8e866d9a7ac21967723f39aba95c1116abeed57e0d5291f2e66cbe937d9708b8cb11746324423654b03b48dbe31993bd991d532bcfbc86f4e0378aa3b74f67cb885f1ed466eeae4ceb3791514593fb4004c061e083d074200e45cfab0de7778d3ebf50fb52f31dd1dff3eaca72f90a67a8ea66a817600081defaafead20037c9021ac84cc439e43e75dcb07f04cba9765c066e990c5903f0b73a99543bb32f0dfd1107465288dc9a2071fea07f7d78e687ab33aa085cc38d8081562dd7546144f0c934c7d8b035d7e5247eff778ca76376357c2fcbcd4c3432febd2194d3bdb901e26ecbbafeb49d0ac462856d4de6ff4a45d49e57dad16d55d0e22d59d63c885ad939d057ab9a76c7e1afac257cd30faf73c7c0b77cad864fb924f009eef57eabb065cd098b9b73ba3b8d061b4bb1544487586e13d477c30884bdb927811e0437623c64825fccb7f45e5a894bde8968617be2e60bc47a4f3f355b7cc62be4695c013176c0408b023150e53bb641b0d40a3fdb269a70f6264b483c1f3e34c1de001b98ab314d18d6ddc953367a8f22327c3cadd9ce2d6420a40b4a05b09eb85fedb5c4ac623dfd6c41169120d1d3e2df942152044026de43dfcee265f7c1447ad66370aa0a37c6dfbdce414e586bd5c882b9eb4ddc0f8c449b74136cd8a11609c68dcf8b3dc92f0f83b9edc6c85eeab1a91803d7b2923c925a399dd7ff3c5bbe07edd543cd436a70917000cfa24565e46a5cbebebf39c6fb5ddbfe5e6cb66400f15e73c3b315c363f2fddc2caa562ffc1392f46287c5e67538f85aec7c58b17dc25b4edfedd894eec8f2b8f4ab37c50a2e77c0a7a2e1a8d8be4c6040eeaa1187e82c9c25bcaecba0987ec1df931764010b7145fa71dd61f2be7128630107477479577fa80ce61d7523769c9e6ae29c740af61c9ae3b5fc363afe97ccf79012be6624894171a027bb58b87bc5acb533411313974de9251f15d322e3b44c983a6638567033412a90b51ca8ba021c9973c5452aff09b948c7fcf7025937890279c5c671e87a522c9793f62754d297a4fae65b7ecc1aa2f18992dcb7061ae0f173cbe5b8d488a9491e7aeba88c85d92d44442375212fb68b25da3f650bbfec8d5feea2d11fc5ea5d960b8bd6c0306fd484109fc68895e2339f96e70f45a7dfff0f4034948e74cd0a429dce4915bae20a478674f48458328b821103768f050df2cfab92995b2de61f345be09e2e643d797568c3146876a2111fc8220d48059f4d7b3b72f6f8749b0aabd9ac5785e1004c66fdd8051cc905d95db732eed6d67cbeb4e47253b234d6ff0b1feed92822c37cdad4969f849a8fabca6d7e21a4b4aad7283d3dfcded79e89fd80fe60b81790a0d8d9dc7aba820c8ce651d80d1d00caddae14cbd30d6b3cdbbe9c740d683fb85effd011bb3e2ee82c6ebd89420211bbabfa000b1ab177d30cfe025544585ddb3301a1828dc75dd3655c015a8face68688fe4fd5b68f9495629890814d0085ba7ddd0517cd6b5ee18d68688394149b11628364233c5eb5a813849d1d1f23a19dc79035f1b2c8ff2da959e2aef4c46fa412c11de620a8a2831836040b6f21d6206fe2b85ce2cb405f001b2a5e5a6557a1c89e080d612e051c37444b6bf88d0a5152de8400e25f5daec1ddd15e534d2c9200a55a2d6f63101693ffb349b08171e6b765cf7d16ad37cecb8e200f37860a99a9fe1881fa2fed2c615e3661cde6ff5b978bb1c8b985a10602d97275df957be7dfe40f10bc0a80900dc76d323aedf0c75ecf77d2215bf3126d5a70c427837b98b15be7ca95bb71072c121596d361e9bd056e40093d6a693002d60479015cda522cfae090af7bf26065a860557fedcfa98a8793c0a7b9a68a9b31c6f9a8b1dd1f25642500613e3b774a6ae2bd8c2bad933b738ff656bedc1188a31d8dd0d2daae7b756ef88727a127440dd8e04345238d058a587f55d82959946c392640b168488f98233a8465c4d07313afd4445b1c799fc92da0bf591a6b73ba2970b5ff746c01558536a9896f80a3606f708ecad6a51c77315d3a303174368828ca9ffc8ef19b4a5b45425bd8dd9a83a55e2d01e2de6bd7bec3afdfbe1cb66a9a4f1738ce2c8ddba3bb322db4b312bd98a257aab68ed8380311d0d34d120b158f0162d4f5328ce1f04c97d0c5ac308e4f302ec053261a24b1dccf07c11cea6cd6361b7d4bbd756d3a9939d0d3bd704b9e1eccdd685ce10cbeb34f9aceda43d8a2ddf94b5ca917c4006f66add6c2086363e6bfee5d8fb1e4a3c569c29405561685538497c2d7230cf011c196a19be20e54fafc3c396570e6a90843fd29f9b6be5d1e3bda381ced1ed576055be2621bbe8acc14130ebd8c03ae623dc11d9294ee4e1d1eb8fda0cfceeaef8cfdf6393e2dd88d329e61c372797ce788c73740673313b26ab615465786e542f34369aa1915a78ffd7ed987261d7037ed39f3c5c40241d9b8e67beb52f37cbbf612fd1c9d4c91535bcea91ce6d4c73f8f19098bbc1b18b30d439916803aa6498dd59fdf03d3e43b675c966dad77ba1bd9c9774734fe0de62c3fb879841bc0ba40376b3adc1d28f58c01917add37d7bec26bdd4c906521fb8ea57f8135b3ef147d33f77520c180c4d6d669828b94ffed1615a8ee7dde6059b9affcada366058600a3e989586784e0a1a0ab4ce5924cac0041a026e01d655194949b99c08cde8f5f96f66b7e7d976f6f0bbf49d8e6305578ecdfb63aacb0e212c873c8015599038479d4e5e529b30df4a442f4ac2cac3b81282e3311c9c1365e2d9eecc32b8967afac41b367373c8675355f07712f7d8ffc069f4218f28c906079db69591ba03b9568a2801ac8722646be4881aacf06e44379b386eabff97865aebfd44ba3a8e75ce32ca49b2f5680b2173a62abbbd5071a6f0aa13d692e73b4fbf3fd55f32c37083b4e319e36c20b9383225e94a4d859b9fcda4be074731c75814684eb590b3e600e541e002a05ab13cecb181da9753fe06455832c6e6466f9c44135d39dbd54ec5e69b16d8c6a4576b91fab482e1d91e92968f6bd9fe3246b43fcf545e43d552ec8f9c71e4934d565a38113800aa88438dfa389c4a7d4eda562bf8e69315fe54ac9fcd2f104bf6014216e2ba18673e309e41cebc28a21ab114426804b37dc2133c4fabe6f2319bfe6065da3e5629e7621f2e971c46e895dab1b4714dac0bb1650e0e960a7a77ece4d9bf98dd166299610ca9128880e5581356581506e27a7576caed260d264a24397fbbbde9d8c8e11ee3e6e94e187d5e8b778f1df340565b1211fbcf6194622d500257eb475fc3c8dbc080b7d1b1cd51b7b40ade039da573d5c6863bf2b3e2c3c2348f478b92e93b1b7eee1fe12b508381f540a505d81921a55b12f1bfb3d6934f937e5e585684e8c3b4ae6a637ea51988af4b45038563c5f6a54c514f914a0e4ed7afa61778d5f898b13b646b6cc5e131db0b1e08fa572d29af64eb334a20ca70c6dcdc73534591b888fd64e41ef8a7300b49e51fef1d832cc9c6acae8eb7e88bd799146f9815f248f2c432db7f0764bd719a1f0ce7fe320688c63c39483737e8c5456daa9ae6b4c606337c898cccc9e4f14d4df0e73ceb3c275de6132f2b57e1535ee8a2b329ad541a5851a6aede70cdd9cc986d75c39f8a19c6fd200117c23133129c03a927d1b5c3d82310d288dd584c58a00dbe57b101c7dc5391755327949a24e7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
