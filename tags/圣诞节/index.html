<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"113ec3298cd9e815822485dd6da749d61608171b7610028ee3d67ed2a40c706a68a9147b9315c810ef0d539cac5146ea033c1347fc09c052d37a19160335ac6c7419a929ec99ed48abec7bfff53d982d7bec95d65906343b855fc51fd627bce166ae3bab81ec4e714db65406e37bd3b64aec7c9680cc8cc0a94fd7f3416a11ea051a47f536c229342a88da3b2844dd5dea7e3570d1dd571dd2679fec6267f1c0aa1cda8b74dd77b5a38a6c20a63fb4ec8166a79de7302ea77a444c2e0ca20533fd9aa0b42daa1cc234e0377ef76988271e23c8278312691622dec1781b7e61775e26374fc46b5725c74653e98505978c5dbe6c44a8cb8b1d618b18e9413999eaf12dbe9c7c5eb9be0489a657d9e83b9c66f264ed1111c2551f2d4b6bb7f57050695161c817785091778df8e2ff593863f5492df7b75aabad80781e86765ffc22596b10820b17eeb4563be639c1b67efb4b26c33d96bec455df6355ebdc787414cc664b34ac6b20f3b455e707449ccd1794c84f7d9281df2dfd6c855234212f31a6821f4dd5b2b6ad932c6df935dd217f9c58a0060e7a7174c6dcca08469367809879e1d35b75a18e36d3e5c6fb565506a43850e95e4bcfc64219c9521e7b6851be7a39a9e417e70980ee6a5c926b88da1e196e87e0e58b0090f312376ae0f68b5f1b87e9dc6addc0ea966df3baf3c9b5c05127b3904a8b1f1016a82805e388ef9f37e8d5c1c4985289740cc879f7d5581a290e87d4b73995357477a07a9329219ff4b4b640e53ce0a8235d7ad29bf029a54b5b7960d0d27fb90401d2e94501a75cf7f5fd0f5f56c2fca5175aa565a4d15cd902db013104d59285d00cc5bf8374befff0c1fd9f09b93efd0c3e4f89e535b6c4127f0a8e4d89186b772621fa0993827de2b0a8db7ba87dfc16197c47cdc47ba054c5e49318b5d7289334400d4e67953aee51e8d53f32c9ede5cbcf746815a4c7c448a25f5b133a6bbb22fdb7b72cd9f2d54bdec967c13826e02766419ebbbd32a3638da91217c67586e32328fc4fe28c7feeddd822fe757fd4c8333b649a68af586b23e1b43647f1569cdafa070cece693b5d04ab72eaf313b74bb64dfa52fb6bdb2eafceda8997959d890a4b1b3789417bd8db872c7874897479136fda1f67dafb614e4f9d1db1513d921655418947445af212cbda12d30933fffa00ccd9ca1d25bdf330322464ed0b05dddda02335811dd40862adcd5dcf299103f0e691141863613b6f080be00dd9a7452bdc3cd46f48cd512f3af9481d2b8604393be366accb6724aa24867d0cd3a36194964d2c81825f875ebed344bef73b3ffa50e261d951d24ee5c741b9985cc938e313592f394936a0a6c189bb87e4f441f0531188cc423908162c3bddbd5ac76186fcb7f77b66017432d2f106459e58a0b7d93d6fee7c823954344d3789a2e27ff12b05842448f1bc632eb283e62786f0a78196a076e4f9e173e02894e5d29f916c883c35a8f5c4f05814e60db240806bd8737d45d807c56be64fad6a7689f76355d014d6304efc5589ea58b8d4289c8eb54fbc2d88ec2bd45df019abb96d53f2ae07e153ea2b295506d9d65d32cc1d5e863a6ae0051657623ca2aa9c8ed6c1fd1efa96e4d931ba492a89a29920c85bf9a02497a16ded5147cd71dfba4d00dce9dd9115ac741b79d0a80f09c90e7f1b601dd5be5a8d0ea7c10cd4905c2a319d062106a15c7020491f661e2202233b9395e17db36d447467bb77f4e2f0a64bfabd9031bbaa524aee433e2d591d05b95245671657f904684f733393a0186c50e4348254d6915b2b5bf9acab82c5070b06eb2e45081d0bd33d391add0edf2440b7e96e02147125e66971507cc511c57958a56f0cd79a3ba55a8e06067c5757104006f351fbcae68010892b134ba664e365429068b22e31598c1808c2257d0d6f930596be73ad3dfba499e590fcece5350fd1adc57a3267e9295410b9b9653656e826e781307788d151cf6d38c497d68818dfb06bb009fe0b32b10dc5a4cd548ac88273acdde5b86860f8994b3ed3f8433b84662ba18a7c1df6f58cfbff4bedb0a3db1ab312670a7232e9613eb77703817b39696f322bd9f487a2c5ccb38b1f5f3c79ede6feb790f195a3f089b4538caa3c58e02735c40844851a505aed4217d9800a43bf76988e3cae6e7ad6affdca14357f33e2725844f42577ea526925049195b854bb4b1fec6dbca9729814a57b289b8ab3f477f3faadd192c4bb91a122f16ade9abc81fe8dd9644ed39f9f0bb0f707daa0fbf13446e2864b15f7edade70b5762700fbb5ccb88daff0b33bc9ba3069f49e25411d1fad5b2aa9f3ff4873ac756dafbef4611e09bf0fbade5f03eb2d8a7956e85154aeb51bd5df8c40b2614d70960499132be7c0490119dad328e57e83a851b6b598784bcebd2f26a1ea7abce522e5ac2763e7534d52cec4ee02e03b3d2334a63382d011fc7fc9e09045b7328b1ce00038de22f9f1ca9f44bfd25369320e604609ca210c745437f6d74ab319e41c56088bfd6f2157caa8a6c3273325012764e950d7d49d0a60be540ca24395c8957534560740befd05420170e9b6ed323a121c49bb7b144c6b18d2131bd0b4e3e701c101b753a22ba77ba45080415e89d60e1b5a57a2d44d3d8d67d9c752325b49d0959d69366ba9deb2c076eeaa59d6144dc8ffa9b6d653a727b9435d97a693b7e74a296ec660f03ce33c45bb1e0fbbb3b8af962f73876772276f901dc55f9008682b2ca0e2b95ff3c168d083e0345773ee7eeafae3db505498ce238555cb30d119c29598c31a536493cf6e9a9ed9ab296465d3e3ddf7f55ef1364ec618e703cb5d341616ff220651edc1386b408084d4ba074307c2a709fd450ebe616fa16a441c430ab2ae24d1e5387671ab98a6a8b8a43f9fc863c188504f51fdb6b906eec47351e18dfa9c50e80b5c6cdb796544e8c162330fd230b0530fabe8eac10e029d8c7edd47ece946504c61ee9803b4cfc77a9c3f2280c56c344f9116ef798bc4ea5b4aec086ec6f9d56eb0125f68d995546d6f7dd8f3db67e001c1a2c2b4d0427f6645502686c7bce48b6be2c99f9a38f66a388381f7f2c6fc8f5e963622630b4ceeebf84bad6c70b032a327fbf24426db0a35f2869c8837b245b9d1e2e331b7b160d7c4b945f816d6ca4fe24a517f2abcf67a8b7282e22beebd1d2a550cfd77a9f34d357bf9851f4a6023c54005dc3e5c35e1ca7f38a9a38cbec8c7c8e9fe6d6fb9926ef84ba1ab6d124dff603eb720015be3b0ef7a616fde25c756868673a05b983d859ab08f2713b7db56692ff7bec1714a6c7da4f867cc9536ddfb604e54e4a6009fcb18eb3c42fa4aef68c29e760a6e73f97f0b5764d3026c46d2b315bb97dea16fd25a890576f0f1ec538b337f0517da94388c535ef6058344dc5b0d22c883700145fc5a40676fb263e40cf0146bcda3214f04e1e2ac656cfba485d002ddf5b84e3e8b873f17526a87fc4fa29b14727cb7a7681ac3c2fabed790221edf56f39c84b3d666babe85cb7b64977ef42c9e5a63fdc1ad916ab87b379c59b5e6cf5ce15aead823ebda876484ee0029b99bb08405106604e016413d8a34c6be277872e3744ea1d5c75cd63d2ab313a560847356629ba78d46fd1f9f788f42827c583e7653df5b02f99fb7b3c9efd1e99c27033d42affa86c2cd0d7beadf3573352aa5d6bb5ed6b1318f0748c085f3b1923e5ca3cf880afb5cd6e95b5696e234b0615efa6abad76e12cf4a1d4a19f8f21cbec260acaa6da6efa5fb0a76056a48d6b7d7df0ade3d2d7b1a4912c7c5e20e896be695d3ae312387ae2e2c994499094187a4224d1dfafea8d7ed284bdb3d28ddb1164175952e267905bb7d440bdd2f4c43be483956b8ef3e0838d74c35831e0201397b8144e277df1e51bac34e3b7a838cd33b90eb12c9faaa539775959e7ab4ffb3d078de874079e735d2720aa46775d9055812fbe6e300a78d2c923944e782e9134b3f2d4054ab73734c3b307e017e83291e8116a36197bfdfd67d8532c48c52d77c1e8db031bfed6a13f4f79e0c302f42e98e57cba60ed7aadd738b5c4c53d03701bc37dea938e01a07b194b32ea05e7f49e1bd02d03e65d105179b46373684c71997e8c451fba72dc42d588de4c0793aabf0d05f9b212095f89e3dc7bbddae48997bec8a8c513be880801801a2b5b04033168c5206f9702f681744427477a4ef820cacb84d57291455adbbcea9481e8bbbf79194519964545d13fc184206feda629d4a8bc5b99033b9ed6c804fbf125132538698a17d2c0ccb34509d4f1f612a36877410f1773d3d26beda05473e9f4758f1f08f2d32a3104eb848783778f224b6597087481842891a9768cd19c23a61550b47fdf485098512b93ae9b9f8364ef203931f85a0a5f6fe02f3bdc22c5098afe49241aeebd580b3a6ab1dad37be63e901b2e048c75885e0ff9fba183a99c7e4c158d0612515a383bdc480944a98c6fa3447476cb9d97af63e290ebd038d062c0155686bf0d7bf82f3a5a7c2163151efda26e6be729a5a4dd0b22df96521b9d435a92269a817c7e07a3d086eb29921b0b67c02258b092de4fa2e3d59df8bdb179dd7349158cb096482ad7c90368a66537e8a11d458e8c1a181d192f91e1eefc1f3aaf36e5650ffc7431f67a40add26a3b3e480daa4771eb11351eb1aedbe4d3558874e19b64fbdafbe2bc743b662d88e8086a4b3dc32ccf55a4a8ba9144a3ceae025b2ed6905af18b8b7bd4471e16291fa48caa0a2fea95c486214c3eb2702d6934ef8b48a2b0403e249fc76d56704d5bc9ed3bea06d7d3f0cf48728a1ce3d66152690a57214acf5c7a40d8895871da952f70746bfdc93a0e2a99ef5192ccac377adc0ca7b6503176550900916f36314637e65242aaaa3816975c97f9bf7c4153002b4959f508780bd6719411f351a341220fc2ee347c691a3ca070b78416a74262c18121bfda882b9b51fef79d27fe5581df933ec42c855f99f78ed82e90e602d5d727a37c8c1424466f63e013d774864cec876d2dc245c089e37f17c940bd6f84be2126bc4d6d5f7bab007c39c744c3925f28ec6cb21689814b676e506572714f0d60302701e2a5c273a9d42b28d17bf768e13f411973d9db0a542bc23fac833e69c5f9b9c7d825679b5d8e898eeb03a89379ee03437027b872bf69705efff529b3ee42c15517c7ce0b467483b517f007e154cbd065773bd5eb9a8af8feb54db6cf437ffd31adb1693c59fe8d28a11f420653cdbb6942aa32d4e8e2f787ec5439f9aa156e649f82d087d4891f8a2ca8f9816b7fbab9f1ffd22d10411037e497bedd78b6a13df19e31293a5a590c788f74a2b48e2afaf60d4c1c8ae171eb420b813b7b9e5d61775409de835d80a003d0298603c4e93772969fa2605f587231f6fb68ddddcace74c31d910a0899bc7f27e22d4befaab46da0ffd22be659776c4b6cd9b5407b68210992b385ea435767dd750bcb9254c26e3ef39c918f83865486042177f646670cdcc39d2767af0925d15d02809f6c88656035f3df05c8947eb5ffa1d54e6df73832f8dbeafdd725d9c441ccfe12cf66aa6665d965832ceee450230f9a88e8dc8d2fe7485098d5b3d308b40c20376dc0f9fbec11fbc5953b82be8e212f9a19ee651c67a4e28fc2d5a647ac59a1a8cf0b0541128e305344c9fb052ef31a56037a6fc40957e4e6bf62ae86fb3c4342dcb8a5f5a984ebae2ed531bd3e7e0342bc73745456e569dbbd5e2d60955026cd35f83a31c030cd53f14d9e9a1a4fce36c6147baf0cda3e4119b878f961393659d8f0b16db93eae7ca3e01641487111da79c0f22e15cc0a85ce9016568c486790013a360ef0ce76b1e25680e616a4775b0eeb82ef584a52be0eab19b2453bae3e1b426c7bcb72ff76822798338ac175b46b7b9eaa5849c56eba7db94fa576e22715368ec396df54b5c1439e19446a54ec0fa61ae38d855a6132ba70dde4b015cd8b318ea926a559d7d5599eb588c0968929172004ec52ac38718f73b4ca64374f2cd9d11ba7abbdb8a9dd939ec2f279eb479a4c84f8571cd058c48411a0ef5c5cf927bf2c9a019ef9340d47900bc8ae750c649cfacf72473edc472011a779dca0e1b1ba1754b2447f31e4d9c57b15e919bd22366fe974beb9f48668ea94e16b6cdc31f25f399057578e58d9f592e8c7ab76e95fdffc133e0c50737e4cd773072b1e237b2ad56cf06bd9a289a281357d77100f0c001daacb2be4bf59a628ce05261954a7dc04b7425ab0e881dc272e396a2f3706ce296dfcba4988f1150dead2b2096bc1b6cd3cd4c9817b02b9785aa87fbbd31745cff2315e38e40b0ecdf14fc489df3f885c7cbdc174cc34f01c5b33aee45af8417e0b56210f3be174e68b754ec117e6395be7ed413a58dc4844b2db8629ac4850b2f6b367d7a9436671d204c4e0ed9c7b0bd05dc1db008e708fc0bc23a09aa83416bd37eaa61dfccb6b74de3d0730143457bd5b0e6747e4a57b223a7a3270a4625008599400765dd6744811b80ecfffe8476c160fda56c834c95411a352afcd65c51c6b33cb02ff244843f51b44a3fb7cff9020155b8a86b160a234694126e54aeae498ed22f77de500712cad865cc0de7a9da2bc0d9ebca81fa0d01e6ad50b178d3fecb2d1619a1825ee9568590866adc15c05fb46cab98dda8aa28db41092b76fe5494c5bb3e8556fc0e60b2d6a318d5368adb0b1e72579dd9c9df4f3f54e17eeb9b56541f17557e69899c786750490608d13ad9b0f511cf8c181d82f5a1120854945a4ab0c517d72a964bdcea92df72f642af67d8c823eb4577581202188b3fa642cf0db2ee343d2e40c4d6cc74cad472ea1a05882cd4508eacea6e1874df0dfbb78531b2f1a0ed4e4334511acb02f910ef5ffda5f57db7cf19384393ca4293a4e1e2ef8b986a9186ab446f6f5156f7b9f1f2c4d9ea4518dafaa83c7b19be2673ede38aed1c8849542f70b9fbb9e5c67d6a56cc42c6375627f07d267d48c52693f1b5c1e8665aef409bc084e84ec761a794aca1c4c67bfa6f5dbd1927c3adcc482c4ce4f5f566ed88896cd94d47981fff172be72894148fb5ec4114b1cc4a9cdddea02517d7ed710daf8f7d8ab99942b9453db9996d3c470a72bf829d72a8b55e1c01de75454c33f5abe701abdc8fee5348a97704b663a6884b601ea1936131a8968c7cd39ca5f68827b1f2021ef6b76a2cd9f7c7cc59a3b29f54bf0e87f5c562743bbf08f1d2eaf3ff6903e5f4977d04248f37a4000ed989bb4b162ce2470438cda3df2680d904c868778b91fb482af202bf628a31307e22d55a5118053e77cdbf06ff26525d991cd9ed0b8a4bfbdd44d66fae4b9e179aa661fa4349a181f6342db1b84cc495a5f7d04917afdcb691cd3611f0dafde043b3ec4f3f48fac74870e3beaad241d0b9f571f7f40207b26dc9afac883cd294d992f4f1010a54487aadb386827685c85456b41ade1a900e5fc5fd219bc6c9b8c7d1ff87f51369b24c9a02eaf72955e0a852dc1cf801f4703cd1194338fe824528c4930025ef5019309d9d30ab69cdab3a67f515fa6d74d615cdbde6c1a36e93fe466cc881d4524e0bc89957273bacbd8becbb55c702700996a54b41b81d8be9e90378d18038b9c3bd60f2961c0d64bc391a0fdf8199418a7ed1fb8c74efe6beb8be21c45f51f2a7881ae95dc6d06368875a495d359b9428646b55704a4b04975ea3c67d9e2a5bf1d4a42df7489ec4cf8d517221ec2bf8b588aebef12187f3e5cfe0a716115f19b905083864f10782a6bd68a907cc97c015c72225fdaeed2d114ade5cf54a378e48429fad1b5a843faa602663b7678114670685bd8f4de04acc30c11be120f7b4d3bbf99df4280fe75fa8a87f39668d6ff2c50aa227ddd6cf44539222edfedaab22eb57b46b3415686bd8323f7cba99dc74e605db230f700f3e5ea2c6184a3fabb8d896dba0c38688e26d505a58e45da22c355e0f791e95836fcdd1f08170a48d4227b1308d970f7c5a2f4876dd49d47271f90b435b1a5a670aaa23e68a0a2aa0778b5f1bf9c065cb831d6a1bacb91c130a4713b938a3e1bf44c01f60da9dc722bab7f2aa90c9a0ac71af21f679f8b903802ac67f5eb8fa5b24efa96fbf5ac53a481077b19520457df92f0e3ac4d293774542e62841bb4bc811da7ff4e00ff1783081bb68016bd766190a75b1fe2f6585e55288d8966ef92a46093121bff372303fc03cb1d7ff0d7117a1ea2bc74cc9d445d01871e075a24ba869c059c388192556158673d9fc6a31bb7b8643033bed26c7670b3da4e986f105e5e54f7dd4943262f49675b43de3348c488f9086cb2d900304a0550b1cf9bc08498878512bcf289c9e07fb1dd18d4767efba34fcefaa522bf4f903e1d8a8c39da07ef547c7742ef200089f9a5b5d91e1df10840e4feae4d669aba5ca87479dd316ca747e74689d9c1ecbc6a25221655aeb5dec2d1f892652a2e1157d7a0e68257ac880cb4fd225c79427c4e60a9306eb10fb7dfdf104132c97ad126fe0cff0adcc6d2250df63057bb849fb5a57bc8da3da051b286fbb82c91e5ce1138d83b2933a3fedb8a043b5d72e6ba97f86279edea8bb3e4ac3b9dace7c0d4e4e3e429ee5a56494615c3a18f57c82c9fda2a9fb412809b43fb26833a17c69e25bbb2cb9fae1dcc129545e994adc2355acae11c1ef653234159e23051276fb8ce112466e4eef7ffa21e59767c6466634bf689b433b9c62b767e63fea5f81b963c4189539870a0cc3c20f022755ce73ade8f082b8b5b76908b799b98e2dc1067b2939838332b664142fefccd599f9a89b83d7e64bea197bf3ec28ee537e485ccaceda90f0f91fd66afa0d655ba22c9ee841919a554e3e90d44381607ba70aaa1442c5656b67ed5c08195c3a703af71cedfda72d4ef42f23d03cd5c914966e06b38261d3a86d42f7ed3389fa446f121e155bee56345bbc9f1a0387e43916b26ef328b032a4449adabc901ce127317a9167795abe1786f5dde4d40365a5800dd6d66f0d741da3abea01a3cf304f75e576f02ea53d868bcd113e905feca510aa5fcc4f4cf7f738b14e4657ffa3595a8952cca49b5069402178889ca8810bea4ccdf827625039be0a2c37ea5ed2cd1804559e05fe155d3d01ee0b1acdf03027ff99c0f423720de17ac85ea393534e36a850c6abe9388d5532a6becaad0a85b71b98d9b6a15eca869a364a88d225a908b90b53825ed90d57b801446054a60c1934daf2a8e086ca0dc86d5ef7cecfe5ecbb18a555b27a1875bf8cb84fcd4fe3bae879eb5871e3742cba73e585062111cc82886f6c74be9ef16b20b1afbc95ed29763a4f447ca14e3823c07c06bcfb581ecea6d99dcf70ee8ec6b02ba0a75f9efbb445f694394c89c3631b715d934a54425f1efef0dffeaba6f9a818159316539172dfca6723e5955a096963a009c914032467164c64e99b4a838b98f49a4cd3d0237b3f3fb8f92cb0987325b11e644cc2f4bf8b9df8d4ed1f7ad2979ab2e04a6ce12cc0099a58c2b66f77b30166e704641deb154cb7756b4de1ac5b08363bb56259142423d33e6a38f722576b0cfbe0ef47ab6d6ac3883f5b5fcd180d08b789e5abd110811e37b1577ec084410fb6a60f8d9d769d128feccaa2779b234c88c3092fe5c23a2e0d0354e014d5330267721049f6d1a257820819e3b8a37b5114d54579a61043cd53ca201f656c5fff133e93b0be6adbf50ff57312bd5623718f3484912cf0e93efadeceb267cbc3798ca27c37281ec2eb9c28629be232a02f78a9b0acedeafc12f720b7c67eafba38b32dd2fc32530e614e1491124eefdee5e4c2464083d76482ffbd2221281f43d696b038f8f3b7074638848840bbdf5b03b67789127b29d462905387d4164a6bcc3b33daae560521e00059032161e2bb5c2872d0a4ca2a3f606b98f8dffa0bcd67fba10de73d01895e64e99ac54ea47891909af8a5f003445e442b26c72f209246e8cdafc622dd494c6cd55a3a806426414a36d4589328f757fcf5a14321f237cfc3afe13dce9fa7be50a9507872f2c30325f4708d3b4b791d3f45e15883d9ee8b6a7905b3b5eab856993358bffca2dbb18f1c7ef16bf729d0d62215035cd99ab9d30d1e49ad1296b7e4f44cd08283ebbe26cfa1394e156de63007c11d0df3367ae1aad29642d205428c1931d067487663194157d2db00ab61d0086ecaddbe5c232c5b536f84aff8c59ee137c7e3f8b8e8af517921572e4fae0ce4098e3c0cce4c6c8912e2dc89c715da41d163c3bca9bded2c8f84c55dd7bd4d9c237e841139af7fe52d8bbd2ceb7cd4304205da74a9b5e7fb87c7a1d2bef603b31702cb39886ba80a143ca1cb3d397e2cefddfd16a2903e7078916ce5abf880a9ee58e128da630c0ae6217eb8dc1fcac7defaa05099e5b10343c31e285570253ca2f7c5edae0d89d5de20b0bbdb8614f68ab847d57cc1740edeb8a01b38f113fedc384008247cdb1d084c7f160ddbf25affd8d41b1b9890233109817e272c8c63c9fe70dd8bb14843492b2147c17ac15739f0abfd1a4d5f21f3b9f331c1c78c32fcef86982e689d3b49393978b871fe41909de49102886708a2c8738b6ad7c3b967e2bcb9bef9480a4c39bd37c8a5fa8a8058bac61a6111d81827f62e97cb7fc01b32780564766feb186212f087bd082997b76946caabf1bf962cf316da890db643f8ab822ea448268ce86b254e4031680db9d2e75dee89d2809b7926302a3d3fb9c2982fc812c5760e4c0de1467fe472e7abfadf288ca149181895bb3d16521dbedcdaffe76d380225a135dedfdcd4020060950a0e62a43f0a91ba5124aad2b5d7de18045ab5c644cb5f78ff95d35d302b66712cd2addc726c1b45e51fda267ca0b34ff0456a8d4c7f557f7dfaac7b3c4f49a97a30703f0d5903538893a9026dbbb81aea91290722e926276b31dd304b05ebb38aea9e76caf2ed6237b018c3de351138e8623b5707bfe6715948bf96fab3cbba8ac2ee0a64981dda8ec3fff24ad570b5b283e5e528db13482f94cdb120105399f5fa6110e99c5be96328dfe7693cc8a522b0109c87e919e220b63bb2d77579f19f25b55479ff1ce239a08a3559bb1d4edb1241b1997487708c1cd9b3b66ae529fc88007b9d2c4984f22db7f08185945a64442962c79995d8959f9252b4ea638d24355a2e4790acfa536ce48239608c407b5de530f91c458044a6892788c76ac8a44e18acfb43b309eff335e1989afdba63436b09ec067383c8b6192b3290d3f28a644e1069ab24eccafb8a9a3ee3e118cdcb29bd206178b2f51b5e6787f2bfbfea77893b597f965bcf677b90083617f63f2d4e74841150ec67ca737650575ba6f84a5d7b40df45b7bc0d2d335ee64a9c7de7df123abb1443fdedb1a089e4a98504931fd1f7d28979a947383776f94cbede9d4c4e872144e99f56b55c2728977a3d9b18c5513e36266e2a2d935462bb7e5eedbea0c73f0b929c72a344ba7afe3104a6ddb86df536c60a74bf56ef86581db26b308c437fcea291f5d2106d73d06f000f7f2d5e7f84d0ec690237e2e0c481ebe03748667ff0f466baea73302f866d44110d525f6e8b22d1701a1772cb719856b9593027c47ec602c7d4943ed57d1f8690e0f6478b29bcc8ef1fd607a13c503900b75258af87d9c35ec09f74b2af52d14ac9c73908a3645c0ebcb2caa34c47ae1665870bc29cc502ff7330f52e478e05502e89a2eb6257c6b15957b142a7e63338a8a0347e517d2d3e86a12bb619f65aff5b2531e1fad7a7e8a4be5ec03c46240911fa664b5f87cbc86195870e8c48510f4e2d4e5322d544d6ab22d22b78de4f4a4754df03f2e21af4f69ec839e542d2f3fa5b3b686f362c33da53c3e2d1f1c2ad13f2ba34b5c53594b31f6a7a8780f5e8b7c1e58371b8f42271ef086b260185184461a44f2e7f63a5882fef7765826e659dfefb5519ffa78ab4a1f6548dfaa64932da2b44ade04e605c4e47d6fceaf3cb901537f1a3aa8fe2f3bbbe1442a9795d166bdeb1e7df65f9d9c0446e3868635eade68b6081eeeeef9360f38c3cff83df5331b6059ec5ff2404bd8424ff76c1d075e167753173d0a3bb2f974149f86c4162ab0aab33d53384313086d7333fc3b54228c2cd80f0c832ce4a06ffed95bedfda44ea9f4b53c0d10cefb047d67f3f63cec46efbbe1d21ce085506488d098aa52e12dea550a7ddf16a8ecad18b897a8a9ffe2a63b2e5925f046155e609c5e3a5d057f130690cf3d6c0a69334048b27fb171213a95e47f62b2691b02571fb19191ea0704cfc0d172f23409d55f5eb865af3b85ac22e55513a20f763ecc3d5534f4bcd9c50f70d82b2609293bfcba3c85dea24e2d1638b2bc8acad711f8f0e14d7d1ea51f2e17932c419fe7e35ebb4285353ac3f427fc3f0e8718baa5fe0aa2be98e291318af0901b1dad81555de7f16b4882d7b32543bdcad573b58caf072d2d5c513ed64bf4f9868981bfee99a9dfd6563187117ec47f6c5b0b06e79acd1b16b22fc5bfb47518fd7eb4a17224bff5d9bb75fcf3bff38be1a0b3f5d738cef952ec8836127e8b7b9c558084024cd83e299a3167986b8149b3ea40abced842b58af9fe8e454d62b621df37772803d916b9cfcc1cad070eec0695bcc8eeb9c5477042f3cfe8ca482148fef3ab4d1c7307b71b854e6b46eb28800956c73ddadca1ba203f735dcdf55adb2f48e84109adafda2f040290200b8d7ce434438dbf0b72f3a9193b07819d533fbb13a77acd5173eb062a374722098426d26fa281aeab4ae5431ce47701f42a2378dc5f52ce4a44d3315c0a65cca9a29d48287ca8b0811c36a504b840000d71bf5105116b5ec9f1956778885c2eaa02b435ed966164899774b893b800051607034e964fa7eb4296108a751849c9cf3955443afb6599fb0e95b676f359bc16c6ec6323ed7890dac773cad05c42d111750fa97912bb3e10b60d4869645818d7bed377378c03bed162873021d9e68a47225bd66ffdfa94294cf48b41fc86d4e659a71eec17e2541807d0883362532c37739f69e0123d446d1ee3317df4c9af67fc38c70014c3f06698c7bb84c994c16f548823389711637d6994d440ded17694a5d3bd1d2417c5b2d8f187ed2912cefc9b71f126e27bf83e6c94bcc7f9617f87031a07b8ceb3a548ad9f1c521676710a5859529454d4f347a3d6b6214c7f5c6430a04f72601e5e38f8c3d8671ff785e5245495eeab55dc4aae30cb16dcd6b2f65b194cc3a504a7e58499516bb92746f63474196f15202fbc525245cf8a0cbef75875923113bbfb661e92a21aeede56a71f2eb6d1f4ec53ac847b4b41db5a6ec59a3acc5a54eab685b1882380e85d767d72999084e1d86b55deedbbca4d2046495dfc5de50cac033f887b29006f4b89febbb5bf93b949fdfb5e5e5ed43b8365dd412f510451f45eb35b3265859d0e66263f20e320ca0e8cc985fed1ae05fc5420def003bc9bb257cfd8ef15326a42a08c03b97e32041465654a18228739acd29ddab061af9814002ada3e552d234ce23c7c930c32a92c9fafce5bb887d513f8e01b4081102d142ade7db4d9e6f50bfe6874a0cdf83dc2b4b190de5f83f62c3dd8c70fe37d4cbd477a1e52dba6799a0e800e3bcab2e783a041db25ddf97ed0bffceb291d119abb19953ae3177df57a7e5be004f87162b5ce78dc649d340141875c355b3e3f915f65bd7e51510955fdfd2fb826cf6dcccbf996d475380c2cace325b9ffdd37f1d77aa6f4b883d200804c5be7f9d514f00f0d46b1d623863b60086a4cf775930472ba3bbf60cf319214f1012798e1710f7b818e979de17f9b0ffc07e15a301aa9f579114a3e9999e0284d2b9f53137e0aa011eee75953b486dcb3ae07791977e63405ea48c0b55d8954fb84c4f271be26797b85a4bdae11ca3ef0766488775a40dfc68357dbe26f61a0d99eac18ab110c0f9dbdc2221fa3099a8675bb235272fd8656d4e1018642febe94fa6bf7c5a064311065952637159dc193f33019cbcf00dc7a2e6d3321506c4d559c75a674f2e74ae4e4d25b05522f6b2899e887e08f68fac35d2d46d70c0c69cf13a57fa931d15d7e6304ad12bdeba600366a761d43d29994946e57056d2be4a14220b0a2f0a87c14ad0de6169882749485f015b761ddaa648509957c6dd0d99cb6e3e6121cb13561afbc1ad0848bd13ea6c1cb53f374d0c95cef1c2789d9e65cb4869d00fd45a19df003e46a15de3f8227a146aa2ca9d9d045cd8eec94125958008a0db152ae88b2236469c705bff58b469439e176d65d005a44bb0c07663c09b46be267c4fdaa9f9524024d354cbce1fed7b242097e6c5e03afbf97664dff435ec5dce49a05e45e171eb7c80c91d7deb22faef64c454761a5ed134bbc86a91c5a5e9e2ebf98f4a07646b8fd77cfdaa6ec02a0011c80a71497c6e28383cf697301da57a6127e43432faab555a0233ae1d50eca52c6ef1751ad16b41f4cb9faa906c9fae3c2e37aac9a8a966b5129f491eb3b31f4d5fd165d4dc45e94b60e08fffe7bf98583b795caabc1489833b13083ac5a9577b3910a17540a19c7e36761e377ca3cacae46bdc1f7cdd4394921870787431bf91fe492ab578ca431195208a5949e15c5889d14926b3dc93c2b28d123777319eebb322545111206d1e7c14f5ea19b897d9b903f2d2c9aa3db63fcd46e1f266316724bd91b512f5db8febfb3a60666b3a2a372e1d6166a164e21651be87ee8daefab9a83ff88a011a9091a9eac69e36eb7284e92a7fc9247239ba25e81a51772d14cd436f0cc536321f8becef52a67aa98c7a03c815","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
