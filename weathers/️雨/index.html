<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b385c8571fbb6d61344fda6a9117e5c61181fea4d75a5b488d5260584d940ae0e68b8e424c3f107da6c7e2f8c9d1607238acea64c652e9f99d64fd6b8f46e1dd01c7c48ef5d1209adb4fa3cd8d57e1f446cdccff34bac174b69dd53c2416936d85fa2632b403fd8c452581655bd514d28f98bc041dd27d38f69c982c318dc7b311bd4661122c657bbc6a5f4d28e50685aa40bef11cbedb53dc428b0261663c0a5b543bc7f3b94f0b3aee694d783e5ba95541f9196897a1e85e358a78f8de49591bfba58082ec93ee1d823375ef2ad754aa2e79a73f05244e6d6a43a1ee9393547af93188152a58ef8caf3a7e0ab612c695b52d33dd7a0708766c834c226e7ff7fec6741ee2e063697df8ca359b55938eb96e1032ac517b1bd4c495b9c3308b92092f679d53e76a82fdadddaedc40a3acc77a0f8f854e5e514ec1bcad84bc30bb5223b0a4e354f92fbd2741a9d1e6e31e9237ae873d7284dd0059b54dc2c0e03b595f7b45cf4edf9822e94eaf8a94d01ef523a907afdd2481c711335c46acea46573f9da87245fb44f74d40ec1a3ab0c6f9df1de943343cad7fcf7e8580c7ebaf4fd0f1a07fc9cd95e82b631cf70e4295f8d53d3420635e77e267aef2caecc429ab7741f349c35d1c3f16d761dd24a49d0841f873ace5a806acfec2aad5027b28982bc46595d5f976b052ebe06fcb7d394eaaf920da7a01d7b3b94cce18e5ff6207371f5ed8008b05178a3b56003d3e10f60f483e6f944af8e330231f9857719684798f6d618c89dac5477caa5a279cf1ee580d38af130b8f13ca957d716c0342400bdb71feb70b0786890f47fea9ec43b359f4b6fb3133142172f4c64d5bb93a79a9353260728e8877e0d8ad0e3203dc8343fc98e82df592f1afe30cd5860c06ba74432d2323500f91dd25abbc6e749af221cb0e24570c6b6fa7b3f2b2775bda465696797583ec6f1f697b16757d7740be3a3ec0b980aa58586b7f35903ae2fce228c0d23711f37610066f18d4cc78cd77b04a4aaea6e96335c13f21661bf7d9f60af49ae3fd390a2b2b2500b2ecb071db8673378a606c40666ca64e64c9b91e718b7ded75692cd2cf8880b5819e3e1c0b230841f35c9fd1c11e0d306ae1fa7659fbe9711509830f7fab838e819cb9e6a74d5d70a89bb7e11c75b7761b7e537e7f75d4e89732486622ed1fa699c997eb6966c32ebfc75a88ed59bc807775464c5ccc68146461d612bdf5a76274011a855143a212e3d106b2105a27fe1b5ddf7ee96c8d33445f833508f9d57ed80450be4084a7c8b37193661c2977d47905d9c535b2676dcf788b12195be8f701eb58f8cfb84fd5dab54953ccf82b0839ea9dd553cb09ce152cadc89f71af27f0cccb783ea98e9c5b77f298ac20f8d8a2bbec96534120e6a16e83a4852565e7ab6a847b3438989927d80413c6f9ef1b110d1b8462e800f6449afb991e0ab39e2f387dd43c059c8767cec93acd1a37b66f4d70904f19e0d9ae1f9b66f7a69d62493b1478bb08efffcffcebd5e6b2724b93e6b8c21355200ed71b63adb2a829fa3006da1c4774bc04dc785df093b4ddd090f4c68503072a584423c988b0a9db56f2c495ccd5980a5bfb174b6212801b09044acf67d94f0440fcdf8595cde9f06d0f37455a3ec96bc66ae80b6ba93e8d30ce07f50c5822fd4dc3635597dd0f57009efcc5c2546d546083d6d6a20376981f837e02eab4b71f056e423a7916590abdfe5ec8ba83a4a22bd478a796aa4b74ecfbf1e2330b78326319a32305a8cab3ae21e047e1813af2f8cd23bee89561d1e103f9ffce8f5176cb34e86103c8271a6a0d7da7c2b11d842b9c99d393677de070f1fa0e431177d12216276ddbfb8a725a37208b07991f436f92558f829ae031b604172c45488c9ead3e444f8fe1b3ead4eb41b5e8921441af9af4002180d6fc6abb198517843ed6a162de8ff92b2d9cd518a9dda53efbdaf2c62dc6332790a698f30e34c3ea21c36bb7e27fca997e7315f9798c276519ac15eb65edf115352f9315ff9bcd7c1a375468c7e245b0c799a78ac61a49ee118b81c06a7288b1f29e9c2ee40fd79ef63ea8f3be30336483834ae197a8233661da77f940b7e477f2d6659c0c4b1ac02ae26eb7be638d566fce88354fb7ad5128841d9b7ed89b902f76acdb23d114cfdef4d415c6df9a11ecfcf5e8cd2f576e27eb7961579d54aadd72bae6eb1d91c9e9cc9b88750a50b7db1e613ec0d23ad052fcc68c5861ab89ffe06774bc9529822ab35567432b90f4797eaf1812799aa6e7c7c4e0e1408d184f61d29fdf4ee30633182856a3a7f264b016e34ffda72521135987a059fc9d150736e73f2da86cbf0056fc7116d466d0559c77dcd29cb31ab2e7cc9898d49594cc3c7665fd95ad7bbc50f9656b1f6e511abfbe24390bf2dcb023577d68f6c377b573586a9a7d1e5899941201bcdc78a601a50caf08ac3e16df7dbf199d7ea45c78cf16648157a083aa28a28195a50f4de12a7177a49c0c170118efab75cb938a6ebcc695838c2dc7d60833a20dae7d3534460097640bf6a6c930440b2717c247228468af7a9c1a90426e420ecf0dbaa38f213ffaacbc5f0d6438675a9d30854757127b4871ea2b68987b5d3fc1e62d44518ed3a4a99a39087d964af72ce61098050b2ad475f920124f8065e7063876aa86f1a63cf8e3dc99aa017a0e3eb6d6f9a5cf9c404935fa3c9f21101b1c60b106517eda4ddf559e0f5684d4bbb58e00d414bc5b4d6ef4d3cb11ef1da200fb1f87f1f824db0a2afce7647a47c5d5bbc1dc2c4bd6ee92e7a6f3f5bfb945e9649b7b81b50c1a3a519f01c2b96ce4c143f0bacdf8b029cfc71515458eac0b46904491ae8f24a2ce63a81945f63dea41c2423b2fc6510fb89a1f917ddf3b39106242a8f75adf38a61970ce442f2e582884bd3da1cd32016e5f2a7caf2da9b1484625c19ddc066bc29bcd04eb42d32e18b2bc9228136d709185ae30a759f8ac452ec4f620c2c49f9acd82a2d8b77ff057a80b17a7d3c4922f89702b965996af25db5ad319010e1ce0a19ebd4e77b78649c3ec51ce3743046796dd0aa2307145e8be0b8947f8fc64d0ed64a9342a4e03e4368d2220fee9049a0782f8f74cac18d70bfb4849a607a94e4e5cbbcffb0718c06e07463d5c8e2409e9f7c7b9e44b84dbb1485ef4d4a7f67e0ac9774bc733848cf1c3de7fffd522df7ae41cc73204c817851bbd205d015d068083322275b650148ac0d2ac4c7947159fa5f05c48c71c85ee25766354b97ecd94357f8d21e78cefbfc0fe6b50c98430db8f5ed7b945b083546050446db0f9a7c06d750757108848b98f2f312512e0fa1fe8fd9a5bc30c5cf0cd5cff1ebac792c6ff81278941ecae6b17713f9e571ddef7ff0e709445e2c59a3c4a91a06e8da73ac92492a84a6d10fe0f2f5f2b568b53659c80386eea8dad16bec3fa09ecdd6883544a338570dfbeda5ce4972057d2552188b897e2bdb7928f9454970f8694fe21d6ee573f94c0e8577425bc58006c94cb612e41845ee258b8a6cbcac12e29f3ea11b015a383fe06abb4a1a78cd630f191369aa1655766b5fbccae7f7a914c8b018c8397664e7942917d0178f56ce9b4a9dbce30bd1b91e6a1507ad5d99740794f0611a6d215f0743a45ec4e6f23c52d92120144f8bd569f182cf5a8b74e6b2df791ea687d07aef8d169fc22f1186e72ba3cfcb3e607beee851e566087620dc60a52375e00d6553d295789ef2edccd1293e281f8bbe57060913a625f7dbca45da2245af6c5dfe5aa0b89eb9142b1cac898b8098ffea3e3815f749f147eaeddb1c8c2e7ec3ab1de9967924c910ca5b9503180852ec4cd903a039094f877e6e9dc5a434c691657bb956cd576946086a283331bcd3f4f967e1309882c6c4606146030e74c0dad7632f9342ed9f3755ef97b6f5437af721d8aa382128e248302ce32fc79835f6f8a8714f6df5c41a3a78e213bb1c1a284a7deb04dc78d5346a08913a10ce8016855dddcd291336dbdf798c7dc1ddd307edf22a7b22a98e156a5929bd3888ff765df042b0f7254fc1408e07731a90dbf30f01d34f40b893c6123d33ae1396c7f12e6c3599027be40db915f793bf733e9304165d6c3b52eec09eba5ce5b52f6ee1ebf07d51f512303cc930e880a7aaa2257b926aa7d8745c8249651ebe0f6ec8de03e31d3bbda7311bb366f5481f5907e349bb42d5e046dec2bdaf7dc4ac016848bc88f9cc859a3e795d9a83c468ca5cfb8578724c26b8e7be5beb2a8ef15b5469e1d6fc5a2989a87c3ab0a2b029050b3e8de3117a3eddeec96c061ba7673535c0251f9d8c018654d7b212501db96ec18274ee56f0bc218af4d30d50e041446a3464d2a6d3792fe496322ce9efa1095586eaa55418d24befedc96a4e2004e80145085cc6527d558204685e506f6d84fe0b595c4f059b7fe1a476ff3393a80cf16e0c3bdd818489f652f5644bb752612331274eed59410fb1d079e0588264df69714636b993c5f2b0701829f85e02de29bfd5b4368b0ad3f41b75162644797b0b1d9bea2396b4f2813949fe1c6272671975eb18a3fec788a480d1c2ce485ed1c6fa6aa4baec4bbdcd7958abe2c47db36ff397d789eb368098c55c98184b29633cbb7bb317c727436185117bd4c2eab8718bf0a8f1e97f1de1605ab45819b14c6f59e0aa7f1aea644d5e888dec09c42d063190159e8053b93425690b864a16c14b60b45797fe7d9c0cf9875464d24322fc0ff68e1e6821889b19b043c38733fa015823b328889a83aee22987b94c15c87b3fcc5338cf906972e33e4a95807146ca5eb6bb56ec67221d781cb148479f4cfcdef9cda328ba97eb1be52d6e40de99920e898fff130533c9c93e6d1209baa27e7d539353095ec649f52dd8c2b59af0bfb638497db65a0395fdd6a7254ae43856f97995470751627c892c0fae12435b43f1f6948d32a558d8d517e103bcdcb904c3d7d4039625d19f3ba77db0f86caf6b9c5029cdc0ecff017ffc99c1426cc1866bd90f0fbe123ff7e2d019bee1b64ef804c946ae1db2568389d83b8a3befe56041f29d8afa3868042a09397abe75cadb342fb2787ae010f1c20ba783292ad90438d8eb52b935c404cfe14f2a6a4134e6003cf08cbd45af6af7e70fd710303053a00b31626c6541db302b7393288b94b98fc6421034ba2aae7e0914b452a0a9dd046d0bb8592a35f8f7af776e4ab4a0aab29e4fc655b23f69c2dac3e0d61cdee9f6421732a0e1d2397b77faa984f54d5a8f7e55b77367c788f80b88fe8b4eaad0770cb7fd01185a0feaf68b1f69fb53f1285649950808d242638b7f9d9054e53aa92c7e29a9f5a204913df797d85974092f48810190276410ecf08158bbaf751d34340874cbff1d12c77225c81618b950723138ba31464ce859eb2b345cb6fddf0c60d844ed9e93838cac29e384240442677b5e1c771615e5ad8db136dd0e7cb1212a8d224410f867e5beeed78a03b677d4e670fe6bee1967650f8505a9fe2137265c356fd9e0479178414ab42f43e3a5ed9f0f03531d932f04c35584ad85e73a71167d053fbedcf3def3c18bdfc062eafe1a308b696cf4e8fcbd6f87127620e1deecb658c553473e58b7c1b13d848a77d0e9d43176e394de4641d34ec9d8396bbbf227aa888c6abe4af6c39cb3e8855581dfa72c9bd92305fd2e725ab1b709fd282c388d1ef161fc80a1744b96a9edd902aa4a49b246008596c6a7f0505a8a549cc0fbaf45de265a2f083dde15ef5437211f7498ee48b99f47912e101ec2e6056e8a8d0be9061ca02ec0ec9575c30004807d665d1a8c424d37b2d48f8216c716e7905fa9c8b32cd7555bf8810dce1618cd090765938b854881f87ed6e799eadc12ca29c39acde5890ff0c9cf84da3e9ed6d4a36e5baab01e1a630bec39da4cf056a68d5dbbabbd0cded946796d7fc709ac8eac2497f4877514080a9923f8289d8ac5b5c8b6b314e11fafe5f5284f5a50fcb29587e27c0a70e7ef2def239b5120869f285ab418351aa3e8cdb070b8ce30b2370e95917fae79f6de5777ddb5378062e61ee9d39b921f4dea0422485e784cb6f6e797f278be81032d42ab14f625433dee26e51ee6c8c29db2488a19892146f99a1571e37739415c968cd8a832ddaa46807781eb726c20866bcef9c2650702914a03994774e8a23f87008b6369703d56e949f0d6d64ad46cb0a568a64a34b91c8acfcf7538d893de9d633cdce63d18a9ff1644716b2b71e3698dfdfee81c2c8402e3e4a381fcc36deb274f61e5bfc75071cb4fbcc1c4b9970e936134fcb04a68f0aec78e2742b2b504552775bc44ef8cb578d4f757e2f568bf243aff3e9a0321329ae23884c0ddf6161aae57a4c30017439b0dff3b3b3434c774e9b2d4009d9eb58f4331af190aa4ab9f153728e4f1016a1d38c8127afc4db7d53cb0518ca125a5edf3dcfe18ce8b55f7ab979114411a17a94942b66dfb373304c56314cafd1748af52fa3b6cfa970f3ba18712e54550109d3302c3c5ef8e5c5356ac165793b760e0c33a45bb38c44a70b924bdf29e51e3f56b90198cf0193401e82bdc8610561a1299fb605e99a3e99c3722709e3015bbc17d0c540cfd0b9065623c2c1c702dd9723d4eba741a0889d780f4f850ba2a4ff68a79ff11fbb7702d70be809915cbd612d097ba080db78b61870dd46ea8f99b55238508a797b0733c86e83885b5f83bb860dfb2ea4e1d2c75459ed71c91e12a160324b749f6fe0000cd70220a30d7666be0259138260e8693e0d25ad27b09993a6c1d7f914c4dc7aae514473600c44ea325792e408155546779afc0d61a1966ed660cb5f6e7becf9b6d8c48667fd59b9516bf6f4a00529e1ceee6fe205fce8e2a37fadfe3ca89ec4f5789fe243c40847e037f53f4272d94af3c98a7c9b6280fc9e05977f3291830b54a1de37adac0574e7325fa92fddc4df0e77e6f8c165a474b561b85b0b61288fc2d80f26b5ca4447950a39c740bf67538c5cfa1155fbb4f90b5e3e4abe4b5ed075da5835e3070c941ef8a3d4b4459769e870a2411b243563febab8e2cc7c3a01d6843657227e56a5c18a8b19e00bd33e9c66caf90fe042c5e4e69435af6a8a0bb3d64aff9b215c3d5f0302a1647be913a1573d1a51739148db6660671b5b41e32d795c3ae78b6e6081fce41b500f4b1553869cf2aa0b8ed879a817cf6430c34bae10c7402ac19e87a902a3f349f5dfcb1c328c1d6417da404bd73cd4e8a82f3420616d9d8648d6e73a182c1e054abfeb669b3feee6decbb297365eca36ef119d86bd4601f6c11cc1d3208aeaffc49b2b6a559b9f40ebd777bdd0e04e4eb7ec23f40a72d630b643a5ae30d65ed0ba362391bcb8b6b763b80701c16bb16dd422921a93848395b065d7db0970dca63ad8a4131aa23dbeb27859f89267ebd9b19beebc75ea42dcfb5c8da341fab1c5349d6287ba398b788dd12bb0905f75d757d2e551d3b6b08b57944660b14633ab175388c8674253e94da8dfc959a10304bfd5ed5104c7122023559b6788c15387056b3a641af24f45f899b7b33502582c241129fef99577b378bcfdeadcad75caeae9b0eace219d3c017ba99501095708e91e83d14e8584d5662e5f4517ff00765f0ace2704950a20814c04a51ffc7e7c99ffb864da1dc8165261db2069caf3a8091f2fb423e1979f334cf82a7a42e461d390e9d54d1af1f8f6a373409eafb77a3b8dc9005254dcf0a3b89e89005d20d46b56d26df087b0ce47d71f213ea7418f6877b3803e7af0ca0266d07b9da0f959e90914f29284f28ecf44548702a1c5fee1a77bff9f5acb0917564cd115cffec7c41c2682d8592ef703b5a130e869e0a814c5c445b33c8b776a25e03abfc608b1860cd58bfaa1efaba2693d34a518e10c7f0e2cd85bc36cd5648af3aca1fa6900f61f53b8b71ed1e23b2c41a74cd84c0793a59c9ae031c6050f297ae8f8d0a248051a6f3c8222a9c83a32e57127d20f6b1e1df3249560cbc340a13d4a86f48eafaceb851d13f898a60435c0cdd0bdd9b656b9fc45ba2ffec848c92864dfae87bebb2d399c06cd1929a9c7d9d8f69e1632d62f2edeac95353ded932e091c5a30153e67e22d9db723b494df948d766f7c6cf384c19a56843e936796082cf289f1fed273b9130a8cd21c3d886ba9d321c0e7529f4041af2b05cb3a3ba75e4e77a2ca021bb2055083a2edb6622db8bffa788f122586fb82ab5d34eacbee1e375563c2b964cf51cf91d54acf8eff852b6115a112dbb8e82c0a03ca50e182a53dc8ec692779a7c446162060ef0bf7de584263b7656b50361ed3394bcdd43e1ed1d03436b21d920968d501836859964e88f0d3970069ed5557355c5528b2e3fad58b39d4ad1b960698b49a8a44e9be23ca78b0e0feda4dba8c320c8a333702d6ebc23d3b4b310794ec6dfaf4fca8348b1fd84c2085592a16e898b11d601696eb0c4989531b043f92c93fac8acebcee29cc847623982d9f3ddf9bc59fedec75ec46ac9a18f885d8f50a6e988bf8171c188d02d2203d3555b841fdde7bff6510b90149015bc58bce62b12523ba90842711c943c9fd676a8a69544b34014f112822a4a4a5c0c974873cf0e92c1db837ce948239f8b3c4f49aec5b4edc0429d06ead881d4c4c279d147b1418370ae31ae698aa522d0d7d07b5da3fbb23e58ba147ba477586b1572c407422ca424730e01b9db42f4cfce86f2e011f9c2ab066912e865b7dec0a1780925c66b002d28476a6b08a9f56f00f3f0b794c883b65976c8a776bba504f09d428c21cdbe9dac9a37e8f2ca8f05a1ed96517f4583b9c1105bb6343f3152b17d450f2f6b5765a357d2101890604d0dadb93eb2553a369d23f2f73391fac6966337eb3d6d06cac0737c9e1699796a0f34139ac8548764b7505ac6109b4e08cf53a05b17dfbbff4b170d99ddaf297b4f8802184305a7c5151184296433e5bc91305d2c7498656ee5c7e0ecc3de5fb6902ddd8dc699c45f28d09a351097b43349e544ff65c0e3df432a23607b55c7f176ca89b8e8fe562e65a040b813047ef5bf1af2349588f3beb9a66361bf1e6495115508bea9d1f4a2d1f0a8214a98588aacf6d008c028e82e5853e761f9a229a14f412dfa8494dde7945815a018ca799815d04f4c049001196b2a45ea8cae6ebdc68b64e80329b8ba461196c3edd96fb3c360fd0ba36d16be4153985098fa123d463a3b22b11b1bbe763dac26f43522f00f4ffde4d9908931b5b72b54b1da68b6b5845597ee06b2561818883a8a1b70539f6364c91aaa34e062cddda84cd552f6d2c8f141b093a3549258e69518db2c13e0afc8ef6b638ea662db23cd3188b26d48cb32e257e48aa8ad7bf4edb1cc7d0d777712bb95400802614156d583f0539bee9df389aaac6a607c0350d5da3f52a4435511fc343e0205d49dca05a66f88b25ba79aea7cd4545e36ba6e226fddd2604cb8703d88dc87715cbeebd311107ea397fb9a4dc060b687d38ed6a9ffa99f277b33d8c3b5717e7e4a7a414ace6c280f22b740b97d4d4a4e2c9fda7bcd6578db9826c4d8a6dd8c0274e243ecbea1fd22b8778d87a6cdb1800d1b757b798ff961f9bdea65a05aa483fc351731fa5ec378845327229473efdc3583a637ebd253fb48ce9e969012a29a6fa7c383045d902d9eb9187c8a676c8c397f51fb385b8c3045fe4ce659ddc9ef751d35aa9a6aa869d8bba3c50263ba07af56866e66eabdfb7c98e0b8fd18b821df36b64ca83e10f3c044fd03a4fd9ab5bafd9a3144767b31ff5f4024d7b6c670e073d3cef81bdfdd68f1948af6866cfd7830badf1dd130c16f9ab55d8b3bcaad74aca240b74613369dd34dbf55f1fe3d26a309da6b3838c9d88e848b8e64a9b6fcc35d2967e2932e70f17b36527c45f0a7b06a02408478d191e702dd2ed2ddb4f23cce06084ea89b6585c64e3c60a35c05de4a2920573fe3c8abad43405d6abeb8906c62c3b6519f02d0fe1b7832361bbd79c114c21e566d538c0d6dddfd36f27fde387d6e2c6c4b70f0a72d0face94e6b4a52a5eacf82f5cf8e2948e363dd4fcde636450836378b56eb9a442c2c700f704733e2acdb98bb2b0669fcbccb89de1e3b4af93013627efe9a782c60aa26c7de5883c9d13bef1868ec04b103e11a1d95be63a6f7ddfadae12cdadee0a7c22ab7b1ace67bedf087ff2052b6284e80049f1f57ac38a4f706182994e5d6478f749a376fe8e69621029362e9b8bdd1c664321b8bcd4260e81fe28e2084bcbfc754cb5e8f70668539f69f34b2b084b24427464799349fe162a7c92a570b4a441663aafcc4aa558cc8052c43322430681445de8c57ae17233c08e2f1d9836ca084208bbabfcae965129b57dc38b1360b54e3c548ffe26969c83d52c189a1a6681360630dd5e11e5e1d1bcb171231ef7ed4d3c1f7854bfc7a17a876effeaad1cd7c2b08e9a5f0e9e4ffe5d186042ddb8c3baa93c46e6a21e2c8b077a99103af559ab33733d5e6f5ffe0ab08f9441c248fb0a7fa031ee43563c71339ceab87dda4e8c607329c620438b88b3c610eb01b426e8190b662349a3853e8e8436b1c9b2668fb988f7d8b4b79bc4fa379ea494147bfaa874a7a217c6cf4d137f87293d26873de0fd2c0348ca1c87d68c6864ec33e368e56f7724d6d6642ceab53baf836745b936f01637adbbe2c4d9f44bc2418f021c5df71c34e87569c362812dde8a0fd1bf005a9860ad04476dc84c436a351a4161e6380371040531a4bbe90bcd171bffd95272eb69a51615d590568ef3f489c735851c6980f901df12453253956e38c856471732caba82d79595d3c2af77166fc69cd98e24617c81d712530a0dcebca456c7118d2fe432dc9c20d388f90c469305443d16b37cae5a16f40670819220c70d96735a89cf62cce55eb1334dbedc4e41a1ed46657c7312e2396d84d2a34ea1311dce307dbef1194795a2fa8b5535ae6a94725255e5ff783cbf26e0bdd87220b393d800ebba9536a210feda73e94897aeabfd88001f6d995562c50b5f717d2535ed96dafbedba7d28ef341a328b5fb6fbdab0e60d7f85804d009aa0fc492b14e4a6e165baeca24f8fd865bfe71512b0eca549df03997c3e629ebed86a41f5ab64f70e08f3ca95abbbcd5cdb78b4165024be759d620b0fbcd61c91fd8b41435162a2820c8f51ab2c60f9c445afeed42a6044f8fcae456eba7d0367acda6f270b6a069ba9fdd35f140745d5b8cd1538fc6d8f05cb20b66ca2550df1df4d586615dac3e6bd7878b1fd171aa0e5df59cdc3e0b4198b7ec5dd28dd6598d7125b59cfe3d9fadbdd40454b97606fc3e29640073906735f3357b9f60e68c7e27ccbc122490514e97a439aaf279d9d4db124b48c2c6068495902e800c9f3c069d015fb4c16b57cb7d743ea0dd0b19ee3dd74518109c953f55044bd50563ef4a079c3f39d0a66bf2b94a6638ca6369897772d1627f6af630834106a1769a603d0b40a1dac283075a7c6a2e1710ba7d0c7dcb70e5b7618260fe8abde3a6ef3c9aaee195787fdddfe6f44e02dfce2ed1fda30a483087b0614ffa3be7b9e5c9fb90e7ca15a1b83d67388929b2372165651c5fba7ff5a6ad9138b74fc8aa9e7c48f288d8a29c9e5cdaf656d8258592920c9ffd4a781ec41a3aa5005506416ccc1b34bc025ae5f680c845166847e9a116b01e9c7baccd73f04edd91c445f410642f4218de15c282bea7f44628f41cd22aa440c25e840e4ff202389450a9abbc96f9e63786b52162dbd183a05dc21432c0aab52436c0aebbef700c945c2c1b89069a64bde2d990a907e2830746375d6e8773ac7a12f8317902e74c028aafa103b38726e39937f76b23c732fb1b1941a959a82bb431f3948b04a550282d374b14e1ceea6ea0902b6bf392793eea29cff0c3bebed8e7de198ef8ad3ade3b2969932023c7f086726e9b4ef0f7134d9a5408bc0ebf0c06fc492021b9f18f098a076acabd258d3ee0dd6df3d248cd6de7cd8372d58c0445c6da921072a99c4a472a2920131edde83dfd2203589d6b6433573481d227192dde574115248499a8bcebff12248cbd437d35c9e7eedd1971348bfa05fbc95f4505acd583ab639a9b44778c1ab61b0659095f1845f6a11ac5468564f8f16c72600607de6a5bb05cb50f81223f3667877fcc81cf5751bb50791ae58cb03c1ef18b899b66b39e1cc6f08de61cba176c37e9796c168d8ec9aaf0cf5dd9a0ac64def6436608c2852930ec577854390c8fc941d37ad33dee94b4e16df63c782ce394b11cac8fb3497065604e3b7f940c87f5b0000340a86f3f78d91c88b72aff705364fbc656a63895b6f147e2458d59dd066be153d22cfad3291c76c8a3b76d946899dacd17387dec19c987e97957db8b9ca92b2921021f6d75d5710c07f895728f07f4997198c0a49b8ed20ba89db57272e6c2a11647d5092c3a51210dda7d7965805a8fd32fe54d4892712c71cb77a12fb68d1edc864c38f89c532c56a64054c4ae60b4ff048d0c76fd232d17e6ef85aeb297858179128020bd25c74c6ab733007e85504456423de959f914fb62cfebfaeab34f0f3189f30ef563eab30d6578af8afa99990a6a124021df39e509baa746dea2e8c03dd4a70bce90c5e26336dd669ccb07b7fbbee5d4aa925878c216c3b26adbdde2834ec71b3e9606787b2af7751815a3362dee92987299d4d86b6bf1b3f0c2ef783f523b3dfa6429691c9744867e761bb9bbb65c84040fd962d125de541722d71133da77b3df078d91911a57b324e7c897b608cf97395187214222863ea74f6597e93b89ff3b70e8f1c44eff841c54f1458aa8ca1a77fe8b4af86735c3a154fa04f001b24a949aeee8bd0e257b286861aaf9ac5c4752bd18d205aab0c4dbfc33348abb9ee7de1f33cb30b93077adc376ba0d80d59e70bb8a9e9a7a31e54aeb076b31fdea92fc2949f57042a97339ede11274c161aa4d744169d3943d68e0099a1534ef8640503f9b722da2efd8cfdd6a8f3f6a64f5101decf753f8e5534ddf8d6b04ddd55d44f7b3ab4617e52bb64fa81035ee5d8732bc5aa88997676c300608bc534be8d76085738b473830a55ffa50440920add9cb271d6fbdfc16c316f07b5d6a8790b8818db67f22e0ec2f90066be3268f0af2ed5057b62fee5df3fcf550381b6cc5cacdc91009b97a858f85cc6e92393fa5079077e6cb242355636fc4b475b1eb12d7f51d49381b60b320af5f8b084a9c79eacd7d3f67c7a709f983378c90bd57d163d8e08e50b15a31de324c714bca1d78a98713f948b213b0311ade06a87518311ec1a8d34ee642cea17718f054de25d402ee6c0ac044c2d4fa0fc3cda48c54c5316fe15b58cdfe28abf8bc09deb3bfceaa986605fb84dc860b94da1ccbd765960cd3bf136ea61a168cd989050b2c23adfc1fb2af8e2b3664a32283db7ca466ac39bf2f3e5ef83c7b509a1266f9ab21676ee84397a4bb94b909d012713e285c59b8e1eaebfc0f67a7da892b34edef7a759d0e467637232b125e97bb7240a5bb9f7e606e5c89bc550b6a98a3c5aa26a3828f174b36f29b43111cd4a9579607626e8383887566343a6473860e47323b69f7aff1d54e1af0043ff28c63b660d23d165df656770489572ed57a1289b54a53976d56dca48dc5b76b12691629a84133fc28d5192be38bdb966914252f9822ad66d6dd30c5e04884dbb1e26af6de6d6d152370bd3f58ee533da60984607b47242fcf064b8ccb655c0a69642a8c5301d4b4d93a80dbaa39684bd439671d9eff1acff8f803a30751726ca1f51589f2f249d03f81125e265608c01b936fd7c3d0e9dbad4aad9be52009a79366112584f7fd973e9ea16fd045b11a1df767bbfa02735feedc0c132128945ff6d222201d2f1ca031d262a81d45eff0852533e9970d0f5562cd8d7d6aab5cb27aeda4eb21b596baf8d8315107bcc11084f841f796816baa8192c82ee1b025ce17b1fad709e4a51139a175b78b280892003b6e17ae8d916fa781798d7d07904357fb4686abf820b6981134ec7f0a9c200c87b68c81f390614021039e944e997f04a4ef5094a33912b06ee1e453197294e119f12d9ebd73e7504d59b41b2e6b8979fa758ea62c5413148ea969bbaf60f1a346e4f3d4e0cf1bd37d752f0b0297d6be5b64de1fad2b61280c1e362352a7ceb28472cbb16fadc2dcb78254017ce982d4fcf99b0c3b4e875ea9da85d1a1bd22e786f0471d3a7df001cc0500d7fbfbc8c1d2f566e42d2102260b2508b951342296b3c11224bf86181adb75baa4831e6ff0fce9b95ac62453b500e818d02afec8d268f51c85146a9ba6ff21c43fe5113ffdabdda8dc9cb56f350ed8a754b4f4875a10c641460f613a5448ced442d8ea48d24773f0d911e4f9eee93c1b244e817b7ed1e943ca66630d1557365345a0cfe267cae3c89fcf5bab3a24b5c026a9537c5c32f9258c78aa1f56adfc5efd1ed5e9d8036b6b620ab16f06b690248d815811d3491c47cccd43494cc20d220091f1afe347daea736719769cddbf01e2fc4289222e3b4a26","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
