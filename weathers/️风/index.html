<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef918fd1730f2c6d0d103867ed874043472179e57f796200b427178c95a90768b5b5ac9f8c87cabcb5065d2aac0a661b2da81ce9fc43f0d96bb08d645cfda000b4ed8b94168c2d8422bbebad7780ab124c742feb6f83b520ebba8566682c54bea63d046c69648e73cc61db40047feaf0507b073ee389b6016af6aa14cf5d15370c730e1cf1ae8c4ed1ef524051f9d0b95c4baf186ac494ddf1c8d6c77c9a124832de360857aa2d755cfec5efe20bb65fa8aefed265ecda07b05aa11d609a83b365bf48208c8c32f11abe093e1cc2b23c65dc18a37402bf35217f3571426e77b27c7a39c0d86c397758f157dbfd7e7aa719ec4627988d7caea363141acdc7d0684753b29c5ad262cbe46b2221fa8300624590a1ee43f2941c110fe4a57a994ba370a86dfd88078e2c16cf8d953710b7a2d691545dbb5687243420a4b3a553a1885f003fff2fc283290d6bfe1ff03220850b73cda27e56d90b2dc6622476be0383bb82cfe1968a4b63a3893f9e7542843698ee7fd2ccb0db98cf87edc10335d26ec777721aac2e5e699f29829e8ca20c805b20756bbf0e9f45b047efd5519bc90d2b2087f25a55053bff721292af46e7dcb6d6f9c6c67bf90bb09a3f6872b2b2a217cf41ba81237042fa3273fc36070498d0b3232f34532e839952fb6b987384e6b9cbc94d7209a1f36fe9daabe96738dd9a01b1df577591046b1746fdf879f067117b01dc3de989935a4766b044a1c0697bd0b06952a73066534595001430845c04229abfdf93891e9979a8183f7cb3da5497a6e6870a178717db2945df29c84f82093c40e1583be761a443b6bc7e6fb5ec8d094ba06cbecbddf9191c1834e2b2ac33b99fe1e80080aa49c0ea9d8b2299c8a5ba72339ad9ba8760436e731f121b8b3c37714c86eb7d6fbfe4f77cc5887e440a144437af59e546a140f42b7d25050e5bf43329db66a0c22bbec865fcca2e41dc5b80af6cdec6e192d75a21edea7b62578674df5b7f35ef4ffd26584b1bbf13abf5b0891f4e8266bd08f77a2596780d0aa192e841c7a8eccfa82707818c3476fa1ad00894ad683e2d602a73df9ae3693d4b9c992b3ddc1b5f296779a2fa3d14cf081975d2a117ad9d46d49547e387f21edbea19803c21b5ae5378e30211708c27cae3a0ecae37b73d9dde96be2a0dee1e2c420bad7c1ad1130cf589bd34b18f215608033e707ca87ba882a09c73b4ffca5d2f2d487249460362dcbdd4921ba9ad879d6ddaf7aa861aa5e1ce7e65009d9f98b417dc3e739603ae965b459d64e7fa80ee1bc91449e5890af2fee1ecb0f3ebd908320bea2d682af12ddbd8719ef333d4422089e2b180fe2fb23f6203c8b763017612bf53900b41dc800d3bc36a34922f6eaa412da7ac12928b1e8f97a8476af3cb202d43f46159419062b8fc289e13c4e43271c96af1fb245f0aafd7093333d10f367669932ff991528756f24a47585311a8489e8c25debf04df5d239cc1374e9a4c8a4266610eb568b9a5e008fa686b6385919f3d19f02650df4682f6eef368ccd138ea35775d055aaad6401c7b4e4b0b639fb2b359863961e88dfe1b463bd214a6336a6f64d0c5e2dbd6c9535263d27cf0df48d4111ca895c2500185109c4d3c2220047f2ec5fcb34b4c90783229cfe89faed32289f53cc7770acafda32cfe9b0d1bb51c49e194c73236db04986faf6cc8b876bd200844f162e390526e9162e494ad9af4e82a7e615fcfc50970b8fbfb11b698343c2796f2fb874e5323f6f8cfdc06cd5699207c981e90995c2a9abf8ef38187c76863c7180e062c6edf72100d508d73989d0b637ee08fa7d4b0635e94a2acc81416e240191cf6884218be21afb466044cd74d81a9c4e5dc7ca9d90e17fb971d5abb977c12ae9380d4dfa0c2952a78daaf294c5defd53e21692ae1107db430ade097c697b804728c26d8b26b21d6fe55cd3cdbcb877e1f7b1f6d154461cd5e3ae1cf8f4ad70f748172ed8379fb0e0659927c8a7704a962f3345ef2bd8f1c09e831d64d74e341910f7254c51359021840ce7acae45c20bb090e037be87b2f76912edc785b0630c191f673a87ff5b67c54f08eab80c9d72443fa397c7980589b30299cf2cff8123ba22713c77f52abddbe109a3955cc1bc316ed9ea304ec2b280226905c6c3482d223c23c6080ed00cd8368616e12af5ad70aaf0df1c8e34436095b2e3173f684d0d70e90cf57accc852f69ef99502ff99126a8026e8b13e5b41263b44d81d2cf96415927b7781f8368cf6acc496332a979cdfa19cf14c1a849dc544ce7dac9c2950edc4fbc958a33511c5ba8106248337805cb2ba8385425624dce132fb642ad69e60437ba8680eca66d269259aec8caffcd745728a17a8ee37adc1a587e1d22ed72c97a9a3d43f44c24a869828e44e5b9c5ea48a00d95c160aa2e5a4eaba01299d286760af3666b052c39686f91f3362844555dc384cf73ae8eac214dba44cbcefb42c62d9a84d864b7bf94e1b5acee7ddaf2c13c1ede2c7fd049f74f3db7365655e866cd5a7f36871c66119dd61f7beb752ac213d1ca798787d7d8bcf79bf0f29753dae31bff6b17c027835514e61d50c8e82d712e788214fbd97a3e67e34fed50733f9ce5f1c80d83c0fd7d8cdd04e4d58a508b8c4cd69ec5d1d6e679e250c12173554661f987e164b9848bd83b213d80f52dc3d358c0cc9fe0114b1383cd4f62f4f93be48e5d24d3eb3c2c5770c356f897c89547956b8d5f2788ee8f9dbfd5874c00ebab6be8d46e3a96cabbe447dd6f9ebb052e3e81c6191fb5a00988007f6ca0f1b324fc2b01af255561b6b55dafe6ead89a7ce5e8dc26caffbb5970e1fd43f28dfeff891e01276e413a4a138e812a00f2e737ce005f5a07eefeb31af25c8085b94d6522aa318561cee7006d91abec9a783f8f6811905cc6bc02f24026273599d25d1abdb924d012172db3ce6de4bf560e6c5ae0b67c008e391e1dcef8d556fc116f67a19ecaa7c42ad82f8eb80afb82394a18c118f0107aa173de1b11f5f3f44178a78355043cc5f0a26535cfe517e9df3498d7155d19352822d537500e10181c5b7bea190e977a9d6d2aca32d0e297053d1817bdc06a1eddfd2703d1f14bb7a69f919ea53d81e6b372668a202e8cb5e8fac444bbdcd7db3cc695bb0f207e3fe2fc82f7b0d4dbf3eb470444fff345459f74ab7c584e111b49b350abd880ee4e2ef15064b3086b26628b862e4ce0980da094fde1a1756533859bc9e510c117d66e7c570ec3c42c59cc2825c21347efdb6387465548d97666f745d428474a2975143094ebf1e09d6490a32534b353810eed2f7cd651a067e599da378a09847bd9641141d08e092c95d0a08dd4d16e9bca6e058975a66a9f22ee05d2eb059171c0378d059a6a2780c7e4396082acc9b671c151f0d8c367177d78e4eefbab29dcd87281e948f522629e3b7860781ea7be97c21d3482f48edb63c1eb4b8e72932c243f7530c48b6c8e0e4c686dcdb11e59d2bdbbcaf8a17bf762691b9f0a7fdd4a732dfb301ed097c6282fb481985cf4053f64da2974b581db1b1a30354aa26db280b73e98da058a3099873d0d113886b00c2e445e4b18ecee5b426689b1852f99ac76f2b16a791c77e93cd9a5b3d9a748ca1ce4cd226545c1f9cbf7eb391a3fa9fad73ca64d86f6165d501c127114048e58fe83089915575ccb5e6415576b1916a6428156746a2f02684311b6772892daac2bf3fc9a72443436f918057b42de8cd3e6f515c90d54e796511d8c058ef394d10377bc5c8f3cea7c03d1663328ad38609ad5d1afe2e1c97a5df162b94b302f9f46f09804e699591ded7794648018dac8acbb745504639e805dc5cbae27b99b4fc6bc06ecbf2153bd49774e5baa738919b78df9a6b62fe8b133ef718ebbd9ad0e876c4ca43e584887a957281dd1e4e68a62b63e8fe23252d47fc5e33cb469503d47a8ec13738ccb299e3e8ffdebc18a668333e0dcd2d3f4e31b40db6e4ba050420b6a910f9f28380ebe586b27f7cffa7fbfdad7c09e095235f4f0578be361a34f947353f8c7e1dbb743ad1790f489fccb394ffa1658ade651c1540bdb510c3d4b9d9415234107ad50fe04716f2ab93c32e98fd2faf5c9f06307ef2322a37f68f083c559ff1d2ed45b3997b7b0f26be3e97016eada52776437ca8e7b9597c53f912f5e7f8e6d345018c5d2ebdaa51999b66f63b053273bd06062ceaf60398c208c6392a01e842ab22a40ad16117494155bb2016d43ad4e74be8fea97a450cce875c04c3eccf8aadeca688d3046a1af635f6525f1c89e7fb1034298e3eb4837ddf15400481ee11379e26a86c79eb9b13c8571bf930883b52758122377bdbe59ba4d638d3ae4da1a60aa34ca56ebf677fed0b60e229edab49ba9812fd919cb905cf8df9e5f645cbd5f891d9c2c70d2bd321f3ba0b8d6619cd649d6169ea014f5b90306d0a14c472eb245243da988f15bc1cd870a7900e5884dff0efd3b0567b189b27d8da83cde07e03fe28ddf8c668679a6b644f8f776db9a845a81c946d955d8c707d1c82864e2a803d80304152a88900c98c04c137b55f9af08fe97d27ce1d12c3a9f1424fd056c25088877f77afc4fae334a5c3983714bb2dfe6f77abd9b24c76ef79a88218fc8ec3b5663bdaafbdabd02df6db0044b9f7209adc5ed2e5be7b68bff7b211d979e01ab3eb4b378d83637af527fe84afa8524602a46d13eb506d06d3bb72556ce3e38c27981f2fe72ac578bbb2f26e07d9edbbace26436dae090def0bef5936000ee76d34028316224f12ea2b237f68538df4ecbacb3d4237bb60af15730e3dd78fe46824b68c8441dd1a92b197275f3a9de893bb4567cafca46fa664d6da2af5e4411250cddfa44db816c33dd930b4e23bfc68166183139126f27a8e2d7fda791df42847b1ec81569757da71654971e0ef89d06c508671c59548ae51d07e48bbe598ced4f2c3a64d2737b674db69782ccf815c9d01a6eb9a06ac069dd1b3427c703d76493798e368e9b90a2062eebb2236f0d0bb499796b651e79b28b91f8dce2e0a9320b4806428947b4365291f69cb72b4ff2e66686b7a5653268364a7cffd0917a043c75b3f5734dcda13956b1f54cd65b87c03e9d9384640f9028e9d2b36c4721ac65c1a14d67b4987deb2622264934c1cafaedec35509087f24391a1935249903d00dc5d44fe8564e55274f3ce762e6bfdf49429576e05ad318b1d0103d198b8599eac46ab319b830426b6b8764525f2cb13b80406c9bc3a881c22aeab0d2773dbb43f1989a651ed49ab196aacf7687f2321ba32a925e9309542273362bee9a4676fb9c7d96018d79a19bec8012cd49d4e027c9a16385643f46ad7c25d374ad240cc2063aebd69a5554ef50d063396a2a20c347423ef7764dfa4f312f81137a696cd997c11fed6bf948710ae3176dffe4a387f6e4176e6f2d953c1c63c607957cb552d0b3e2e72d01249adcb103121e7efab081d8498c3e837d713be39fd8cbb3042aeacfec4facd6498635ba8164ea60834d0ec301a03106c96c20b5dfd956cbd9939879014d17dff1b5e246ad96ecc498ba5371ea603d9bbc8abb81af9ee21cafaaf881f8964f414c4a637e647ed90d40273a7f54a47dedf7bb69795fad92a3306ac0856cb04b6a18e1002994a42ec4f4c2461e8e9354a0ad1a0e407a57db5ee95ccda89c7e7dd162fd449003168b9a628866f521eb72050a5aabc3215273ba98fa02d8c7e598d0f8b290c5ebba8fb8d014c70f42e8c14c882142edacfe805e1a62486dfcc4688cd30d6ddcee2211fcd3e369cc1da6563247ce66086fcb39b892d0d3e4959e68a805ee11c370583708314611fa4493a52dae3917d34bae735d4b74dfd7b0db87643c5ae1064b335f228e35b6643e4c7370eb14d4411068771d6db15b5bfd4a272999622057bc816a665a112014eb951fe10c8561180de219fe475b39d39f961d2bc3f1056838ecabe142307134e6a81bfe2e91b9dcf0d4d1ca00c8e53377f5203c931676c5ccf0c8e4766f03df4e6bd3d16f33b233b5bf2023c4e0fae569ecfe43522133abd2a08a357a60f336b497dc55b196bd47f206950f1f2d51ae0c2af86b19d4229bdcce1331a7f9cf541436f736194ed7318f6d6258f3893fe436f32336f9b6c2c5f342a9764425a5e8e1cae861fd9ac3004bb14538b155962968c8772f12a5df985dc3269efc3ce318e955ecf4b38dc735a2ea87aa65dabef7368061b65514c04a2bce75c84cee710e10744a38c3d23b0bd65439710100c0965a082cc1522d933542bcd1e25a9f450b504a16555882089d202346f7fa6ce58c1ccd4ef6599278d7f68e4b0214980e5ea980ace0704bd8f069d90c9e1c4d51065c51a6186347a5e2e5023e12ec1403d6da4cf0634acc1c2f58da5bb185861222765295ec2a95228bf4d23745d70d1005088a9ca2efcb0f17ab61c6be605db710b2d553eec376a4038604b4236fe1c82105a10dcbcaffbc5ddf8289a55996cba302c531cd3be3920a428395c4e8a46524882152905eac6d77f463f424d7df93d164615c1f79c9a6e112148553ddf40f3e3903be31eef72f6c6e779231520874609cea0e233d8f4cd931d811e7ce9cc789a6635c36145a314c728dd624a69f179f465aa03f1720d9d27483b6c408903d48e525245aa84bc1bf307137224af50d953ef436c5f182d6fde6275843232439f795bfaad9b1f66dc6ed7fe253e7222cd64b1c8d204b195c40397baaf35a6f17441767819a106b51fce662c1f425af6de787d635659e4a007b510e56c11d948f8ded5376b926cc50eb7a36153b73f0cd6a73a8419800952d4d852074fb428966115f07001a69541484b4fff18d8a8dca3b3711caa0239f24dbc1615e10a1e3d37a3328fcef62a60ffdc8d81b58fa435af0760ccc46f27f61beec26deefb0004133605ec17e9f3abc24065dc6b8cc089e364f8257443465c9eed1484c285d8d86e10098b38d3d1906f0cbe4fcb3271e279d7f66625d9890e1702b731ce985aa48305308f54ee65f70445b2a77a4c865df9b788d2fbcb9cd77fcd334747224d8245a4e00c59a0457c64c6803e37e6fd2d477b0405244214388e6ad23d44ea51c5407dd3b5ea7d0611620994d88454b3221f01d4151f27ff38b62d3e25184beb84cbdf0c90aadad83e2569ce87978706670f3a7f3aefe0345cdb9966941521b6945fd4edef575e03067d93caf178b39d7224be0b7158b5f71925f6b152334ed98798c5f941a4a350d9c881e1c3a71c60ea344d4f198d43552d44d208bc96051cf5967a24f6286c373eeb8b7dd6ab694b67318c10ef99f76663d42da4734c58c0e856a1dfdec174b398401608a8915e08c890a4de18508ce92b68732ec6dd7d95fd777e76f2dc57456bed713495763d4fd42707fd04ee8f21b2e534d57f7808551973dfcf94506f68b70ec337b716dbb19868d72c9a753ef78a0524378ff624d1c333ef69cb5945460237e1304f78840ef98dfd13c08b64c775b188b81d073f3a4c7bb52fc87dc08ddb9b97b20d01ed01f5eacf1bc93d52e17a8f19e55e24279b1c930b2200cb4c7dee5e6c421ecafa77995bd554a6c4c60107e1b0b4c7e8c58cc84d90f28a9ebdae49b06f46c28c400ecb206cfd6f5e3b8bba781453acee351b4437e60db07d11fdd13b1d108ed77ebccabc05aa97faf81b4bf6f654861a987ac85b673e5f0eddecbfa1f62c44abe2d27b33fd076f538277b34894dc2266a5e600ac933dceeb3e0204c36c364a02126dfcc33b46d98f263d1e08ca7887eea1b3c06b5a721721ea3fef02d482bb5b52076e0bb93076474bec904728491753a7bc1ee961654a4c91f3698e7a84c4d7b770489ac062ea65c6305b14408b8bd7e3d89a34abd29ec2e43b8a23aee603da2232572181918fd55539b22d633d346495d01d0598cea03c9aca0fc19f0592359701d91c5451b7b3417883f0845955d8cd781fd3c096b24aa3789b973b083611c76ae2b4f7d5ce9fc07b71e0609fd9dbc7d16a6d7293e1ef7aa6b17501557d8b7ed4a52c5540d2a6d7244cc851078c00fd98a064c7482dd936103711257410c249ca412aaf53a36ab4a4f1cc4d01f65d538cb5981bd62c3b4d03fac74c041eb6ee4c7643e273a0f93877a8807b968a19bb0f9efd65112f63824c8be20087008b481b05aa15afea97d4c9ba732453684473f5073300e6a60c08219f7d4da5021fe3a074a299f200322f865d4b4461b604cb961078a5724366db6f87c86eea96aca225c21f886a3b8e02a8cca234a8bc866745d9e0936d304f89473a5b4308148a6d3fe8e1f9115b56b7ea289fdb449ad79ee3b4064769ac257c468b966c4a9961e26970ab8abaefe53c6316a0a810afb0536452f7366c35aa31b153141d9d126610030afc2680e811472e0dbde00a8bb6cc10e8e4c11dfb35ae8be73aec8c72533c925274467076bbb087d552635ef6a7acfe5bc2d824ddaeab5be9fdf1adfd5b744dbcc308c91e6f34087257bf4475b52cba29a3986f0cd41a16ea250ab4344bb1ca9e626c816aa90b4dc835be809c8548f75295b4d87b3470852fc75132626d5e97341cdf8c04b201d4e0a5cf1261a37b1fe079ccc88ed7a69cbc9aa0bbb8f4ea2edead4a36da1e0052bdc2c6fc03efb931a2f4f7c88a0252c546283dfcfe7f1ed01835c70e309c5452385089dee6192d611594578fe5117a2aa748f91fe0c2ddd73871754092aeb9e4e5b07dda744b9a9989579aea807c34831508c711381c4399692dee358b1970c5e167e0de6999ddc23b60f95eaa2c72841b5163d7ff05dc682e2fddc99fa16b940c3f3f84151afa312451cc46d55c0fa4fbbae0d420b3432a4693d00fa9c676cef8cec1c5a0f62a29c4e1b8818aa64fb1832e8fff83a641278df07a5d6e399de547a24cce4eeaff430762ab113ade5f3b9c0bb1faa4c58acd5a56cec3c45a62bdf732334e164c500914be77dc918f1f602bb3d034048000a816388905e3c5cf3291916bda29d2bb47a361a4f17bdc07e7f44c2c94a3130c002a6aed2700624aea9ef974a7099bde98bc44f131814b79bfed05ba0c4442db32409cc4f3863215d28cab370c829c2766f756f4779c8d66bb9d7f87bfa7685fd87a5300cedc50f29538d9aae1c38d5eac2ed3d2fa6cd2c2e27083eee375f16c181d03c0c82586be55ebcfed8ade0a5e83fd2dec21099ae2625c7a573e832b8aeb03238fde10e5b03211cb6a4688bb695729313f804d7e727ce94cd67e9dc41270b7a6dc1a0744bb0088d1d79877c0f823162667d25e0d824e143978050cabc7ce306ec173ab932e623ddee22be9f4a1819e53dca9272ace6c7c98bebcc4f454c33c6c3ee00f7ef558b699d63f707ec0e47d6ed78e45af154800d2eab91ba033511124895d09a6eb30e9c780403f9d935f6a59135546344173e446092f42dd0fab7702b84533342a3694c156e8f7db3c18c12258644545965a9f6824d0be14d2ec13da455427365d9c6ca9d69d5b02040b9ba5752597c2c10d0afe44c0aaad7d6c843eea9c06b20b3b9d5491d10d3fd646c54fb368f9e3d56f9d4c03ad20d3a6b97fcbdd904a272489862e519780ab31c498ef2da7e13c0a96cf16a81e2c30e089269c856820c0f39389667d3cee8356ddc7684cafa07202437f5d2dbcae05c7621c466b4645131bcc88a1ca2c20472e49613ca9583831433107a0554dd0137c7805e8cf40093e01f465ac645f0b7df8aac337a193e9d1742f8f789af30d69667e3bad8c5007d17ceac53d9d6aae82a66ddd7791aa94cdfd271a3ff260414fa91d386adace9eca3145fbccc338a58025d1cf8ca41273258889629a65f05a6ef05c7b7281760298957d52d3d424f353f7f2093774aea8f24fcc6b1d491e29b19cb4d1c0c7c195045f244b06fd64b2becc784927edca04c66c68e51e94f1071548c4fdd21fa4ecb39a7541edb023700f4b79f22318ef3b21b78be1bfc4d29cc10d73be7b8dab7fab4a3d266659cebf8c0e7deee9f39d166face4993553dc3b4a2fa9948d87426dd43ccd300b64d17289533a5b64be59c75343509e33bd2fb85314588a193a2aea0acdbd08c46d3cc733e4ab8c94fcb1ac252c9744d0e2e938fb10988358105a305233b832309aa9b94fc70e34faa74c8191adc5d245e1f1d2a8a90460bb4b244b94b8c90064e9d2a0fea5ae861ddd052dbdc6940c1aaa72bef227f2a2e2a2a392e6c368ed1d34591e3141705aff6b822abd75db9fc62c3d89d0daeaf9d3152dae0145f5e0ad2cf3f786f62ddbe75452326076043b9ceb6055be32c24aadbee603ee5787184a685f50b1532ab36ca9a9fb6e2c8e11b285f3a9f02ee7b25af1d0fae2b78b1a679848e03e6513af89e699f56411547f75883f517907afed1e471b76d8f850241aabf182848ae4744cc0c3dc4c2e22699bb05efab0bcbe3b463c5e29d11420612f06d4801826b0f4ab5c2f287d9f4e7dcbdf63685097a6065c5a991ba9a9d9c2550d2295cc4592d4cbd3938af4e5ccfb27de584ef49519f154d7ca997b5e12b3b7aa46e619c310ad3fe3828c3d4bd74829e96f5a284401e73e74ccadc4dd903fde54f67152bfaa65cb62aad96bf5114a18d322209ac7bf05ff7a9ebddaecb30c62d523e6b118308cbdabd126319f2a23a858c41c16f838a5d9f1a423f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
