<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"65d2c9377776263f0ece06ee81f60db67d48f8024cc026e0bc71af559cfbf880c49cc6b03608d06ba7a7b874e61bbacbf1a8c036771736a228912d3917ac02a79e7d35e041be93a9aeee20c112cd626e13629bc92bcf12ccb6f027b098fe925dd6c5ed4381e9ca252df50296e423d4239022952d716b19d844478e2f689e6b89ae22119c611bed02429de3e7142b8f964101bcf00b39ed2f878bd29002912264043f39ba92cb96369825fb554ff7200f906babbef984149e881a690b5b3f385fba8c42a42492feca0537ed80cd96a63c746690c29f8800aac92525d43d8475689c98c19e9813b55f1bfdbf55b10120b0cd09e2ae1ced3d4502454ab60483a6661b0077f89bb923654af30535bd20a642db84151ccf03e4536a3f9bc4761016416bde32fb5119049f07fff94f5cc4b4fd184cef48963fce5fb644ab9e03e7b30ac958c6be70788b22f2aa119721db1d7178e17299dc7bb4ab6412d82809cdc2f1a090c29317af005c9be5a71ea48f9e4a0453cedf6b1b068f69b726b92e666738b5c974f5bf06dcad21881bb4d8e6cf77cfd3c8ac4d1f0b155087abd8c70d5c91246c08c14f3023213801d9e4ba4198e4b91a834109d41950cd66b64103f1f724670c16b84b412bd82f93dc1607cc643a971f64fa964ae6ca32e796ec0e26dac91119a29a45c683f188a8692938465356d0fa353f916fa83ae70d78f1c64b11c19472771ef80b6cce20328226bc0f9f19f8ac6a84c44e159a00b6d5fb69c5a4138b14c91bc007a3e1ef66fcdb63265a742a001d985c46b87eaa7ec90d29c50a279205c82954c4b2c0f148090a2b9c1198b72ccbfd3a557a22bdafefe4b00f64426a49d89b5a0616ee305303fa06f80adad0ddd925e27f4b4a6f3ee6f5246771327c64d8693cbb9825c92c0bdf04a27bd8a534177fd34de7dc7f3b0d6d1cf6c9c32fd33157c7dce3666273384648d8ce6607bfd1065cc318d1a4c006ed2d9e6185adf1f27cc217efa74a95dcf579bad8df94af811fe8fc572ddb358d2f0dd4e15610bbab0e4ac0fa73c43817a87d4ba28385594db45aafcdbfda65a694d595450c67ba46c112883f2ca472b3ec75265cdc828f40b63a3e2181da5205010ec693fbc2b5ba4dcfcc19e005a07452653ebca8e6db348a19832796c4f43b7539f0a7dd350b0026163764e94ed3ce53d34c24b4f05d15583f273c407ec38c19369769e7b307a9647409530a134e5ab74c0c78ccd758aa56f2d88536424f2354fbfa5240abb8495e85308b9e39a1145a330a022cebb18b45b8afd67f1db506bb8569d80f67f37b857427f7a34f1b9498f8087c9fd857c43d9c23f1a8f7b742370b3066a1776bcdfa26fcf591d5fa052aa7092dc64616b955074c367b56e7d885cb95aa9840f9ac364a42b77711e284c0b7de8dc981503ab5b8a79c8c0407cdf23a0fbdb262699eb58784aa80820e8d0635a5e1bf68e969a4d9ccfb4ab627dc400be26e60e582ee9f0eba4b26797fcd4ef0e1ffc46f63909e84526d48eb44a3a6d949d8b438ed7647de64aef376cc8bec7a7494b3057e1ed23976264922563e2c4a5687468d241365e8763f1193dcf7fe5d9da53549b1829b596845bbfda6e435411a02a77a63fa158ce5cd1dc72710842daa58ef74c7cfdccad78432228dd88cc213382388210a058d6aa4c5b19f2b18e2faa1388105cdd61ec42890c137b69dcf96ed7f1c82f85b240b035b01cd72229b2ed15f637f9c5b66ca81ab25233f762ee11ed0853f3f1138f1386c15d7a0d47a08116c8618f4270b29fb7fdd984f75f515b3019699c4d8db968ae498c353850f78bf5c7349b18174002aed98d3bf1a295dca0351950bcf432c22b77cde7ede34b4d03eeb8d8c958e24a98d58efbfd6a250829e2db4b52a38c63f58627af0e2940724541b86cb20c2c992e5573640a75dcd39071681f6d4e22265e59ddb7edaef17dcc9005b8272310959871a6678258d2cc2e19b12afdfe147b157415bb417232a7ff442b3d2f30f7b90d3fba41884e741ee1d0a12b2397b82c4c485e1c7d08c5321e0fc097264cb1bcae81bc3690cd9a41a4689ad8ad7cbba1c9b9a765ae31c46c2eaaab09fce46d1c7e50c54ecd7e877af2cd9ef9f8526c7a7433e34e4725602cc1ff8ff0ee1abd65cbc1b93ee7178472f09ed431c6b2015ef39d159a8ddd2a857516e30ae43b0a886e81e7819366d8a3058bf39ea59e2a53b3f094eeb709fd63b0ac6058ada25a87198f950e1e64f6f46e4058c711d777a71692c68102672fb37896844ec41427f8b60a13e5b29d7499d81788e4efb8fa7ffe297d1c142f0a31a1f381cf11cd8c64f4745fa14727b05a5ccb9ea3a4b713fc19696951384c2ecaa222949ef3b134c99f756844a211b03e08d0c7338d3446ddb88c60d891e0736f39e970d85329fc00a4d8319b11c79a4af31ef591e2a539930a27d31790a2b28ab0784b1f7db01ec5ed5484b4c1597eed4c07feeab1cc7d936a95063d9cb29a3b3453d4f95bd0a7ee0c6d22e8eb2789cad53c7589c94fc249819870ae4b9dc502aab9a29a9ac7d3a74a773fbf98258c32dcbb0a7aa8840a173b7b6671a2edc083065acae840585acdabe515be6c0ebc28f2de93465a370f085d954e337f0f56eaa5eb84c3049362856cb72223c4ed79710bba23952ce0be068042f89a384193c69eeb010b9e6f4fc5e9da0e6c2417d08a47e5790e4c0d6831b2dcf88dd47877f9ce6fe32600c2296c501ef50a73ce2fb75041254a5ad483689b799509cc9705b219905b654a5a624dbbc24d9c54c01f66b7c9729309bbe549b0be54bc1e1fd638050057f89a9aee3108af859bae8784fa8bdead57bbb63fd641b87f2579679c3108103392be09057fd83570d4505cabddd9924e6a8c66be0458cebfe80e6bc842cabdcbb2e954a8485298f9612ef61af65cc3c1b2f47ab392eb5b6b1453991131112a28a0e289f985f6df5e79dad59d40b29c6c56bf17af6c63bee462a9a6fc32c30a2b7735560e30581b6f7ffb7b55d3fdc48b629a53966ea34905f2995e72e53b06ee35232b38135331c047917f55a119df800dd226af5150f7877fb69907070bb6323e76d33f0a3b5a1b5061bf479467c24c6ea70cdf60692e84ad6ba2e18d14f3ff929c4d7bbace203859176edb274ab1bc228c1ef26e44370c8a0fbdb567e3a754d2c8d769af834ddc7fa9d13085d9afb074d38aa036e23c8be3244d6f961d32cd70f3e3dab49011840c8f4a9b90a1e4807c522327a54ed6d067a5f125bdb02a0fd914b81531b4f2a7ca93cb27fb430b88169d2baaa1351394cda2f868c94e2e0f1a39a62d91806fd4b938c82229bb5f63cfff71263e1e8bd76ff2f7e76d616d95d2271018726a928d26ffa14ba0f87735431000f5e25f378ebef89c39a9d3ce0a9c045ca6e80dbce5d329ed324dc256b0083aa9e1995253fe74ce13d709e9b7c2097e536ed7d7d6d965e02f2a35d8bf414d4ba84274a7631f9fa4d1dc48f097f656db84154459afd94e129b3211d1d1393d82517b3acd5d11312ab9b94444e4e1a11e0bdcfde5e977de3096b9fe23d51e6b1cbb6502a2842789ca4a126be175eb7f2dbbc6767643f1327e0a6e8c336366ad63b57f970d7202f147cd46beb20725a6d1b2df4eeeb97097d55a53ad91875d9dba3c2641fb1a1de2c05126cbffc82654ea6e9b88df5bd1049a4b994baad7e99ee06a4e40bd391e2a478620c0e7b5ccf5e2a95d37f64eb394bd306642999f073c30330af9db7d07bd6ac2601c348ce1e7ffbde1e0ef494c065f583d4a88e5be7ded87d625d5335d4171cbe5620133c974a334efa506c3031ad72aa4dbb41788f0ea592c36918b1e89eedcca32d21dfef9666801d6ed007b7e9d6a1b1eb085649c85d712c33519b8b10a48dd6538c02d505f930692d6afd0b3ab96324a0e8d56755961e6a072d8a18aa9c131c217b0aebecd7540041bf6bfe342287b4cdf28364fd5e555c6ae5cf46743bd054bf0388bf7ab4fdc94a5f821bb0eefe2050c0dbb85e3d2aa8e68ff95697abd17fca7db7467de82a8d01c8898dabe2ac64db35a89e9e98e35056e08e84e01daade5dbc0f8061d8a86242a63d2060791512dff1936328e6c5c951dfac9583b232ea7c1877338f3ba3b3e5f99abe95a1204ecdd98649d6f1847917c5a3ccf2efd29852fe0848d9b2bd3391338d35cc0b97ea6e5594f8d01877db9553d4116de923d18a796419aceb0052da3501e4c3084fc2b5899101086f9ea1266361ba9f4a51f796d15fa007b7e671b8f8e039dcbae9be178a61ca52768216993fca8ce56cb9ec9c9541bc0aebcf04184aabdfb0606fee953ee4231a34d2aae9bba4dd81ac10cb0394601e78cb477b32cd5867797fbf2f8c83b14a5c6d0600b2237749abf64a464e2ada168d559bd4e5e7d37be6518b42c1c5a5983b3975a4af61db8539bb73c1f9446d2d5f430b5aa322f9a72896296e590a20283f398289139096650dd1255a265f061771ddc86ac07fc300e89a1615aabf1344f4177a96caedc25fe4cfdcb8f2051f9e83084a4eb0e7edf47817c12cee4d1dc824fdc1fcdbfb5cab0606a73fd80906d4d6a941ee37907e19b212e3d1181f3550e7042cf2a373d8164928ac476bafc609b05959ae1070633e75b982458571c6fb679e278000a009391a2e5665f81317f6a3433051addaf1548f18bc19694fdec0601f24af0775165c053826ac9c126b630a368759a90a2c7414bea25f798f499101c7a11a6079c12a6165800ea9c25c0a4001317c37faa0580257bb5bf3f1407277572ff11d1c16fb6a7685f453aef6634e0af4cdcbd8f7b5cf52bee87960b207874e5c8026e047c54b9ea086b9e0184d97d3ef9a14696f18a091690f7a7ba62c53b3e8fc19a6875e9b1d216db4f29388f5f3b52096d4d4516b0aa3c726710dc51a381f4534b711fb3f24174cca3d31cb4ed3b21085adf0b49c418b7111a4ceca4dd34edaddd45d3fc7f91695b5197483593f194791b899244aba0ab63816ab897299928f754e16b810c4c9369b511d4c9921826fd4c132a67f9403d561e854ae1f34125164c49101d1b3fe5c7b36b86ab176ba73bdc05f962e7001353b159b10aae91d22a276181606a17f7e842718cac96ed5eb16e5b4d93cb09fbd5bf81b7b80bb2af0884923e51f3d7d85aa74cf822a024f9e511fc98cda81123fba2895602a0392c57f1f02d5edb87be33eabb4755ac02b1881712613b1e438cf599cda1157c56f4e172170dab559c66adcc8d11e406f9b0fe02de9880ed8148db96ffe8211e00fbeccec503267af67d23090f54cd4e1e1fcf3fa52e206a8683cd175c78f89cc4c8901a9dbcbe446daa9af65c8dfa5827653ff8fe693f450cfe3da5358d78598f4f19a894e55ba6f531abe70ae674e2d024fdf320330c448c3c2123f33fa77398434e3f520bab380afc920b88667027537974963ce24d23e109d39217f4233d8983ea714351059228bbee9770c810abb8e6f868e7661349d1790ba8c1cd70d4a9a483afb0f5d59de8e51df87a6b7b14034271acd246bc0a1267dcb8f4395c766a83865a39bb0a6f4b2017a1918528b90034dc6fdc697622933cb772a0c42ab0f1e1db35767fe724e491a732a554e87f6c04862f93268f2221ea4e07789bdb801df04695df5808c2fe53c1dd29643a95117ad2a5a4b137ea033a5cbeb2a60993d8281b4cd3e81bbc02611eb51c132ea69f5d0e5fe3ed73b22df11e291c24427ae4514a33bc667e2760a5dc59c9978b35e4cb5aece979281eab9bbe946db2db71f8c88d5ac3eb837e7555e1a0af7fb51e5302819c29e1aab7333a13bb17bfc9d538e6a30981277846c3170f60eeacdfddf15f40120ba2164a63013a8ccf996f5a1328ba5e2e917bfc798e56b9c523183d8970a92542ccc7dcfd91f7fdd44ea3380f65280e635cc78dd87ec0b0bef5e62dc00fdd46289048ed399c8bc93211001f883b84481139191a7a4367e76a2af9e253ce72a859857909952a5b52168d4e73c30eea395067cb35efdbdf57ce5287ae80d1292be2cab63711d056e20c15751b21c741ba81526471bb06477e04a66c4f8866a875b5531bdd5f848b8a8b3c33ed299baa16cfabcb7f17da384ad6b5ac62c46daf574c3357810bd12072a3d51723acdcdce13d45fb1fba0be4666213a5ad5cf38b94c988c45e6e0f07902ba2b0c68642330c47341f572f7050a05717c52761534b68b3a9c1d7977bef89007d74aa1a01b952c8ac8c974ff1f9798a1f83918da717b3740297053ca09d287c766bdc2a4cf4b02484230c91c53347b3130d12a4d1593577d745c1d97567ff41a70e0fc96c9c596fc57072b0bb4c94352715821e7d4c74e0e566f0c196fea291641f9c67939d3b74de09ac8c4912dc0a1b7d2962a6b66d95f47358f6e34291fd477c8e012fd06c9890562d6cebe795bc613d68f420a1b7a01ca4c626f74e661843dc06caa5843f386950519f3c5d7993fb1bd1497bf4065ab554a7f357196c83627b99792b712c515959e56888252a69c1e249e83600b84c06be42fe69770ebd473e3347ce1c4ef1b9e2b7e93c94e3736f1b9b609116408dc88241caf5d41c4ec760f244d2ae4629d07c26d36494d79983fd3cc8157ea703b942970a2adec670cbb8992961a263fc50ec751eb82a69437dddf25e2c0f0c159c6d74080d74dd3de5e37e1950a8281d35d353b4321ee589505d0cc543a3e12abf7a28cc5c8fa085bd26cfbb5cb8668f3ac1404ed32d5d6b0fbcb62b202ddc11e5e6a89a88176c3552166182cb81be68410cbc319655565a62e77c5ad4c9711a548949454593bab7d58a10e5026b107945c4491bd7e21b6a42f873ee066bf4d9aeb3be5740cd5f7a70063817a6df61108888b95e2cb359f5475cad73a774d33e1f49325aad085a5b83dd7174dbe1d1396149614debc720830c34ba0ff32646342377ead9eff2573c980fbaa2970c90969a4e09741fef907637bb3b1f731d88e4a48d55b172a2329b5afa0adf2edbd5223840d48dc8f226abaafb14084780b74b484a4623c88f9e004416bf50b17cbf0d9368e38a266b4b0a83678621fec80d8328b664fda83685f77d2fad46a668dac177a3d8f3dfa81e446c52a5b9b3e72109d25e96dba2314e511e8ecbfce4c7ca85d8c6c615f416ca5e4fbdbd8735a5e8d0a7f1bd6f13180c606f63576c03b0d3145566da1d6d9e0d32e4d12dd09201551bd1c156892620d16e672e339bc5d6908c76e088d6e7285c0f8f24bb43099d48d2e6b12de74412e53210940eb6bba77939e9e092329b49fcf96503afe18ab367d8cf65cee5bf36071960316e69157e23cace6138dabdb62e377f1ec3c883f4736731fa06496c4b87302bb1f5bdfe8f8f07aae481cecae8d5be109ecf9fea6cb21d18a1e5d3ccf34c0542bbfc584439e9ac649f30b11c6124068d6617f553147ae17bb81d2b22a4c342e2d4b35fbba263b2b390d9a34c58b796fd1c72076b5fbf20443bddb926538e9647cc74ea11ba2df07e6f5c936e7946cc936780142527901df7bd9347a1b55310991a81c25aedcae4f40fe3beffe564e9508c09fc7d091fc660165516f83e38fee9747dcbcd05867346f63467e35e94eacc533deecc05bf3eb1c90c9673ee610845c4ccab899689a0548be4bd596122128390dd1398ea846bcbf162b9d02967e6d56f02ef1e3b4a66c05b77d113075e98e29ec99bdddce11cd3a48b6f82624064578deaed46d21e22d0d131131c2f166ca5cc9603c2a5a16cfca7702b0cde3c6eb05571cc38fa70e0e51779088f35a36f4ce36a663d8233b34f65bdb401c69fb8f5f817f1eede26291b607c0527470b18c270d007619f0923f9b0a1b0a16f515f36119e0c4e909c02446f822dc29267468221861d1c14dc340f157e9bd92d933aa69f131397ad51d2e4b34bec104d9b1b4ab2d6980d187a74aab379a738f10a15065296e9fecc9c04f0a9474d0262855939fc789ee3e75bb6134d958ba91fd501c48a26f8ecff30290f8564afd3886dffd3dac2934fc1b34e03a55f777d2f15036a01096e4c7222a953e65a8135c843014721d4037b81d78b667ccaba1a93794bdb82bc2e2edd61f04d781c79280ddd0e511386b8d0dd3da9f650d6a6c2d9b2c0ddb820328f7ba8a27f85e0de11d003991fcdd2bb5182175e5eb505130a63da64ec8641765bac26a4fb3ce501935292abd37bc89ec6d03bd4794126e1a71b1039d0c5353ff472b0767e1556f9dbd26372f96e833aa8b6940d8e3eabe60eff6c22f66e2c0544d6119eaad0f87c564fa593a7e18c73d795073ebf812db376d3d615e565dfd5ca8964b99ef26b8995bcbeff1e55ad169525ebfdea1f55737400532b91bfea618fe30eb1ade246161d873d7681a06112ee1af1dd3fb1a9e74af74525b224aca40b7428c0c9b8ec53fd78d0c1d2e6450f8749e39a4d208fa5ee89f89b1cc1dcea0bf9fe7bc9cd90a68893e9428eb1159b965f5ae275320841deeb6c00a633eb06e8c7241da071e0e262cb8b99b62bd1e3f4ad406b0f4e113541a12976f9890e90caed53ae153867b30631599cf597f7d43b018d385467f16d2610ee0720a4d5ace649e4248c985bf8c4f5b77733a39653c874a2900deccf5d031a37e3a999779074e233de7f0da4552b00cfd73bf4183a8886474056db741d48564608297e6080ffcf506832ca8ca86d6f367c7d6bcf56900e19058ce69919f81dbd633130e4c63eaa14fbd0e540a909f473894ed255321626564a0a1c2659e69fac3725a6403431c7d8e85c97149da580277a2096c7022b250259c0149ce3ab3a60ab61bbbfe8762185a5cd66b3d24510efa32fc1bf788965c4f53faed7bb0c9f2a3cc814f5ced287c2cccf2e36864a0c51d418ed82eab38531b932b464cfb7ae035eee5b6e61c549115b050347cd1137d328eeaa682e56f26fb7a8e54ffc44e97087fc071ce70d32a85f85844423d7af283386a324d4b14404a14b09a8733eb64401faeb76e714a7bce5120651d3e483b42a25f556f5bcd64d47137e76c6e53efa8e9e95d628f1289e14c050088ebf2467d43183a0a5bfbfeecc1eae9afb6e57759afc4e75683c8083ffe28a794f99851310123e9d56d23a73fedd14e116ccad79bfab8e4cf5463cab6aa027fab7f800d65fd04c0e7a84710dbe125b18f4620f7aaaaf5d46de4597ddd0d155ab2a9ddddd08149281ec6842200ca6477a04094d1905703921a82f4db19d1ab5c36348884d7cedcfaa8d333c4a2328f9b7b587ef763916250e50fec5fb05456e2c2a19f2381f6abab80bdb530ac612fe06d12605bfaa78ec7a4394867065f105fff9a9ee9fd4f9072f2b84a005b826a5b06b0e0764e2e9672ca2199e15aca33bfdfc71a3ee96c305c235b716f1e3350f965f06027aad244b325e3cb7335a61e90e48cc23020cae8b91003b4f0bff73bad8f3687522dde359990c390c45000de350cbf8d37cbd8f790765de3ecf5121731fa31e834aa8b652271181890da47a8324da231a3f987c847a66a27a06c1923bd0f5778f9a29e3b640038a84598dd254d02933b5bdef200a853322bb4fa9c6e55411eca36063c6dfc4c28ee2b570ff8f71375a8d657998ed2c94ca064a4aa4f6d0d85932406e6580fbebc0f756b81f2b78fd24dce78df90b1ea30a15ba1447f6ac5c020424ddec53565ce1165d13b363e918c1341e95da709bcd5a8220737abd025cd86bd57401a1d2f356442a8661b489b92502c1e2cac1b7ad49806d06a9b95e7c8605cdeba979c9a82b436688c7943fd2562d46b401fafbc38112471e36a9be086458f6b460b6c25181bda834740ab22c0be11c17be559a469cb7a2568423a526593e840d1b398e7eb00ccc3b7a0ceabfd9697128f33aa8a4256771b2f0d4ee1b4d10612f9bffc96102dd8bc7c9f217c3166abcbde219ed9e1cb7ca251e1661ded52374ed4d53b255792f59ac835ee3f55dfc345597d8bea26a6c3c29dc8be77a3efdf30091d731feadb15ca0b1f3b6a89d77248054e7a75965a4f97049097b9b0b31233492e126330b8426dbe804080bafa114a3f18781a1c0cc1fe4ba1a45e7f8ab716dad12d14b370e919f7185cda1b6589b302132bbed8ceedbad2d6539e0d281a72f6c34418c5d8473d2493e7232fb7f7ee2c7bee9ab41217de2dc2d8ba5b59f96a18d177c6f6f29f777f6d635f0b2e0fbd2cf05569f00f30d03d0a8d340b945cb1ce358ef7b0ebe2b2fe91c4f13263ee071153f2085c8b247b45bb92c508adf96c40e6b2c4a50881f632044b03b74c20797c7ce04268299321bae9af90afdc0006d6ca60e184a3e74f320d36e1833a7c434b89cc3d3930b03a0596e2b51b91bd497636b8ee47343b0e4c2973b11662a509876dcbc7ed72b2d2913e3c4e234fa6a5cd21a561c6a5904f7880378855e4d9c986d0202f49279fc6e48551e98f6a2fb84a16348490cc4b9663011cb01e648bebc2398b5223cd1ebf76d5c8ec97e442c177032ef96c4437144b5c83a8bc8c3c519f9b2c1bcd9e6fe774098d953635fb2c6940aabc64a4e453db8754c279b8d2a35a13f02b02a119701e276c444ce49673fb1bf20842e0a79e3747ea2c1da693751e19807f79e8ab19142d940c73024d5b71e5e60c73ac38e8c613c5a0d01c2676084ca1b0f965aa5f6690dbad9d702aa67206dff65a3137f9eaceb07503994098e811f1a0c6910b5f61165f3f151a18bbb34d55dfe4bc8dccaf9c74d52cd88902de96fe9f506fd76c0b5aa968da5ed0173aa633f52769e37c7015438d298b4b18884f2ad162caeb8522879d76ec9d09a113d44d540d9a61c36d43e3bf553c8803641dbb40854b53017428f0c1c19e904067aa360aab2abf1e7a4f142cf9f7b627c78262034487306763795fd7f17b9c02fe4d5fd8730062a655adbcea1129854ce4ce7620463c675cecf1ba2334ab7b8649ae0f54f9e8a560918c23b4f03d2a2ee906e956315d6d3cd096812055b5eaa3107c6197ffb429099cae7845353d44d3549b32ed285d4d90970f7892de0580347485a60aa65bbcfd4d3f1ccb40aa0bd0e07ad4fd235dd854f5562e7a582aa178a1b53bcca9ebefb670cf23d6835d3317116992e84e6c907280f8d890b3264d653e331085a220f58dca025f995d0ba09376790798a2449d1964a8f7e174464ccccf27f2c6e345d85dacd4169b77673d2aed767804bf54a41cce2cb2abc536a577585e6e372838f4ec3334a6524843cfab3595d290c0c1dcd3ac9cf9f67a2257135a849a14e5e7d84d4d3ed0e3efaab3db213aabfe45548a8d1f603e419508fa7aea4445657e1380e501abd60b59d179ff87abec95499081a2ebe4dc82ee3a2328b905dccbf489ac92b5b0371e0086f3147591e26f4eaa6893a18981c5a49e2fc875c9c75e8f1b0c3046f67ce5a691c581ca3997a810686573fa3e64c7b02a5563dae7e988d2cd77153ac42a1b43661d7208d1a687a0a3a60204dfad33d9f8e765bce55c4dd19a3d006289f713b44689d2d2b2a5be348ed1409b532097c333126b44f17c2af18d6e84423f5b392677b2575d0bea578a1c2d1dbfc7a20f5530aa4a78f35de6000221c766bc0c97b5c90b1ac5b52cb7409841e02b1611cb6ec32bd23a1b33eb62be10938541ccf5a4a6dff79db7957de4b201b308676ade08586fa0b6c12219cc13c32b9beafab3849079a1f3decf09229018cbf2dee593ab852f9d33dd113b5e36c35cf18cd9b70435bf8a7c89fcb7cd1549f5d544f5c74ce2b9f452e3e76bd980cd1a0d83bbefbd10ade4c1318bc128526416f070a3e0615efa087ea0460854ef654e996716732bcaa987845adf71d5b5f525daf5e4b764c2b86143ee221796f0fe5e015daaef7c1bc3c04d9da7fe893c96d39ab64b96cab1611dcacea5225601bfc39af7cd10f35ddde49d7f4dcbf2808ba7c0fe967c246ee6cef198e0a0fa54b171d91ce1d74812dbef4d3cb526a913775e1e652e4ad34b247b084aaca51aaf75714dfa9093050024dce06906d2a3bdd25b18e91b0c2adceeeb0936114368f7eee6d9e920de21c743df30d0fddfdd8eb51aa1e3e9cee2009f91cc95083e88c94e316ce626298d13a11f17876cc3304388674734693fece8963af2a4e8f3c4d963966e6558273b96a945e8c1e711f59cd95452c5365c322a63ba3412b3ed40bd5bd5cc0e9e0234a1a88d96945a31c490455f6cff1fb45f42c51a4713abe5c73f303be4df5866a9e027b3d9fa412fc896f99bab3c74286bea3dedb83766227889b09024df2d9f518017bdb5d2c673cbfedf0f812841e3d4236c2ed861b64233fb7464fe33b3957615b271d9940d4b383f098c27a776f4ea14dd605dbf308f4fa6ca0ed99c2e38e2e1098ce143f22d12781465564e872332372b19fb3992b1a56908e2521fd8f94cb4e7c84355732aad4b59d790beeca6f7733baf46e06eaf01ba6c9c77cd58d82780f7aba26d836c86f01c986de26cea32fb619de45643d752e4797cb4f29d8b5921cb613b0949a53eaf00e4865300210874d622a70c162956cbefa65a037f966567a4ed5ce3b06d5725348c344b9ebcef2ea86f1cb4fef0e43a376249d54e46268395a6bd8b31d1a63fda972c0d1f94f86eda0cf49a3b448c6c29853d592d2466a991d09c1581b31fbbc40f67a8d62f827e94a0108466b62c10147a7e3034866ad128a0e26046bea72bf6a221c896ae2cad58120314943a4148cbd91605aa3d2b66c739c1264cb56530c1238908077c0ee6116c11fd271870d5bbfddeb152a750d586f5ed444184e7791801574674411c015b5cde2154582e3fea9412e47cb5cbd41a1cb0ea6636097b1c55983a1cb120220f9211af1401cedb70b7a4fbac88e1457693af5b984aad53b8ea6ef9298031bf44e06dc4236623c9e3a9c4dffdecc3e47c3202aaad4588c9fff59dcccb513e1b971aded45c43503839a6a9faf8a25498844fcaa5787346a0594ebdfe423031ff2eeedc1099258e0d9464cf8acf957d7c3ffd3d0f08fdade493a9746a30a36ca3864dcea5a28d65b136783907effc250fd526c24621ae800354fb18a094fa3cbaff50d8cc1b0fc57863095ab04e498b58203201be49eaa032e8663fccfab2b4e574cf74ac635ae43acfac615c99a0345ce739ca322f83d661900672f558ef1af4faa966d07bec9a45a659ea97a8712482c1934952303deaba641a9bedd1cf3d389b79b239cc343c39f1b7ce492a671c079d0225b497a8b4b72161bc004593499f5c5239ef5a078d95cc5d9f9a6a9b3fa23f137cf7576560d35539ddbce053aea00bcdbf5ca62dbaaa781cf2b37b6369a575aa1b6f4e94c0101b466e10336492eeafc9a745a33e6d816a76666bdfdbc04306a6da6f8592dea842850d0bc03e0de2e416ff43adfe87a95844cf5a15d723c6cfcc54c2d5a292689e58687f0bae1e68e59475515b98fe5bdddff386cf29b848f4780d7786cb472764e4d1af8aa59264f3c09052bbb02272f4cfc7fa717a3a6ea1b347a143526e69bcfa53518a16aa2bd17c6f6835eee46df19fe042759545cbe3de283ad00f940c92cc377e1f5f7243a370435ba24b3bca65b2fbdd77a7e57cfeb24949a0f5b77ea6e2328de1cabbbfbddd3334080a7a3c8e24294d339c7b7edba383e33338d6249fbd8ad7dd17c70bb81d17d4a2342fe252453a8a84b1d3f0423ec0838e758e7f1b93e9a4fda138c19775eb5d3474469d625ac1337b190194bfa93ee10e9bb8ba835096e5e37b20684f4af3251d580c0cfea8819ee900eddd98248bb8386b47b4f3745a8f3d236ece8f47bc61fc7fe04016fbf523326b3bd6be8b07d6968751489dcb6ea4f766ae496ffd978b034bbd4c4e0aa7d08d9e8e1f0bb6381f2725c2440ff69319b45ac1885fdc15f4b7b253c3c84ef7d110b9310f311cbb7a3f8bf009493f9020121fe83948bab78ce1bd405700022a925e7d1b91df43b208498be58e93dad5aac5e327614fe28d61735b602b314a4743328a9a1843420aba5e688205e91df6cd1f18774ba6f825b7e35615f1db8b68fe327301280d277c1ebd1aa76ce4c3764ef1653292fcfd39c3f0f75375cd868512244896f90f2337fe288d86fdaacf46adc7aad6b0fdb5a04fdbef57c5724ad4545face979efe41ce711dbbc61248761438037ed81e92eaa43660de3278f2683357d5ddaca8a5750aae0a88656de636db6496cb45d1bb3b729b8c55fe547b67e59b7fe849be72cff9585f9a9b2244dd991f7f4ac6bff5375f6145744697ee7993bc8849ae87c45822f54d5cdc1f9c9756a3db651d3f5fbce0ec91ea67df66c9d4a9894fa1879f539b45921a8a7fa79290c5a4d140bf068e35b0e74e86914b1b61a20e4d9120ece96a2cd2192752d2c81b431f8ec82e9d3f448c1a305f5ba0eaf3d1ae1bd06dffc3871a5713124fb0705f648481723070045613b4be23d3e3eb49098b5f8d44783b100241fd3c295f77cad174f4cc1e0e35051a294f5e5a6827f02b553d24e0a8ff78660fa2a08ad837a2136c6b489b04caab2b88bcc8f302115726cbd8612910d76f033ade26ef8c95d3d006f4da4cbeabf12cc9d77f9d4d8d6664eb02c0fc925d26cc0a277cadd172b579c95f88558504354dde4b7547e3a72655a59a0e696bea25dc6eb2e86f272308b94465fcde08923942c394b0e110003642061595d098c9187826ce7ea00e855eeda8cf762984b297a0a98e9e991baad56fe12280cb2563f89879668f674ba2f226ac85cfebf7f3b3e57aed25f52d79e7ebd368100dfe92a16a8c4345a16813a11bb573e55e77d2280fd690bb7e14a169be24ca29a899c09c89e536334c91f69b0d0e8c3b22312de6c18edecee446cfb8bdb99be8c7e92ca80a0067e318d9613b0e5462495ad9aa191185e3870355a10f2958ecad2ebc7bd9697cf8034f7478524761bc032f00e6d783894febfee9fe33dfe6d2ef17f6413aa4e430ad22eeb49dfce6cf9a02029005976c98276e14cc54a7fd3606673f2046e7008d5215f218b36310f4dc3afbbdd58570cd1677fe56ca9132d8170943777e09e824ce6a781611c62360d3af420a8023e2b122a265627b7aae56f1dc6968f050712fac0913d77f38a84078b89a561acf785846bfb8ea7d98eaac8443dab7c8c04c04a7bf0e364a2d5ef0ad59c4fa08a9f9d485a3242c2b956221dee45d897fcc077e649481a986d02a3be022f1b97f48daef92b72b14f288d9b0e4173cc35e167f66dd8c8bb6f54794dfd79a56a539332a7cacf09219cb4fc6576f8e3d75291abba536aeaa2ba9a69eee4fdadc928d709abeabcdc5c6eab4deff5ed457de57804afb27fd27c4ca6d7115f795b2096c3a23befbac0aa3d23bad908a02f828d3f5ced1fe8bdf6c9305b8fd61bc7b24209c98ebdb3ac57b6f7edca187544719d65ecb1db067dd32f5f663e0e774668f231a99a3f8a4044fedfe7fdf7f6c6506e6431814928c8558683abd3ec201d10ccded47fed0141f0073be20a983f88fa65271de276028ec8f7a4038a003aaa0ffcc67123a8719f4ba4faadfeb734e12c9e21ed2c497b65ab27e9879588c00678305541b8d6ac962ab81c64b05ba7c40ecb996c30c3710a5fecc276cf99fab967c198ada65339e36c350fcd8d5ece26c4c977eb5e55a77fa6cb8413a28adccffdc58f6c887890c69d2f57a684ceb65c8da1d99ebca85dbbfe072fe994dd9b194b8731c51c3ba862596937fdeabec6bc9aa46c2785cf24b37c9c53ce3695a2d5fa150d94d35187089b7d2dc1e3eb94fdb143a9c735f51cc0d174c84a42d8c684c8f67136701f7afc9d6c42f09f85d529259997a13dec41a9ebf85cdc80a614e6da7099de129c1063dae3224fa81d64a32939d1f40ac520721eeb0b334e6c0b05cc5a964a33d6aca6f5ee3fb72dbd9d6b40dfd865f98d2f13c1c41d3a398ab0b887a7c4f98043592030cfb6702682860c3e6d5848573d07a723e8e79a4bbde07db29e61ca4bb128f037edbf790c8c1648faec23a5ac3a54cf2623ae5600a3df50e301b24d0dcea47c8489926438f57458ac016d714d495a8545c2454f7047dbf1bed7e34f94efafd2511891092ee0b93e12f054fe3b73eebe98dce3f1f601e399def5dff8a6791253309f2b6424fbfdf10abc4718fabed55d01a7d149de0a02405ee0514011c585306614310c545b5aab2e7baa9becf4465ac0c71ebaf2cfa2d990c2a8260ea70b44c9bb55b8b7c057fd9eefae9f5f878d678d667c9fae87fd434e210e540993ef3c7ccee8061d938753ffb169d12263182b142305fd0cce70e5c8afa2e1d088acf4e2c9f5e0f71fcdd9676691f7a9a64196e5283c8e3d857150c57f014106eecd124285fd86a527bffeeac44aac9575345d953afa58e531ac7ecd7bde5c42a3a8294aa8dca8e446bd54c53b6edc90531ccd7942131f78e687a41a7b3e8e15bdb1c33380cd4a6cc2bf10779b48bed372cbb6b4b6dd3d3bffdeea67a8ccc975cb6836acffdcf8da7f83cc4f1e9fc6a4d55e67cf4f648912debeccaa093e9cfc6cd55e889541f72131f2071340596c8d69781c052f89d41fefb5b741117832e5b9235b9210617857e3b48687a367563912e01166c928cca1024d57f5f4ee27718969c5ea9bdd3662b9cdfe83","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
