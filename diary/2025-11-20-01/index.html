<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d36e8b7a34f458ca384026f3d3c824c92a5415b47095c1c7a21a96ce6da8592d34bdd85c70645122c080e3936b2e4859a46ad724bf7f4b65c2144b8de238ee39b9b290a2d7d791226e9774a025c121a808fe0ed74065a11373906310f285fe3f964c57364e2c47d777ff82005072ee4eda14e85ae9adb40319d281f5b86afc0c7c7e00282391c364ca53d6b81a84d08e17d6f06ab29c1570af63189edaa18f83f79c356f5114f8976cbde07a9947cd73791d7dcbed78a3c81fcc882b40b3ea76b875b5b02ebf0bf7a224b2e16b541cc78ac899e341ec3a9a8cfd916cbc99c5f2fb7e1f9e1af1823796e567ea3727f39bdd9509cb0356131d9b4f2cc813cf6c1ea1ccdfaed09887bbd54a6d3306ef5050338f36b3d069b4712f1fb1113466172ff0c818555491f5f9a1796ee53ff2c9ef726b306e1f268490df35efd2f0a3b7112b2c167c619229a6196df3329ade64cff1125b2c26af8064b90af39934c33353ffd1616fb198fd64e4bfd5218a675bbeb1112fceba7977a5ec0dce364af18d0bcd8393887823e689f862a1bfb71d85a3a1a9d82636216ade212fac8735a8fb96a98a8b2ce2bda3e33636dc92886b85375b6ba77d05d3db9c42f9c1eee7143976f994662cd300e38f2ef5d392b2b3b318724f792c7fdea98f4861bb92f933ccbb557d54f3cdde347cb31a7e6cca05b754bd7f253a6f1fa8aed934d1c3f05b8987f7840735e9a9b3e5e2abfaae8ab86a4a1f15122bbf178bfd73627149b7dd0cce3db4756963a4c521412425dbe4264882f1ee70897b3761e86e5880354456de236adaf6169b9efafff61e2731798370055ba813de47de9a84292875e895db996005f52e007a9da7269d54320d9661390c9e5e6ab4183abf06532e89017ce9c36e9345e14764b20d02435af58c48e687c695e3ad8437660cb67014995513ab81bd4dd3736b6aebc3f0b72fef4cc88c8620b93c29eb61185ea409f06cd6adeefac6ef74e954d0b1672a5d388bb65b637c4bafe6541804988a7f19aaa68377fa1adca6dff1dbbfc44cb3710044916b988297d15629e14d362882f862dddde218d81c017365c930ff5e5a87490b9fb4613c27001baf11e3b75e6ccb3c92a6a006678f8fb0ab29a68dafe656622d19996673fe3aff21b781b6010413c5de2ca6bb01cfe27c6a417471328af1bbf728a4468270567a6a953dd563a6e19cb80e2f02008d46dfb28909b83e8a1702a71b5a708633b84ae6915e6aa8bc4c67dbcf555d556bc6385143e9967755ac8953ee5803f0181ddd6e17fb7829825b46f053afdebf523b2266ecb313e9d8f7305728398e16677a2ecd217ecb9b3e4daa7a76a6cdb10721f3def80a625d58c565eb03fc306896e27a642d1a4d620ac0352bf11f452acb5069fea70d8a7c4a0db0800a0ec3b5ea7d6eb85b7b79ecb6c4b0acf4e5e21884b0fa70c6b0f3a1a564f8dcc688f5363b9d71dde3bc5fa5ba2d35b5c8d81702b3490af959750e59ac2ca64994a8ad8b70433d2875a86f34cd226423c68b8e73e5194987755bc7c21a4fd0b25bb6307a666027e6dc4f18968c5c984721a98da99b8605b8612bda5f544dd204f006411ce74d8e9a950f3b1d56bbfe56653527069911a54011c7d2a89487d4d1f487a0b9e0f85413beb6f241deb88cdaba8cd20c2dd7830003d78793abe8881ddfd250f14706b7da9d89751827841db374b619f3c6c67be04777ecb6d6d534cd0485503ee57d6f529a1217e2c8b5e29a7ed155ba9f18250e4abc3fc188e1110ab628981369ca755464bf77d69d4ceb3ed92fcf6aac2f4dc5054a495cb3eb01b9e824b482c0ac4b954514ce27b851f7ec35d805f506353ccf0ad672889e7ccfafb50aa6b3b1a07fd34eaa471af67f87d379b91cb3438e2ce67c2b47ced3c8be2c45e8ef5579d9bb67f7584e38eaea188c81bf66c888bc57e13afb502c0a3725d900e2eb5fdcc320bd4ba29a227b03b80beba34d3e8561e8bbe1421c7a6b362052c0567262842509bf2bde620ddb10fac2c61787024105e20d3f781936160f1c3a3669aa9f37829e9ad98443dcc4af7cac0f89afd251b88b730da937998266bd3fe66cae203b6b97e18470f079d424004ce9f868de53b96aa82683021efb2c41b8049acc76f25282329fb85a1d365b647ff402eadbd6be7cddb6c0f6f516a603967407c00a7330c65b41ee8657207cba597c97ab0b261c699c50be994435cdff3fb93397e9db5d6a46d2a0ac0e64ac6f3018973e0ec6b7abc1f211a1b898c8880ab93a2765acd40203e1552c5a241732e8cbb406996f1adbe7ae4d6972b5e54cfa7f822f956b8702ac90d7771cca4ce90f73d1c8728c88396836728029c688152eeecd9432e5985584c95f1855f77c3c9750e803a62d1d753390f81176960ef4f7dbe99749418d2dd328367a9d84e38a16744e8606302d879be33f751a6ceed387073f6f0aac17ef1ade40ed48e8122c5fd00ae2b940ebc3a768d46b90cc8b68759e466fa353f4a66b90ea3112b1ad8a87e09bffe189a244c33c9c9f3012af96ca092b5b0a6c904220b57fe77ac8277d8a037c03dba2942645e0bf60ecd4a007d1896820367dd57d9e084c0768c9a1edb68d8122d23034b7ae7cf814be86b2523e24066fb1f9d2cca04c1f0a845711ffdb7b6ca14bd8360be4c08ac614dbb7e3f11f4af82f8fa039fe6520136fb8bca771b71af522b095d16e79444b758b8a38fa26032a8c881aa0e3c3b21cf63432615f1c9a9bd2a1aa3b0a23781a96ce5d2cdb4db954db2d0207a136449834b16e54805dac20aa17be0f20421c20e8639e2346a0ebc44d3026ad0c836821e956797414b323beb3e926ad0cc67e377e31941f8f2eb6e8b94cf89f4c17b10a13790f5b13954b23d6567a0f949dd045362e624c5e48e389937a2bd51f021ba9372b43455f59656de79dcd1271deb00da3278fa759d9c05934639656c8e4033a2f9f716cbf03752de33ac349636d8f92bfad78d24bdae514ec7493499b732680d62810770ad63fa1a53d9f5de9a694c085370949e4b6dd63aef7f16ae292c48a3bd07a9c2d41640507e0a2fd8f87cac5d9b3814d966179ee89edf4da32fe27ef9c5edbcd99c4a79f4789973c1383ec1efab4e8d996886ac036f3df5c5c532deb10383f798f955fdaa4f4de50e4a076b09476927279041b8115f69f5e6b70a184c145d27d8d47b002136712fa8bf1d79b6fdaacac120662201e09c485c922e5c79959c7b8d719c219018e47e1b4e7573d987c73c1cfcd734ac486916375f96da0e12b4d635e95bbec9ece0a0ca2baf4a832f76b5c8a4ab4d5e08b62f74dd8aee4fbe18bba0f41b146701ad89f01425b74156cee409d9b37412ae1187bec29da3a00aaaff2bd74f9c26ac74381b5eb9f42f2c7bf35b302ff7f97c3184e46c2b5665cf1da853197afd1f0add1b209c059fb88120ca312c0cd6e3e832ec9a24b3c57326a7b0535ab60b8a95b6d095dfaaaea596ebe6a47128cf6ac065ccf5e323090cbdcb1de27a6d2b001785d9446c1cd3d1730fa23e1fce4ab624a3fb00b9357a5a843a34d96e9cbb0f4233623880da14acb4cdc11b0299bc63e42a3f0e21194625cfdebff4d241ab0a275e5dc771c34619673f5908799103af52b66e1ed010e175b3b39fce8ce91dc297a270bf7e25fda14335aecaf4ccae874e99023f1b0835abed2340eac0ab629fff2d05d80e38401afacc89666440047690062a4331aa8d1966de2a22788d224ada22efb605ff2c6dcb8a618a9e0f90be5c4a2f2ca0210d181d5ea9fdb3b873bd09dca1cb629e2a5ed662aea5d58c49ba401688b3783a976b30cd1c90607d32e5eb0617f81043c55f20173ddc08993f31bf5425c75cda403f09d90e821a6c685707db27d84ade010a380b2cc3ad7dd65159a1b5373bca630451ace93c75ce3b554ea4159d79a658d5ca8db9f36e05a8ffc04514f115a9f51ab49668924015cbca9bdf9edb5481a267b7372a8382e23b8da1c64822d04f1b1cdee49f5ca480806882476e581928b61698baefc50f9b04fdef1095209a37307582b914ee324a576b59e3f1ae7caaa9869c7d9e47ed1052579791babdc09d1363bed483565fde20c66be5094e2040fa44587b8e3f951337dd6a110d8f2b6ef5043c98be0f395ce5435cbf74ff7d282e22554cde7a320f2edabc69a0649d49dc0852d06bc6349417f894944c3907a1780ff8ef4278a165afcb520723250917bddd514523eb14f3166e7e46af34b4988c11f2062255c92604503711c603787819392b8b101a679645f2ac5f89e6b6515b76726b371a2352bfdac2670f018641c726378d7ae4bba57a955c19d94cb5c38cbfc0da08f7d39f1117281bd2cbba19555b16e8a8f7a68828f9f4c89c741c3ebdadcc7d94ad1b7f8aaa5a42b5106e97b7d4f829b581332150604bea5f0cfe0dba082bddea3653f868b6239dcbe0b21a8f3e0d120924e6ef705e9e954c861f15c9ce236a0ab4f1412e554c838dd630a5ed10f1f48ebbfab0eaaf6dc92a68958541cb165371d16b354214c17078d4359687dfe98ffa36cb426809316900508e00ccd8c0f39c4c6cabbac0d3efacbe60cd809603a02f7a2af70fe150f6d7762c88985c604a9dd1347f268ace16f14fe2cc23d610bc23a9cd2a57c47b9fec5d5fb95483fe0152716f88133739252726c131d96096a3e2332c4ba705a6ca9247867fc97adef512ef8909b4e7dd296c78fc22927b48ac9fd98d068c89a997eeda40bb950ef69c67d9befd269e279852317c7aea092debcb9b289139c44864b128d50a3fcfc25718223e0fe3471a54bece87698bbed5fb63954b0bd2f3583afbb767332cfd1055f5fe68db5f6eb5dc5d58e4e23c0a99bed27514995d5dd6fe3b8c9e8d08742f6e33f0b41ae747d3669d6f9888f7846d892cc133e6c366932fa67a731c28d12f0c837967558642dc52fcbd3a7b7179f09aa3fbe8c6d80eb15ce76626445776da11ad596b8b06f155b39f26fc8eabc308ecbbee708a3d8eb4f47149f9b12cde082a68dc6e07fbc1deb635c2a868f9f7f95bb7e9f383619bd100d493343790104eede9c0cdb3207c969c6cf5df4622d94c158e21c416d0b8046adf6eab68c1d5c680b8824624d5782d23d4cef2aa660144162575637f1e9b0439e97bab7c0dcba254d8ffbe8c54739718a72fd9ad00830ee181f4fe646ef4c0f25534d41d73cd4168d27b29e07429fde43a04a02981e1daac01036ba8cb209c03dde14f718a181b6938a8ac3a0fa497510c129e25924b719b8f953416bbe1d1720807865d6518fdd2686d90d48aa67b845840bc0baffea65b0014c81bbc819cad2ba293950152fb9c0ea959b51b5a4c04dec370ddf69c14f00b377e2d68042c797703f8ef5a017686f9c2ff02a3f550e6259766bed27aa1d59d853ebf4fd4fb6acb803fe714482ff08b573508887042792b23d4c567ef5c535a4056fa704939bdd77baee084fb16e726b8917cd6cdd9e008754e257f6407454d3bf91d9bf3a096c838c8093d1379bf355995ecfe344d3e72485339bed84b6f64a96375962861ae9d9d803b52d75372b4f7e0edd6c78c8a09939b1ffb2b2e19b99ea1be3d4638e5d5625f79f4713a26aba21d98cf36f6f0e5decb6581546f15bc5d624be2dabc21ec3eb79186b1eaf57d8061fe8c8e97accb1e4f9882d5d8f1078d1669b929a80c7c17cb0ad072b7af7a0c39613251fabbc0a7c910cbe7144912913545d25934c985231fd5c1c8cbcb44a150664497fdb819c9d5ae350de0f1490f9f48b849e91bdcc7ff0fca5b68601503ce1d0c7b8082be37508ee8e3b07de9810850be7a45e5d3452802a5056bed872989c42e4bd06ead78306c220dbab16b8dc233fa69f30a985bb7d68e08e706eb796b452be770100d8cf1a28d6416b739e8ffe902b3b921218fd202e46e039ede6ab11bd9cdb8337f789b9cc7e6c9f0cc15a65107cc61be6dd0ceb1f8efd05ab3c76f6839daad6c65169b9990faf0e4505f7425f40a0460f6c1aa81dbeea5a6ee4f8ac2e89b07e4d3a3b633240886e3bf76dd283e0b4ff153ca9e7e9e49bfa2ad0858fceb7f31b9449a50bab70336d189137f989ffc82742da2cc37807d3be09f94e71d4300215072a49b5d46401b6261fc89f284282e77c74582d36968825db278ca5527b530ee4105098cb5a3ffca298911f3eb687993c1378348e63827e3fcfd519c92831035f4d4211e904c36718487ac6c63a5514491a6e8ce9ffd9e88cd1e95cf9021c098232e5f1d59f88f3b362f55ba61814cd831757fdb0553638f9619b94fc9c713b650cd11f1e7b230e9edfe9d638f93f1b18bb2b6aa135f821456c4748269c2c90e128d194fe986ee5ee179fc0c91cc94bb41ee6f9c643434d41ae8719541ff509d93982e0d37aa45154cefca1aefe06e91aaebedcfd7ad24e451b478b2afdc52ddf1589df0b62d59f16c983bf4b016188d1884e3c152812681e702ddbebeee70ba3dd5127a9f244b7a8397108460e1da76384a2593a4b818b3449b2c0d01f5801372ea78f5495359f89eb1e80772178eb9a3ce47381d454007fb64fbca9d86f41098e3a0709d60776ac02d23cacd6a30f4292c20176429f464b56a284cca5c422c0593a706f1ebba0293442aa74e098ec427d63d1ede804a6628fdba6a6e512e383b30ab05dd4f4c6220092ca7eeba052316a449302a221fd0b9733d6a5782304b8bb68662d129caa0f9e80796495da3e80b822683cfef928a37033cb2389decb37f55e15f74b2997653c2c586c338bd171fcda38283b987b90df652d58a62219b11b3971875e1f900d198f53092230d14573e92e5ad62fa35c5f86abafff7faf30676f8e7f67e90655e41c51e309d7355acbe0a144669ea28ee5e4cfeb41d3455ccf4551ef06db5c441d8e910e5d3d2278c7168ec5b42f53e3fb6873de6090045c89541b0d05009c8bada2e21671a15938c7d94403d8914ddaf818bc8b269d715c6fe3af4ed74b7e15605be266086ce32921bf483d97e68d166a58ee9a99e405092339f1f0fbf7e104971fc294169eabc6aa2b65102b3f56ea410cf11eca8eb16099068ec1b5f12d71873c57fc0f6578bf2a47a1a6fed502c2da7da9fed47f4975ae739bdf4db6a785668235c4c458ef84750b05d12e4edc0e45c364826098e91d5a5c2cfac58fb4f4584ba48a2ccd3096b912e8aa1fc52e9c971b4713150bb214679b93edabb11be62b9caecd9552ae07b6cf9adf491602c56d3ccb76afefc2eff29bf29dab058056bfe308cebcca5e7c3d86ad3ae4323e480f715c988f44b5a626fabc7823e807a16bc8ebbb1eb569696831ef6cbae796d6ec5f054d5fdee9ec903b8fa8593802b12ddfdc36d07c899b3f8192aec75893c393e606e3974b9b59aebc378594293150b715bea994fa95b2f5a40455a18188abe76eabb73823ce57c686174f8dee1a4800c01578d72b090035a4557953b7b5b8bc48b3db62c5b9086d9693670efd5309910ddd82d91adffdcfea5f438522266cd39d28f410f2ce525fe61310b242457e9c21ba9debabbc673bbf8f4fc29502f55ab28be502df7ed5f3813fe968b6991e18e58d4d45034c4c1848c12b66be56acc195d1860bd1fe98fad5099c25e304229da246d9325e27bd7e2e6bd5e6adebd028170ef7ed304a68576dacb94b6f3a51c7accbe3833962b76515f8f2ab9bc4c8b49bebf705e2413580537c1cdc9ed08085347c5138ab63f7b43eb6f209fe52ac3c3904ca6b1362caa9e805377f50f583bdd32f9f4886eca01ce28efe314bc89111f32c798670f8c1cbe1d3aabbc20b4456e7dec424d378babc3073ca18536c7765dc7de290057560226ae96d75dbddfe2e37a81b2b8c4452f59968431596b73b4096702233ba31808baec7f662ab4c5e56dfea261058be1ffd166fe6bb14aaecdc235a17e4bade359351a4d6dd2a3144b6bcfd9a5e6ef1cf121d741d01597f05604dd8d70c6bd6e678f98a4d682046be8e1f9485b8d7be9f8a1046951e7fee9f52cdba32c60cb22ddf09854f2583898153388c117ee7901be083cd94ad8719ecca7896c46091ba98b23e4d1c24ed5538874fe50f11057954e96ca2f37cfa4114a6e0d59652ab02224e0053c42ccded22a07a357c8aab3a24ee57c7670220537e59026f5142c46d56b3275375b9124d7260ba4896d243ccae7f121cb78278caab1fff3607dc6be47b88b940c2291c3af26d0b9580efad61994435e089d33aed66024d25373a956373c4b923e559c42e2b180d9ad8e6db1371a048ebcf60723ab0ce78c4401dc99523ce871df30ab4c6d52c4523ef95a05367d1725b03f9514ac4fda775490e716abc3b81002d00cc8eee3e2abe7743a196f0e5850e3f7c0d6f252a883fcc6b29f0359fda691aa40c02f780ec9047cbacd5fbcce2fd0ee41eb30b50eb9877a3e2d2e4956123cc0a19a81fdb38d1f3948535e2c36103cb63e5b5d15837094f0be2102307b74f7dcd7df5bb3946b34e3e22d6658ec13da3b8b34d63fd8bda03e37f0550871682f9f059b0d6bca35e089fde69ab60f1d421d39921f986498e1c8aaa33542c27e7ce8513a3aa9a22a5913682019382603645d9f9ecf3575cfffaa45bd7556b7b257de3252612a341750ddd961b49998d321d9ca2844310f61fe98be79ba80d82e295cb42c1b807299c0bbd16f7d3794cbd490ad6b9173598f7a2ad5ac8b8b5a19440084dbf9e44b7f5646c3e4ac2cf941fb3fd60ca1e46dfbaa06a5d9b904d55e67e24fda8b7d8b30fab44c99502014d5259fa9f8b398b798a79dda17998fa1fa8cdfedf45080de3743e31bd9be3cb0bf0eaaf1b5ea395c452b6882b2c59a20366b3870b6143f01baf7f7fd0f73e8c1d8257f1fb0e288ff9a70f62ad514223d4e9bd058542809687cac846d8fd05616a25193cba86c8182abc97af296a6a41c8f6f1698aacb5396a81b54adad177fb253d2e7a27e54c93670add4aad3268ddae2ba345b285ace1ad5f4d131131d4b9f5916bd5a66a5ec76b4c2e3dd848275a30a122fd2a15b2bca92eb52b111a75beca94a71a09c1f58bbd7d9784f6c478f830db893ea839bf4de9e363066b441c297db21354006c4311822bf801f2f8e6bdfcc64d518fac0b667c9181e131f50911b9ae71806234588d9e52f1e34a32875f3f48c6616d5bce15d7a0db39b89df3511f907193fa4cfc7b85393f1e6ccf19c64546624576656cfb9590e950ba0a23f2cc9124b7d1edbf7f8ebf289a7f0e97f2f1ef0b91ec759e8e45c91ecd33dedfcfe8d577187a5cf77f3573a8093b14592de08e887534b1024bd63c985a7a06141644223f0f329736fbda0c9497ac824deff9383948143ed18c5246be65f94327a0132bf6aeeae6d1ed83f62203a1d596ece89700d78607849dadeefebd26dd0b74b0891f818dd2b3929d913234a28a30f7c58975ddc47a1370f7f15ad79860b5bfd1096da1dca175dc6d01bd0aa97963e385c295d4a6ff4502909c7d8e9f27ae081d15f2191735afc4bdf45d1d03c3fd35b2eb8e08736e078e19d73de661e20c42bec3c937108aa6da938401536d4b4299d627f894ca23710b15390c778c6bbca8910c77d2b9153af84deac3fa7d1553f3b83d819b89efd1d885e6ae73d445dcfc929b070c278151d2cff0f01f8d0b87e2f9ade4311b9cc3d07d7a8ea0504695f1da9d283b14067440ca9bdec5819abee8f05a749a528492484d20eb731ad3d1b0a86b80fd3e82742a09adecc50f0cb5dbad9eb1ba56545315184c670b306ad0c793adda7bcc0af79cc5a58c695177ea6cabf27a31106256898e33b49e1d4d6a6cc3182da946edb6525a6add3064849b2d3d3f6f315606f84e77c75c89a8c4e762c24a25205b45ae49967fca91b1306f3d278dbbd0e768f2156572ca1d0b82b0837b661e7e18caa5d27faab2a4aa129d65ea897794f02039e8345f95cdf95d11eadc3fd629d09708afd18be32c99598a693287096d4106df23f20405c5aaceef2f716813212e13e2b7da3e00f1b8c123c8472e6c9616615a8c5d3b36f7e316d0c0e565a96c108c3d1f649488ef3cebea865330d1d2f4469b966087c6c130ef035934aef1cf38c69d25e600799f2d1aa944b5b7d981c56c4315d313bf102bb366a0116a7946ed24ef01cfa0ea1ea2a8c619ab905c79861267a10a6ca02398e5d2010444b1c472d4e3a63cdee6c4e4e3776ae6d96c7b6673d15b2c78023fb099495907ebc36bbb1b6bfc608f50a6792ce4a6739cbb8dbab528534a82b8aa771d38ff689f7e82a8c35c55cbe55c6fa94de390ef6305c298caef897c1c396a01e96a509ea09f70773d93ac55ab83c685aa96fb5cb9ee82eec5e5054a71592fb51e7987a8b05ab04735a12bb671b4c2cd9379950d773ce51c8027c92975b28c333527c5d2c422a59a67d8c54ad459b1eacd7aee036b3574bb6dfe4d753e3e4d420dfa145d2311c2f0f37a6d86e18c2d4e2f63b3bf440f6d4fc22725296fca876922bc1c0a318ed416990bb5529041c6129603e4844cef63544fa01ea95dac8ba9f22315665cb2720d75fb7797f3ade73cd2745e3ffcba459afac83419ada157f6d368b0ead433ab79c66b0f0c726f69efce189712512c81512762e1af78aea54fe54f26730b5a492f08e2e5d8c288af42e8d0d1b1e9abc9e07fce940e3942f1737082d09e45dfe917b4fbe8c25a27e8e99ab948804269b954952700db8d8588397bba7735a72d3b0467c9e8780b59c71e58566212d8779517dd2862ced448207fb5253d9b857a4e9c47bcf9c8a2565743c5d8c8a67fbd37fa0dfc9667ee57a56c96a01168608702c784a10b8a7d280d4b3508cfffdb21246e960f10f61b0a356e578ea688c91911bed9df54a8d6d219374745550e5c895505cc436d6a052263f9ab234ccfc26bf12804b07eed549b5e042191e22e0fd5d0ab4b632c948c2ccb10d73554c2184afb38e8bc9b8aa0452e5525b9e3f7d86cb5a10ce0e31f1933919d006f5b5bcf82dc64d8c16415829d825b5eaa089f02d3efcaec864a29caee869cf25fd60c882b7b3fc347d63abf3d0145feab44effc5deca61f74ac8563680577d04ed2e8bc64feb09a9f89b34b32699abdb8eb7e49a9c3d44397d1c6bad635746535e0dc390d0751112b2c399ce203871d2f5b61d5c1ab14a5cd872343bb556c797976fa4d44aa052019fd78eba58479cb78ee1306898a6f1dbf12fc62165d2af43b8b676ab77b2a7335e6b032eca4fc1589cf327d23e85704de1844162265c18cc27e5b65ecc06817a846d3230cf8a19df5a15a787d253dde4df261dd6c07676a8d4716efbb13f76f90bfaef98da6426dc6eacef23ad510fb3bdcae9e1ee51d4ec42fb7f97b1e3c815be4f9ba4e753328b5ebfa78d1f79eb880297015a49b9f593a8ea6d751e27a3679d190df9afafe15bc77d86ff170c7d3606b6c955f189e4f7e9e28b1a8a68a5830b31ddadec2a38156f8a4faaf030d2959b3306868dcac7ac03bd29ee4e36ccfd8567ebb83de2019d88e6a01686fd8742991299aecafb69876cebbe946f9cc0ffe060dfe9fd15424f01f326ad75f5e7246b6645e57ebd0d722eb2e8c7df7a9a0655f25a632fa3dd75dd75d3970104b590d043edb78cf9ae4b27de85ffce4f9c9d59741a650148659bc3c22713a5c05699cc856dc5281442f80d0d0168ebbc5923083ab27f9a46a63886308191912d184229a02e79233adef4d181dbb372a822a0821ec3edd4b6ad71b9f78ec8357b75afbc6df04c8f8c13e3064d3b93f419bb3adbae00ec6cacb05acc55bb7a9496bd4e344fcc2f1e1ab5af6271f54158b815fab21da5b1b9977c758fc52df7d8bb63d025899a4a2d088644cf5df4640b900f5dcdb2b424e6d6d3ffe90082c241d9b078a39f8a1952f6ac4c4dacacbc9972aaba06442fabf80dbbd1e047ec6e56de9fc7cfcd525a4670e3da3fb0f8ac29a4f6d4a55d6883e3add6523bf01d65565909968f2658f9d59f8285d1c83f6119e0ea6e0223375dfd6f0ad2911e3974e0e1927f6ddb5a96834e7fc6bccd1c3ee52e35bdd391a394273c85a670e9c3428f308f2f779e85e8fbde9fe5dee1d0d395b2dfb00c25dc3641b2f9a597a253aa0d009313efe97ce48b2a675f1be550d8a754605e29af7bd52a5f957bf54bdb4c2d56dda976f323b76bc4088768d5fbef74c72db0e62ed39a6ced4bd03e9457e3f5fec113009a70886b218e4547361b57d366eff39086f3f536eb4d514b12c76471d59b41a839c0beac2f7c13e36ac656f42a3c1428ba955bc5c1932942323d0e7eef0049580e70393db1b543ee7ab93f3223beb43a5ab2649928fd4afceb805020dec03f0471ed44e8479e4a5f1299b09aba28ff31850288a2cacd7d104c36b6af6cd370801eec28321529f3dac6b7304e3129e096c5ed00f83eae65e1d4e380418d0a3a4b87e74d5faca7208b795d36fe0262c0b500cf07b5f3a6694beb9aeee0b48a8e0a86bfef24dc67d2d5c7609b37ecf6c89f4ac34a7f77bdbd2edb0506235e66727de41073eca560d07c2b5f935e955a2a8e382df1ec9562c1e0f1a59e321ff35730e5920e866b6118e751afd2828f2d07784482177505e47f809589e7569dbdfa2bef350e71f757e48b26b0ee33e87bc29b7e0485056ea36149814f5f4b0ad287d1246aec89925953f48aecc1ef9cbc3394545610317473c1c70f7e274fa0730c39589334223d4224087acde2bd988aabe2f088de820caf7922600f19e9aa6a74368320be3a61075a282a3f9259a1cfd722d7248497c65ec4fd2aada5ff9494fe6c6784a0487611c707f0c216ee5aaa1fecd0d9712163b8d887b7e26bb87c3ac7c65dcdb8f962a71f2aedf7d4c4279530bfa94458d74eae40a693465cb630d631c6042e2d3f99e06983f35e01af603c3206290bb473277a744f26a925b1232724e4af713b3df10bc4744b27a662df5708e41ae4c8801b8361adb4b75c2e4b21a7a74f11fef3d5eb67df9e0292411819e15e7177b511923091a6392d709a8965c0551c9f493e6b128d7e2456d27901be592848be1d279833a8bc9706758921ee27899fae44ac1f89e103de7140a4d72db4333448c2463ab52e09584e8463f9b70dd1349dd7d128cb7e13a8e8d566a7804354a79c907621b4db77da32df49438f77eaf044e4609b6c7c441e87e6c4a68b5807e18f0d4c74bc49617ba7d85ce48f89272c60f784e4b2fa1ed4f3c430781bb741dfec84dbd7bef1ce8594e8baa737c3b151af326c19a2b55bfabb42d20e6a92bac1fc08f7af9194ea8fd356210336f57f041a57da27c21c1d041eac10c3bd2607c09af642bbbb27462898830c6cd9f6776d2718b64b37eaf4665ae544e8adf67d94239dc6b3599d3651fb68d220421498106c015c9028eca6292b8229d16a11e88e560ac72971ce4d036c7de8d8a2d7a2ab1cdef5c22d07815944734d0cc7aa9efd65f3b3d8d8edb9dd022bb8e8ce4a14873b59c9c4e57301dc6bf9dfba97a346b212b9241acd0d48300d31c1d42dc11498d6f7eaad7fad7a31fac3c7e6f0b5ea981362644163be5efdf5ca161e89953dbeb55f86159f52f7a63c81fc369d6c62c37d6573f12e2647a2d512115a2f49d8bddff9402b9d2d184f2bd692073fb54a58ae3db892995564c259f65cb9ecf7848d0903fdcac43fcb3f29b9f11144a5c4ff042d0fecd5e9b8bc937af223cc1f31dd6a76a26d7b99d40bf420a129ce79347266c3f9fca508315ab625acd824e691af790057755627088929299f5baaa517ef321d56dae9b750d8df94b5ebd0388def700a6625226be87d67e733aefe9c40749c476563745f8f85b89afa722bf724e791faa372f7019d77a5d9599cb0f1620f2d1b8fea0c4a43d68df31d1ff03ccdf9b7f20ba7a9bc63ed43484762d6b8c99daaf42eb071b85e3736029c0042abe1ad73ccb4f840e389260f688f9936821cb4f293aeb8f96d906e190a1c3e0ddc3828f4f0e2eaec1f48196af1d3caf057dd362c64306b1669115de00fbca10b98761d3000418bd9a0568ed596dc05dbe53ab2ccb618fd59aab11efefdfbc6f81efe13e3096c492711401378054a9b85cf05098daeb1359b73cb14457099bf28fbe6139f42b8c03c618a5a34ccd6f3a661f6e167fb41b3ae4fc2a807b14167fc2ddcc44b0b765bcd89c4abe9d1f9e24bfb70b6e4c27b44d98ee0ebc4c265c23d7179db6f4810829caf5b6c6a908c3690a64881dd96ebd8d85fb446c2f75b7a1f3f2caf3af4c1d667daa6b5cacb524e9ba1ce8628c8b4edd542af480f3e2578eca4fe4ccd043e6b9e17a3e2289bd62a60e9bde02a3df3ec4bfd60746452665b17a44cea120b460f3b499734a6844c57b958aa2d55aa5bb8d62211a434f4ec7fbc44c690cf5390d9897d0fa3c57ebe2ac05473f5a4477519fca25caafc6efbfe802e3e6de8ace29e623fb2b03a365b5b8723f47307dd40a7c589e669534d0a74a6e3fa9180d0f21dfe90bb309789c91ab98c567014682fc8ec2e857b9388654aa0479925948c1aaa8d506681bab494c82d7d6cadec35cb4e87da6da34c3214de4c3788d9eab63d695cb8aa262f62fdf3d09695d5ca0028e1bfba847f24f2d57b89e91585d46e714a0a37466da4cfe9d5f5d4e63bea1b6d9cd32a2833ae290420f94505e7f177c84a6ee408533863573f92da0a2b5333c3d9be291b0870fd886ce9ddabd5940e116da3491e4dc70ee161379abf35138d2eb18aee7791308d044c17434ce8a78e1bd4164e2fc395f6465d654f1367cf14c618c62d72ab09ad3026168b78a2756e19a00d82e1733e7c21c5a6ae41b914eceeb5cce071e8a044bb6da70b3325bb3cb4d17f2390b8a386cbd683fe4df38e002b110bd961e0cd0689d747af071da69dc56cb47590c68e1a5f925ecc4c3b48b0374d10280ed661eb3ebe7dbf3819c6d2cbd8294f26e8f1625e5bc58ea53f96a600ffbef670d43f261ac6a2a954fed258adbc3abfeb9d745e64676fbe7336f2b338172b5d10cd69ad636caad88e0a4e753eac2bd267db54e98015e17b8231869af04c90751b6c25eeb73bac5bf2487747f1253663038750f0d4a031dcc2c014d76f71e6b4a4f0b8790d4cd1c910e901c196d56f38fafb951a0460ea542d5a544c68c138e711efa0f0c4270985b8dee58e3c5c4cfce31b8f805cd0761e4f53fc8b54ce09d696f7f0f471059fd37b4e4fe9b0294769d8aa89d49b1ca642a89ddcc8bc38be8f8c44f41625f38b0fe54674fa9a3575daa5754c89336d5a51ee8710ea80e8df50893283abd2a99c9f3bb632a72cb2d33fde88cb6348cf20f2a396d3a8cb15a5fe1168e1997a7b8e91804a72e4f246bb253b605835ed38fdd201847e213ee4baca358fa5f613f35575ff89f00dea8478fa7a0369e42317c6cae3bf9b57bfc64d6c47b9ce628c14739d55b483cd9261d40a7635adbb6dcec18c93d58ce96e7af0736b353c5be6727ea0988ba505de2a34847a856fde136fe6074d9b1d31775f1191830ce51edb22a3d713fd295b194b13463293adca7a094ed1281f025aa6cf1986f281e142da95a504370c88720fbf886897bf9c0561e600180f747150d9c4aa71f8187bf36036e8ff57a24daca098ecd9bf12afd8d153d8f792a57137c020d453c127435c00a987403db88c88e0489bedfd7cedd5a04aa6510044062cdb4c39007106dd7890e7a46a66c7839c5675ed275b710a29b0b977aceb9ff9b85603fc9e9e2ff80a0be215dcdca90434475dc93ce4345985ed6e103a12e5a64fc3e4a476bb08c740ea547c26ca6ac64010f997ce765067c758fd60bd49735cbb03d56f868c21e8c72e0367ffa0195ad5a150237196da1574f5278a8abd0ba5dd6cdfae65bc85d171f712de97e82b5acb6ffc52a918fdbb5f0942f01e337811328a921a99fe8412da91cd41ebfcc641a7f657237e0c881c1dede950cc38eeb1bb047f96e9e4017c2f50be7b0bd44426eb3dc89581cac2d5592ad79ee9c85e89f89f55ab431e3901032705bd9c5b74cd77f18b5130381c84bddc420f4193df6166beaba2c52a62bb37e3c92979b3f4d78450227253e4fcc8cde7ef83a98aa81236269dd28bf164bac139a385c0a52d1341d873dc1e195c4902c30af58af0c210a0e1396b068f408cab4d319c4ed2328887524a27468505d7901441175bed562d6dc022bc7cf7ab92b32fba924a5ab304b4ff896f4e58841adc25074b300024f6837eafb4159ea68b2e4456e9c79c4513735a9c26b28e0f0bff85f013c2c30ef3473aa7a1cf3ebc74886ad6dcc9926e50e3df077f4f6b6bd9149b7bbbd2604344209c0ac6c63a9fd398e3e7d7244aab72ed3dc7ce7824791e023049a21019e52b63c0b11298c2d3d5ee6a5a5afee341eb746a3a26bc1e8650d30d1dfb5602e4194633fb271c74d479667043cc9488b10648287f30bbfc2e92b233b2a93f043034ab9a0b2373ab115905b31a72d6aad14916ebba401a097a8cc3434bf4fc92dcaa4803df9338469b610a30cada635b082e11afe8e7bd76c26b78c0ff961d6c340bfaa70b525af0402dfda3c2929510696f82b56c8abd86ca31969bdebb280fd0b5d638c711216330cb38e6d618ade01a3ea7f6f8d5467ae065df15d7b281180acc4c871739c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
