<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b2abfe6bc2d746f93e78208fd28cc5a96ea4db8d4aa8f56df56f3903ec97778e88175d6278dc8918eaeb7231a1875f6ecbd5365adbd6ee6f12e2683a6a74973242b3774bebb373c82a979d0d3532b411e3352362e5fb6b64e9d17252f22f797841c8182a8501fe64e1adbfefc9770dace3c4926f6fd295ad02aec75c3dc4bb24afe8da65189d08640ccacc9a0e85870069a888bfa713215cda0d6acef0286791296a27774c15d1ef40676db851f980e15a640b97eb354258d2c43d0723019024718b478689e793ea37608f2f6abc12e05d272c114a92019585eb76a785e79570454a54d11b885ef5df01087cca80156a0ab9455632cee508892809d132f44e5342f2a377532b3343ffdd1298d9de9d1c1f0fbcb657f0e93f35d7f13d560e17ed095a0d3e067c5e041853c023a94e7fd90dfc6685beb06ea7b59de9e291cc041c2d9a25fb5935336c9799e72240fd5efb7551191ffb52bfceb567882037113f1f8415e6eba29f9dcba3ddbb1ce22bc96e9da16b882ca7a9039d1a761b81451bca4af211975c32572dcd8655bd174b29e1b54745eaf4598edfc7d1673b819212f4f31cd95525d1272031b58679d582f3da5550f8dbb527c4770c5bf59cc90f88b06e7a444ba2a77a8e3404ffd1f9a89e9b8e9e27fb35e55a1133214938df661baa47a7b74a516c6df3b652d40e93da53f1cf11224395b995ca6381cc36852cb712990b09bc1b34116f43da8cb08adcd5988db966162c5d31236b0b9a3335f34cb7002805462a7664650df1d2bd84e7a34d4c81d8b61d01d64a01635391670957b0f0ca3e50db6b4dff4554f514e80504e93d4613630ac9d11bee50cd6ac2a32bf891a0b4afe5cb84edf0d43a5c6cf25ca300beae583dbca7990ce8a9beec363610b6bac3ab0caff6ba1ea67ec76ac36d08c6dd5f5a7c02e857442028a37f46b94a4822f6797fc7b983323f941cf50e8cd1498eac4e1e11d51c06fd74a7dae6c1105f36a3de52aa282297746db7400cdd40d391f382b501f8a8e8b5de66a305608e561e18c17b060578379c6e7d8496316e0d41c766f9064e4ea66609ada175e61aa146899fb9d49561e073bfa1269d0d0999f060cb509d32c3df7d48cad0edb7e5916e3eeeacc462599128eb3ccf7f606447dd121f3ec69034f6bfcb573645c8b6b964a9fd95faec4d7e8fdfb38be88b5942570ededea72113099dff4faee0fbeaedaa67b77cb266a58a276a76392db47d146f2161966cd75d8abe0cacbca57c8b2ed1cfbc09656d97e5794780929f774b07eb49f09ceaf5e1f79572415ce88cc49ca1de3e638acb32e6eb5da7f14e38fa045d034242b819dce24367484b4fc2e501e40ebcb3f77a92f0cfb15e04958ff51b8020786f6861e3be0894e1b24f3874f417b52535e7c73d7cf5de10f92ffc764104b9860c309a0b5e62ca5e87c663b9fcaeb852a7df9c01eb60a98c348c3dae2eaa0f4d0c90856c34de4794551af3c97cc0f8264388af633bc7bc2784c1ec8508e45ef4a88e987c6cbf411e9c4e5e16687f43083dcea019af59275870c1bcbdc0d465df2487c9d8d2883d8315815fb1ad0cee5a5a172318e4d4d9af27e7a7bd83cd5bccf13e41c91e5add1c3cd79692d74930cce1070a524acf3310008e164db1e4c75a60f9494103bc0e663f90a2987d2c09011a43a7a3adccb068edf42cd566e73a21d9f44f653bb638f5467e928fcc9a08642985805825d74725b15b0f818da1ecfbb900cbabdffd15898c00dec5bb5932bb49ab1397f9110aff8aacafe6751f8a68899839105d326a70d89d0b36a22596ad5c707598bcf84d4beb1cf393f84dd6fc50bce67e07f8480426cb119d82bdef3d7d96838cc2dfdbdfbb8d79c13a94fde70ce679e888e7724f9b0bf23cd480e8bd7984d1ea2d33a75875462bc301a1ef97011cb8dd4ea6f8e716716a21714d840e739cf89c86a73601d3e229f0b06af8db9a7eb4f9c717425ad722b240215cce4679744f08f392e74927bf353993842ffb6ba69587fe547c905d9e21bb94507093adfee68b4c158a81b319da210115dd7e0e75da3acbcdb8abc2f1f0249a708e489c763ea98658ed067ae5967d34a7190563177e8eca2562e36499426e3cc77a74dd0e6b1d9653307cb692e33d43d7c44685884c4953630183ddb0cf0434c9de8c2d08ba0e14474dc2d02462ab26c7f6025865e41d01ecad59ec09caa87aa79ee6df4c132d1246e37c927536f8af09d5eacf09801ac2c74564ff787b89f7bb0410b5c7abc33fab7fa43d3cc80ffb294b4b9c4ba23a2e7e275c0fe586c5456455db8cb0cb7c2e5b793a7b22953c1fdb32324a9c1a8b75ee0cf2397a198aa7367df5f59fa2fa44a7e3cc19d4a46adc68d74d95a60b0dd4724673c1aa728aa2aa466583c59668c9a18fa7fd8cb32c8117fd62307d44ff57cb46e262ce0fd6cf8e67929b71f4321249c2f9c9c80060c8f50c00402b026a0fa271f960c3a8194636acfcbdf8a18e7a05a204d9cf003d38888e12476d506cc672cd951702eae7c65ce46d3dd19b92c8771acfa374006e13ebe9c0e6043351802121e8f028e1baee04d3f3dcb3c1cd8fef126b3c719e9a50d5984293c6aeaca49e86f094413ab17ebf4672f88863162f49937ffb9a5bedb738b4e7ac230d585261cef6cd8659d7af5b8378c55e60ada1ea82352f0c778b89f88a44b20b9ccab25bc9b75462bc7906785c979f744a58584c267bf466767a65a9ade3a97fde9cea566a7dcebc3159ae217b8bbb88afd7d3d7d2badec51fe66c3fee5fdd83ae097ed5bfb23c726b9739308b580df5ac072b78d01db98025536532d8acd9fa7f322dfc2d630dd4caa10e29ab4b3430aa0814b5371a010a2680636f7198509e11c120494115441c2dc88c69173bccb1f36f65bcecfcf4901f1c7b8eae5f5234edf6638c840c4e052d9513f116ee1807f26e1609c727f71efeff2735fba0751bd1b6b2722d79c84cbe328aed9f9c79bf885af96f8e5ab44bedd1dd49b63a5ac30a00e150ea946864f47b279bfa6094ff7ad268caaccdf47943ddcbc5ccf19d3cf02395e1c72868ff969a244eb9044e99fa55e7dba9ef7e40fcdd3cc37c599fa30195320c502ca7203afb4ca9cb65359054a2505cc1ade2f37d186978d38b9c059d026ffc71721e1358b275ae3e85793a3ceea3a3835bef3ed4cf4cbeb3869b07487ae1f40b6a88d40c0f2a1d995307e454070ea799113a5ae2a3a6d371213d65b7715a4bc53bd1a02b27bc099d4fb46a64947734f346eaf1554a864441ae3647dbb964ac0b56795fe1e7c660fd85f72f5aa52780134b8898ec6e6d7dd8279b8ac8a7f94879beadb1b091a2b394db79e9bef56a95867fec1e02313dd1bfdff95f247a587da25e3930c775e0d4798f77bb89afd95b4bf3258ed229a10ded21dee73b04708abec14d3a3dda7595359fa26292ae2586fdd8736a2695b801a19043636affb1779175dab1a84280bf6801033275184250a62abc55436b46db917d7873942ff4f7b3b53b83fa78843d03c529ec009454819dc6ee55f99b37396bc72b2af6f7bad8fe2cd63bec3e15e02e5dfc9685d0d2bdcf8c34021924e8c471b6842e68f9f6ae1680504e687d4220b83776588423fb3a4599512d639779992456bc8adc108344cccb25b76dd9543860265e106d78fe20238d641ba416c7d63d8b2ac649db6ed366196b503209e725d1150eb415e54ec68ee7913dfa9dc690fd40fd06eb1c14704a7b37d16215b89e68c38dcb127abec07ffb9d6c2241d18a9249257bf19ca3771c289d1d44854c88f006e2c397015917d94e51518a7196c75403124eb4213cb5f6ac36dac045cc0721530658a6143490ca64190b5fae7401c90c93ab1df8ed45fe849dd0137ff726371c11ceea66ce3bd1614e0bf204a70f724780a4ae7c10b7453442bf82b829618d77b6d3be0a3df49dc611c245389ae19b66839866f94d436c1b393669e33f94e6ab26300b5fd6270a083611b195d36cf1d10375495f96708e044622caf24dabee087455c6c83a4f009c9ad8bbc48fc3a103865c0914871ccbdb4a11f9abe06a9afbe94f319fe55206cf11c80345f17e3a4a43318ea705591403a1f12111f85eadbb1e1794aca77e05286edd0478e5edba44e7ef3a72b43c748cd67a45ac0c9c1783dcf27c9c6d8c488819b1b9f071b2d425940d928771c5f293f14eed4199a6f9bee8183dd440fddeb02b3ea00f7f1f01df9c653b8ce50c6521729582f9bba7ba7d3da4d48b9813196a51714fdd04bddad84038428e4736fe0d2e800792eaa096f83db40845f6fd6ac762cbb23da68b98007214d3750dd5060a6bec54ae4d940f97707e243a04f46883ca1cf06501f2bb2071eff35fd8d2365c637d1bf4dc8eb7940cdfce4386fa52b0e18a2107b3c2f3075194ff07a10223ddbf9ff0e4b63d06a98869d8952a3281ae33815d9a4ec7fd911424fdc47c55375986361d68f564daca87ee9afa76beb418aab8c1e49600ea86d2e26d9282b1ca9a367b4de8f6ba4e714ecf63430cb76b57eb3758b39221f96adc3b0d21affd9012464bab408567abe84ec99a97212131da44319603478224776dff7f647543f353506bf4d4832c0187ff8587becfb54e843caf6007768933cb55212b1434a98349db42e04a55f61f7fce31d461bd96d8dc216a14ccf2a4f2dd100a6cbf5103aaf3f7e5a98f56a910ae43df936c33c4c78c312da6f592214c0f0acb066d9a500c0219305a49e481a5d3e58c8e8e8b2e5b1cd619adb48455209d436925cef6ce1546b0e8bcea300aa920a4ee2035ee189d99f34926956b5fbb3bd3410ab08fa399363686903ab4617f75bfdef681d0196f8a15d766b5826ab38b7b16c035acb5fb632b5953d3c16dd70c979123b329fa35b8c1628f0964ba397390b2fb1b1c38e3c844f5285dfb2bd917a94e26a91213ea02b18dea4ce632ad3f35c4193017b3b191e1eea2279aa9c9f12812da9ae3caa29fc4239c54ddc8d5bc15ce9baa8b80272e54a1796be9bee75c9dd639f0d19c0c5dd62f90e708cea66f8b68ffc8425f7a16ea0033aacc35f17bd2a7ca4cfc998369708a9aeb0bec38d43e2a55fc221a5930a348ba4b00cb935880ba6475aee000f18fa71d4c6d4c26b2667226438b9f284700c558608c276951a0e630650559721bd5250cac3973bcccd17271f5039a49c7993559944e48b63a8275364c135037057a0c3ece2109b3560b07ea8936c59f9dfbbb5fbd620eed1bb9d35d1e1327a6f215df4f40d1df0029c378a564c1e78686e78a46b696c6a46a534d6ace105217996f4567a67fa1a6e45c463b38679fb6595fbd5bf46b474e57fa6dff25fe8fc73a89b771efb3d0805e9fdfe31c0f4d0d87b374a68ba3724b733cf9211a2302cd287bcaee2f50095b9ef9579adb0d12a571f3426c2824a69d03c1e52d52495aed1a1506ed28e005ff6684cf5bb2c65856ece71de60de7892c0623afd9a9944433b1bf3370cfacf03f0bfc8648a5e48942f99ef62141cca44689e49a46b13b33ffe43aa30c46ea29b127e1b2e62be78c6abab06b656dc0fb8253245989565bfe00bfed931fda954e342fc11ba52ae404036e7fa768894c27738fc6d2b7e052b867f0a1e132a8daa693b059574de0911051592a0a3b39007a9c0bf14a2f144c4008f434f9e60d34d9e675263cdc493988a6244b50444af45f7258d89e84d9c90f42c790e3f988835b6d9bdd7618cc9679b4a29f2b559fc61fa48ce0f8a5fb20c037bf6a9b414f717b15f2f06012ac494762f2faa6ea57fb521034fb1ec18ed65fc0f266b7cd5b0972d8c84c6a7745c5f468ca2a9295946516816500a5b7fecbbf1adb678ac5d5e7aa955a6c0be5adc68de8ae67d953559db7e1b9e2882b976513e41cbab4af12e52965da56be1d58499f198bc302bf4f17ca6c7940a138f682d8335f3d0dfbf8cf3f31fe73a59ce06f7453e9d55b7f9ec94a833ff9a1f2d8c7a7fa6997846866f27aa2e9f1bef334cc51f8862743cfcf43afe3066466bd3844f90584180b02aaa5b46525964f0241c81f29ac85ba11dd346fc0f85325c22aa26d4c74b92a812a0a0476e531e652122aaa55fbd3a6b7ed072a2154d59375d654d05b8364d9f2159fcbd241d035a49429be65d4deab0e44bf42875e71241c4c263aadb565b90cdd0ed1e29371c7306f602e961f0177619a2af2cc9af4a591fb35345f57da7918a42ce6419977bf1b4360935d799aa8bac41553d4ab69ed59b288a717a2dd0f972c1f9318b755f5f77ae2ec91b7d33e7f18ac097355d7903fcf86fd4d48c54c77dba6ab07e5513b87a8b7d81eaeb3d7dab6f629a34ff4c0a4b3576f9bb03adc7be62a852762dac2c7e202c71d8664968d6039bec2d08215c87cfe269fda30e6f6a09262c0ea60162adf50d2f712748bb9652dacd36c27c053b0c80eb4aba5d395dbd4d77b579f13b24fc18e72bceafa9be2ea2f997837f477bbc0450f9fd34aa78271ecf7687f7cf2c20d65c2c99df2e674d16046da818469165f5c8f8c8be7e6ccb0990fac50c05f0960726768f361f622d274caa36a8068f44568038c0b39a7f44dc574ea912e84c0f4d184cffe641918d81e86623d8465ac945be745f5fb4f50fc1b5a62025b001037ed40d327c9a0dc020462fb96e26629e3e44e71ac17315544be2c9a2144237bc6da7e6ee86f7654b48287e2b5eaed2f838144f114a3fcef54088c1fd966b6a01a6057ec03230e1b3ccf003a2ae129480067cc4514234d0f9b53288a918cecd0fb39bac700da818dece9f745e1f575b4c253b0d85f96788fe35e8481c632dd9a184ffdba157e0e4d03eb864065e15e4d4d7292e7904de8931d95cc6062351835efaaf81ca85a51e129f2ecadd0b704836b3ff88f45af55916ee540f7f9f28851499b1d6511c18ab674901c8156b3225d6d83b1be4c0321fb659275496d788969c6ee9f086fc9e2aa9a027d452b1890854ced62f97c5e72f82b67940b4b83d730cc6214a618dc7f9e93237e63210ba9ec78cf5ac22f7c0f4de4b0b68abb84a5455be1c836bd60d4c9a98b160181031102505b960751d01c9b2873d9aca3d6155a6e22cdd98afc2026e81cb98e5da7389ae153b2f34819429c787543cbcc81321efa82a38f326fc09dad52d55421c675a78612231e4149eed8a6e5329f8654267776756a94d5b2e27a3cfa782ccb0db32cde855aac595abe9be5386cfc48c2e40f78a08d0e8998a28839bfbe066cb39ef9387820342ad0323bbf0636741e6cf29617483df7fc8735d70d41edd261dccba7973fbe870b9dd8e3b86f75792c2c1208e7bccc38e29e1b02e6dfb4591aa8931889ce03be240d90e1a931079b3a8181f3edacbf7d22b06f9b52374876c2edce3e4508b2bfa5b4138828b54bbc68cf3b07ddb2498d778426212f6880e1444904815fcd4050e109a93b43656d2ce4054159525f73840fd8e30f5a119edb851fd4d54b548069f35ae86e8151fb61d9b7d3f49cffb3ba5fb34daccd67e9424d302bd5c639f2e012b44c11272ee44b5b3a19bc34b19300ed7ac74c5df4905fee770693906b265be3120e4816f8370eb8ce129511af6bece4a7931d782d8c732817917a53d1d1ecc70e7d018634dd06d9ca162ee043a746524faa6b59324a9a95ca4b0c33d8c4e146d23a332ac5682938313a9ac28fd6e500511a3c34a981998d70bdcaa38b1bdc840d26cdd87626330cc64ce2cb798848aea88974d2381bee9546ffec22e95f2a4b8dd6999fdc4c997f0127fc40b0ae56c171cce148671b6b6cb73710cf77974eb1e663903a86b67b7a930cde701096a1c65b87dfeaf95ae711dd02b2177142c0624556b9b3118f3adc895073c4caefa523a5c17417159e91a84308224480f2393c84cfd792421480f9b4fd3ee8d8ad8018e62ac7bd24ff544d274684de0b51191a2ecea66165270b30804a7b57841abfa3cc94e442357996acb53c6b9c68d29663bfffc3b2e27dbdf7661b1f9d6e080b2ac634011486171f0e650f63f16e5c268f76b6007d03149345f758f6a926dfce5464dc9ccd803c94d6156353cd3b6ffdfc1e6256582dcec847c12bbc60df75363836dbb28e963117314c329de7d28001e87d737294130c6492903f795438e972f8c89d9fa29e51c5d72b8b5a9d5724b8bd9af22c88170f7a70c5e28203098f57116f8261ab97e2d3c32a8b51b5c4330631d2325dc55bf78acfe3d03e4e062b5c65f9832c1aa56f56451b709c6a3aa13b8faefdc44d8626e583293c71dbe974954f56e4bec1be8fd7a453c6ea2b3b2ee38a1656e4001193d22bfb0949711c30196a6d77c46c54f5d3eb93f045f6c988f074a4485ed51109082173cc28777d588498940215a16d6dada64c246113f83ddca5bcc779b82f68281fd2860329fbd6121beb53b09892ee08590e44eb2f85fa2c88799bb802fc2dbcdf45f12ad1ea07385bcba1ffe2479cfb3f993169421046b9a18fc949bf1e8637b854cc9bacb9bd5d18925ef186e866f6dbdc13e22924047d3939f87c72071aa12f22cf25d63a39b92978976c2b16ad1c59bb4e8808b67afda5aba56d9afa3d72f0948c39fc75e0585b564117cec690cf5eaf58903db5869fba7e259308ef5b740f255c388df08193794049979aaa37c89cf65fa1f8ef1fbd6c5267c0b8b35a2dbb0b09d1a3fd8703ea9b0c39611167e01be827052d7016b0cbb711efe4db308750ddc1bf21ed77a50de94c69d3c8432e61939c4557d42eeeb3e24078d4418bfb2615464f4f7591231693def76ec8ef88ecf47e1df74510f75aa5061fac320b736ea35f1b69a26d73e0e3a35d740f87e72dc3ba0f21281484effee76f668e9046a6da6eb5fda603c5327b9361e2361429b2094835dbfd91cd2142f5d3d2342a6dc93f9eb21d10865d0b713c1bb3a4181ee51548aee9ccb921b4dc48154e6ef623290aa735a7a2faf943f82c740981071a553e815ff5499f49e356146ef3b760b049b2c22cdf9b3078bc4967c4e5cc8b90cdcbad5a2ea762984d0f7235d7738d85f83b976e6993a1c780aa8922dffeff0f66b824e4368b6aae651cb33156af344edf19ae88429c7e959975253285e042f405763c83116ee8e6d12660a5a54281aafebce8eb4d055c84fd1981733d0d2561d244bbfbde9264ef3c9a8323412f90a49fc2337938a06a02786a125363018d5eeecacff2cdc134704e1d79035ddf3e1b1ebe71b855c1dcf10580e265050804e78435a803666f6202c75b150f15e6997b6187ae54d2bbbdc60ba2065bf8df799f6ea11839bd0244f8d27d0f7772339ddafb8174aabd937cb17f619618a393779755884ead666d69ea33086d324fd39eedbd2ce42c8443f2511dfdc5075ed96534cc3dcf6134fce192547b866bb3c8e201b85b3a7f258114fac931f7be5a038fb3e10b2cc531ddc5af53416072b9355970837d73f4ac3c5f9b419f8068acc41ba102f1b8931eb39722e4c1270d4232ae15fa4a6ffe0021050062ab7c9201bdcc00c3f79ff523406b41c7b0c655de01278cdf058f479e777308184039cf80fbe8b9311549411d047290204dd4cbb7cd2ba9e4c919bdc0f07e5958b5eb9f02ea214dd66bffe1ab76b6b57b48d4af4318e8364227ebd5108fb6eb29d2483ba52eb98285085159bf11226778fcb05332d5a68bf3fac7bcce4a870760415737508f34a48977593a409e6343212ca70d2740d405a75e9ddb8dbe5ca0d40347d8fbdd8e5d46316bc9c400a89cac1c6fe6a6e3186b0a3f2b09f97b42283322538125ca0e761557a1cf7275491ceda8370f3bd09f6ea0135635f860ed94e602bb172472a674021fb093dc49a4cd49af13b40465e57761f7e7a9c212b2e5657f0ba635a34fd50ef7a1552c2c38e010c227a1ab2696dfde64163a155583143cc602ce2f0ce2336f1860db4a3443734dd3f276ecf73df233cf4ee1b0f865295ebb5c59de752860b5d50ce42a729031469de7402b27c95eea5e35ad04691053067cad49bfc3f0d4abda543dc177c94ff1ed7bd036671d8cbe83852fb0728e67e3781c3b894039b9dbeda427721280b31a29636c48bef09395a128429594bbfe5426ce5bba9412039ba7bab29d4be495b77b74a8076235383859e5653110866badcdba24a1a80250d4a9305cd7091a3bfa71760d4f9d62bb56b6286e4deb3878aedb5405b897c01c9e2eeabc1c244194d9892b453831c5a71b76625d1e65444e2eefcea20bea4623bfd55394ef5f9a3e84500f22179c479679be56758479eb66357a29746a25fb3ff86b8207890a5a93fca46f4f419d595413dd74ad7b7f98911e58236d064e7e26afa90dca7c901f8f653d2831ef24f093e1bd037a31c8d4913350804ad129324c92ae0eef83f7628967afc4b263a1a6b275117b9673714c1a58c2199a2c41f1a253d906ee77974fde3e660975fb3602879d333645bd16951af00513ec82b77e35c4c750040d1a8b6dccea162a0b6b3d6fa95d9369c16ce92d65328b67b7bb90b3dd7a9d1af001bc55dcf78b93849e3d5e09dfc4925f89449ed1e7991946e9122f3b784732121e571dce11f2304993d3e25bf0fd7e3e98f88f8eb599edab8d17b0b738faffac7ab6bce884f4813990869c85cac32535d6808d0c1d6ae5a9a99fda39b67dcb624c4249ae9c4b1e1a6b0cd6a514cc88dc8d87d5ac83a122b49deb88056357fa71c2e6ad042e3a4fd2531b2d8369c8b3715e9388c74924239e22b57d86036d7908133933578b15c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
