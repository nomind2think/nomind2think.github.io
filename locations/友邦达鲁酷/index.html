<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"373e2942b9d8a00c0e143f89c86d90ebd4f14e7c82c47b32f43f310be60e59fe505c3641b66677d63f86a06c4c2ad983519cb002c5ab4a8cc290b61787b91d8f8b3d5fce3ea730503c2c236bdbc1c74e21ca0474959cef9b6578375a55f53db828f44cfc26f1e93f69beb2b5aa3d368e1cc1a6c132ad50643a407cae4f22721fabb6b368b72e6b882b07f1208af1f64350dddd65772e78931d2c2b2a5102f58bf281c8fce981bc0fdbecf83ea4e347799289e1c8a3be11d17f2622b5c83da711df7b9bf5983149bbd42fcab235283cbf0fefd21d471ee2c3ba7ec45626f39a1a6e80cabbd9492b0dc916bf26bda03746d78c757d981e26b792f7f5f9df25f29a35535c334357c83c98bad7b1d63f810e35931806636bf307f7de6af5200127312fb54c3c50ef1f355b85e4118f09f893572c2cf8b1d5993bd88379cd8c4161cfb68034021f000237872fea406357bf12dda3e46523a8a564649218f1bedbb96a7d10d0ecad797f3e83e8df622d9da85546bfb7e88e4babb5ad801ba5e10a05ff363d55ed56cb5ffb7f4599928ba8302873cb01263173c8e76f21aac837f64f08b04df25faafaa8de99e4391876d26a9108eeb064acd0f4d62d043c218e72e94f582e16e501c0a9b6037ae30494c70a0684777f272aa1c469dc9d1b96c0ee3a5adeaa65add1f88ce4e6c33e8fbfe5f1806ae771a620ebf776297c14a1a85a2b6c499b9d97c2633f3dbd495da48e575117b3bd206d69c7991ca994ba0624e5161b1a5f87ed762746e67ff74193c771fd64621bc16ae1ebc8b57dd9f0fb07f164aacac89c947e7bd2645a4bc9f69522fe91035bbc2c8a2bcf08aa6d1ce64485bfac0244178d073ac4b87c25d95813e04ada8cf7911ab3adc7f4dedf6fe5fa0f9ff7e9bf2cca04c11ffdc73b940b4327dad56594fe61b6af4bf91a1b05e2180f7ec42bcdfcdb8d2f02884e39573dcb23e21bcd7feab011f66ff875e931d2b49bfe78773c480369585b4ccfaf34d5cb9253a528a7e6fdef30e6c406bf5feafdc758d22ce1064c83e4da629880cef7c54c1f9b8967f870c6c5c8e1861face4c5356d1be8095d25605f91a5e1490cbc3490a3dd76cc3b5e87794e24d1217c1ace173d0179ad7edc53ec85a11ca8e7a30afe6ca8970be563a684734f2df192cc3572bb96e991e8fb9eaa2a463930ea80bf675f7b8893e0684ed93c69a5f35ed3af56a08d8ae6c1afc466c00fe92b25dd3d99ca0ae4283b87486766f12a3b9963c1663b00a1fa909047a4febd60b5a9d83152b670982a84b7e8f297147cf3d44e989e012de0cd38c5bfc015038c94730dac04a60aa3d8cdf944b935716e3b59eae24a88f151d33e6106c72fc647c43f757d46b8faf3ce141a64e9e3ab9618cca313576154430072aa21b776ce1517eb80f1e0729b23e72a22b358072f9691a8c21c36d63dcf2c029e7ade57f2bf29f3f4992c8e31f8db852672da2e3d51b69c277d6fc90c1e0188e7c094908e97ddc7a4194912cf7743d75f0548cb191330a3a85f30a1676db7e93434110fe16d62662437a885798ac3a1a7cca308436d60443c5a2b28fa2958217512e3f3d62df625c2272aa862824ed3c83e9b5c1fc370a95df5335f80d16ca8e6bb1caa2adaefaa973b0f0c79d90c76df35349cbea55371eda7b6dedfe22a1e5198e479e0db6d7b7b85b52cdba742f7c6d5c42d60aa0dbb384fb10c3fab383e7bad69f763b2c2533dabee98cc4b0f56e28380ada7080fd2a89eff35e1b9d7e6ac3f81575301ebaccde721cf6572cd49c6389e31cabd6831ec0f32c55f632b6eb04537437a1165853ab3ad1340500493859c80b310475ba9ec5f00d12d865c2f03c7dea20bf92e062f37825c8963713a3abf7a1f8c5234f388dfd54b9264b4792e35bfac05248b686925404aa0ca94c7f0dc9c15346577517563d3274fd159689f7c914034e26c2e3f9ccb29c9d1c0ce4c3ccccf553c29faf2ce1e550614ce66efa0f9aa653edaa3fafb87b4e0dda6d166496e450fb56dc013c9f10b653d77d2939939e17d8bc01794a95188e52c81a072f63f3d95605f02c6818abcdecd2bc5c3e571fd72147eca627cdb56c1434c8a16d1c9ba149fe8e24f0c8da29591ab162439ea2e807078095bf6dd50d6087c49af73e2fe26c354dccb9f4cafc33d6f772f650430859f73ca0f1727c4949ec88f774f2ad0ec9a3629786b375ad88cfd595388cc68713ac46ab046758eefe1d78f67ec5cea0ae19491b6bf8eac31ec80df25ef3497e908d25ac99bfd86071673df4c2c0383fede19dfdf23b5a2ce074ba3c7fc282d3d4539460e1debc71405b5ea4dcaf75abc1cd9b2b96fc0e42e8b5f8f054c0f5a733600c8c3fe8b5991cd5a7f25990d6419abd8ccc9345dff31a5961a400e4a395c363cc0171dae9c469f287a496a35c5ae2db238ad51f40e71f9bfabb239ce6471e173017fd72c1b3485d7923596b879c8db02af6f62ce6b8030bec7094af3690916af57d1df5dce0b4c8c3ba5bb8a58d3153c285bcffe493558bf2c7aa20bd3121ec601ec87f19f2aa9ee4033b6e46a304c92b1bb4bd58b41c6f0c39b9db4df21290e818f7deda30e412ed0969769c8079780245f86e87aeffc967ed967ee7e5694f3a3ef05433c1d90b53b1f2d8b781c6ea410851a8f71ac08ad8786c0733f294ab4dfcd99f58114685376fa4878efff47256cbfdb88e6b19afd9a9313e56db1dace9b390cb11cce1a20a5a5fb0ae2eef09b597a7e87e7ace37a1d158b90619b8a49ede6e7d7b3d5dc482e3cd913066e1c5731058dd071a306221ab05903dd895566baca4925a77d194d0bc235ec43b64767971f65a320498a711beb6c477764946b7cf7a8ecc78dbfe6d9ecd8fdc03f36c3e1a8bc1a9109133cc0f22182abbcc32c9eee7b8c93016dd44aee49690b4bcbb0d068ccaa4a00e3d2aeb2f129d5363eebdf01ffa08ed1513b5d7562f69bd9ee2d18a86f4592bc4746307894ef80b378cbed324ca4dd78600453a5058b55abaf51536f2b2ca9ce046d5c855d345868dff10af2badedbd21c1cbedc423e86604d40cd9d0324c2f22691c6182ddf890e1476f6995b9372ddc68c21f48180cf42a560b274a2898818801301db56e40cde730c8f001e7b4d95984b536d5cea051f82c715299a327dc8f51cb50dd72abdcd4940d5ec53e666f9208bf6bdd1a5353eeb35e99df18b4f628597b4cc701c62f41509e6b4ae4e525566663079b8631a303b04b1ebc57790e0efbc81e6890b03e09fa2a9dfa177186f20a15c2d9258fcb764339f4058f5b574e8f33fc1cd0d7075faaf8e27fa73bbd13790076391b64d02b198c797a7ed5086a6b3a1839d39815f30bd94e639c02e127532cb13f26a9343b008afc5e648dded652c2fd680a1f7ff9097750cc55de7c5924a15a228e7a04b35b8bb2dce8937c618491ef1c6f3b50c1cb7fe45bcf17e7b27839e234f88360837a84a38d6f6906e396e14460c8de4247a74ef0e22c7add99073dcea9bdeaade82268d871fe0b970bbd0b97689077ce61f5a333a1f6be139c7b322525d4d9ee4d2cb428fb27f941788ef537d5e3e0f18656b5abaa998cfeaea9a46308c1966b378d1527e27ac06dc4df6f6f85939affa029a7a0d93314b10ccbba2629967fdec70a4d7e6f6e50f9f93ba329fa94084de481a7fa6b5261ce0f112ec6abfae0320ff456c1cf31420d19f8ad3412edb9c2a3c9bc7f2a73b135e6f168f2a4366d6a4823272d70cf3b7ccee35af4a81cbefdd538f5dad97147ef38277e6fca85de97927db9737aea3b368f9de44d427bf6a68655467ae0fbab10b82f30ef8d83106bafb89a8f97ec5a72f69285ecb960ed78a25da34d0f3c672e6268988269ac111e688786e152220e0726a9fc76d9c1a8a98e34eb8249e3fe7a1b1cdb2a03edfd519b4bf2d14f11299e12f81233c9aef2198dda3a75a704063e2fdfd7dc77e942238e51e0130c69fa941bc9930a9794e4ed4cee0c09690448856a6e7d051780c0929d86eac35b01eecf9dd847337fd2da9f2d178bd3b9c00b7e815a0bf1ea9b789b2dd609758483c0cd036d3cc0523950bfc249ca39b4e395afc4b38ee8fa3fdc8917d3f8dad43e51ea96b5ad9a4fdf38109d703da78983e16a3a70c782d8c895973c282d7371cea5f919568b34081066df27cb567bf00943bda8a7739016632d7c8da0ed84085febbadf8aae5e87435165a99d9e9f4222b0b67300a317d6183c934c5c8e547759fd44b7a598a2568519db7a49e54b84b965e340597a60a5ffc063dbaf0b0d19877e26f084939863ced514a1b7aee496b4c8bfd4eba39cd0c31abdbab79b65317af4b3772634d023ac2bad4cb168c391649758d953c01d86cabc43b89ef35780495080e8ee3c24adbd519695ac9b5d537d316d463f78ae13db2fe59367f5cf67c53a8fd037c05a303f2dd744f3b1e056835b846a2a94dfbb008784cf3f787c59c146cf2da3d0725afb6dac062ba98c892fc07d343103893ab48a08c3596da6e3635e209f0c79d4608764c5c7efe6396bc304e002f566bb6dcad8c110fcdf5da64c95681eeb6ad3082e0ea4b26a5386fd12842c76b8d6dee5c7b3546a1347c6653699e290b6a3283164c5655af3c137a58c8689f22ff028c1d618cd5229d3cd3eacf8a0179c5d905ec4f511c928515bb49a87c00ab4cd930e05491e6be735b99dc9c6c48e0d64c1c4c7a28fa3cfaefad93f31a2d5dbc4f5c2c9bf9479e53cdbc4ad32125912349f258d1900e4f2d995fbc788a796b41a1245414bfb2a257ae86e5c7855a91fb7744ded2a3ff9ff029048651d942758178c71a60bf42d2755b5fb24db3d6cbcfa36e1b20299ac50f168f95b606aab393e9ad77e6991d5bebacf6597b1cedebba16ca62d5ea81346636c06ae3cce003027bce6951cc5bdffae7d9206276529cc3aa3bb767d24f3a9ce762d1efba333a1d3e53d619e853a7eb9548cb3053919152fb87b8743b0b1000e8dedd45391c9b59565813b05980ca14cdc4e31f6888627ad1957c83ef81cefc35242fb7d0129f4a772fb1103a794b2c15a41de06ebd4f69c3c1e33bc51e0c66a9f15f38d37f73dc6ecf04c2f76b70d254e492a6bc0f8f8b4f4151715098bffe9385f8ac15694fa62f55e9fbdb06fb8faac269a2238f4eec18f99a0d720da8fd9b2a59744cad208efd22c1bb8d9cc69b886e30814ed7908ce68338c8343c1c9d7aa92a324a64b0e17438d966a507d1ee063e47a0ae8ab2d4e7ce25d429148af0c80734c9f5384c7de9215e720bbe03608c33dc51770f6c2290482983e1dccfbfba0fc57028d8f35d887b572b8ecdc01d2a136c69fde4bb23ed406fe6aaa751bf5fe896c0cd8afc11d341a8ed97f4c49cb685b7f953bdf337958348edfd4ff3e4d530884474037e314317972df7e098d3d5805835f2f3533a1100e2e127bde4bc835ecfdbbb750f5074b6fd3613b3dd18588b11fa8d219dc19ba9cd73ad02e422faa0ae17a8f5afeecf232296bda75af2bf71519705cd3266323e3b008eec193538ccf411d1412523dea4022a36db04d0f754db8809e79f5bcb6a6e267c7882a115f6a55a4bbfc356fbe39dad74afa8d0cbff90829821cea97ca00b89ea9ead12f4d08fecac80bcaa61ee953447a1898f2ade0ce3b40c15f1c20c3446ba61ce090d4045a6cb7fa4665f417ed76119ab6ff1d59c0afcbf9782b2f0eb6918096a1fccf5a0c280dbc9bd635163db5948a1a976a05cbbe12cf3cb1e522b52463144a833b36c185cc00d976342c1ea7192b372776792d64500ad0fb363f023c1a4dd5332e9b01166049150af2b8fc992cd9772f092c3f819fcfc52aa39264591afc7e8b6befb69dddaa40c6075f413537b1682a5feaae0fae96529465f0ee6e37d1f935e2845952400cbe605df96008011a3890bc06c49ae96dd1f7c40adb99a32804af7a2e6e20da720bf5490209247f1c459e074e84d676872f3248e65a2aaacaac405b092e43012a33b97e219fe258cfd2ac7766255c441149ebc623a5e4ac245139902c8b41b1ef43be35b669fb5027baea294789141c73bb1934b70a4f418aa30f5b0cc6ede0bd2e90edd1a66973e30c15d1a816ed8ecc5f023d6c6781cfd5ba6a1ea896b854421fa024c68d201d5f520da6c0ee167809ac11787c8c1232e0a8ec0c03ff36281600e5a09a78eeca4c6e67c6aa62be6367f62d8e259e132e4e10e12108ef1a7c9a5c661efb97eac2447ce4ce423b58d77c640222b6300724255aea05d6e36e1ece8d5aab638d1a02f1cfdd19fa0d87c67f20bbe0b017c72058a7e532fa26bede10390740d8f240d8f6a0d3775676d19d58e15a023a8f9b642705fd0026a7e1f4bb9bc9f244c89ec4475d3f5dd07dbb8df07887a6ed5e708b9bb3daf6d098fbd98492b20ce6fbe18a1748a2934d2f451cae0852c2b366b93c637fc225d1bf540ebae575f3f5ba90b95dd79107bf1df49e75aa37e5ac39408a8791acc31339d094872a23ebc5ecc77e5706f016256a26473d907a003a30d66d3133f9a3f8e7f9c3ee15ff9a442af755a373bde23d08738c350e3cc67f571d69ab71995b9c7fc7c7571f3414ed93de3a6e3da676181b7bfb4d253d7ed1db75cec2d4a38da03dad5582ab5e5f71ede0ec3449e6efaca8a410b979918f62ee1c5ebe417fc993cbc350e56c322bfafd82d37b7d533980c81df49c4b2099b940af9853ed436d9bbf1a97d3a18a778f7679b461ff6685d91cf455cdb20592a44677c4e080f409ce03e667ed75440ccb026aa3db8e4a122ccc4cfd31ebeefbddbb2e4ded27cdb48bf9f409c4df1d9a68a8dce482ee7176e39d3cd4042f0784355e129294b16566827b348fc6e2cb4a7226fca2ec8a0ee77803ce6748152acd6787667d03151f620f02ccc7cf668bd06b4f4f8d1b18f25fbf79bff7b5e74afdb6a53f8b2d190232f9164d8b5aabd132d8a385920ab7a511138fd61e22f2a42f484c767fa61e2e87670517f567243c41b9703bfa8ada7a57f2dbcc779f6f510b0fbbb1ea6794612ccd7e7a6c8feafb60042ed5fdd261f47fdcd60a9c895f99f7efaae7eec820437afeb3d50f5d010cde1ced99166ad09f356dff6831adb7065e4f0ec8c0caf3d69e96bc0ed2cae2e95fa651517bd47f5f45e02f87f9f506215251985ea601bf31400db4ff3e88444984b814a7e9d4221c5a7777f0ff928bbd8ca282a2514bb0cca83e1b0504471fe4caadf8246dbccbbe1cb8db1ae5d93c6e89f497f5959d00c0d1c3f0c34dd7e534226b1d120101ba9ebbdfcbfd9564fe72e2d3f05f81fc909d167b60c73a9a3f2711094dc993518bde48f5088be070543753baf642181b3e6b6246c7859ebfa0a150ab85d2f822edb14665751624aa639a68d30a78be18a7db753e6cb3470147ee728ba489a9e31b48e9b17829983f715dc6847f5ebfd0417ab06cb6b4470810224db8492771a15dc712ce322b44a6d4b6ab7f96636f43b0ff34e7f84f37023a3a917a83498a825ca464c73ea52c7a8b4300cefd42b1dbadb47e2a1c1107aaf21e0440cd4180531036e7045efd4b62b653f6a00cf2d1a459a9f10bb97f0ef7eaa5be48e27dcaec2a4b6fefcc6a96a3809fb5ec2497a6d9571ab520a720ca39a0d7b98dd3a76a43f4a5ecf362d0773bd282991e8890a0e1f42c84dee804c6e3199d9033e2a0bb35a3a7b094ab767aaeeee78ed1a2044a15166e46ed19211611ab8184d81e120f809c20db2affccbef3998f061db6248e06c0dfaa35a34dbfc42749bd6d7427c56c859036c5c5057b1cacbce15e67282a4de6789e1b7be3d3225a993947cc2450018aa1476f025a0e45d4446362044daf16115d5d75cf29e88200b1c57fae98a72d330435ae295084ae5def9aaa6ad690d7484d91daab686cfc31efc7c8d386b2fc089802b23c54e610b73446f7b8070ef9f6a08637994365037aeef4e27478ba02eaa7d48f5ff58537c8192a9d3dce703db80458b84de07dca1341bd2cb40b7214fde5b056c0113c552820a1dfbd1cdfa0ec1925d9d543417f41162bdc6b2f97cb119bfacff4397d6659f367e49ec7a79e473d1dd270803a547e317661a84d2f2f7c95b447ddc59e737c69555134420b89f7fe8b632d16d19e4e81da08513d9ae50606ae1d332039700ab20f4deb09fe640270f352582dca51548036ed3c0e341f29381552f3475e78f5efa0c48c46208eb16a068a5ff3cedf351c08ac549120e99c435c48f138e91195a2468233cc3b9a8a61337ccd83b7ec6fbe8cadc7134db3cce01dceafc655594881f89d18759dec9f04d1933b3eb4b94be32018711f20d7834346b4114fbb8ff3e924ad7136a667689e69a65912326e947fdecc89f88f9cbe3dc0720649cf47fa63e115f3bee8cbbf680260413004d51aaf13b12d22f3a7a09b5589d7350e517265561d0a3ab7198342b128494af94b4ed4eec81c656a9b557eaaa937360dae8d6fd4d2778370ad1b7e819146e959d6ed70f94a75e4d3593bd4bcf28b2ecf0db5d2b8080217005d5f0cbdd9756d4fc67833185c05d254499727ef9a5b027908d5c59aac9ef0f85a87442cf0380a6787bc17e269b4db36ac9c710dd4389eceacf7f894dbb87375cd9031de681a268e3918ae4394f8ea8ada5b5650d0741c44c9bb8e44f550138e7b455f62b88352ff5142da7214bf8e6cd00eee1d1463c9916b502bbd2229aa5176a9390b986b9d5425776b93b102ce056598b2ea09b5e019de2d462f98c258e9dcc53b96f797ab2f7ec8991bc5fbf0eb9bad83ee4f37e6290d6b5a3013f25c0aa2864b2b6ef5fcc127ec610f83359e66e2063e5c535264d77a2f28095da1b4b8a8c9aeaaeda9ee48426a2fd0b8edf9588ebb568f4771317c44afffabb072b7f1b278b7e7ba7fa5ce5dcb929f467963c7f14a5479576bdc752ac0dfcdd6562026d38ace38960a600b4d98553db8b7ef1beccc2d58082a0b1bbff18afe4305295bbe793efa8537f71541a9d3d00f225da4dd1e79a771bb4538b488b10ec30b103783022cb7aab3014a0432953952c4f60a450f0f6e4524630c939870de1ec95afdce5ae9c958a72f1cbf920b4b4d26b7a1c5b7402df7c06d7c3ff86a3461e237bf9831bb5bdb0946175d08d9e7036f78df994f900b57b71c04f87725e385280eda3f205295c0574a82bd1e036519dcd978d61d85d5bdc2404c632b2c10d0ec0503d26783996ca5cfa70d6c85ecc175bd8d1e1767bf2e6dc5eea25ca56a8e0e5ce202cbebc1c0995964c3f6ea88b6f838f154a3b41dcd146516173d2b08336b1f36edc4a8e63d0d96c01cd387e922c17774360037b18450041f7c59ed90f40ced29b465db6cb9779085929203db19d12d6209e96c999d86ed2db5f46302f0be4b676f3591f50f92447c2648750a3d2d73c9485f62876746d4047946710b4f8f1954bcbfa6f2db1457b4eef5443eb6a8aa0ac16a35296a392d3ba8aaab8f4e176671366c3f080fb20941c1c25e1aac08b5e0684f0581d191723fb1c067ade99c936bd9d54d753ad7cfcd8c935033415754c0fe3168a1bb073c803c76b9fbcc356288453f782c81477a5537bc7e7971379425d5e175c2003b8d96d52433843f7ee6c7cc807c6206c2e82dee1827ca81bfed5f917ceec7fe59947937e30607f56d010569da6d760b30bff19f4cb80e6d5ebf3fb1d69d366aec8b2179e020188df1b4a7509b63e72a4703aed712f5ec09e1314f052f6a4fea4fe7840434040bd2be0142bef8ce2d27e6dc10c2f7d3d0f28dcb2c20dc2e66b9d6d6d47302077b639d4d866cbbfb5aff088826f7c1eca1406eb7a29c09ed347391f70087b54d5a90e270335bb4cd069b3da29d6989f22a10bf91a1947c2db7ac4d8ba5c36f29b26835ec1cc8a7b837ff8845c9dc2f405ab0b561ba57d303cd090bb73cd549eec5c299f3e124734e85be508620d0785c361aec526386691e15ab7711e44c41319be29aeb6f249a032cfcd865833e1103611a2b5a9ee337628ceadd5250f897ec1ac96d9c359c0ac22d103af36a41df88c1cc445d8258ca040a74c6eb6f0c4d6078431fca42b34a96d43abb02ad6b93efe2ea74ae0fe472bb9cb79b71751930d850e1cb6b3f756a4e8e539fc58ced5cb71b617783018cdf379a6dc2338413856eb246ccefaf8b780ac44bdcdd86196f0cfb5b8951a893312d4d3cea569911ec120b9880245cc22717bfea7ba4078bcd976ac628a5651ab7e7cfbe122481e2cad4d00914158c3670405e6167124a195ef263e566a474619a9a05bcb6fd23bcb1587d1db8d5eb9cc9795e84ef57712abf88156000df99466b0751f1facc1b45ff53160e43cd505f5303901440d1ffe11db584a6ac39db8bbbfdb673db14686de7af39d3569d285929aeeda230723772f8d5cc2b59f0736f1ca74a3c514b50ebeae67f251b9b3b6c5a8bf4fdde0ccf6c5d6c9dd017183b18c37ce87da7f54b751bdde6fcfcfb3198994793e0d64f729b334a4ebd0bd4b58845bd56beaf93437449792d1539b180b0006b7d7bc65bc803cbe585b20af7cf1f59bd12307a892f689f5b37554515de9754e0ee1934d2eb6139844055e5190cbd30b5c9bd8de17b29e1aa2e33494428edddb131928e160f6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
