<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b44f04a152ca308ee5393035b6a6a08982b5b9f566713d03cc5091a66a2d34f695ea0f0ac22f2bb3dcdb2d0d1b49a47aa905fd66791cd1ef1f21fcb0bf8ffc9673f3275139e44b38044c04eba91c6ec4c53a3fb6bc9f3c829263efa95b787407367336e2457cc42f190c3296841239270c4a2a53719cf4cabf16dc3dc8d15b10f975ecf70be34897d98dda529bb2377503199911986d3539e029146bb3b53f88720086692773711d8405efed3af8620a1119ac563f7f54b37e6cbdf26619c02629fc76cb5ed92b40028e395b08841c08e67e89ed58b6ecd54d65e66965869aa438a92db0efa8e10c922406fd7661e3b392f05dcab95dbb3cea54cc15fd887cac1bb5d0fad1a1bc6707bbc9d8182eb667e66f63a2ca2a09d6695a5192b272713d9db2eab3a2082cba449de8b78cb6d310737bde5d1c730cebbeba46beb261cfb59a268298e091a8e431929413f4bca26c2b7eb3d09bf6e65f9064462a624eb9cf8790e2f6c02439485a5a28dbb2e73ebc2ca3642177a3b322d8caad0d309a33f474441dc137c414aef9af1ce9c7ea26a1b4f40007842f1164686da2e900bc5cd8c0087bac05c27b6d8424295d20c5d6e53edcdd21b7577dfef58e94854c80dadfa4d95307bf77c33851e899d2823194735fac222a5cda0c245729e959bb55e8c656e7d40ab68e30f1273e9dc5033f127f32fef8043fc4d042df8d0ac4ff4c2aea0d46d9d1856bd408789815c7d8f2a17a1aa43d30357e778d6a43d47368d0d87598a28b7c1ef09582d4b41db8033d773d238e5446e0e26467b08325a3f9798caae2bd3fe5b0683eca434019f0385048fafa50612445a39a7706f894bc403075624388c5017014d455d37120a9f3b0a0251e7eb0d902d2fe4037ae724404ba92b1d4b16e640885bfc99741dcdb510ae4bd6fa40bd6ddb74be7b6849a19aad955783bf3297be1e9c338c3fae5182e6f6c8881bf00aa53963d9a187d78cb6eb2de00e23da40fe21bfefe52caf7bc2006fb620c6fb62af290661e8756d9d781244b5f55e6e7550116b929f858f04076d42ec87df9eb141e82b788b8b30dd72f74dbc8e90bed0cca96eb14526735dc4baa68a5a5f8b50aa92e05c8a51cc7b28d27ce6d5bf01b698f8eff9ac2d3fe51d6db8726b6959333a0f74210ed6adcb755a7e7419e0267c715ab9c656a16c81cff74ff743e3c89c5c189821f32e9aae99adf6b5a8eaf183450c7cad2b071b1b8846649a351ced22bc1d0205c0647679c44fd561695ff4eda45283633f82a2499f5ec095185903b17f1a5cbbab4f98194ded543a36b759ff1655e20ab4790eea4f2f8ccf0db1d4e85006e97c64ce85d13ef3a253bb7db5ca183e41790c6dda167b76231eeed3bf67b3ef059572b334124da3d6621342c5ff63a9e21c03a37ce084184412dc8ccd730a1ca0befbe5e21f84ea90400866e5ac01c6532d9cab0cd7b8f45669b352147a25104193a38f25cda03846a026538d6a20e9d59d46e129844f0253ed8c827a042fea73af83a0517b16c1945e55ea177d09f1d14657f884b0eef7eb85c46c39da32cc2cb633025de4c2047e177bb019406abbeb1f86ba376e57f97763653fa14ee2f5308d43d56c1e9a59e288e768d4b373f13d02408475652a67c7ef8e8d3096115038214f1a08634c6b0f108c62ef283bdeb06fa24b82c0e400e8617503f0f3b228792d5045c84e31512e6d2bf031ab22dceacac717129af5a3e30c17a6b69e2c4c061b7bdd1847a869697d761872af8401e0bba5abc4598d725267968d6f26d5caca8c38dcacafdc0bd62e4cae66449b95ff886475dba29338a83e2efcf00a1d7a2d68e4df178125edcf7ac1f5d95deee83babf98b895bb73f851d7e1219aaf3be44f522563c1862fcb8b5501aa64e121673676eac1c551131ab2a1acb97d7583d2f2b581920c1c21dfa488810ff643a46a9ec2906514b062fc4aa7e7e8722c8035534aee414b73020838935d6b6b89c48edcc3b773e8f0ea754b4e3fad2b145639edfafcd7cfb364f63f4117e25b6f36c2cfb8e226dc44250d34d489aa15e917316ad380f062a050f471ade690071c8f4c65f59837d0792075c2921d617354035847e6e1b4e093f567dafe5b94e2097d20c48a9ed43e57b2df62c13368152a46e1776742e205863b385ab1c4eb21e084945dcab08cb8e5b5ae4b5ecf21e6ed4d853567521467d7f0b31a9ef82e4368a599bcf9f55a51c7012a9a7c2b516d53e88571aecbc5ddef3327123b853fb545d76efa79bdc1e44f3d2ecbf9b9179b83ca7824b6f496f047d87930b4a643fbaf3f31c4c2488e62f308f5905fb9bbb9423b9cfc583901cc9f2ffa94cd01af108bb3ad378f9c542f3dcf9e46c686b6f6ae7ec7f7a802fe3db25ca4ef20d43ab00ef68bdaceb91124a0b5f582d491cbf8ab42fcdb34848fa1d7b45da69abb4e2ac5c9f331f797c5ee736ad05f22e879262680d716c25e6b698201b37028d732489a297741dcd6f0b3b300800a35e8b2f972e9a4a3529a2504a6585922c964b30c8442f32e03aa5e49c3e1d0054d97ec01da5e0f75044df7fb1177bf4dd09c3b74ac060f677e6d6c6bc71c8b828a3910e1d475b09ccf211029dc3fc474f92d4bf2869d461c03bc60307bedc4324d4e7dcf6309cb3d31cdcbac412ab9f6a368f83b536c782b4f261b852a6139109b95d2c2988e8f5fc27ad9d24368242827a0363ebfff864d845810e3110db329328294d279341df44bbf7ba0326fd634e1195fd8dc63b8f109e69854094247fafe68783e5c51872e36438928e0cbbf322df89782d3939ca9770195baa8cf18f06b39ccf52475edd19cc631e4289461ae0e56df7196d03904e7d63a9e3b2c1dcc98ee105ce7db75f37b59dda520a50e4f95fd0ca913422e2ccd5c722dccca1ead5e8a42f33a6b5b0bfb28439f274891e6bc587c6d3816580fffaf56b14842f2f1b8fa9de6646e9bb2af6682d5456e58092ce634f88e9bd7524d6c7b16d5f5c95b4d5b825749de0d73c70f84ddefb45a22341d2aba0c522418b4208c150d0a669c9a33553c68b47424b3a450f62aca973a0a0cbb8e91a4b34bed76df37b7ced6c092b784069e661636b2153c57e3928ce8809d2fb3dc7ef1a5c39d7b6145fe8a8a20debf1aa7101e46dae8775f29bc681823002e7cca636e3adb128e1119e1d025f622f39d2dc82d887c2f0c612ecba8168213ced24824c41e94d9c9f9399372d8d4ce0703429ca51822e74c0db2de4e47bb66115ddb8bf1dd7ddaea2bdd0001428224a6de1f836915a7c11f64508c38ba5070cbf9cbe031ffd922b413f95fb4de001171d9142ddc2f4f9b294d523ef09773c289f4ec3d6953f495b9fa3e5dd7b0116487d006a2dace223af0deab2d2837edb604581e5359f558454be87b24b3cfff586a3ba1d201767f16fe0119c0c977e9c9665fec5bbf4ad4edde87b8bded616d15fc77dd0fd149f67665cfe9a15df634b54d84b4b4a9cbc295827729b7f03c03c3e68df52a39063848f39593fb87e7310a373041d2e77ab2d52052d005e5e60b4eea05713b75d4718ba75c2c245b5add19088145c8e1f0f5be1e1e3e40f37babb37a9b80ce00b5776e450e2f169d74ceace150a90876a73600e62dfc717ce289aeae61dfc855a821e9a747e6680318552fb72b90703f00512f962398719bd7c62d01bedd2263619f21198e6fe38ad49f7c47ef629aa823dc8cfbe2d856c367d3994ff4f17179d130b20e526a3f0d09bba4fb03e71713b1e8ff186cbfbdc5d072bdcefa3b65b9bd5602a21199810b30295e756d8d958f3bb7d66273d3fc52b866b72c0afe5c43a3919084b8b91c24b7322d7ba9c95029174f9313b50d738e963da45e1934d0efcf67542a95c64b3f994c51aec8d3e2ab03c3aba8c200ab57133f7999f8f6e2d3080d231ee24b0e8f3a02b360468a3491c0bea110f55c23e84a9d49af1d74b436e8d7c7a9ecc94bcd0f5a468e9e4c55e94a4dae1471330eab19869c84cbe13acc4dec5372e184f1b4714dc56f5d411bfc606f24f64c0678697482f0cc21bb0ffe9cb8d6e5c6d52d11d24697a48c374065a549ba9feeafe57065b702e5f9ae83bbd6e512e418bdb52f4bda03d1a577e8e6d2e9a4017cca2408217a917394c1ccaa05802fc49d52b6670330916283a2464bca4a101fe9992c754bac3f33784dc145e0b21bc795301fdcb66cac03cf8a20b2e71817a26db93fddc3d58bba6754cdd7ccda5ab05a5ffc5ccbbf2654925d7279913bd89031cd4d61940af393e5011bc556312023ef0b78892c3a6069e48608f2ecc2a1ce73270e3f437c9efadfbc3fc1e02a5634a60fa4e3e3377c7355969bb81d8285d491161cede48c389ffe753fa2f10d57351d1e778365c44e84110bb550bc495de7a0d27ffe7a2bc4bef036a61d47dcaeed5c7796f5a1639ad45a4d82e49c1f7c9ceb71ccfad1dacc8ada6d4c4cd8661516b9107e26f51fd1bd2d069678a7a051bab4bd0ce86710b4821b8238aca876765b6cf7023b7c4a4e6bd3df4d66969afce1128ddf724c24fac272c35adeb63472a750b8e4aa851c382ac3715a627000076caf10d8acf0d0efa902ba073aa898d05c2eebe2cc6cee0ce4cfe275db52ac0483cde10b75be93089b00b87bdd418783070e2a3d5b26873dc85d80dbf92b6e74cc8512d8ba7fc10940f837c91425f050b3e4f646750e751c0cfe9f1c603bf11d67c640426a65174b32a35b5cb5e600671c0edb43cc343a247f9caaa539c774e78bf680d1c77622816bec7ef0e04326cc960dd95f5acfbfdd8fdd01519e5d4d0479d12eb819249fae79558726efa76e5ceaf7b4cea893da855e4c6cf3e6935dd4f78032243aa4c192b7e4796b7ceb9cc58114b7056982f3d6b1af4d79bfca67156be17f93c72b3bdd69c6df650128bae6c85d2c38a2458387cbf5f78427b8965dafa37931e20f4b61aa4c913337230f8a3fab7768eb938993c9746ae0c1cfb9020d3651bef036ce985fcc321a28c96e06316d039281d2c972ee0287910eeeabd1e45f1b6a53cba0bfde43d88d80841fa362a1fe49e4c393ac0038c30b47898c1885c87bf4b79eca032426a103b36f393d8e50bdf41ec27685f25709cb0a1f43f2cb8f97a1d8379b0dc8405ee3323c7997817c3fd8c8580a1e002b2c34f4ce2a019669861189fba33965ca501b8b2b5678ad161df33b4495092a69549835634fd14c5edcd79551a7b35eeb09b27649d6e0dc7f00500714ef260b0fdd832082d3905dc08bd06fd75947af052ef6d87d938b0bfaf2632d6fd97635305c33a1d1b1b92dd5697a2461bf2e1b03de5d137a2cdf389fe949b552387df8e2e3a0c6b2df2045f2c62ce5859503f1d7210384810cc56e38ee97c09184acd430c471919344be02ed167e92b476a29c14a70930f8c3075beba03fdc293e2e987952a5cbbb16cd07d9273867534d220d4c34d336a49d4914504352d148f8a4cd75bf5498358dddaba2d505b96297c448eacb9b0f808f3062f297fda9380e83979512a28a30513c36954f72b7534ce0c12d6d0b701b62c1d279644bdc328af5d249b2031eb29b70ad52017ef19939212710503bd73bde5816a60e3be08507369a1b9f6760d0013189f49bcda66ae01c2b62cb24c1b975b8b2dedd56a943761f36d02b8ad2b1c033369098859d4cc679ecf12cc572ff4be3ca8b596eb198ffb71b8da760a8e847534d988b388d0a8569967f10180b4bc2f8de3dca90b1034e407400085da68f5d8e7aeefeba4a1ea9199e2f741e9d533e60c28d65a364792eea2561e9bc08376e440068cf800955aaa7b82e652aeddc2564341ea4b3ef409ada654e2cea9f4977835f8ae2e1f6914d6981b7ebcfc9099d13d5965b5172e0ddd2078d3e22c5a38bbc922f5d2eae3d0388d5e00c42072f86d23080fa95b8c00bd37217c6cbf33c8eae746169dc9f042ce221b531a8e6c54b5d00f44602ed5b6174752ddff08a890ddcb8de0dad5f2de86d3d4f7187ff2989ff8bfa156ea0c68d8288292db594315cf5cc060c64cfb5e2c19fa4a7a31c4dc07384c814a1a78ae84d859a7800f7b3fcbf3c4a55fdba459ddae43f62d041fb30f2b1455ed0d068fc5340e8cb767367a1505b56ffbb49441c8e78792fef12c0bcc3ffe5ddd2bac586c548793a559a0c9daa962ec422e753c7a955239bf678ce1b629161a378e1b542b11bbcee416bbb34927ac6d2fd7c3fb2076806470b6ed5e026e4d2f7d3336a7a0f9b4c53d1483e0fdb4ba40f12a5462f53f58e5f7b4c499cfdd7d893e53f0557264331d57619bc5326ebd7c95daf841f9ebf96c43d8185cb1ef493c2e93d743b8d8adab72d5cc11ce170921b890d9f982baa7b97a522a55b750ba272c10056b110eaa7b75ddfd9588929b4ee4f473ee10b16d6ccff082015908eb749f2118ae1a27633ce4d9dd9c08212e233e86df9eb54aa3477085f7443e8194a867f20b34baaaf32b663d7056cfabadef9d3a62e39325389eceafb19b79c1ee364e17362827dbe379d367fbf6944c1e72afeb32a51f2fd0323bc48d43e035c844f87fa54e8ff01600db29a144cb72efda426a5eff283a6efc2d34c0fa12bf860713bd71c8d185ceedbcb80be763e8290bf1fd20835c57fbd7439ab124e2e5a2e276738f33f1f11d9f548fae0747093174fb681c68bd04b84a289474a9ffd501018b8db21e1160e98fb17a38277dab716256a450359e973ad327816834d85a91c9484a75ba518f47313f51f5494855d6847b41d3e56b537f6fd907b11510872e2a41c2116c91cf9cc914b9f7462f49300d6ff8e4014ccf821f800ef529568ab01b45a6834463eacf336ccda3d1fb50d76c52a8a4a8d8071ed0160dde00651b1ef284457f81cb8a080969519a824e589f974c32d54e9c9f381cb1caf310362b2ccaf41631314543936fb6085375b8cc9d262363f82dce253af4c0aab6047b06fe3fceb398b634a27f39630ed7be897d9fc160b9af571bdf61ccc0867dcdc844ca0579e13180a884bc9e4dc9184cf934b2a0474f77b2cd47466649b2b433211b6870cf578e7a4bb14d5b536db6a67da81f6f715bb78b11ac6dac3eba884eaa4daf33fbe8e33aed6b4e06f7f844f11ae68864291fe0f27d9b368bb0bb51be3d28d0584c0e4764ad3a6ab72ea9ed7cf6c11e453ff51dc0ae4b1eb2a53c2717e6fe8696dc80af3241f0fe4063d10fe4a6f204c8c50df9cc42490e82de04c3f6c744992cec7df4d2c8eb9a6ca71fb2ed3c54bd656c4d1a670e8bb1ee019350cb34c73c85348af57cf512af7f8f9b99f68561f5aedf122bbb2fedcea83dbd7207dd8a978493010f7731f4dace284b23133d886fd97c54bb6bc9e2327d9fcce48a400d2824d1e24ac66e0ddf83257e10be554d341ab90f1204f9847f0421acbb8c2cb9ac6834d6705beeb43d1395c6c2714d1ae35cd8b05221d0a1de237bf511faf6b8ad84edc3dfa00236e83a063aee79e3da6d68fc8ee3c9d471322e894934ce346483c6e85cdee23c186f9144b7f919776b7a08c15109f2b53cca34cd4841bd761e54c583c14788805d0c73f009e0a20c36857443eca557af2ff42616f555125e984975cb9a5b2b62ee34811cb9f6a5c5137115ea4593ad0549fd97014d588689fef5b9084e3841d0699c41e88ea97c711faf0ad56821f95b5c929359f28eaf5f12e355c5a56df6839943819254dee00902f4b2a25aec707da606d1d0f1f4b7dda870c6b21ec319ec8c25a46b21ddb5af07967fcca29aa54eb928e6f48e69e96cbfab07aba7b6fa163c31624eda0d5716e8e3c6b0a66ae5b97c56797a4b269499e251f6460c54b4f02ef10fa2656c431e02c8e10d08e9d24c9ad913762d7800b5681397ad56ae9f68191f625cb73c81c601a63f14c6ff01be2852890e15d2e16005e4c2350663670d056f6bc901703738ace035024df6d070590bf3b1dc62d59e0d0520b0aef22f229d1eef516499fdbffd70b2b8abed47c18d13de39ef453d888d0a46a2f3206a019c231c3d0e781d4a3de65017bd4ea20ec34778e68f061871753dc91af5d983c0b29e98fbca9169849093c8df6ceab39642af48a1e8d2fa1aed3cf3c6fe38a3e80ce1b4f5b94292e038098d2c7cb7f98b7a7e27031d60d3fe4bea73bcbfde8407dc15c7c455b80f3d441fda932602411d3f369dbbe24c2c115ffa12bb035a61233b53abf8142d628459e242fb2b425c6d0e7d2d6de9b721658cae63200c54d11647cda04525fbad9813105ce31e457d3c2b1a87ababc4e27e2f2987f540e3607d2e3e941954f5019c759b2d083f40a0834764c102016a90c65f5422e67aa46ba0026143b22d09655dc995bdf68006e48aa443ba0c6f6ac4dc6b5871ab2bbecdef5624d1657d4e75ba4fef9dc67067ca4acb8c0608f65a6d54ba4b81554c07ec839ffa7bcf09a9332e945e50c3462b52f019284cae4ad9dcee9d59416b548648d1493753654578025596ce3881facf32413eb30db2868d4c30bc410330ab51ac84da0b9e042079bbb1998726479a7f4c2975c38a0ccd1ebc07d533e3091c33e1470725acf4a47849f84e6e4dc443d0b8aa955c8e16ebfb6c58ab293fab5f685374ece42d2f37cff2616fe9f6f0503c9d16a67c706ec442cb336b47df57d52b198d6aafdc5da428b68e0856625cd23fb677eae723d92c528c90067f0f0811434a88a3c4f12e472b9cafc898bbc78f40bf45ef192c962adbe7ba69f068c54d36fde409e0fe83c53c29ed79ca731296fc384e32cc88f985627fe62aa304f9d928979c469e0fc2e830983fde55e1a8a386ed6a504bed2f98a871c25856c0ad36a16e787390c188a726227b195fd57c3e6828985efca2f7f2bed98c7f18b63ade1090a8b767c88cd1020439d189ffc3fbc416b7f227bfd064e7b535511efbe569abab07856209da4ae67e20eef9d9d73b9ac2ec2ccd1dadf9b06bf6505505923a807638b98cfe397a10a5a34cf7e6c0024f7f05c7c3fe314e21969091031a69b8372f730436d42fcea8aba37379032ce8c8096b8cf09096e6e6339cca13989a1a672619ccd420c3a64b92889eea5d6ee2b2d53a5a5d0a9f903b1965ab4b8eaa0d7366533ea3dfc07352f8ef0e63b16b673dc638a201299b73f645f5e5312ebe293544aef333dc38eda4d94ab6752c9fad29a2aad5520d4f1d6af5d38a0b17f8094c8c75ff08b141c7a72cad735c7906282aabd417c9c2522aa3d8a7b408d4855967fad312d4a22f4b7c1a9486229e24e3b152ebaf49b44ad4432cc575e506a443af50841655da2475d368b8edafc0aa4c655d40f9732ad7ebb4b719f21fcaf454e6e149619922ea1b73fb24a5195b199832ab7d67f5a1a73e37e71d7c11b63bf018b50e654589037e0cea8f256b3833bfd728ce99fa8e3a66cf249980c7743d4f5c91c2198578fd69a5f60d43d7514362a0329a4fd887d77a8c0fb554c979f35cabb81a6d8c767508b9e5ec7de9a2855a8c34512d5dbd6da596c8ba462df291d33141760ca9c415b04fa930d14694f726ca1bc72afc950a1cf81e8d9cd2c0c61c46a8ce1512d2e8fadb6d9d6d33f4d136789a647550b4ebb72d214a611d5e693578f7c08071f604752c7d165ca30e9bebd7140bdafb7a098ddcc5868d3a6d0e3bbd2ccac074e4fa21f6ddce81998fc7ae900356f7fde6f214c97cea438faa886af1c5071a78af4b131ba6520737305a4ce0cb716ac3e7066fec0d2d5786009449331e145359a350442e187ae604806fc0d3c9688aed78722675cdbdb32629efce2a19595bcb61ebe7c19da34990f42991351d5cfbe726098a2b6de7f807bf41db8d3f7ce87f2375ecbc79b05b7688a2cc962908bb9bb1566fcadae813868a0ae037a04c0d94a39faabe7faa7a09693d5486d5d2114198b4246b7b1f2712236572e15467e178495d0818b68db4b5323dd4149cc055a4069863d7392b2472abd63ccf5beb0a891006eb6662134c13bc5372f6d2b47b16e3eed75b30fe29d09e44418236a21744e8e3d6ad5dfa88d668b93c4ee21d508757aba5b5892824d62ccc22ad29232920c023f532aeb729f5b4c65c73d940d60185a1767048eb838ee2a9e9a99c73021fa9109fd0a4eba9b27d4886c1ec95ed5115eef28bd55f00dd56c0df7a97df554376a0c3908f86cd2cf476c527749ac10152f38a8ec034121822fd41be1e42a416f12bcca9bef55b59918890ad31f03cd68247f55fa971ceb254c893ace86c1983d359ff32c27498a5cbfc148bc8c8d4b44aab417caef9961fd847653e7ad911757641dd1d15b5c09bb73ac58a9cfde9df774ba3fcd78bc0b0000ce44009eff487cf871bea843e2a53bb6e15fdcd9844409ed3052a3b6e9aa8b15736ebd71eab08ff690345025e32765da884c49e80f9073bfc54fc138aa84a4d18ed25f896d2d437ecb2646f4c5f621ed0e50892761ede1987ac9e775e498f268a2507ed4bf6e86522d8e89de8c98abee05885ebf8e132df8e73949f25a87c29f28875366636161e307e654b720fa84fe1f9d7276426bde3e232ca34089eaaf31e865c4ea45a1031d659c88fcb0a9070586fcc15b2df15dca5c0487cec3bef19482428993ba1b18376405c7d885f643d82bb050798cc7d7d97b7caaae4d881bcdf9e60f4891f3665520646bd8919d5ccd3e4883985da8b1ea1a175eb57b1138adcc7c66a2","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
