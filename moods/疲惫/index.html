<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50e37a8c99f96f5bc288a68a0106f4c86de6c681e8638c121bc03b853df985f03b48a68173eb9cd85a6b2abae28055f6ad70ff1a5401ebd27ee3aab47d32704312bd1ed51135357689d54d008cfdf9ead431749ccb4085b53c249cbf30bc8635f3ed458dbefaf7b7d4564f17d40ec7967f35ebcc4e6315d0a08f251c89eee3bbdf528e7729167d84e2c3ec84caeb05237c5ab5a819fc81448e09b32439a807135567abfdffd3740f8ea40cd22f8ff0d6f12a0c75bb10097a35ea2efc9a4b31cd0140cc4b6e0296d32cea08a49ef99ed07f8b82774627ca9a4febb457342620d78ed4213b92b9322e89c18b82b4b3dc17617a899a04166e7353453fa4c240540beffdddb013a8a759962225d4165a9d6dc9cca6ebacd7e0dbeadee060c0da52420d29ea8abf0f339a2945c0ae683e2a106d57517a7d15e2584d5d0bbdd1f7a5d6fb21093215cdc01443169d8dbedd4dda6926b2b58afc0b3d9a4a3e7272d00bed6684944f30ebc0812a4e215096359096e45d79dbdbe7e8c0db167ade32a0015ffcc01babff6b32320237e1fe2a344019abd40261c66bb900d0c73203aa6461ac01bd51776369db8418138886909de30ffc3c7b33a729cd89138143fd562117dcc5868c60d5984e1c537bcfca272d7cb6467c6a0b91ba1c326ee49c929b660fd2edc0a757bf30222f7cc26cb9f7954399f94a3bb8286f2bf030e31c4f64c875ec713c6dbd4c351bf4df35c6ed01a2edf76660910efcb2b0375940b1c2ce476d2e58c66c7670720bc3de4f5395a0e78a9a146fd8fd8cafacd58f22aba20be589a90ea7c751d2a5a211b986e5c66f3757a6d621b0c40d15b58b420a4f8e23e6066f2d6a38a47424c7ea9d5717177997e4f1f4fe301b16ee3c940325fdc496abcf00b5c3020cb76f9266b73524726739bcc4834c02c404788d579d1fb5b1b0ff5f07fd4952600aa16f509b5bee01901f58379bdcbf2ea35cdd6814c9c56bab3f92da17556972e923ffcb71330e7dd56ef7348fc4086328ce368f997ebe53a2d8e1266c9fb9e003484cfd6a676f558268c2465fb76392c77af36b160e3797602c18ef41e303d9aedc4a836049bebfba83136ca77ba49df06f0636790427b027656a644d7972031c12d0bd9badba5884e5f60cc0e64623ed5a81045ccde31d7230953861f675ec7ce52328770d51f53f7f6d6b39e1f2e7d8d94eb16402410e3d650b754ed504e22b6ad0e5dc734171ac3966822bb4371b5e74179f9bc8de66b51b22ca9188400ba11bbe5d78f3abdb89ae5f672dee2601e1370c6339c16d0a0cd76359e02e364f9fbcae3ac2fa0dd033ccf4cce299151491bf5a7cd4853573b708cf42a59cb31396889bcb51d1c1973978e98a805f8940fc86b33c7be0fcdcae0dd86fc11d611c505066c2c2cd727cf3c046cadfa15391caa3dc0664e002023e2fbb5d2058d90740a292a27bbaa0e45cdf7325a7d0f766c102d4fa20c8b5d38f74ff1a63e3117065e558f9ce954a6dfe50cb86c299a3b7056e0de2a30f68aa5a3a2577a029bd90f200007183e69c269d2bb27bed41264285f70a4c370a235bf88f61a8ba4ff639709f9f88cfb3831e9061df4e5777a57eac8e23e5fd30189841d3ba3dd18397052c7d14891898bac1f033707844706b665b474111ed4ff4beadd1bbc0fc3c04adfc974d9510f9f40bd2d6351f7b9a2b44b31733175b665abb373a3a8966ef64c80184bcdb1a364e31e6c0e754f1dfc02765863989314d80abca42d0fdc5b47555c5e228b59ca9017fa48aabc5cff392c1d15602f6cce872d3811879039979965c872bf38025eace971d1cdbef304a3efe6e683e3ab62c6eb4b8b89aeffdde2ddfebc3f7159ba7588343e6d6674739ee24945dcf0aa23a633cf157af8035078509dd753a178b9a789c82fa687a81f1102543c0776e40e56638e41b6742e0d407df583deb138a0baab38bb1221c00e108d91728eb149f9f659ed6a8aa72be47bbdbceb5b57e8cf17840a438fbb1cde0517da0949a42161c64445f457b8f1be33f710c4844cba577e2e550f481224f5d2fd2d4931330f269b778b195c04b2a90439b9bf166def755ad9b9565f09237e0939be8321548e9e64c3c17f5e124b4ca5185942c50e4b30e217bf92e12525c65f585a7506151bddb05b49842eb02e05b42399f3daec4f70d164689e7ebb11eb835acdf0e0cefb025cbaf2184214d04cbaea57fbe55cdd2df9b09a32b27b711247dd937d0a2194f92b4e123de722ed0b5ff0b36355d0996da5fd2466867cd3cce17cee1e6d561c34dc17c852f0d3aa4ddcb423a5405fdf8da8198e142b73eab59e05910993ad708be0f24d65c5584464c0ec5abca20da5bdc824e5a41db89378d8c00c80835d351b315c55e7e75499dbb220d12a19546ad788e291f135843d75c63ad164ebc90a3b54962ea3c6ee0c73f010f5242948d0395f37d3b5a2b6a05c547dc9ab2242c4436931b06ea82b07742bdcf8d129a211c568c5d8c4ea05632dd4d77b39ea56c40b10e191939f35a159c34d17b4b91bcc5f83e9bd3f4007439513904cb04fb4b8f0830a7771fa2dcfb8fb0be2f9e9193bf90a198ddf6ac08bd8e67c9fe7a8a066e193bb66a6072af5e99c19e555009ac9cf85a83fe082d0ad2f141413e48203bc4c49d99ee87c1ed8f301253f4418b2e0a04603d19e67c9cda79683962c23ffa54d4fd1965e0d2e61ef0b4277e29f7f2059341e1e036a5f3f419acb50947dc6cce583f27b92defd673ca0d29362184b5ac6e6710a2146df90ed95d763965cc76a1c320cde454476b84c4c7ec81e5c69d195495094789bcecac0a930bc6706cb7c6d78840b5ba16c0a2ca2888dbabed4b52e72afcafc8ce89807b1970682f45d03079dca174644c2676a7cb1b91edc84dedb7e6dc2881a0bfa403bfadfa7332a0d52e302a9f10477fca038d88ec80e5222e00eb4e619645afe7f72cfae3bb812f9a60a812132381d4d4551a3fbfe12e98c6db8ad7d8a0bbf055587ae3d32d3924c61f5568be4cd559514fae860658dc7728dbfc37036e82088c04884a0a05d709d13314a48a65b3228ccf413f9eb492dbc9fef5ad3f0f25c1a120ddd6182db5ad85c85220df3a0dfc93e419d4ec345302975155b927f364699f9db364b1dc8073a944b7d34129f84ae23838c5ff983d66c41902f1a00df797f29223e9a1a03dd0470b55223ad67904a9eac01f4e9d220630c8b7ba53018ec2fad4eec736810f3bc973bf5c745c2baff3ac8dd19eb4bb98d3fa9e36d3f9156ab883417c0d382ef667ea8306b2e22dac5259a1db407ebcecab19ca572d294a84f2031cbe130244f116250f22d153dabe8a551ecbd13532ac1f33771a87c4368ff91f2752ce18d538dab13891dc32a567d9e4393f12885e6f21fbafd2e3b8698d48c604ae9d2ff447dd62f18a333ccaf4c0b82f91264119b094844a95d20f840962a3def182dbba497dbf0f797ab5a6fa5fe96fe062acdd86be76eba70033ecf2c1ce268232f2a404937c3bb1a378cf277c7ea15874eed9b682b66ed5d5d880057299bfa4bcc1e866b04afd43792059b3986ecb79f757451ec2356a51431786188e0571022e6c4e44032e63c45f81310e4da1413f7bac6a66f6eb9166604f22534d149aee7aeb995cc232621982723f7ecf5870457fe12a89546fbe987663378e6424711a59a6c6408024ddb528656861c6b886d1629573b75c2e85b8c0fa0509627c037549bcfb0f8de4d11fc0935ad8198d3a80a96e2e9a5440ba02150a38569d9bca388e9114fdac1bbe19bf7986a7b29f32a54729fb70fef3d835991bc4285424dd8821e80ec3afc93c33927bd97a841d71ad0d6a522a0af840a863cc68fa517208a5fa595cc666566d01f68604441c4b5486e8e1e771045c7d9b4436e8902e9b42fce3774e9319272e0b6891b8543db88a023363a00cc8de41c8876607d0b409b0c9c9e0d2c90c13f240b66718aad4f4ec943d8b17d05bd73ab17f49174a3e9d008765b1d69eca4ab831749b1af8c5d00336228601fbcf2593cac5eab73b39b575f02f105c6b9d46ee84b06e7f6a45e7a02083b121f5fe0f299071d521243652c19dd2531b46a8c389d289a115e63d596844b81eb9014d1d83cb4e2c4d636e47d1c12575850d10964e3ff4ddbf6b47f5bc145664b2522256a5eb53f761ec4867cce0d38970761906e2e8ff928ae3ea6f65674c97b4df4d7febe3a62d0b474f3232ce64e67140e79fe416131fa797bbb45a7f982ac4b51c149265568076ea6cc650edb0c2710e990345793d04621dcb3176cc62de4710143d823fef8b8c4474a3b4cf91d18136e74f6318a7725e9798db642f4cfa8709723c0dca08e8f882c4638798c235d97dfee0bb21f5e0ac18d5ad8bf162ca789d010d17873e6d8da383b7db3d7782610cbe11f6ba3570e3087abb73ebbcb791e161e0018c613ec66ab5116090ff97fd37b0ed7adbb60572aaf18d73ef817a8950cdbe58046cf0748f4a62ea1722320f199e3b7e523fda7989d7ba307564b2ad10c309d137a8dbcf2e1feaaf7484bd01ece151b255c91dea05a0cae575dc9ae28d0018f5618f05b5e2bceb5a9da75dceb9370f9adae42755dc49d8377e20d95d22d8fe5836da771940569eceadf299f3cbea437d351642fc2876c023de131f6ae69fb4ca1b2ec45304e443eee8f475fbdea5478e5945695a58dadb8d1dae723702557e4129f82d367f422196f133c9e40f660b40d3ce59e23366f49cb2e1f3bb6254c18786f7f7733ff13dbbc445fde5277044ba71fe8fb3a4e483be63731b52c39ed82d27753ca495f50f2feecf276083ad4af80b7372594978560010b99c93855ca6bddb9bee2333749ba709d8c4f5ac21f1860a854c3ee2e67c29c777dbe5eb889c6774e488009884f4af30dfb645cf7c7ecf0e080ac2b7cf9b36d930c3a093b91f011ee4331297946728bf10cb3f9d2ae22fd8ad9c2f760b4df3fe8659a80b474350b5f51da41c38d6d8956fef61db4fd78083d544da69982b21508dca795e6a49396e681b8ba88fcd83ee3d958d3b3d3a35a5a280178d73d727e86e1a859888e963c3a49bb2643af3a9ba8e0a08c75f6350eec7405c98d6eb9dd5625e994737a272b293d2346bf3d56dd1c6db08338d47aa3c9a7c2778a50e94b0556d48822bad9421ba0871dbcd328c5c7ff6a984ee2a9bbc4ce7da87c3b1ac7f263753c746f4fb934deb6a9924b0e8d9692238617cdc5801f30ee3030ddd4740739ba1a39cdb4e8d09c65c2cd5ce9653c477b47adad6f5fa9542c2cd2ffc48fbb9bbd0c14889928fea0b459764f9f0c7730b4e4cc03bf2d727e03daa70a64e9174c6ca892e948bf56f523b2a06a94ccc86fc3bd611fb409c3d01fe016825d2baaf38961331a49866cc5d50064a25e5984b04fb3ab0d6a28616c05c51f5e7bd170c51acf5c6b9ebc623a231a78c6b82051aee6a26831fa24a0f023be153e19e1fcbda6d137ea82f0deb06b24e7f5ca14b58cc5184bb26a682b59d6583cf5119adc2f31ae7e27c7b53e95c3a45acb9ad6f27eb8f6c257092100ec0045b5b347d457e6c9ad85a198ced594bf44542302215ac519b572ffbe035e55442b410c07c6c88cb05960274564d77de8bab486b4baaf4f78083f1d9b6d4d33a8c97d3cde754a1ecded48fb78bfaa4e8c9146df00c839a1866cf825a3cbf33a69a9aa38039172d52d61fdf3e82ba0301f4b1b828d56b5974a5125e63e291ec2d2ae99b04bcc827185eb4bf3d7ee75c26b7ffd1989e95b7784af721899ea3774beb9fb9d0e59cc75098853d92befb90e54803e215ff527d12ffc8372d8cc8f55148752a7ed25b1a96922c3be15f7f7e0b7ddc9f2aed76b253a6548318cddbb11cd01d7a19031dd320213b1a3bf40dd2357925cb82b6fe07d79aa3d18833c76455ae268dbc2d9df194c177a2458423da5f2239484eeb2f5f8e6e2df8ef3d0e958928a4d0e756c90e8c2ca3fff9d8ce20befe6a8a353d6443d4fcea372186d0fb5e3f51c5a1408e2d4e5f854f94b7e649c56443d8d0e31227c84e4d2cc8e1261b4707d81af8093c3ae791fd86cb706c5d1c68119dca0045041c2d2e11b62114f7a1d411c869c04784224ea46a7479a0b71746fc04cb142fc5ef4a0085f25bbb0fdaf5e6a33ead869f9fdd43a4cdd5736f296d519ed26b1bcc91fda02fdeefae38463b40c0fd4ba86a0f8bdbbc3cd111c217da17c62ce67e91a8ad4d27a8741ba4bba06841a1f957c991be135270041b207ab8e1babaead7bb55d78f8fc231925b3202b32421c871332538d3628275de7d6558a40f27b41b684ad353123de2f0e6f9784ee3b875a47e0bee95288e910e80dd056a6211a1cb06cce8d9be8a4d672b6be32e6522f64f309e072d059a432a2f566a5ef99fc685305fe82066343bde433e7b65311bba758ad21cb2ca14885cb503d92a9f9eba66430c292da7a54fd68164e852975711165b08207ff2e59d9561ef19cc6ef385cfbede0d5ddee6ec3181debad863c585ceb8577343cca4379d76a2e26c4ff11ae5ebad7986ff51511219495d50d1b3ab9ee6adf018a9168a33dd59a85245a4721b6381e84f1b15edcd4f519cb92ffd76bf638ef6dffc9c44da9db2fcdd303d38af94ed8b475e695d165bf68357fbada072b62cb1580ad695f5932ff6efb66adda7bfd784fed61f850b0d2bd707b4332d83a0318268cc10ad1b4da1832ce13f7b4ececc63206c5002cbc6bda8ed0175289777ef2571791ad2585d890e90499ed11750718d0f64a19ef007d96e4c324d5235764a8edbcea8df89c3ffa3e4429c289290d3e9629f4276a98578fde0561df4912be7cb0fc97456d2a5634559545e9d535cb5591f72af3d53d8828b68af0e03d388eb9fa245610e3748930ffd9140f2799c15c0206ee60973543f495c03eff2e24b63d0914d943866bec46185d17e8820df65543d92ad775badf4a9d3ab1fb32798679bf5fa8ee03bc4fce943773eb7dc5fd06125aeae5131fa56948f8258fc74431ffc15b046e1a64a096a5a1941a6e44db35b603f2805e3e92c007709c15b7a8900dd710fb5517db566484dab68489403c5d2a7117d73ebc685be442683622c7b997edfb104bcbb2f5f67e85daeb78eb4101b96b1b8e0ff2ccc73ed8d5434a624f7bc52edc72c8ea9fd38000ec56016ebebcbc2bd802071db5cc5a8f12f3de253e3a9e34d1bd7647b1822b607393824a7e2b42317d2da5aa4293489fcc6b584a1bf634936c7bf80abc98fd74b660a4abe95b068c40940f37fb5e0a2a0d590cbdd2eb4a42f37e59e2487c13e3e2fb7a1e3e559d3428c082390b4837efcff0f93ca5d1d12e197c95e0e70e536d516e3da85568c45f45f670f3fdeea57948f5eddbdd2afdcdf8f202923c35411a09e6673f4334a6033c38381b130e2888988574419dba8a340a074e5d8731b9885f835805f378f121804ef43920002a8cad7ae07415f1eea277e74a5a51b2602665e034ddeafe0651cb24b9da53a713a65b92906ea23f92f8abb1e0942ce822e69bd9494e932a9fc0bcdb7e977e2a443f0a092cf84be6de998af3db630396cd01baa285c3a9dfd9a0db2beedfa75e0578d2f7dec5cbb3c86ebe47f46eb634b408eec49ab09e3441315ee95860f850dbf198187678dec0722eaf724c3a6c6968c1b559c933f6a0d72f5824031353772124cef95e85b3dbc3c121e2982f1df876d3bfe5d1573d188bc6845913333f0a56196a994e0131934cffa8add9365a469904d75e6c68901f377c38f3c328b47ba5731c3bac8711fd465d7c11699100a1120c1c7650bff962f8776d21eb6c1cead842d247615a072ccca6e8fd68e55e81046f7141e75c1a4f811c234540b5f09687c9e7649bddae6c48de373491583c78fcb1ec7226b5f8a1e15a41be1cbccc86c4bb81ee8e89efd3ff0e0b7d00da2cf059707f380d6090b8b9e128c77659c91ee1431b0ef1ac30b033fe6c0196040606b610fc8b5ba1d3ceb16bc0f199062b7100836fae9d6a85a178ac26e5db25b79eb6f4f3a1e6aa99bb06cbb05e0998694cba0751e801845d694c4fc6d9a915cdde50081996bd4f5a5bae9ed9c8e236d09a325187781393d4a8d2b1514a1061a447327baa25d31bb5a5048f1253b7589f9b581a373417dbefdf8515d3226f7f3d20d44ae6c96cf2d4f2ff80bc256678237ba951e73db2ca2221d509bf8a95529286e0150cdf726e44ac947ff0c5c371a8a74827f48ddb263880d83a23b40160997edc3cd0ef8b061593f99ce899a0b8f2064e8a6af7b1a1234fe83831f086c927dd0460099eac0087c9c6a1ff58aa296f54f167b7ec09308ed532e3510e4db15e6145088df9d211acaac643340a13f50ee2b07dff44c212c5279a009528cc9e24fba5f14481da7874a64898889dcba899f7d164f51a2848655c706142515381e67f5af678d90cde7320f01281873954811a96537d98df70dfe0372eff37a5f81d62973e0de791de6b89b86485a1c5f634719bdc932a11e49b35765460451bc91b64da52802822bde07676dace6a93472736a4cf07270b74b2bf57a8440fe21d2753b9935a1fa378128cc870bbc21c58bc7a9e779ca086ff6572db3a445e2e22d207c4fe09236814f5bb0fc415f61d71f12d33c0c2b9d44d33fdacdc33d6b2241cd902652800a974f47adbc4479d5c357b16c755f0612b89946eb8ecefe1a3c9126da018ae5c66bdc7a13d982fccf37f33acfcd8b0a129494d58723f22f07dd35fd5c30f588ce3716f1e70646649ff5e022b3883a8488d621a56731a4e02ff5767bc4b3a9e401f38e256bd12140acb7120b26d44ed9a7720f9fb8c662bc2e06f875598cbdf80c227a075c43c5c6ee126b24e036042a8c10c05dbc880d6421fb4d01d3791e1563581298e6a572403f220cfcce0e2b817a61d5f9c19984421bf1c2d93dc3757c8f5d6fc721f9bdd178b805830b1c636ff9f0612877d4d82f036b3f8218dbfa81a92def86b314349822c63a34070459ba97826fdeb2c658c719d517b8a277b056341a5db9f7e631c03ca4ee8ee68d72ba4c12ec4faf546038e4c14d61d58f1da1bc4b23c36b7a14874c97ffd5e3db4dbf6f87befff8a4809dfa80bfa710b20841cd9895f9ed5dca08f1a7183e34e205cc183fb938d635ac5005d794977d8a9888cad8a7f57073cfebb8809ad0a8f69fd9fa46e19686b4c9b576ffd303a7521278cc98d4c072deafd0c95d7a1a7c4915998af09163fb0f2bb7378afeec512c0c9c9aca96f2c1c6c18e819cc45a43b790197f0025f8616e28c5d98dddad6fcb6f8d32bede5ab95b2648d985d643012b5ae1d5f88ea726deff02f7a25c0ab2b5f0df6aae6ae869f6a0f33e8ecc2328657bf01a0538741a0b593afe2cec24ffe3106c813a6ffc214e3547acf62b5ea6af37cab9a6567aceca7b21ce3d7df9fe7c787a3c9eac838f95baec51b9c96fafac70003493682077f20a009926142690726621ccbb3a5b71b78e099a21f6a32ed51a7aaff477bd9cd3ee70d7764cde0063d45e05b13b03e0e45faba5f7105436fc7d94449f293ee2b0cc9286fa2e02e61059c8895e35773463187df4447c6b85d33f46ce86d30b887752d0e8c3254c3d386c9aa1c3f604bad8eecfa32f40437593476113fb187cfb193b05341c24249309b0e106ed7a5268c38989ecc69ab002c39a2d4efb137e976871874953dd0a9707554e5830952935e3a788779a3aea3ce5ae2ad231ef8e66d379bc477ab6750e93595d65043af5939d60b33a958b0249d9ed9f53eb944a35f5b972eb5f9524ed29d8dc3e08f24b72c514b86e5577fd7fead8b395360f50aa054aec0515f38ce01b5f60adc990d8d2b1925b84bab76ff36bfa0c379de8b117f6294fa187207be6b45dd7d67319359ce11334412459844ca3ed270863f6ef0c87658ca4078e7e6442dd6c8b0cb8a6f30523bce6a752682a9f914e84616e67efcd7b206c22c08b30a0bf6ff34ad4d1c90df83062d36a68ffefdaee4776e0d0910e4769a22a99d4afbccc06acdafc97f19b5e93f23804b09833607307d5b370c202f8f463e36ce31f38ae0a1e493d21cafd6e09091b4c1a104c9ff1dcd48bd31461eaa66dddaecc83982d33ecbb906965116218fa58c972be7f1fbab9a1adfaf39e38e6829683ab61c51b5b65428ab211bd84ef357e0e1653dd0aec8494f5b383fa0885a036b72915f425b93a4204fe1c41ffdfae098eba20a5efa02df4ef7d55a3992fbf5faa3ff865c38aac1d724ab28bdafaff2a07b775202672677a1184008aa94663155e0830c32e8f29f9d468c2129aeda3bb10ab88bee263170eb79c02ade4aabb6fc9bd594c5450c6b0851471c1383a6a50b93843a8776d27b3e6cf4909a9bf75ea4bc6ce4d057f3c5a614d76410c89263395f9d301ea460be900f038f69b9d29f7c4afd6eb58282d5e8fea35eb1e70e45a22fc43b6ad0c5ec91af8d3c82892566f29f51539218f89153019e24f3efda2ff21b4569529fedac6ff801f612f1d0ddd44c8f714401154c10576addd3596b80e7edb75d9ef775f5f9c0e6d3912c330946c261ef5313551bfe2f1341bfa4c238347b58befbae9e115684cdd301c7670acdc7292f6cfdfbaef8593f1d9fc12151a3a40cafb1828ce18fb0ca3b8170dc38fbb24d0e3a48e4f72eae3389ebed7327d46a75eb5a1251c634c5e477299e0e19b22046a123f2c4f70859a5989f23f228d1b88f22b9ce39cca912bd4bd9acebdbf58cc151829eddd8c0d247526855926c18a800f067ba08f49d497e2eacad158b2ab1158e2ec94d92519392f72914941c9c5763e2f4c20ae44c43a9181907fa58df9d82adf9b8f5500480bfb567dcb1a00b2c963406b7937df3f3e911ab616e51f539888a4bafbeb1065dccb6d779e5522eb12823b1f14246ff027a56ef4968a85456a8eb2548277dd821fded0c0d488b774eeacb5959ea661b85dc31336dbcedf6affc849ba583fa4a32342a37d00be1ed21d9dc6b305265c65c4c2cb3db5533117c50ec84711c12302adfb21c1c54dd913b65022b995dd841d2a00b8465dbcec15cc9b4e9d0599be69d1c3c7be521bd36cc26cc9f3117e2aa8fdb1a0ebccc48c257843103fae5fb932052094cda7318d162a27469597d1ad5f526a00648b8acf4188890a104e986fec0f1548bd29f46f1df9304eb91a329293768bdcb71d52d763fe21f43058558a5dfa50697f05360d3c2489ce3eea13a96c890d2ced629a5c431d1e0fa4f3866a6ba49a45d5d4ae570ed5f43257839228387612ecedd4d3214f610e5fd5bc451070ee04675413dee6597d0073e210152326a1ee689409379e4154060e09e9c893d44884b7195115742b1f126ea16b5796e4fe5452d130abc5d0c4d3a60241c1c5ff6299686d957eb4c4cc347fdf4676a7624c4e79b4a79c770a67ad0f387c01bd90a4882e48ecb366433532cb046c8f36ce60b6fad23d88d0ef4d90f94314a7cf57a8dcb4d39b85512cf9d0ff039cd3305ece93a80f8877034a221aa6650295ac5e54b3a7adcbfe9d1563f6a3730210b3270574fd4ec10013a313b9c05c17c6b49a7def4a93b3f6aa58209dc6c148974d84c43d7e4b376d6373086ca31028d637ea17cc395dd29410861a8f9b8fc25f248a7f0c6607a6ea3fcd62b6006285fbc5bf6c5abebb1264bb3af66864c77bbe692ac6730f35d5313e974b97510c5c7dfc1ee8b93caa9ddad34b545a103702f854f839a7a90ede0c0d6463dd8eab7d6b4445620b16224ed0caf74bfc5edb4a7816d30e1de9f2e7b20a41400cfeb3f90d17a623fad2c825aa721b27478843ca86ed8df527bb06120a34f77cd7056333bff47ef1d96b2f50e0d1fc1878bd24edef33f0246f886b208a0d58e8f0e29a354a2a84952fdbb6837ce3cff057cbba56448bdf8913849ffb1414406f856a59c8562da4541b6c0af1be854b09a676c4ee0483d4543a0fce996f1c91769f8ff7dbe00e41e3b94bba352751b57c12dbe3ffc8d244611511960c3e6cde204a16cbb5aa753ddc68591c5bc0339bc92391ad6c4779f03bbd55ef3de995d7f8366ca6beb30a8989ca03c03cf38fe430d78810381278cea7a9051de64cb225cca85131dd6c1213cd79f80573a348ed2a2605baa96dda632a836004c46c40c952bbe645b5fc9f2e78bd960cc85377ab20d867f0c0a31f5c5327d4830c6370a21b4b20eb9abec93c645a49ff5b7bc0b093e6ad732d15e32769fa5d26225abb6f7ab96932e669cd0eee00ff6a0635b3e51dc329a30e4424601a2d1624e097c0fdc523a224241bac98ff0dc20c8e71066269cf68ec79d5f8c93a777a3c0590c316a5a8bad16ebb2797fe1753410e1560179984f2ecd74d9d15b6c0dae753b7c90a7d790ac8ceac75e3f085dea8637de46a808050ef20764f00b0080014dcd8985f1e75450c98ac1eddf5b19be3f16fffdaa68432ddf4d1585397dfb38d5fb09545dc2221433bb17e3b24ee60a41731b5ded36ecd28bdde0064eafed7f7bc987edc82ca2950aa4458e07f81a045a71cbbf4acc8b7dc21013264445e3c4b2f61d5dc5e7713f05de2e7e48c1e5e0cdc7204c4d55480dfb6e5ac8cdf641aa61ebe11271d85705d35e1d7fe5ca4f17baa5b6db141e06906d004f7d0121b95aced1e2a052a9bb2288b9f3e1ec941de04152a4a1c1d93daccc7eaa6b4dedcd084c65041c23263fbca12f60c16c8dfd131108a839301c96328305bee97b119679272195a85364457baa029d19443ca05e9e261fb737e59fc3d4d8eecb5858418ba1fe53a9382889095a4a1c18f0766f69997580266a856eb0ecb4660875f520652a5b6c5f0f200813f729fae0c6f6dae54de522b8db1a84a3db55ac3dbce75cfabe8a84c513206e7d0f952d2ac4388d34c9f0bff494da53e9ebf614e20ccfaf19bcaf85517d35032f5df5e44980eb975eef166980b450bc23dac355b042ecfaadfef363a375626d1137656b247e627a93514c9ee134bc4d5845b850c58f03d3ffce8305fb05fc6cbadee583650857b556e2410d3b665e8491509749f9d8c3ca3dd5a673c60d41c4b9b346e6a20c805fa8525e0243f0f9f56329d4e5f2c712ed6dc0fe22cd60e08e8d04b84fff74868e6b8edfd2e41eadbab03de8c2532072460987b59cb9a0986174ac4872eac8bf58e2c98ddd11835bf029df514b62c2dfaaadb2da4f35eed21c6c60a09601772d48c4b5b7e5c4a3f4d773d54b46f684eb6245f546a7f3bc0662e75acc799786ca3a2fbc439204ae51fa695708a24c7829ff712d0a8dffb408f610c884e5ad024cc5fae22ba1b66fe9701c2d8bb776d3ebe430ae48ceb83bb8ca629f7e81da44fd749c146a2baca74f444e80ecbfc9ca8d539d255447a874ccf7b607e511a387ebfb56e10d6df7dc298585d5fa644e0d693001dbf5b1d319a32b1e8c6eed99d97325a3ee6a9d6af004f6ad27ce2f1123b3ad153f777729346773fb36406bcce8da43dd2b0242e0f642b3931c21e4a78f1f2a0f91f52a0ef806e1940a1d86a5aa67cd65e4c0643d7ee1d376a0e1e25824412a78f3ef793dddf73023e1c1b0e66f67c01c7f8cc60171c80d636b593d6e656ee61169e7ede1712c587542b4d1334090f30c68520b9e1cd24b1b7f48170111b6e7d5e32910150fd148f14c596ae19b6d9b6b5c624b513ac05611e826c4ba4208c9f033c6d7deb73eb1342e402ca7ae9e431b5f0dfca102881f5f71aa8550aa0a12b473dd25a92b34cf70d4ff61509ba8f76ea40136cee162e7a256498aa62cf4c1087b95a825770ec7dc32d575566c52eadd84c1862ca01c852ceb1990f871e724d0c408280da7b80acdf957c407bb58b6e28d63649f49ee7a9a66f6e3b0bcf667f60856e3fc9c70229ae976e2332f4f9d26258f53cb8dae0e9556afc8c074c0e73d23e359c1b3c1b45b885277ad73ec74ef07dc8ff2d6ba9f3d891ad823a92dc3262d3e87373e6f330279d9aff8332e4e8389d8bb75ef707e16a3c97ac7ab5b465c167303b69ed332e844aac7e027b044848d9f6a3732ec9e73458e13150b99ea08dea5d3320724246131ac8208179fcc5a7b16ece2b0435c7746cfc3171858299ec8d05fbf785bdd16887184296199a54ff1d361c1073a6dabe0084e17a74d9b9d6fc5817d329bb5a15365678e44045fd5736bb8d8e176d363934bf873f988e42800583f5cc2536ae9693aef2db6f2f78dfde4f546b47e46baa24b628be92943a1ebe4d3e06d6a4f1e9bdb47289fc14b7a96516520cdf9d4820e01acdebf3795d3b35c1f8f4e6fc9c4a0f0e7bd4362fe5a096a9c3a8096caa16c6819188e318c12b615781ac30f0dd413e25896e1aba0fa0aca2b8b1a746e42126f6fefeaaa7cca380ed9c6aae23f2cf5ed7ee6e9d0410f0e245bd25b4e1b38b8450cc50a8e4b108d9a97aa6260d41abf79bd7e5b048c9980ef209b50e2483285c961ee0b94ba6caa8657283dc1fd19f00c1660b1cae8ce1bab80a531c3d7af2212f834d11c519c56b54eab8ed3aaa0fc896a03ca70135fcd873c9d03b12e1d70357055059dbe299629b493faa9bf5151d22d7d19eac425e4179503ab183b622fa343a42619edf9d8a7cad014837d80355e06fb1168c9ab3dc9d79f27069226b46dc3fa59ee82615554c0a293583e8710e1a90c7e7ee7c360fc92c8653461371bd5a4b1f130a62e142fc6f1bc66866a54bf494dac103df265721525eb28bc2fa3902f1571eb06511f3ad61a81dd59512e4cd1b229ba4d618107a3b835ef89c620878fa0120a1a8145bde441d68b3bd8131e0cdc444c4e1b9dc81d2a7a7a4a0c3b49132ff3a99740dd863335d2336767546273d90f2ed7b62d754728c90e4780344c2db60168782fb8b9c1b2b075b881dc021ebb0be6e6172975eef08d1eda7092a5eb9b11b90d1dcfe0dd4dd81da3317b05376ef759c40741e027c40a990b10751ed8093b13e71759a48dbe2857adca05cff5b508d0f851826952593f24bd05292b522dfc66c27ee3e19c1640ba232b6e6af8b9e89a8bbc33999199f348bdfa61965de53781e727c65662128c4ea13ede7dbf8887b80f1de5c19ca578b9c6898e50b6f00f7be2afcfc9af15d16f7d1579f531001210113511e80c7d02c343c7b3e612837409a156f4d9c185127b8ffbbe91cef28b4c7843c6c43d00db013f156ef144c20a34fc099c06bba1e2c1925a83df48e895e11eebb70bba194d4f969f145ae701c4c395c5cafcb8c806a43f138873ab28f82059b1349e0dddbf61486b9ef496e51c68a3a38178c340074ac4851e3e39e15d829dcc4de95756ca86ab5d69cade274cb107a94993502ccdd626d50fa5e25dc3a49f7632b36e8ea5dbd9b015d3acd41369abc96177c74e974ebecd296d3fdb5b21edc1aac077bab1e0b4c033a9fe389fe4d980164eebf49c04c2a2deef09aa89390ef836c99d8fed654d83a16010f70a58d2c4ca2ad5ebe8da470ba76ce30631df3face32149969a92f707fd70099d7f77cc6d8aac8eecb770d1d1e5ac4901c65923eec36a2f0d9618b05e9c01aa8da2d3783ca55b34499265ddc460b6546e04934b3c04b5349e1664066123a11cfaf0ece38fa816686694b09005c82ed9d73a831d5d1d60ab307e249bca2eb202135ad4181a6cb3a8e99dff4b2c30a3f3a5531d1f3a63076a3dcdceaeddedd58fbf65f9d40dfad9f1138daae2ad5a17110de9174365ef18619ad2049d52c80d892d3ea6e1331d32473439c1d5a44db3a1509d9857da26ebe8bf84a8faa094ac4182489c179b9d605cc9d07e90bcc92393525ca6ad041dc8418b88dc103515e340beb3e9f004a567f9fe2a77ae550e3e6e026c649aecd36ecf9e0cc7927bc69999357fa2cd76affd15e2d8c8c9fb1e0574a64c25385e20569ae1294ffca7807dc838424960339886c0e660342cc4e75a3a14d85aebe9378475a2bddde3413f90554accee0a03d3ce614aee44c148f662e3688f9596f2f471737d933788962e7b38481b0d4bdc2f784682df2a30f597a290142d694ed5b7f89acc0f274df6fc384cb42607314b9d273623d2e12c65a6bbb4111ed298a4da9ca07f6cb5c337dc6b7d27a28573a8ebd4ef9636d0feb1ec0e844ef2ad2b10fabba78152e7e626173bb634d31a179617f350e7dfb5a20225f2a6ae1dfab59c0c102e9c284e4ce07abff63f3900e1cfa3e13997414aa2b9a6178a9000eed11d2d3cea934c2ab23f76dedde196423a3d84c38cdc69c4f6d7c19352d5d95c0200dd855ebeede5c6da593b0bb80b3429268ca6f188d6dc66487ee0f452fb65ebd556d987b0ae13a2cd7114d113e09ba99f17d712090d48b3cfba6281b95af77f7ed8465af030b3dc76d9e7a00fec398e998b43f199fdbb27ba55eb19e84a8d28177c608e22cc65ed26ea1f66079435bb2204c8672995c82f695aa32fa78f68a894a48499a519452251dfd2ff3412f8ce44447121527ad93c93d8ae7f9962a821973c60c7feaa0bc360268acd49e511a805442ad5da22357165b5022906c62432c719380c0bf6c133a4d254ded666edebf4dbbdc10015c746228eb3183175ee26246df07f2ec6e1f6af00a7744a5340784a8e70d8030816dd9f24d9e1e00f95801422be05c829bcaac19f3bb561519916695e79de1fabdc423d9f64a9380b0c2495938114e33d6857d95d1e494d3546183e1621ae4e5ddb0eb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
