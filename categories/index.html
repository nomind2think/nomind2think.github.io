<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e558fd3b3f15241dd3aac428310f1b04407d689ff4a4b3f4094cb52f5df7893bdeaf815be88ef330f91a478992c437ed7d8ab2e36ebdc178eab4ef8e62605ff6c4cb836f447834f3ab638ab1fe58c2c9bf5ae4c672e079af0701435d2c45834c3231f5052b6a64ba53f2ed2b870fb1dbe53ba5075c613c62ad615a5b9a5c1ac5fe3f253a68531ee1af506dd701fc4753bba3d5c9c57d2923b81bf3b6bafc535c717ac97d44590c1826f31e783dd070a76fbe2041ade2964985958486438d7866afa0e0b6f64028cffe99b7340932700b93ae0848dc6dbf447d8c055e92ec431776aa0e65efa41e5003cc7858ac275dfa446a22550f8920c63d072316ccae2d41aa504aee41ba0e570a30d337196e3afb3593e6d81de296d2a03a4e6fb48b1b945198564c3d62d23fc04b8ab0cc36c403b5ffae6d76a9bed9dc7e5a8bfac19948c85330eb9dff01c70eec2e74c09616251edd68e82956cd3a2ddc5e3a8f0195f687a1ab94acfa6d1735b908e06e4ff769a2e4abb65f24e4899fbade24e9aa472c4afceb5d170ca2c8fa5e8c7b3d9b56dd7d4c2e081747929098b8eaf966b493d47564480d8a5a083be582eeb5c40d0a18d6d039eb8f2cf1ffe2f4f8eb4b0d7515c33fa8cf5e0d3cc9606c8a87f29b1e996d50420b1edc35350bcde25873571607b968957f44b1ab57aa725402c3587c06b5d1219de78ccb0b3faf2fa0b65ca48c82f3c52f188af364944ad71885a32581d20617351cb52f83ea665064163e8a911b4bf1b5e2911e4ea1a956d45c4bc3c42810a0d4afaf876937e3ad0c9761dcb87f98ef93704204ee9bbe211d708cd52dd67ab3e34eaddc0e8de6e1c91004589c0fc6dfda6c85fdb9e3e5b36f748cd6c5e8a54c7f01d87f6f4cb8e40787b23d6358c36e18a0884f184d1963f8d58aa6911d9bfac47fc7628562b080e8136f69c890e26570fe0acf795e641971fd81a5034bf7b34523182fb2032f4e3071c79d1c277266bb25595e232853067b543904709e58143e95b5cbac6a79aeee934c1c5ab6a9e75c05b91210c3fea876d85be70ef4e8a41d61e7d9d1b50aca2918a6782243523f83852ba27810d1906a8f649a14287f28c75ec666c8d29b4f94b03403388dbb89a62a70423c74db60029cd6edb4fdf80055121a49dc70080968519ccdc137ef0ccf41da60002b99b42a7c705ee60a07dc97bdbbb2b484eac5464a12e3fd49a16635bbd67b5928711069befc5171db1a849099943685be5a101d489a05b10c46808538b022e5c93a369455cca1b3905c76cc804fed7d5945625cf95e9b4dbd682d7999fbc20a8ba996de51ebfab8b633ad3b22350aa14d0758c25d72d3f35d3060bca0be64959e96d3776d34f4d3a72ca9ea06a2cde32f4107ee3098ececa775733152eeb2d59ecef427bd423803d4a737a842d6f932013c63504528584f92cc0f6f56bf4bc533660f5a8c44c3a01ebf3e93c184e415a7cfedd45b2df65a0a2cb725076ec19b179fa9bd1f0d9077168287fe4eff2c1b9cea7031be13e0bb90d40dec31f70332431d18ed96179bce205c3062227dd011e64e854c450378bf503df5925ed89af1a51ca312d466584e193937fb442e48b00535477f503a124d1fdeb23df694ec4037ac817d12de27aadf1ef2ed6b2639e625b02fac8d4f9de7247bfe64d3451a059683adc318617e9fac0b1e0d170270e5e21269fd96e370bf63a8ad4308e1004d25a2d230a679815027fbf72f46be130cde32d55d33388a56501890b24dc7319bb23fa42bd7980120203666977846602aa3b70434da4780bcf46f6883689e5914fbfbb44bff76fb6059ed79b72f3cf0bcdb75d87250c2c5e76b535946835779e431441f96b42244201fcea4b689bd60d027cd3bd8dd7835c9b3591f4924c819d2801efc1903bb23f567607e2204b0c729b4ffc69412cb284deba27b658d1d089377f58b9c69368d732557a503d0dbab89f51e667e71464a8d143cf308aea08cd35296e3f7a75c491b9156d03517a563ccf7fa3bc4a217f1a4c956c06297b91f4139b84b187d525c05701443b5a92d8988e6e493a214325926da356e738adbb3c2c48385010198bfa9311551890afbb4bcbf958216324c521fcbbb4577df3a21429c0a681cd48ec914f7f945eb70ec111aaba9911ac216f571dfb9a3cfa584c74298c4c4722a0ea18fff164ef805f1d92ac5a913b47d664388064dbf9d9f1866b0df6cbbf3d07c55b9a1fe5183d2ef277a68bd2b4d056894ea16606d0137c8d1d3fa20367f236e4f465ce6a959bdc29535eca6a186ccf4ed8fecc0fe97c6a5fc6fbe69c0bd7c03b7359a9b70591ed7fd5bb9a0b7c0e7bf2c9a483dc0a85138d9b7a4e648f86ed641363cbec425a949257c167b594fd5f643c40eb1dc73790943425fd43a79b9f30754129545030c87d385e69c421a9bb44cd0f858d33246e41d09673084062fcfeb7b11df88b8dd1200fdb2a3e2e88764944f386025699174e34ff8cec445e0ddb4e3407fec10c75ef854796ab74fc8d3901e6b1556467b52d66a46b61864dc5d054c19184af00b569e95bc07fe25e779a8ba10bfa2407e6fbf750891a3634ed426c56b8ff95b23f02faa55ffda41618e8b821c0d27c972fc4c7f47653367253424c8796b6feef48e1dfb1e492653bb459151789fbcf041bec964ae6bceb05ed3728b690d8b34709bb7a21f10a73aba65932f01755a02b1383951ee19d10bb425958c378e31bb115eaef909c02f2cc0446acdb37c763ba2f90db3961747957e4489c254819db51d9ba4dfec2a0fba724cab769515613b07c8886efb66cfbe5f797f084783f3c549b18ecbc646db4da97de82a21fe14eef0e6c551e7e4fa8ef94ffb9bc3cb33230e1d6f5e2998d3d50a7444b41f6b65485096e46c859811c809f3252045cf0c426b2fc9a263860c686e8883ce43a60e6997837b7b4e94f3d330849e1be47125f01a7eaa0950f951aaed8e9eaa75201d481a49ff8ef1d1b86041b537e1cc653cf56ecdd6cae642ee2b599dc73cdd94ba4b1fd6fa444f11084e3edd55806a112216ad9dd015181b2fce96539cc662845f4e462334acc2d58a1f5ace010c3d0c894b95c2d6ace3772105703fa89139b8539ccd38ed425c3f5ffa11b00f4b5a970e6777a3b0ab71a03872985c0e34c1a0f635e97e0caad68f5278c4e813bd4ca2da51bead61343d44464cc378d342b6ce21e18fd3aceb11f8d99878c13a25362b1b79b6443522606ed62f472ccf974feb45b83b797e815668bee1a8ef28ef373d013eba31e39e6e8f6c75ecc7d9c48c5137773d86a08d17274fdf9167b7b3bbfad650d479e71cc9e3df392db56f05cac671b9ecab91801fb0fc366b73d8e9593b2de8a10a29ffebad72aa79a92cedc9ac318d9abf99546d8721777b27a8ec06513821b155142068ef2f29a86136ce948da2f6822abc39b4f8681aa1cb22d044f8fe6cf7ed5324d2595b5fe852b222c1563ca9ea0738d728a3409bc13bf7388979ac0e7c74af1452fa8eb8527a7fbd4a9ff86f15cfdbaa9a7a6424759985b83305a7a8f30eaeaf1fa1895bd2f249deae00bf1eada5fb5da62c4094df6caa36f7d6d0039bafae208724bc14ed5edf96f7db61b8a7055290de30cdd4838873efe7e0704e88157f387cea956bf422e1dbd4ded91d971b13d748d0a1752b9be4d3cbb10f263ef30ee00dcf265c6026e4c5f3275396d55ea10352d27eac79b743f609c8ab6135d8c2c4af204fa51f8bae0f4bfb60c034636d7d87401a871c02ffde5cd4bd092c9727cfbd21c25bf4d278bfbeddaee72ef5fde351c7937947f9e295ecedf1c999d42a04b94bfa84b645a9dcda4dfcfe7d2be80a414618446868ba6130fff06d20f71d04fcd50acc5f61d53d095eb3d49d44643aa59f315638d9af83bbf09661efa4f048d6bc29a5bce023e04cfc50761388aa1eac52670f0cecbf259d04b2a29a5915a88da9cf18ec5eeac82b70805f372d9126fd4a5f4ba43e2434034633a5fdf84cf98d59318ad8d962398bb8f1003718da3c09ff650049632e3fd16c205840e501173a3c9a6b02ff142ed8f0ae023386bf5b3e2f7b2b1ab5b06030c339b37c3be896a47abf9673be2ae89080a600867fb6a51e7afa5eb1f995d2d1daeaac65855fb9a81dec44afd3e18cabb3800c57ccfde66bb28af1f263a5125fdb0f212344157595fb022a7317f0f4c0c79b51aa5a601550e4103be6aaf3ccf35a67cd8e0a15568e367eecd641926b206baf98644f5f17bf58b208e9b3da02e20ad2dea98e8e659d3e36da24447bbcf75a8838e4b22fd79c6f68582fbcab3b917bfdad04461df5dd98205e74b50899cec1aca9553837fdb76a2b93c8816a14a786d332a75079dcd19fd5ec9ff61de2277d2f1e777f251f088349dc308db7c950ca740c5c0b75ee7210a3637707f8bec2c8ddb5b0f778b75989a34010d771b61594cbd3234cb4aedc7ce3966bdbeb43b9fedb07e2bebb93ca78b161d933904c2c4b1b9d671f99d39c68ca1971f4bf5c49fd2da34de9bc8111a51baa541b059262adf158bb958fb6edfe7ae0ee68c546e443ba714287fb780a6f4c341ddb6d5b8c2dacde037e7c3701ae74ce708c71f0ab1ab050b7e194b700d9e0a3c0d98d572017a4486ff7cbf00dda74817979da68cdab4fa12cbdb5a42893b92559852c4c2d5a5c3eae94b54d774c1e2ce2ef92b40113a54313a221b50b6e0696a3f73c2985d40f18b73b0da18afbcc38cca7e9492645c619dc4e218b47da8b000a588d2597658edbc909812a1c2b90d1cf61a91f0bf76aeef62f8fe5e928ffb30ab8578e6a246b40b09452d4d8ca4dc26200591a2318075e44f1eda2d05c3579db0e74f0051092043d1e840e8494ce96f761aa0665c9307081dc671bca25492db67b0d9f2daaefb23a6c2e9d583fcc1f2c7b94f094f460747f14b2071365ea3173d5d8b1cbd79d21898e45acbd60c6bd100ff899db548435421366f798e8f58f769fe53d6c64eb04898084cc003426cc583ebe15a985f771eedcb8e918c13191cd0fee667fc5dd1948ee564556100b2dd92411df69bcf8bf65f4c0e11ca1d0a742f6215c268ae9333d78d46dbe2c1db67db7e4dff2a1046a636ff57603383bc8c96439a23fe26121522bff8c637ae46b3c4560e90303d535aabebb35e7455be17faceedf7ee490a4f473fa6ee15109b5635d31b5ec5594018336c5fc1213c0c7538f515ce54ff5d49b20623b533b096d0f1668309b8454661dae7be98a3dbb323301f4f11ee03d4b78afb8dd6987547ac2d4301c26b41637e1b5708e90bbbed9f01fd3e2695cf34e71f40c2fd7476e57337146cd488ae97fd7925c9c6c2ce0cad3472cf130746e7b17f062f9cb2d6fc4eed8d7d1c9903e323cc740b08a4c9b271ca169bdf673ec969c3321bd570b346a301dbcc2c0a897065f2d4e8d7e0b37a5a5b34f1b2a8134c56ad2113c216aa74e18879224499085557d72fedbd712154fb40a455d89b24a2da0bc190ea4060be9bf4fb32fdba977416e0780e61b9a9b76ed61c9b13b7bc73438675847d296ec87cfc687014664e25506c636ce295fc0d25481f5988e598da08ae0bfd34477957432673f2fd68fd2422e8f8bcde65263a021891d6e27d3cd9a09b020449274b13b3811f38581aa244dcc26f5fe2772fc3c653be27fc2e7c99a7a7a246f86cb82d70668b1105cfea99acefb0333a274a4e79b4dc50f2b9ddb75b8beb2c21b981cc443ef26d7d6a921ec9e7abe16af9a40782500c4028cd68ff4b8bc1e313737f6b2bb81fe319ac3baec4802b9996185e4278d85b84299a6cd1ed053b0c8aed86ea8417314f72e05c1f45e75739a01993e53ba3edb5fb0901f135289e5da257f4b61bf9a83d0b9482f27a404673c2a7acb62df94a6e8fd93de89f572a6ab5aa92464a87264ea8564c5cdb9da96198ddf340de7a9d79b7aebc62bb8765b6e844abb06fe02a9094afb6aab4a326b89ad6beb7fb6b7619da6e946a0eeb48e13cc2f91b54966c4147879be7ede07e6b93584b6fb1f7cde0f39d093affca0dddf4567f81d87762281aa4a46b361fee54324347fc128e757ae3c963ebc02fdf394e8581430053b78af2008b55777da512cc4b085d484852b51f0465d6c04d9cefc65d8df77f8b1cc9e16a43100b9e21da41551212bab2e1ab238800abf3e419b50332e86fb85394bd195ee39e4ee92c9c1cf4ac23c2c8968b29e8031cef856490fe221d3107551d395aad5e8b9307189e27cebd62a02fc3f8b25ba0399691834057449664f1c5e7532aaecdd9a40c80b8b96d53db91112aa24aac1925052403d061413fa61ec9c7b2e635eeb996b0c770409667ac71cf6f07ea156a405f5cc8cb214529cc3edea3521989566b6aca82fd3d03bdf8abc16c220d71984730e4588f17399c4ad7e6f61d6fecb5bb2fc5ce6a566def9c78eb55af2f8161e2f8359d6cf096b5c69733d867f8e5d4cf784b3e7cd784feb3f78320e63a1b4ddf00ee6dcf327fb3f0d4c09676be52207a451ca4e2ea7e73e451a8dded85267522f3110fc277389de5bdf2cd8f93acc0e1fd67029a0ebada2b15cb0cfb6889c3a22578b4497dd35e89c7bcc100a803496232d9731e8a394690ea84f329c45b53cea82aaa8b5f50b6aa5887f31c5bd9e0183561823a9f8f0f2ea5b3f2a26e93773e17b169260abeef951e50841f964460bcfe09cf4cccac68e39ed336d8a13907abcbf34fc3c30480273a616ad94183419b3b697149051b2d8859bb95e52261586c8b57bf060d94d2c19a954c18b7355475a307050e1a435022579ccee2c4a8ea30a7d8607e4d5d2eac0278c66cbe217d0bb7d02db3681fd9967502e8d7d306f083fe6340f38fc52c11ab3c20c161b5a73d4fa1bb67565e86ef4557b10e6ab440a0afacde95b3fbceed30f66392af3f629511b36125f5281eb2a51720443761a761fe6adc9505fb46e268275eca2d006bdc5d0c90073e4850a848eb017fe09f1d69dea53417d33430d9dc0afd887c994a93ccb3904cbb553cf06221b94b5198c0024aaa9de2d8a5df58e126d02553afae192c8dfdf12c632e359d6a85ccbbaf799237eb3762ff7788d5331976f43dc822766a981cdea3e56d8e7da9b7793ae3d35d11b18c07a46a8925cb9faee4b11a08aaf56051a3030f1c68760343ded186a3d64a476c59386b80ceb555e999bdf3373045f1a167f5807d99d6a4cad4473a34c39049e9f607808e7ba71936338b1d6abe0d8acc14adf2b8cdf6441d0a34d009eec29f61e1e49d7bdc92acc1e628f7c20dd96644d0b5335ea0364032ae19777c95bcb54ba43483b76b6ed3e337da9ee54967d668e77dc859293314edd15aeb196d27b7d2b24a2a0a666997aee756f315293014439d0253f01f7b14b67dff7adb4a1d195843253fc730e9e3613df8bc8bb8bd477c8e9540f865d7ca5300fbfc1235e066820ad0b79a233004d0b92dac28ed11f3491b2c508140963b5f100886ba6d42188c1437fd2dbb39e59c71c70addaa80d6d20a276a9b6acaa6487f0bf7d3ed3299fd6c7f5122c4a3aa85873ca68dfceefff571c3b5efa2a62aa782b541f11774bdce43f3d81ca6ab0f3c59e4743aeb6a7e4b7629fd85efb8aa5f05d75c460a9d14b069cfc91bbd323075a4611049b6cd652803009bd29eda364a3e4bba2c4a54047b150a1f0ef2082b62c5de625f959c56925ded57cec55672761bca670c42bdc99eddb0f3bd2511f92d55749e2cb08cef4983c3d6a1a0ec52c4592f38a616856c12d7ac81ea807e5e59bf6035d08787ddd89126923c5be36a56bbe02854460c6db94d664b173fb9fc82e7ee09f1352adabf8469a86dbbc9b0317140edfe681220ed37d879a3edb14a7da1683c76050d96223e36f7e576f72b567c6b85cbe2698987f04375613d7960c727ac66bf6fc66cb6c3b088f6e220e1d2ac02d382436314ae46a7565c9e5a0e544d54fb9934677852f845dad1869c573206fa9e791c79841a4664b7c3915486fe49444b826003371c0d2160ca2a9ce100cd87fecb07720919795b96bc57dc5cac8cc03b7b5588cde84db9d27bf77dcecea0247d8e28ec7c6002e7bb4f0144eea93dfa393513f3b6c95b4341a68e21154623121e19971b4f560d1d9078745f274a438514006592d41efc8ddf261aa1c50b7e77176bf74395b9120670f06f25c2fac2890ed4502d96856a7a51122014dcc91a70cbc3e11d3165fa2252bb8ac9e5e16038c08f01cbc1d42b0a183aa22fc08787d33a505c317215e2a62f4a2cffd92cb0bf090ffb61b008ce211384058a570de199321e797e65b231796d837bce4e92c6171a3bd1671cde74bd5f1f7b4bddf2dd6a4f97be08676bc9c14731820b7e04044f5cc00623c34d6a1fc83d149c15bcbf1d6ef9efe66854f311f18ce9a7e6ad911a3db8dff5989a2287a4067db0ff9cf728b633a95b455b83da7e6cf779205e417d8e5be871be5697f64ac04a70136acade9289bfd5d263fe7630cadce8487362d05bafad326df1c2044780a4aac93c499afe7bf0182302778d3c2e1fdbde93e885565d48de42339e1848c2e5772f996ba75d4982f214ba39a7faa0f0621ccc61fc614bf771bc8a3e1a666783f365475a49e346de1e16d21020ef40cdcbaccb742a09a938b10e8b9784ea230cbd835e8390a7d37948e3fc285e3d42e5344c0fbaa275b833a20f9606063b5b6f7824b122a1c9b215bf60ff970e4398685be64e30e2a55ef078a0cd793a3fc455773a01db6285c1fbba1ef59831cf6d7e2615e752856697cc026106ce8a1570b609129adca8f86962412f72a2c1d48838973a8d044234f8f0fb9fc31d285460927434262de190f870f45f2088889ea7a85a6bf3e706fcf93a0dd4cdf59c2a620b62c82114b9e72afb24eb00c7ab8d8f30bbaae9f7ab08e4b293fef67147e770b32dcbe6ce5c494c498d26fc1a5836428e436fcc392f96f66d10a155132dfab5188144bd92d564b11780f69471fbc031ac1837c5557c640a7fa60ad33badba71ce8fb9179c160021c2bbfbd10e47670d705be68d90d8384604be2e559bd54e0fc620a189770a0af3c03e17fb301883b8fa98adb527779cad659bc077bfd42670e264bce286cd55feb2e012b9d2183377cd80f62f6cb4debd83390fe39a8e994382c5123db413811546fa3736e3fbf4becc4c7fa64b29b69c0b59468eda1e5a643cec96cb8c0876618c65201e3b2c39f8d50c27a129f09db18698e255f01e43e80f5db0d074688312aa609c1be27f61df338af7766da4896becf25cf9a15e9d3da5bf3b24326045ddfc4c0fc6bee683a36a0dc5d777ad2064a7689b0ee0b29f867e074ec40ed6ff69a77007a9856de9ef9b7175dc8e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
