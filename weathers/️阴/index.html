<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f5c7b0f76ff35863b9231d35d8adde9bc8cbc2ae0299d57d2eec9443b50f9a3f37c4c6c311f2c25c0470b593dffd5e72866b4f6903f6c62fd9032df84bd7fb7ce0662573aea18b781a56ae89f79c49ee63743f29ddea9bfeac4283cf2efd25943e2077daad8d759fc7f54483a4f20dad47c386c1d382580d1b483f67339587cb9cca4ce1ccc178e70eeb9a9f2884905d0ae5a30f94e00fbb170081c8cc837eed7b86aaba698bed53af5d83cb1822d6917523ae65c67a49953dccbc743a5fd800e651a2757ffce3d4983e02dbc46a021cdf928b12e75dfd2a61ff32b55f004ccc1dbe21d99911a6876f1a7b6eaee43646e28ddeb4aefd842e2ca750df8f483a17d95b7ec7b5bfa4d4819ffb06689a0d4abeabf2907fb9cc8c8b4e62c79d5280a5e16797f9e8adf8bac39c5318bc2266b2840f1731d6fb4af3171a2a79157129908d604e3afb28b1a9d334fd1e4bfa4c3965af30f3946a1733a04be7154085550fe8595be1a7ed78d08dab6cd7b3a8bd77350796981341513047255c515d564ba056c57164e959f2253a7494ef25fe0f6ce4fb7367fd5266805cc7a933e21438605e1e1315b3a4b89e2d27252d7a0bbf17304d4cd814ca43326bf57aaca89f8bb418a7a4619e70b9eb62bad63c32bf1556ce2066cbb131463a44721d83addaa8ebc3102f00417255f071811c93ac5f53d9f9a24dc3d2dc0df267019c451f636c85a4e36cf58a371642ab01a97a7fa8edff0a5a64060e18886fcd8e0ba8df4f80337553ec8dfb21d10c2b06f9c2394d913fd1cfeafba41c4a3067d1dc4c1cf0adf91a5c061b7396dacebff26d9b690712534d24d2c4c2a9eed353b1a68af7d0b197eca7b5856a91293712de53b5b1584f1f858239046ef64d51e3b1aae5da4090f95ceff16214b34d1847595d7e3528134dd7d779043ad9550fde6fd4d20187a66b96180636382226d62d6d5064d7bbe5410fe747f1a3dfea0f9f6bc9838cd57bcdb120281cce2c8ccf83814bfb18ef6314a05e5a5c2dfd526af90179dd5215c810827e1feaee5c14dcb00de9b8b965bdcf6c9cfe66a5917714937c27df222e73fe9d8951cb71fe92e57ad8e4565619b8fb3a7570d7ae974b331a49aa6840eb6e7e280ce551e56b268cf54edc1540453974387e64b6ff7d959ae4fb40bf378082d9f4782d0b3577f12e1e9eed7924b48ac5fb86ba1374288f37be52a8d48e4b44052150026411573d1d2a06667b15af5013bfcbce140d964af691a9e089e86a6eebe721cbab000f0dbd776822848fdaee1d7c188fa8abf2afef9a7f7be8e9f80830029f4a5cddf0dfef7c06885f14140583993d693c725ccf4fd9d87308a05e52564b972a857c7dad5dd1a97b4dc426e26086f4547643e56605f8310f412a69695b632a41c393d8ca30d35470ca1291c1bbdd9a67de39b504f3b526a39aa8f8a74f341d39a4f0ca6d8fb46da7163e385ffcee8ac41c121d886697249f6e49c6ec613f6bfb352ee0565e6b05e577f3bdd6eadf456b23ed204a6fc096e3cb1af949e0bd487f2483cc8b3812b3dc9a3bc423724206638dbb0516bcf82fe41ea6c604feed7fcd7f80207e7a12e9e6978636c6e0a6555f45fcb1974f37f0dac308e4378ed6c5cf8fd3a608d73d1d0abc839d0b35d41de0ea45fe5e734490dce9919c652ae808dfcf164e62a1787ffc9dd904a3fe86ddc9d0bd804e9ff0f16aa63b22d1d62717f2f05b1bb7410a5d184516febf823f73100c8ae87d5415486c1bc4d23218043e12b7f5ffa1d8174f5c3f0d85a61c8fc566224cc33029cea2c6cb8d1a7edb58119807a5fc619dd3ce00a58fd7b8df8f0a99ab4c9a06fc6d9b1d5e7a315f2e2113765292221f8535755e71c20c4301b1d7c5dc6eec1029278200e1dae80c423c1484bb913ec20b5f2e95edc06997746e134cc933ebf3f179ffbb07541bc80934cf2f20992685c8f5b1fda9316629bd696063aabe22a2a38353096cda0f0e19c012ee873c687e6dcdfb847246018a6edc3931f9638f202ab08ea88d0ac1840631ee0209db6e45372364f5648b8c5c4d4c78b08eed0a5bdc58b2d440c40871ed832fba1e4bb841394194e678b0e30babbf2911d826b9d0335e9699dc70b30c9ee32e9f437341b980231de3fcd5b64111dca7ea96c12c8316c357ced77d07b7ac7f9c729d8ca1020bb9a0e224ddcb486fae6fe819dc995ae39f8d22f73dfe3df0ba509f209a8e8f14f2a912cbf7c07e2c289ad54090def60a6d4870d53e44ef387f72749f56bea71fe1089a4aa4b143f0f611467d24073857b84d61dd7527c943abc16df071725be5fb2213399bf999f3f14fca861045de6baf4e24c67c6a81e18bde80081891724ee240406535a2ca2f2f3ec53d69bf2e7f0cdc91eaf7bbbb960449e46695634ddb8a1fbcd33450067f2f828d0109239dc26bf43d75333b504691f9cfe0ef0985f11a4e9884885d1df26800a2ce87325249421aab47c7354a99e7ca20f8133da1c29e86e3007fcb86c34f3ce234eb8932a3b3bcb5b9db1005cbf95862eb405ea2f04ca49474fe0a98f916f5cf14a0c413fa827d9de9965df6ffcef15706a2f319388276d5723a2580090979c54d43294cf1d2029835f47dce57f0694de3892726fa83980431b49a91e46682975a54ea3976156f19c383c5a3cbb2a415623134281c6a2b85aca3eb86603c01c3a1729213750e186612954f2ca2770b39db17ed3cf5ec3456d45afa90a957ee9aec397d886332a4681a53f46ad6dc12473cd2eb5bb538aa7f403369389ec4843e4ee48e223bc097118777dd87bce405a7eb80dc83a4e293dd7c4d541af17fa24287d0f24700790526af557f78466b5311360bcdf6ad5f3d1b3404235247cfdd0493d4b9fd59bf621363b2de9ea2d30d5e677b6f5b7cbda52b7ab85d3b28e87e9900c19a6261c77238df62d3a0171ebebec8cc19495d7e18a006c478460868d4bcede7a0807e32e44787080fe60cf9b819db93c6e91867b621102ce7c34a5303efeeae97da6003335da9087f23d70a099d8277cfa0d9abaefe88d9d22879d4ff25f974f408150c539d6495d6289e6466ec44167c85740d394917e716c1c2950fa1ab7cd352797f92d6007ac2042c6ef1ba5a24168862f3417b2f3f80e93891d7401a018a18100d3336b804739cd734bd6ead7759c1264b690e256ccf796ffc81dedc4a4f8ee889da594ac5d2081b90bceb24b6bd660050cffc4d1cc329895956f6fb984816839c39ae36f5bf53bcb3dc9dbdca81191ce3bb87d79b81a273d84b4940d260aec5d14fabbd766761c333a9f0a6bb9c0c8093f3a72429f5024b1620e568b940f60102da2aa1188ac3c29d921d1aed2c86a9486cf7dc4400df784d22e06977ac6d4ce98e11cf02c700317c697ea1961b833b27deb8f8572718a5ce28cb343c0444fcc5fbffc1699bf6fd6300461b9cf368da1a99a00d32fbc1617d6f2e03fcf7d6b12bf1f7145e709b4498e28b6932dd06091cfa6784577157783d022f0f74a49c717df6f3d1727fad441eda7b57819abd3cec6e6d4963e48ea698c50dbecdfc4237d599e807bf9a1a9e634da302d67efc4a4d8ce2a6b1325bb843f7f6b44f5de046fa3c04e5fc4cf1da5a58508ce34fcd47540f7b851b12d5c426448bb1383f72fd8d15d9110a38d5845b89f3a49daffaed18ebecd6bae18215ac9a131ff8fe1e5d8ec2b4defe3ba3b5dd81ccb851bea3b9f754d2c140f02863fce15c1f4c0c92d25404ac66ccf4e8d836bbc7ecbcb05a5fa7f62f87c933b861dd311b28e50e52c92532d19e95b1ad70777309f003094dac0c1d406aaa09e8df21f6c6ae13d158006c3c1ee0e4616cb2c9ab1432dbf15ffdcc7927522e91007ddf7e4caab21ea9e416f35b86cf784ede458c5522e2bd15571cd3ac77c8727df37c4aa421366d46e940b201fbb042c248ec47997577d270fa788464124df68f58c41e9b34b0b9ae7acf5daaca9621025ee1ebdc0e7e5f731cd8d68ab95cb7cf9316d5bb8e0829af12aa8a6243897d61035b65dc548394766842b35ac50449c82747e6f57cbaa2e492a6e631b0b3ddeaede140679cb6a69a69c7e00dc2d34659c43177fcf5e738603cff7dff74d1faba8082c3f07453ff6c759151f3e54be3cf1bb1ce59b1466cc199bb50d5bbdaee453b59a7dd99ae2de40613920238a715dd9ae2b2be54ef1678e804295747f03eaf3b376747f1dc588e99fb7cc412ee0dc44fa9707387ecce2a99221168df351f3f456d702cb6204aa0c632998b9db2a0c4567d08fa897613ffcccab534a82efcbe4fd98c222b0241863d320f8ed660caa6b9cf35f2d9ba160d45b1412b55ea5f1020aa681e524620398c8366abf5add9891ee1b81495bcbf41fffd575529da681b80ea92b0b55e83eda59aff7c29b7bcddbe35dff5287e2d67a911ef3653089a3788467d99446004df77ab5cec146fbedd1de77f4695220691ccb3a1659e0e45cb63992d184c900aadcd47e6032f3cfce7dd3eab58d26160c886c30dca74777ab89f33cdb707dbcfadf00f0718ed3da2d15ff93495f81e7c85b98ac6ecac6c02e16410e0390a39774a762fffbbf87067d41f20a37c759a371d6c6cde5fb9698d45ba964c0ca69592ea038de825fb913399d1047543dade306453c0c6a47a2d3716a0b3a646b8bd2d6ef701a1df1710c8a77f8e15ed6f6ae5749f40d5476d5c78deaae6f27d749f5af85fa07bb8af4c3fc3907fa7b2efce61044b1cf2737703ee379e271ec9379fe6908d39f694d1e21e5e7644e74bad3a0a9dc92b3ee85fc0898abd675004626f36b69ac10e3b2a29563111a75b010abeb4b418aa547965fbd8b33b48321f6a19ec329ca5b77644cbb7568ee9de1f221c36b824c25bc44e49d7d796ab6bd1b343957dd49946bdb16806483a8e631dd647153728013c5d377f3746d016480e69d929d0b512830df11ecdf30882db583deeb64736de300b362978dff419c286ef65419686de9d42f790c22768088a93b34364630caaaca4bac0746d15c3527bdbeef2b74d695522c713baa3d692fcbc0bd7d413601d402771b7bed4ac9fda22afa90d4b2c90bda6813d7ddf1a6d9c6fdd34858714b7e8838656f40e8c2c4d9f847aae5049f37d3c62aefe7038acef0d6679ad7c74057d6a516f1270609115d6b8426d19e36cf349beb330a3c3cb210944d662576af5a05d92146080e1eab706b167bd38b64605d72397e528cc1099349f607a565fef8651c81e6c95eb5036c61b139e831e173334a822cb6768217abcc642be35cbde90eba8bb690ce9121a4aa65133c1c726ad8a7e3cc789e53fccc4465a6ab7faf32217cad9ede1d54ff8017af5aeb521d5d93eda922f7af6d00f30f8c62a8afd20fbaf8c1063472b937f4d2946d6e550e4d1314506aeb8e0098ebfecf1a80ed2bc48dcd41ea6409e3708b7f130385e3b1c7138462cc398a9412266764ade6300406c03e3b0c393f5ef74cecd3b9c49b3b93815436667a7ff004beda1414e912f20e2a628839263312210aca7d2ff6547de8bd3e3695c4f5f8a8ade879f271a6cf3d93de4c5e7bebea4f9077cc9cfd767d970a98932be28c879c11e171c6be737d95c9b1b9eaff4d62009e6946f0d878545e6279d00583e154747815f5ddf2f442de3b8174260edbe97a3c46d559d9c4d8f39caf7810b1f4ccd7ec3aaa8dec56969228c868d8f55fdcd60475d8692eec681f364b98ae15acf37ff9fbf930f748909bff88b17cd10a72c508224de9e8aaaf006b442e667dbdb492e0ad8e260f830bd0e1a6c52ebb568a7ee757f742da21f86be41a9da4ef9e191d24733747b1cce74106009e69dcc76fe7742e177705a40a43f2b362cdbce1c467883a5ba39b53856ca3d9a7e6ab9e39d1cbaff8e323a8fcb3ec50a0c873cc338452e757971b1d4bbccf3c0d5e29a3640128984383524797323f874cab9c379a0c20877a58ab9043a8ef7cdec8774c289ea9aeb19485911e577ec80d769dcd236b6d32d35aa5ab12db09397f9c88eef681f015f5c9e8ec796f1e66f0dcecb57251ee8cc7391cb4acc3c88ca1d936e392e68df5e66b9b6a0fe11520b768620b54dc42308f8ead47d2d21d265dda267fc6601e315dcfc531e22ef3de5638baecb32e58ff4e9445e5a8f6c996469e8d371d8b822395d232618087420f96f4a1c8431ca489a79032841058fac4b3556061eec9bd8ac4fb9df559266cd06c5ede0b4d2e7eb30a0a590520ec7bae5f3f0d4c49e9ed6eb76bcc8d202a6c78eec65ea71677eadab5dc9e79925f1d5707b72e871572dfd3cffca7cf1f53c03756179f8e703b423e0efe91277caa7a9454d680661eb1c2dd081b18607bc44ee1a0507c6336a15bc6643a21a5efaae0a16a13f734fd5c4cffee57a7dba49ef3092cac26020bc576c935ce27ec7eb4516554706ebf255e1f04e8b5ff999b558461b3652d65f1604a596ef6a34f66b90291dacf0aa2bc598f37b8e239b63b362e231596d6b9904648e79dcf300fc4ca9c2109fc73e35030ec1d4ca75cb5a56c606e14d4f2967fead895ff68d4c081a4f77ab860ce84770732791f5e82083055db6e9b21dcca6670db44af0bd87d272a89ad2fbed1202604a913d1823727227ce16d9b3edd5e977440f7b8f130e7d8bf0c6c77eb8733075d841667bffa6c45155a44eb242cc943dbc2481f9da39cbab4f2a1bbb41a7239f8dbbe2f2ef4cbbe94228184903b08a4d1b106f7e29e43a4ec477365d15a6618c4ee1e6b18fc9ad10877f7e5535759fff12920b43753a45974a40ad5c28096b4e6b8bb8caf6787e10ae269eacde65a0e03bb77e41576ded08c675ca8a111c9864a0a79a13285754b2ad0682c1dd6f52476c6ef0213190eb730c1fe99003fb01116b45c881090a61bb0336b7386239e9faf15276b1dd491bb6cd4036757006a4dafd23a63d2a6486a9a9cefdf200a7ead318146891fa104fc49ddf14235ac7fc06d80326f80ed396618b4c9754bcf51db4609339f0f4e3ce286ddf19bf2cb47a95abb00b4fe9913640cc5f922c47d2ce7c8028ed4435a1f9eef1779db6fdc71177f54c531afd939de411ddbe1f928c287373c46be1950b7118d00aca969547a5738129084526c69c8f3ae7714391b4a9dddb74e3bb2aeed109750eb026490138e9889ac7b539f1511e2d068c8e397cf8c955057db9cf3dd0cb1cc0790f453ed852e2ed409acdc6a158772619324368f3bfa98972c8b6845d7f04fedc06aaae1f4e16c7c777bfd72c1465693ed17de16efe7c99ca84c3543d303f6d7ef67647c20bdb7a62cf5e84e348cfda46ba4796b0bb512e70f5bd072405a69d2c41f73f93040d27a54524f2ba1024e725f8eb0ef886917e721157142189824bd4ea293a88800ce2d2970a76d0827930bea543dd9cc280c44366675d1109fb8a75e93abb6acd72e23a8a4835128479d9afe14c48b2668856ecb0ceda46942e08ae49729ebf2a0b308f27f0c73b2802a3b6b4f1b5d86476729dc86b7a7107339e37d64ab98d785fdf277d37b526fb82dc55ce1d842c806533d766feed76b3c2586077ae62236c9b3f497a480f786bd4fc103c01e423ce0db520707c4cef1f686c523741acc9bfc637e87de6e46664c7304ea62e5733978a63bb1f8032a33417567c6637aa45e0bb76ce56f5d5bae4f1a47cda674d8ac8a8e4750e30ce68687674bb42de0b787cf167eea1895ca0b98c7e3ecca8356781c9c6327a7732143722be5aada5ee495a882a40f9be5fb9b2acd217e66d53f1976ebad8b043473fdd0aa4932f71b64db16776462db0a99e72316624d2e224c879fe0d380540a2e1e23b474a9919369d4387881e5de85c1e2df61f92c69232dbc80342ce95f405536100df9840490420f8fd56d0d317f9a6df45be41f19291ca5e07ac768a434fb9577dbb164f27be98bd391f062b422fcf5f5f4c303d2e4d9e1d9b9d7f068f618b9484d608b1787e58a0abc7a98865699a3c1385aae814d916ddfa1183a88586b30d4878f669c1f9dc437c630024b718215ab59682831c7180f04c19a804417677a71f72fd95981ce7861833c0e7548abfb7439c17b8cc9c0d4f3aa9b6aa9f8725f94514bbef8f4558da27bcfbd74ac3978d6c939d0125f42dbd9ceb3c698959eda92c3be196ce9af2bb92617a63e686b8c96f4b414d2ae3f46c2f85d7704361300553c2378e8e200bada8dd1200dc80856e3576a0a3f4cbe763dfd615714e478861cf0d93fac357b6918535e482fb153505f4c53f942e95b57d5dc139ac8f95b57cd5181b0b33167e2789786ce5f999b4af76f01395584466c02fa079f13745453b5593f6ed0253214434c8e7d3532eef7c3ae23a16abd39c45d642cd9f9497e223397e4e607a4c6dd39fa842f122e9d7648870af9f84bd29129c30eeae54e102d9aab58524f0892c20970292f6540aefca7c8c1d3618a9e532865e2fa4e9b7b6dd0b41d2451e40e35c0730d6581bf55680fe435f8ca5a466f54c05f837bbbaacc07509486bb234f45bc56a55f6f38230aafd4ff0d065768be255587f2aa5ce096e5a5fce907e27c590863559135e802b3605a240c9e54148fdcfe0fb7232253b0681aa407c1df0f9bd9f090ffc0b6ae3ad9fb05827f6b156bc60bb09e0161bdff8022cac71e0df87dcc2c585bcc3eb972013784037b7e45fd6d2a055000ceb1e0c6e61828b2464d3013b877d06b2b2731ca5b4d78250266d74cc4746a70b2f589a468f680849e06f7b04f84bffcf49884ac67d4bdf6e7cfdfec432e99700e6fc804457bed56ab2ae00ee950587b299d1a5a6bcd72b482352db91f4ea12897a7cc215cb96ff0492b49d2d66e102a9d937be1f13dc664040ef1f2d80f0009f9378b941bc497f0c0ccfae57785b42bf4708009a9d76bd61e3058035d30ca04a32b6f95cdcfdfa3fd214a5ad4d400cfcc61ed74efb1fac5f3f2ffacee940a702b93b9aa03322b2eddebef6b52e8ddbb43b699d44c1be0883ec716cc8962765ff4ef8ab22310a3d94a17d0ffa0e180a39fc5ff2af75bed636f3bdbb55c5f234a7cb45a61dcba9f9b79e04cd07003940881bc6ef93018cd0855ed179446b442599504ec89a9f84aca0e3c4f2dc0779cbbbea3a5bce7f0c20543b02ee8a51965d0824e84e79bf5f52216f6ed16a93e1c8c1ae5ec0fbcd8deda545ed42842635548c4a4c452deb52b6568611133f1b6b6f08fbcbd43bcb5afcb02e98f628920738d4d8a1d28de83d8627a2eb393088e621a44740e955378bbc8eb9880da710eb5b7ed970d530d749e885e3d75f9cb403ff42c691820a1e9d98b1d7969769915fe28a0b311f0a941d5ee20002bedade32e423e08d81d99c428f0d57151fb41b5bf760d7ef3a63e9a54e8826ac52aeafe0228ca5195b8ea542bfed69bb623cd6b64779ae2221782f1cf95ae1fac9360e059ad702da1728abf2a5241b0964e539855d1ec25ad647ac294d01f78bd053abd9dee3b99da98a562d9d0d8763034dfb128e3c51145e6bf0c8f8f1950428d6c3259d7a808c9b58ac57e8d0160ef4ff0e59e67dce372a768c508287c44cfd6bda5d311d503a08bf7b8bf58cededebd7ba5f8a0c68898b5b76bb5f250a2d3795d1c7b94e1ab3352497070127e1cc513347ade193300054884fc6896e25f8db929054607b082163714ed0d030380e73e9ff1b670682d18d2770362b6332a79ae5611c156cf64707d0f45231ba9759190cd58d1deacd52e68e1e396392d80ccd813da493f407bebfba905028854dddb1ac8633f82292037fe6d247a384b86d17620385235256293be7aa95743eb86f392f9bbde62ab621f517edd98e9cffa7c515fb96bf7c1e2a3c75e297562c4e1640621e56fe88630290674e212b4030ee5a6fb9c15d1c7bc0814a115528edb65c400f1c01002e5cbbfd8050e7dc0903aeba15366ac10836563235fe40ac6f19605daffd48769efcdbaea6b8120213c73804d67b6bb3ee012c7b2d33b5d6c1e109fa2ade9f6e07e5fc51baf0a08520309a187ad59bc7c0c350d3879af5d9059ec117e6be2ef2965d60fe40f6b8e0fecb7986967ce6955a4876ae350d092fec1b6887617c0066931e7a318ebcbe7e78ce53f9ce837446c48914bcb2c64095c390414a06315607a5938d07c95ad84c8c7ca44575e299aa4ed4d960d5a31c0852e35e57080d1e740f99934ba553495e25cb617109155a47a8e31c3bac30a2be8ee8221174d5b8d70f537cf6730cc92b09487ea9fcd1c28b3f7776455e099c8122ecab691f9149298f04c6178964f94d4e38625c7bbc85dcddf32f8e569dedc371e6c292eb62dbb382afd8579913a41b846ae9b94b47663c17dc38b08e85aeea80cbb7922688b37f7732384232dcb46884a2281754382aec704e287b2e8876528fd91eaab97de63867a6f6525c17e50feb960c4a13ccc6ffe1f75295f80e4d7c4dad7d71c94c30ce72707a47cce76ae073b876b08d270e43ccf86a0e318fb55236a58e5aae5169e3d84f34e8669747d1690c1d559d3f88beca4dcfcebe02196d9f1e4d6842e3cecdfdbdacc4ae19a320237a14a4414a8148ebeb35b41951612c23d18bf6cda5c7912d61649509a9f751e1129f877bbf0cf83c14574b0bbb1c5172f289fa9c0451772058c8e6f7d7f21cc1dd6ec0927259eec33890ed91bd0a9eeef7afe712d5e823eb2762a5a6ae8a65ef8819a4fb8553c176ea7be6befc1a2b3dcba6c8250c5aedf290837dd4e92ac692cde83c769818840a0fc20a6383abe3da327de921468cbd556fd9b0c0ebcd496ae8df9b29e58388bf62477309c1909aa222c9f3c46d1f4a322fc4fa5c377ef390334d6238aa3d08775895da22a82cfc4ab11d6d42355b95f75c51a7c6f0a876df6d940c888a88a2edff284927e4e82ce1f115b397f3e47569aff453768acd35fc401b85e9c9e8eb1744aa727b87b82c50e3ca287a421521c4b0932242caf8878418bcbd35d93c438bbc5820f6e14aaba494fe9b9d8e570ff387e47c9ac6eb211debd6e942e46dff4cf4a0527e3b14a456551b7074b0f5b08974c95f32ae40b159c509165e6acb600df9b48c518fb58890842b7ad140e5c39b38436d22f8f5814d29f298f368748506874af86bfefc65c459a0b3c83d2159094ca6784281219cb4e5eeaaf6d8c16a1a0b7e8058de4879644c91cfa0cfc700a19ca413add6ff09f02d6e948adcaa286b688759f86e39ea7c9924f737f9f617816082135e3927337b9341de479cfbed05dc23f3031ef4e9d35193397e6bd9c9e9e855d65491a6faa945b3879cb3f10934cc93c41e2e5bdbcc28de37618ff49e1a1d36b30e4d5e6893c9a393a4e36d062a6edca563f55576192d1f32e213258192d3f1f8be69567bc7367e82c53de67680ec46e2039c5ede44343409696a7c021313332f172420158630616a20d07234a1516149d0237fcdf2e2b4b1ca4633c92a9a9205d314011d856b98b8d396318afb3bd1eafe042672634ebd56cacd2d44234aa7d97570b43bf84cc294290bad5d3ca048386056304fd3a2cf90ffce83575c9714a47ec442ce4f05c71da279dc2aa09c6498f030f5fafe9e449fed9e55ce80198fd1f8156c446a91c99660213ea2a028cade6ab36edbf66ab8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
