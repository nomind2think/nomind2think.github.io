<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4dfc00f703fd5b90068a60e71bcfedec8417e0bc05c26d4dcafe56cd00d2e203f45ebe2d4dd90277bf8bc673dfebfc895335b05e632dfe3000acb036041c289c3b7f65a03a685379df0d534981828268b6a36c1df494e9afe8ddea6926c4f2eb7aa68983c220a295aa5bc4c1eaec377ce4b51b4a767256adaa4affacb2ba5b67969a6e6185f96d4438fb89f74b27b978164199f3ccd09aabfe8a5d0c7574d3dba3f6a6305053dd00d6dd4f8e634e378f7e3cd1c2767fc7d33e3ecf782340832cbef8e2d6b7fe18e331a79e164ca63e9b355c907e983cd420b49e81200f0d22c42cd50d88995ae1d35de6e783926932eace9a449ce366d0d21f714f092614ffb97ac4c70c3adf2c83876531f29983c56dd4e5a0d977b3d9e40cbf46964a168db68dcf4c62ef33b66daf63241702e682c5f4cc60c244f683ba66e10dfe1773c4aefa9dde4826a3900e9638e5209bc59f35c5f5786dcdc430a542417e5975a7337f99e14b1ac77bc053e434bb259ab2497595475dffa054abe63247bd6b0fa18f421a6846774cb310ec2a23034fa56526fd9fdb0e6a032e3a94c021622c5ce4793465f3d04ea3efdb6158f6a9421eb2103d3a5f24e8a85f2100a88e63a2717791e04b5d67a49e39b21e972eb2e9a02d4a3eaf39404cdbf249397f6693c5e331b8310df43fa1f645e7561778e68e58197ad6ac6446ae99e1928f5cbb9ab4b150262b3215d16b38d8047aa6e36ba84a4235aee0e62e2bee63c663ecdf2e9dc962f060bd8d2a34018a4499754974321334af212282ad29140de94f874096e2b19bf6b757c11535131f676e41ad053738189624c28a7298f2bffded8b331e3b6a03ca10f760971293efc5cbfd38984a1652798cdb252e8c3f91bc47c411276b59dda79b250c9e9ea6c69f2a39cc047a2c43d64a304f03ba8a1d7ef0edd8774638e9fb4719641293e7b3442dc9c4e34666ca949f470f511b2616907a01a319306d07f3420a29fdfbbad22fbaaf699e18e48cee70b21f621485a9512c7ea2bb22e0b7c6f822f4631dbd141d2d3dba661407c7d1ea5a23e0ef9e2a7fb57f7bf6fb1390ef160d3345a10f6d49cd901e454f19a6bf872806755830fa53c423f1db944205d03d18eb3335474691e0af141dbf8643bb3c08114b15c9d34756abdbc16f9f53d761c2fe2c77905c4e12aedcb769a9496195adddd9648b122964c66c3dc19efebe56ae974aa48fe4734f324ad9047d860794ac69de5d98f55de63c6ea2053090efb1d034c865822abd9209ba86c3191b1386d80c1424240617d58e5fa0497b2f36f0793a2e308e517ada2cbba927543d8ffb59deb50a9c34c5a19c3987deb11447386e66ec2c56abf50998674f4265113f8c4244777512200c1848f5abaaecce535d3cf7e6276612835c0579e8297838501ba9bd89225fcbf933def03a5dacce58ff39215900245c30ac36de57cc69efa6370c64059d8ccbf56d2b6448e9f6ec8974ba4a8f7d21ae58beef7f19a8e125d1cb8a504e7095575d666221a9c0330c3f770692b0e6668bc95e4112e05329395e9467bb1bbc47384b4f7e9f07c9b68a4fdcd7aa5111c1526b813e641a224c4f3b1d5203623fa4d87529799777a499156f4cc9094190aa2236dc2e949fc7bed0f252e13bb78538281fbc4f4994fa03695758d81f957437eaeb3bf124d1f2f27229bcf47c5cb87c06b29b2051b7b6d5be5abd78902f1e33c6179a40e84abbe6bbbf5a81e4472ae3e6cdecde234fd07ce43da23d3397177ee3a98427c1c9b2ad7e89ffc5c13e564cd9579ea01368e2718841ab3bf38672509e7248ed7d38ea350d448fdcbdd29486c5679be11d937bb74ca57b0b729d6aa3b7451ead6eed3faa1a9dd00d8ca0880e8c35b9fba25a0940e2ea835bb10e9b765b8651a183e7d6b15d9e3726abb7e1220231aa682ce46c76f909a4a64c93e2ebb2963db51c643f5ff2cf03ba229e8547be2baa4e9281cbf2a7b565edfc05f49b5fa68e840afbcbfec5805d15f64184797c5b90214ca9fdef68621b8b17dac3eddb9451bde3cc7e9f452fa6ff816e00add2adac61827ef9e4c5af6362b631d3c0b29741b56323dc1c6615437ab6960eb9486e95241d47db7f04e4cedfadb1b7eb8ec49eb15547244b9ebf20ac616769e0903f82b07280efa2d50ece7da946fe4121113d6f4d6f18135b8639423e7a9b107d4510ecd74cff1e8213266637430aa0e229457f5de41e4d5cbe71701f7c06a363f117708b87668229ca85eb376fd3440f4ae95586b63a8fed70291a53d522a931216c278daf757480d8f8ee1a0cf15573ec5360095e1ae688e61a34751ade15f66120e7697f4e7c2bff986c28d5135945a2a54433176c6f211bcb7ae8de35f1d67079d782632fa2055e490bd6921d31f3a9427e6098efe3c6e9a7cb862ff002d310277c738531413c6e46f84f948404f37de670d3658091ec76bf19e50989fa8f0815ad762c1cf5c09382a8dcc4cbdbfc395cc30eb82aa38f2a40c4cba74a7ffe99b64db27e2d2166257d6684fcaba3bcefa6fc1060069370cbc5a48b13140e2e346b19259faeba612c47c659803221ec38f02b74d89602e4baa5ddcd07b32c79854c4fbd984e72f6bf54358ca926ac269078b65f9051dad6ac606f19b5538e869b92c563f710d5af2a6aa3195343b92bd31c2f2576284ce899b4ed2ea5db8000ce3368480520593db258149bda7c9e437416eafefba23a9572f96033f62d46d4fdd2924c63af8281e9cbba9edf31883cefa898292fcd186c9f3c73903c429b8d82592f02668f427b754ccc1cbb542d1925e6e138d8f7541372b8ded0c6c95ff091c0e2c9931133cf5989ef8b72eb9a2911836304700ef373b3c0c1281ae58c848071dd9a53aa70618da7e0d1dda7fac29b6b8a6b2f1e6b998b353761df4233a951fa0a5721109ff29750de6c6ee7785f1f320b7c1ef269fdf1fcc31c07182a2ede0c4a6a09a17be3e43a61ed5fb369f4d94c690ac5ccea5c5a95712438e8cd74d1a07862678e1fabda1e46b2b25c0aa62ce27e67ff6144c77db741f78f1e5657835fe7000d9c2a013f26b02fdfdb167c0b814bce1accf6dc349f0c4ea082dfa6b0416ba987b7ecac0b9e73c9cb22ed0b3b0de2eceba2b80f6a3d74fb01362587012760e169e7ab7ba8399e37294037ebdbdaf18e4872a6bbb658d16c5437acf5a8f1b46b709c25a59ccde4458532ae4b644c94ae17aba5932856489b3df0b04d4d41d51d71615f7b3b486b6201c88091b48e058968fb2e605df47a9d483f54dcfd8713e749ea957e7a5c235f36300787c33af7f65c1853fc3202d49add4fefef783cd31daa44b600d29728e29f9bbd074ddaf097aad5bfca02ffd07d0456abbe0a1e28c6297c94e390b25107ea5bfe0ab12961d5ffa7b3559c7300347cf5cd2e9d07e0e649ff9d4ce88d9cf87d1c265491e6a91e23953a593fee593a8c3727d86e39f683086f6c49739443950b14248d00889572e1b9f73d2cc50a47a31a9e950f110c99c75ca26073d2de6da11824e6561c44c66d5d824366f8f340ec1bb6b22f6f1501b94e25813645c5867e822dc3379c9cdc8bc0dece2c51a4fe70d3c3b7a9b675b955c6f33f3aa0420372b56cf81a06d7616371516faff4dac1f103dca892c8dad4fc9d429f4bb14cbcb9339ecdf500cccd11ab8392d96ff9fe5320a71e121e67956835d02e8d476cb0b6f7002973827f5e7910cdec7ec271d15a85ed0ee522243cad506d9b090c1fbf19e04f834d4fcba41de43d651a583bd9502fab83cc00a4d3c2603f3a8deb34dbb0dd77257376e8bb5288b513f2b6bbc0addc28537f3423765cb327e791f2afd44f3c4c70093757f0c0214596659a23727ab3e978daa0d6d97c497ac3326d6f107c6f92ae3204a24f3971bee2d9b3428479ad209a6de54770cc17962441fe6c04741ad77c889423e6ebf599e9de7fb9f9e00339cb40ff393cc3d66e4c59414f0602e71be6eaab1760c30eb9ec8e1ee0ca254e22c6488fabc8f965a231b066a4a581873f2a3053a01968d267474b62c3a034c50c11ee8cd57bd020052e9eed22f58428e0e17db38593ccec9ab9d41284b41fb5e8ab62bf1c5dea755e4d6fe95ed807d11486d6e140fd26b432c653b2fbefa05920040c1754957c28a254ff36d73fecc9b3a0eb5c1b33d8a2c7bb09fa4fa8a73ca32feb73232515ee0a3b19a8449550d3d070baf0b42e3733ffeba839096efaaa1f10f5ccafe66bb7ac656c714b7987c0db79a8e7f9305b9841daec1d69edbf699dd89a3ff51a13ea8dc539a5c2e20c1c99380201a62306264b7d901868c37398547e455acf669ab5599663d54304af3806e50f14af527dfb496a0cc131a6505280589206cf1f8fb45e9b3442923cb38703468bde72edbbafe13817ec10b16ff071f316971e52b9621abc06f8b9ed75a2dcd2a7c08405871139604d2307108031c55e6d2ef4acc1c0f205d2eed4a5995c2a0f3964026fb0ff1ada9ea88d03c4bf1254aed8b3c051383932c0a9c9fa8ced7df2b56c78663f6210c6445c83c8a3018c2ad1d8d8e9fc47e1692c6521b78b8e5b9677bf087668e6008eceff4a1d094c326a0dff03ed5972d0f3f9e96eb3607b7b0f81304624625e7c2961aea680749713e45585a93fd17fd030c4c30d388a99b8981be3cdeb4c3e23342c72e7f456a4aa6838243ad1fcd1c925e5abe1ecd9cc32a2e9a6d29df3d383aee77b743dbdf39f34e91b9d4578c0ab1e3228d7a4c8c567f703917d6c0339a7fa73f72f0bf7cde811dfc7833f866d581405c18be8618af9d74c79dc322b4201cd690b4b2397e3b403475040b54bebad0346d2cf68d0f516c21f3a29c892ac7d2df2d209c8bdc6e1160f833a120d3b6ed65d4feada817964b62483f873a914758cffa5714a95b62b60ef97f08a34383eb5fcca29d54ec0089d2151f0a756d125facb98a9923559822ffcc8d8294e64ef8ad7377572ae96061447b1a627806375f46808c2138e6d2c71ce4ccb8523a4ee6d45a2497737ad90a35c9a96e2d875c0cd7947ec469ae78a53282f5f5551aa71084c0a58b634f0e2bdd764da3e4ea0904333a0e0f470d58f818728864a94d94278e7f4aa11d34cc62cef0cf5e942a6e67cb06f2d672584567029d914a8c8c5408cb481c5be311c98e966a16aabc4661f7fe99150ae6ea23560ba24f5630a545d38cab4705ffbd167b528b81143966cea54717b5cdb69dc20e509f13004dc00114e8455af4f6bd9321b0e6e84b333bd5a6fdd34288f47762670e30d7ebfa5d2c29c88a5866059ef230076f9f37390685e6006e98946e3724d7fe619f332a18a89d45dff64be36dbc4f2f5e57ab2716d27a974e4e61bd537dca2994bbbd5c8b5ec2e2c0ea48021b6d9c59955502b6e85e1ee158b77193a65689833fd42b7433938a8d4aae27cefa14a07a60c551c46dc62b1d8db61d303a490c4bd641580d468365c29f829a924421659a64abd936df647143eaf1ae832c46bebe2536fb7b4924874bbfe814f202e31b8df8a5e4967c7b00f798b669cd9d0a191e2ff78600b6d39fa79848a088521387be9beb99313b6f31d226c9cc043ecdd404c1a8130ccdbb43b016522731687b0f1e1858e272c3b5d7a01e0c4cc97310514ed531f56865c91a0e6acd0f9c6941c66acadc4f58638c189737bb146b145b24a4654867964944822b1f0b34710c4ca1267f953cdbe7d8c9fa579833e9c837163765adecb6b003bba8bf27baf34d4b436b7e1010e060d39130bf378ac2a4f86b0fbf095e99b8cb72e71a43d4b2efa099b37a104b80be35e7d3ad6baf0a69aee310fccff7b316628819369189c35145af754585a3bb05e983a033b621add2905562bf8d0f7cb2d90dc80cf1c465b3b2c5353226eb7f4a8ad9c340d86e0aaae281819491a27c36ed84c6b06dcf0b24cc3e335c7dd95f5d999ae576f6f49d792d189ef29d0e89565b520cdb26ceebb0a52a34c1b566c5651d5b2bc1634c6baaf7dbcff43e9ca986e4de265ec959bec84746bbf041921d7e84a85ffcd8235631337919c9df6349ea60ee9ff2ed60a2202cfc4c9978dee8b193954ad0138000d5d06c579557826c0334ac36e30699e2fc57c4f0e0dea0d2d26893b740b81733756a1f3c36400b56d9c48ec911e0bef8f0c1baddad3043e6f9f47a6d6c0e9b361a99ac39afe661e6f74fdce2b40c7d49b190248042dcdc8f1eb78633be60402bc9bdb704cfc81ec166dcc0ef81bd4fb1b6c879ccc4bf4c278b488043831a905d44afbd1b360adf070960b9137ec57089a634a64d315c25fd71c1012efeed91712492eb5e59f1215eb898c3666e766732cd32b6cf326fc44c0d3f29f6c117038293d932f646e551e1918b1368365256027a85c7035224cc62ba1fa9c35bdb8a031c119df4b153be6d757803c1a8b3c3ed306840aff8bea42a843c324332829d841f80a11a220e3d73d02d9418885107b259ca99feef04fb321dafab306a3db26a89ad7167bd6eb64605756edecf3cdd686bc49e689194074e43b2027b3d01c60cd64992964c133c6d1859c074c5ee669e7c9d020542d80f461609bd86f0af5040845c79dca8b10411ba07123f0f146b5959ad996c722fa81f867f65166bd9ae62620db6ad47602e3e70571688c9c6b1c414ecfdf5c817f8a24b5f34bbcc32c3b5640ce0b68162089174785b585191117d37f36e9e27727794ca523e1ca304cee43e6ec391267d052229220d183e5314b5ada404baef9222134d5d080e4c8fabdecb45e2670ed9ce52d6625ed065340f64dd6662adce914f05bda223999ec1d9330256f25a58cbc78211aa7a87622338a303abc2ef76dc2a4c43c8c6985ffb7d06e4c2f88cb7504441a3117c8dc0dea3399e4ecc15472048e5d4e7d9d052a79b52ad1e9d54056c7a229302c5bc9704d4c8c64d792fcdaf07ff94505a6138f2589c3871084adc88bc81a7c9f4c4c7010d976903208e00d447d16314b428ba9334c4fbda19d96976a0c831f68244c99ad5911ba13ae44d9d6b73d13053aead277f9dbdf11ee488612fa7bf9e35ffcf2fc8c12dd247f770eeae780078f5f956ddff329a84cfce2d6b6e0b45707a2efb17f0d2a18d3ddae841548ef01597e72c7bafcfbd97c43f6abcee5bfdc750f4611aa5d9c5e98b20785d62351188b5c7943d1bd74bc8676f3224915983eeb9d70b041c041d9472e2e0de37870f6d2cc33005d4b381dc90012954f5fdbf428cfe3e3f34ace8f48f9855efe8363f7c14bf3e90122cd6f76b265befe1868b5d7bdb9e6c5b382652d06e7c386de46fbfe340b3a7816a0daf0dca37e2e1577563d876e77e4180144edbfcb853cef141fc68f72724a6771fbaf21b466ef969643d9001d3811e16501b9fb1ffd7beec18e3af8121e82dd9dca264ac886d84cb127f193f020089b41ac1c1a7c4c7455a2112e77ba1ba136787a2c44a417faf909e97210fe91b8e18d9255f977f228ef71d8e7b83141230048576ca432c83a0c723e8574fee4a5cd78035743eb02d67969afe990b82d44f7c841dc18783ea44ed9a6b3d5b61fdea875ec821c0f9094b0b6e9a4142f73e407ddf954896ee9662cf3d8ce84bae770b1dc3ea35aa03d924bbb3664b781bec885793100bdb2a2a5f60c43fde7c6893322931f451f1f03b66e842ff2e42159c816b186e1bb0dc5a98a51656de0b81b1f272c39a123fafc3085fa38f817386c647d562b6d7ed49d8919341e23c6315bc0eb7b689f16d2448594b166fb8e3a64bf7f953a6d3857709cdd926c8f9557e139c5c23b748c755de5948f1ebc1bf97f5602e664e9bb97f9f9ccece2c2c7784c1a79a3be29bb0e965caebe2585dcd55d50bf3908965a5e28dad880ccbd5268a3a7ae3802df64c74f09505b9b12484bf1fdca4e1939e13e9ec454126d9f4308e3a37a8b403c237b17a3cda7cb17cb759ae5973d62294b6b2107cdc342c97146462a71a97b2637af59b50fff5afea87917dddd71338ed6beaf6145ccb8da84caad4b9477b8149ed116972e66cba8cba496fbd74a87299984c2ec584ab5c34306c3d240203f8e28bf096f3203e6fbd0048fdb99e0d4cb553985729e88efc7a6c1b17681176e7aea18f6ad74c8f612ae144b780c59b28e603fcab1b34525a8f92ee7e22e74fe99f55c8099be91a78117146e309d2da877429e2db649c2660c5b93cbbcb9d6aef36e4deb396c711d9603ec7201d7e6ed13a9e60d24b30c8e299416d17da9b1f2a3e808f0b540b59287a22d0546900e5da31f72e8176e95a0ef6325fe9b8e2375e5b6598036f1125fea68d7bf62af30b6b22611ef0923f29ba0846ff2319089ae3f65704c3f5f8b0dfecfcba1541cdfa7e7f2e4716ae51190efaacb502f38739b4ec3c0bc0c6e1043b8c876c881c42db089caec05c40f77cb18a2516afa9e75ccc4be274dea0d5483d97261aaaff2931d02dd4e86dd88ab8ca8557d3b47e27071fbe0f84cc7ae3570257da2e47a07bc44c5051e97d167282c0e3f0dfcea97b4cbad20f5bc1a6ab1de1ee8af26e72259d996586884a798c99280482cc490ddb52b5919222c17df45e8a6ebe29eeb6b57c74c5909a95105c512a1b19dde89b8b1ff8b051dedef069e70b49c3fc043030fc9e9b0b7f9d30b433c87db9e534d0f9c79a5096a06e550661f8e0b0d9a67507b6a6d75eb894d1bca83b8a0b396f5613255f2bedf4b72bc348bf2a6448eaee4e9ebdef910bd8b2d9a392bb02c8b5ee238b4d485c3fac6132a0de283c743a29eb04ab661b22baefc14b60664341f29fe1475705c7c67690d2f52c2db712c953a5b9992fc41a48d5a36f34dca796eeec7be92c8765962edcf9fabdbe42ca2b2bac551f9a0e1e1cd5835d44cfee6f5a9f7f9e09cd27c8b3a791ed8a0201b20cedfa07bd726919dcb7c6b05bee308605ccbad6de3f693caa5c7904e3facf6c43bcfd19e24ab547fcb001979eb8096e69d8828b7379fe70a4c7257702d402409fe9f4756d5d4d86e9c7c85a91cec928441148f899c909c3da55be7019ea706389d85e2427b61c2c926b7ecc2e3c656b5157be8b6a1e1274c062207928781106f5915b661f49986e304d60beb3a32ad7feea5bf9e8a589a50e2bcc71d30747eae53aee5b339e29c6b7d17b28ca5de455191ab3094eec35a7c74c288e95e9a0108196ee84e7d37945071d0fde63862101f41fa20aff0093bb963cf78529aa5e09f13fc7f9ad0f09405840f969f2a1db3e663e6456862e8d4b7b3efaaddd531b5e9b578f4705ffa257bd54ac0a7a03a981ed2fedf1464f7f91dd35d0a00b90e462452e0e462442b812150652045c9c755194eb1da27f64089dd8caf0b9b753fc96c2a7022c4a119138f8340f04cf6995a4e48bb1fa31db62834d88259f811bc5e58ac433cb73575ba60fcf94ed575f7bfb7dfb875e2c67655817bb9c72a198a28135e4de4bd53ccdf3b82dce62a033148b8c01b2fa1df07586d5f2625f224c956b401385f74bda80d3b2fe313de4b177fe7d83b09d09f7da1ffe893ab3bdf72fa70baf75e014bf4a22f91ac096ff971ab61e4d15b5c03f42a9d34c6a5ed24d10660896711416f370e74361b8b890e9b3f7ad94cbd3720b65b6d67e30337d9683d9d39d91bb4efc2f66c9cfd847c57af4628231b32d8831cd765557a3d2d2b4ad5c4ea440c894ee195a15df078670c8cc7cfd0668240443182aee7c753b3c4fa9403c15ce93c12f488c2fe209c46ce82eb360d91d8fb0e797d2a7ec03e90317d47a1a77a521b8d9dbbebfaa6e341650a25ecaf52ecfe6a2bc3c91de6d111f6f3b94467ea964c89f4abcac6f5ecfbaf1317984df8c82e9f14eb974c67258612c7f6e37e2602ac1288603c775d5ab09b31979eb92fcf913449d45cd17464a9a06db225433123e839cde7878b947b0154898564ccc3962aed705b4c36c3f541d8196f671cb026b69b80bb57b85b5f89e2281cba0544948e652f03ce5eca777779fbc02bd9a089c0429f5f4c92d14ec7ca09ce13a8e1c42bfa188de209a3ae9a722f5dc60db8a42eec86c715f16e5872c6ccdba961922417e22f86c1a98f57ad33fa73765dc7ee36d11a89e7d8d3fd80d494128f778977aca221b80d5ee613da4bb410c36336ce71c08df390e7d274b45a57c72a834bc49b606bc881fdde2159e0ff9e84c4fe4ecaeae23b881b428029f52e1f78cc106fbaeb0b70f532aa852e04cbcc844f6c86c459c388ee6892f4c0d83a7134e73f76798b52e0fe1ead6bcb29a753bef3ec67d2b3456e62579a1f304e3a019197114250c668c2e5912710adc5749ac1fe1a09aee5fbc184aee6ad1b8a54ae067c5cb42349ea3dfd6079e79aa5bccfe4498b27c126d2d387994d4035f861c00b1663b89dadfeddf5e16bbdd03d4627d1c41bf847a6f0da88ad50bc261e9512ec4a7443c3030bbc6c7767e9f35b3fb2c495c334303329e4d6d3b9fb467f8c251942e7785e7f7fbba3acb327fda6288b579e2e364fe400e650fddeeefcaee9f13152bc0cdc7f45e18f48e291eaea9604f5aac6c1c1f2c0ad445bc0b523159a317c77873e95d256858df8219ccabb6244305b010f01aae30c0d801cd9a1573c9113054faf068a622d915db588d0f913e7f0712902ca52b042acc8652fb610715c5a87237b28ea90fad40166dca90f95da23f4927fd4901f0be46d32f1ebcbee4137539c2a8dc8a6c7986cff1580db241c4be0cbf7c3575c1518fcb5bc8e653f8d7b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
