<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18bb663d9fe27d0fe864015cb9a5fd189c41ab7036d72a0a520b7101bd91cb3d1d15cc98e92156682b31eeb051e0fe2b61ffd27e14a24f102370318b6fef0a3d94163c6ce06b8e1c65dbe2fd1349b1e0150b04ddbbabeb4d0f07f8ecd5fdbbef2d58d079db5a5e5ab58aa7c46e88da75afd4e70e5a18c2c3284750a9f9e457a273e272f2ae627573cd4629c6c7b86631da2e513a0430a313600388058f69e283efafa8375ca9327760f84a0a1726e80dbd3accd5254dfd9e004eb1911c0a06ad76c5bf70d21fb4b6a74fbbf85969008a06cbf4e4dd74d364d64dd05f4a054607bcf887119a50be3f1f0a059ff222a837663d5ace386e0ff023c8769674577752b97f9a60f2daa010edc9f883bf2cc2133cfcd1c93a74e2f35c36ed5d9cafc34d072de496c783f95da46201fe7a694be2fcf5233759a831eea0e569f974b157f91cc644e06f9add1785f216755c7d81725a417fa8507bc8e783149092e2fda48df9860517013b80be0c2936552132973ba0dc28eb52e2f5cdfdab906c78f3a13d90c15f2d55c299b954c9889902846bb0eaece5efb51640a4f36f4ba6e15a307b1b5547034eea34c470ee39dddadc59564a7013bc63c17545639a64d70bb712b21a4dd5ac390c132d5a2bf941b3fd3ae76321683a0f3825d57b13a6c34ea1ce4a6516b5467303c1f4f15a4521538ab3b9fd7dea6f310aa789990634d2d4beb1fcffea07bcac0421d4e3ebce7fce17369aac4a924bec3002df38f2ce6a19eeff14f200d839609cdbbfe532cab75a52575eff52e8de2e3a4471affd9101d668798661c8aeccccacb67f6302f74ec5054927f63e20a456eaab3f25a8ee063ee0ce6cebad272faa2a102cbcd344162676e88f7ba3ad1fb58bcf1d7c2ee3a343bf3382e7baee7743541b60829f0f6c100109679951f011ef1ad6c22b70cb21e96b0529ede7f6716b59c2001d213756fe642d1b41c07c8ac97186c75f021ddd359dcfcc7274aaca41f659c284af475dcee69439522e4327abf8d1a8982e3c394bc2b0c94ce158ae48e76a6e326ffee11680a4a17c5233ff952c367485bda015a3fe821db19fdfd81a0bb10246037b2a8e47bf6d5ec84a137f374b4a609325b2908f4f45e0a3c0ecb8cfe388b7a2be11df7fc66d672b69a08bf915e2b43bf059ce30cdc3dd6cde97e0931bfeca69e959a3f0b8f57cb6a60644dd44773d5d496e1b51a1d917225b8982a0c34b975dddcf1ff7fb3d00f5ba39f56a66b819e5b3dd9d4a91e01684083a30a585bde66d80502d6226eda34d7d1f4b1cb1689db75352a16ab438f26bd8459bec1d25358950efe6ec4123054fc9fe071cdad6b28468fbe3030967c33d64702c9b746ff73b7bd95d6e7823d4f91d5fb78af6aadf20c8861ddbca56c45f24983546dac0d25f2a7264e4c21bdb6d156c4d5e3f1f1f9f251db68e3fe19a2e686c3488e9dfce9f7a73340607b2803e620592c2c7128b4a1bdf7e5892071f212c5a2aeddd4203d3fc43def6f2ed0c4671faabae669ec02704d69e4f179c7428215e20152ce78aa0dce6f4e47e1adb5cfd71d4b980076113560fb08b17d6e1959a0a01143177ea635b5e6462e8c2d67a727aab7499e5cff58debd96ba6970531c6bd9b90f28517e21699f38652b12b9c32038fae049ef0e9f85bd2b773214b1da81758fc3278e27585e17ed4c910f87c49e16b770acae822145c869ccee51a575c4137503f42384b97e7ca457c17e6910ced6ad7e2b06e0900f8b62f7ae9ccd23129201a2a99351dc0817316686be47fea3c547726d4ef7a3a9c17451b6e9823edfd7abf151529a751b2d945e989459c1010c0f3c67c829f24786c4a90db4bba5af1a80d3020a1afc24bc6787e5d5a0845768716a24d7a2877491b26c1c39ec7dc6d678400769a7c9850224378c363759ad4d15e3e710e4604f571950bee443b945603677ec17031b9bbd42b43072ad20371deeda572b6279b35e321c3d6471cd592868bfbdd53bf21e1a4690a33d0ae0f217bf7d19d382120265cb025595e3ac9f406d3bfc81b793dbb63945dfe079a85f648d446121097783fe579fd6bdfb20ae7ceb52c142aceb850786904dc1f908ed178981d5c1c96d834b89222d91aeb048523501d69e88334e142f1d21fe398fd3605693437c7de1637f4db7b11ffadb638340ea4c5d28b8b6b31b023f254113da6457f2e91dd65222db96210c49d35408f11a63ae5990c7fb34bdc2c6013e94f3aa8ea3965715776af0212edd542fef10515638ef2405eb121f4af09070da464bb9998f372b14535fdc15968519f4dc3b4a9f6fd245e9145c7c4de894045ca381f85cb95ebc559ee3b369dc08aa74ec627b148ab33efa6a559b7aaf6d0594cd1591d16ab4cdfd742c31da81c085134bc15cc2310e4fab351d76d497e46b0e54f75ca70201bf34cd9b511b52fd708d86fd895c33204e5293aa923cc53347843302cf30415cc3ab8d89e55675eee7d6ba8c13ffe23f4322235a9ae9b7302c6512666f74181238dda8a86d08b3e00d1edf3a770726ac1572de6071f5286a0798037b1ff2162e14bd65fd229c131ee76a9e68c1494f4936a6e779cd4ad702a1b92ea647c9bd08791490224546be323065c0a458471e2f1e2e908fcf43ff578062bc5bae7dcac0edf1e7c8c640d42d022cec8aa3372d4d63a498155bfc11adf826bac5775ed0af72b6ad5b62ebe95d7d861354853d1a9f88b2ef6ca02849e237046652650a5ba4925690483d5a0271840accb14349251d4e1b8d9c79daf88ab3aa7902fd10e059f13890a9197d59567b7c86f1655615d97e606d435191a2cafab5d2f6cd019e16b0813d17b5dd9d8700003b72a8ebd37d7baf08bb49c5e38153618f45de2391c6a152fe7f7d12e55fb7d566d668b6af7c5b3246c458876997593f0a507672fc765ba301154e9b34011d3b59f02b4e7451824b9b044b8e4aa8b0d13658e7806b936e6288175e47a6644d7179a58b87eb3a0e7869d7836f8ecf09060d3ea9d50a1b4c3711f09c22b9a3bad60a8cd6485e0225e367bb4ae2bb078b272092ec7cc51c7540ce244256cbce5a40b6d0ff32282e90605c7c2ef15023f959ac466657a94878f1cbef8341f3bcce777e916b55ff4637a172214641062bb24265e18fab94181dafe02c331db5facb4b9ae6f55be2a4423707cb2ceb69e277dc2f2a7a54dc6ff4658d7c1a763d82055b233d2d339995de1f412a9389806cef6a917169c969d4cc83e474fc6d154afbc2f602bc3e37bb1ab1c4f4207c392a92a320f73464a4759137cb06451f9bc37bb3b4ba8383da0c6b6681f04fbf9dd404b71fc87f1e02f52753aa78d4feca2e685c552ce01dc97763beeb9eea6403af256d5809398b9ccd41d1e5d60fa1073792bbe58c5176088ade27c07e6b78d187119405db2c41f079a86727c2f5716f3b7a8e1c30e6e0b3e858e7f1b8d1b7d0b849240f51fefd05ef48337a27f9c0ccfb044a9a87049280a8391088ff9c846c445d59c6ac46e9a6965468cfd13452ce7139c0112060733458c8379f01b07d1a01a06755adbf4f51853f11d19a9429db291e7c16c22eea828beeaa36aef284f22356f1396d713728e9c7f2ab896c83b869edee455964779032f352d683c5a5c09d12a6347d3a452b119cc04db35493e9ec5b236bfb28491d09a9f7ef364294ac7ee2d2191fc1aa8021bbc63bdc23bb72414c0c415de34d9ebb341af1bf888bd879b51f513664699b90f1cef91232119d4e35061b0cb646166f80ca4a47738a46986b96fef2d27163e6443cf1efbc08a4f833deac89329343f339867bd799003ef673a60f9581add114f4637767d3abd26a392adf70e8a19a987bf3c905ae6a2518b90a38b7b0995d231eb9b0ec6fc3bd06be6904a335ae2796ac77cf2a3c45493cf9b1cce93746715782e9b7408ad30aa5c4972e62852bf3bc833cbfbd7c8a104782afeecbdf734084b902a63085e28b436b875d0d106b6cbbfa4cc09c6a09c74006b820d1b63cbcde63de6bc6ea7ec23821dbcd9c301195b108652f520a75fa4c1adffbc0523a9caae5aaff694c579f968f4ab2fc5846af35ef64793492c6a777b653da4a44f955372eb6d1513ad9236fb847b0588b8c4dbcf71a68952e9928f55a1235ad32fd1f97e3c4fb7f72b632656507d73bd0d5ae9bfcea2f89f3dda9017512c9b65a56e14646c2814649ba6d9c6234e28e191fc6da03a918adb4a01acf46bc5447c9a5b3380ec96175c4a091a5e877db26d49942f3178ad28d55adc19c57de5a4a32dd401aa40ffd9b060c345e828b1e09244cc0bd1de4b881e8a891058f09d275c5c0555e060f9b1b23eaa1a6feb82c983cda1e5a7b31e6d07a8ce7230f2d04347c135a5dc239a6f00ab3010f55e14a0a0035bf3e46674c0a3b1064fa9d9d2d4b489975fce986b79c31118da204b55ff70d9af2a3bb5194b5d724ffb874c120dc03ad5d6b5c13903c3eafec9695227d0be01c15f7a0bc4d24d262940f3637e3e66d74c35936f4a3195e1ff6be24ae6318e9814438b2af8e93ad8b36352333d872baa77f9ffad1ea2ef999ccfa20adf6c1d2b0ce6a33e4c45afa30a0325dcbd8967cb4b97fe08bb31c93c7170f4ba5d503fb131c6f47803f2aab18b765f4fed0ed326413e5060c6dd1c9aba2a416fba2bf07e796d69b9cf2061d33173b8a4ddfc6db49c372b70eb51d215c6ac85f538001a9e5ca989ee7ec2a97dd2c924c639ec1c03238be6d96edb90a28837b5de1f15e7df9651decab121dd3d59a28b95d610fa2c244e69b43f96b9ce4eec9e5fc8b6f906d88b71e1b92cc8fa7cfba9395bbb2906cea11f4c8bc8952453ea684d1d29b268016ff8aa42d360798b07738338da97ee318b1139c969111df696c68eccbff6c470c3fd11c97d88ae1d7d81b2deca2233c29b127515508b8904cfe461fec5140ef690d7e38f6254ccc99e95fdbb597d0795ac2fbd7ad214d383b60f4448c5ad34a3f524515f9e6bcffccb5745f005e8bc1b3544e341832f00740d234e3d46416c4c71e832b9d87f567559713354815ea7af018b71471468e997aa3870df087898c77a97aa02be828424513b6b99abc0faf873876cabc78ad843df25f17a07edf3dd2cce24e156139154600c3dea085cb366cd329d7aa681886122d34191cb2149873300acd0cfc5891991a6f386936c5108aaa42d13e250242ea3f2990baca29d91f1301c4bba3346409def90145095589c9db731bcbbf38d5ac0530719ef017e295be60aab72c97bceb2b3ead180a1783c5212ea0210a11e115f2f76c20879417a829a454396cffd1423de0f758c4490d98f18c1510f5d138ea14ec63d21312b40ce715bdb80ab774f9621d6dd0dbb81143b9dba0e7958dfc3849a41857c6904422496148f922f77f4aef3742a9f2e9c5b4807a0e22ee54f8c816ddc9559d7b956145ec7379caa9d3d9fefd49c08e272e59c5fc46afe6aade57da5b5ae28d42afcb4ebdc3200f758d4a805eb58e539d89a734a1202bfade4758554fd4fbcd869763968649f90daa898f8f5ff48cd1b2d0a2053d998d0b93a79db126ecd4f307e1731d2d49e86e68d216fae79c81376c037c1985f988091b2c7ffb8f6d67b0ac48eac2d2cb14738c6f1fc007e4fd19fda3d2d5278d9e38967b1a604dc1e2b75425236b46a63c2e6b7c56121993f62bc1bad8c07f640c3f2b277f6344b7c8a4038ae79f742f8262868fe0de6a91a2fb126b21032636e8c60ddc6b0012cb288e0931f6156bcf680a92bb4f518dbe20ce8258ce8107bc15b8c0e6cc706069d6229826f655379a02814b3865a31d381f239f0cb6a0c5135090d460b61793e0e0026bcdaec2174492139326c60707fb6634da4f7de058ea049101931cde18f34327a355ea663b6f2682591f7da0b7f7c0749458d6eb927a54e242f42519fd992a073c78d8b4183fd6f62aaccb359ec3eb8e71a552a203e6d037e4b4a4c508093fd559bab230fe34323b9eca310fa04ebe1fd4f88ad944f7b54175ddc3beb994fb97b61a9f437a1048787f96e74397d6f4b9ab269af18c1c506418165b773f4a2b7b4464405b6e8d539cb5a9fad683a9829c81c4f634476b23b8702210fdb47bc8669d915ef64c1f829b717608897193a45f78ed6668d47f200f70222ebec3e8ac57d798dd15e9222c07f1aa0cb914c301b8f55d958ba77786d0e2c3dfa0336b8693075e3f79e23cc5ff3820b1719695a36319a9803b29c7e4494406ec6fe0979e9e59858da1f2c7abbec17b1ed90d3eb9e2d0c46c471212bf69b47a3ef0bf483fba159333348e5793c916f30a4dc728b99fc0d69d3b64676204d43d11a7ff7eef5d86df5df2e624a4f38cd35a5ee8c23e92d03d6ec6bd9e31af408074a293ed3e331774ba3ea6542c446d68d9fc34ada20fc96ea9cfbcb07e5fe30acff1a0d50b95b5a0bee0c043a439611cb898c989764e722f6c2334125b23b5f3b9f0ea9db6193eb3931ac4c48e6bb774f941105f926ac6ff637892841d3502d0f520d16a42b215824ea5a28937ec1c7913f6cb343af69300c6e6935a6817fa5c6452d32d88dcb7a925d87a2b9b3747f7f5cd77e7f67594038f258cae390fe9cbd23339396b47370a9110974cb21356feda81ce733e3412f6539b6bbb545a3d7d309c810d9877962549e601ad1b4141acf87d31121ea4456ae82ded532850226c2adf8e582b0ae27904a1837f1a2674c98d82870ca4d521c58e7557539ce381ec7082f2f84bfab965d399994ef783277261c0842f274c8712775fc8b2d5ff078798fc6eec155ce98055f483c274d98130de08c92d70a0317befb226eb18aef322c6e285933633470ad6189ee061ac310ca84f2bcf0f50d46d2808ec398869ac6674ea8f8fcf07aaa44000a4e4e67b9f7f85bf684e3bd5c61b1e9d4219ed82c90c74bd2806287417ecea6ed1953d48825a7f49d8378ff50928f420faf088de86dcaaeb54cfee1b0e451baf85f7896e9b1c8955ab175bf1115d8cb4cd47748c690139e564e864b4be76f71d398dec3d5ec3df56eb25d9e3f172147c0afbb98ed3c4e7df97aeb359e07fa59f6a01f862b332537814d5fa7e6246992c073a013125cf4632481dba710bbdde4353f5ae38f9bb4efb759e6ad9b6c59b28ca9d383cbb6952e92e1118b58e307f8f9222f0a14fdc723b8dc35c05fde74281aac62ef7f7a8715cd67746cc6a78dd25b13acba3eb50fb90e14c3abc0b092cae2f7e8dd98d7f798c565d757c141791129646fd72899c0208c2124005e9873e08f5a4e82cc6915d367d7723883b9b19d514f8165d558d579d9226e26df97e68efb3eaa2d487c0f60a98833d80cb5a271d08ddaa1d18cbdf6ab750684bf4109cd6151737a77a798475de0eacec966ecebddb7c4870abd9ce94a09a1d173fa75eacdb157f1ffe2b9dfaf7ff40f4c03d930236619758f22bf4657b56e5a8c2d692a4382553b62eaf410b857ecab9e9639616659f18fad5e00e61bba36a2295ecf4f92cd1f7e0b7d96785481ac4e19d7b50414725371780943fdc5a7b9a97161deea1118ae675704dc0e804bd7f56530657c240e5c471e688cff73eb50edbb18e1870b320222e7b867603d5ef6f3796b343c64c10af4c35478d03fbb0f385a0cddb1e64bfe988718980ada1b39950dd3f39dff628fa26d42d918fd70565df9efce969cfa10a8ce6f113c0493e3c5af4363451ade7d795e390d55c55744c8e8227ba0628caa01e75b86d78b9108bf629be3240ad4a84f88b6e6c510898899c8b3ae3fd1d069aa9eb1d225c7cb133de142741405acf61fc32e1711a7ef5fcb0b38045f08a9d61007d4dcfcac02c32c7fdaa10a0d12612a42aa6c123ece6b25b9d7ea800c76c5eabbfa6834401fea22da84fab177e32581bdcc9ecd0078fcab8dbe945502ec0c50044bd07b5b871181d66213fe0c2be9c8946834d19d791bc0c010a15ae0d771c44c3f2410c8359af3046d9bb7a73fcbe4bebf880e8461237bb0685c2a18ec3048a9212f1de0cd96b27bdc0977f25f51aeb95ee0d940f0ec03a67c7da42674c19a49de4a2e05e31f44c9d2e3e50b3531e3b6b9b30ec0f50ac7e5ff7562ceccbd0d09bbaa8a7fb17de57078ee9b505c136f38616b0f05ce48d19202ac6c36d5ab76cdd607ebb63f082b8b11843f1fb2f3abc31203dcfef0656eed64935f142ccc5e1d43ccbbc60022d792187a6bee2111e4fe50113e0531b4269542a3c7ce57be289386ae8d967233d2a3d94f798625c61e95e07824e991078213981eaf12740a9f1f632495c7564ea4fb8fb9c95f054d30e36cb51df02aa194d932bacb63dfc613a5804056c3298741c405795b2a39ef7f69c89a5a1fe0f6b00cab43038cfbe1d3484e30c5df67a03dd0440b4e001490002584847dc439054b1eab724b1204453facd379a40e4291993fc3370984df213df7c5543985f2af3f81336f280f954825e8ab1b17c86a7d916eb5b83442f9f7e7e95d490f9cd791a95652ece47f6d2a56ab1f3e5e637c5b37ff8e26a53e254f3763d8cad21e5093eda18c473430e105ad1466916d65a1da9da81e0a0d071c2f161dabd08fef0d7877d293948e6885933160739286c7e6b3c50c24c3994a6a3e30e917ba1a4caca9149ff93f75173e7a0bf4d5d19f623ff09ceb15b70cd04f44445b992e2010d7857c1c74eaa90c4ea87463f13419b8bf5516f1805c5e5daf58c1a951ac46ecc6216406e00713150960212aa2e67352508b769d57aaed62e90adca1f8db3101aa720c9d06b5326a5b7c9493a5e57e48fb865120235205606ffa089712fc4ef0146e4f7ad1e269413c8d8d0625bbb4a36cf9f03c6f042ab3872b567bf377c6dd07af0851fe3b68a6cad7b5e0556fbefc26f4b00c7a2591067e3d3e7e36bfc3094783f72113d082dd14fcbf49c3a52518dfddde460fdd20ab2d8f9346ec7081690dda868b2a27b3d14fe813cad89d8858c9806051567c1da4886d5d2a03bfa0eba34d6b0dcb59c8ed45d4c0c00456cff9812cdb6978bac1fbc96028abc587d99015a4cce8ec16f1360305525e89cd2b05012ec030f66368eb6f7b6f94d80195defd1ce025872d3ea9dd8aca6acb05da7c3d53ab63541e8ccf13f2f82394aac3fa1dd1d4666701fc5a08cd97f230e27c0accc9f75b64845a8a319aa8e1010da00cfcb2620f2ae1680424c4ef9177d0b1519f7bb2fb1e0a6bbcfde8d3f899e63ca812a2b1310d8ff7e4e69a862232350b2aadc697e42912417530543ce9054b397872d36e1c72dc75291f22bac4810e710a431ad7f233477f4f0a4da601d2713f41efd39d43d7fefd619c79d00b5adab2df537e952f6a837e42b96526b4d3d0cc2621ad93f04dff9fe153693a9b57b508d64e2116eb13f3cce17ae6fa194bdcbafb4da84c7e36469e6f5b03e00f29abcf3275485029b933265482f366acdce23271d4aab9290846b453bd94aab190d4c36c5e4acb7f66b7ea0f595a7e3500e16f9c081684124de63df38b8edff2da30af1266f6031e0230477148524447ae1b1b8922b927d829ca77109748e0ab5adddaa09686294b756a173a08f3a1e4a4e2ad073e032c691b1053e8d8cf0f33817fbfbf7655a769a58ef3ad2ba2de79f5f746ea0cb5fbdc6e7dc2e13313d3f7a4dfb0e6a2c1000f474efd5c8f6c877a4b57e3f30de94be21e89932e8a0ff9367d99b4ebff9ae91df33eff8cdc47cb2c065976fc30ec5ae2e42f348e1a0ff9f2a3db405f784e9786dddf0176a7532a3c76556295903548feb35b2fd2a514aff3c67986a64aa51ee924427fa7892e13499ffd95f2fbad9ef16a271c8da3070604b329f8263f063b19b8a1e8de2f582cdd5e444ff19bc0355b0758013326de379c5e87e1f3e695d2c2ab37fb0077b9203144d5565fe614a3975b9fd6a7e0b21875b802a069dca7f26e8e4bce30e28e66f919f49f03668a291a6e65cae702d0f3bfd111ed346b4d7a3579748933b82190aa87b6da9eb2d1ccd1a5c27eec0af5a096c1aee91ccdb2cb1a77bd5edfe6aec2245d443f9ea7ff8674bda26ae88dd960de26076485e9fa7c61a1292cc507047c9dd9040976789bcdfa512690a635db24bbd08ad6642a8855def55e09992b5733508a704064b65ea9788a0f785f07915fbf22b0317c996324965b5ad7f3e470cdd8920583084311d951bce9eaf5d673e02978d7afb73ccafa59330bddad1247c14fdbc9e65892fd694481fbe995bae573325ae21002bf9c9f09ec7cec0d13973190ace24bb97a1565f3dad0b01b57e828f85be15ba833beb49955aa44b1b1b1bacecd460ef1128c184bcb5d921ded0138580adbac8a99f532cc879498904e99bb03729b9c923607599ee03d6489bd3ceb259e8e00ef94403b6da787014b2a29236bbf210a36e3afac89a63c29c22905bb7fee186a69100431a8e5fa247c6a96a89afbf751b0aa5c15dceb4ae454089d5a2be33a1a202578da5fc9c4a123b255cbb00c46439669b056f666de01b8cf6cc9f25d5bad4fc314fcfa3e0d0c5b62c42618ae1e831c3c5083fce1adbe17607f6d403c3f43b04a450662151bcf9375a15156cec3f9a9ee39e0614bca76544bb27596359584abf2ba92bfc8392c0dd1fbff65c355608d836fe9628a4a624621cc664224e2c704da090b0a2852d58cf4de9d14ec116067335f8dd8c0ab4578b6874c38ee98ed8d969a61f97252ce2d5d7614c766d35c8e52e7f5d4bb944ecfe89a4bdc1891fb0ed8e5a1c5233d579c37aa701ec57a7ec8f98c80c0a1e88f804bbd85c8e4e337151d30556cee7d8a8d5243988eb3f73eecebbbbf4f70c286a13f67fc4b10b0b891e9382188f617afedf91c973413b0520cba0ce2ee2257e73602378df63f2db49fe790464c0c3ddd335b45cd888c788fc950615861228cb9703e75e77de8a257ba7f58b9ddc1897b70d361628de95d32db3ec14c73b998309816625908d7352e89b989dfa05b7fbd4ffbe99a2fb9f123790c9c18fdd66339cd0492523fe68c33f816cca34f03432b371d06b9020d6fcaea16c31a1f9412a0c47d83747955c08e7360712714d19fa1246581d70fa2b8850fe50a925614a631924d502280d0d2f8d93348898ab78005cabf7d0ed8d0d64bf0cb3b9ff5b01af8d5d13e117d4b53f6b3331f6fa1312484d0fd970b769be59c725ff95c931e3299d5d27ed404e65c786b5c3089261c22dc37c35e7ca064e4c2861cbfe6d6486b737a2c40bc721c406ca5433efa6b6cf542b60cf86abcf4cf12a0c9b29675081466e1fbe4138f3e4e99e6b72545425baed1d85993d9a9edef43edf62a880a0aa1b8a3480a4cc3cecf2087d03aa10fc18839490f7c029c5e4f48cd5a66432384f6308ddefea2ec281dd45299f267a8457c2f8e8378a88118d082792bfc3de63ea3f04f67bc1b5eb22dc7a9fea9efbb30c23f966603d6c2ab54bac62adc2dd43f735b735d998a4e9ff9482ac3e41a1ad1218f4481313d1bf534dd31ac965064c80affc4acc9debac9795d9970fb9adc1cb8f004ab121cbcb0b6b96003ff47999dcdfc0af1b664aa2b9f6b3b303cf91fdd2c9c2af735d6a39a3d9c3527572c02eb6f09533a42e03fccf4b9d7ab664636a4efcde8c04c81e21ebdbd94fd22e436f528fcb4f7a8989ad45ad4ff49756f7eb42ff627e6868873faea9ce7a6c99ada842e497de70cf68c18305deafa60db4754d26bd366f735c3a024102bea0735d0eca404015445420277f2b081711f2a76bfaca9ce7de5070a4c40d87b2be4209aba9e1a2b94f0c53be7003a5a98d5bf9b195d4afaeeeedc56878ad437371ac1e272f4d151dd5ba9e82ec69298cebc27ab9e22f9e97955508a3a1c548db29c7e90e41ca332891a744b8cf4733b8ac0c93187cafb669dd620878e878bced2645c55d4af79cfc238b5f338a56e4982838f5ff0a93c9ca312386633a04c87cdf0ce7664eec12943f07fff04991662de2243fdddf239446150e63665fecfb9159897860e4af6561af38d5f25b7a70595e60a3a31c075d193d26bc54fe65994b180641ad02ac2eb066c1efb4742ecc97b1e190ac670d463b868745a8212cf91d902903b1e94986763639a5e436352c61e84625652cde48ff863f7bc05851708164c8e2faa185cb6ac8f22b3fd44595e1c4404fb5f832d41f1826d44bbbdf4643734a73f348d7a8506b0c7d6c869aa15031788c9d68463d6acff92e85457e28f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
