<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8cd21f435e8c50c03f661801381676040b0cb37aeaeeaf0f40f1b050fce6c275e83bc8980aa57c5f8f8b83f21da739afd25d00b5e54a70d50c44588c95b1c597d2645a09b0546547bddc76be3a9e8e5f4c54133b34ecf76c779ee430f6dbcac59e627efaa083044b6263a2ec040faafe53913eaa1201895525f78455617fc17ec0406305e17aa41c93c6ee483d5daa212b0acaca058e183b5d2520f03479ab7f99c6a8bdcd5819c4843241f9aeba5aa894639a97b4621c2272694825dcc82bd668e4d96b10ca7643bdcd9150202502e833bfde0c69d722de33ac5156f544884fd007ecdd169bb1c982c1a2faf2e658319104ec747b891533bdb458ddb3c371d83f6ddf1f7a5f3c17c73aedb89cad258c0208ac713c9d7e4dd8b4af51c03d1305277c929abc886a0ad08f1dc18449b39d59fb81a11e380acd4d04f75111c5e40e2e09ddb2cf3a68bbf40e5cf3b722148b5b12ce43555e02930d41898f18773c591c833a226b4f11177dac6e24fe9fac5e3092b5ed421c1652503fab457d3f3a17ddd699b7a45f671f8a866349b6f9878c9fc21a72b83f06260a3add5130e8e9eef7f0d902174e72a6acf479a19bc8249f1c151945fae724c85cd7ceff65f059d5883c19d9b5f05482810a65d02289dd62a49eb118fbdeefc66dc03dddd62fb25e53ebe67caa4f219e93827e7f77c5fdb1ced6e8007d0443125cd70984ef5851a65573dc5060bc336dff4d00bf87e5f52a6231c29edb6d874c0b2bcc1a078d7fd0941b1febd93d763eb55d2da116acd439c174a54b8cb8548145df41c1b3d6137ff1d4f4122a22e7ac3a9e4615a4008c5ed2ebcb839fdd161a9ef78237aa040048105027c5bfb419672b5214bc06c3be0b9e11cc2a5cfba5bace3826828ee0009aab5c7023e9178d71e0b6dc3dc75453b0ffdd3dc75b5e628bd22f8bf0e68151eafd90fd1b621f5581048af94d691f47cdf4ec9a97aaf9137b7362934b3671cea64676c2aee8ae77e559c8c21bf37c97f0a44a1e9e23ef424e55919ed940018e30e8b94fe231ee4b5d71b74d8441b5a1dab5a770915f34e1e043109e32cc9e61c7f8cf28b4a4992a736f35df482bcd5173c30862fd0f072a5c4a45c1d1ab311fd3db2a1e030e0520c7142383a2ada78b650aab7f7441dfa2a04dab28e4a60d10cc7b9e6f26801e0f0e261ec6cae543f7c201b666dd0911221084815dd3e0109dab185a24901e4e3dbe3d52d9cb496607dd8e23b3a44f9aa225bbec2f45f04a22a10fb640935ad722966ac4bc69352639ae0f5153c228ebdf874a107a7c77635f2cfb70aca997076ead89029ea8eb1bd64246af2149dc3c9eaf5aba7ae6816a941edc1fc37e66fb39146225c66e889d9983f8658752f94343c869b05df4754474f996c88b9d37b7270e0942c301c4d89ba9e4fedca815eba0df3fb4181aa3eb37c46f4042315f221149ba3f4652784229e1f36c265d02faaee49fd4e169865683190c15fd1cddafbb2328417aa5287b2baf159b7651512c750c1cb2f793c2f7f631be4e5076344710e09e1f9d34f8f52fce8d7d3c7c282804655e426bd2874151aba28cb50740e39357864a16fd84b0a0e8e39daab007485475403c03c2189ff34c7c4265f25e6c89eb599003c1a53ef69da20146fb23f45fe87d273527b1ef300ecf795de2084fdc8412b4742f8e39e0f9e76d44c765c7f58482c5b9ca4bd5548346cde8d764e53c8ada1d036b250936748fb610ead1b2a37cc1ca20905d0eef8fc214c911a4f6ce257f951c384b44a4ac1b6f68a7a8e2beacc4ca8a2464f666f191266044f49d24e00d24e10cae18404e2dc6aae6983a5fd71e64cd364681d227df8722ec3f6c40052e860dc9582e1a9731901aabb123ee2d80ba7a645d7004ae500849e4a3fcfb88f3454a78432eb46aa0c4ea5db604d9dd9205980ea58db9170babe1b9101c8bb90f6dd602d9ce1e90921e5db1a633b42b68bba6a6e1febfec34045af32586f58e133dc3fb2d85df241600e6d44724550cee411981d21b4337da1a0f7198f9a60df07db02ab6db21cefad2939ecc61aa0b2d3fead57f57f1ad1cf067fade49f853c030161034c955a447fc9737a176a7b4d4af217791f23a4ac2d6ba7e1137d60cca636711a5178b4580a20787b39f9cbe3d097d9682a0e211efa3a00a98aeca2555b88e7b7ae9c0ba2831755f766971f86afe7576abc190ec02b928a37cfb68d3e129c283f94db1a038410303bb84f5c0aa1607658afbb0675b7083c51b36c12889c0a2965035427f4bf517d3bf0cfdb5e854a36d8568d2905919a017a3ac29aa13fb31448c1cbdb313f0daf49c62594586e8e2db0638839f4fba9a3c26722b46c9f9397fdba32fd52a005b1445bf5b03416a13c3b923a937aa2a664ab3022a31b14b285c559ebc2cb6a5a80bf4df6bab6103e0a0385c15cf3960168d74d175ae8acf90edfcc1d690797288fcec92b2a9f1cdd6e10ef8cbfa0ef724bc2039ab36dcff2dca54264bfe6ccec9f16e8c23ac5b29a37a375dc79361b32efadbfda869a4a42884a6175ca9b021c2686c178f80e2dd39a1a76438d7a7563a43be79eeffe5ce955ade901a3956875e68e7fff9b85d5ce357f6cb4ad8648a6f9ea0995e573cf33a8a8ac214c23c03cc56c76eb7f413271aee5a96d4e6a879ac5760d8122bd6d08b37c00a04d90b1234fc400007513ba227508333a342dbf1f4ec79e6f234bd859f4065195d1b98747d9354ef67f02d641641a4dee0a95ffaade9b74e6af42b10ecbd5527efe0553bb24f5654d85d13988eddf5d740bf1c84989392ead99a5f16c63be77632f3dbad51934029303a77e026c74a1a2e027b1c3b7ea0614dbe32f92423c87d2d47e3f28817e3a7a524c1aad55b5981343b18736ff5c7fd6a0000cbdcccd23bcc2236eca360e211c4d2213ba89aca3d4633ab76e34376e76c80be05bec76d44fd5cac35768157f17e73ed21b6218179d5145081cf3d3264bdf954f7ae07900e37d057cf9b49588a5fa6d2363cc8287530ec39a3feac866777e7cf60a767f4cf6c4a85f5cd42ae9e63c9e99c79729e460585266d23b52bc458d1f4f55f4d1bd494a8bd6da6556639008ab0383e180d3f0dac3b91abb682e136431c65c25576f0813a43a51a0b046136eb96b53b5f0d184f4108235394e6f04a6601c75e6f3c1d1753ad3c3cc57fe8b24286471693b317b344c2c60003a2ddfcb62a9815c6143801f085769d897393c947f5d5827b7e5905850012c153e7115242a33c9e2e9ff341d5776db500c0bc23df7f88ef4110493961a5de28935032d0a09e013b3feca1c9eb08a0cdca27c4528db08ed43746c0e07e5bc79b42df4bf34344d55e0c034e832d45cf4d017950da96149d3ea0e3d917e8f888b7bfab3864140adb7ab91f799a974c224bc46bf36f24669dc9a592cf6ef6f293e89793e1b43fc10242d426e166225bf06343bfa92fe5db5ab7c82be5312896382d32fc4a2c83930d4cd3dcdfc5b6c4f17e5fab2763fd63e7d8e24c9a014a378ef563a2a2e4e463a816383224aad7d3a72d4609ebeee4979c53b6d876944faef0705fd0d194959c19fee532b5c7e260bac40ac7d781b8b2375cf8a99c20c2db10db586378f4cf16f561a200019be140b2e8a76d7958599e539a7404431b8931e6357642e4c8799ea5f56638a0812677d247c860fcac8d088d2f3701720d7d9ee91e010c5c20d6c68dad435680b6043f9d2f9444ea4f3e4f4c9e3e7e4becc69b4990eed5bc40a7cea10c851642f3264f9c5ead212723b5bd897a7d4c8ce1df903f785cc9d3008df86231ef02d588df3ff0eb38674dc084f5edb48553559abbac439fc7e4fd9f250a4e6a3c1d9336f5261a1c37088df3440b9e396f1bd8316532a5887284f12695d9b9e2cb9933cb478f6cae2a331ebcf657d907f9911e2198346e99df278d700f566dd1a87b857657b3ad148b93729c5de4bcaecbb004ff987decb1ece8f0a9edf46a1f3e9f3259261b54a0d082e56e173270406cec473078120973777915df281aca0742ef8f979af11d16d75098d768325bb944b77f786d7c4420993c53941f2206ffe45c48e10c53f78c1488500ececc4f01841d8cdd708ccd962d8fdb0bb23d098c25d3c89428e9b155617130ea46aa2503d21a5f8e084d3280c046e7ecd913d99dcfc25654410dd6813500d720b80dc48989befe2812b56661a590b20d19c81343aec20a753b9b06c24348d9e431b92322a1d77b36d0c6731b1cfb5c167cee30d9b8e23c58d834f2baa4bc062558d4b6abd0ca6888cefd66e5b38d6dedbfa9fd9d2a177ce53f3416417636ce54d881a012d622367abbf510f34b6035e0c89059a2632b85f4189109a20804bf87b109729cc31925fe00332c1807995d400a67431cd7a27d3e86a3e420bb555576b33c8b14299e334c77cb0c4d6c87e87d7678ee7fb35599f2fd00d540d271209c9da92d3ddf6d95f4ba6333e7fb35012a889aa61dbe0b076f02351bbf7591f969c1b5deea88b27ca7280118726eb2c6d2e3c4228d3dab4e133ef2a955ccf0f9660a4cf244f440ccde7819b56c750279865c2c1c200c3eb3a7b051cbe5c6d3a87fe4cdf0529da6f731315d3e71a2182aa9d4e84983c3355ee31989f016996042b71c3d0cb6164b7b0d1aeef0944b9e9d2c36c99ef4f27baed1f71d2fd67cd2f9f573c4fd0bb145e09274ffc4e22de3edbcde2aa121a9151ed5eddd085e9ccbc5b9b90601974e87cdf1f0dd6bc0be54ab6748c67804fdc86c793c4b25d73663d5e46a37ebc2f349870ac08a140d08910d490bcede6658a1c5eaea643ebb7f83b5d8b5ed16053e9cfe351f09a8fef2bf0a0cfcb25c647b882577127ab5c85ec3f8e8c55a5be4a84fa2df92e6971a9c96cc48d84f7f9973bcb48419a6c8e6c6e86c5efafa7b6f203bdff4abae8442b0e82625faa7a6e113215070ca7bd88786d8d50a21332dc40ae79e40f6faabc4a5e7dfb49bddd1841b20eed91eee22af082c5c4bca57760bd1d2441695f02fc6b6e98dc87a5413a9f2ab318fba79cb15f1e9a489040cb4461dd5dfc2dc2a545a1d98890f9c3120c92bc458bf9d969c3221aba59bd964eb0b007bbe370291f662d2c6778e56eabf3ad6be1382d77f7b5aa7e1c60c662ec2be484363a144655f2accb1e023244bc63ae6b4d271c9023e978b608628217c0564e93411f30026b44243cd30b06296e7b2233170364d1bb4549c08071b1ab771de3aa42bb932fac02a53e04a4cf6d0fb2f63ea812965b2e27e8d43f9f235734b1bae7527ee8124b01cb3f5ec7fea00edcbb24ffb2ea322535907e3c6433cc9f079824e778fe75de80c8b16b28f45b364fd4fd4946a9d444d4a631cd8b193c92cf3041c93e730ce952b66d726cecd5d1bc57008161603a4875dcc1f305db31e8e1a4ba8f1b9567a60a023253008dd8bf6896592aaab0dd779f28be238ac6b4ed3cfb0c778aa248dc1721fc8129f73ab4c00e92f0a9d411aaef888b80f26c1971f583dc1737e3495be5e1d9db7474e3743996f6cbf766d212065850e754dba0588cdc9103aec11c9ba5f5123b65477dcd1b595ed6aeda6a984be5cbdc1ef022dde5c5ef85c50b22008449a08e659e583b69fe7b3d11c3b16b286232d8675350821d4c4744d721c0690f16e21d3cbbd645e59377f5a8c33152442cb005dd6fdd833a205a34ad3bd547d98e2bb31c57aee526365abe78d23526f664fa72e3a4b18b250da79b61ba4e218ee83fbaece7cb81f5a112f36c7f99ff062b2646b6e4e281a6be9cec8df58e9710c636c1391af351e5a247a55adfd7cb1a5252ee3089bad1aa49ab6318c7957cfb618d11aea7ffd260dff96c57e6dbef0a669d97234b485672a2dae8288b9a7bbe770c8d4d7a5b328a61d6fdefa75db2513b35afa312277f5c87c21f987c85ca32c5c14140901149daf784e5534cba686fa91387c174303c8db5c641f6d98098bae6494a5ce2d279dd6e81aee7c328e20804303173132c3472ee11ea51b95cebc4af41f2e22d021a3700c7dfd1247dc45ddfc983df5cb971b1230a4748c9ae4d5be7ca8e07df2d28bf94a5fa88193d1a496b9fff54750d3c1d776053f7c5a09c229e986216f6306d21b719412f74720600fc39e7ab04e9a598a481c3bc0ebc6258f8c5973b829e02a219f8a2e4fa41ce26a28dc3a4d586e08f43c482e55f34ef9e9cef428128933a486d8d5ceb545f718d0a5fb1da3e1211241c9f6a339352b58596d271abb13e9e9ad2b3ed16c1edafff92ec0ea8cfa9f7e5e4eb52529e929f44c62aa1014937f5e632087f46f33b202012d93f3eed8dffd015fef3805bd2d9b9b16c090410f5d20a109daacf46973079229e740016b4b5c4a0580e78596f843ab6db0ea487fe5e0a446553dd9e7927747df2633f51a6e8025c2d3d5e177f3d2cf39e06f37c6edacd5d40f306b8a5ebdddaf0f9828e80adda410de34008c61468e59cdb38903a42867d7894bfc29218112a8fcc3bf6de2e2ed73ca00dbd7e618139ee56ec18c8bb693647119e13cd206c454237d419efc44bdf6e037e227d67a946acdf453d56f1a707b78a3b590ae2fcb279a1976509830814390b80dd65d8d05ec85835e2bd2b4b6c8200dbf3bca2ef509b0468c0f52e7298c0aa966264e84ec261096d8b64d7a06d1ba9e6baac11f3e9925aee69330d3915cfb1eb32ea4908eacc90f5aff6eee9cdc9d5cab0963094e4d2f5e2d3da7d3f7cf99f9a23540150fa93a0a760bcae10abf15846442f64c49243439ef53bafdd4f116812d879fa8db03e94d03ff5f3060df4c0e6c6dafa0fa4d52acff38529eb8372782cbfe804291a81a5cbbee06cb533707542843c606de5159e3a1097d18f6e7eb65f849b8d15a8c26cea06f60af58d9d738877d76e6cdca21c17d63ff132f212bdf948c07e597ba9e7243cb082a26dd8d01df8b3351aeb92fb1e5ffdcb05261b382e92a4cd26d20c25b515a3412f7f51723ea965a00616d99e64fbb686b91dc52c44d2a633220c088c38f9a0360c9567e1570797ec71447a60cc6467a00b8fb0ec6736d41cc8a89bd80d2aee1dd69f472d5ee5668f91b8ad299f12cd2d49fabe1647c7fa635ef577bbbeec25ccdccf155418300be809d159b2c72cc88cf211b11d48667e2766c5368f5ba818200237283f11dc56b834d9c4c977eb10887fe67fb21ee569d6cba72a22cfb6ae9e254c37c83ca289940744ecd429261e9c839cf8fcf621381fe4a6db8fe53c5eafd8df3230f038efa3decbd56c455818509398632db098b7fa1084803c55945d4950cb12b3c0df3e72ed7440210b4feb7e8d4c74b5461ef4fe35f938933884a72bf105771c292a4c293a4737a501056f8d97cd4ada295e62fc075f6e399f363bbfd273fb531d7f12d20d090483b05abac8b0e98fa42f1aea3cb440dc263c175d99c8940113551fdbe536ddaaba23f2a49ccc619c3082602cf16d0088a063cf1e20404555d7be666b507ab6f3f69059bb55fee6aacda39f340dbe0c362a33b6fb4e4befcabc7fe6baa807b910474797f5e9000f0725c02fbb6b56b3699b2424e23d89b052d7d2a7ec6cf001e0583c61860001272d42cfe7f55190b0d50f590180717bcd3d9c060df5205793c21bcad65bd3e91a82962eae3204bc31a44d36ab8b9d83a0612a69a112a2783620825691e232cbfd5ac730d353fd5e7126d75ad4684db739bfed32b41549dcc8f0f993714e66a07c3a9927a1d8fae46d1f57bced7b1c5bc7bfafb4159ec4b61457a0ecf1234645a26993662503f66d152f9b1084d1f3683dfe528d65883f3afe4e102379703e04e6018d9d7fe95ef0a2df448985299ae0b8046b8eab951cff23cc3392bf27625ba8a034b12860682a4fa48a17da3dbd106ae23fd1f6ebe46f594c145b6a6e6ddcc0a738cde30ce1b0a75dd9927f716f69e6b41d30fba46c1941e454f0eb55e6e2ed54c1b79eec38791a70af94f45e24ddc0943f356ab2d664a774fa9a8a39a772fd191bc5685eb8680745ae25be34fbfb4bfc58b2d8eaf247922b4abaa2c9fc139f53136c1dc5d8a2292856bce39175f7b1ffe37cb6dfcc976bacc122377b2ec6fbca89b8212327efe1d319109bf0bfc85e5b6a0b0839478f4f53b58e0b893115ba128ff092d901dd75eeb6c33755e676731bf23e203dc79b8e8d8a82456cda73c786b1224268c880a7d51b43c1c20e1295c2976189ae2d9ebcd9bd5c4df1b47696a649fdc451337c2f85db142efbbbfbdd4d1b2bf92e999a75dc4fa87ca300a85c88a95569a6c688c52202d3fc44ea6f2fd3faf0e8b324c3368fc278659df01e69a07f5266a4a9a277cb39b647723d04d876a018713a7e47501a384c255fb1ee5753d0e5886311c7e7734ab04ec07a6c02ec74c203573e8f970ec0d005affd5b5c32d460e85bf3c08f02f72da3f13d1b53a0bb4b28345e28f4aeb9b992589aa1d9e8cc18adcacd2731a245b95543f88f5120c46c2449a4bebbd2fb74382f42ff57842f2dcb872563cb401f39277cca4a54b9309a2fa88b58d38399e6ee0bd1c7734bfdfc7ea843c2ddc8eaf871f2639758cb70f479c76366c2eb72775e2c4c5c3600c6d05034878ec8f324d08b56f006dba70c1b373163431abef71f64b7ca07df8ee00fcdafaae8578779a6dabb93de3aa088897fd29137d9faeb6a13936a948c58695414f53785aa2ae76485d848379b3ece131f44435c121c3bfeca261a73ef409776a09fd4701c7e76d57b31f05502f46676f622df71fa679385a4d6cc025bab22e5ac679b28284fef4513430f1eb2f0a3e4bd96a2c7815dca58cad739f5d911e20ab9c7ab7f940443fd32389abd7dc076556dccd11aa40b6f081292100906618e8945df626c883105694991bb237f65772dbe32edf52b92c2faeee2df498318fc57c8a60c65066d30f6e0444884351e2a2efb296bc3b460fe0f898938760f466cc58edfda88e98a476139c42e11a910a72e1d872fb0bb0eaacaf790efc83228aafe0fc74f0d32f0e3f5e5c7b60934d7d4c39ff34120a7e9731384324b9bc60e849696e3cffacf8b5f924244396da68b569383bf7945313bfe18f2c3aa0b9a39546f17ffb0aaf5581e39d0f33377ebeb45e53791ba1ea7a244c57f024512a096d07080c73105c332d3a57bf2ce5569bde312fc60f3ce4ac8706af23036a58aaeae6fb1d4004e07c578be56aeaddadff514fc6b030a0de97e1a8ac24f79b7d2dba67328b7565d0f81bc8ce3fed65fa52337a14ef2424f907867ce0ade3024df46652cc94e0e114f84f1800cef852acef576de90a6f966c247467a257ce6c198fb5fadc4bb9f705f574ab1c310b6247dffe142b5b8f2a874d1b02f75e3b045aba018f9341241a8d0afeafbb429fc03bc2ca811b3c29ab3788703298b0d1ae6660191a801479eb5dac5a152310f57945338ad0a4836111febcd9de2339403c18433386cf76e9dda6db1dabfddfeda54ead2c59104561453179f4a95c2c0beeae17cbfd3c6971636fad939b078881c728a65bc0c9747f53a05cf5ab001614ee528a02362ffaa77405598da6eb2efe78ddc088c706118050f34db3a0d4fbf760c8493340b04a4a19ce269464f89ccc685e39379c72f5c5d0f5cb66832c87cf1f1d02ea975dababdb6e352f50051be264f5baa841ba3b5db518db96102bf58cadd023a5feaa03583217e87453f7a858083bf0e3228153313c144c18c5de4a0c6dc6ab944725038effe9bd2bdf9516d9fe1430a5f96b049d6b1ad46afa53f95c28fc320c87b774adc6b6225f417cbf72350e87f1ca376211c3a0b788b34df03a51a216063bb6e0133a48c4d427a1f30767d61878b94061c9008b6bb34081c09a70849c392aa9144b2af065db11b689ca28482fc6e35ad6b1c0d70762309d19d6ff7420d027fb127c7295981f415f581e2591f659498c756412a10ef238b85827416d07a6191e0e97bb6687abdbb16a426f4b1c916cc1de","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
