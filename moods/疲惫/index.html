<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b431e05f71d9c48100b8564b1baa68088bdc87b56cdf11c2e13ad872b58f210fe61cf18ae55004d199582fe62b1a52aba0613b62acb3f632cde90942194a8f3a463e3204f4b1943c401b982d312d294c0f0dd3eb820c6413e6adf4512dc30e0f83399078e4de3df6da18997206c3e47ce62bc30d4ccc04829ecbd5d958af1abf6d44f26cc87544f34d5625fcac002f0c918dd7498d206a4e07ac375e16363f91ae296ad815eef7d64d2bd5128c71f06f8c8d068a8ca4ab30feae81e21e6b5be7a43c5fb1c498d1b652f4cc5b1b8b25b0e0ef55bda4b3d9d8fa6f67173c4c3272b035a62733d6f024dae256a55dae6bf7c50d07f1ab9e25d3ddfff038cd6156a4019f45b49d6c23712a66bfd084a8d6a1f97375c3bdae4042f64783775757fda1a3b99ba5644bec740803b641761e9469dbc2b988b985629c0f529d82485eaf6b2cfae5a2a35d99e3c4f2eaec7e04847f35ea07af17861856bcc5ec38a58438c1aeba0984da327a34b2b5d68aa09989a21501f7f75530ac72e973392a9172f70b9ffa956b93a1978b0ce7669edf51f9cf3282a9fa10c494a2d65dc36a6d4997805b05f850acd8bcee94a7bad3ff89f06958289a2bc857aa93b22834b725eb4d6d4168e43f098102c985d661873e0730bc2c46bf29eee2293b258ba6da1269540f4c6edefa52d1ae87e251a4b6c6ae9599c9e2d45349ffbd79d1a30d53b2a046c3814496198629abe08609331913b9b592d41582f3eb53ef4be85646e4a7f5c4ca012c0dd274bd0e8bcde28705b0e133eb291058c9c072f99dc35ebbc13b27a248f96d7e48dcd6154192d0c881fbc8a1c9b4a561273814d38e4e799e2e0aa052e108d33fb7c8c841ecf1b3d877706888afef8785a62dea3bd4e424e0095e96f7bae27c8e3ab767fc3feafc8dfaaf61bd84ed452d3e732c990ee822602caa96dfc86788d88c49db77d1cced413597f9b24124f9c38534d17f367b6becd5a7f16efaea9eb87ee146b954b8f50890617bfcee969042b585d84a37e94741a9807a55270b0938e6f53234d1eb3aff4712958f2a558cf7113ddc31687b251150089e4ae5590ab13f33ee40861a176622d036dc3efbbcf91af05c5190544209598958c4160bfc1fc4a5b43a0a3cf618c473c1cb862f6bf1d761aff0abbd93e9c2a70590cffca695beaf625e4fd4b98cefdebaa0216779254b6f7baca6aba4ece372501661018bc51ce737b221e82d927bf2482ed0f28b434989e73e0967cba041f7146043c1372df1a5f0a5db253a1ac056a4d8a056ac3691552ad2e3382b3deb6c6aeecf8ab674b3a98a4b305504aa9c41a3ec9e5bf8374169b39bf93a8d6ddd4b08fa93c69ad5d5f27b5f3b0eb329f6ae60eec82f77bf84bb6e2a388b9fdb8bb23772d7eb401471080567194811a9917a4166d5c783e199696b2d93af326eb6c51f1437515c88f8bdbdf2e80d4697398afd56a52955c6eb959d26e316ecdaeffa1fdaf8c00c99e5736969734618563db3114274ba2a4b91102d0bd2bec4d26feb455b291b5fb8df6ceee9241c180c14c1b473f07f5574c8927b4b93d648372304bfb9ef128caff6d63d2ebe932c5781fefa74640d731d19f812faf6ca9a8ae324f6ddfbe41ba77b51942a8944e9f9f97256fdca901cc83b927a2cccb79c23e2c0ab5faa379b2ca6d1a9d227ac05645e22384b168736d9c8715f3964564d24bafa643a46269dfa0a9e8e02f1eaaf722eea03e7767b432353228a8739d6af4a0decf8b4feab5e98caf123362f190314c828baa4a68d0c8569335c7fdb6ca823c4d662dc4d424c1ae66bd42db7ba39f31be30ba2e280c85054db503552a30a0a0bcb3c1aba6c8c0f7d44a9b71e547c5359b2dbc53c288cfac47d2031c267e2fcdd0fded232b2f4de99e6a829ede8183b73512bff4929c61ba33a2a25d59a49d173cec32897a4f4052b124c08e4844e13c4e89f5ff61d73cad7901667977e66443820f8a1325cab7a6336298c35072c213bfd4ca219c40d3ccbc87017611d6ca3cf564e79439863599b498824f4185cdc1704cb6ecb49588d8a3b102a36d433bb523be83717a3b27e0f0148d6b6b419d72881071c9c99b3a96f0e22d24e689e46c080d3287c712b45f45c88a717fdc2e301f6da7e3a7145d5f62652defacd3dacebf60bc672821e5181fb7c06289792ca750a0e66cfc46cf61fc661830a2651a776a3275987a5848aef6be2568c69e3326a8b85700d1eb796cca3f0f4c0ecd1a4a59ebddcb14875a7ce8169fa95252e448df668975b94cc39d488b2883a23ed70ddcced8c4d45bef398f7de6054269a8b823004dd4ec5c018b4cabcfd56449fb7b5316f16351a4d35f8e341ba2d1adbea07e194b4c389e818a3f5d48c9d204cadac1455676c437c276b85047558a9245cf09400114ad9c6863dcf1707400de13c7215961ea110352d66e5a7f6797a06c1e9add2ce57f1cdfe597e14418a95320100518f7c3ca0797b927e47160188ac1b5e6e686fdd42d78b9e150db946031a663dd63efa44fc0268ec7af91d8c6c00fde48060fbeb1e927568183e30a5f31e392aa56bec92a5d75caceea583782e4742702da1f211136fdf9576cbcb69a0073733b8c63fc83d4b7329b9b997e7e7f837fb7f9f53d81da85a1f31f8d28ec8fd75bca2fd1f016751180b385bbacbdfeb2d5b6f423f63fc84d93a13325f3f32949adf629b3dd2e8238a9d2915545f324a74d883bd5b5c8003f9ef8e8e7596de2d297ecb80d5e1f219b08cf85fef32e5c01b95f20515a1f8e57022c16b27c99d056fd0ae25d73b36516169296f17836127f5d90b0e5077eed21037549651c9441a6268b274284e3d636805fbc8dc13f565e965ab63e8f92c2108ca575a735760066bca29a1db0ff18c8c0d114b623173370d838b36ca796fb4841b17b5a3da722c592934b81cacbbf1691d10cdf028254abfeaaeb040cb7822eff47edd46d40326a09bd4604851ee45c1265ea9de62d22a76e9fe9090445f7e23898e6988e2240afe527a64f6ed1485cd0a930e822cfb86d55f3f82afeb1876d6e3f3e9623e4a7379023307811247ea7a8bf9ba49bdafa816882e59cc0947706e0eee0ea4377c717140b131bcfe6d38143cf76c1c7fb22f5e80c047d1f40b3603ce4f9b1fd11d117bef679baf973e12f63b5345dd60492506c7d6f8fad47a65c425bac69f875b9974587ddb7210167c372010b5f10849bbd694c5b2c89e286c6f8124346d5fd240ab77fe3f86e1926daac8d7fea9cf49ab1d34cc11c53fe5e08c5930797d6e3e17230a8a9ce5004e22637323daa4735118914c708e8c02030ea1759bd595a6fd6139917abccf39296eafb25eb6ea5dedc57d97df726450844b201208cae411bfeb2cf876fba143ffd363fb60646fa2bedd00f8664c15748717972f75d1a20bac94b17024e840ffe012192d1a7d1eb1afaa417d55376a368a29f8ca89ee9a18acd7e81ea727a6bba019d7b1548208829102c5e0f6612c6ca82022c2ebdef221640cc85d15d9aa77cfc00c2d15a4b7f1d8cbc85134aa86c6d5489417ae8829fc52a2d5cbcb813f4cf346248090a46ba7f51746255e6af1bd91fa518dd663d8cbc61399a97b3795575d571b03c930bf0606791af183f262c49bed72aa19f9d30f485d766c7d88c7599c7fe345d86f6820263652a6d348ffdc9c5b00b1ccf0d25d846cb287a9c68fe76644c87d7b06f8a62bc9a86ac4ceb783ce8fb6e5d161817c297009971e792b73cdec883bdb7839421907a46ef42af4453be874914201e9aab075bd790fc89f0b435386a20713c2d2d2126c21978cb9b2bd65d5134f3722387bf63b69c4fb67af63fa39523c74b3920c9b777e82c8c7a2dd2d2ad173e868d172f713627758bfe36d8e865f0de4cf948433daa65cc2f12927ea1b451639759342e992f3970981bbed22953f60dfc4afa7b4fe0db6ccfd71a3540aaf785efb1a00c0490219a264b3e59cab7c4b6c7d748e7cb7ec4e05c90fee319771eedd13ab4f8db92dc11cc8df5916ccc893428c3185ceb7ae920ad42b9b74d6712d3ff08b72ad31dd3ef4fe755d07586709afcf71a060746c58fdb1be88749272dcd5ed17f594ba93a3df389dab3b217553b177844d54948b7783f1d4268292361654bc8af849bb51f943c580a29eb8797e4ba6d66e7f77500a61cf0979fbec9f2a5a518771fa6709e0e60787ded931ffaf18e68a9d27412555241aa698e76b0e9275ef1308a089399acd1e39aad17a9a6026909762ccd546ef82a440e65d7bb71b77e9f82924ec7fa5ffe1b016f066005d124b00a75a3e088501d4b26651ef37dc06c3118c980a25763eb5c4b36d65a818f28ae827d86931e0775161749dfb30f7dd92ed16aa5e4566e1828855db207ad495ffe15a7aa6fcac10e9e3a6e9511202aeb474db1b9688f1dd2c03d77a122a9d967e768b766b56e60f106f8cdea49829ceb7a330e2ac74a4839b8a4cfce924cc1174deff9ef502716983cc89beb4ca46fe6c77b1d10c73d66c0e82f88c9de3f969c10f5188d0bf52ec127d1b780bb64518f0cd786faa18ef3723a8a40038f6aa5708f5b863180ea69298eeae939e61b2941e2599e78a7cfccd1fde250ad4c027621aa038cb25d8f67d699db1075e162f4cbcb7010f8b89e8d62e9da9b370b47abffed94a2c551f8a28dec9e2c96fa9d33a901c72525d6039413a20e3c2c826b9634fd7110a24c8358080b8fa677d9ac5843b3cfac50c6770c71674c3ef11ce82bb67c8f8e4d1da1308522970adc9288cff640ac38a0f8562f42fe1d5ff55844aaaf46ef65dfc9c733ca8f6fa987dbbbc1ddc722e0cc3b83248c1783afea63bc3a391ed9273a75f6c6cab86bcbf93c479121dbaa0ea57049317b67eb84585e481833a06f050dead6d6835c02f16c2fa7ef24eaefba8f09d81d91abceac36b29ea24786664719f304876c3d6d7b7aa4b8335df42297be99fd70d567f07db4630d90b32a949f8d8e923d248f015584ed32ae8febc93c4fecca40c453af4ab5e36398172e214ae52831b685dac47ad221df739338a3a076a622c8618ab9072e3422c95f9d1148453e74917d0d1c374d075e8d375783f52bcfc1aa9dfebaa1407a1500a1e98ab353e4b509023fb72ce60013d796f2072925918f9bb9dd1e424c297481bc4691d100a3947aa10bc3cb6dd4810d4380dd423910ac29bdbc83f828bf61ebe8d0734525c65ad23732653afc4929079c2a02ae6e10fed53b5bd6ccb87494e79552068ae54e7cef8c95449cdaaaf9a001f62add34d6d8e0f8e147a6407ad0e152ebaae049acf8c79bb32fa898971f7a2da2b80ba4e6f077c76d4b2802266b30b57d685ef74663c47a303dd68566c00d9b7f5f82a189b87d41349a30fc89570c24aebef6e1571b1ed19b199d34c6af0e169c4e6f5fce13e7856007565aed75cb72f2eecf11c7d61609ff90e0614e0cef2ee354a00df4b85fa43afcd24cb771934de51e300678a52446f86d9e2452bea8abec784852e61028d7071220c12c50b75c405b00eb4f9895d43f2b3cd1964f957301b155c0f6d0b2831a87f4c9d0bd28987a799c396205ef33e4712646c6c987e68892625390828492d8e56c912fe58fafe11ff3def0917e8aa635cc4657f74635e6dcb226a17b38685e318b7ca78d89110dd85cc79846463750b52b150d3c0ae9e866769347490425a027435570f503d41c31e3064289fb76f563e1c0fdafe9a41c34df9deb13494fe49bddcf7b1e53a1a2c7a4155026bd1f30c712b488f384fec4d2d8c96fad6ae74dc35c7ba47cf481be1f78b1b375e6faa2a420ceaa01de590294a137770c3d7717d5faf229a5c74af478fa7c9f6cec4c1120de290356548117e65c358e98db29ea66431f82dfb3cf9a446e2d4293855390e319351de1caa9c77586fcc7521a566619e33b8f62f5cd4cb8b8487627c007e3d1d7de0b4b52d10c3a491cc9a227c440c8d7d6a7ddf2cae0c39f265b3a605b23a8b76b628b3bcc80f2483c78073f186225b032d2cbfce11eaa2295c1bc55e5003c22bcef80e3ea8659d89e2d7b409260ce50baa82eab507a39279156d8a6d13271a9d4b8b9b1a02e92103ab835ab6d3008bce313eabcc33fd1b2965fd9720710192c227152d97164983632259e6ff366f79cbbfe5055ad5f46ba9e81a5be50b74e2c9818f6c4d600d58e0a6f674848cda4eda6c77c3bd67fbd63ec2e84697976233c938d8c083acba0f219bbef209e62e2ed24a4c2928b6557a9bbd84cc187f5cd4bc0370139df1e1889c53c99fd0b4e27ecc9c56f9c4ee32b82f4fff42277964f77521f631e89e1898aee9f92ffa5876c90ad5602ea21cc7577323f22c26a303dca9f32225cc1528738e1f8b0e348f76812ad4b5da9da23d742c88dffe32ba3bcdddc6ab0e9fffdb29ddb404236a76107cb8144b659555b3ee4a25a99ed878f9d104fba7dcdc7a79b3511af99ad3c122936957d0a424e7d90313598b5d267010f1b3c6f0b5e4cf07c8fb04552243471303d34fe4262046beec2181b657d34c35d5953cb8dc7444d98fbe36de329ac13c45af321277870027b1438639af53fb1ca8df8904db27c9c7ee84af697f13a7054c972191c6f98f15103b0febc75a2f1d0d1bc6da9a28d6d8774b2d03d54520e3462f35e16c15ebfaa56ba1035e3f7773b95e815541f42f49d3a10de170bd827037b5e67535a762a2a5f282d0f90d98821d76b2e602cea754041af3b54a06234ea1652bb2b282ecb3002992c91b6d76fac23e6a5a1200eff7138aee22847ce17a89cce481cfd632f9f0cc0a9f1d0d21f56ed771dbd65d96da7a37b144d186bc314bafa5113730569fd9019e8efdb2b705cf7da2e43b3f020caf1b7f6e6e73ee30e264170ac0ec8f30178c091cd9f07d0cb56ad96c2e8e0bb5580aaaf18d90eea8a6c7b9d1c9d00ec523031530147cdfc616ca2b25ec6f66bd103c21ea88c08b49cd8b7f2f9966adf6bab4c02560a36da5e3e78968e6f0e29d0bef9c8ddbdec4cefcd1f4b942311823a0156b94b9f1ab1530a1d2dd6aac3a54ac9b304ede058c7665192a8d709b10ad8ae632eeafc565d8f83164581464e1b86b46b5e2075c9eec49ae5c331b727884a85595f8e04694991c31f91f0004c3ba240b92ec13c7df5edefb5b294497601cc997a6dcc592d420389e3c04f82a84f3fec0268d53a2e8762cf62f34711d4fee6242c660dfa4a9e14c22c1c9182cd1b3c28740ce30d068226ba03bfdcc289ecfb37f824d63807dbbc8025168c98751374f33eed7f64b0376f38cda042ca3da530d882fc7766ffb9626170ed7e478ba2a82749cf7393e5c36209fac2f07075ee108464b14abb9b416dc0a27a8803008a3c5706a1144fd2f1bf6857ebfea4abae385dcc0e077cc473e2785052eb105632efe496beec6c682da626dee338026138084acece9a37e88425446293420f3c22c9e21b8f41abe6e344d85c00856c3897e530d5fadca1fdd965175c29c61b29db2d54c13e5aed49d0e56e102536c36cf5441805c71e8969ae6f935024af167ae6bd93f5021466cf122528cdd8e4c4460300a333f1b7ed3dc8ebc44f55c800ab9bfc63e0c00c6de7b6d41ac3d03742d005140ffa86dfefd78945ab8943f3429307620269e79004c52a3652c30593e89dc3ef2f0b4cd6e3ea376bf51a8770889ed20684e31f273403ccb84f45e63a7b080a57fec2ee5d9421f868db414b01b01b58c10389374ed5a8fc48ac21fd5054f49d4e5f981c27d66ba058de9f74bc74fd83d9793eb049dbc2fbf16ebac692cfbd17da322c80a98d0c2cabbe6eae94002fb90e271202b9f2dc3e7caf293eacec90192f868e13651ab757a11cb992082dbbfce68641ae4f1c1c2f4d7b5f2564c347834d540d09b2506756b1af4d2d8a49e722e761dfc8938fed66777fc57bd1b279048f25122160dff7a0c775625182fc54ea81bb67acbd5ee02bbf62935a03bf566287f52043e46200eca47a599bbbcf34327ce5ac0868d7e8dd6c51e040db24a35d92a90b7b18ac92926249ff58a2a380db138b0ad82c75354e6ef6474c223cd1695975e4d86a67ce39811320268542011a400e434091869b356612fe4e40ea5df62c4f84d2be885860b8d130b84d7a26b096a34428b36be68fcaa22a790d46483e03e4ea8f5b3f35d7c1aef399a630059d3a3dc663d591b28204cfba897ef60b752b2ebae584b96619cb99d349cc8f6417054d96e5d7553a1ad70bb3edcc15a4b598371bc4f2cc6cdf9377aaee017a2b8c892a27ff039dd860576e5f28c5885737dcd034d7fafd4675b1eba16502a00bc5e7632530596914a8109c12d5ec13745510235f9f02f133b5a77a430c5b48d3232a9793f6214c9613de0abc6d23dfc4e440db579df70c4d1ff5a3b3deb2eeeb4a985763e3c43007368b7cdc14e7a80974876886b84d4394b5105fcffe847d715565b8be25f521468c08708c4e0bccc7288d635cb7b6fdc0a31b444522d897ec372ca08b7a5b37c9c5abf834e937d845914f9cda240528a28c1c70154f90a5bff33dde4ca86ef023b01929c417e520aca790147e96deded711ced99dfaacdc2276913f564b97bedf7fbe8da09826d1718cc089e5b9ba790f85a412105daf2a42f2e3d0d03594b4392309c3c3f816cec98a38d181088daed032b62259fb195db5a12b6b32a130d79555569fafc09ced24bc741398b7cd3440b8652231da8220a4704c59c04b7989dc80588b133a076c36963ae51f5403662795267032304b25d1a08194cd697309a7edd40843d2590bfb41ed39c333c884dc5fc6f8c748e7c0133fd2467a72ce56caa8a3155b9e930c2cf041336bcafddf25443ef37a6f3e1066557a0cae4f2b02a83d28ebcfd01f32453df5e2c8551e377ccbfc7292c8c45da3ea800b5c71ce18f786f0d92e59ea06e036fb7e8858e382702380e40cb6191553c65aee25eb9736263c2cc7b87db0f6b5dc74a2304b492e5dd6e614583357b01c572bebbff37aaad68d5541211bb8fa70a8fbca0e92276cb0a7266bd6d302fed6a45a820cbccd0292d8c9a3f13d0d85d4bb45e102936204af06a6d130047e3a6ca800f25cff738d13de2508f8d32e37e9e9fd34d85f5ed9883f3d5e1bc46f59a9ebd788df60f70a989bd40353a84cebffee3d2c3974e6bf6dad9be83d7c5f04173e7714276446864568c319e4e2edb57b1f00982cdb02dddfc6e800664233934238580af796fd32b83f6a365db5ded7654a725584d999a33c904323edc1a3310da4b3f7df20a07239cf56e1812af89a7d0d40a2bc270206c90060df2034157851514a8ed1adb635369562167003dce53b9b4fe9355cffd9f2766f3ce53e1a896fb7cedf62b25d5d9c5513ca84ff4fc6a4fe23315aac72ee469a890c2f7c03333fc16da620fa7e4d4c6e9728583e3a41f3c124c61b2fa9a674ae8b90364e5b902e3ee388b3503cf5dd97662248313011b821be759a641d1d906b2ff1149eece9cbcf549cd1c97e2f74b5f185325803e30cb086ae149aa06b5c07316701f4a8ba8711facd628539d96803394d4f379714dbac61b80989e2f3ee28384278a60541a44ad9075b7a8239d9df5f760d3d06fa1d21c5d892796d5e4d461b5d52897297e03b5a99bbbfb7221e25062ade997d876cf9f222f55b2ecc596e36496f7ad850d768e167b837157079be1215627abe2ef9498bd60da95a257739a09150bfa2392fb3789c59f747acf2efb88b034b43ac50845cbfb3ef5b44fcbb342e098c0064ab335eaec3c7bfc7bce099fa151a47f4d806ff31c777e73fd86bfa022d8fad06458836aff4d62a1eb90f82aae9a9c4b05b583773337117bc6c7912c05b3dd5efe1ac33795b0a5941d72cb988b508386a43ae0a7e9fda88cbf7a85d6c2d4ae8753ca4d6e67b3c53317ca4650a52811644ecece0653d566548e1da826ae3e10858b6022ba7d04111fad0c5582e52ce3366784c780f68c84505ed08c9b0e6442c3beeb33f11fbb6e42e306c8502d6873afbcbd1dfbe849ccc9b85be20e4440dbcdda5686734fc8d9281823c7a1ada7088d60d9e2fc0ca440618eabda5849e186ada8a2da09a5673d5fb76dd1943e5624f1ce5f60fdbc8dd2799264681841ac80ceecc34ab1581c8a4659f561c33834edea79176283216dccbe359a18afb28b3601a891f321c757a11f0949b8576a4766df9cee5051c68104e066df66265c9c68d00de0512b48e424b09bf1859cdaa11470dc9e88f4223747a1e113c7cce36b4ce98a2f0f4ef5d48198930badc971ada7cecf997ba27d53634674dda701a682591e0d2caadacf9eece9e89f768e2a746c93849e284a6cc0279e49b2b0db637dc537c5724689199fe2216d81b6f707b05bb16b01d10c209c8b87f03a691b995904ced65140833e015a786b055fa9b177519202ce3bbcec047737d6b868a7af3cee932013defaf70618ae7b5949202026eeef02df06a8a8f1aa0e463e6b62eacc3c1796230d6ae8997052c86206a090b922cd2a55397c20952e482b31f2ccdf81872df998f9afa7c766463d505af1069212f8d3667bd803429735b7a3cd82ef569dc7c513818f16fa410a365b6cd44fa34c4a356629e1416bce09cd194dc9ddf6053ffa8e87cefc7e84e5931d9c57e371ab7e0eefb313babebd476a835f59be6fce40ce0f3c2c1c08df1c2c24280a607abe7eb705e3d6a90a1e56b53ea082cbc24afe66921ea595b80a291fe1ca35bf43a9fd68fac4a7d59db71692498bb7b281bdf2eec1e05ddea26807159956b5152cc43082359f62028a93562dc63881efc3f7e0bb9a0ef94fc8280e44cd3372231ccc025e2424f4e0942e2a21824ab8608496f613e25860571c779c9ddd72d2fd33a07ac723ee163a58f8ecde53efa52d8a26f6b7d66c43039ce302f225d1b9bef6596170dc91da5e939ce95b4433ccb21bce70f116d1f43faaca7b6e0af56eb5a1ad354709a884dcee5b5e2e0ef4cd0c9b34dd345a8f40d7cda36d4025002e9e26e3ec4c26c91d06c5498e59ac82af949f2fb4d3dddb94377b8a75c34d2defd4145dbf41b6262ce1d51142eef7909a54ac2c0d2125ea3a4c25f9d96fce06aa23ec6c672eba7463948f72b79d061291477871cd68beff077c5f110f5462a7d8aa38f4c72d386673f8c152948e085b71bd35b6f2f591cd16069e0d0112cfe9ac1773e9e83b01ff7843c13037c252dfc26ce55873eeec39047b172cb6bf4bc7404d1ec9667016dd7c07c0eb1256865eaec53d07c56fd482994583dea970f41d6d5c287e726b49f65cf2f519cb765b59b9a7645b0b7603e3723b27ccfb5787e67e1f93b59871d3d80791c7cde75313db6f36241bcde15e166f315134677160514d6eb3119cc53f4470a005a5a3940bafce220d39011482063162a9185362c97bbf23ea7a56d9bc525aa8f7da051e3b31cb2d104721cf085098890ad7d897c9547ea2ec0fb844bab3d197426db918a84f66e4678586b2ffac51f4e9a6541070b37e0b54128cc4341a57cb72c3bde98c6d3b462a686bf699c07cd188ff0ee4c189bec0f20c01f96694a17311297ab204b151ac1c5990d7d78de18cf55c5d69d665b17ae7ffe8ea872d4018fad9942be6cdb9cac7472ce01b7c4ee3638aa60f553104aad9cbd98448d7e3e2d6fc2fd17974b16aced01d8d863a8b858856b2406b39977b1d0789ce35b4a29ae20b38153b588a2c2460d323df3f84e18a83c17dcae0aa02ae37333a7498ed7475cd11363788f7056f12326c778263769ffbd87460109a2af7a30040888ad0046a62489b846f926a9beabbb34537fb277685206b5c8d1f32357f995183ef0cf8c5bfb41c267daa4b91b6921c3b3b86af4814146bd4bd3793141a0d7a3be1ca3d5e404a6f4ffc837541144439482bcd1b479ddda1e75d47caac1967dd37dcb1fa04e193466b55d99073199e09ddaac2693e16b68aba5f83bbe725ceac708b6758d10790ba7a6cd4d78df8c106409d4ebcbb6ab9b97b18ca36b1ffd42b2180038040d850e162688895d31a4bca31f04fd158a1189be6cbedb3545c4c5993bed378a6c8248a35283a0578732e009f56dacf69e8518525c5d188e18b9bb9a93480461acd6c014813ce623f302cbe49c5d3ec359409d6f2eff31717f8ff394a0a07ea9b46ada7a272bb58bc60c425b223b11aced504dabb48c193e0998502b586db2d4b5d75f78c30c6e849e4ad1e2fd0ce2787a92d92395cf05bd44427440fc00394a1ad11dde7c5354555f6099086d23c7bfd344e6a153d296d84cf78015538f19d167e131eae4c5f72dd874521d74efa98060c412183faf5b2bd56f555ddf4f7c6fe1fd15a5002f21a81ce62bfd6974fce0f4cb68b49870c58ada99c44168d4922eb7225c84d12a9a0c32471c9dcdb7ee0d9fee6f41a00d254afe16ce1c0fa168e332be107b3aa386524de521ee26e15962658d4e8612c42cb2a204243f9b38503bd51d4c4e1f336e069b2e0542feb7d70f76c0af764475c05ff331b7ac8f52bb5b566080c25f05850f8b489441706b31ea9059d92ca32b92a109352b6e95098a67f6c2a5aa81d69534834f50ad35bfa67c17f3c4c1587a782b51480c450277db06b31fde3291768171cf91566dd0c1c68f1fc1760fafadedc4a2b04ca26d2cb6a6b9871b5d4f51be604df61f363916a17e046bc3b62319b3564eaf5da47ebeead66e13fc988b9248bec58481fa57efd1aaf9e5d5a617c3bf4ec083ed67f51caa63cc5c578020f526fa485eccf8f9d8f909b389855bc5759ee639c6e989e3745413fe8824cc60c98766036e8f70a4aae552c6ea77bc4497fe957576ce6334a31ec9730b767731cc8a389693a37ea11b25dae17be2fc75e3b5bd1fc4118e416bceb018ad7325f34b6fddf5a47451e3313b67bff1238d56d55b5f1281e97aeb3c8facd4b966dce4bf39c6e1911441552b177a9bf7b6aeea75582708063f2d34077336f43d29eb8e7fbc60f4c26935053797c3c6080214b1d6dbe7419d813c2905526a57d5b4c3104cfc8cc78df560af0adb90a114844423c3b9c469a1b14332c4dbfa573cd80bcf26d4ae62b0d7519ef5423148a3a69a91f7b25c44fc0d03c9ea49309834df3a1cf26d3f8792146d4b8965cd82bc4dcdc9db048eb9ab6e2012b6e3c96f2e286693fb82dc3ce13b83ce48ff65950b6d7b224cfa39527825cf9383815578d7509861f17448c363984b60c2eb26b94dd36ebbe5edac0506e69b7bce8a8e1dae2ceebea8310a99c867c001347affefc95badf1ace73c18142a0f2648bfbafda5b9b088b3b73bacd1f897e35e4454ca755d8c76a825d37c88d13bea5b2df546d6cede1f8e0360511d2cb399ad7a787641259894979bdcc9996bf4afd5bac61af57594e88e3c0b33a7f41dce3e9e9e57a0b67f4a92096269026986c1bfde199ae78ee1dbd3d635b0b4f41b53f8658d262f4ef56db94789d2954fe51e367a284dfffc7351a6d4297f5a964ad24d580bce6142480077c83e1249be800a533559039651b0f0f2947346a44ea46f7ef02f66ed777e745170a4a0ee1a9f5dd2e3a82668a8876b7e882749c5473a5a5646e86a5f5029e8cbde1bb59a96eb96dbe2c908f711a4f71339a17ffd3692c39dd5353e9ec445848fd5225a3c5a1fdfcc9a5ad174532e8644b72ada72db631263ce4df086e0bfa87291f61c8d89831a85347b467259417e062fbf0fcf7d877041035172d1977e1512fee406cfd7ff62644ccb19e58342247e79f1e84289841eac5512358e8abc97221a002de6f60ab278873086bf9316deea335a3f4b422baae6539c4869d24a9101b39b64a58011bb7853d027b0014021f214f2bccffb642313c362f72895e379c96b69b8534e0bdb9ddde924185e551510eaa1f9e3fa63b523c71dd3b8ab714d7d3bf4b9f2cec060910078191ec68941409dd60efeac668fcd4009f9a7393fe37f772eea1abe31425a7a48aa743dd7df4600ec99fb9fdf17625782f856e7cc6ad6e4938227b439df9765433ccc076cd5cded8fee1ccee20829b74982adf8b8cdbf7c01f98faf9fc828c827584ace188688dee45a4af0eb5a1539ddb51b323850ac5e8a99940971056d027175a770b06789a829827461342cf336243188264755a77214926bd4c4f50991e9e3683d9f926d7a9879d7d766f1bbcf47c2663fdf3aeecb4b0cff5984c86fd40c798a53a715a6b4e607a2d0ceb869b64fb49513313d22d833b1c59058a006b43bac993a56593f30ca25dbd959768fb79b60b0b2e70b18b592b128337fc2c2d53e1c5b28fdc62c0e28dd75b570b7c03322f9bd28dc517736d1ce693811ff0408af2c6a333081dd4c6206ece5eaaf7b1cdd9b270ed1f1efc1f91c0f6f0b1b804f8b64f66c4f03f8aed452a0f82d6f0ee8144a0bf963940c69bcffa6d2b41b5f91a242666ab8ed05c66b118b0800f64aebc73b27f0110c60b33dc4b48bada068e41a081c2bd633f6172a19e2014c2305e4d090a754e09108d1916813d7a78d54ced4dbac5e4833550f4bc9bc56e059ec1e26893712706f83aff64c12229303c98bc18f952ff85ca70cebfbf56429243695dc32b6b4bdcc9d1c982c53da6fa2c8e7ddf5dc0cbc9dc0ae897fae41e7ca73b5d27bbaec2b3af2e9e7f56aaeca9e34c56fe47e88cdfa47a146bbdc85e60157f3bc06c40a08ab654d8557dbbdf06519f6099543881f5be735676bc8239675e7de35e635cdbc4333c885202419a185a27d1d7b68453bc472a1e2863c91a3b7bb224a84aa5f7e733d7cd56126895cea561fdeee3e01656ea46661c5580695643a623f712b1ebc26d33eb34f40678a6dcf57f3a0d6f66f8a3a47290c036f1971b3bf8aed3a4f5f30ccfd0a3c8e21c3bad21e18043841d815b50471005f8935048bc43bdfaf9ba40b026926f50ff65a3f947c36d84c58eb650201a4be72b4b713762a6cef5554c3df847e440d3a7f7721aa2fec27f989b99a3a0e048470041c5fe01992b9bb5cf95a566736e5fa1ce4c348d5714ff38b53cea64137730df16c3555b7196b04826906b95116ba2af585f12e48726b59f0dbc71479c25b6f8e111571f59e705a6d7ed598e7cfff70e3e555bd6e0247a31140403d351210ce1f496a520da98c35eaf31091078e5db5c154af68d78a39e256e0d69ffcd4aa7b8230a9d1cd26c774f5c2273e0879349ff2046b28227487069b6a8271a8b06dd405dfa7fd8cf2cb4e767e6f0d4eae50027f8f604947bca754c6fbf8193135f70306f9f9179c83a83f10f04f1204cc11c9653034076a72490e4504479186b5e862dccddeeb3decb06b1a8e34de1e772ce831829cf6fba0dfd42e17e5defef1dc0e8820175b56b43fe3ae284724edccb82db37f9cc753297f30bd6977308035f8dd817d039890f418965cecb0292c6b84d5da064bf9ba5b39418966635e18f8d42ab990f31bff23ca805f954473d1387107b07fab54bcd2e87cb07c607348926b437006bc5cc796cdfa64fb9a560709f62279f8fa30b3b25148baf52a51a0fd8225db385a6b548806ab74fbfc8d7e847172026a003bc8c3aa99756dae30d9dcbbf2dcdd434ef2c2b00fb2803dfc4f6f74d558fb84f8464db6a1a581b11856767e4b3ec8d3de2fd4cab22e0f1ecaf8eb7fdec003b3a1c22f5736b7b442ff2ccc810031040187d2b7af097d9c31c68bde1d6a991469c8571debd7567a111a9905c46f51873783a72f5afe7a1f2251b7e8600bdead98a83372d8a92ca6a5217022ab06ebeaadada4ceef13f924678493cb1305b7a66753e81e9f8a908f1faabb27272aa364ab4950e774008fc9dd6c65826dd72ea99667d9bb5a77d40a2575871800a3c8726249f422d18ce4997fba78956152fd6a429901d08ec7b1f5a2868ebaaa263e266e37dfa4e1b3a743008c73c97d756fdeb5e345bc50f1f3e39a5cd4f908561df191b988fc6d4771289c90550d7a3415e35835933dda7d3111eb5b982006d30162cf96373fad08a601d8ba506698c3d479ecf4315c1620444a5c0bb81e57b64bee6389d615b3a7a91500ed57861057dd20a1d8e09554e647f5661b8e1b17c65c5d6360b68670a6cc640b965de7626e537755d2eb0a07e422e08014ba8278455638e112ff6d274d684a0c098ab09e692ebfbbd9c0ef9c2e62d89bf9aa0d0224094bdf47d422dd4901fa9c406f32fa84962285ddbb34d61d960298a0e80920a7fdaaa49d296a5d603252e9f47a081ca8e94279d96ec87f6a31107208e6e41fc3562fc1a244df3a280a0d437f17913ec871daa3211fedbc2b31a94cbda6a8669db1698a791fbf897612f896d6d45a10a98b5fbd7685a98f4824318f98cbe883d21a38609a4375a483de6981d92964e7ff4744a7be0e8012bafdb21b4d05e7a83cb499d597adf840eade54e26d64adde143415c5f74fee0c0597c7f76b2aaf30ac3110f61ef62626af1eecd6cece946904070f9cc2d8e0ccd125931f3c427c930c0fe87aee57fb9d637267bc6b14ed4f55a196007c3d31ae46fa1516ca17284a768fcbf97400b61bd7f72c148f5735537f3dc488fdc177150dc5cb16834c04172d5e3ad960cddfefa779bdc5d9d9ff924494b67531dec75a9417081177982769d698ad8af6526c995d438c09ebf04b0623007ce826811aed8d9a51b8a403af3a1f8ac4eb8758631f8cedb66fb5395985cc96ee1356c99a9fdf0387e2b","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
