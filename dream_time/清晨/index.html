<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c6989be94ec8004b051bb72b963cd3cf6c2431f07bc03a3096b10eb5a65c3944170811bf9ca4b3862e87c6f0bd9a323661d7144d9a25e18f0634d1574792bd30ec7804b4c9bd8533a093c5a6c39e45bf60dda103a3c5dd6d50e7c7d13317b67d55927e5d209ce5b6da427ef1a1f3942615a953b1540323744f18eec24abec7f3c6dcc0db84f2b8d4ed7b522be9cd9c384223434dd0e5b20b832f44adc7ad57dfec462aeee9c450706af689e889b9e67a190a4caa8bd2b3b6258e45e934ddc5174c4a4007c68e2e1ee36605dc1fe1059e850414279f57e1517ed081ca5c8ba9746f93c6e33b2eef7e24a267619d4b62f900fce6aab24e4c61889a01c11175d54cabdeb5a959fc71e72ef5529b85373263c6f094393410bafa4bbafeba709612a84a2f4ec4f797f43720c339cba2c005d54206e42be3da9c973f8aea35e873759cb01dde50049a04f0ab24995ff10da464bcf6e7f3fe297ab2797ad63eba56e4c6415c3b7aebe6fb9b194e3ede51b0afea93c47aa4f25ca474067efd4b6e2a217ac6c63106aecef2f46d9d92c46b801afefea0262ef504a85cb0e5091d8d314db45fc6ebbe9199cc5857d0ae61636cc8575f817742ba00fcfbb34864dda25e1092140b7f4cd1543d1d29539116de1234097987c075c5f926480486c0d1e4679a5832d0b810552d6cd4bb0f42872ce3217cbc4c36d0184386e013804c9d1e75beb8a492ee00d1b73f96b7b2779bc89cd0a0ca0776be5a66fe18700c332c888a78eb7dd8b9bf8252ccddcbec0ca857481ca335106153f9d1ba529f83ea9f5a778cf352c66b69a63c859d1a765845dd7ea08ee86f7346211b5949ae2238b68df48ef88aaa1002d5acc7634b4e1c5a50c6c5ef990cdd0a7bb4c534bbc4d09ea4b7a2f640fef0d0c78d48227288b755a5484c3bcb43441f08f745c7a3c494ce6bbf747fb7df02f12969bc0f8c5c5763ade9799159d287a2c5908412ba48ac871be079be0a279369f9a92bba44155cd1506d362a45a510964adc5dcdace94ed2244b97dce5d48068cc0d9238c6a5809e3dea6a9bfb7f7ee79dd7a0d2af844f9270ae641404168ecd6fda50a7911b7c18068417e5ed69909c54babf1cbb400b7f98d81664a6088fe52d525d8d83fe46cc39fb5d0c675f259d5365afe3d090bc671581249f3cff697eea44c42764499958c647b9fa9bab326af3e1104c37c503bc56e1fead0f6c2e8337213b1c133f6d16b85d96704ff995e4946165c02b5037c4c0bdc0611ebff0b3f9817227d29356022c4bef2aa99469261ba59a64aaacdf5b405dd9e9211151e6d3565ae3180ee55ae94bbaada82a6b50ca1a1572426aa930dd6eb878101b2c5f6f3d5e6e38aea16ddf56ceb01509a4b94fd9610101dd4f35ac12419e68416d0573a9fa7804b0463472219980fbdcc2580de8eb8669b9ff3282116d53a3d56efd2e530a68d3532112ba14cd18444befa8aede24290082f09de211bdebffda3cfd0025775838309db44e4f55f6a9f7d4686a77994d4237f63a02f5c9a4b25f7f95287944d46b9f7f818be447715a55e12f77db1c3c05ada64344029fdd42646c1a4ec84f186e85665d37d9f9edcf5c882dd3fe78e7f20b79c39d2ed0bef74e11decc4f1d17d470602eeb9919bcb478ee706f77f52df0fa637ecf72ed038c192df0a7cf269204b55a25f075dd89275d283f7f514f5e7cdaaf7804fe124f87ac24e64c943d2e42af15abb50739ecb2178a27418e89eb2cb1ab76c41fbd36730d1465ead1c77684413cad663474698b31b2eeb9978aa070a9fd537f8731918a3dd439b9c2c6338cd961e9dab6b516623c8f6e62ffabfae9d5de6a803bed1c1b813e51123561d72324b5e4111dea743e1e8d16a537e70ce80a9217c5b4c289545461c7441c72f2649120bb58cd69adf7dfdbda3f7d734bd01c591652f37c8f4d285c19913c360188bc0ba14ac8df64405e6b5299f3df72e869c4286babbbbfae67249dc617f656066e06d09ad0e19587b772565453abf02b9c1c219face2925ca22f25b3426064c99c07b158c78c1ab0294037bf1b3d236fceb6bd6b5a029fc86ef5ec1496e977e9a56e9d089230c4fc5a364067514780dacee1c5a080726ad016821a93d8773059d142351c0e900dbe9e81c8e4af86fc640e35f5f76a302965543a68648291452f601bf6ca49a7a8049118ec228ddba3b65b415832a739c1f3e4f214f6e73f44fe31512ebeb3d83d4e31c6ceb319b999547c0590373504118a2f3709bb746b9a002161bb5661514bc9b0dbe91c5391e823461ed3c35d0a45b7e4fdbe0b859613cedcbda4c241aff2db428a6f658db3a770d102b374b85bd315ffd5b854bf8de9d3e4031847636a303f2f26809b7d5b771ea018a8e6ac481a8d905e787adde9f45a5bdffd2fbd3cd4c2ba08e04bb62e3c47001a0bcd64b7078bdac79624d477edde29701f5119668dd4895d2cfd045b12b7dce820363a4b414e0816665ee0ccc4aac425dec45fbc12b76c28b109d944686caf78fc997dcb3addd70c2b5807d89cc068588c4dc712a7c749e539dc18ab682bf3db761dbf403ea873d1a356761b90bf0fc4a62779e3d284e680d82e2985e21e4cf309030e5be67d73031c5234e4fd4c2f0fff7b387a4201abe93430b187eb74d6cb0a7ed35ebb50e9449146d2f5831040cd55f8302f32c57d2c7ff82f565e4adb6a2f4110c4ab9331ba8ab25ac09dd17f9d1488526605887d8deb534a5ac66cbfeddfc9581aaed9d09ab8aa7ea96c63ea53b9e851e13a36729e5eede11a67929525dacc810dbca784f40b27da7c70ab090dd984d0c3bc2ac6dd59b0ff2d0463b0d9b7ac6184875a89e79a15f80bd3320e33436d3bd987c513d765cace7143553564bcd71276022774d0004272e682d23d6920ef0bbd9e3b224ab625059f77f4b2b3c7bd922717758d8e9ada68a3bd6045a485f4f6c31bfab9e7e0ae4be5d0946fabdaa74bd4546efa6fa421ebd9a7d57b2129726bc48faedb280765d452db7dc89d9f53ae4e444e251813793302fb42d9a00194d1fa0cbb361f703f09292e17d2bfd27698258d8df00e5856d48c2543763b4b5b9b63f7c5abdcaf99c3e0693be4c6079a8b7c53eeab5c0fbcbeb07d3787e8e7117623279f211feb083256e884daca90f635a1181070ffe13c71ddff769dcacf729abaec0526734e432a172537d15bcb47a83537f4aeeccf86c001aff67bf2255d968a5606fa71912a635a07dad921824ba1e72e8cd9563e3233052ff3d07c86b792692d377301d47f2c70049495eefe8bfe7267d1e0d316104b52bc1cface7ef85b20afa9cd394b918a88c487d3a451cbfb5c629e5a7f96e95970205cf33014192f49cf7b8a493f5685b8f5928e3d1b4e8faefca6db286940f68d561d0d0ba25f21abb7055d48e09b3d0d0590a4b34b75cfb61894bd56eda2417b60f6cb31cbc78905958cd3e9b5162326e8210ac76305a2fdf13c0343ba50a6a5ec02226847b965f0526f86e660f94e8e186f94cf5bf8070b591d8731c7ace2c00eef1caca151ea691a8ae047cea39dd148e45928014b98846c051278f1f706857ce2c387bb747f9aa90f0e9bd43012a9d47ac1c32eb4ecad6d0912dc074075b6672cdf303297a279e477849f459794ce152842521a81ff193dd301dadf88b614cc60f4a3277ee78c75901a9d3f161276b2341812761f25c8e0e6c6f004e4f7cdb0b8cce54e141ffa0103be3d87228cadc37ef3e3cf273d398b963f9d643c65cfcdd6b3e1c09b2e9ca29d0fce861f4622ffd8c1c3c6c93e16457a5a74c90bcdfe170d012b1e7ff51782831919ddbe562cf084e7a6a8b44de75b66d7ede351ce931d5d581df15cce8fd834a8ad7c11533a759bae9bda34ba0e6e6fe799d08876fc2b0dc8437fbb3709dd34e09d59458e380ecca3227709ceeccd2a9a3c0c7b4c5903cb6f7b441eee3bf76a449561aa0a52041b594762da2f18b2513edbdbca482b15dcd10e43a175afda6461b4559f9fef88b96e0026c68464402db54f1e9e4e03864e6193711f92d6558810a27625085f9c366cb5dab6366386d3dad89c902d9fd757bfc659281e540d7ca28cd27311c7a042405df087a3666f965ad7a6a75f48aa1b78c80694fd3c38f2204f59fef5e6cd9fbca74553b0c7866e4132605022eeb06322387a7c3a11481103cd61818bb0126b3ef50857cd7e02f25aab98fa01eecae8ef0453d76864c6cfde369779f3c29a0e1e099c3da7c6c426cc3478253b34bb756e0423af398fe690450b580cfa83c6999c894a614a7e44a1b6933cbd62d6af30fd2ee52c55c98a0615c742182ad182e3e78673950f984332859affa57bd8793b371ca8a6b682cf273975dfa6958a059cf1837cd611cd4d24fa4875d34c7c1ff7e899f906dd2f484c243f33a2ac9a6b1ab6736a4bf1961023229a96ce19d9a9af01b9873acf3f83c6f47ff7bc56e781923787526979913d83546222e97f3812f226895c04e4fe0f4541b10358b92af5761599509712091da428e20ad575d6e5f3e5eca46d11ec6013a3f683a46619b81dae69431fe15e33a06f339b891f5ac1c985858a4b6cc47cba58b0dc91d147de5a1dfd4539f5ce1684a863f67ca70dd17f74b58c5b27326f7907689890f25d9ea4d9325cb0b9ef846597fd4c1a1e1f72cd01f9284ba9400e03326403f26183a2f2847448220259f35c1ff6e62007aabde308e7f49d1dbb1b52ee0eff7443de3a942818ed03f916aba115fa316ef756f376af81e1d7f74fb13e3d09661319959ef40fdaaabb898ee5df8fded2d00d02d05bc490bac873c71643efd80a569b811fe6bbfdb3ebbec8b82099f291e213b243ddd4ec922ad439ba72b2219c1bd1911902f10fd449a8896dd78900c872f3a660b76faee1bc126928c4bd75bcb36b9f9099f1480a76da3a095d4ae80e1c5390fc40a8287e635e2ac0626d723c983ea9cb4aee489f865f1a60e7a6049f3c2b89b6310cf96d33e0b974637e8b48769c89c4b353b6464056d0db6e66e6d338da31b8e7a1fe9a21ee660b227664eab42221c21733135c8e117138447ddb879cd3178d587b8e0cf04c8117399d980f7be1557464b3d71ca2262495991e8650bb4971dc5ca46f1bf7ac8fb1cb20ffe5aba281bac7bfdba007fcc798d8bb6a07f18b570367e8221d94fe361c09d863d768aaa42c04a8abbdcea5dfb426a8e3fc9ab32b8ca00687c2731a121c84be3450a0765f6d3cda60d8384757530b2b7f8ea8a652361ef0bdf0b2f5c856c997af3831fa7abf17da1194241570fa001b6fea5bec2c49dd30306d283ccbaaddb8c962debc549661be4da6cef3c933b13086467fac6450b4247e29f7ad65cab0d69c976755a7e49e49d11e9b0dd0f30fc211d4ce31138ae5d569ae492f20227d022d41adcfc1d7cc8edb3a3f29a0e74497317b9bfa8e6e79ee1168a897962c39af2990a67f567c6d1af834fb925853338445afdd861afaafc03f161ad1acfe6e5b46499b3fb28b5fc1930cfb58c338ba1550df42fdd8a502409ac335f94b0e2f505597ca8fe0323744671cc9b06e9620e0c0ff42b45d270424123db39553746bfa8585fd1902c81bd78c231d2b43b38c2b45340911fd4530249dcd7e0eb2b89b577eedbf40e05d139d8db7cb33b32018523544ab3d2ed888301646729e400b35542d80c223943ea3862e0f3f72988ea57d8409de8f2e8e5d1334153891647c6491633519d448a7c3ab95eab2e11ff82316f37b3d458703895943b6256cac7a4423c91830852c3f68292016ce55f560eda48eed73c0c7fbf4c2a4822253b9b4d1585b0a0c2f11df9a4ffb62c8d09b72f42d60e7e25009c585f340fab4d13d721ba29364b3cb60a163e281f7d16e027303e3498df34488a631ce1ff40fd930d316307616c37dc590c96da817e4fa4a6c4cff318ef4eb14e1189d68ae0a08c93b8b4eea0dfc96ef91fae5bf7cb2883fdc21d4cb283e0567d265af76f6fa34ac15cb36bcc06d8b37a1c19593a824129cd85e33f5011704e62e8fca3f05077ff03debc35d56bd916add9ba9b33c23034b99b0aa5df957a8ea7ce4fd1d9383c41ce999eb17a6acd24e65456212bef86a08ff43c24a438a8752eb43108dc33fe89b1b7fc257ee48e0c31859face82c076ddba91bb92fe9b4550c4c94370ef80541d5266509bfbc72ea79a009718ca742f4fae45741104355d0a20aeed71f9cead227e9231001017673693b3347e1af856d5f7d2f5924ef7a2d762af23708b9dafcc23cf13d03bdad7589a8986f23719791de0782f4e116b34443de590c6f12680cf21395eb77c66ac5147e0dd5e78e45220aab47e468e83ecfa35e04fd68d57f5dc29709ddda8f875a44ddbaab6993ebf533746b05db6c4305882be5755e79e9d9ca5b3744d7087066838c070038c96b93fcc89ce4cd266aa0efb7871c62e68ce3a9be515be2de06fc4d99e46ddb43da7062526acc8e3237e7a8ee554bc4c07afa1d60d4c7f0133cdd47e8cc7c171154c8e5215904e0df5ea344e41b930f02fd215e0ddc961c0e9ad85e77f1c7d332977b80269b290e24964db1838c582e3d173c874a265945ad029e4495f8cdda845ec02298bd6fd5e14de11dada0ac998d02f37337432d26ecacd3d359b7ccda9ccb38d066fa3cf7949b99fba0761971bb75594e6f138ceef96d34ccacfd5b6bd529926dad5ed84ef7b842bfab24c8e7e6b3a02b9bb46719f5ede59e5a1ec13f5307e39315f83c703988400195fdac15fcfce106cb684e33ab8973e195e91767327e88a87ddef514517552e2f6ff28272ceb59c29fa03eaae344c3c23ac05d9b982a26416a960101b1d9c55161b9fe5b8c3f7e74ed524f11d856a657a81769fec9e0a27d052db04862cc8d7a9542c77b698de5bce65ff40b54a3dd0819cb90ae4e72a2e91e449f265aced374ab218ea275da52508bc3d648cffcd74d399b95f753819a125ad02794d525d8825bed4e4b939b766f6ef32d0c113e95aee8ccbc22861f5b5e6717207d8795d98b153ca52fa6a97c8a219e6406e65b32d06cd34cbe7ac15d464fc1bf57e3abb1f770e28f589f219a25bae798194d383b316dd58a94eb5d2ec4e721d34d820cb5f1b4bea25f718f4fb99c8ef9f0a773fd13736555d55c4e373ddc90c62280993c73d496bfd4162ceb3e9723d99c17911a4a6c45a8d9d977d4e244c943826a90c5ac11efe0a9698be5fe172bfdad530da3c7490f0f01bf9c3b9dd93a889ab0f7899152f4e850d5e99dc6e3d28eb60ee326e8567f220ce060ade0eded5321d6788dce0cf131451b40b2c09bdbe05ec49f393ad4f7ef3bf1675576c5fb8d74b9a6d186f161b72888267a7d8bc44700c1e58e45c9120415de751895ce381a7ea9b800f5f58acd4345c944bc8cb127c3108cb7e6badaeb838af2adf021a5348285d80b9b35fceabc1403fd740e51e355bd2c1f6e5e3aecc801bc570d50ffb334d44c5a5bfa4e06fff809822feb5e72ceaf41e2ea144765fb601708a9d17717fa4042ab4d247f2c7108ac1db04664b3c407057395fd8e648e33c0f251c2e4e99471f517a0b6254dbd3c7d98a1fa338e60950c780c5d5c342f7e1726ebe3093e6e6bcc6194ceb74d055a1ea33ef80684cf81df15f9930d33a1c7f3805fac0f544cc0df2e2a98d1927c8c30fc91810d38bfba5b8e3dc902ee6e38ed7df3bd56b640e0887b55a5d1fd85444a8e8891a34cb203e806338c1896ffae04cb42d3ff04c86baf2d6b87ec20524790511410aa87f306df52972d4f613cea3ee1d8ad0cee89ae538d813f98d06cb0d29c9417ed4c66122bd1bbf507cd740cf97266b74369653f93f1ffd83e6e5c51bbec94aba3304eca263db937c42735677d619ab13a1b1174a7ee99f215bed2f881ae3404ebc52b47d95dbf50308bed88cb211e573977e719d86cc8b14f38259a7f981acedfd391c0c78e4798ef72fa825508ff044c98ab717450481b6addd028ffd102bfcc3a105a0642f1bb7033ee1ae3ee923b9c29060bcb40074e57cf5950b81d8a1801c9a7818a8d00da45841ffc4994e791a6d866f46b71fbfe9c009c5ea9ea19c08ce51fda3a889cc3ede06cfc364b65ae6b0e00c5b64504194d0003ae3bb51bad873d879e9415e85caf53492cf71f5363c191fbbb1bec900a0d859a5ab1973e1b5e2fbae6091e53ffe555ef8e733a8f207764c545f12c3f3488753569053aaf4988e9ac49807579bab4a90145afe96327ff01395131e6ac3fe5a60680524179bf7504aaaa8c0b012e16635f7741b18f4df69c517483af9bec3a4bb7d54d68f93e46cacdbd1d14602466b3fb222645ee70117a5c9dd654ca9dfa817e3c95a4fc71803d91caa28c893e0f6586b11c2ab35fe1141bee6c077199bd799108d1fb9a0588109250a66b5214c9c5f46452acde9154571d373f4fd202720cfb91c999edb4f546fdaadc077cb17e49c2dbeb0f4c8c026d86093bf7ae73224fa3c3280e3a35f801e770e873357e2e984352ba1eaba17c01bef4936d3ed6befc39ca13603844fbfd3ec2b4dcf90e7411ba4f88b2c2a39216805f99b38967ee9e08721987e03370f0ea678a0b3f8a418774ebf5bcb1180c8a16742fe77a4e24dab2573aeca8aed9b88ac3d0661fef9244eb2fe2ba5ad368f4f8ed62d630835c110b33bef4c2775ded3a93e9f83f8b1d3a8cb7548e8b803d118442b453b95b1cb93823a5141065fe595dbd77a4f6163d0cb1ae7ac6d42426ac56de4e90a69b2b9acf39118bd6dcbb1d5e4bf00ca1d00ec96498e0992c60aa876c4d1aafc6d2f769d65a5a7f15c604e7e237e05a83187730e7a2294c27d9fef7848e9fb1eb0feca6d91bad816e942c366e5da327c252e129b50cef2d5c0bb7a3ffa19e59e950123af04468d5f0c83c31cf07b216b43d70d0c1aaeb0b63ce743714e6d7115613bb049736caf7278261e315060f25ffc09e1f3bec8d631bc17eb685acdfcd5daa87859cae74bf893984403ab8fd2ad7d89550af86d3a039b693f1b304e4ae0021f6958b26ac0bb15b28c56bfe8b8ba3978f571556ba52e60fba206e9f6e729a8d75296bebf78343a38e23dfc269a12a85d444c57023cb1c50bcf99ec47267a76788b79b90b94d6dbef8d07a190e95f2d3e4467ed37dabb3c8994d885af231451d993beb8bc457a741641a8834cab0ed74a1289a203b0fed35e030c37205662922452a30639e7d0d1ebd412411e119da81ef9548618f9ff6c84ffd874b38b973e92713e295d1d226c745ed650f90310742b50abb30f2fa8f1fb3de91b9521d25678c05f4433fd7da828dafa02b9e62115ce1e6aef6b9fd2698b27305092de849485df4f18349ba6ffdfa02043dc238d35cafd587a0b7bb247cddd0d61694cf9f4ab9ca48b160a3b121eef0f445a6c09af16996d9217d4928cb171e5a41ccdddec35a13a88982eda305311428de3426ef6d94bce7cf392d8952d3920fbb7cf3b31246f4649e7a30f2bdc5d246f99248be36e1632d9048b5b8376e6daaa96e36b426cd733168ae49a2bba393727948c0df35c6abc0950f87ba1a5d26dc1f689b97cd16872846aa20060a1b24be09d7415f4d6aed623880a90b89d140c2611e75949fba277b647e1c313c12918637e9a71188068f49f27c537dd29dc255a37e7c23b755937876a09312f766b357b135ba75208b6dc9a53d14e0bfdd98c6a5bd470c1dcb1c73383e6036a0b1a564b00d4755556232179be35473814805b2cd9d36031fdda1c179ba4fab2ff40679568927338f200b1db289633a260524814d56d676b6094f4b9c5575b03a9d717c24cf610c553ffbcf7636a02c20447d0a5285e201aa44f9d2b08eb5a910123e1bdec746bd3a179d322063448e0788a66bd126f47681c1cc149bc24fb33b6152e0d8a3f22a1858f091276ef6ac9bf4302988652c21d8ad6f09b434e22abaac2b038e4f8dc4bd7587ed6b0fb97ccfe2a99697ad27309f7138993fcca78c2cee3c58c396ce83e32cc147bafa94343742435be737178a4827ba6a01fc3723f8d6b215911e62a0ee6590dce1f8c538ff06e42bc08674c4b9cd94222f2036f6ef6dc1945ea6546b2080ae749b6cb4539206bb34a1ac254a0b3723c4ad062dd64ec7ab2ce15bfa54b0f51420aa26acd33612bda0bdd7b1a0327014ad112205d0cf24be649cbe318d1771e1aab0cbe3d7cc5863572a34e4def0a71c23a836a65649a7ff3db976fe1b4bea884a9963e2c81136af3588e19088297ee3fe8a925e362e59ea5c2f1e06b5dc95aec8ad88e59f214162bbd86e07e60d679a130a98fbd85ff2b990a7b6a6b2604041dc50e8b027ef19fdd752f61ff62a47b6b7d9a155f1e39c806cd7e687b404a4837a1b16cbfeab5bd19e915e77ff070cac2f29d97cbf3a4ddd725b5e44b3976b074d1f80ba4a74b790ed4ce200923b8204178c831f19e8ee7db46879e25f92fea4071773b283756eee5896ca2e2568ed2306216216c43be023659cb4cf3a1a19a61e9d2c08225af0aa1f28493c66bd1de04246acb8c2ff9d2345d1fb87019e7092dab5f4d67239b95e0bdae3c4c311fd4877b0202bda8fed6d18dedae6823fce72a9e3977d7282b1854a051029e89a44e91966207a0f6abfedf1ebc17d8bd89086ad5826a626d18ca4dbf95827cca5e4cb2fbf0250bd28d17d5760171202baaed2a1e491a9d3c6a7d59b6d0e05fc1f08f6bcfaaf3d4a160d8f3f2231153c24873a3cbdc7beec6c5598899e64bb902075c66580d6286397214f3b4b3134102608854cfa8eb4a8a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
