<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"226f3c8fc1b638cafe1a79dcbdedb268b57de538a715e366289b4822203a5861e3c517f807b5b26d6bbe32dd436f1889c369dfe5a175bba44680f6be06593b49317a282c299998cb669ee9d1a8e6116a9b8349e0e2c243c5d22db8304c8f8ab719499227743101f89e3799fb5b0415930403cbb812119c488248457895cb138acbdf2baf7d9b31991a1aa4584ac2c52ef5d941c6fb8d2f18bd47a9728675bd3408a8fe1c0196da6fcf3b699725ae8645342e7d1e92c09e390d3b1f5519e25a40384b124d03d3e794cb183a5d8d27a99cbda09f06995d8691d8e47b45ef3d1b1b40f42eb21d0b18ac2e788df5252e7542484a880da79ddf0117981a0109eec09b6bffb2c9978592b6691c2cd9e4256760d5482f4042444a74d51903ff848f9463b23a0dbdd93a4dc004fd9271e0243663da1157b2e31a673447945bc748e7448890e87ee3f4c78ecf28ac2fd3eecbd16c19f9c0d136e033216cf68f9b690b1815fa2f1fcb1c625fba335dc9869542edf0a2c53db1c5947b14f5b6ed94395e7985b222046e4f688708d91bcc529d9d65af3e674ec8bd7c8eee9b1dc2b78dce9b506dfe39b8b03bf52995da8a196d4b6e113d3faa18b4bbdfe7bb5639726c67946d8223ab89adc4e8f3ebd2d4128c5d041d886d142e516414047e16cac4e71e27bdf1e3ef14ab409a731b37436be5b08cc526028438936b23f4591bd7c0c884910e85b82144eba28332244d55136b63bc6d332f56caabff37cca9cad8046c19eb9e041a29f0ab79f08b8a7c1d6ab625c707c3d7a2bae878912b72cce0429bf15127dfdc4b80e51eeeb1ee9428a08b39ffca8964e48808144c8bc42e6a142d573d3fca87d082cb1c578630b3744c88d172c54dd85d44b5d04678e2e5ad65717744425850d8ca994ffabc30eeac97941b8736c091f05c4a436bb61ca257338a6a33c8c85f4f00232e6852f9c98eb513be7e3e29f82d39ffc3d838fe50d3fa2615ff9effa36c9aa1497fcb08a0c5832b32f75291f22c4ae32f42c6dd65a518b64a42da49adc47e9278b4cf1ec34a59362679697d4c96cf919ad97dec9589bb58310b26ab8bf944333e2c791b0ddec84caec8a54a06b23140149be84831ea48a4cb12094e33d5bbcf5fb956885f2534e1b3c177d1db4af00f1cdd8338ccba6c2637871b1247eee62bcf08826c870597f35fd762fa4e182f9a10d34938da6f0965a8da3953c7166b27c114eaad1d6610c9366253f1457e89dddbae69d46ef493659942f06e6f87674f2b854982de35fd42ab647123edee2165ef0cde6eb01db6715a746c43c649ccb83a5902b840baa5a2e6760d664b68b6212f2b64901ab3eb528c1bd50cf68be56c2a1025068347f4379c750477be41b0b5e16c04fc84e32c0b8b70b627cf101b39e61979395aa7981ff83525f68407a9467aeb9309160caecc5a93d9882554573ff7672bae5c1176d6994a9a01cc217785a93a3c2ab1a35c938adb7943dcb56722f83024da581dd36380a0e7322fc50e6b510f2257b34934f738c2880ba0e3da6c8ae1cb2f9076aa514ff702d5e401237475951a545ceacaf0b51d8554d464266df21717095a41cc24210917cfa23dcf71c344a001f6de6839013a16bc26b48d558f50161a8fedd4d7d90022edd1f57131f3c1f02e024e5d415d71d16d8b0074c17b36fc6931ef990b0eb743c89714b9283f36028dd46ad2e43b4ed90504fdc999f499ea9fb6d79574c07e4c02fa9b935107e1091c9cc65344c1046794560e3dff940e6f9d2e5f5bc80a08462047525d2c092fd3735cc5d75eae8e32733612af83759e32ecf528bfbe0778848a4f23fddbd767f0e9c3c736fb9fe047d4d2432f59a7aea1d09e0fb78ae9372680ec0fabb83af411ff7347e827272660f8adf5e048baf1bdced91ad1a327417ec4a44f925a6dae37d14cb3546e166a1d0c7d04846f836255b701fd54d6739485637f5a39bd6c3d7cab5d0f212186d1a7653765db4bb6d041a874e0397fdd75376c8aebb664b04e7d22b73fc560d62fb0a76dcb3ae5a07abf105e2c1cd50f86d8609943a5de68ea314cad40e79773296ca1b2c48c638947784430d733722d3db3608ab73b3ac675af051119cbf8a4c572d353e560d14d95413ca6f9e6a231547b9f43346106aeb926d227856512b03cf83e7014767e4c90b34490a179650bf61a021899f2c592a2d3e68dba90d81f1e5d5fa1c1005d74f4110303b7c5d69fd49c1a70db2eb326cde4e89adf9bd4b6f296e299aab62837f248b0bb391e74f752b1541efd386ce2e6505bd83eca24ec5e7d682789dd817cd44613f8dbdbc6b6eb31cb10a0c6bf1f27a5667d34a2dd76fb22d530b55575f157af2061ba29a787f5e680c8a9b890eceadd59d981702eb46b3dce3a730b4128d102d7b652dffd88195badf1ef9e1a9c910b410320d964d0c6c9a3958ab4d4e5ffead9cbb9ae415d2a6dc3170a84f3484c5ed067e95206c3ff92290e83c50a132852c744b37de4be57d4f6d24908e1895c9046c9c7eb612d27d5c11e106816d0f9eca776b6b73e4422a3595a113bbbcade38bedd9597646df2ed079eda91d0264276cd73b31b171b2ccd7713201acc40c9067b12294cb8405e8113d0e6880ed6a5e295046ed41710ce67c4d27733fd345d99f8d81c6577901bab1f7dd6cbc5089bcb9de79c410963a23fe6768a73e2796b9665fe1d71e94808100abe6ae0955c2de1192e3ae3eecacde6011a4fe7a90ead38f2d0b5b2e63dd4ae273e890e3be7847dc4a5f3afd9cddd59009bd7abba9eaf1e1beddd5279e642fc59776fdfc0f4c88e8d280eb4e55fe5d4b596e4561aa35de9f77a758193c9d8a5f82230b31d94edd27ff97032f0eef1c51840a2ea5fc3955778a3015bd8d6827d39a42b73f15fe89311d0763ab630a18926105e3dfdf510700b261752671cbf89adf0aebe604c19a9577c59f8880c78d2a03d4ec718b78544a03474f4c1b3df76ea4e05f69933bd9237fc0d0344159e58b181eed678395cfce97d353b4adf1d73f0589bb1a94165beedd80c4a032303122cbe5c86725288840b9e7c477a41edcb83efc1a328fa584f43d6c74ec10c941476caa5bcae3e219832b9f52902285f84efae31be656728abda57cb8a1d16c3a843e8b2235b288dc08474edf11c2ac98f6bae8fcf0a0390a7043c42139b7b1b336c102fcaf4a0fe461990a3fd8225f9d58139e2b82a274f3746db27bfb01a6002bae48b5e69b4107a939ebc28b9a0f0be8c2c8eeb5f391f984b8786547af7aab70c1447b38cdf013444c194cdd9b18bff73a1d123683ba598761e3c8700df4b4d910550fe0fc0e91298a00f9d39051e213fbbed7df77b5e05effff75f8bbdd3dc90e789ceff3a92202a8bcd28816e94b4757bf023073ed74711485df701b73a90deb188f2e29be663a8861c7976ef74d1a9cec183ac65d56dd90b3b9ec1dd654363e2bf044ee55f16b3cf61fab7c43b50d4075c93d37fcef0b125a55306ad58e0685f496e1f6adc17857d7ed02e6aa3262d62ac8489dcd97d20b9926b6a50bf5623d9662e0be6dfb441ebcd9ac677c744f29932d30e136ea0097e78454110eb5bbf59989481200b56746630fd2e54690e862e9dba919130c44f472fc48f82bf6a4647cca7c862e6e9f8e1de65d51f8d7f45a36098be0ee10ee1a7e60d6030d66423554a13fc495367d6ff045b80e0b63eb456baefb699cfe635f63b6d85fdfe77f4503e9d9832750cd3d067029557307feb260439b6b7c18c0b1c1b16ccb72adae68bf209727714e32bb4fa0fa6ae77896f5865fe310f4f6a6845c6517d34a6458bdff4657722ca36e145a911373937074692e49961ba3a55b101d07106ac193bec264e26401ef34a8bc12c8bcfcb6a2b64d0aef2e150b62ffba2f465cd4c09edc0379435d3ddf081ef4ae4d11af602345091efacbe606d676201da699e6f9fa117031e7cc7a88716d431fcb608cdb6169ef686a73a3bb8d4cf7670aa27cb8c230b676d137e0fd1291a08b7199ea5ef2159a212db48d4796aef311dcaf0ba79001d93d090d5d0b56b29ed358e74b547dc4f2dc6f8215eb30bba946d0aa5e271fbf90c98dea975dd4a98fd76cc9e809943ff1ce46ec04726f739bd0f48936c31ae9c4c55d7817b66530ec079d43fe21d59d82a10606c0a273f3f4ebac21cae52e4def3bf168369f246fd3257e19cac35645f751d75d6dfc24f9b198b0564c3489209c22896db937a0690becf08931df178961149f0f207e01a82178bbe04090bb4cb79e53d72218fe1ad3aee45ed045330ac9eddf183f4bfcfbb9cf06747834f08bb4f3b105b9d005e3243e0af9aee7071e776806028f1910190ae37c12d5fb90dbfef5288f06d4f62fd517bf3414ac300ff58352505f44dc849bdc77078f22f377a17e8a246f5d21c1487c4a7294d8001e35f2b26f462cf3962297151036b04240934cf766794d122809e33927af170ea1f7fabbcd1dce8f5bc793fd371fa264474dc4c79fcebc9cd6c8656c5dffc0e20fac5395897d5a783e46e3a3618bd85ed76aff519c8034b0e991b1f0cc9e43ada51b765b968e7529ce5bfac77c95d876ab27a21cbf1893d81c7ba28488b7efd42db5c3ac7230ffce2bc63a6c39811767985dab50b549124b5d70a66dc3c9503d8207c0ddd3a1295c119570019105db39ca8e4b44c052713f6f7b2d0cca2612e774cddfc5b9fe589cb02de8bafeebe5c849f145acfe16b6a47485565c85d631b50ca72c84597b8f9fe7a018b53dc1a307c06054b38457ef384c34b9ea529bc97648291cb82f9efdd93bfdf44f4a144b285f5ea8194eeaa44abbd89c43654e8b17e4de2be50af3297e7f220e8060c8dd2c6ee61d005fc76c71d64cccb0d4e37377e216797a138b67ebcfde04d82eb36a1c803b4017146c3d2fb6876b94d76d6d850903c16b12b034b662d67341c6953f3c178a3d1f43f054ec1c14c87b70ef9dfcf508feb09f15d95ad669ea9adb4184d4e93bd1f5cec4f6b19559a6dc2e4f50302765738e6bc590957ce38ec0742feda901a7d4da881b458ac18abf9a866db06b12a384c143bbb52f747dd049f8e67d252175813fad16468095cddb216a67be3b2a6c5912c9bd236a6950febf6ea4ed3ea7dcbcc716b144763b8c885444475f4a18628d536927b72e4be51c9bdacf3714120bc0095f879b200133e70a9b9db34cc62f875bd6ad81eee908d883ff096e62331cab5ea27521f8dc627e02a9dbdc72b258a3c3b04045d317f050c85f924a361ea43a2ae937f1bcd3abc435a3cd76587eb87803dca3902bb6735adee38d03ca9aa94044b16d0e7576056da0b44938236bb542ee738d9b807602dfed7f5502765c5d41a7cf03cdd07e9edf02762aac2621fc93b12c006bbe248327d8b0037406110acd1a9edcfbbc74a53918d0db2f7cfd8022789d330120087d4a1c99c91950e4edbc8066c057939868ece21401a92ac113a9c6081c1ec78999053eef18a9e5cbae0d1e1697d800ad970fc8bbccb7d2c1b0a946e82968cd5ed72c1ff995f768c4f12148f725562e9bbf8eaf089a47018e19c7f3b9b5480fb3313685c00ee64af0e87024a8b69a6bb6d90faed3bd420885af4ab2e96b7c9946e16478c1a818921897d9348cbc967d79c97908f39bdbcc9c225e66e8c912c89cf7eec0bc1be87bec2ba968ca427de79a5ea844e35a642c8c41249057968d41f023546bb7bcadc1be294d1b6c3175e46b2ba22a0e89540b4cc00f3059d3c61027b235a5a92a785e0c294bb9970778f06276aaec530f245db746bb931f25fd90ead330b6874f1058967457a9a3484ef3ca34ee0f615d567d24d8fcd9fc36fb93801a28b10795a88626f160472ee9d2250dc6fff27d61eca818f05f49a177be92513042104ad054feb5fcc49b3e8691f391192db49a3736b2e135136d7fbec130d560795aaaf8063187ae0d310c3a11945166a4a2f43ab64eec97430c5f9ad16e17cbaca078b1e8c12320c0c2cad359116dfb83e4f5a933e81f42f05ec7ad18ef64425bcbae4a16baf75da348d977df6faf8218832f451d7844f7c84768f2cd27dfe7b2eab1b0dd249e2e52ae0e8ca15855d25dbf9a32823bcd37db945a656770e8774631010a97a42e77fa3cfef771194d257f6aba8e8a88b9ef1f0f9d9f9cba2eed603bcc186b1b5f3c5fbaa0c1ee22b44488d54458557424fc0a211f3f7f721835df2be66caa0bd2a4c7051b11c44f44d2b558998952338bc646441bc3da1682e3e631c01c59d15f5991be0eedf1d727c4f3fecd90b761e4ce161e126341d1eed93d71e82ccb326d6170b29cf6cb0e1bacf9563e11bfb47b36782deec737e0b86373dc610a4a1f3efa591d79a96769dd745bcc449f09a0ac2a67706c9a81296ba3655985a6350dbc680e50dc14b5a8f9c853ce1c7323b83ce312e7529b81d758844f0ac8eb3c717f7545930905fb41e0f857ebf714cacf3adbd32d071b44769820235615a5d1cb23011f9c4e039143b9c9fde63503e0359a8c3f4f14fc85ae240b62d0fc448dfcc5bfe9eee54387a23eb4b70df4ad6d37435f8d9093ee9bb9a07117f40be33d36bd3cc22bdcb0cd4ec1e273ffbc34f29fc189d6ca1a84fb390a35bb4a5cc14207b5913c3cdb3ba7bf6bb421df5d3762341b319585eaa14e9a74865fba418fdf84c5ca96d778989670a2539a90afa3c1fbf3f89ab09ea7b2e989c5a802973fbc49ba20285f6861c344ed65973c72a8c4857d51c972a530753061eb92b297689640e1ca41274aa7d0e4b17da5a2cdccb7c684b9fd865ef6623beaa46357c4f5779423918463806df7ed404e9aff1db5298d2b7e59b26f9a1d781679b7a8c5c04d7230635dcfe32772592df628a93dc3b5f22bdcb66f0fd3f37752455963c8a8702d7be06b2a3246b798246616c6aa5ec3e277c758984153b0a8ee675f8a01e23e0f5d24ad5fbb46ea535a0838fb3c2687c595c89513c69cf38fdb0dfde18064baec83ca55023d00ba8fbefe60154c29a663968cedf51859984a6607247c5dbaa2c810bd2e127a6b714f6247827a51f6562e3f678477e5b75db964a40e1091e81000a519be4df905fa348fecdaaa7d72ab5716bb74fd1a6607cde92a28269b40d7741c2a6e592f99cf12d5efc94d3258b8132444f234d61c3b8aa62642707a6b2344e10d9effa0fa36c2a71c42762e703aca3b1ef19eeaa4464145743b28d8ff948f83199c2e4a7ada9cf0cdf64c2011ae3c42c630fe7c7df2144a736e015f273b74dd8b24d0133a6b648c6ad043b8d0ad9215b499fd9309036ceb09b58d36b1caae1915bf348798ec4efd67fd601f8e1a3d180836e64341c90f3c50f25113a345e2e4a33a39d5af7b34df62086e335f0e4e2ec8ac666fecaa98ffb44c3e385233c9886c73127bb102e701268a3738655e6ccf2478038628cf89b10380a64af9850998d0d9897d67a7217802ed240c3c8204c5d0f604d8a8432db2ab22ec840153247977c10379134043d9cc03fe528b976045d80968009247d54592c0b771dc74068c288e74f76de0bb200b86118d46bd411d6aa64ecf3878f65ace82bcf140935dc6b192c60b3fed8fa1618a3ee841f81eb6cfdf7811fe51c84736958f319a81b04161dcbe4f2c37d55493f28ee8ee54ac9c98eac6acec9d4b3ab57a407d8960484d9f16d9c616c2298577e8e38cccbc4843f5bec4a750d9705ee8e9caee8ec12fa52f2c04c511e927263c5c0a49dc1b1c0a04718ff076a6ed8762b96761ff211da5384747055066ef7b41131a16fcf3c1aa2b9f13cfbfc25bb1595c297444e7fb6e3f00d0c2c2bbcb5a6eec2b78f24ce7768debde4398865e9c530a6d6ad0c26efec1e07cc5bf32106588972d98b8d9dd26f66b26e8acb659f3eaa06bbed9ad7a537105c3cecf8e71fe22224cd9d58635b04f3e8e4cb94988c108b500b7fc6225a9b10a6df7fe239069f546f9a5ddb9f445a601e571a0f391213fa107dcb4759cb11c1216520298100778c6b40e76677c74832d87563f234c51673cda1133005f67b7586ea7c9a0a5cd7d3a2556d1bf54ac89616cfc6af77e7267b5c37ef458ac18a37230c05726c44508890f810a865c5a11d929d1feb3d2c1f5ffc79632a057970b91326d1a4e1b142d821ad84db350f70e5ecb09b5d498066482f71c5e59a8fd08f28c04952b46eb6a32de0580cafa2e6695afab00d7e80b7bdcf0e0782d4a4635feac3a0c501e93fb9f84edf3fd4026d1cd9f10c9f407fd8621772cefed93a7065c0b3d168b91adad64f48567b94fc20dd4b85014d53b7b72d14ba23b52b0728e4cf3a519e065aa267fd27dfef91023493c8e80d8251421e03634d6911e9c7b6079256449b0dc3b34101253da0e1416e77872b3779b7202b666067662aedde7d51e3f78c8f56b750ae51e7215f4da0af44f02a29f62d8f654a306d170e89c0f10c470b921edde6727f713fb858640317186af0abe2328fe859554ed878a3eeb35d1645c3abb06d188a618b8cf66e373dce71718dc0ef8377cde1a7f3b6cbf084761b01a17c86a624efcc2b35e5c92a36bdc5b450e977fe448edb7586c46189146bd82ce10bdc346b7cca680afe3dbf1768944c7501aeafb76a06f104060ad0e821739d275675b73affcbbf7445a4bc94646f411d1f5bc75926ee62891b7512167ad0df6f4dc23c9db862498b1c47da753c284e06dba065f5c4aa93b132be6756ea98217d7c08fb6af492b064002b42438ff977191882a6f7011d6a1060d4302f5dd279861761a6be99eb5752a40c3d70cf32c6b5f52a53b99c2580ccef6d2813345da2b0b3b5f4cb17821eeeb33aff3477177eea2bd8a8904d1dd2075856529561247356396bdc0fb5953b843b77ec808949be25572a4ea072a2e49992b7a36e2af2b05a68692f761c78846fb0ac803945fece4743c367f1743517438230fd8b3a67d686e159bbb4224dfc3493e1ad96f3bac30e2cb91bf26755685c4001f37653519fa15b1ed7fe2818073a4ad9f50614aaaf26331bf886b3c026ce54903db88694c6bc1cf4faf7dd56657c883d57efd6da2dbf9642ba9a2c91a74fbb455337e1e84453e5a5ed79f7728b2ae5fff2e6ecae9cd6f3a50cc8abbbcb7b807d4e80f7de57682bf154f21a78a9fbabdfe8fb22b25418689831349ac67bc90b3b3fe3d7ac5874c20f13e4d701dd0bfd6a5ae06502c13463bd502517509f6c9e3ff62ee3332fe3b480c3b5a83e122ce6caee7ee135b4a19759976efa01c961e94d2a40feb80b49884f6b75ab25845746cce54c08a2690add4700de2cb8bcf40a4830192f1dcbe9efb46690e56d459630267d162aec561ced08f872000a58dfb78742615fb22f579ce40a146bd522b93a0cecda71ac77a4e2e2f339f199c4fba5af9aedf0d3bb5175b2182e27a48215c9b6273bf2f2a2f9ae4371be64e7e8bdca5f0a96c29c745cb1067192e576f7bd93303bcc454aba9dc53b95687492a8d35c0baf24196d8b565f28d0625fbac300d1659fb05465eb4786426fe2eb609cf0a6c6b865c83b5e05742685293361a7bf88e93d097539ecc27a27ee986bb423adfde25d1959eee36262969bd129d2a496842e38e4b51ea7f9e5cd6ee5ccb1dd8f0ac6f8bfb70f5633392c73dfd26e5c71e1c0b756f225624897e169f2654512cf64cccb53685285858a8ed0169698f249b325ef36389f2355021bea57f88a5963b6961284acc517fab59af65f6da3f12a52ebb31090e30712bfff8a24d53f72bcce72b8697e3441c82abd2b0546bef5a95a3ec5a85faaacdc255a630fc2806f5fc3c982588ea0b42ff21ee0bcfe289c8ab428a1f90ff808f71001ed2d4820294544e09dd3119e547366a745ed76b3c6574f9bd552000be1a64a68fdd166b72bbc440c5d0a4b53cb54f99fe9a6f7271775d123b96864b80bbb84398254990267331e0c249632e6a4c17c3bf89703667805f1da53","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
