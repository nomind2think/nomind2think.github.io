<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34bcfbb0fa0d033f0901a6f679b47754af731f0d4e9dae7ae8712f20c763101f31473e5cc815a1d754e57fe8c413f17991ac8a171a29baedeae7ce7c881293501939946b249dcd1dec1f040fc48b59af20cbd140392dbfcdf43ea93067860311529971728aae4eddb62d6cfc91f441d839bf1a18bfa8563ef6f5b3e038b0c2867f962e8d11672c796de8077b332ce2f53aea7a2453ab821b182d7501cc44f36ae3ed65d046159d0df56a87efb497453c6c6bb95780550b6af399689f079e492b83c8a761be8f305079efb19e6cf05a9590c9a0dce9167358a2d24e7e068c27211150e64a0f7cfe6be2a9da40ebb423a50f24f57a0ce905470fd29b77d131afca42380a111f9a2683c914042b72b8e2674663cd76d8950139f5cfb5c97af33cd0c3578b13756332e01c2f5c62ed16a71bb90b2723abcac944e896568ecdd4682b95019729997e4445ea72a7360f7179f33d8f720d17f9075860bc5579281018fa8429197b380a5dc98c6fe9a7032f68c37a3ce5b3a9df9baf614ded813d6863f945e1566fce70d993cf422eff1eb398ee8facb38898196b2e4802948296cea324c03262d98b3730cb76d5a26d4bd605a98812cc9066d7f8f1bf4cf265b57e72c49c4a35e3a665cf31e71d200a1d7b47b6f627ce9a9ccb0fd832c0fd1132ad3f3c7157a02c67b7663a75e825c18ce812ed1ac5eb19529928601f585d0f6608a3c7194895b157671fe9a7097cfb634035a6aee278f0a0f9877c53ed9e1d24d7836548cc19e5f12d71b9325ad90463aaf92bea5aab3932e893e56e7a934439fdea2111a2f7a5d732eb5205e083dd945144444bcdc5c1fd105a1664f0056f2f193f1f24ed77cad7a07daadf3ae957f2ddd0536c12d5614721c17072a2bfb5853d2be505994fca0a9f678ee6ecc5d3557af2a4c7776de5e004515a9db9607d9a4a9450f75234267fb650334def816f61eb4f6eaaaca899070f945300a2c9885455f318eee10394facecc913e6693b4ad34c408df32d25f8b75488e07907159a1e89f4ecc9b70d4c0ba76dc0732f85ed932dedb55e20fd0a1d24c8ff6a77647a9d3f577b747077889788b91debba43e6633cdd4faeb78b3f49754fa86a9767329c0d3ead408cbc572d99db7e90e909db53c368b1342aeb1cda0b698c9c9b3022ccdeab414a3696e4cc211763d11165f1a24ca421b608988631e03c839033d57857e2b50bf870a0a5a70ddc47a8cd927b1589ec348c19996b83fa06fda287ae38b689c79b030ce309c4cdfadf2e9a1e35673234f5ea7f1b7d2a8a9774473eb49870cf8419e8b66ae593c68e47d923dd0cf3734e4aff1468e6317eaeb1436ef76c529dfe6f28b03e904348dd646ce631df37a2014924cbab4356122450193a4e45a2e1e590e3056244b02659829d7b26c1b7c4e68d651543ff709b4a06d6fdacde6230cb9ec314fb2a21f720e08980971bbe6560d6987e48050f86f333d699bac13108c74853737564f837cbba46261f0c8020964b4827c27366090dfca34daf78ccd1bf6d148d14457f6e9afb92448e9bb917782213c3d6adc6f1f250f75b6cccf46f3b1a4f96e59c9e3cc400b52a61ca7d10199648f1049dcec84bb16a082512c12be1d013bbcff1d13c0f4fa16ee988f18535f9125935966fca1bda925b774f1bb35464e8c9fa9fb71401bb755bfae094aec9c940277d5bf31bdf2fe24c74400f1c7f6e7aebb255485d71dddf150e52eeb254f70059874a40268ab57ccd7045209a891c64220e4be7464450e370e747234037dde73c3c7c1c560bf371f9c59459269ebe2f590952823f3c59102f193d5929eb94af8a0b3579c44ac665cc16a6ff350a41fddb68d5c7ea1d72c05a471ba228676dc8106fc44cbb7dab219c652c9982a0c6771d23944a6d7ee093795dc422f233f6e7d13feb35c47edaef022bc07947773ad5effb1ef1303e6640d605725850223522bc9f9e98fc7c7b3446e821b1a5f8e39c75ab33b8e03dd9dd7bf08f452ba360386b90448f1d00755e7491cd57f15b72b4d1aee38857ca96d579f38dc90c47faf9ec818c62091f51b2906f3792be2386c017dc8e75faa49a2a3058726249cfa3224dcd60147c12d7a12b32e5fea1294aaa30fc8c5e27c7f96d81b378952e80b1187cd8056b2b9b3309a59183378a535e41be5ab3f5030bf04379ac96e0764c34b6d6d0f037303d46b0db1b09bf02cbb69f8023efe2bc9a8e9032083d38ea072052f7f8cdeb3c6aabdcf9a572be289d1c7b8d16678ad698bc7b8cebe3130db0657e045205f45e191ba2d542f081fc8a9adb6fe00172b7714f9ed4fa076380ee2e63df3c870d2ac71abecb9182834e15ee47a4c7fcc9fb626e165241f64d94176a8652b26901556e032f24a8af5e5be8962afa3dcf92cb3f8e7ce5c7dc02b5e11ef0f97e13f50a2d78b196ea1e830113c4d41e297f551f6673642bba247f8c6296686a1b46cb023b1a818c66ec4b98a921ff5a0a979ef398fc0b932a0bd5ffc4f6bc63510b4eacdef3cd2049cef79e16b30b1cd33b811e5946b47bdfde537c9df03c987f231c1e4185462e44350141ff75a813a8bcc2e11c135208e51d1b7786e6eff32b0acf9c30af80c5b22347ca674e1a6430d74d116608a952ebb49ecdf90ff439ed5917a89e20814f6fdb4b2a0089409a507e3bcaf8979b8d053b3355e10fe78f54563f45606240814311633adb048a910240d6608939e62a389589a8bde76e4e1f3f6d4ba3d90d4b5224ef42a55e21096d7c0d40ee63897386fec47b9d9c110dbde77a3c4e429b3b5b9f07172b776f53bd930e9c3e83ad7725533af6e0da7bf7b11b979ce1a0b5b9a4c155d57b118d57a23bc2cff3925c88df64a389db14c5551f99bd6a5218d7f64b489233c731f5fe4eec2678a50d6d2f20a4ebb88dd976486bae636deff50c91f5a20da1996608edc5990ecfc92ad6cf1a9b7fa6d24b6126cdefaedddd06582621705da2bb7121ab4b668fae99db94130a623038d69ea297f0f09b594bc7251fa1a44bfb63450c355591750e6fba71615e92bfa97332dff9ccd2f7ff29720b0b9af73d806fa0be387bb64fb171ebe425b0c8c9d46e617e4ffb1901e1831fde6aa258f990333c5dceb3790e00446762abe96a380e47edd730068f31d77a5719bcada5a51ba20654256a6479e835505990424f9cbf2b391144df7a05dcede1b1b868075083cd30f861474ada1b0b878307eccb64553a8dd23d481265979a9a4e47955d33b0ae682b9037dd92291a6e2fa7cac59ce01dbc5defd9fcd7a5dad8b82c9bb6efb8ed22638dc7536682723349511b9245dc3854e38a9d7e4d7596daefec066959911bd754fc9e1220b04ea1049704bcbd4f760de78a57239058015fa41f800268b6ba9ffd4e4688b6663ef5c5375704510d866e98aa32a36fb45cc73eda4dd0ae1c9e9b4f2931f58b7d03882a3be3312aab2237d2e2d16e77141220c20fd6a0272dc48181e6b34de97dfc3adb4c86ca37aba5b3cf5ba6a76cc85a1880cd91d3f580c37a3b4b35b370f821fc6673e8e028183df589ec7a6671a9bba5167c31c0764fd198e13d1013aa5972bea6910a824bb490a242336c95d4a94003d4e7efe98c6790cb0ac8ee101f2eee32d346ac0c32bcd0831656b8562cd0bc063abdd87f78fadce563caec69f2d601d349aaed5cdbbd778aaac13f850b80ab9142ec01f3b06ba45f3f4366c05ca073b93dd1d9251789b613914b5c32371b68c5ece38dba888c81e63089fdee477eb4ce204b8e0c7a1b9eaefc409d91ce121dc24ed70207d3b2e3630e0aba41339b342812da4acc472d594fcfe3be5b2eab818add89bd8fb2d23624f0edebf28e33c7e8da83bdfbe96caf9016dc589a9f660a2fd8a2484336490d9077e255fcc11c9caff0c1d28e42f57eaf46e8b054c327d5e4dd612eb8e69291fdc1fa5711301e60ff4a5290e2c504c3057e6f6b120faaba7826e8a29d400b696b63f329041aea79bca58322cdff937fb9c86a323e3c1ccef105113619ae99882c6bfe88fd41fd3513a39fb008f73ccc5c4a1a6b45aa8cb91b8a6fcdc51a0d666fa8ee5ff149d74d46e17c2fa4218e82d3a8f7b7b7f1dd02cea5416508c5e2c5879d93907b676c8654d7c8bc4ff320553431f86ec7ab4b7a8eb3ad71d0fbf03a50c342b9a56e58e3c6d5998ebf8582cf8c0441e2fc462a4d8d571db0977a8844c7bcc1647d32fc3d1723e50bfe0a7e57b3a4c8f52d4333023192d220ba266604377080cec5635a72f867b5f83d901892abe74494157439bce752522e8efa3a22bf6cc5ca2da843dcf38839664cf259f310750cfe09924c51808ace83a0e46415ee575a2a424acc45064a4f7ef11b12be8fa279e1d22153444f40af51d248a4c64b1bf9b9728e40039ad2cef2af337260381d8dd827076f0de74ee2670bae0cd4a692507b59c05134db59139793c4be7d3bc0acadc642ceeabe916d0d9795c62a25af1a2e3dc6023a6cf04be68fec30a917ffd604ecd2a7ce5a850af8eaf6f1bb75c203cc3d9fe183e2472de9fdcad38b5a6222e2c245b964ebb636ac4c5fe4d44f2bbe517544b9823d06aad88c5bd6005ccc421d6a6d095226c9b700e664ac557118df6b789507a07c80eba2a5768c2588823bff5fe3b88787018ab9f7d918dc31fb3568a0457a9182aa36b3250ea6450bce491e22511b88d22666da0b86fe34903988d04a435ae59b6592c176d008421da42cb74dc63bff113e4f2fd863112329a31be3b1a5e91befc2788075213c994369e83a5633ea34816395a7b418b887bd0bffa516088c5d5d29bfce72da3418168925ea1cac6047a3ae57af89ff69710d86b6e34b5781660423b3c8c576462895cad38c9cc33aee5ec8a0fa116ef7708a3db4dc7537044d84489dbfb909b8e7afcc7e20c5d58765fab3e87ac700c735c8959863de61f911656a54daaeee1d73aaf66113bb324aa39a41d4537e7cd2a2d9524bc8f9c4ceae5034388bfa21ce1b10c06ad3702d8191e932da0105a442a4d7eb5e48cd598c162a0000ee86f683e088f004bbd0297d5aebba741bc8b0c86e6c0148a6c67aea5fb7e5fc4dfdbec48a6cfc09b744eaf22221cc02a47ddf0a0e8f6233ffa3906384342b73bd78d9c7e3dd66920777383780c8ff3eb104dc79cef7772837b323de18be7b65b1b9b8097499e8c1d675f8958a010b454994efa5cc730fa876d44cdef4b8643bd5515dfea286dc37a24a57031fe00e483bc20b039982ff5176c33ff9687f3cb61b24bf326a2c1fdb6a39a6a8fbb3d6bfc88c39698bd008c0b379703d707b9b624f428fbba19ddd6e594164a10d74f67912edb48b58c33530c7f0f58dbbe2a56cf62b566f8b900d2c48df366307efc6f6f891fdfe73c092617549a6381f2c79d92423b7326ac7f4e67e616ae8d2bf7b89634460c497b3e13d8ebb36528f6329cfc996c15625c0fcc6158601b76df25f8380f16766906b8d619e8ec2386aa2b598f3088475cddc22e3e802fc9bf6232b6853dbd24cc2026face0de03d69f7f97e71cf84c63c10ca546d16cdb3111bad22af374f57e980e35f787e9132541d11f254ba55b50de43f07709c9417583330994dbd5fa41d1de99bbdce71603e1ae17f1a976b783fd826a66f49c979fb06df38b491c6a77487ea33a9ddaab5e6317881e249448c65ae34967f6e39c76ed4de71f95efb515d4e3e8497a4693bb2c059265ecf72fa2c5895b0a8907972c9dd3ec9c3da260203b8bf9a419a7a47d7f2c2f9e078b4a5c8363de2950d79ba55b0cc8c1ccf7f2944f9cd2f6c7bd9db9bf9f6c6bc4098f6351040a3632e4e9037ea3db4664fbc3f1754f3617aee340b43192b75eff86086f0c5d66125bdfd619c3d698f9fb3e34e3133108756285f179f85b9bced375c5cde94a567959fb6de063c00300e49ab40fa5c42b09cd4014224a4ef84e25798b47fb56c32646d06bafae2dec8302332faaafa1b69b689595cdd7c36d137e7bf8135a2fb7c07cccd682de64189a1c590d7cfcb9e381e6453df2e1c889b61878530e532922622f28957d8a1c2ade0b9d0ad9826075da1b1dc45759187e60014feb8d70280ffe296ef6e004d35f61f3cb287fc9bd3486121974e127603a0da5f7eb08ba580cba80bcc44d1bf79dc52ed5484d604503e05c296749f24064f48a44171c1fc5be8241d7edaf12740f3a1d6bd9b20d7d6478fe75bf6df1ef38d116e23dcf9a8d879ddb6cbb97a4bfb26add0aa9202b2f5386d4e12aec9bc841919052bc869c94925e9495062b4b29c46a795095579d13f41d60ca1eeb6acc1ed4cc32b545aa01f524d535fd6f491ea7da17a856f60d49479ccc1d94b41330bf93be76c8f723503f6d834b2cdcb46f6ff79f6c27816f6b764b96ba1dea93badc3b60e37e157afb9901b18c51e68c03e0be3bf9d011511e2dc7a1549d80b7f46a699cbf4c7beb4a403011f9331668bb9d6d7eec6006fdcebb54f70f559c7f1efdffccdea070c9106735d58594bf4d951741d8716ae1715e839c9c22377c7510df4713c9e00b0d7513a929644b31710c674f0ef5bc37a84668c2c2a3d84d39c381136ccc8b2a8deee90e75002be63a87792aa6528a74d10a520cada397443e232a78e5f77f5f97b485e7de0a583461a6d637e33e09ba3b923c9b2b67ce617539d961962faa19b3fed07b09bf3d08509cfa17c27c66c6ddce302c382c2c29fd51c3baa0a4a63f58a19d5b6c64564d0c95d9739c038a60c36b1fae4640da2de0f9aa2e84aa172659d25c3cfd5edb85931dee3f491d9bb57e09ee1c8715790230875490473914c052b50195beac186a9d7bb14622d70e361462edb427a83f230fca8a6e2fb0b628b02f98b07ceca5b87cccbc5b086f0443c871dc585f8cebc4f086027c735166572571d9183efa1903c8da41bbfdaec8575076d62efc7441f28115e6694d77b53daf2618d51e85d203acfcc38bc9bac097e91fdb54651923cb4379a69f04a37c5a33e9e886bbd63abb5bfaef5424b0e7b3bbcc3d0d47788fa3665c63580e620137a1c0d063a42ba8fe15a7de01fb235762365ce472980124bd31b947e757a562f267191bc99c11d157d8286d61a07d2b46f91a7cdacca74544d1936e6568ceae18405aeab6471f654460da09333760cca277c9e819d2dec4455ad8678a61a32f9b42ad7490bf3165d523a2e4039b37a8e0967effd68744b7b7371950baef6e6af0482964e58642b7eca710e4b6d87802911119ed147c81385e2bbc76d721b8964ab3d8fb36d231dcb69b2b75b0a619c89d3d6b41e07a2c649330c4abfbe089fe638312d22000a2bcc8f2579491f52fafa79224365218933fef20429c2ced1dd7120022dca9844df8893fa9756baa7613d6a633d79c46ead30597e408cdf48349b5b49e0f09ed0e49f7c6ba83ffd6c17d490a1c3b3886ef6725f4b3278768cd89662ce8b3131aa91be07cc7d3aae7c8c58d7187b269fe5e461ca21e4f48d7eb7e930327a55592369a1839f83d2257355cee47d36d1f2b357c905d892296dce62c0c3d667276f1ceb60fd3df1e9e216895fe6f52e4dbc8d21a1852d084f999907a5dfa2bfddb1c9385e8d1cc2cc46c031f65b0f79d922bffdc9f02f372981046610f412301016cf9b39a9e621f7570cf3db5644e807593de2c70695dfc496ad2c4deb9033f7ec786d51c19b08b44a10a03a222b1817162921c0ad311ad79a1859848d29bf3ad9f4a57312021bef7ff7717c271e21f346ca2f2bbc85afcc27fc0a0f203c24b609f2b69d20bf8d6fe55612b455bd8fd5148f622526fdb11f1de90fbcb2a92e4ce401c31ef2a553161a5e44f8abe21519e4e09a35fd88e4e9c583bbfb7d2fefffec89f6dc63660ff0f1190dba477e6c09dd08d658efbd571b1e41cd1024ab0944683ee42155385c9160b022bfdf047573d0fa470d919b53c0e3eac7a58fada5362957cdd892bd04f9614fdc7affb74f7238d6b544e9e0b0a466390f71e5a50a5c66f0e855d5d2846b89394385324d8938c9ab5a3d26dec243222a35d2898624e284508a82bafd631b9c8a0db03c05849a58a2f83b16566902e290973c98fb3448e5303bea6e3f28cf6f071526f8020f109761608b2cece00dc9d167340e88a1ce6e8627e622a5182000babb20bde3f15f5809e238408d8f7771eda516657b19d2492f2b4e60c22afbc9418f66dbb3259da6fe1d60bd03354b4ed55cf1a2ab45b671c4f717c31a561c9cae377cb97dd82135e1e573e886d545ed0f0eef2b501d2fbdee8ea76c8fcc00d4179c72a019e121b89828e77b92c6aedeb517540c84861edabd5b8478a82a6a72b30d9e6fe37d82fef720d8304f62a770bf2e4e52f633353d627949e355155e1a641faf475a15e946255905a82fe7b0e5959769afce99ae411ad31d6bb39b2f49849b91e31562580b5cd7e23998c5de46f2375f03ab833fe6b1f514467c83e46754821cea591918e4fbb6a2a05447f8a1ac02c79576f32969493ad082908b0763de5504113f7d2bfb3a803fe11a2ab2bd1485cf5ef7a7f35f5a54d05b2af272100a7bf4f99a1f83cdf01f61497fdd9b2fb6351d332db835b9a97bcdc14d5af30497655ef7c99eb14266e1a124734c25fd126330bc0efb9b611e8972f27d51dfbdbe65c5af6fa0407ce7cb5736e663e4cce31c02f41a479f9197e60d60d9742c66d8b4695263f042d10abd4631cc69047a7eba2cfdb48c73a5cb35d72f1d03d19ba07fe76ea9cf39a0ae1aadf6da5b7c3cdf4e80211dbc132c79f7bdb98a6a4a88f1d2bd795ce72d31f05b2694769f959fa754fc6b537b0c359aba99ea051a1450cf2d092c0b58f4668f38a2c6319f332f1da1cd160d475c57b05fb9e0ef5c705f0026b6716dad74ab2ae5b5b8c088ed273c6fc8203a9dd72891c57ad54feb0328da73e0f8b09b30cd19d23921ca394293faefef673e101fba28f07a84254cd34fc72d90dbdc233f76056e6da423a59d6622be05ad1c1d5fd567179cb121a6a1ee59c9ca81f2a97984f323a2cdbe6594cc6ce993e69d1d2f51334688f3fcea115a0bba62294789f293f5178a9e9bdc3c8812b19746bdaab602489c933afa027edbc69beda84bc32c8172819b02a0d860f78b774dcd642c28ec7cd6430fc1ee59d1661eac0fb6f499e8e62301ef028e91874b7992aaa62d04b848961cda724665d3dc41631e302c1386cb6a67f82bec0347543ca302bd4c9d637991bd3c8071d9add3da365dcb","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
