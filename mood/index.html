<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf023bf77bb28d3eaec47d16b7a767916a8812735d0ff6864f8292de76f524892d8d36f3d76b4076c4837b2080b84365489614330b4ccb2d26534c82015f5afb4f8494c78dff8c30d72bded077d859c97e6f99016bfc3e0d4a7db7fab42b0694e4f4b3e0dbfab6b2875ad26e424eaa9fa5a0aaec83bb60d9740b548fe1bd19635a4319c2dad257dca8a4d5a3110888285337397caf31199c2f4f610d1296990148321e09c8da596bd66653ebebc5d3b2e8d6272e61ffeee031e6a51c05701cd1ee553b37515df8fb28d7a81295a94dfc9f9788d6d3dc43944d951fa36a568b9bc18b82262c044e081ead9ca9370d889ad25fb760d58b08a2de972c135d49c9af315bc82bddfe714d51d546b3933d768d0b7ba34c6f9340984a17e14e326e314b72e2b399bd67a453704ecf13ce240863b62aa30c5b5bfa9ce4a99f905f23d77d49554b519a1295300f75c52b3b9f834a10bf5a57126f98b80e57422162c3839775ce06787098183ded7821c48288ee7c6299154e5fc395e7510f097d39e8d3d5195afd61dc33113bea94b426bada14e878572c4f9be0600f9ba53570b008840a7d56b1b95d9a3f3121aaf212c5d54c392e5c9bb72b67536c7ab1fe839fdbf37089fcd0b339e214386cb7eeb2e9a98a7cc25cbc250aeb339ad1800df50833286f8738cca13959bd80a6a267227373ddc908e8ceb962eb0cc15f90bd485fe7a8f7ac8ebc9aa6b493b16a38014e0f990d254b6b14a0ec958ff072696c208690ff0520cde9592f3173c8249e9d3f803da9ee4366c1a440067f08ce079ee0ef9f62f20d079fe8437cc668e104c82bbcbfbcf053961ca68bb3fa6a9792180b90217addc74d7202f5a63cc778b13401e82b0696fb41b2922bc37aaf0a3d3114bcedec9a72be5ebd8035e207c055271d7fe4252fe6e24381107081edf3382c9139a884431deba2b8cbd4273ac3210c1f4272bb2c9c2311d73807cb1d1da77b072eb396488918f1b29310b4a7dfc1b960e717cb3345f8cecb770f864f90422adc62b55a8d024f8d677efda6f1ebbe03da4ca6fdf96da5af3f4968ee0b433b3d12ed963dfc98d4b80f7b7d85d25247ff0a620be6187f59927e450329e636b4d8c952e28bbefc0cb6ddf2aaccb7959cf6b9dd2414b950691fe49bc25d48cf8e01f744043e4bc092e91c54cbdb291bbb09dfabc0fc08c7a2760a6429c0c0bffac744d35c66379ca5c48ae1a513ee7ed4ea8c756a236b0c2d064a4955c68153c2ec7b6dba23f25a9ba0ee9252a5ed625124f88f1d1b4572c468de829c7a8c8989f4ee9f66adfd38301038ca3af678d1cf977c7ea9a436e3f75962a333dc3cfd15b8a164cd298c7edc9d5c0fcc0c4a12df424c53c67e49025d93bcf880dcf9c1e32e8d3712e0a519b51e16ba61eaced5fdfb24530a6fe8c9be367179f7dee551cb248298bbf8aecf35723ea76bbb964a14d91efad61d14c8e589291ff2872430c260445184eadf371318297485a6bb850171b964a6097f91173694e1bd8f97a3972f59b4efb3d2cd57aa4b7a7a50136ce98ce9834ce7134af53f7d1d0cfe8b5deaad328f4b7c7c7653d5f283f8169821358f08613432af15a9fc9991112acf9126ff97d186c542b54c8e1d932ca28691dacfe7f103c6a751245af8d85b2e264cbea23ce39d0208e7a88aa911337827b9bb2b666366fd0e8d5b991c361b6ce36393bf71d6fd224f8025f3fefdf418ec7a422e045e1bc0ebbe6266d56e928c60e03653744a982e82a046f3afccbf97a9e70d1b681a479f921461fb3557adb95ed2525fcfd37a047ad061a6614c094eb063cc0697727adcbf017f2ea32947b45786ee3aaa63fa247a30201e38b06cb7a77c76c7ae5b04248e3b54661083a0f6deaa196b88b1c858b2e32fc95ad182ee37f2c76327e938fdeb7ae88aebf31a92707ad5f1696c0326fa91ff6fb5a06d0b640fd827063a9f397e671f425155ea5b011cc0ea1654629e90b615841efb43c2d489a62c0bed57456c20c7958397f760f7c2d3366cf6102f975c4efb41ff902f06cf665e92572e94ab5a2948b855575e92e66bc20748104f463cc03a8b5dcbe4ed477d90b34aac18b5ba21176c66659bfe298bfcefc45291c719a2e64192442e08f0ae4e6828047a69d9a2be660e5ad5bacac06945171dff50f5ca7d823b307c4c712f2c6a8ad6952e4c08e372eb4bf95649ed07038d357600cba9caf893e09451a2e8aa5b0af368b7f106869f3e4f4a863ef5ee47c09e4a77b2fe3c1a96bae63d53e87287c026ca9d5ce8cbea748c990dff0dc79504215468abb9095f70aab2cbe591a72c4bde5644578e16a7982c38713b2f2a31785bcfa547f6a11257384f052685f8eb8f21a0766adaf11f49d68cd2225866204b3960c3084046632ce5a26b85434e064ed7893109ceb1a4d96ef42e2116beff2b0b2d19bf2a929c6b2169b497d152cc586172ca8b654310a6d5c5a36a51fbc70799f06abbaff29fc619131990f2e043198de59af7b64e2ff5175c19f077a1fd78b5150349de4067dacfde80a079b683630812347d1b6113cd5fb776a4c4e4ef8df9132f828220cf9326fd744bc7c7d41f315caa9678e69dd240ba588daeb7e7511332e11af9fe1ba0304e04ffbfc53d9d11dbd422996518acd37c488c2cf5312a730d250b0206e773a66fd1289d42ced559a2e29d01eb4948493ce12caeb65898f4746adc09b113d9b906892768f4d7dbf5a0a38e70f5856ba61ca79f786fb629b611d80359832d06cf362990d7a128ba18c91d7eaf51ff950c4d262d47e48327766e13828ebb559791895f567596120c51233866eade87122d7066c31b959bb29e62da464e95599026fd55070fb2a926d90b005af447603f516e498dc44f5a765fefbe19a317216ab6882b2c5ec08d0c6ed3f8fb0874bc670b79f184063849b3ba53c1c4a2210643b839e43aa4fa2e78b79fea79c343ba40a67b1e4688995e1e2d8006ba671bfa5f034cc1a6e7e8ee348939fb3182a229a6741b683da2f361921eb5044a15e11a3a5b52a383d2f4ab5a1d4493a777315bc68bdd4f711530d0483d10898034d001dd8f683089edaaf5ee219e213ef327086bd6b2880b05d0fe5a555316b64611fa0611d1727acb16db59d5470d18ca2279d36b80c79d1e57e41b8d1ab402e4619a74be1ae5dfcc700aa01eac3babe8dba315c5aab382e66ce358ac15f0f79a1a641ba69dca3977882a9ba732cb9e3ffa5c78e16a5a658ea93ec22c30d5b55410a5954b34130a1a91756625cc3c65c5d455cbe8f9ec87e0c6548679fe644396d131b959db8e1cf5f11ae3b8347d025503cdb7aa2909207bfefcff1591c6afff49bd39e272614409d8d8066aa2f256fd34fedd42b76ae08022e914a23a53b1494c89ee6caf80eb3c827b0d354a5f7f69cda97b08d1990fda6b6da2ccf2d23153521629ff2340beb0d6b2f003abbf6d6b586325b53015babdad61871c8b413e59f177061751b6458e362c02d85acb541bee741f5d9b4c24246b7b25777fc57e054deba5a401345202f137ea858f90aca6bea5f89601e34e7678640a2be86a3424bac8dff636a0c722bb131a047e62d052a2d778d069347f7b7d0225a1e1c2490d8d8019c29988bee27b6b528b9d7ea2a7d92c88ee3f6a16ff9fd60c16d86c9412fa9be44f557399df863068978170b0063284d006b57ee4c78844c56c6a76da888993fc4ffa1d300dfc394ee0c3f5549f693363210f334e49c2b1af0e37f9d564ec241c04ab2366ca1146ee27d6b2fb5d0cb852736e23cd97818b3a868f7da50e9f27345c5d99a36fa5c11c6a8fc4d0883e63a88cdd295089df650e04010d534cbc40826d49b3a549fa11641f229c4c167de52c57f2c2b9ea9b93f79df847a4e5641de0dd80e4c3044fdb73910d0a0588d6e4e4fd49256649c8b53c81ba2f874d6a5173281d9ff1372687134ae576c1f1f0602ea097fbd166453e75ace5da8b10908824a38a2c32657b69546c7dca1969dbeb3514478f8106e20227405d66bc34c88553758f62af487ab7b99c0952361e217f1ed1f109d4993fddf95b85288ad5c38481659a2b7de9b9d63eb2d7b5aaef7ef79f46ba899cddae770e2bfec67477325a2047aca5ea6f84abd02c84fd41fbfb363d502c9ebe9120d0f5fa105ebcc071543a6f7510c3b9bc115d1472b0edeb8e316e5b472010d0e08e38165586594cbcccf1e9c554096c9c3c3700ac60dc4be00ed56ab7cce6296ed4084440b3540e786c0804ae0394f9c736bb789e56c82961f2180f241b8f983a7f888b9262fa742fdbd067e9180915dbbd2f032e7780a1f041451305cad72ad837f55a10099c559748d9eb4fbc90ea9f30a0ed5426b6dbc0fc337ff51d53e6ff19aaa27e71da8cb9773bece48cde2de7f4a7c858dcda13badc4b19a06865fd248fba01ee814ee6a011c301f7e48018e0d8650c5747679a8d2dc021023a08779558c7742d8459c76db39ce33cd408c56f964b5ed97b76e6e6e32a85d2d78251f96fd675a09efe48ef6416cfc5c80c9fe232e217e447bdf520f1a95112e131d81b25303c9deecee4a22dff641fb788f7e3877a0c8da3acbf191bf3aeaf4bf8db2e140550a5cbe1ff51edb3b70fed3798ba6ebb581194a0e3f7ab5e64a1458cb195430899d79d992d06400399c759c56d4e720bff88e8facb180afc777b91b410b85a50243a3466c39562a8301b1a195c9cfa0adb634e0394428f096f197f78425accdf611bf5912d6d802bb9eb768231e79ea8552c76564271e07a44cf502f46a57ed04f75f0b1c178a32dff42531a3d815af532d2228fad0a16ca726a4b985cf7ba2b1479322e8dce257978844a203f89f344a120dea4fd5e5b80c4bc6da35b7d5601622feb39875ee4af92a08109849424920570b574e867dd9a16f7974c42385adc50eef6e0780d594a59b53347424ef6fc67c7c6817916e71b6dc5f080b90152071ffebfb0f3b9ada6dda24b44ebf6804f6f025fce96663db6254c839d08ffbcd4f372af1425af6f89caac0670054d4248661cffe2ec732072f9f2f04e4ef32bad338868d051f506a5b4347918b08628e6127dd9bdb4013ddf4a48b7d2336b9af62489130a9792cb10205c2ce66637ef2bd9ade6b46c0f253af014a807b10439e31e8efc36f39b3d78337f5134bd866fdc728c79f6d43dca8b397dec35dd0c0691a3402c3d6956f72f3cbea05a092ca027ca8dfcdca0eda8dc1402f509f99de00f30a2bb26c10c4920f7b7c04e8f9de4ea5b4311d2aab508cd53a688f2347a42b5463cc00b3af7ec3c3017393a9e380f7345a3c5677c6de209dad08857e71aacf51426229217a48aba077b1601f934117752cc284c6aad80569a911789aa39cd0026c2b7b3539d68aa663b9e22f401b292e89af594d92afedb66ab03983ad85f9a8418be176b14010ec8d73b58348b71d599f62067e87f04cea90f1db1ca4fb628832e9161c4ec8ee7ee098b1aa3db8f14d80988d74eb12c199a1394c747f0024c65a5f9b87f62b43d674a6a90f395306e7fb7801ab99d0e0624d689817ae2a203eae821bc96eaeb43c076d59daf37ad395dde11ef5bacd817eeb09abc6099737f9e8a8df0e95737d01f65d4f7ac870408f0dcff40134d9d53cc5ba6967ac5e66b6bfa72e62d08ae0cd225f3d1c3044f8f1093c697057bd27ce309ccae62c741cb1d52650f3db91b3fd19b9bbae93c497e19cb620edcab3e4d68971e5993aa81366b5fa6c2e2c05eb74bcd32d75dd59321e0b8fa50cd7416b89a15226dbe888e08aa9f2a2a99dae15c3f79bfa8993fd90650146129aa13a4bc8b34d1f3b2e26e9d28d26c6f63d5f8d63269094bf4c44a7680eda5d0e3fea70c9455c16c2b6acabbea71bd50783a00af1cbd4aa280a6f4446e91d6491f69cb6958f1f8bc5719f61d83e473fc7f8447033d05562278d02d2c02acdb89cadcaa038fb154cdd6c5f7322c52ca55eec939d0e68c2647a117bbce8eb664ab1d79f913f18ad07d6fba34f1ddbaaf1bc05edcb39826b994d097950731850600980e44d9c3a10610ca12000095a187a6a855d4086ad5fe9844244e1268696bc320fb10fd07357fdac5aa54cfea558bfd43c5d08e0184d54c9d82337f4c90ab8101afd55cf76322c999365b5eba73eaba361f9e41d7640226cf4f389f181553c3d67f850dc7f535a2bf9e76a31dcfa86df662187d4d91ce38a1292949de43356c3afae1c87b5fdb50695aec9b14df03695b13ec4b18658e94720243bf5c4cf0f69d9ebefe10197fb84d683256aab62c70f896e8aed6a08d91c82234b5f9087dc261aea06f1b3f99b268edf98aca19e419a9dbc4308797ff8efa3ec79b2eaaed934eea792908c98f0a0c2e7daf264b32da422d90049fe109b3e5c85e958d71454119b1167ed5351599aea0a0e16129e40099144bda70aaf96447a6099a9af3eef4e73754e7ca4dded7173480252cc50b1afe4d7e8d80f40af5d4c8a413f8dd824f513f7f52b4f22490f89573bf09c460f1b70dc004ac9d47bb92c12456ecc1e04d42482e6e93493ca5bc6fd9b93baebd8f3ab08c0982a3d82a52881c2d4a3a5121cf49ce50ab783bdf023d6470f75aab7e2a911c5c170ab570edcdc8f17997286113f5a12aca055164aea7efc3dba2ae9c1e7fc9f33c794a6f83f875b6be89fb2af8d764342c4e43bfb1ee654da28d6bb8ceb543f245387690970abaf54be4c7ac3edc8201a26b35197baa0f7829d1c07491a65790806245cd0d61447daa27675ee5499c37caf06bc1a2d36de7e1bd5cd55b94ef4f1fbed24d1ee30bbeb5179febace2ace43044dbbc453147828a34e9ea5bb8999d9c1a20a5078515cb0662192bae7d7dbc947066bf77433452ea3db3cb75b293eebee8132682278a42406aad6d03266d1a89d6a65265fa24f0f6dc316c3142e16cbea214f52eebab64d6c106278d1135d30ca30c4b875c58ca75e32c33f30f4a17bdb618ceac97a0cfbe7f95a114887183adc7ad456794f76f880a4685e7ebe916e8da83b29d77d8ee3b755e3a02d26932496c1b528bdbfdd7a081bcaa622394c189e77a143027c1c869b1c0ed317cd73b677ab477f84c7ba1e098ff77dbb94bb47d6461e3960c9eaf3aead4293520407fd9d95be52738db7582dd2ef9a5bf81c6f10ea5692a192be24ddfa7cf99f4c46b5819dae6d43604d30d58d12e01dc0cd607c2585112168f0a536b1e17f70ab6999c77df66b500da8fe8c7e2bb8d05c416e38e400c6e7735a7fa3080859080002b479df130d701bdbac7037583308001d7457ca0ad028e54bbc2c3200ea1b480659e61fc2d8b1d2c805159107930234863adbd716d6f362f7f86feecf0ce889c0709e0fa937628991c27e8a831dc570a98039bab9f78f724e50d22707b54e3c5759999e0ba64ff1545274405f9516f9f8ca187476d24b0e2c4982bccd05e18e8eeada3006c47776702098897a28bab822611e66da5e3f8e378443e9ceb4e95ebee1be05d537a9f2bc01fa15cab809fb5356f6b91982b128d9d83e22a3151b9cf1141f4b9e0d66d7b62c5088f65efe0c1319a25a656f60e1403d4d46a7edc05812ff0ef8dd934c57ded9cd06e417dbc4f710ee28237266fad5f01808699a6e32125d232d9e3500ee0ba2e509fa5b2845bc85f804858240453be10127f07b252f297fb9e8d86c0f4627e9ef0e73064ea943f61d9f27586c2f28e69dd34c901a45b34eacd306fa0e64ebdd52ad3e7de0f3c6b3d0a4ad856c93823107d32c947b51e431bf88879101705c1383f0923b3d7b6b3d29f08316efcb1134986fe34601c1136ff9442eec7818121e668008d39dfab61dfed27bbcb60a563cbcf52ed4ed76d79d509c80d3023c15efa40c5299186dd153bdeda3b7e4e1be5c40df0790ba0b4887dd74a7b228fbd78a478ec69f6a38190fde28d023a1be9793ed440157fd1e66e7605281983e5b8a93a929c820592cc47a20642a6cdcd721eece50cebd65bb5016ac65eb0a964da1ff7c8f295923c2302f6a84a6c10f8e7110b56f7410a0114d2fdbb16bb5fe656986ffe793c1611e02e32f18e4e5a20fc1a861ad3cf3a07302dff5392dce2bba58a094e50d79519cf6950a45c841bf2286b5501ac7267794ddb7d9edc153d0bb95e9c5bb1b9afdf442a9f705c7595780d98cbc39a5d46191ebb3fcb9b32d1900564aee011c41c87059f0d5dec89668b751c95b9059cfba7dd6329c1bd76474f05f6bc6a0dcd9c1598a281159ee8a16b745a208aba1540eec4725b34893c8db3a2a8e4b9f43dc1dfd416908020c988318aa939ea3170d7e157e6d6a7dee6c7161d684dd8c1bb49c5db9c510cefce4cb5a684569d9b771bdd37ae203ad29f018ee635014ac8ec9ca5ab690e0bf43e86c4ebe0554cb8210e5bd465bd97a136298f016acf2e88f7e07eff3783b3a33e29312d1bd5ecb21394fcde2f38493d1d672768954080867497e55f2a6bdf335751c03475c9655ad12c9842ccf99865ee7f5fb6644f4caea46d293d45714cb4023ca8f95cf2415953eb2ec19ccfde59cb855cd62b9042ae87167d4a542f029551cd7d0f305869e43775d73b98fe0e28915ec8e6d7f925c60ee72615b8399d5cd1157e01b9af006f4bc25fd3e238c7aef539cde81bc4ec0bf8b72e644ac5d3a07e4d0354fb3d40f41a830927ff60902ec37ee1097af1cee4572029226b8a2875f55e88899bcf106b5cab13ed88db156302095710eac164dfe803bebcab507b74f7fae4cd00e893559b74cab028c2039979525285be80a81ef86bd5931f019f0a5e006a5ca1da106c85d84d2b00ae3a6331f8a4cd3d7f989ca6c813eec4077278d2d383c2382dc23ba62dd78ee7854b6922823752a7cfcca1e0f8fc9b412ac263883fcf54a9cc6f688741d9f326f4a398014982774f755adee3001f8ea4dae89a39f5899f534df05ff71b19489caea8ca8826db9b60fd3446930fe75d17dbb1dd8f1bb20ec1cfa7620e0640f1529b140f0c52ccb65229050d3b9b424cb856881638a114c93d24a4eed01137862e13d585f65a445b667c489b172ce694a6a628af0de4c4efc2c815557ccf36ffd76646511e2c6bb759f6d2cb8d05c459d790d5daad0816b374af65ca332a426ea263c6075bd3059a77c128ea0d0616836d211db4ee68f47e4385a48c1c45433e452042af283a8482a9d02a40867de1d1efb6e2daceb75a5d857a1ae1f556e4cc4603d49c0935bce8a89cdb5b177544408883c5abe3ebf53d6e51d3ace051c5f45ae30fee78fc1d2c224145276de8d8d5aff4e7c61b411dadf62415895624c2aef9f33c03ff659229ffad3f0bdfc036c6d17c91f1b5214fc52cb1c01ba21c725268e37934672224c692ea8698b9b46fe933ea42b7c1aff0c30e54340db1d351cf500b7fd6d9c46d33055b596c48324542b1dc55b36a2468adee721a7f082da417ef88bca886f690aeaf42cd19fcce50218e373556cb7c7f7e981fe2f415e2c752ccfba34cf91abdd427eefb9d538c2088a5f597e373ff4ffb2816295c532f449399b0e1ec48e8227ba141804d7c909fdbdd88bf4dcae6bfd38df486b4d2c265f2f952c5aa30d6f36084069cf06115d0c63226cbcfa6e4d8b3bca1739f5261f066bdc40090af7208946a1d9b9b912c07e290c7188b16ac68958f5aa8e1de4e09b832e3fcd0971fe464afa2b84aac89eaa0764cf69edcd932ff686ce65c0e10053704f4156c3fc171b67d1d905c6b1a43a372a8d6a5d84aef265ce1eb4379efadb91423105e5ba4e31313b3364a3c09843f4f59dd86d70625d6365cbf151126f05d66425a3c27e701cad525fbebdbcafcf28eafa61ace1e3b8fbfcbce155dbbef8b85e3c5a7a82d1244db6396a5806ebe55cbb3bb34ac3653b60a62ba17e31cb01d554a84f5cb1969734211cdf0ea73970720597bb9edc04a45b7bc3400","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
