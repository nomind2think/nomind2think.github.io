<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61f26d7a14b51fb0906be5eacad1e19af12d2bf4df71a1606117a00935bf1355c9c7da7009ea174bcd22ac961fb81a376d454411da360834264773f38d0a784d8148eaae203cb866ebbecb1e641e1d7f077a7a49e5b534b2987b2d5224e91cbc0c1ab9a00fa71f10edc9811f8a9224d9759fe51bd073ae52aba9859cc2f7d79694f2982a4b3f24ca16e6b5054ec5e488478809f4b73522393256a855e34eb7fca8fd5bdad6c60709211b1e34ec893fb42824626340bba91679923ef1fe3f23c2a5c2ae3181a03e0c744cb7b52ada0b4c26aafe2d11dfa9ab19aea2d7b38a6e69cf1a8066c1283cbe84c73a3cd4f6944e5f49dd43683b65a8ddaede1347f18e11eeb06f57fac30db3dd3c3cca0a2ef035a2967e729863c8e1be160423cacf6ab4bb20010115e295a3e43c434c61574105b77db0704d5e470077bebf922ba76fe934dd31203a13ac1858e0bd21f0e94dc04f7d6111be297fc10d72f187f88cd4e0508783d427c1d582ab89a212055dc78a38b3851406259ca71eada6d123ae0388862df09c00b7894940d4a936ee4728ca1e990aaab4ca5762610e02a7e2fce1bcc9201da8f1e1851c144c92f5d43d3a09f4dbbdfbfa0df321475f60b6817d2494395226af8d241a987d9242d876bbc5b8c6acac2839b72151d08937a40e13234529f686b78184ec01266adf7807fdbb6f5ca732ec36b7b587af47b73c26f19dd8221f3ae11bacd9aee294e8a273364bd1b00bd1cb5719f13be6076927eefd1396ac5a3483b618cd8e4b62275f7fd5cd0848c44a8b3d47283f915d6768a7b65cfecb689bcd6df229819ee04123429adda88aee9d73b1d5424c3e1a8d33774be51886cdcd2e97cc4f5247b137d790287b17f515a07ab08ca224609afbdb885f0ebc02dff364666b3329ddecf6759b42eede5cceb64959cceb682f99774c5852b332a9ae241598afe6eb15ca44329d5d3d623739d45cc5aae6d868f2940a23ce74428814eb086c25fb1d1b6fadc4b0b4a978523826326b0648f53bc110983ec32ee1e79be63d5c816ab9dba73405092363c6da80d8061492c43bc5a18bb780012c7656d8f4206c5d5a1b1d78a5d84339fe85e8c60272ccc7f5a82b8759caec3b079325fe9e83f8f92429606ee0a41184d8dab27ea2b964d486e86f1dbb4ff6a7fcad2f29fe9a7e551f01991c4855361edd7cc23c79e0e43552f45c2a06107374694d07defea3f97faf33b5950c58d68b25a0bd9d1c30fc53e9809d094a27732b3840f3472c23807e613dabce2e4249ef6d69e386ac6ed329d90d0e0611ade9298c288b04e153121c3e28166911e7aede370524057730e78bd18c94816848cf7d101d3c8609fef9b651a1fdd76864a8513c71a935a8d3db581df041f6e32d1ffd1a8953f80f32695f2aef7414213b2fe284abee5661fb8476f9b4c68ae1e7f9c9948dedb5cc9e51eacd0bf953608f070d078dc1667228f412f714d8b4a20d556de42c2e231c3c0a4de45466df3621bb5c2155a542819496f276483d4b72c97ccaa46a3b1b2d421ba8c91be521486341c1b11557224bcc1ea1795bd56500e48660f1507681ec03793f485c01c8435b9e44e622f74ac18f620f0fc1ad9b291420d4eaa10033459469a28696a0cd3744abbbe58382fee880bbf0b1682ebc0c0eadf91178faec642078676fa77400a7063c3a5e8fbb59f5fdec22330229f1e67b8a24b28b4263a474dea9c9affd86c338b96556c5134e70557b66350f4da81054154172dd0b9dc01c3d4f4850a34effd3a941a2c78bcadac2162cda897f0c75f0564504a40ea0d7d85d1309a2746cd0f5b4c892c0d6f21d32255acf99b90b60e24af43459a3300b3948b9a3b1a66840b1bcff4cbfa6fa9d12418d673e1b48710db98cc6367df036ad3ae05cef6c27a739af7dbf9d1218a9f0c36edec143e734eb32ad64d0744b080e43abf8b340f46c21d15fd15bac6915fe7b9c5885136de7bd78c6363de2383ed60eec0fcdc2895fbe11b6a145f036580b1894115e95b0b467f776972a28db184f9f828c5d9ff41627513c5a8850a49523c2c8730a0d09bab45e4872288c05aa4c31320d5b4a748b8ad54a81f4674778dd899c8681433c84f99302da61204da9fc182e853ea7d0d215c498be8ad3c3ad454523ee270a1d50c0e25efb19960ca33f60da97bcb98d48c572bc8d38687e1242be703888f75050e7b7a496f4d5880659847747b7de90e59711173390a241a5639eff5dc8aae8a2e9b364ac5c500699a41232d5c5fde2ce0a90f8e77490aef79675118bf88e01d63de12b2eee7640fec9db0d8bcd54f1648e1eb56d935b4bd1c32cc8cf498e482d2546f36178e6166ad1ab0708174a2e8cbf5bfa9b28520a8069b6676ca828a0fa4cb29be374166c68f3eeff29f80fabe3f825f0ab8c6eb31071315c622aa55cc1f5397a65f0a86e0fea99173b1786de2d8cd37050ccce73dc00149c7ec67b24244b6756e49ef4f8cc58248416edb730284a9897a6d4d8ab3e8b5054f7879fdc5e921d93506ff453a51f45345f67fae0cb9c64e00bde9cd6ae360b0c6b4bd74a942a4ac625e123c9927e25942d6bfc28945147a24299205d4c3e319038440b69afc53f0a10dbbd8014ce7f3b1d2bc69e3268f9726c45043f78cc7ef2b5ed7070a2c6f786230ef9c5adb19f4f3e4816a6a0d1e450080463d5f21736638111a6b9f635166927b0e2c2e210be350a6c372115fbefc88e9d187f60d19b9858d237bcaaa389a7694cb9065fe244053511bccc9352db4d4fdcd6a43305648998d9688d493365ffe27e57a080d1ba3139774f8391458b8cabdfdfd3c8e10e9de7f1f3ba85ff75b5f7f7d86f9f0f70a54507150e149f7e3b141ec48c6a48231f536b69f30e5f4b1133935882e6c6288b85df371548f6f939b67ed17002685f72a4dbf4e245c4c767f93c68545f3deb5607f791722f0bdc9d2e415fd6e2c2af20f0c1c3126432c06d302a91d5d643ed7e4c2c9124f998d860e91087c117b69717313f8f91d13d5f7ea01154973d70ddf8a1023ec4917bb08b7356da6e0b5cc0575b3e224d363d9e80e2f64c75dd967db8403540220ca6b87072067526abbe9b4ea2179e0541360a593f7182983001c94002dedeed6cb643aaf94811017a14f507e6bb997efc90940d0144fb9043b94cb4404b7dbb77f192c3d2d30e66bfacc9c874fe08c87a18438d3d811b220bba10f60f348ddbaf10f4f9fae4b083587115e27f3ca0c182f8c61fc074ceb8e9ee3bc094b2ffe8a0fbf09b7516a30428c95f67d4c65102a2d10f4cd0cc01c1e4a9362e7dd39d0da7d149af55ad416fa50681c2b4d652a7e3f7fd516f0ce952db58d486a525ccc229fc02b8a9af313b3275e223f0ff724827d23a5ee5594e418cf1b41034658cee12a374521d4d8c555217b4699d5327eaa9cfab19b22550a1015bf2127377837f3440088a158f56ebba7e1c41ee02ad628b0d7850aa011fac1e2dfcd3ac44d08f6a272870370b9320eebe69bbb53413cdc66e4c5de930263109ae0a6ab6bd8a70dc397c65d35110aa2cc6dd9276c7ef944d158f6dd5fa06cd3260027b8086926ded00f5d9ee8abfc732456e5e86826c5d721fcc76fe3fe136de38c2743b7a0796d0d4a3a3ca75c68d74e827e2f7f2149578c7809be1f8a987ed5e758eb4c3a131d83aee179d54ddce5d062934efddaa1fdabc6815ba8e7328a44c5b1bada3680bbd2fbdba4c43bf88150c5e805d8a6c3f03bd5eaf8abfab82b8b1785bf91795f86d6b0890c0361465f5090d990c5b7a9ad86f490edbea61d661e14ba8cca50c428bc7172dbfafc9faf194bf6307bf6bd9bc8bc1a604cc9c3af65d09882de460aa812a6de407bf6fb934a5f8ca79744343391d3250acb8f503e63e842c2e6cbfd33ba01efe9a219b26d28aa541eaa65878e1aca24fde17c22e8e7a15d133ace20ef41d0953fe1671084c15199893fc40f94e8a085158143d4661ffa1c7b8b3ead7e039a09d003d81fdf1aab374ed681e59c73f09b794430138e3dd4db75063d64c27ca85e365c3851d366d71cca19299a2f20ddd0538f1119c44860157d94843d558378ebb0a9c67d34a5bdd68ce55f619bc54b97b2408c7470aab9739517a9dc0a80211f65636491b9b2c0dcfa29449d0d8e93aae67a5292e873f78a07fc70696c4af034b3a4dfe618f1a7fb125be3260acc62978071c792abe0269c8115b5559dffe436bd10c187cc53fe714eaace9d5b1c9b880a4c8b5579ef910ddd2804d1b158f2f4016d876998a5ef6445bb24e42e3caa0dfb3caad4972febec20724a67abcf822015d6b60e6d5227bcc16ef747c475115f404cfb5ba22f27d1eff8744cbce41354af336ab574d883aae7861d49070581934f375384d83971ff1809d516dc467b52d8278d129d807993039ee32129d12728df1be881224e8748edea7950dbcdd922e916a86bd6027af92675f1a56d3e8ebd9ff88e05ca38149bd10239191f5c8c1f69469cc3c20883027c3a3516cd9feec2f51d59f0bd04adce7c5bba921870f005450a6b9fc3ab4815e3197d2e4eac37dbd0d98c8daf6020497ea33a063ef0aa15c91f519682daf93ade5d41fbabed3cb29fbab91a2a554d666f1e848d1ee42841b1baccf39d7c4aee3260ffc0dab24ed1de2457bcb0dc37acecc789f211d4dc53c7301f5471d6660409fd61ba58d265d56d44c36f8f34150467d89c7291df660fdebf3fd3031a85fb97de2f3f880d7e9b1e37204ba01a941b8270d8144991e281f5739f348c031ef9d6b55c638b35d38ee1b3f4ee5cac4b4e072260a0c86efe92d46b42ab1fbd02aadac6713143e6c4712d210559c718e8605a0464fd200cc4b87c0affd806dd4780e3ba6822944cb294059410b6c9194b91b676e43305caee8264076c3c19d3b8dd47dd001417634d42e51043aaff19c4adfb0ad6f47f877880738a4d69c3ac556ac83e50068c621f0418519038318abcb8a74c58102999cd925a5430b4be71503921e8fd133b5f2df4dba8e2dedbd6a07af8d86d9a5511963c2eff3b699117dbbb72fc42a3db92dfb51d6535d2510147a8afd18903d85b22ea8c9e8171bcc7603bf315aca4406b31c8512e038903b52ade677f08ffb41e905b016b1af8a5933fc0cb1cba21d25784d8e1f45b82b61cd6bd0f8f5d3239a5090aacd084cfdccad8c9792ef97a8f9c51427f236ae59b9139aa70be4694c3af57110f5ee188f6d255f59a016e1c77b7ea0afbe25f1274c9f62bbcb21aa49ac3c3765a874b336b58e547f6d2e9f1343dc8793a3d390a7a9513c39d2b16c35ddf141b81b1a2ad95284df0dfda5da87c0ec9faafcb4a6bb61fbe9a5dacee34b28be51ea77b89fa98cf656d8adaac872f2a37143048faa92c135d29820cb092b2c4b8c6ff1b8717663f993593e58fe75aaa3bcb6db110fc1641999e06e6286c93893ad31ab54bee38b29640b620afd7e38e49a3ca40edf68e0a6235db44736f8275f9c2f11b6c6fb8e94d4d99e7bc167b3eb9cb2947f9d43a22de9f5c4f6e99cd295d39346128ce0b5c80e48fa542694c9ad6c5785362ee638d4102af2a5debf936397ea443b30c2fb55e02e7e03fda959dd5418051d3da169da8e3c03b624075e2e16f3b856c9b5f03e7e91749e4b6cda6a11bfe46138f7128eddf4c7ea54ca1f355c1c690cbf086cf4cdb3e50a2626226c02c2ac7ebc130061630b24ad0fb0f52687d1175bdd28230da150c45ca3f4449a9901095d442fc55a0aa5a688a37817fe899b691f695657bf88c565745aed3d693a7d401c9b950989c9074a943df2eaf2f7b05bc251bc0a3144375b90ef06a0853f62629c4a1b87c841e5e8e5bf520ba3baf1a41c56d725e1fc010910c5ac1d215d0c6d6c25d71fddfd227a67175f4ee1a435a29aa2170731f06922d4a71cabfb930ebc04143f56a40f704ad14763121d4a98b3f8cdf242f2e67c41da46a1e82ea61c8f3fecadb5441d6d54efa0aff2329f9acdf937d5fe044d938264b2149b24b0c2fb7084852d0752fcd9835f0254ff9d765ed913205b65489674b27c74d57013207323161049b813bf4059efbcd88419366fd8e6e0bae9bdee33782ec7bf10ab1fd3d3d2281180e47e01b3d5a5ca5c1f349d2f9e3c29c6055efbfe5d699361ce21a49c3a71d0572572821039611d2897fc2c72f3b2703bae0c87fa180d61fb8da79037e79a5536e8a5711d57ddc2bfff463067e0b38463e9f9ab71ff92742a76b1429067180e6d2c4ff82a80348bbf13c7b27aec621debdf14876e911af7b4160eec6e29742b3551653d484ac790303ee36db4808705b71bd7a18cc7e65e3d6bfee3edefc6ec5878902b8eb578689af9fc1a999b38d31ae38f1212e857133c57e1ce5f658f679d24eaea65a72f8b8d268da8a76de3d407bf20001ad716a5d4e5ec1487ccc9d404fd8c02bea1517b3808f41e981f40156a4417a4d6d3c96ed609ec395d859cacb5b15b2a5188c3bbc803a56e0154efad2cb9d64edf374bd01e59c7409d0bf85fba8bf873b64eb5587a4902a1d7e487c2a31d489387a405272d6af8bcb476ae44b0d9a335784e3d50e3cbec8d9992215589fc7c81699d782ef41c7a147b27f74c504008be663ea6fbf1420a6e45522bec6ac83137e22c069acfca01023178cc43a373e9308e9a54c83a47b945b43d22f179daf9f418d193738193fbb0626600420bf1079e9ad38a445eec164009dd414eb8842d31fca0c23b805350cc2b8b73b8404e991c2a6612bf9512e6bd3a879753e8f4ca02c154af512fdb63736624162f24132e94fcd4aefe97010ac6e8686566255c5ba86a395b30684376a2c96a4b3d99751526b8c996f93f14864784a7dafa9f246597a3be174d10bfffa4878f5c2f5585e369bef3a89a42f785fbe1cd74afd07c4e0f9e1abaca7a49580a49891450b2bf45efd53858372716c42aa7bcace81cd036b06a58860f1bd7d3e1f40c3d638b766e66c58823f4c5513ceaca2d05fc9592f7cac4f002e38d2cf57b9d9bea4e30974c2ad307f188ab21ed1768d49d2531bdebd3b0c0684aef292c0d01aaf4380849ee5e416ca1acd5b17db768964694ddd3fed089db82f71f65bf0374693a6f0b56afd560e4b605e18a9007f4d4c2fdb708587bb57563d4ca2857d647bbd70a3798c8a1b9b1315213b785dfea8c6433b17171a235b446beb16e5c93f622c33d50316c9d4f95f2f4e3ea09bc5495cf062a4489bda9cc702c6c69a7904cc02fb23039487cc8e7f1f449b1756d5b84bac7a8665c793a2b29673dfa2c0459e9956be0ed2da8a3cc5354a58aefcb1e8d03a3d976d4a610bed6b793ef5e11452344a0e25cee0f236c9cc77c65078178cf0898ba71f927183832e34a1ef294196963de77c909a807cb19b99fefbe5037c97b5c08fbe99ab347347caa213d512e2c53b87dcfa220f92794981ff1ec2de31559543e50f25c3b1f95002a87775f1007517d219190cd3dde0e2e3989eda54e2d6f5a6a92f76bfaab44e5c12bc7f3b3aca5b8381e13ef55fa1b023aec79c0b359df1a57391deca195e9232694db011220b19c34f3cf14f3a444c69962eaed9f4f95910534829716c4d7fe9647c6a2311775a4d5da2729f8b547337b672fa10447c09bbd9451d61f6e9671a53d92d2240f3022c2a258804b84690d084a686579c6cc486692c8e871b3104002e7c758f4f4a8a655bf234abb9864837c2d431a1b724513d07bd4ba79fd8afdefc2e5aa6df58d18a65b2cee14bd3f166f68f976b4f778be7166c847540f2335ffa777e2c0167ef7936cd3ca5d3f4d8918982e051f65aec36154780d17612ab7cdfec12e380c38298e83473a0469cf5984feb81e56f9eb1ab67eba5a4c3d846ce34444dc7508ab770af5c38c6d2a8fda7075d8f65ee0bd4604bd0946d3b8b96f8e05a0875a0929d533c9b2db1d9b513c3b29d9894acf4261bc3c00fd3285e4bec3d3a568a7e5931bebe37a4e50d66cd049c1051c9b95e9f455657eebb7a8ca23c4a502d448367d296b86897cb84e1fcdf339479e74dc57536a3d7b99af670515e8d9ccfbf50449b82f4169e376c1589db0cb414fbe94e0f4bbc308900d324258855a3759ca95ea691e64af827d1c63b052ffab732e50ae8660d89cffd1e358283a64c5c2a159660e69f470a5eb9c3beb238d4ba016bcfa42991ae8452e74394aeb6dfdcd4aaa50355f9231c994f778dc6f179649b53bf9c74b9cc987db20d26c171830352fe4bc17c8f4172654150e316957613edd88e9d1e42f03782f2ef31119e999320918ee908ced4100fcc3c3b808ba0a06d78be1e8448c039e48a0d7c16494178d02a08aebcc40d23630c7d840e9f36ad9f271bd4aff92c35870041df4ef59e41a690a654ba5c9372109083d9e27a06140abd93ecfab2b69012f69d86e236a7ef5b505cb6d1292bbc9e2a182121b65754f54cc234d6f060a72bf2ee6ab242ed683f1baab18747df69fd25c5e0633f77669a061179ff76853d28c5d07eb98642ea6d17e937002b6d9671303f2ed698843e96590a62aa2ac92218d1b16026a1e413a39b32e46d789bc364b95b27245a79d35fe624c53e42c6c99399f912e0eff5b7198449af3ac95f93844aa06a9972ae3c07c100ecea8d67d455143a5b2886fa169bf212772e2e2b92cd7c22a5e9263bae6c85ac21a3d4f9f1b852a920d9c999bd031254f969b5c9b43df79e4feeda424d22c7ec6cd2a6ebdd2c0e0e791573061b3f0767e3df2d9bd380ca20d101dfc799bbddf0a9f2e7b1b852cb3fbfa6f31c528a7d5e6a17dc27ac083f830db5bed8cf6b2efb5083225e74dfc82386df48a9ca1d9917951c0e0bfd6bf11efd4a9d55238bb8969ef5ebd8350d3fdb3eee6fdffd4554654dda63954d66ec6bcfe5ff9c8de0c4c659c760bbd8f69ea7e3aa4d47df93a8d0cb4c770f650881b2ceff69927509499c560d1e212f74779cbea0f88ebf4723abfe032f8ae4f2107878ef18c2b2d4dfa058bb2f0cae8bb7a7fc4d5c58f62ad58f43a0c4b2780a851f52d1252a5f1f1f2116f26375eb94118bb9e378f6e170cb123f281ca0a84b5c4f4d12ca07966daf7c9dd308c7668a86e8be6aa6c50e881678709445e8f2ca24716b33b738ec01933dbca2bc5a5eadd86fe0bfbb9faf3d8edfc0cfb87b77a04e5f412fa8c42fd844d9200a95374f6ce45349a2247f5e0b676a5f9e06fc120e127f3621af0bde5c237cb98fcf9f87ec6ab512daf20bfb3b9d9774c5b3e828801249a8de94f80a53675dc2e8c536f3291b1f75d523681e5b9a5453226af0c62dd9499bf3c7f2762d834c66612293bbee12ca37640e50b6912c0611c48a4acdd96f62ea710a127a5f3e25c50635f5762cc659003f8986cd5ead0039012e5330ce56b2ea2901fcf797fd03ae5dc2ed80d0c3cc03ea6d08e6ad208898f605ee2acf10f4116e1d8b92ebc1f1261ed3ee17eb973179583e1c6e5301e9c15d27e8e4492883955e9262cb60b2e5e64f1f7adebb0792c4c763cde6bad116fd4916a8b43ac33f511b146faab3c532c05755d2ba07dc5df97e0b36f024fa88959af576fcb2336c307f8c73b68bdc32b67df5161c4d8e193c4cb0af13469f71a5ed11eede638780be7f0fed189b7c3d2cc0cc333fc1aad47b841b2e9b7545f7918ee879c0db11340a14c0459902e73817acad3180c512ef9f46fdd6a5cbeb209e6656aed01d8ae51c7e409fbedd3fd2388aae8b4be645dc2cdca86a0d6a9142a3d0543eb9db7fc7e3cefc0cc4ac351e5e937266758ed49f34459eef3fb10874fd2fa0eff87028570ee6c5deebba0cf4fb63dc740a0e2517bb0dc2aba36da8f2d194837c4fc6a04525d8e4ccb990c28f7ac8fa07102c9f05706861857dc632c92f5e8ed1496d191ba20c41511d1ced4e1549b1084012f81a41e6ff7a3dbd61be7b3f1815ede2e5de2b9845832298edcbd2d2b7e2ba780b1c2baae080838a254d3e230068942fb6b0acf5cea68d58923109e3104b115c6d44177f5a525c385668ebaec80a256ea9cfaf27709ef0d4e27ce51e18a642f646925a427f66f8bd3da64491e6041ce7312ac546dd42124ec28d7f817cca8eed8b7b6431e1966cdda2f8ed4bed0cf016540766ff5754267a424771a7065ea3433bb994b8a9982d388a6f13e2880e34b4eb041a92664bcd4f8c1183e2d9fe971e9d761f3f2ea25ace019862814a3eb3e36aa04bef9859874d9f741ed391085d006d9c04a8a9cfaa02f599ff75e2f5935450fcf27538a9c714423210f2f5312fd442594139fd1cfa0cd134b5c689109532007195f37b2dd9bced9492f29f72e06fac24fc25dce1733bd31767f68bf438405d54f956f442acc68fa0e527e8d0e73a1d05deb2607d9e275dba38a817e00a9b69e87e791356c3b41e004c60912518d94960f3d50f8f3d738dc894be3abd0a40c03bf05abfb0318249abc6512cc31f5e528aa79d968d5e6d2a67abc5a0ef5ae7ffbfcfb7c5696bfff1aaba97d557c226d590b69b1713caa6076273db410a10e9e7c4d62d4783eff1240c2a543b86a818b3a313323a6c54b1ead7b0c5e633c83886720f4edb4486c16bd90ee86a00f8c6139441adb3e8c821fec18dd08f1ea9532b3ac5b225e71eb97bbed3fa60c8c6c456e1e667be3ad94cc23685a6e522a4ac69fd5cea31080153acb2652c40a1f1dd0cd4b5a9549300b55","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
