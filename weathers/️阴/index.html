<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e466ac9fc4730e0ee4e030aa3fc6bdfd190b43719b6cb0fce22b158b60f49495e0bfb134a95a9eb5a2fc120a2d3107825fa3f1a8a570cca178d23afca4cd1a7e9f0227a3903240d86b9b335d825f7fe421050065c8e0341b36583417101b2b92f6d4f893b70ba5f021f7727057d1c865eab93a98e5be571063bd38e0c1d7bd238a05fff24bd09790699646497d721c252803926e19d86e18f3a3ed7918d6015a5e9d501fa58e36186ac317b88ea3b3786847da583edd6025b057953ca748c44ea2b50639d5c9247b92474d95fbb7d2bd8aef9665fcd1345b261abbc727f1b4d94ac5e75aa28c230b6ac28c72ef42688b295777f06cb2ee44a17c2f17636d7b642cb17c043dd05aa1fbc77524a6471be489e2dafdb0b701b4e8c9a8ecf3823adcaaf96e2ac990005cde367d6e5a0b8b470ad7a5cb45318f8837f08a4478d5eb26cfe2ca40bfa6b5d0acbcc88258a32a497f40534b8b56c8b9dd5f8d76c89868069ae31179c792704380b45ef3b59c3b051087dd3320534b8d67b8c07a5d079dfef3b991b134f3b35362d37b419ad98ee4f9c06c43c5f73dbc4556ed673b5ca897598d57fbe5136a2a14d0ac53ffabb9d43fc1156ebae884935a1494b74e53c2bfb71fd78574ce432157eed5f4a60b21250ea32d4631120dd6942fd6936a6b8ddc21d31b9da8fdf4459bedf9c895900dea069183c1211d570289eb71404e39ff647687cc9e6cb68d7f7060cedbacb9c27c16506f16033bbff23b0ad155602a8c2ba390511a218e729d2a5f3088e9d9f1c15bd8ee45c76529bd58c0e5927584d0a9ff96011f2f5e60c48cf6424d35ac64aeaf59ee226d846e8a9c18861d07c994a7f5f987ba2e42fc7c6cb8a51b4c4cacd782baa957bf07153fed29ba2e4fa32c6e887e7f14a7b5ee3f812df8043b7fda339341447d326ade9f3c1b470dd4adb7080a09bfc08efe8e6aa57c8ed3c0ab60afac5a414829f1bc18756e5c4dcb252885d725fb016bf91559432b6e8212af0a7b8a90920ca3b001986c8a722cdae571171b9f0a3badea59e95e31c0014b4b654a7470128f2523c4fc03a7b8f50256149666a55f1eaa84926deec016ffe0272684d37575851fb2d6bfe20eea14448f5359023fb0e6e81b8b192b269aa194dc5e8d1a0bedd91c8a3a55a0b680c0841a53e8efbb2046faff632c6558b8f77c3b220a31c019e193a206228aeb3558de0ece82ba6a488f7c942b0197cf7e74d5ae57909a719ef47c8aa0d052786abf17533568a74787fef4e576367a92ee7da9c68e74ba4e9144a6fc6a44f48f0b7a46bace0773f37a2c54b3ce83fada5462dbb54199e139b20acad44b32a482ade3a6c8b009b8caba78e6bd9ac4db6a0101baa0b8322de25d7765fbcbfea944992ac63bc92c06cdd0ea8e286a605f6a0f5e0d46d2b91678f19967867cb444abdb0cf0e590a8d5f5c455a492aa041a30e84c1605b8768fec373bf6304abe4887d037414f5beee0da019b3f18d8b68496f74c0cd29089a85602a43b7de8a176f2ebf657b39533325855e1fc85b1532b55b0fc058fd0fc103e26230d2d53aca0a81f570f2d4a08a284f0d5358360797c702896ba1dc5e46b992a7c4b3e76a8f2fa215c22f05b2ae98b5f70feefb3f9b6b03cfc302e5696ec884508ca00cd0d09ac2a238dce9fd165df0a7636f67982d904d951448ec2985ab1f4c2991a97efe0145b0f2a51c945b8145d404e3bf7e9f64bce39e08f7bd1e83d7bee30954b80ab2c2e7e05fda22adbfdcf660b019ebfe5558a24d35648ed2478597e2ef62c1e290568d397d64ba96ae9ec22e5829275885ffb2c01244f4efc4e5cef757772b4341e265fcc7523a140582b72b91fa4e232871bb9f5132e81f0c5909f290cc3eeef3758c1e2f3dab9061c096bcd4b9cf2729f17309d82949e1f37e9e2cae717a320bbcdd03e20e1dcca93c077b82ac7c6b87e8e6a8d1a8c29f6431999ef3834d1cb427c2fd40cd7131083f0fd0ac60a4135b32396f7dfe63ecb8f57000f8380cb8c734739bb20759a8e447361e90d5ea9748e854a825836a412201356a18714a9de43980aac35658307c9d4faf83b4e9697bd1f8564ea333cb5f1f9c014efcd5806bb7ae6f5a265ae24d059698fbbf588b80533b6d918930da64c1587f3c2499d658ba0f3a2eb556d4a22ad206b383afd88cd49bee89ecc7ea81e4ecd1300864d244f16d3ea284a673600d149dbf0330fbc7040b8e204711cf28634d329e978b029f11c67783fbddc06fc7ef272af72f66a05b859983e361ad6e319ed8276c6e222589ff2c5be221bbe53a59325b9b06609f6bef00d4dc5b06bd870bb2c2acfe555b0601fe570324f552aa7f86a8e098044c9a2249d95a9229d04a14485429b570e81ddf43c38a25e28c4051bd2414cb4dbc6757b0fce14860cafd94196819355265d1f8ee96be5864ae73f63f2be26223a55ec841d05640180c35acf2ba327f3ed495b787f3b31dc0f2dbf44e57f64f7fe5ccd3667500b6253c06a0cba76123788ec091c7d724d3f9ba1d39d772cee2a001d5075d02ca986fbc3677985864bf2ebd3f34aed3af07027ae07db43b61dda0f835410d3d4f113e30301cf494089271984d9064381265f140a75b3e54142830c74eba727c061cb6269da6ab7b25a528391442b910dca0fec60f04634b1a9d54147d0622f7a13ae184b6ce939a2c5fd48f7dd7d0467ce078b6467853294b212a53cbe6485f9040aeefbd5ba753ec73be9d1dec4e2fbb222cc922d2e8edd8829e551b5e9862b6dc215e8f2cef797d7c059228da9f2317fbfdd5f2fb5e18d5cf7f8291ca36bc2f7ec66637d4e0a03b24ae42011f7c24a02491b695747ebe1a8b919af16dc490d2dea3ea36535ae8b5d747902632a72b4db43903954ed38d3f02b73a05a22b889284373f0bf4b37cc080b8f35f9f8ae8d2a53b4c15dec2e2a3cc45162aa5744a694822b84cbd59e4962b032c8e4fe99086fe4014de1b879b72a258cb26cf28c879233d49abad2386cfbfb683f0c1d6333a5504e5b837c5e0b577ddef254e2139279cb6abe17f51ed9c9009c26ad5fa44c9573bfcddf97fa2225bf13b769e243bc7aebc3864bcfdd7cebf5f467609cdd706d5d9ef1a4eb01076fba038986c756808b51f89f7cec1c15b2f83c161f40562423e2138d36a1d8ea3cb30e3895e8c7f3645d357b64c89b42f13ee8f452136eff6d194551619947e3797d855cb34fba14d4ca75a0c30667c058b7a8b7adfbdc88316d378cc667e32360d3e56966dbe78b7a1f0780dd2ca18d8156e2c7f8d1ec58a45403be3b0e6f81f005fe88448980898a3b50e5b533d09cbc8bcd59908bb42ecfe3b8ffccee0b8d1875acfe04f740c5f4629a9cc7d21479452d9fb354374121103286ef19f876f48e5d1f638159446e68bd63a3820ee73ca19eee7b793ff85f817617335c667c374785678c805bd9837a8c272f84200e92ec5424705795e324fc5f82f5fe8de3f7a98c3d857746829901621a8f47719d93e326c63cea6ce60c3b8f92e202b2916ca17c91028307688d08262f6de2532f35cd03cbe0f03063c37b1c4980018dbe55977b9c3194c952b198337c85b61adc405a3523da8f0d083481f66e2cb7d2d645cb8547a746b80ce2aa5bcfc2746bef0ad2eb77b6957cd8b62bb62dd83b3e9b0126f81f916f40125e1e0f5913ca9da85c182b2e692c508344b45ba3e5fcb0a129d0149f57f0dd6cc9beb5808b5f43423b533dfb3d6fabf54ee84cdcbba0a3b46cfb834e6524669f056bba34927ef60d5a61f7b08e014a3b0facc054a547931b9e03833b81e625b116b7ac4853d0930e50f29f4caa173ac3b51707854cd05e21a0a79abcbde5e89fe3c56a3892862f2fa5d1fde328721aa4a810dbf754e7e0a0dbcf24425edd324277fa72589269158762043635e3bb32364c4ecd65b8c1c565d3b51e0ebb0632052658e59058a3f3c32ad67fab701153444a16eae8ad48154e52a508432ad3d51c15c9c659f2d5f9dea6259a08fe92119fb0543b3994f1f8abf6d07e3200852dd1cf7a835006a7a3b35f9f3c741537ce38c72ca63356c44cd2ba0d290627bf380dbc417fff07541e5ba34a43a089b2213ade4d77b0e3b39f9eabc2be0e5d2c688b8dd27d31c3705fb66da930fbce462759e4de8837696769d8d5f1b9adc5ddab7e9d346d00daff6c71113d14ab231e23319cf3fe58599505cfe66fb5ad25e678f4a8218c9d26a765b198a37962ee5ae1f5e29cb2464a5099ba7425f3837ba48a5ffa8cf212f43384141a59f0479e6b74fd27728702182abcea9d70a48697c14bfc34974116355d113045387b14ddeb33a306eb2c1171d9b998684b445584f21bfcd47618bdf38e840d6b5ff13d2452aa577b2f09c161a130a597e03401e3e51fcb9f68c377004fcc8a821aa039e1cf9d0fb424ff9b6626d9d31b2c2c84765437208fd4e5b25792cdc29549e9cc96522c6ede6c46c5965c56e910b7559725976344dfce7b9979bb945bc679b92fc5f20135f9b397922a6acb7dea313e23434f0cb33bafaf984a8014926eb1b97a87ba749cd11cd4e8b1fe23cd5c0b855d9af953757fcde7949aeb4deeeee89cce0015496ccd3e5c5c52be695fd79747a8f4ade9ab9a2293318705b4fa13ba90d9408085e381f5b2c0466fcd0167a138bff30ca8d301e5ffa76eca53cd0e2550549aa3d36eb6dab858bded51c432f46b7c958f4b8d78c89543028ad56564e4945adbf1866bc1653e884ba0c25c7dea1598dbcfa6b14f215d480baa43e6c9d31206958c413976f19e5d27aefa40c16aae149c767f7af6c73c1f23b3314f0db30d882f49a093134fb336f8eeedf4b27f7461670e720453966ef6a35a8db15431be91d545a9febb80cecffde7a0dd1027342959abaeb86d0212bb691d65da9e3f6abfca7d3c5ab82f241fef569422d3d7f7a4ba846a04becf713f2bab4a867fdbda56ebf62447846d5610dfc9a5ba42b3d37db657022c7d1f9af6ebb694f4127c0b89af8a0d0d3c6c2eb115bd276face4bf8e42bb403c7a14254a2a4abca4e78f5daf1bae1231de567c3465f87a08f9eb881252aeee3f4dc9454b1062463df2e0be58a5634e55f6fffbf1eca0ce93d0de8605d752ebcb22896d3327ec8c43f87cbc5a674d14765e468e13b3cdf887776995399cbdbeb486821148e48ca1f8a66742054404cbded70526f55daa5c9e3446992c74fb830a53ffbdadf41cde3b732a54a71a3182f2617952a3ba284132ea768f1d36c7b1b3c46549792b5a44fdac140472ac329fed621bb7b11df5cfeb4632e4a1257e4151698823238b0f3d2328882d08570656d8f5b68928af7852edc090a92008ec9f17ad23b55794d9c177e412323d7764e5ad1cfd6073bced084cc94f72e4704cf0825845e00c0680824ee502f9cab83cf1b7a5b2d62d399566927c86eabfa3ae2780f30d28190732a3b486f6b5a69da83c6d10570e4ff00098d940ce1e6d21be7318a880e13f2835c14ed87de69a89cdb02e9de834f1d5b23c4c2fa13f2874c087f822efe635dc3555d0b5e6a2b14836f965203dc7516a7dc805a1196ea00eb5f418f094b7a6a430ac2944351b75b086bfd2dfde1ee3f1ea80004b0f1fc3a1ea6f9e8e87aeb94d4345610af1bdcf09dd9835462e69c9ffc80c3c6aaecbdd3eb16746fa83a332a7f1bd63421106d46d9374a618209b75ef993cdc0bc5816c77d60671c6f7c87812bb130cc338d25c26ab58545ff69919b7ee7ee65aff940dfac1542db1cf14dde0c46da07d44996433980a96b5531c9e4e41a58f85f84265b9e5ff19c845081ea3901c29d1488baac816b0030a8ee9f83f2e0375b6503f3bf80f9ff560d7ab4727bbece40443c7cd53e479ffb654a794c5648b94d772e1711b2f4baa1c1ac8a297aba581521c18c594fcfb1541f847d59c41782586ffb2684df1e505055fe5a8fd0d7d8a792695db8dc2c95c6455dd9deb10f8b2731835423273447926f1c7815e7201a7f1c174a81d129278bc6559ff937ae683ec71d1ae2cddcb0ba91668e506bcf5f2727e52fd903e32f4eb83b60b2c9ec2dd2faa3429a60badf1b6e252126da820a1a6bf5ab70c03a5f0504590b614483ee0164801a512089073f090ffff46e9fb6aa8e22985e95861df469aa47e8a64d7d731dedd5cebbe00c5c573d00854e6457bbef29fe1db36675fd287e9ce43d908a8d1c8a78605e421534000a9a72e31856a3ffdc583258f29a2bdf8c5d56f8fb19ae8f694da18c16345990f49d86fd700599560b6bdac87a4ef26838ccb32f59126e9844a2e1190e671b992d5de8549e068078840a71172c04a8399dbd3ddebfaa033527eee603e20d9fbf3ed6be40afe4520753731587bd0fb5d3436c0fd6076524396cd9ebba78544830eedbde3816d673fd03dcb8c650fba7b34fe4008b0d65d9f1ecb4e3f02254d26d8fa448bc0411c312804c4abaaec79f31cc3cd11d39b55189a552750d2211ee29fe71b00d6b975b073168ca899cb0e4f8efb30d339150f17a3ab77061fcdf3338883993006453a0055f4f805e10dc7448e5031eef969c463187586c289fea4f5383d2637c9cc8e800adbd535adadd9b56ee50e3fbcabd536f77126fb0646514b66cf95ce115c71c00e86758a475ca8dabcf403c71a7d21c6521fb1d2769fb95297916ace831b348bc080544f0c53a5377ef6b227eeaf88c5c8f59005f2c11a145cd6d5df4b036eac3c3d541c3af675545141b2b34cab22e5d87ddd51381be1fef9085671e4f16abdf20ba05a5545ce42629cf92c284aec13806d83cede0381e08ab47079a63473ffcafc0f6091c8cb820ec96f3983dded23f30db2df50b9fae73a0dc1b512af207a068b4b600f5e103a685d3d9eb4789899ac62c7787a79452cd36876fc61b3bf3ef45dc08f58483ab7296acd539fc8ddebd91b8e4158a6618d7af6a87387c41e8b6546c88b2c9772b81a808b69f72e7d53aafe43eaae7226b394bfc62804a99bf34225582990fc414eedee9b07dae33e8960edafccf0807dcee92ed6cc28ec4e595560bf600c8544669c41acb00e2d1345e02ae256e28ad6e1d8acb6eaae77c0c1cc3c8d4746a2293900080fbc08878e5b7a4db00240ce0548e6bea9ef9b8487f7d33d4059976ead5c31a64a13575ab590e6f9caaaf80c8f38031b56b262c006a2f5dd61614e5d8f8a9e919a31fa6f16490747fdb4b9031cfc294c57f420a1fd014093c876d1c0469f06c18423b60097acc3d0517a13b8df99956299ebf673f1c47fd902a663436091f0ce622c375db1ffe227571307673510772609e2e992244fc67073f0449c7c9cfb860e1e0da3ee9f046ef25be9bbd22a8c1202c6b1d717a9a8e5762a413502eaaa12d75b27452f9ac3451227310705f09b8cb78ac9897a05b7ba7e8f4300185f8d7eeae790ae94b171c600dd13fcb2e346e363ade0816072f8f6634462d8f792fc30689b74ce762052f02f2e55ea4a4163218408e54b3cd238a4c9a36f655b9f6e55a5c485292b39df5dcd1fc3ca2caa34be29547ce1dda94920381de15d8693b73a8cc210a2b4bed0100742cc224320a53454d9aaae822b992912c33748b1a96561ac70b86d1e092c88c08e52851163f9722256fb6c22c127d8a31658b83ef54949027d42b411a19a61c75a768efb3e6837fe49b54dce7d8d5e0da2173bde901c0684b69cf1815a623dca237c57b01e769d16c2418d97f831b2aa5f8eaf2c4422968368454316e85b63726b576061f0c690db51616aa1f468570f2c80cedb43ec36dc1a646c86e2a551189b3eac9e9dfb11de4a111a427b7a363cdf9cfa0b2d95d7e4d31309609a333e1ef5278d86606805bc34b541ea83b1b561174ff48715c27dffc3dd5bedb9c7aad58cf349cc05bb035b051498697c546dcff7f1cd7d2a757f46a3fe5bfbe97ce53243d1f1b87de8251b497c8f364eef658df6d822b18b3c907cbc2de566a72c9bd45570bdb35faf0b727b99245818ec2c67c45a7aa448ebc16716acebd9570a9952a57efb97cfe9d9c4e43d5cd11bb4a03b4e33d8eae261644a16d3971ffe05c8b05894a92aa8dca06f8531dd619f0956ae5f4b4ff0fddc48d1a746f11c0108d2bec908e0db8c3454bba5ad2b4711fae78c8b4e60672f61ace5275d7d55659e03e6260adfc81478b18fd9d808ec241f4f6f9c6c207c2a2de3fa87f1f38a8dc5a043bdcfe7c82c9da26ab0e5e696d08aa7794667f51c51a2f281f8b1f0a07433c62b06cb1dafb0d7bd8b1f44110f942c8be72765bb7e175c476679d233049ddd8e0a7a02bd42fba913786c529a25f18a7b0f5292f87570320e60eb1d8ef3402349a3eab6a75b743485fd5183773ddba0f5b1f4931074f1954494e7df7ea6c68b59079c86e1c03b711f9de64f57c2fe94fc6c8eea3c13d6f2a19d66db99c62599fdbbcb7eee2c313c88e12ea98c0b32a5fd8ffccd3bf2af2f8fbc6508ae9601196fb6b01c953d4aa4b4ab263bc74a373123141a6632dc5987e17d5d0719c2a05f0ca6b4d04b0b8607e6ffa26919f2a0470b9a7069cf021e3c50c0a41a410b6b66b922c621e7157b062e160d7a5180be27b2f591f04dd1be9c472f303e83555aa45048bdf1547b30ac4e91d5bdcd2edbaf6a88f5ff749c2534a0503ec996eb2563429550f5f96105d0aaa221cacff9d8fdf120c013a220a8dba317f00b26cb6924ef4a4835cfa782dafa7b2bdba2a2fe57a0a28a6182c5f1aca754727ab5434bdb22a138874a2f9f3fdc35119e97655022726660f03de975ae9f5401c623dd9d85a334a316112d1889620c9b562aa673aed287bc45a024d896014f9febb22adccce8ec77e0bb8cd796ae2917757032699df3383ef0301d25427e13181cade8d1c4704b67044cbbe136792d06a0d8a7a6a4c3bea0f0c7a6c3a83982791099c3e6f3106609689057b9e85d3039642dec04388ad8aa80f45927690cbf4505c49c11ec5909e226b6775509ca399739f477815cb104559eb30ebe8b8e8b0eb1da913eb73dbab0cf796c7ec71afe9ca72e41df389ac06f60446b6c4626ca2b3bfa0cb9167f90053316e7550cd44ab2898a189b00f67133d868192753165012b288951cb175dda29d9808e90b9f10ecb577f3d37889d910a405db4be91f4edeab988ce68ee5517d83a171b83bb0eab877035dfea58c224b977eab2e7bebfe758d485f00fbb68f368ef1d508cfc407ffa2af265128512e129f4aaa9c0d447d35db63389c4312e37d27bbf6082b6eaae98c85f1e061025bfd9f4a25c96a793faf598a5e99796ead6ce7eb3e2aedc8b81d06c68daed1082e0a5721d8409a309cb33938ec434b3da77a20e9ca939ad8bd0764c558b721fbdb89f3c87ef4662b1ffad3116e27a2b4bcb3462b335bc895196efb006b9748528dfe9429f8a936e70f1dbcd6c440d8b9f1d291c19fe7aefa068c5c5cfa1b90025fe74e14347cd436a476e3da31820c4574c899b9af86f2704678fbe7c6a1df4dbcece218bc219a87969dbf4532082d7e2f62d69c158ec7b2a3b3d83da9742da0b4836b8797410304802b97e725b4cbb0a50f047617f05b7667921c29821d39f97bb629f65aebbce364824f6d302d7164eba5925bbead309df919fc58694366a918b54afdea028471db13ac826b66ca020742d527b60cf08b600865191ee55a4ae584c4721ebdc9aa72ddb6dec7cad15524c19181edf81fcc18734af9913026ac51525eea7fac094a9f7ae9c0950330ec74432a970e0e923103a75d0b34b605077215562376968bbd283d628c14938593efd39bbb8919445289f8259a06ca5b59cabefa1c134b4da51a66d0c82c9eaa8767172119e22b95ce78f1a1233525c35049e0396ad03a7f4477384528970f9553fd63ee1d28bc4cdd27dcf56c7cf8e4b2a43b924d47703306495e77d1b9fc6f5c7396c694168aa923cf354de93e51c2a4d582739a22f65b7dfd6088a8c18e8c1f1d45651bf924268e87023556c721778482b12005a5e0e362ef9962e679842f4ac357c7b294a0e883d5a483a3d28dd02c4ba2d8b3eaccc881a7a6eb33fb059a7aa14fcbe3bba8fb3676b8b2ce2cf51e535d3de86e8673570055bf5508ed7014fe7fc0e84d25a515f42e7c645aa130fecd5cd49b3e8e85c9a3586a9c77ea074366b55d6cd3a74414f90dfbf01501f98109ce7c836ddcd37a83975defa02e8a3bac6570cab2aa4856457c23d51d698f13803287cb64bbcd57f08e0c0c8e1ee585f71404a18778fbdb11ba38fb1b7b04e075e9a955be86c539d7fe2c498343a7acecb55237acd4c65f613eeaf0d6c775a7587b4bf8d1a41dab54437005de7de37e55fc64df8692b7ee1ceb3509799a2d81c3bb6cafcb1e364f9be034b492be394097dd5e0fc363de31ed8bc5b88d5753890c06867091684437c9ed309e5d522635aac912afd63add45edb3b305d0557c08465322b02418888ce44f18f36652843461c72891f1dac98cb9c15fcf3a8b1fb56bb6f4354617f5ddba4a499b497552dc719117ab10120e1e03a180ff697de87034a5cb2155642da929ad76dd26b61f9f9679e7b4c11cbfa47407ac5ffec9d349c47489d005576eb42198cb3e6daab922ffc204f215dca2749914a4498418bc53cee8e577cdbd9ee42ff2f0d9adefb0c2fe17c2fecdaa3896bc8afaf3f38c44775576eae2b51b18a3c631a392c2c2d6961f474875758320b2c1eb6e247430ae9411749f88778ff1ca531db197913ea2b779fced3d6660016c1ebd44e5bb3fa1a78bba8c4710a7cc510052dac04019d0e183134492ca5d74b54574d17ef145abee9c6f25ba901875c449f7e60dda75d3e4e355f961fd450478709313f49dece1781b1857c061a0a137858aec579335e5cf8a1440c22ef7b83deeabc00d1d362ad92f521da33f8e69d0936b0df1608609094df02baff52fd8f08fc0e7cc3507073643d5064fa951b035dc23bbfcf60f15cc34cda0a9366c5f4f3fa02523b0dfe546c3ffcb68eb9aa514016dadc6b239435002fc7207b369b8fe42e9b1c5bcf71df0fedef51862e3fb6169acba3aee5a12308a2d85187a3992b875b4e17068804aae36d02f83c6a865ccfbd2098743e75195d28e5e49124ae233fe32184b3540fc61243e09f25c48b8d1409cfc1b8428d5ec2b6fd6d3fd69804fa02bf993a1fb2d215d8c0813f82cc537592049de80d95306cd47d7d3f0f2be6d3b0d5776df6d6d55b6fa13fe5c06cb547fc52cb7ac3146b3baa17c963ed14a5aaddc9bd4501dd1e3f85ee2588ba510a8da6780e4fd27aa581017f3dfe815c9f2fc10d1339aaa727f2e5c38a9f661215584d706d78bcafd0aae76ffdf1d0d80ecde2d3cbc0535bdbd788435634255deb6637431e35414a11c346cc2f58734f19a0ae7c8faae1db1dd1a9acad2ee7090d099219a0c738de8ecfbb8cce6f54b4086f9001ae5ec5a3cfa03bb148d6d1d3daf8533720ea5f09dea3748d2cc03e53b1eee558101ccb644cadfa637f8e51fdac4390b63b4c028c6c565f334cf8bf6732e2c4de847ac9313dd56b7b019fa0ecce2808ac13f1ebc14e004d9c4f5d0f42ec42465c0816a2cf01416dde3091ded1d08ace0b30f0bdeed97c041eca1d6c8f969e7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
