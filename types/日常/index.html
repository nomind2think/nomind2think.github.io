<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd7915a800552ad5b751173b0ecfa2166fcbb03e8d5984229e563747d5d1282868fb66fd41a48dba9f8704e3186eb3992e0e7515648f46478e828c1467fb8eb9b8fa2c2c19b612776672eebdaf9e8876259649284c91a839ec2186c515c65cdfaea984fc6df91abe3ad3b29ee1ccf7755b5fb6852fe4c59d530e1abcd2a40a5528ed68c6db080cf5a4bc60e3cf8ff7502cb2550cfa561267e366f857be18f988f0c51d6946b9ec892290d57d1a0f0e555a528b59564215b85e2fbefba1f2b9b5edeff3042e87a18b83db9f23da7a07fbf2251748a3ca9ad9a299e7a81671ab7288ab773ca293d1c1bf835e1565bcc47690ecfa9064f00ccf6dfa0898d477a3e2ed676fcc5642655cec1e106d647fc451126c048909638e96a1c3824e978b642c0797386b1ee0c2e519c62368f3d13a8a13bb8466189ecc4d8535bd33190c9278b3ae23b1999631dc0b9e7f75f76709ec496762feb9cdf249d797d4bf6e2bb53d52f0641b2f921baa1ebe91849f75c38274fa7f0d60d5075fb9da3eff205111ea2ba62e57667acd958025690f36c2c66819f20a218d347a87cb8d158d410cecec6249ab911a55d4c2c796ba4ec07220e85a9b24718d6e34509bb5457f44ebe902466f2150c68d2d73e084567f2374f1ebaaddf85b45ea1b6182daef0ba0b207de952552100a7169a87e9481f5bbde77c7264b9963edda225f6945657d9e71c5a06181847022b2087a5cedf1a7ce67464793981549a0acadb515cb703a53f3803b829af2b41db93ca4d5df2c997862c7d2357bc91b103fd672a909e9e5e557f8cc341a8c54b5fe1faf5c379b47f4f23c9d55469b922cf476ddb8bc0680fe779fabbc13cfad53ed496ea36b5b3bac989f6ac8876bff57121a184aac1a34ddb2dd6418b3aa255f484fbe2444a7756d16e2e1d76a08c2c25c21495a8d0037ff8ef5e218343cf1aeb1198686e011e96dce1da2bc3664fccb617fa3d9119323006b6036de3410884701b731bf03665d1d2c060a6b8e957283a183cc86309b0914ff4cb2e792bc8b32a79b8f9e2e1e984c31adc975f2d03bc078ddcf7e84a9f10a6c8bcb05aa7f974207c0082720013a15c3cf6eba0abaa2115968e0c235506c213eee6f570e06e2fefbc11a0c2b5f0bc528320a7248f55b3e2994f183735a2b9625405e303463601ffe0ca58e7a4fff31560d0790b787c7c6851b23b9a5eca413afba4e3958bb96c7547ccf439e06407c77a09b71efce910f06c4c1c8e00ae3c71a309476a59d256946cdf69c9218f14c59b9f1555549dde1e2ab760b09783c85b427b007546c0775ae2ef7925d63d3cac3e1bdb3cacfc627f93f6b7fb7037344fa9b47ce138f5eb9d6c50fa303dd67a56d021f6ddc38e0917ec0ae38cdba6d5bf4babf69dc79ad460bb71f888a4debeeb4cb3194ee7edf886ce5322450eb05a764685276cb31dcbef1de2b9a8bdb26164a5ea4e273c4fd521f6556ffb6fbb104a62a5b459580e38873fa4e31018124d19794d58b4a7688d4e2de78f13873e69cca9b5878b380f6b1583d739b0b0ddea66923504b62f36cbc58fa2e5a8ef0ca582a846de3dbf16f7fb2e3b935f169d3f79921ae75eaba01264268d4bc129e8eed35bcd478fd232ffbef2da234eba1b0933028e6055d1dd1bb91d6d3c5d89fd24b18f8e4cfa6248fdf44fa01b1a2aa35c86e5925a4db4e201f952ee6d9fe99947750945361f0470ce730ebe8e90417bc9c680de899bd372c792085b49525c840f9a29c8005ca0d910118100509df67edaba76f080f410d7168230f48eb98839ad80e414a5302fc13c5486f16deb1920b41006daf4d03e73a81813c070d49e7cdcffd2ada3230118205816064fe0b179a17558be4bf68639f4641cc16d6519d4ff3371668078c3f45063199808c0a6decfa90ab7fc89e6f51f2e588e55a0ffa9df2675bbde60462aaebe0e505330d993a952ef3c65425244504c4280404ed5f418524ee3b92180cbe7fcfe263b7caacaaff0a4df06959ade5a80263322eb7aa327da1f2bd05c051c0bd77fa478b713b76cf1e1fb9b993a4cf85c99bfa84cef8b4f51b879c2e38648f15cd2eb512d391160aeec164fb91c29988bf2aa84835d803b980b1f5ba3f9c8f705e8638845098386d376441264a75ad6d9296edbe3715082e56b98fed723a0e23fa4140395b0c2372f19eb1eaa52d04a868b7ef3838876236befc8a01f3bb99e1769ce7d1e9d4b13eb2de781ca96adcd545432ce02d980b840afcaecce73c67a538ff272a183c1e1e1c560a1ba866c249232ac0b11af66dd512cdcca07d192d9977c187b33494638ec17114cdedd0daf865a3ad129c207b3c1a5b87a339e8fa6eca8c51c29c78d0f48041b09d71df9f45e7505ddeb99a3c6d07e9ea10f236338883a1f1597c0b1f761a8f2ecdbc61f9e2bbbbad6c99a547506f70b977063b19d3e6b3ba706257aefe46065a0e541e0eb679aef6ec8b1d98f5a66808cf8e162980216126948ab526357c9241f770a6f4cbc6b26ee49d83ed76e813e1502b05a6143d1199e8441f969f91503d3ea679931a7c067d2ce1f021b6fc9c75f0db384755df73a8e5d0b1263349b048a533a2e9042d192ed2a050e99783658f1c204ad9737e454a94254ff4d4f32f303c55f4dba088536a0b33e8e7343204a3963955882e60c95e17a894bbd0d1a0fb04e02b596fc626748ab42253762dae8b5625aaa3c72bce1067ebbc01e2b71c39e3d4cea99f902c479e35245fd5e861bdad52d977908143230c84f72d1607545114a06e3808d54236aeb172bc06fe66e5a019b4ebe485b79160f230eb1e073493b854f9b427beac56359d488d2336d8355dfd90886fd839c847615751256315ed3d187d1af89e0de908c1592518739ec6523587d4f5cdde5dd1fac82e99a2159509679847be13dc08431a10ece3bfe2d0e097a13da49b88a83c330e29b81b54b0a570c75daf7500fc76e0cd7d48780953f88dba63cb69f215df2c3aba8a71c466da88b8debcd27ee93737828c27c3fc0918e184fc3a616091f96288c587457fef013f532cbec1ecb3043e05dbb781be80d34127a4bcd865940352fd2654285fb2891cd704fc7248f51c4337dbd1d11e683d4416f898026ad8690243a029ce503c4721fbe29327ea7dc7a47b963d90c59c7a930b75d1f3faaa032267b29214e4edea02b6c018f4ba474c638cc720cd041e9b0bd6aa3deb93347a5a6d15f4aefd3790de651c268afdcbcbf9dbc7099f0e51fb3f17dba0aef43d2ddca05861831e529acc0ac8c85e52d5c2c534b1a66e3afc1d35fb8636972feb180b56f0c725d5e6e2e9a305b587f79e2b99d86a98c7a0ef0883f7a21aa4276ea88f8a175719122a433536b2759d30ab711c66f7e2aa751566d6f8fce9f8fcc8f29a1bed659135941db72c1f776a016e283ba37132f7e9d0915a76ea79897024909bbfd4c64cacfe0cdef09e907c608c4ea58cf50fb16168e1da19bedb6e1318f2f84858ddc6d0877024cfb24353dce8a46b67607630668114e2ece75a022e98d831fbc44cd5456545e4e858cd719881db01e9299145035cab73fb0d7e008e70469f286bff952ff39d257b986ce21ecc77d9e1d54caca545a7ec1ae9d7b5ac6ad3cfacd49c82a435c8a14f2fa9a6ec752bac54d2925781b6626cdcc33a8c750726da54999a100241027c47388b9cbe96edb1aa6f6d1c9e4ff7c476b2a8f23d2fe5806eed58c9b32a77b6a04dd08679b49d81fda5245533b956a0de108d8633d1e762aa24e4006fc6c2738c81e11f015d6bf91b506e5e47b0ae3e8d93ef8be7205cfe49785e0440e16e5d4b24ef142f963416d67622e438c274eb465e1ed59de97aec0214114301574786c3fb550615aa97ed1575cad407a105b0afa355f56d44c748746db32fff06fc925f87ce0ea31f72a6d83b2ced55cad6d9299c9fd513c7da082f3c561cb6013dadd76045f04e25249e45b843ddc96c27f5f4bebbd17b6427c00e5f9ae41e24b1f72660d31b1689409870ded4da62609afdcc54510ae92231fc309b5c818d6e79b27f77157ec0da3b55c26fb0ccaa3145839ed461f6d19720a21de51b9e2e51cc5019c681d8894d709f8ef910689f27e61de01df5a7c604e4bae203a924c502cf8eb91a36251623c81cff85a97f018f586f22b142815191fb150c0afc393facf2e7cb0fc201f75a53a8b0f3f1d7b858f541f60e683d8396365edc8b92f7e798e89ab5d4008a36a4a1b4922f516b094d5b67aa9b3589e23bbeff3f71a05dad857576441738d9844356950251001e69507656557a96fb258b07c70548b0cb53502528fc490e915e5e6274fa232a3a00798c393a6ae3d84cee990193e30256f227a03d6b4e949061bc4c7e1cd871ac729c22aaf5b9d0f4f625f8e3483637c4b0ad8ade75e081113be7aa4055a26a43b043153d81dd1cab8dc4d513d0940e80a6707e2a3f362c72b51e9f8bf54e429479e5291ddb14d53f3d29ff616ae5dafc2d0c2ef006b310fe67888a07455883eb80f93729126a7773b1f95d07c8afae76765ea3b61ed745e5e60c7459802d12f555f07e6d75961fdca712ec63b971647179e280e083da9dd8ac66b4dc48341384466b33f8f1131fc0561eebe6daa02584cf96f22dbac67626a13d537448d546c2e67b04a2b55b53dc50734b2858112510554826dcd578d5659bdce23125e730294528a281bef23f255b2e2279ba2179f6d70ec447b03a963f5d84d0ad2efdcbad5d6bea21b1b187741ac914a1757d33352d9aadb781d8c9edc32aa4606abbf71cf162f12a66ce538d71816183cdffe2057c53e678c55423bec2d3f742346edf57f712c8bd999959b395484e963f7a30425ceefaf27b099097d9b2a70e97550d228560f9f01ae7746e41d13e7611920632a88b9600e1fa8dc1326c5428c3f2133224462d485c43ca2c8e83c7b624a53a208c0d3f53ad090f732dc1d72f4d10334d34403ef513443706d2844a6244762058debb6bc2fc25a69c1759bc3fbe6a61ca3faaf7a34f1f6d7dcecc97a83c5469aa43d6da7f13707cbfef2e9a99bc2784832c655f0698769f39b4dc50ebe689e726778007c71e5942a0a88df48a9b5ae32fbcf5cf78e46cc613a7a744c00115a27cdcfa9e6bc415ae4271a85c7cae7cd36b3b63836694a949e62237be89b1a063eaff5125480be138dd8e18d09b3694af9e8d9bcf0b9cc4723e7c2a8ba557959869ecf4a81b7362d22b622448f65ac9b305aeabce91cf413d4d0598bd2cb1fd21021af964137c6aa957cd9fcd389a5253c9391393217e544347f0e66431bdbf828df9a3279635ed87a0c71bd115673a767defe99f442dbd0c2e2a42584eb42f9cf17f7a7122735433a3b172e66ea3b9e1de6479a788907249a6d6baa803223391d440e4399d76bba6af37cb947a44a2cf271007bdf86d4fb8d8ae33901db3a0d7806c483a907ef4dd266d4d6f51d4e41de894f426c93b84e005d3394dc10141fd9e394da2ec5d60b2a88fb832097a9bb895853960105cd7196d95be23184329a173407e037af71c052ffd9ba9dde81f0f5f79e5889410f773d4ce6e0ef0b98d09182229bee13ecb43a7be7e986258e01f2a84b86e0c9cf579142315574c528e6adab8e3c3cf2d46b655f7b858b2444661239ac473b44a46d1a395a91a36ffae3ef96b310de8a4eb1bfebac95e2e7bb6be9780326fdbbe5fd4e6b86a7d9fa08cc5be04a5c65209cfc9de14b45b0b9de511d99bba2f49a4d138fd3de40abd01c78481c5fbfba9cef5862f811462cad9d33968531cc01baad1794cb71157595efbdfb21adaaa13867ff6511189c1324b5fde88322f902d7099174f9cc130d6758e632ba0474a72a935de38ddd153ed7513586d7efe3fba0716ecba41abe2ba3a8ef5b63b982513bf12ea01e6538c4e5b3c28b35639c9689c26fc7ce9769185520fb81f58e90ff499f102ebe9faa7b5f88b1ffe5a9717d136d66f411c675d2032488fe895ae1b6ecaea09de59d0b3530c02a47410dacdea0ea6b77f07a405a55bc3315f6e4d9d27cd462bf6b24b8bd4e6d0c02e0d307019bcd64228bdc41871912be0710b6137d889b8d4e0c44d2bbf3cefc36a5ade66148f673c2cb8ed7a6de0881ae1dec3fb07834079c098d3ba6557ad15a08c96d34e2c569c1e990478cb023a4364a2a21fbd70354807a38a004a837f297f4204215f0ef65f4d34bae09c2a65cad07975f7b12a876c808054731ab2bb1a01e7f7752e2e57e74d2491eb336be7b5bcc42d29c8c1b05e8d511ba882006c32217db09a4f9a14e6a153439e3bfa84e87760c845ca75f8d843cfda54b2addc509486b55dbdaff5307a48ba8d51392c4259db5b3358c1bdee1b6cb165552eefd91d29074589362205a1a2af3ab6e7a82ff080495df037af8e38fde061077067dcfae3be53647a6314f737a21d267e15a89ebd4ff1ef636d76ddf515d27adbf8ee858deaf5554c7847754bbab8ad0c9fc26eb629251382ddceda660fcb097e4156d566577313e0da68f5723c461b91c96f121bbab146c9b62dc6bc084c3134600c42b3685105720cf587477b07aef843ea975dfad1e3679d2d063cad7eb2b9c09615222fcf74d8970b28b2fa241f9b2e2824c0bc6a0681ba38d0ca0b898dc20b536bf2e604f57fdd01b3b9e1f9966db04246d4bd77ccb4ea68c8ea200d0290d57c56fa782f1077e4bbf75e2a4143b54b3cc7ef322ef8ea36bf2bd6b93d92e558149cb52d2f38e881fed0b34638f768b38563b7f98c746564d6fb9f8982bb608d60d7def8f40687337e24ec61d2a7c9f6b057a9c535850b3ad882d316ee8d74ad93fbf605dfc2218239ea0ba7c3ce03d4ba4a9ef0094c24c7c37dbf19956b9281a22a566330b9e0d95010133a3a209442b75d2c29386890fcd8b6cfc24b4310b8836d589d4ce1ae5f26494fde4831ad3356a0f3abcaf53bafb0dfc8944f264eab7c8e1e14dc35826a08113740e164b848df6e343be81cefd4d0ef5499136a923f7636cb26ec80fc4932a9be528958a39a9439b45bfcf404b5dd60c464a360b0f6cecee6bbee4de42435dc4dfcea58ab7bdaedd190b166bfc064fd82d02455878a53a40f9d83317134eef498945b13ba50825d1eb2448817502a5a4efdb5fc1fcff7968a047c0c52ca7054bcc93231cbcdf98a0c6c46dc2700127825afffa275f88fcd28be11aad8c4104e4fa7cb83b849d4617f30110abe42b71412ef782c3405d205752f42fe0906c86cba10714e4bba964f1c40680b1ba9a413d3a289608f9f451f48d21e5400ec18479c4bbfd1f2d2f22bb379d94dddfe707ade28626c2090af87a42238318f96b128a77ed4db0ac09b384c0fec7b2a9afaedc8a1688108216622cf25609f731908c6cca9b9c7272a42ced0f3f27f3b36d8bf0d2101f345ceb30a0f9cd18567a513e79dbd095095ae253334e0bb80f206b4103affeef210a2d97e1e2794b014fc655df0ddc1ee7e3505bdd989cc839209cd1e6ed4214454bdf9a324307782e2c9df4c7b22e43fe458278e9c7dd95f1cdd0964e8150264e21313e2a09b26a8ed38f285287774f06eabd8deca5c614d417aae220586e8f4e7e90e0bce72974dfc4d98481d87ebe8f70589b6a721a04dbdee904edb2744b88dacb10ef8b40729401b913694dd28c0775ceac6aa9ed5e7eb7b389f4e81afcf54c123bf11b830b0a825eb23c665987a9eb4ee37fe038feaa25b167752f572da0703a06d8a32f72c4523abf3fca9344e6036b33ce7bbb6d9b085b0aeeae131c8779db0b7b2465858577e92ced658d37fde3f0a9aed28c69efd2835c9fcc5f167b8b36fc176db77c6cba42f50377d4ae0299d9beac86b3c2581e00a12e831bcff3aaa77cf5432c8c813bbcc5b03a8d69b2a62e719ee3709acc3e12a0ac2e0826e7e5dd85a2bb48791d7eb036b7f237e1be97b2896e53517bcc487d3ef7a5a3293ca5c674c7619f909b4d5d008be0573d798d1feb28067870b0e08e000d096347fdd7809cca3a4ad47e8ccc85d27894199743b918c52950e112bcfef5f938cfadb02fc547db5045d6dffa461690cc5eb68198fcf682f45f44f16c58b92d87777d119e4075f281c665e66376cc6d4c091bbdc1d463b668b3a57535a8b7d64fa749047247c3a596dc57d681ef3697d2a81feaf671d8db739b4f9d8aea862342c8202fa93e4dd3d3535f2849ac323f43cc32ec50e514f585471da127d5e591366be18bc6e0a27dc9227e0bde6029d44478a89662f49860bd550cd3cf68edb9b8f6726dffbef6e0e7d248cdb1e6ea395618708491e8a8b35b8598853a1053e1cbca687b63f5f427f1634520532f37a29d1bed41d9e8b3d95fe8ca9e4016a4af38638ae919e2c4df987af915a06070b5d3ad87ef6d3c49dfe722507f417ef88035fd329fe75609c48d08bf6c8af10aad4fd567a4a4ccc51fed8b5d3c0abd852d1e01c2f17ffcc7a91c1269538de8bcb3f2fbe7bdc08fc7ce2d644ca0fcac862447363b4f393b06c5d2e6a54f45f28fa5ee8d8da369fb831f6c16929922afe5e756a875370ec2d0a08bba5b7e28b18c393c8b55cf76190ed86c32d7af15c73e61c539d20add63a5a002ea837e25d351af6bc4c774ed7478a50196fb5a538a3cc153689b0a898859d14e3be7da8137537dd7796170e300f38030841e53b499ee1ff5bc131e676cbbb78431463513c717893ab5aa29396ef072312489284da30cf3d27eabf37f7a9e4f7f38390154c016e6aa89c73187703bd2ddb3673ad4575378481877ae5ed6476c8ea06246917237233bf4712a7c38d214e17dd8e4356d4a4f2e9b1b949bea7ce76527b6776d4d9f3b03d879a52353879035abba5c81a0130bf0c90172bd2504d259d914a6a9519bb1ea869bac67146b389a4e1a3b95e0b537384d201aa494ad2835f480534f42c8df8df1f725af1dfd0a2bea599fd0753db5d6cc4827b7faf807e71825f545caf05b3645067d05eb4b14bde78b60729af96ab8fea4e814522ab232a2fe16da193b1c97296d367dde3ee1610134a08c6734d541cebf197f36c0b650ed939efd97047932352d0d4af3369d54857832f8988c2dfa7149599178a05a8ce6c110c9c8f5ec4f501224c32930e6e15dd17e897db65cdb0c7395e38ad9f4b8d97d2911158269317b227efa4fdc7565437a435bd612acf4eef2500dd858775c905691562946e01ff7fe4107a201c95a0a0da5fcc7ceace8bfe2918c3c5524d34e7ceb85ff5ee8f09b5940155755a3597beed776748af33ad7786abe32db6ed59f206bfece78f3636cda7cefdb646c3aab1921a761efcb40cece0dbb33578957b1c21a85e8f0f0e9d27905bb2eff2c88003f89921ab857009749d4efb88720aceffe8ce6f26159973ad3c8af2dd03bf1dcb87c85266f51af71f3ad0fae22f7d23b2b7d11a081f9fea82f8acb71889cdcad8e8279978924e65d0176c594ee1e944802d2dc8039e91239cffcde75f25d9cd61b1f4867070cec64a646f778d82a797b6e963011fc499ff2224687483d39a21ba42814b4b5631402f307be8e38122985017991f2136b6404740a1cba87ccbf79f6153d60bdfe12ce7c6ba168ab5e4c3c389262b81a6ead7aa8faa51408a799ab60012ef5d7e9e8d23ed596ecfbf6693877ba7ae3cd76d0e6a1afc96b29ffafaa7f985329c210c3189969385d3500be0730f7ae3b2d830ed53c2451758fcad034c820b8437d39dd9179b6936e0cd2424e673d46b0492b00e9ff9021c3aa1150249cdc66efd5c9cfc5753c005d1c45140e5044ede96e9cc4531e2ccfa99d3229b6fbfbc0495d0c00790ac6c9371919d98c8f62434ef7668c2d02965e303cc5d944982009ca8860fda52e2b6ab305fb61f2dedad9fa1fa01d0d6b25350a446e1ce7d222224575060a834cbe38e903ef16d0d0778b3e961d032d946a5c01f6790dd074ed8f5967f429e1ced7f8cc4bdd5452052463262e5d1db05d83c2fb50b4aaa13b84070aca129def98e7ac4fedfe4e4e30afa242fd2366367476c10c7e610d5eca0982e156ff8e84f849a1861b1c3d74a31de0b9eb34a4015a892be4ccee151aa6a3361f8d7d896f1e41f835704030331f05b24b1e7bb0ea4734119c86b867d629737967f73de25229bea4835dc78b6b65ce116299e93ba58bac2f0ea96476a6cdb1440cfc6d0246ffd3ea61764a6454facbe67a81b7a5fcee278c14c0d5d6aa26f52c05bae9b5641b4f748587989690dd0dd2828f51cf464ff8c22de58ecb317b8b29dc0006e18a8890add39fe17bba6d3ce4b1222dbdc2a5d2971d27b909550505a27e1b328ee06db09d790e9fd34d8c3c00faa1725aa0e4010e4a85dd0b9389cc82c3e9452a5d7fca751f457026ee713031a6e6880c2d955caad0c9529961656f915b0b64e757435561b2171a390f0c5103153c243fddf735e50e7390039da28a1f2a5a8a1bc36e46278bf902080e80aa51d8518d6a567cb07ebe9b8af45ac24b4ce80a04550a95436a50ff7ff9368c83db11415ddcba5d75e91202cdfa19401db2dd261a3f4ec3c9f8ba95bd7c3eb09fd7a3e348f5d937fb3acdac96a8626c491f858a0eb7a889718beaf04dd6af94d94a8a5ff71ee6917967d45d27362252869ebf69f2708bf03ce8ec7db3a8c4d772e7c5a68ee38b81d14071c437c951750d65c710f8752f4ecbdf9bd00064209aff3b0b93c1342d62e53501926165592a555c577f9bf2e7b74541624f95615","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
