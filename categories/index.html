<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d568e978e4fafcc886749366bdf373ad0c0f87d79484bb0593a9feaee21741566b9d00a9b95a152fc176951cbf896a2936a505e6c04a405c6d69050cd16630bda4b351dcfb66ab058ef5e328466b0c69337c4f6f575d5688ae5e10f36a1c0e12df0ade771f8d2ea6f9144343b34122dc6886d374ff7240c4c188728736ae3b61f653bbe39a10a5ccbe6f191a474c03986830b098b62f632a04e7f13d46517607b6ab85c3fb7b4b29b0e4e71640fef9619a0c63594863fc9517561a0dde02ba756e248b1418480ec92fa1152c074a941d4152dde492e6ea62d147e888d80bbde384b62672898028e99721beb6aeaba106cce63a2f8ef94ce0347e66d8de12b72953298e0f191b83d3d993a4777a474c8f3dfdb5fe1f7c6df4fa345d9f12456cecddaa306646d11a40b1959d67854e5c5e6cc2cc274645eff35b6130151ce793be01ee5b4acb98b127b244d040b0c0da8e4c26a43bf95a9644bd6e38995769bc3b1135ba9f2da81a90ecb2f6484f482e77cb0d310a0f042217d1a7a084b61e3f0ebe78e3260a9e33fa9871ec21b0e1d3eed5dcc1f332a27f0f31d7bf571aa48725f59697cd554c44eadfd280bceda174f6d9eb01b7e69517dcda0137fcc7c7799e338a25a22a15502db4e7eabf68cdd297ee5c0ea2e0e6a6ee96867b77478d40c2b697ab12f8f6e3d744d3f1dc2ca135a552624f1f4e5982d4ffa3adfa9f9c71be712725e3446ea18236cc192f3a199920448e3953f0d37752f0ac7489d55dc85f13f40f0a099e8fd139286f540c9bd34bab75a8a9a522bd461bb7f6df883882a6d52728f7d345b987a244b2154dba4bac60958795c287821483f147d5e974840c22bf9a512c593fc8be5812e1fad3c511352918ab8ee5bd5ad7aea343251f9b2ee804cd1f73515f955088918b108dcd45cc94294ed39451988ee345411764e8bc28a1e292ebed5c7756d67f7599fdb1faac9d8f204374fd9f419d13a61f44d5cbbfbb6f6887916792fd24e84e1db0c9b482f8b0e37ab4bf1c9c4b8e33910eaa5a5aca7fa26b66d79b24db59d4eaa05bc6ab2e7adea0a469788c1281c9a549ec5c3a1afc7ffe067d3df6d1f0a3376594031938d2e2c421403519ccb66d92ac1bbd5dea7e68501fa46c1a0062bee503f6cc7bb616b9464e89cf37836d338cd9be5345cfec91b776679fa735fdc09c0ee0e7964dd5cadbcd453c88e250c9dfcc9dc88c762fabf12360f6f15a300eb76f28379734332a18a6b108e215d3ff7754347169b0baf32236bdde5d26cd31541ff86aa545f8d793641327628df74a304206c855a2a569183883302159e6417ca86e92e9a126b749e74584430c1a8756918af7c851ca50a0fe0a5385b42661737333f6d09e4f5a2b17cc62086930de843187ef2248f0c2810544d6e9e8c9dcd1b510575558dc16125047873184f01418c1cf4f67c1977f15af8fc9df06c99054c97e7f65eeb66a3f041a6dfce0bb622f0323a365efa5b6eda014324ab4107204b4c5d53235a20db0dd951b5f6ec812ad7d5f5e6eb66c1c358aacbab3db1aab06003419a6d5ed440ffada4bc5803ad10832cd3d713ca0023badfaca5a13320624c1f389ec97a69febc690e415c72ae0f9574fb2679d916a222f15e1c991ad463474cf6b4f993d06bcd833d6006b075c6cbaddead825d08f5e503ecf2312a10a2be7d7d591cfba99097d8d989f6a6ecf3deef3909c80328a52fe898119c7076ac9f92797263aee2e5a888f2a176354e799fd8a25b2af6d6630794b577d762cbe9c38dbfaa1389f093b0f6afd7eb62483a88a566a4ab4bce71597e6290299abb1d9efa2d4a2d3a8479314a168e8eeb77ae14bbca5740e28e80084b1a6bbde4a2cc5c00e842eb4c79b15ac5f4a300cbe7ad61566adf3a6f31405b3f24b6ab997f8bf38fb58490fffea23e01b6b85578dc354534c421de0fc04793b3fbe4a4fe7454b53a3f4544f8e81d15d99f074b82c1615214b3bbedc228a84f82f5afda3a314a5b3338e18fe6ab2ade5cde81efe1aa81c8b3f9192887f2325e340e0af56d6d0b9949f602ec78f811be4fab8f3a0cafc82f91ba8eb942ac2cc2306c1595c8b27c429c87d9a5e5a4a42de5cdfd0c21d19864a295d4ff5caa265d9f52416405095cef2814b1fcd49de6d75faeac919b8db38a69b7c0a8d816cd619a810b54606c0d8687ded89831126ea686da5c09e899ffc377cba3df7ff1fcfac12fa2ec8c5666f2d2fd954b9249cc44a0dfd57d28a1f43af93301fdda41e38eff2263f12efd2d7f81d5deb1da37f0d757fdbbffc90d84504e5c0df4bec2864eee97f5930b1bdc98b45dd32fc6461f0a4ac7c1829a79843abb161523226152c18609f501d371d2aa10eefa2712c4ee2707044fe68ec8ba87f97d2d12a1fbe2903c2915eca721e5a105e1040303ee08c5d6835677e0f6e68e706017fd03c0820fe1c18228236cde7ba3f7cbf89fb20dee278f19a96abfe2a7d8d46e8c891699c2d714617181258b90dc791fd0898a5cbe94be0b59e9baf0236485ff46957d59d098edbe042754a99f266462934ce9b37ed0a8857332d87ae27c304a090fabebebb2b75e54b7e8cb6a44d01fe56193943add7923d8821de3817613bced0551ea37fb611cc1c9ae0878cbd5e0fa03afc7950e6c6958043146ffe3896f4404ecd21e9db017d0d4466b6eaa9aed8d6769f48d9cd8ff11086c750e9cf0570630f9306eab2eaf0fda7187e8e9595bfd9a754e12e1deaea443b7ea0efc30758f5f62fb909afdf5bb17f984ca4ee89a0381df070fc5f88a90205ad2773edb7b20de72fda12c9e4008c20624422343f64ecb1a2ccbd13d71e6b9bc42b04b9d970c460c5221fde8a2bac07e6258f796a279bbadeb80463a4875c166d27fe2db2e3fd56644ee2480bcb09e5f2c898aa06434d4202922df58c1f77e622c3e09048767d836f4f8660276f83403421cd5b696c7ca4a981b8fe1456a011e0df0240f8e8b4cb397d0dbeca81b6eab7ed75e8a2276cc620836dd8c4cdda0bc9fa3c2d1a99ed3d4c924ba66af2c84bc9336924f4d54200cd29a3cfbc65c75f49f976e81f7ec241211d3f415eb57a3f6a55f89f5109b48354f090aae6020eca0a8ae853fa9853b0afb75c9c9aa077ad76d98d21d288020be11e1448a26da9a9ae94c23295a7a816881d89fff8f17da47ce36e4107388f0c02ba79ce93d56ccdd5b9abf54b3296c1c5ca26b1c611953210c738fc0b632d82dbb6bc5626a4049f4a64a2b7d58ffa428ea408494afa550bcd35523842bf0323a7714123d9243c7d8ed88f5c933980695488f0166dff97fcda3f9af3b883a2aab61e4709ca3948a7caf372c01d6f45c464d7f492f9cb7c295a9a6db63be94abb8367c9afb059ab737454314c1c32956194e5e081c3d30286a5a2d5ced816252654c7cc6da51163da8bc88a38ca36c60f53394f172560af6b92ac1893b67c83c5633dde521abf07a2c2c94c547348d00e57cda79398cf3d3d5400a49fc4fef0fb7e8b387afb3b50dccd192da8edc3f5a27c24a971563a13fd843431aae20605741d94d0d103dffbbca1d8eadf0ece209dce53203f7bde9949473f4f05e80c0d06fa572f96353e68b8fae542cc984a3fadf26522ae7f172cb489f3ba01029958b395191d087e440db945dc11bb4949629a4d1764fb1d09f77ee3a429941a4ca49256870ae61bf136d7655f2d587d1a2936727ea7c6afeb5041976381274734970f384940d879af722adbdb50d09c9f08bbd9f93fbc33b1dd4a65690f2b46d813b094966952fdeae8900f387475de44c456f81837fa0365dc9e039a2408729b75bfb2dea7afbab3f89725803137b2b299af81665e1e6ccf70fbb6ec0db88f1a676e79dcc209900120fcc226ffceadcc3d311c97510f893fbabeccfbcf917c13e04a60c34660c0d4415260eb05605d8f23846c2e4a94cb848d1f206aab434a5c99224a09374d6806cfb1d3b9ac671128843bc422bb05736f3bac813f222f81575a59890ab904af43127f0f5dff9ced2230d30d803d915c7c2817ffd1907e396101e32624a77e6ce2a844c704955f678df9aef7caef6f99096cde3a49e1eaa0c51af51d95dc21dde50accd904c5304e4f02ec1081dfd626185c9c2fd895d7247f588aca670ff8169c01962cf7d56e0bbba1212deffdd8f6c5cf75917d696626a93ddbd62c78f794152f7798bf53e7065023048c8e4501447b4a32ce87c70bd5668f2a60f1fb14448764fa096380bef6e72d021777448056bbd337efa50c5270141d29708355a8704950b23cc89ca92e9a6b5db06aecd1a4439f8014e5cbbaef65b9c9d24e5410746726887125d420b246394ec5e73c6afae51ccdbcf2b9c775e5cad28012536b40db3b3695ce53e08d7b769ab1bfec945fb326143749f6c831d6207badb6e3e6eb021f8bc4938067c7fa2ad32ae0dec92690c5d18fb835a211eb688bc4f49ed31cb550b78529344c738306f27d77dd9bd653dfb6a50cdef9e1fd5568a240127678dacbf823e94201cb17f49f4781eaa0200e30a917a0e6b023b0a45eb2f0b0c7db5f2dff99d2b9210f20811c00174aaaea6cf90e60ad52321dcc979f952a439c675472d8c405e53c0dceea4d7b1de24394001f96cfb2c81598368b1503dc6a6290b61fd45f50dfa012b1461b4946ee937c9f0830474e3f7cea96718c406c3dcdeb7dd66dc1f414216d016c78c287c39abf2788e27653b02f40e8d277d44fc34c3f2a72c8f52879c50f8392e70e6fb8ea38946da1659c9c37cdc5d0599765646f679b382b7348b7b6128cf36c3f70c168555aea21a572fd3972fd812b993730c2e196aa4c40b6f79e1ec7fa7f0a55661e136d1359e51786ff3968afa7eac3b00be5e988fcf09d6fbea6d687c194a10e881870e41487de84f8a80760abe4b53ca6a0780d8e64e43eb3c16674a4bc65b378dff27b4344379c9d87dbf5c65793495d51396209f6af7bd7aaba7f483c6ebf16f39f52842bfb96c6562a3c0f02ed1968b4c151eef5e84c5256e54808e4f6b9aec5d783e6f70f68af620ff9d9a379c9fe825af4bbb96d668326e7ca30c313c4b913231c6fb1db2e9c4e79c5f87d26d4381c2b9033af3143d09ad8348b02d432ecef332bbd52da448d4191513d2fdfcf1f49d046fc881c104f1e349e4044d02208b92e28ceb47427bcb02c2b91d6542901762bf2ec8375fa49623e05b90445981b05ba2189bfc4e6d035eb67de84931b79a7f933bc6939c3689572c200c18705f6db9602b0ea0e185a96a015b3e64e1128d0f1eba0e9894f43e32d2544ba26be2d41e6855ec30bdd24054ecf0cb5c4136721f19e2f6b3fb10ba4dbc821d66bb2e2a06c04693f65855a9de298dc067bf72dfb699997ccc4b2bb79a92ba702fec1461ad4d35bf1ec2ef9fe906b406b76560a9ffca8fc9d1b846da520a5d7525649d7a8e82cbcccb9f0689a8491146979c73463fcb001aa9a53306a4b6cafa5181879136505eb18d586283cbf2264b4457b119e8bb47bdb7a3e10cedb092780044933fdcf4ea6a3a1ce81bd667a4808c0fdc1a11ca9487aa5bd60afe756e4813f7483b6d19e5737de048cc61ffd52b6f07481114e83765d2686a2a282f9fdc910a402b92aac191c52ea0d4f043f5714d310cc49f51b7ba9dcdc3ba129bab6b464b9f4973805a13fe747e9a1b1bbfbcdbcbed484201377bc493c010cdfda0f6af74845b88c17817f629372eee2f4c54101a31cc2033f8c0599fdd267bc378fd0d207c1598eba323f67faec861c4287e85b8aa88a81069a79f095e99420fefbe243d77dc5059bea80b6798c87ee8ab04a3aadda38d84e72fe0bd913481e79e20327ebd0583120483fed2fa82b61c85c9b2550fa778ed12a4beb29c9d33d233a6579e85bb9ece3a4ab7be51d4995bb55a64ac8c18ad07463c6c5f81e1b00bbfab7aaa63e965d57e405e017beedfd36e74b56d37093674f6ca0c04cdac663a36b65427531980b46910cb839a4e01197e2ed75ddc179e8490be2bb79da63a1b626e081967d10c04c50d55de67545c31e4aea323ec500bab21cf0089b7239b999f07d95fd04bfa26c706113ab2950d4a5bf7351f583b7f26af0c8d3270fd56c3b9ba60338907a5ba811e8bfaaf0bac4ec39735cba9d70e387eb69f1846e353a75f6bc0ff09f39816908537ccbe11a8bba88b45f95fcf1fe73c1b2fd8ba85372b8c0aa93790d7eec1bd7087c26a5f229debf5adde928548c69fd5acc97a11fe4ec8bcb503bb756495f77e445c7f363351467cc11dd92b3ec7888d60e5ea1138a7f6d3900ea781380cffde53ce7316ed9eafe2924381eeb4fcb919879213b11415a6c4084981fbed1ac0a87f7c46a315b54b07caa042d9660cdf0c142c90842928c2921b05ddd4dffbf53fe288314fc48a18ef058475d2394f8b4a7a3b0d0149c45306561494f8d3c75c32a852b5917390e0f3e62c3d4ae4a8bf10070c201777a68af523b304d3689b878c0390eb78c9559542e1a8c962b714730d57ef73e1de01c2f49ad157849a80eb5f5a3671adf92784c157588136338549188705fee55b0edd2027a410c0a2b654c6190a97eecf9e0cffa87ee02b1fb47112772d3e4505595c9c00df09d190923f6ef8e9106d011180347a677bd91b281084658f756cae62eef66a2498a70e42f3ae8c66285ff13c35723dff5fb6bfacaeaaaeed4212c1438c935823b85f8aeae0fad4e15e26ea35b0cd5786ff0a40e981aeb53be022cdff606ba00a9e486e74cd8bd94c08e8cef9baca6b9168821947e70d4312c4fac3c15c2c66ac1f8ce45d8f5600c09f9afd6b34476d988aca5a4e6183f54c4e19ac9b5a07cd6030332f904e581bf323220e4d57837d570d5524b6a468bf4ff2189f62dd5a5951a18b6bca5fe4d475367d89ec3d41c526b9a84c8ea5b78d5802f754a42e164b208fd064f2a6784d99b805852b447cb2a1a8bd3b639e3f0829ca844d53fa16027a20a5e69ad45e31a61e70531b92dbe4adcc56624006a5fad9442b30cde697f07e3706dcf74d02d69525eb5e0aed7e6609e4f7ccb97ba1ae0803d6086b50863d25a26627a5c85e76c8dda9bfb53674e51b5aac452b021c93b0ffcbb620f3e86e50f19ed526d53909695a202ed4da0c3f91c68a17909a65ae3bee0c009c16eacbb267044b01c2ca7933ccf38ae11843849e3389ac6bdb9d07d0137d00d4a4f54a245b0e9d886be6278ce1f9805c7c3f53a485959671e3fc53fd090518e2e81f3969a2f3a9fbfaae946722a614edabdf117396bb42db827ce0485c9b538c489fabd3329d51473a821010993e6a60818ad629c5e3c4ed19491792afd334047544ea0da27c3823ce0189f8c80d41e2d0a0087217f2adf6f5b9d915468aa7e4cf5e25152cf2e6880ad28128bdbc0ec3cc09db2f544183722a9b9fef15abb74281d04d8dda0494c799d58a8af18b639f9987e940b8bd1d9ba0447861adf5b96bf1f371c2978a841ef9876a9bad882d9a66a58fe7c82acf03b03c03c0ce24a9c45b7111ec06357b04b8c169ad201063e9b5e100ba121e575236a90eb607f1295dd45ffc75024c245f68b9a4ba1a139f432f42a3ef5c21855bee2d00c9d4ba57376dfc8b30109377bda61b5464ed8e06738791c7abf0fbde146dc828bd5cd589f8a7988482d29c6347724c834de2f5ee2f1009e3b8e3be6824cee759972c96812e592369d09831297d3522bcc63b2c800c678c6adb84a05b89709cd84e3592de0c851f040bd5013bd161e807e6bd7d43e8de037fe52155d1d59f46228956b6636ce354eb0d7b62c13f38a21db6a18b0efd431add1a0866ea4e4ee9cdd5e09ee1e5f694e7c2688f2b8fd6a7cda2c1b36aa7da6f5916c4a5e3e749e6d8c1365ac0b7b1359873bbef43bf6b1f1035ff915e92aae679ef4df8d43d35ecec7711b5e01eace144a28ee9fe6aec28f292e9b86b5fc1af1d5fc395e852a057698b3d69b20f16d5f3a22c1c8792c88ca82c6c2c3b5d49b67875746c61085e93cd8e52cecfa085717dddf62235e80211423939d29ceb6d949902733870155eb3ae42d531bbd08bf294cb710a48cb98507b4143bf8092475a4cd2f69dd8f8216d26dcb2191ba9060952bd4ad69bbc029dcc7e43f4a41a4eb8c7a499ea530ee1dae46240fa4b05af84f3a65c6a54725ec58dfc2a3e207d7a6d59e04b9c3fcc719052d65da950f0dca1cda7228c26e2c839f522f8a26cef0f7283744385218a548f8a721559c2b9f5c7a5b8292d19a6baf7995e7cb14b4df94ba741d38fb7e3fe25ce4bd68d9a9826bf245227dee891ff9761172c1c1a8f8d925956b343ebca5ec08208ab53f9f1a076bf76675d3829d9a835ec5fe868c36d0c7febd86cbcf41a86b912956533c0cb8a133f8a908a53a38ac3c6c9446ca8a8ecaee543f422392fcf248d46b6708bc64be178b1802ff00d0502e3c8a0fcdbf63121f9c4d379307c15cd5a5d2fb5508354b11b0355ca37600e0675383cf3d78dec7fe9c3c0cd7eeaee05c2060631e26e24e7da00713fb460e69f94e3e40e64e7128aaaa332fc1032526ea4fac42db11fc223602076e79fcb73e165321e7682085caff88aad1b2d80426111e7517afc6d5a0f0e57da694d12ccdacfd4cd264f3a9124e33df815f47782ce8cbbb6ce27beb4ee8a0dd568a472978e573a955bf17d9e9fbea15d6f86506748868e32a0964bdc986b122f410fcb5b8ea103474eb3aff226d101dde1dae367ae242e7cc0550d8a1f524a5352aa8ce2db2bad83f04d657681309e319570398b925c32ad4b7bce75d913e94ae5ff5853a234c40be3b18abfad4fad6f72d8a4394d0336bd43cfb2dca66800048c710f4b7823609a08e4f2eeaf772f2e8bd4b76669c834c072e87a4207c260b482faf5cf1a4e14eb566dcb96582d7dc9d52540900bfd8352943bc3826c8f678873ffe8ef662937ecb5ffa8414587dd00ae11522e37d0737c0b4773f1e5b5d366daf6887da875de499e1a32bbab7aca99688dd44e707b715754f5855c3f0178d0b80dd7eaa85b1e1cebc01636d48ee3daaf17529f15c98d11101ae76a431abe56dd5305ddd9c649f613e0d155d50d5e0594cef5e75395ff40e78f30e3d958cd7109f90aef53f18662844920ff0822aa4deb815757db278cf73b4aae292e17a3f751afb20455004c487de9b0009d43c8fad57cb8f980bec9fc72ebc95fe17e0e29849f604737ab527847e4c6e76040033062c6e16ac839d638812f1e8bffb5f959825b72eeb566dd2795ba5fe0f027e7b4e54446f1f2a22ced0d6bdd2e0e29483364f308d577756ef5347a56ddadcde41ef520f3fe4dd6a198a086c7f4f76ed018a008585798616e4cb6128a1384a814874403c170fe2d23d50","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
