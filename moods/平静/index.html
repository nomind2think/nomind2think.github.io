<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35c3323c9ccedaf8654dea74001b886326cb7bb9a4e88ff2bd9ac80f0d1726f0ed2daa2f60f2b7394c16906bc26815f2c88e840541969b0e3557472f64f815ffdc8df5f66da8cafc1dd840d9220f94f02637cde941efc4d83290ce4dc5f1c2d74872178b32a25704e2686a2715b89d792a87755d47f0eb980b9922b4c71e2f512d31644578b08440a3639bacb02f06ed1429f795c9ce5b7dff520298ddcbf201029f46b6fad9c575ba4092dfc0fa3f31dcfc8072c5c9a8bbade1a5e0bc905b362c4018ec1a6714695dc64e5c23819e53e0a9d43bf3cf702ce79aa2621cf7d0fb11edcdc1ae8b706f498b3b1a2c7ccb481626179647c37fe66e145a9da72a02d1e8cad0a743ec8240b9a82d154f32116f866fecf5121f647599eaef7feeb01bdda58a65d79af318480ddf677aa725649535f5684fad03be5f9e6ab0298497633023c3b50014cfe09ffa7c0543fa05acd2ab5467021428eb3dd73ca6d107cb9ad275aa5ee611aebba985c7c431b61cc865a30eb09778580778302f939816492c2b602f6af790b91aa0d02cd90ea6017fb94e489e8bed549389c13cf12615e1c4f2450dca45c4e3fd7023c360fa8157140597c756e6f06b44c5498897d382470bb11508cb40d56ab9a45ef556115f3eb80a35a55be49dae692ab5da0d1392177bfb45a71a7ca536b36822a6f2209a5796d51cdf1bcdbf9f324beecbfb7512665d65634645e80fafe89865ff03770d818efd61ae2dc83e7312308a6da373cc7b674ba4703372797d30570fcd22b1bc12e85cd5b53a0d08e6af9d0809c2104458f84b947342f5aecb874d4abec5b76f8c29a7eac49875272117f6513ae5951d6daf9c4318ca69ef9a52a9fb453f1a3487e5eec72ee4d72ae79e97f2d37c731ceb65753b84add19a41555981d79d164b108ad5117b30e5a8d401cc5e632a025a9dda0f8cee8c31702248e5fb89b1d0e298f688b532c439398581c644031b311f8816e2440c6d61afea0fd30ba0718c722515d9abb50b4043cd38295b741d89341aba7c44161af6f5ffe0bc6b12d021077107bfc7c5d6725d26c6cae32163a9e38b1671ff8ee51f19a4d5643b7677096f45c40efe7136d95436a9fccecfaea412884c721cc0281d1619c86096481ed2bb2004e63e35fc14ecdcf613fd8d19135f3b0fa98da4a42cba6c38bbadbaef0a79743d1bb647a3fa0bdc78ac0c3753b8c1306c1ecbe841afed08da6e5ea02b2ed379912c1481dfe77a8c9b770dee2a33bf5ec4a961780460340fd9ec84fe714e54f03b2b7caa475f69323d482ab69d2efca18ecddb28f322250a1900ed0031867449afd37e560b1f65ce2e397301a3b1ef1210d4459a491a34b08fddf42c36a9cda081b66dd07fc803780cecf21409a971588698f987213a0c8fcd96d84931430a90cbe3413f7118ad6ea5380a2daa26ad05c7f8cd9624f6a0c249c7aebd1471a902d91683fe616113aeb0aaabe03d65f47689a0c8ddd8973e50ff651f6b8a0370f11aecbffb13393a7cb1bad498a4dc8e666944521e8450b42b3d21dd9607114de63855642fa2e0359aaefe12c4c6db5559786f8a10ca325f8ad7edaccb3b5925e674570b71c51cf92dea79a1d31f0bbbcb3137cccc292c903abb5a250075074fe4324d329e23ca5ce250110eae37797bff05e6a04c421c548841c0f4515c8ef7efbd80e02df9d6f9d6453ad47262ae4793fec723cbaef80a8d8cf38b56caa98a031291c5e618ef05f203ac46c2c447e9502dd87958a18b92b407f5452db1282d428c2db0dc31314dcaf62629f59f00b85f49adcf8348f61baa3a3a54dde6afac66e55a39161d84184d4dba86aa6342a452b91764385c80d91eda2b2a4ee9dfc15fd2ce8eb51199401450577bf222c88c2c1ee988e9c66889995e3a1f92354d168d912299810d4a6278dfef612677b113c40ce52c81e8b3468bc52dfb00b4ac9ccdf0014ecc35ba49a7af9190817068176d8b4bb00d85bf9bd65b9fbe7b4541a8a71d7f1b66a518940f833abd36c0fb6a03bb4a4ae58b3e1a8fdce8e2a80fbc17b317f3947ba02e813edd8f494c5de3c152d5f6a5dad24b263b48ac1cee5e56bf6bfc4f315486e7b52390e051e3b199e47bc2be09121de3fde2bf9e0a1e3535d46f6a7c2a0355e5a3d9691411e858740e63e163c044f79f1d4fac5e0d4098b25c64bdcebd4ef2589b353071facf23c1965f8bebfa8cca9c7b5a80a661c68ca673ae332759c8134233d234c0594a7e3e47540d8ec64956111a3ab4c7eb9c6de66b8912a7fde33323fabef75b0a40f1bb0dbcc3cb0955e49075bce18c5d15ee686b73670582d1e55d66c17c215fbbe0234625aad8cfb11a7bb792268ce02ebf5defb0ccc4e29ae6ee745df6a78cf7e826780f36e57835483a4c4477197b02904698f7cc1e2cd6c00facd8c25b847915b1480d26ac3fcd4e8b2a9354a6a47fd49621f05f250828e667d5cec136b9e7dae1916f3ee721b520141f2ba2ffcd223999d9db503566dc72a68489ab0d02dff22095de1dcea813e628be3a445a6748f8ca46256d558bfcaafb02f090cea7d3670d00a339d7c0203e8f1e1bd5b7525c47e0240652623a8db4ec57352fa3167dcd31580c5b222b78e4c87e8c9b9b31ca4d464396ccea84d0dcb45b8f82cb8ca865fc6b0cb182467c8086ba98839031f8628fe5b0ffceed3c59c36cb870825a2446f17859bf21a09a8c350807f598a79b2430a59eb93f00fec052ec6fdd5a569828b0b2586d76ba62686bdec736737149a1ec1532f7af1b8a62cb3c3257abdf6b463c6799fb9e84e34555e74231e45b41c4548e1be7ee941b6298866f3ec38761bd4fec2fe2c82af031df7c0de7dff68b15c2f7ff4aecb76f6f3590847104822b53025d34b8a6fb774e07efd508bb56914aa15c93e9aeea75fd48d56dc10147ea5cc9b2d3ae460558ec169bed047d48d15571fb6bc300e2def84a97f3984c63aea3859820d03dc09009ac3fd85cf44cf55eb5cbfeecbd7355241e486fc284219d1c50832c035d7bb549c00486c54593315f1152c2605e2c2a563114f0195547d764dfd4f837355e5339554c77e22add2f7b24f59f51a286ad4f8123050b4b69ab6a96a3323f6588cd5a1bf10d04b9945bbb7bc426c62a7357fc5903f9410e6433d726547fd9d1b58d75e6e40094e01b938a748ce241f12c6b304bedab838bfc90d4c958463868c40890723a42c8803a8029ba85ef079e4ef37049e010d29b1e7ba1406be59356ae00bb91c4d11b2dbb71063aa5c72522f6db89a6ac101fbc7a095c1b7584a3f366d75dc5a4e56e36d6262f1ca8f8c8ccd4d3ec75b2c5f2ad80b5c2e7132cb245ee0b4fb73d0c76b01c9cd3806a9185c0560a91fc8defaa2eb754f8ba362b0f46b1dbf74e00f13dbd70dd4e6f94b5024cc8795f7c4ca0f6d1b656bffd29fe9d103ffffd36e9f0ed622b9e852393271db538849a1ce4f8bde73843ce55d035e23ce572cf28844a2e431bf2b4b1a3c6e130fee5ff15c1ac53418936ecd681837b774693d326a92fc08aeb9e3992bfb667a39bc4e9ee7f25fd0e9349c2a00728386f4b879b017314d2874c95318ed7d33bd3d59c35da636a3a8f2b2096744699fddc85b81d3ca9080b074bb0e9b1f407fee0d27b47e69c40e871cc5cc3034a3e44c174be4c39c9d6d003cfa288c6649f5b5558c425ced89af76d0dd95c844510f992319f48f96ed24cfc606b72e04ce6a638e3977db535c5cfeca3c91761399d641811a0a7e3f961be756e4373990cd01edaaa17a7de782078cb16f9fede1f77f9a2e48c59b9f512a58b293544ca82856b4f4db9c1c6b0cb2e187da633f940be73904d5d6cbbf84d57279baa05a8064c55a10c00476f8173a4fd330f7b91cf62e209df9fe5cce17c05676631a376bb55ca69dbfe50c95f07a200b5ce5c5837c0a22a021f0b7eea075c5e7e0a9dc322672e95c9e3e2c5e5cf7216768b60f5b4266d36b3d755668970b656e8bf9d16ec9f7e9c573dfed2329f14eb038ce4e84338b18ae7bcf7742643164b074c50d9704437a387a1fcab02762caa26799cde0c806458559f56059829676491769145cf1d55bb09260a83f9b5a2b65f3bf1bce4dc2d2a288a7eaa5c7dd218f272eb3c4fef3a206d483785f2ef86561df6538741e63e46b9aeb6a9344df0e019f396a0b470cce7cecb3a70939569c6c760b4d54fdcf048663db9e29874c413cb95f0a23bac9ba194007cda5a71d8f0e427cd6dfb6f70cb717db983f0d5f0f7f5020f7ffd268ea4082ab831e6008d76954df538a3c46fa3b8e86272e45bcb8cd8a468795f76af6d58ce540c1b8e3be7811787baaccebd4659f21266880cdb53da128a8d3168abc89ed6e231a3ccecf0e155dcf4a6103016e2c0eba698800b6c1412900bdcf6c0c0f3ecffd81bc94f701668e44af7c72263ece53a1a46a81cc514e90558fd8986aa9a317664c4e8936ae11e5377055c82ab7562086d7dc31f63a4c0415681c9632d589daf859bbb2c4632c1ca420fb200436a4afa7c7543e743f3fa29cfefbd2ff11145f7d54e98d9fb7b601321cf53d2312073fd17cf3a48b877a541a5746c75db793fca15486d5e713acaeac59ebaa1fc652b16e1bba03ca8dce87314bb2d47863f8e58c923beb2110036f45140a1b30be936ceacc20d4942f3caa9cf32497e8418a66ba0bcd72b46a7ded48bb29efd5baf67450c1d66342b6b3e0ee042fbf1325ffb155f78f8cdd95c693abdcdf693438a02b5dd1b68d349fec156124840cc3370a2d63ffa6a69998bb6208f4535e479063e5f2e8f952acb0ae2fc93268ac3de5ece41211c2a8d313e71b58732c16f77560f12fad25af2a33ce57bb4a9ce65740c26ee90e391507f654a11fef93e66a1f691b7f4aa64590078e98dac7334bff6e79c60c091cbe5a02cb98af7d8d76310dbd01f33313e7a4ad44143b6d1b5311831ea31295788475b6557a9b74e2984de976eab4261133bffd748057639a7e77dc19c61e37e083e7097225587768fc8dceb9204a6d6060a532da6189c715c2901674eca009368d4cb3ed4bc36d6b60c50529e763814171eb110ef66997bf819ae152798bb39cde03db865594c4faf8da6dcdb218815ba73a67abe8f238692523672cebc2c04a136ddace1d01dbecb0c6e192078b0f29f6e9faaa813ada3aa50817999d36e77bbf01760eae49a7f0d82fedf835037ee2e42fae7b479412d8ebbc2c59da63a4c1a8c7454945c79a932ad46c6889b71210f86d2c24190c9602255a784c59d9e7dfe0d8d31b869085b7564c623bb906e29c4914fa8daed6d701de274f2fa752d626877a6110a8a05aafa196622a699fd84e3ac50d0c8dc66e062e227f89ebe2fac440a9b0953a79eebc9798f179d04974946b377d8cba39d862ff3972845c2f7fb69c239789a6ba5861190c190abc0b9806e6985853911e21a7202c103f7cc5de955fbfccca545ea39221a816181621da4e5766c84705d4d47fef33e265b2d6956f7a58f65f891a4a2216e7cb48fab12bb4a7aa80984f7ea96a1eda6a090a4e528e2d07bc99065651fe5856851c9d4671c69ff8108af6485be22067c925650a109e9799f35acb9b21b32a7eb9fa717aebd4bffa666fffd8272a0116777db874f5db102b35321ee0561b478e291b6096244b80959369d13ef197fe20dd79bc10882d52da2fe7824bfa731476f0ab50752eacb8bde60c702632963dce298ea498e8df8f7332c21a7b77fb9c95195ceb39dc6f03110f26b2531d9abed687c51a8cc06a38c0461327b54603e9fbdb0d6008e6682b5266e883b59aad7eab07fec03c227a08da95fc3b27576556a07ab361b2d34c16f773463faac35bbc1da1e049cff89cf280230b0ceb240a7c7c5dc257bbbe1d75008a8a871022a5b9f37f37d06eb5b4e6d2d550bed6a909a96115db7887c8d925dcd795f281b2b5557e77b72e26861b143609be6d96a24196f0ea52a93c4cc9f1e9a7c5a171709052958649467f07a84527fa24a2640ab0b604c5e2ddc561b0537d78bd8ae7faab259262450b51796fd48226a12fd7ae35ffe7cc4c21b9757549c7516ceee015dbc60ac937b6d471739d5c185f1565e2b7f9ee5612fb313f754446678638e33fbd6ca22fbc38e68d87b7a2e7e8e7ab0a9b776c45e23460a6b3934d29eca6309ca01b51615eb1f115ed1cb3f80c449d05e3c10dafcf61b5bdeb8cda3a292c8dd33b54dab4f5b36e815bc3fa4164a953a67a060bfc6e41cac099f241a28dadf81bb47242d2102508feb0bc50d2a4d8ee9ef1d54bdc99cb85cd91b35dee1ddae223cc3b9b93b017d8cb6de9eea5631a4d0d6185a44fc108699afaed2fab358b48ae9499a151e0c1f3ca11242592f641c222e543323ea433c97a0deaad074adef5c605c2d7a9c209f9771227dfc0f2fc9965484e77e34b974d48c766c0902a3f32c2b148f9c146007fafc145673c3e0228c0e7331cde1bbf317b192d51b450262f77d9f1e9891d83d3decac43b5da16ad38b6fe12db897db9f03ddddf2945cb238574d04b4615b186298bf100aa97a0c27a85d8572a01d3a594c132b7164d52d1b34c1ce85ebe8180097d9c4ffe3f0f4f8d49a73f7ec8c337c51bc330914afc776a49f2f276ba1e94b1f5a571836a895efdeb99f0d5c51e9daaddb83a7f221474f6a1d528355168b6149b18d89df6ebfbe4a6eb830057d0039c0944a7cc1d3373827d9a803276840b640e4add0131db07e801f7eaa30ae1c7a8af1a3901bc18e95278e450ad39013c1754eb01f59b1d4aee111b65d87b48928744050af655e5c04b6c292a4af11765a7d0c42cb18e291015220024d74cf80c4f03af1949bccab5776aebfd0615876903e8d47b384c139105d546f666f0a10381c66f97a9ef33ea303d8eb15800788ce6bb1a6892bc08a503d0ebb061208747afabd33d559a2cc6a6fb48b117d1eec8e3dd7eaea8e46786ccf3f40e8c9ff701d18b7fd430b0875c951aa150325434f26715c93e73069bdcab494ab1048d13f20f65bc36b1bbd9a143f5dff6c41563969ca613560c4c1a83fdc138e42460495f9a87f78e063de5edb0d4fca7f6fcdc0a8d0930a6955fd6ac528f96c7421923065a89853c8c6c440017ab8fdb7e579f24e48e067213e378c895f19b0c152014bb26a625c1963d1e0409e4acc572c770019bb86cd93f71f5b6dc459e0ed40079a3190b285b6950daf868a07a59f93040fa6df0afb3c881f9cb0f9d051209bdc7f8d0ef267fd0b346c7de99168bbd4fec15dd0e984eb8fcd8c802a214081171ee599973934f10f8badf89328ef3bed318d51a190ccb95d3980347164ba2f0808c82961ac3b645fd11ca750a50e0ff81f56239634588fc3da648e7083ea71d381b322f0a45cbc808c175d9124e927e6af661e030fc76c7695e1fcd29739416354c6cee6431b169b0a6eff8569f700d9715d7be8be06176642604091932228c8d6ba3e2cbd443bdf6f1bc08a895f933c5b9e8ea76f01e9067a08918f054b9ac22dfc27c8b01cb63d5310a128c8f2c73e49d2a2b9e24aabd0d8a8b114a903e2c35a9fc1ec868b104f1305929f9709401deb336b9024bdb18f34852b37989c5cee8ec3a426d9a4bf618785f14231c408a7913acc4cbedc21bf6e957d0c2e808ade2df6404273d4b95bc56ee4fc8e50f73a18181471b831e80e51d3b8069b844a16a9d15574c3f13f06aab152cd97172956a6acd57f4e1623702039ac07552b597dd257b414f3cffbdf1ec0b9e1bdfa68803f07a53791478b631fa5866643f9eeeea2c1a8a242329b28b40a20ccacb4f5c7b4c615ff2346c10906dcba1ab085fe7279b092fadd9836c3e09caa4e517a38d9273b8e6b21be98f5f2c58fd2363338a17f7014921c39e604467544b4155fbfa6f92870361f7ba1c8e5c11e259d0a8a7b172c14ba4d35c4c2e696122919c4978960fb246446ed246f5f4cb6cf7159926516cb959ebe1ac201d58453c6950d6f9b5c29897e4a3c93e6ceaae5291ab7aa9ebe31e3010024d1afb215e42a15726a6b0079bd1b128e8da7b1bf87643a7c9fd3faf93bc6599a55b8b7b7a676ac376aca301958bf1fe047a2a20aadd081d52fb97e99bb59eccbb3e1b463a248038fc9e49835ee0be31823235ef62dba4403c3f5762d1f9b992f06aba90f4492d7bd8652b09b0a23af27a91155b3914dc16ac33e08a199a42d27bc001881aa147b97d11306e58ed87ebff387d8cea83263285ed4494f1f3d916c3dfaddab6c6661d4047d4a418a04575c5f83ef8f7f908e022a7469e25ff77e2195f3b1cdab3e1d5b194f794e07c97d242b7db0a8dd6cb3a59d4565446047cbe63852aed7ecd748593619e080f2368384b9304dc920d9cc47e2b1f7d850d5fdce0333fb47e0b8f976c084cf4f1715f71b67850388ab8a6198732ecb1605ac73f92255312d337e822a74a5002163e0c4e115aa59cfc76901f928c4459ae30e583a20c815554eddc5b821d159cbe79ac23757c0536034166216f979bf9a35fdb36f628f4ebcf1299189a32657ed03ac1eaee8eb4ac20e6d3489b2df8e7eaa3d149db7848806e6e2947d03d4074b5150cf63d6675df536077b7b957f3e7390f210aff591cfe2853304bd213246ddc48a8f275605303e1dff4fd12a93cded4671ca3d293e7b76fdddd6a256dbf26215801f59a9c99ef656f0e3ff2d5e316c2037820206afd6110a4068a7db350458e5823a4e2cbba47d0bed48b0a4fda8b242f2aa13c9b9a90d60d8cf9d0ef13bcfb2a4313a0a6a46cc1958d541c3354c480667f4b25afd6d7592492b53edd98d74fa96eca8d290c7297d9ec55d313a1282f5dd0d586b97373097f933fe1d7a2b0241874f824b3266c7ec80def18f9f891ebd752c946853b75069342b2b3bbb0aba56e12e1a4a827aa50a22078c6393fad73ede1bc609b3d05a76b5e2a243d7c93193bec946ec9ddd446a5dd9612165533d0fa5a18b838f7104ff77a1c5032fa280f25af8878d2633f5b4652407df79db9164144c86f1dcc04d7af0b2665a714fc4800179ab58978a4d611481ab8f6c639b4c388bce603c909dbe30bf90f0ce0ad8ae1f8354eb6a35d06b1588524dff78b3fff9a9bca059a257e507a64f1c88436fd00c8af8b249e3c99ba0529454185a073c7e7b70720cbeac2c2ed4d16a2ea914a3affc9619346f68c330d0b582d80871f676c5fc11e222eb9044decd20213835981f48b912d025fe86116449e85b5d9cd3933fb5c3f17b1dccb4298255f2980987fbff711a2858f2e1843af24048dcf86388b4bfcb1d9d84de86b429604d890117ba9c538033049b277f2d06bbdeb663b890b5999dfae3acac35026a8d34a37e8525095e1000d7d974393a1017d908437e7eda49b6d28972e3d17d7b01b86c1f2922e12281c691d3cb65d422ff983dd1e977a1052ae9d28c45ec08150b0f51a95ad1dce2f51d4ae35950fb84d5ec8a535810c64a62a7e7bc4fe0e06b95f405244d9a0b534823c713b84ab7672e69c957876e27dc537a0146e8de062fd68276426f3ad58fcaeaf4eceb8ae3a034503ab2e163bf5ef039aaeeecff345b4072965a8f3abd522ce5b7ba829161c5b85ff6e80f39b3221b2014a02eea20b9b0f899bbb6bfd167b773eb6f62a469de5ad8852e64234ca9160fd8e536b79e1a01535c4c63fefc401825abe1ba930ca188b67115edc594aba29874d67824181ceb0069aa1e9d4799040a84acfdd3191ff11816b5347d03bb595e6c17731a25df77a9ab6225e7943352c980ebb81a5f0a58fe2a8cd68dd09acf0b9897bad44ae8c1e652823ea72a15d7e2bf1ac6034c7f676aca182c5a5df1f0600c7d61a08e6eaf08de3f7e77cf80860aec3c94b9d9246aab96259842fff3824c41fb36bbb89b95319c8f93df7771397eeff12b967cb3f2b7fbba505b2231cd1c9a5e1a38e67c4f647952fb4a5a28e68b8f5d60a0b8c72089d5e85b7ad79ac67c726bfbc5c6f070c0918bd73e2699bc0b998ac890fa159f0dd19c80323abfde0f769f70fc6ec914c31267f47093e4e611145b36816b8cfa3fe61966f8064e1671d1179b738530fd5ed92a468a02314f18beb023161c9068beca9252673fe52c828355ca0f87d622e29d7e7e708799cc50243cdc8b75095926e6976dd47e1406b91c2de61e997e5063fe94a8809a61f1b88757cbf6c420742985fa2e2c86fc642ffa4b1bb2d65a572e130f807175cdce21d9f9d933ed29db55e130fd4117a2348c92d2d47b07b5a30fa1704b61a9652263db4e36cd8857cc1367e96ad644a923955645fe764cc279af75f6e321dcacdbb26c65c38816d08c7075dfc2e755256732fcab229965121d0eb3e80387479001ee9ec0a5db262428a7289074943b6851e9e526ac81049904e6b51696c76454bcb0c28402d9cda2854337f653a4116b5c20ce73ff0cf2c92e885b4ddccac67d2adb8712c47c84b2eafd69b138276a63adf0b12a43bc4867778bc2d5bfb7e76fc01c61512fd3f9d1a93d102e96c23a4aacc76f4a0db4014ff1ddf6ebbbd61a752079993bbef5a2d2d6cf283b92f6768972ba895ce47cc7a11537cda78f99a212b5b4ce9b1cd7c2779b50b499940a7aff04001b58f0159eb7a76cadd1a11427ad808e5a272adb985a39f27d50ebe9ba4b17a72af026cb82f579db7336ac78a09909a1405e2481d2bfcc58b56164bca1b2fb3fa5f0c79f72034fd4c85f3b68fd19c8f16b58ad1976026b738eab71acc1bbb47d807d40c84af23bdd4fc89bcb73f3305deb001177aa8c5dc1e25bb1f42baa97f4abd478db9164b48f020469f5e044ac0d6a396264cc5ab3009fec917d2629d41835f03af532ac7c8124fffb8f87c4d9fc8268d0a3c5a15d806f4ad1f4f124c6ec510173ac09836b528cd7f2aa437046a6b8de898fbff7f29e1d0e3b86dd35349b77850f720d1ac841e80af47dab2eb6743d552bcba75fe91ca3f558c35a3764f5931b8e1f205112aa49e62b8bfe2172c206a864bdc4ddca6d884edad65ca2bb88b5e24c35198f878d8eb543ffae5a652e7c385c3b2978fb9195a35f4b23f9bf6b514d2aea1b7dffae9fe398f7c08b59ce06b2d9c7160bc43089029969c19b52aef040919d050d178aa9325eb709d1363d617ad11c70d53fabcf231fc88d5bd2efce0b35ca69dda34251cf15f9dac96ce1aa27ae5ff8c9503ee9592f0a6df2acb1fe6f0a4a4d193264fed239cabe34921a9a315fce6e9dc6dfd3c8709a3cb6f2caeeacaf8a067eefddd822c11f83e077235b104a9b71b68bc880593ba90907ca1d20b032c56a320fb9efd2b6436cfcccc12a4102ee287fde43955bd6b2406a8ba4bbd190b632ed2b8cbafa0c12603dac14249e73684575d8ce2be9f3b161b55edfa616ac32ff5df64d693e6baed097cdf0f6f46eb0a46239775d2af338c501b68b78dc8b3f007f628c6763a46c271b818843e645a51cbfb72de4670bb7d4f425edb68499df10d6f21ed8f58e16dfcf865e6ec9d7550f8118eb817cd00423e106e43ae3277b4f92e9c19321bbf8f7a677355832ccc5a0b9e43d96187d0d6a93c33b04510b5b844e444b49b2ef516d4dd26059d783493af447367c90790bcd8155a6c3a763e4bf0e2fc99ce0df16fca72ecd9b4e559e7e19f85948cea1a831560097e11925b06f1217f6a301c8c17b3043b46a01f9cc3830c974d23b664bb70c95c3b29e9e5cbfa61fe509b3a8f842757646c16647231ab890b392e78c5ff2441169f59eba3950409c1643ac4096f95758adca3d8407cbbd4c521b6736db98278ad659fd3262d1bccfd0d51da9c506625183589dc7628926a3fecec877f617ece3dab6210fa51ef48268a2e84bec21a43ec37923288a7d7142befee5ec2c3b881cacf9de12d31f5053b983383012ba20b90bd88c758515db5b1a3aa1d1cc8e3fa24d701210bfce4d30d9048093105de77154091e0cca8646de9fe7685d3a138505a3725523a99714224da2d942bbb3fc87858243456d54d6c4c07a354a29148847c8860c8c12f942f441a804343a12443a7893ac277daf49f6fd032e71a864eaa8491f105ae4235a7160d961a1b5ea43307a163bbaeffb314971291d21c4a4e0851527420ef292bfcacb21d8a801a9dfc012b699e48aa025f6f1264577f43e5b188b3e1abedd7ddc255b574129d7746fa94aeba0dfcdc7f2875fde0a8bbad111621d0310739a3a8321c7c3c9207badf59964c2ba432d7b7d3acfec50d1d55e64569786a8b9027cc273043f3efa25e9aa0293a9f76aaaa585c453bed21fdbd654768581321668a79fec76a70f882eb8fcd460327bcd1a014ca2eb045a25f4dba0d21151a5ce17890176f42e8552b6c22220e6876940aec81ce028da292c0b388bedbc494aa798dc4570ad6db86b4dacae3a59e617c56b204289bca57266d50d2ffedde6a9aaa4396ff6a006d5a72bf47f55edf534d7829be7b1a7c9fb1f11202169802e3a6427e55717204408203772f36d603713a590e7c7d7c2c5cc13334a6810ea1231f91f6ac8b3cb72b749e66ced31444ef79acb1211d552c76ba708c070a36b47ab52f6e2481cf9bab17ab275a5987a10d08b16e0ef165a0361f7b7347b7d8d8511b1e152fe4961a418e6bc2310c19a9e446a7dfce71b5f234fcac9aa1946bc4ab871bc84c90de6539e0d5ddaf836e922d485470b18ff694de3281bf9be55e18fa8e786b68403617fb2dd4e1fefdb402b011b722c49686783996586b065dfd15515d7825cdc9e687bd61472ff413271b8017ee1f33cc5fabd8a51ce3ab79c8fc8874a1b62d879135c2c594b7a00db0d62421088661eb30c1bb24348546f9eaed16135f29baaaa397f224fa27216800c6f06d8cf2823430e6107d9adbee6736ffb4fb8edf537499200d8109288967b29111aca42af0ee51ca6fe8e12e44e9f1e950f0ae4a8e81e505f3af7219e8b58f9ecc680c79383a85ae959250c04dc9df95610c4d07d6825d496022d18d6124fa33537f25171d4d0beeac837c5b3e2c49fabe5c1881b2e702dce54420712ae311699beef79787afbdbbb171d493546ec06e7f612d215030979c832d552d5a5b20c8ba3189d34173ff4e00b97297e8a5bbce055e504fce7caf6c0ececbf0c12647db354664183d387bf9848ab547cc028fc4a2a4706845e3848d45c4d8a2b00628ab5eb0d118b65f877e2a8409c56164d69839e90819283f1b94245d3fae060c60e705747536173a496bbdffa3e9ff267547e0deaaabc80cff345ccea3c979d03fda908028c5a4f093334a854807ef1542177a6ccf5c62692e09b626da9db63336cefe25f9aa84a3b632a11b436e828931c8573b4fd797108b53f5744fc0f12acfe3383f69fbaad5df140529f4f529919b8737fb61539f31340c6e2e6710ad1b610b36e37b5e2a5d50d4c3b6f21c6335a6d22afec6dff210505a5a1c815eb576ce8c463691381b783eb9cd77cb47de4634cdebe334ddf7e344a6c9aa31b14408fda5948c00709568d4b6e2fbc4507f15914b56bb1a81e38abb3c8b3d9ff10227dcf467982d0d28a08e99b6d603e4f2ce8ab89dff27cd896b1e49d348b89866b436ce30219db0be6a442fdf805b31395aa856b50c182a7170eef5fe5f177da3edf5346902f33cddc806d0b401f08266becf7504f37e3e4b5173fb3c09ee61104eb55c9c8238a269748ffe3946b8ec07061e3e09998634cd991486b872414747f6f776f51c9c70d6a7c58220270135943f51bc4c79edc71a1104345b94e0425887a5c177afc050bb06764d307a4f5be203633dfea3dd2a53af5ea8b8f123b8515ce49ecfe62cb386760e432c3f81e7b6db263ae0540fd480fab97a06c83a1864f1ef3c0f99f0198d039d6320e9c5e874bfaf723cdb3891659a3a86ac0cb61e9c8157e0e6cb5c729cf4e6ebb87b87a56e52db98323f94718c36784b847791bdf537cc3fe9b2625c8b5bbf1f9bc1c1d138823c707b0b5483bc22ac21864da36d09ecb27f7c39c8b7f96a3eff355f367602b07a0a542e5835ad98ace31210bd87a8589d22713df1b3fdd62311de464e29f43bb609e6cbf1e0e63b74935fed5b9571b5ee936f3f862f67dfb6707048e1702675834d73f9f98ffb849df83b105e658a46cef5f5424bf21e47a821dc788466708b7b428466540d650a4db1b8ea4f990c78d69bb331d6534cb185540f38986c0212165a38b9ed232d5614db0751fe21c79f64341a142aeb935125138ffcffddc6cacbd1721a4b8ac1485e5087c737c35ec9d45e4ea6f746b8ef31521d477288c6109f7fa4bf06405a2f8ed68e7d04136cc9446f4eca367678f9b88cd0b58dc7dfcccaa046d618171a7c1600aced3d59c378500054a9c093ce985faa80effab1f7017eacdf05ad589e30c5de785917126b5bddf6116e92cf249517366c15a6a9b9e18ee3587dc202a2a49afa7f5c81ba8e2750a5ac7bc42261cc7892c33573186f82b0814dc2bc7a4936d28239819e20a4d0ad641bbb45cc0830385dcc0f023305faed96e76bf1a1a9033c51b9ca47ba0c21cb1faf277a7893005e2e9b0b89930d11aac0b5b9e2af5db41fd0c9c7d952f3b6023bbf333113b83dcc93a71c25934e3563896bf38b07b5dceafd18ea507991c8cab1c1a1be30df737ceb79fbb4df8d963ebdb60d94621b26249d30cfd48ed0fae523cb6764b633567bad6581b8395f3bc5eea3ce949fba5673cfbc71cdb3dc5b119f07cd6a4dbb266e9515786138972d81bf3d93c78486bd6b9e36bcc6131dad6e6dc319fab991c0e213c06ca052e567955fb7ac49bbca18baaaee6bee679d355b85fbaa5ae2ca130c746ad9af893d11e36e48a006e27601878417f0829785382b20c41b940e05e89bc8a37f6eb37982ec25451a0e29d4df5164fe1713e3a0aa3ed4da761e84a1c971172c2f10b36acb0352acc509d9ca350c6001db0b255d9a810ce391d464a692b14da9b9c632d0a37672ae1ac24bebdccc5aad5437907240ae103532beab65afd6b6a9b230c89120fd1accd33fbdf7550fa072302db6970991dde391de5b20d0dbc04151f0c81cfb94536882ad7085fda9e13b56e21e5607075d4b8c7373f49ef7e64f82f019e6c24136d89cd1197098515ac050b13353459e590a06082fd4d517d4399a95c550aa16bb0fb49ae7bdf82b55b54d0a20af77c9fedf3bc03193a59181ad54a1fe397e94ecf3e8a8c440719e491a0656700474f73f3692940e04d3b64e9aee6bf0081b5d517beedf677b988f8a12e957d23355f83f9ec2b70a4443cc6eceba4ab96469d96d8539cb4c4ddd92757fb58a6faa092d88684377ddabc8d654b629d87550d3a5c38f70af30d173fc3243b5cd1b1bdcf278897ef6e7877faaeb6dffe2852042e9c26b884d36d51d473a76fb96367b76021849c7e76d62f34afd237951fc79decc7cc8241fdf8c0212d98c24dd5e330048b68b8fdde0f29c3b13fa237eff63ea94d3100e85bdaa36fd9191c6816f7cbec4fa7ba51181dbb0afefc0b2056ee1add9399cb990982d90c9ba8751e2a14952902a1eeec360aa8ff3ab944ff8f857c74e855bb74950e26a4801f10cddc149ed25633bc91e4b43ead0e232ae9ce592cb53391f45de8b08253d4093d171b92a162a1b6980fe9139d246d50ae659d9655a7dac039e8856f2a31c9ba7e8af2f433381ff70b22d118c3d9435877b0ac6a56e7052af94bf5d6c280ea0044bf41bf66cc1e29f35d1f307976ba503275ccbc54f5e205711ee1fe45d309a8b6f25bc567c4004522df31616149999580103877e2c6a57ec38f9940122be164275c09114da480f5a2a9631000fe4cda4f9897aedb659438098a78ca5ac6c405968e1fb63fee34a7e1d735d6f1ef6279618520ac3c1f1d0606623f270ef5c61ee541ff3c6854c4b1c03367f7349c46cb4fd9bd5a7a405b4709e4aef26279bf702d6149d9599ffb87a5476072146705865860388ea9b139aeab0b1d9f71bbd5e8e454eef321c75b63923a343755b5343c8a7a52b4ecaaf4659eaed39c8d634e038e6ea69551cf5f6d8568a8f2cea866128c5c753947c143197dc1a760ab833e97fe1d09c38ec2922b6e17c32885e0948f9a3df33679e82426c102e8a1bb9adb56af646e3ced151f79da97f34fb45f079ce9c94085685e46ab26b9a46b267066fd1f3c9a35e96cf5033fc84d4a1950db14b0fc5ddc4746fe5cb5038977ba7aa4d64ae1a9c53a319f374a32dd37a18fa824eaa48278454711f3c1d8526dabac493098e01a8e4706cb64cabddef69ae00acbf525c9cac91c5a0d7870ceb81c50f79642bf7bac8df3e96dae52121bfc63a7316bb24d5c65464835b6f5c9249e3a3f5f858792e59bcd3b04da9d363a48918ba956312f4db388a48f8669b1e286c1f5c23567abb9b4d6b435bb7cab3e5f2c142f5e78fd279bf0b7f33844a979b06ce058a2cc33cbf7e967e6766d385ec27602b611439b6e0324ff35afa8b55be4b53e4233997c821c3781c9ce7506a22fb29ebf34a96e392e1993099b4a9dbbe03fb73dac2c58dd39eedf8ae8b9634e48b4beaa6d304f885ab4a4c67a87de9e4a261230cdc059603433831e3f4178f4c319edd830566a2243e050e984f3080ddb49aa59c314f87736830541fa327e295066fcc6a2d2b2e71a4082b4b149470e9a41df5e30c9147c67facecdcea99ab507e94334965e4e340fb947c00e5e9599a543578959960105b637202c93618e96a06c02ff124910ee4a72fcc40f04907e5205ad68a6ae445e59ec4fd5d47cb0fb0c4428c86b25aa0332e27bb9e0403ed1579e96dc443882a21b029c17ab249bf44469c25c3d4f06cf21dca1473eb4873d756e9a23cb5eb0f622f1fa75929cbc3fb1b41cff4852b00fa57ba0867e6cf49ef763686e8aea78bbdd392c5a71e83b72eb08ff01e54349f8bc09318266c6eb2f150659d468ad24cc26d90cb7002b6903d145bba5013ecb5416b7d0fcf8f29eddac5480aa808a2cd815ef4a08cde83ed48de9e970ba1b0cc5c8744ef524d321560c21d52d843230c3f2dd1760ea767dbf8aa45a563e4841892fba2fc00646a5f76d1bc5a4f926f555c681f29bf8738b4b53f7fa721a3eab9e60faa84ee03846c8126ec9d6355a1aefb5b90f4c949b9c520a71900749c6f484389e872fa453c630bf2263666383c1edc37e139c588f4537c7d6f93717b0d16d4375d5047afa3217a471beebe1900c93ba52765abd25a6ab9322764bec96c09c2ddc8f1efa1e2718f4aeae51bb3bbfc7588d249eed12a2c5b4defce51f5eafa5c156cc62fb2528b715664dd88b5aa6f9c0d791514355ab387afe205b0d39cb7dad461602c7832792fcd89b0627f64f0a80f35491630481942681cf8188b839553e0f12afdcd1a1661a2818009f67d032f4ac31336845878454b7e118d2c9347a585107c67cf974aac6ad11b57709228844bc8e6e767908622b540a81f11f10a31addcf7a3b4b8659f3017cb084fe5c34adead833692f7c6c24aac419acc2eddbc53e11082df471e42a7cf17cdaa6d55f6c86240281c511d91847eeaf40c399b3669bea27ef95a48e6d8a6c245d2d072864658d307fa8fa5e11067ae9189d4c72cdee88530ba0ce664fd582db5b26f0e55e26396466cad7dc2e577a6b1e6f29090934816bbaa5a63db0e6e5c6658b50c56c2f86cdc605ef5b2d6f7665b043f46491f7eb457205fc661aee9e290594399c592a46f4394c64893f6a2466d92fe5a1c93cc54137f730031f0c23c95229e7dfb6b0cc942693cc33d6835abd461358f7bef093a5dc0583de1bcea3a5cc787f8107156645d725a39289f036ca4db51eb060144aa05ea03679774ade3abd7c537d30e2d136b102dede04624f8cb1ee7de1c6b3af31533f2cd05d66e889633375954d595eae1d4163e980ead35de06498e94ec134c61c6717c138dce0f8e00012e831979cbf1c7cc04e3e1c58ec71f832fab5146190e4287b77fe6731727febbf33de284ac6d266ca80124f8e3c956d25dfcf7be0601b8954f43d14fabc20c965c6684f318d215612b2050c56bde3b7b793e1335250fb25b8f64870f730db092fe77422d56c2bd0d7caf6ccf2a39ebb9cf853f7253f9481808a191fe666973cf3473175c788984676e25bcb5ac9b9c8e82b6dc4f167aa62457b9f106d00a102c8c36d495b334079d72072bd63fe28e37f87a201553fefb6c03ae319f8d04c34eb7c9434d3a3dce80f96d35e6d010a3e53c214e640760c1cad684541163b31268367afdfa8479356bce40aac25fb2a5bce96a3963539e99d7fc6994779032bc91646512a1c2da260b453b83c60f40515a65eafb9f9e35ceac5c823b55e6eee440bd9dc6382a94d260e307f122dd51c8bb452a531c225dca977342bd45558e171d0c265640bfa64bd55e04a58fff66c0d41c3684481614840628de86f447a30d552094bcfb3446ea0b806891e1aafebf8687a48d147a9edc0ad07fe964aa6df1f76ff3d77dbe08dca2a2dfc8a4de22f71cdb1981935f7c315d36a83c3127cc3ce764f1793078cf07cbcad93c9bf885107d31e6d98831ab99d9e03e5f21dba1fba31106074053da3286ce0c736a208d6f17be67586fd38ab973b821547447eb7c64162c65116d590e93cede190bbe7d9857f3f5cd849787eb8ff73d8a6a760fcc422177aad2f99a230c2551eb718c37819f97c8f2590c7497337342fd90b55735db813d84600ccbd99ec8e3c0e4a809003dd91663d91da93731a952934f824c3cbc22b55eb22b90854753bc163a228ef75c4e6f5577b7b712796711014a35211dad1d0e9de5c0dba5c071c91a2820d0c40b82394d12de939d13414cf452af51aa62657c21bbe3323a106a1880e6c6f09468d55d1747d76a8a64caecf665ecb9ddb7c3aca81aa55523db2210029262e872b91a86559f610024a36663402543e8478b6a6b756d352bbd4382ef2321d3ceadf1a6be222b72f7576f401ca94b82b88f9be49fd1df0a2e2395e72f1d6d2c19e2f66c05f850ffe19a64722796a537abaddab624600f8d4849ec1d8b2b10ff70ffcb5730714825cacb36f585165c5dd03aec7613744a798af9911ea21ab3b355d34b521ffb6a73db7197d994ad7813c073b6511fcce80933e22825c7ea31fcbbed37477d47af96f37e33660e1215bd6ab197f001df088c8dc5766dc7bfed231da4a558f8034eaa92048f9efda1c30ea751d4c6f677be7d196be072735ad0c0c229ef46f41f07d2ec21bf13686574894c8514abbe09542f75ddc7186610d693977a310945b24bffd6fd65afb8f0d0e993083732a6b7e21c3725157fc6e44c10bb228e203344e9e48ff4a7fca44769b83cebffaa7e42650c1d8982319bac84dcbefe06c40da6f70e80b8b42367dd8292926c4b71fd0259869d114ad33415c15b24dc991732638a5dc55a41a917bec09f831aa41f9d8a24e6bcb748d53d7122d20f9fba1e1fbbb72a575a2d54c463de162d84283848f3481424292cb15332c726653f4e513bbb0704b1aa88781507849c3fc6d23e5c62558c79de293557b34749be07c1e21e2fafe317aefd05519af86a19a821fa1d237ccf50ca1b23c479f3dc1b8dd6f830c8224605a6aeb97dafc9560ffd396d5d0a190477ff6a885609d818af8e02937d26abf0c42aa26f51b57c276ce5b5cbb7eceeff88c4ad142386c0f6711307c36a58471738fb6dfe27c12ccf3aad35bf9d411a9944c7ee5c72a86abc2ac8ea9ebcb5065ed6188cd0dc44ab0414df36a6bf561e0d86e6e901067e6fee7b276813d910cb45133d21c67f49296f74cd4bf841bae7c9a9ac0f1a9e990418d2577b2d67cbabc2f3c18c3c10e46fd7a88ca79c32a11bd2c464e23433e67492940473bff5be7ad6c27412dedb14c9174b95168a05c3df8695b9e516561e30d8d8a702abaef4dafffc2bef329fcba27a1c3b4d95cc449168252653848e676b793e290f6f34691cea37dd74a8f4b1bf684fee625d70e2d7b8667271e09ada2a6f99743eafdae134655b6fc6cf09567e5aa2eba941f234cd19405f71dcdb5a6e9fafc3c367014ece71afc1a43ab90f4527517437bf7cb7a5209bb73cb63def8d98a32fdc69ab35280ebd20a90eee1c0f9eba38c7c792e11efc6169c21d6453abe4c653c0a5de93e4206a3bcc697ef1de4982781b206bd629936a245375a575387e223c7c8dd19fe738f22234437edb031bffc45abfa470bc7a5d13584d4365a9b53bf910cc88e454dbf2dad1eb7322588a4714152e60562e290a0bb8dabeba369af93af054ff0e76299123d3f9681c1c23b89b3495504765363772041589016f02e6f163f15aed56814373aaa6900e0f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
