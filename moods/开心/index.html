<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>请输入密码</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">请输入密码</p>
                        <p>此内容已加密，请输入密码访问</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="密码"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="解锁" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a4b687d7cbc3cc34331703648f74b6a79a3c31cea9308326e00ee306b3f50998e8df62bbc539fb859fc4c54acb920cd7c8f2c02233d97da8dd4300b28bf1aaaf261df643b2412c5507b89ea2987b5b8e597b83861be667f12a98a6a5e21c01c6b9040b4b4f6cadd016fe877e023ce21a7ac1aebfc136f709bb1392aebab78acaad22574de5a84177d277e812c69a339dee375e130f8eff74910d331ebf5d6d97182d7c316875d99b7fc89bcee0c57418da5a031668b824219bd58f8993d78988c25be4c1ab27dff26a7f3df96518b14e937f7335b09f74d308105264c7ebbf592c4783e8ff6af35d70d0bab20f0d830c038379b49fc60650c052d10184b5200d1acb7ce1b3f0a5c83e466cfe6114cb25def43aea2bef4162548b45b78cd064aa69161177b7bd1fbcd6c4346d015d06a49be7219e0b60938143552e4386fd71f5dcf9fa1ff40282f106ad44d089b1a39f2bc5c0710c740935274b920930f6909a6edd809025647178101ea235860ed34a2ce823ec3a160e1d8d3166c29ef3b64ba0060483315b211fc86d8f78944a2cb6c4c667d4df7031c62c8032e18fb90559e8e4f5924043656eb060e82038304b789586fc6ec32a16b88ed07611c1b559f597c27b4d257c251c422cdccb5eda4cf3fd0ddb99bb1a589fd9775309874ef143ba8015e765b259475d46ec878f00a5ae4801bfcdd6e1d4ab8c73c0e91a357445cf39ce8fd79bdeb327e7b13c8bf6191e197985ffc9ce4f18d2a0536763755b007a4bb6afea9a1a8d4e4b79ede2f04a87efc3ae22c789f50c14b956d783e58a10d7d9c2957aab6cc00c1e0df5db83c629b2035b5b89a91dacccdcc5ccde0a2689c33258cc66f919f178f4b6146923ca28390232615c5f2da6ab403aa3e00c4ee8273fb69bd2fb6f6a4e9a7975ed31f4ea9be9a7c64264078a7d136839cba25934f0de4036c562b9bb5f8ee6af281c06f6453f0a838e3b4ba1010ab32ddfea9078600fdea880edcdce81271a3295bbfddb8b449bb83e936d191cb398dfa7ef02155135621e9ccb2380fc8f7d7fd679b7a3b88041c0a4e9d7beeda9bbe96a5fd182389b4abf82cc3dee5f1ecdf2fd4766de6096dd5c0dda193f8554ab3809c253f460ea88df9c15d7bf059d124c8b93c3c6a3e0e1f8c9fdb87602e5d2c4382492a5b97cb39ceec7ccd6148a83aca8e3be6c320ee5468ce0a650763aace4c245f5ba3668a8098de3e96dfc48334883bb43e04bfbde98f87f4bbcdc7ef42f1db90cab01d33f746fcb1997ead136cbc8a6ebd869df2c9921df68cd2ecbd0eed1bef48b4864cf8a62bc32f125bde2b38e79f1b69877939213e24af86a411c5e1449c87ba11b180e1fbcf19704e75e0e8460868aa8ceeb506f62f78c0705c7a4a3cefdf510a25cef7f02879dd1a73683d6ce278fc3a628464d7233780a9e861657410e41b90c16ab135df92c4a21d54dedaea06b5632f358401270aa8199de2b12ba97db67ec183921da104d107f7aecfab9cf0c06b2acd76445aabc8b5ed8b317878321e03a6b19cae603392a05e5f4cb2f0b3e6b6552d32cc92a7f10ad3436417441c9e4bfe8acbf298aa21558eab9390c84d357ecb07c99c5bbe378ee7d605baa86c613fe6ada711e7b3be82d2a87ee245d52c77b27676fb93342bd6d16e2fb82f9f368fffdc225acd1d8f40f5c18436c92f1fba1bc7f9d275a7c985b5538be8b92850ca38c17c4680239196e1e9a969430bc104905b939aee5c1a86fb4c631cc1ea3870523cbaa197cc50ff9b78918138ac623e21940f1254fc5a6ac54412eefeafc63e3fb49cfce9bdf92cfe363ac63ba726d8c636c6fefb8cc8b0847ba282d3bc3ef9fc21e896bc45bd41fde5791d1fb2b1eee318a2404fe2193876b3d91ad2031f473086d44ee65839ec8b303223bc3b66d68b60bb48295c7a15a21e850eb0ec4a4841f7b0aead4558a78cc87b508bee9a9339e4899c03014c686e4b5bd90eef703f00c106f5410825c41b10cded0cdd46ab738f833b7931adb39788938e5e9d8a98d600ec461087c4ed0b958fb352a30586e3db3ffac4fff07df3577a5c2da4875b16cf804c96db8027ca69d9ccd7a432de6c8f82add226a44c9b64ff0323e169758b69d47f7a9b39e3756d65638b644e6f2376635fde19b98a492cf9823359be17c5cd87ae2a43431a4fdded54b5dd9890db273075d262d7226b15a724974543937013cc233af9daa3d0862f3f670a35583d35ab22814d31fdecfc07bd71b015a476ee3f3974fb75884e0a8b7176b985bf594da8210871b4cbc23261b3aef7be75ac651a42cacc68b6797e2ad178d801e0d020095d027256c6d3c6fad67bdb956eec5e9a938a31c4660c63f01d1482f2a89af52be301b5f27c1dbfba190e120fd8f68943381d5f57b20e1bf577b5399ed45b2dffc14535b077c7183f4fe143808609072c29f546517944aded14c8a8feb25fb269941262df64a2d72523fd443e5f861000620c08439e668dfbcd3a1d77b59c1d92d714b4c8dab5b3e99b620f4c397443333f6f17385970f0ada68752699382b0d31a1f6797515f2e3f915a480d0f010089f3e204038e8a85c0a8f87a73b5a5510f11f43068a7dd401c5b9cfb604bb9fe01ce279daee8936e1d147245deba9973ecae11c62cbd81ecc216440427e4fa46805754c32eb8fc13955e0a2f3796d960d0de3031a9431c12363612a43075f6048eb9f3723c9556795ba0ffa9919552204d1317072a8546f8ecf37f01a04f2fdc350e0db516acb4046b38a921e92ce9e9b94437df514dd2473a030c1641b67d90aead0eeb62e4d025fe542485ef7bf5f2b9ded1326458d3d6252a75f13fcea4fea420cb40aa7eff52884dd238b8103d31596067d0db52b26db3479200d31eaa666f6b5c840b96d427b75be8ee5eb9ef3ffcea94cec057f5eb0a920806676e72f9bd52dc449e3e1a36b06fb8ed0880cea8d204a42b244040c075023c0840be2a53d49dde3c75daa674bf589d498e1dd5628993d575a643dc53f94a4596cd916e56175e9e1c20c9bf18c4f7cfd19540664cf7d697659abe3708b0b7ae7f253a07ce7077e5a96c823ff3046a404a8924c53c1526e86cd927f1f9cd9fa5762b3dff52c3dd0beab57d71c07ca92b9f360b7700f7707020374772d573d4a2e5ee1a0443a0a3def08b4df92044488a3108ddd5835c2c7ca2f62ac4023a7a2bea3debd5bf5b81c0e105a4d8c61e57165df3652cc2cebcd9d1dc52dc65c4c779de52ad9e49c93548616402ef92b0b38f7f409328a4dd0d9b830220f349b0f365a868d33094fd856ff3b0be43db3895db9f7f81fb444ec972bb7dcae8b68019b283d78f973a44e6de9243a5afe6ff192985eda74575bef34ba99af99d30e8d73086a7055e12f59a057d845127837e6d1b4b67a351c6e94bfc11ed2bda2daac9695009055cb1ca4b70e14870764f2c3c6364836107653347a84f7c1966214a6c08dd42d8bf8295f55a64c8f88b60e3ae657ce2f33a249b1293a803be63654254f8ea2798d64061ae3bd21077c3fa5fcd702b351027777f96c9eb6eda7b095c05dddcb0705d256889eb88d6aad819c0bf426918ff58a9fac676550f25149718863176bbbc685b915c4e2aec62392542f1e2157b9d895027d1b0d0d46dc0186f2c54687f172537249dc99f92d32a19d0a201fb5abffeea26c17bd5e58ddc8d8b845b13225853cdbc9a8c201378d1291aa82570ede9b1a1c62c4dca5ad95f0ef719122f9b75cdb8cd7ef26c77e756c7c61c9d576c647504459493d684cde6a8f133884c2df869091a99be623bdd7aeabee1c016fd4f164ca4c0bde9109f32d981cf6c0da4dca7259b5a9f66b6c3e6848443699b6eccba2cbd08bf8806733c7a3f46d71c223cd9f395c14b33503b8d37b2cd3de9814be13af5535e91d039a916aafe650314002119974c075178a2cd16df8bd11a13384c14086e432c8841997892feafb352a7d0e291f42cda574c14b253606cbd6daf0295392038b40a30dbe4efba967c652cc9673a1253df64f603537175e80f17104b92fbcb0b7eadfd37202eb3e625db96ecce95ae35d878db78bf033b8fd7a92c99e28867b68063d796d04d3f01fd28860658744fea4e027d808094410521f741789903e6e34d5664415c2494af2e0eb3031f6509ecc2afdf9c18d444f40908a13fc3c614da6f8cc482b909d2d3a1b065c232b1e64a7e29ac9c1829183ee1c5ac591d5103e2ee5baa6ae04a8743521e8f13a531192d3df9562f6bdac08914ac46b0dab790cb1a6d644de091bbf1396cdf9ca05836cb3fede9170a49aa866bc164accc65e526534dab7cb7c24d6410fc8407077eecf705c20becd48e993c6cd7f308f5f7388f562661293af1ab7f9372f5cbc1ad0453a12e8baaa6d33682aed0d1fbcbc224d7ea45895c649e86c4fae182b10f49c127a6c5bdec14ac851d186035bf505c534dcd059ae40370777944c5129f1fd1aba44afe60dc4d08ca2e7857753ffb5a117d16ea6d2afc4e8ac26a5d965b90767f6344212ad05e7c24793b0591e7f81268fa06ec9321f5b2796c9780a9d41184325155080011ba9c1581841636d5c229a02a67d8d15890356c3b46b1c4aa89c4b1132d5cd73cee86ad7288745d3c92bbb6bc818da03fd2ef0bf3dc9cbe83b3ef376b18fe9c4b8e7d601929353568736091d52a2cab55ab4e4138a6f1661e65165e239f3e1b95a4036b47f0be937290395a351107c4fd9a4eb45b755bd6d080ce1233d4f8a191a2c80aff4805387ccc387c3c3291030bd83ce998deb3b623c42b37f41bc741f7018ee63904a2ea642b2e4d606fa6c75b7becc1881fb11d079023cad15e607ade72c9c0d702facef0ae001a41a161374cff37f91853f5d315dde077dbe3119462d2f872f68e862a5918a5fc6b4080734b16ab16d4167387d4c8e27a9bee9caa5571afc9e78dfbb25e8265961f463d66cddca61212555f5ddcf2669e4347415f3c567571c6d4a942a90ceecab43ef0d323fdafbc7a32d9d18bc47ba4cff1c242907b52cf51d4fbb920c8bf4469db1c02536355762f8d20b905834065cb5525639622e38150d56381529096c31d3d2f303b3e6af650fa9a9f3a426665270f53edfb47fa88c5b34d6088fa115b83b871fbbdfa1c735f42e04380e7496bd4c87542674d76de313e89092573dcd50b81bf5c0d175f996c8d3f30640b170a8701768fa00a00efd7fd2ad9181adcb7b8b3597b443563ab2710efb9fc39053e8a76f58c1c07f55aaa69c46ca6a6f3c22018fae34ff92b2f61c7699909f404aa2fb6ce222cb4b0bc65364386607f48b4fb8c4090a8890718462a0e9d3e20b26aeab834552f79c2ac0287f003c528da0504e858441c29cbdbf941ce0f9cf2cc9d215cb5acad518786a4736861808a1fd547989d1bca3cb37d0412d3586c5289fe3e568084416526e8396a15d38fc77ee4d5424e5eff763c11047d831ca8f9bcbd4894ffaef77c211b29ba3d2eee6db39cfe72ad1941af0d2584a591552763be36e97b19a1d69caa7894a56c6fcd78b69a3c8bef859ac510f59452821e64e1c00bc1fa1dc0b942eeaeac2f698dd528f7246bbe837bc781e3c40dc2fa13411766708d92d8da43a98d111c46397769771ffd687bf3aed8549dbe5cc6a8b47ba7830a3ab83d6dd35cda32d93d993cfcdb07caba8359ccbe748a6a62dd34aac9f26ee8d876cfe3b324ca5668e70844344fc8ad13c3aa79ab3b3fedfac5d0930ed7d158db7429bdb6510f1a752adaa22e51b0f64e955f059c1f67bddcf617f04061c8cef3dd1a243e8846c94b5fdc00bc3cf3e467698be1e49bd763b5e08cbabdfed311831bd0de9e84f70de0d62778c04aa20cca27a64c7fc10a1480901efae5d8297779bb2ddf12ec6bc54d11152a84843c3c0c19d62d434b5e894b77a48c77b84124af61998d11bb12ad39c05b7f85cf14fe9e12dbf3db596f8c3d79e3b66d58c9836cc77fb481629f7de2548c12774e88230b1755f4df02bbb80553733be52bec446d6abf71c52f31ce3181e3ad368552eb629801d5c2822d0cb8de062f23efb4c11da017eb18ba593b337e2782e486c37c84f3ca1d3c799fabdaa879a23f5c32ee9f3e4d340a98dc3f9d091993535eb0a69689b6ee66ee39c7d9c9404c0695a39e247948d7520ee60273dff84f8b0a4e010550de15e07daecdce858e024f7b0d62a6cc47080e051eeb019e42221d5297db6ba5bce5414c4e752ea8a024dd85329d682629fc4ea2720d9e531d5447bd7c849f6b6729628cf83ab9f89eb23731fc7581a343ee777ab8308f54eaefc335c3e67382b11e06edced996b5fbc3ed41736cbd03bde5bb9d90747f8f7ac3c873a97ba85edc7f563f87d26ecb6e3aeb72f1b1b9621dc36fb1438574afb98a56af158b6ee9e8224e71dfcc26c203d4d63aea3b6ad533157b6200d77d421024e3d7078e2ecdb07f119223b14de45289b6f8efbf86e49276b457f8c55dc1bc165be104b4a6cbc42038b9dd170c4b69f98153ca65bd05a1659a89bd7eab451200f60be5a3a184cbc07589fabc92eeb687daab3db1f66dd60b6f8425474d93ccc1a5c66c5b8d7db807674fad7d5f59b13f4c5f34a01b46ce88c5c2f5c2d79fb3daa89a664c757b2d6cf32b43972c0eaa9dd42501e4f03edb447560ca5a33b52237bd43de764e15da311ab2fde9797fe5ae434c0571da2b557e0dafb143f59eb174fac0e9db4c06025fa3ef74428c8813fc20c6214e4e70a3b06c62af3bb249ca5431b5f06775ad42f482f8360c17dee00fce94b86aba00a5298e7021a624364493ba79b1b92fba1af0490de927117026f8d20281da047eb9fa6c6058fbd28414e69d88fe864fa5685bea8c7d39d47ba0cb939ebe168b1285c9d9f652556a55f21718169b066eed34400cf8ccb193c1bfde529322b37f8aee55d3206fead0e5f4293422d98e27f894d2178023875d76d53ea3a680358b404bc8fedf920174eeeb1b7ff8d7f560378a1f8456a57fc51efd4b770e6e3c7d92bd93340b0656f6813f9b082bdd7729dae13dcdccdebe4d0ab9078c3299ed0b5d2ca43faca076ff60530b9077eee6cdf2f19be48fe1f479f7230f5dbe3785452ba98899b24ec619c8f2d79bfed340949278b8b2572967bd2fb71ea21028ad11e1f07b26538e49e1ae26e82741b226a5023b280d2358bccf435a1a51cac650f58d90ee9e2582cd681c554d6adcb43b406d7248810a62f0de2ffd9ac1431fd7bde2bf07ea952b09db36c6000098512c0f07c6d6beaacb575c273a99b9a976518b7d335d13d7ed7526f3184216d07a7ed81113e6061ebcdd0b43a65c10fb40a78420e52f68bf0add4d6390d961fdb2cbf3e374a5a5f65eab3fdfcbe01fcf111425378338e1fa7ab8871d4be51035b98f6fff42c0d8ecdeb17a16acfe2620b0c9269c20532736fa4804183028ffa0e056b0de5b7518b4fa1fc26402f719a53b5a8291aaf270dc4859bd3184b4d927342468e22b62df2881929c4a6f98daff29846be01a471cb9dd89062f7bb816d2f3005ea90590fd8cd61fe706d2c7b527f34e2c311208d5156735d1ffcff8423f5ee1406c16cf57ecccea16b22277b925c93e7fdb740b25a606f2ecb4132de3c92d6d4e0e01d829857b8a0f6240577a18445192a2642c5654e00185e6f9546daee83dc2c434439a7d5f10fffbc2eec3022b95175fb6ef399ae4f4dd700df8df5a23cf83fccf0ec475fe4c191585fd2b7f9cd34c65a2168accd7ef3d98c488bc4bc82ee3e3e9d25607c8569bf11bc1643fcbf2e38daaa8df177e7aea5b85f55d0f3675e27b884594b5559601fa3b5df0bb56104348ca2d84f6f12c395accbe01ab54c71c6dcf1e2f6afbc4d5bc803bd263112e52d86db9c4fcd996cb48975ee6bf8f8fc024a4320e37da6df33bfa7f3d4608719805c2f4e16aa0fde5fa5d23c7b53d8b2adb85a78199fca413166a384d0f8355f530dfdad54dcaec51806955ed5d3053d100ef70534392e33667e22681d09f9c153d5c10f2cb42ae791f5eacceab71085743782a9d05fb05f600b0d841790aab4bc8fb966fd785a339f01a1ba7d682909421601645ee749df3406c29ee45bc81af38ef0c4200accdc835c57c6f66f9757b980d61de06e70fcc6a38f13cbf5b82b5a04e0f95827bb4886282983b515675f8a66fe470071a98c7bd6f3631aade344dd065721aba4c1bc17a3629461d4b80139f4c136310e3991cc5e2f1572fd339b9a030a177fc90b19edf45c910f7e8f0ddee166a84ddf055252056b862a1bdef78da4fd48f8e1fef9bf16fb859afaa8e175a12c2dbed688a09f5bd7b6768bca51929cb3d980a239419c2c2c2e3abc0e8b8b1c678c514892572275f67b62908df1c1cbb84e9782cba8c328f9bd56ec063dde2ef013d56c0a406d997c706b47bbf10f169684a1b63048406e7f9fd6be43618e4392b09d54891cfd9fd760cb7b19af64bb128f9ed075ed7386f199f528bd45308162d244107d9d02e4d7926adb78a9c7dbc2954abba01bfccd9691959d190f33e65551c6e0f647e7f6ee05f5b3447d3bc5b5f52369510325520a610b037ee99bc209cb655cc09d10421eda81b509e65c1c2a4def1dc1a30c56ad8b2150e4acb1d0cc49ddd0f7fe09e1f36c1a90562a00c4c488586b5dc2ddf1ad5e038c9ec4853d020e2b6515b84cb9c2b1ce484e1d22f2e8634f51231118a03c45784b24c8865f63691e8195489e5c44742488d9b08d9f0160601e0fe8358e073d8cf5f74fb563305086d720631945d795b5f1026f8b35f2064f3658e0aa546153ced26048c156b6ad03ae4859a7d0b32c505afbbd8573a867f0f9680bd47836fc59234bcd884525849870bd5611d6d66bd5f031cd601b4646a38a2e4cf54fce6b9e1bb85077834075d0ee93b9ea6712fc3b11f505da9ddbaa5fda667af6d5e066481ab646a693d9f19cbd363a047ca822493ac5b2cd7f1d05645b4bafbc231cd45800301463b58c397791292874fb3ecd7604c167391ac8b7f8745f048dcb334ec4c914705c1e38ec6345901a5caefad964f10f43c9139b747f98ba175ecefe8488ea44f5f77a6881fbc220e052a690d2ef705c24c82b704150e0c3ea6a3fda7d6b0f70d9d63afb08b945a9611442367f852f837c5b19025d525d7e49b33c2f8751982aab1a58ae62c3858ab8bc8f607f1fd91dda8cda704e97498912298ceb1d6ee49e047465b0719e00486c0ab9f93262be31e55fe44848e764ea1f032ca3c0e1da0fb0c9de91a2a59db229afe3f0b9b020e96657e264c4f04d1be8c973309d965b5f2463a037f458fb7def119f062ca260272c207547e588148767764fb9175a96e143b8dcd9ac6b757d76cf9f4d0bdc2b8a292edde009e7616ffc233af185dbb2e070f002957ebba1dbe1e46a1e6b70b21c34c1ae36808ab8681595f71d88da4613f255b593cd7066b9d8d17371a2dadb7c33697cd179bef9ac16eaee452ac1a932e490d14b389c7fcdbb58e9c8550a4267ee13e667b511f1243c98209f75f34570cfbf5e6eb71c837ef31ba06b60da3e24743c5f22554b6ce5adedc398b0196138fc9c8b05a340536ae6e1499bf8e254a21b007d717a3ae8217dcf34e72cd9678e6daaddff1722833a620f368b9731dcab159ca859ee62a92cdb1ffead405bfa7793c4cfadba3df433830d92caaa43dbd568dc82e859d10185ae376cbfeac876b5d372e3182918122a1d5c5665b7643b119a5d1017df1b692e0b67caa1a1df895d9dfecf26b01e12b1d5ff437f8427ff48aa79e6661bc9682f515b054998c2967f57701e2822b8b0331435f6407ecf5ce82529e76d008c97632da011f8f6095790b1f9cdeebf8b15009c3b262e607cfd6d317ed68035f4bf133e4d65356911dde74f1f5709388b7e2c53b747881926f8ff808a2670a0e6971880d6f7d700986ce77d0ee8f4cfd3da51dbbd727d2a9eb84a70516bd8e3d9bc463b0a24270929b9b5f65e5805cd2b58782dadd3c8d93b970504175134472a62f2804776d5fc1e94ffbcf7a2255940265b53f04800a0fa7f5da42e90e8d84c403d7848b010b038b08be0d32cbd4f750fa52abcf8c5e75f04d4cc0fa9aaf8598123f108c11d1f6121ce43379a494afdf1144b8c699963e94e82d9cbcaa8c3318666ad98f33f0d8bf0af0bf0f74c653830e4b3fa68e331827885102d5096cc63cb51f2301cfbed5494f55f17461d71c83f1bb45f281b8939f970152316fb7a2319df461fb0b1530355b6b881f49328cffedebd7f61b5b8ce9b5a76ac3ef678a17ae276056466b896f727c0d9cc1691ab15553772a9e6d334dfee75ecd1155ea9f154fd2706e4c9b45c310a518af772382167fe4c706f0255d1f43d8cfbdcbe7de0c63a22d929778fed001e46ec9243a7f07f6791b2f3fc4e528d7a153b63cc7815aaa34a5855cfdd3a1fee7c84a8c59fa39d82094888692e899bed32cf0bdf46dcde52c855dcf05b3522d3f1f8cd8c86668d1374083da24b1d5f30fbcd01297bc80901819755ee5bbeccaef3b60b214a252df9f3d69ce3c613f616156649044bec564392ea101eeb978befbe12685b94750dfa921029aac73dfbc0b5ccdd6996d546a600e5ab414164c33c4c53050e33759c4d8ecf685ddfb1a4a28078123f9e61c7a276b7278c195d616d9b5944f2be2957376410bf4927e3836eea544691106df32fea31a0da841e4e4ea4d90b3fb68442b38fe3aadc952c380fb83e92c080ff0c1da0a560b9e3ed2096c54a474a7b3964982818959a166fde9b0fde8609d9b36731b3c2d90e2f931a57daffcf25a40ae027c6040b09628498ae29341efb63b535ccaf936afea8e871fce85a2536ec25c8e67b568e5d5ccb397cfa3282ee56a88fac22f96ee0b634216c7a2cff4d5a420aa127b57ef5d5c7f993af94d0fd813bd431927f94d823b7e5ee468a79bbba1ff42632ed0f48c84db12d3cb4f9d35c53850ebf0048148abc73b9973700589de1a0fd2f5832cfccb5a064457502ff38a3c01c286ecd54069d74bedec47834d452733424374e38aa5a5e2a905348fed0ca8f5cc3358fe7880b72206139e4f8e02c8bd2f0cb7ff1c94a2829acfb86c1b1bb23e924c35d495b49fab790a6a81617fe895bf2f89c2d4873cb0aebda4c8b75fbde1d45cde3b08f9fe4d16ab36336774dfed55f9fe87d0e95940e69d81a29b4c544104cdc640d08e8894d338ab1277999a70d06e8192fc80c8c613c7ac0403240949f31fa2ad1898e7be98abf6030d0012997127ddab7f0c8b0a046758e1d6ddbe7b7b4409a20e278de76983f91dec354a1f5d86ede83d5376fe7bef6f305e5a80611c28538b0b5d4ef976e9776791c7e88c20ab2b1aac0e0be5d3f018b42f73f137900faba6f6982fa5bb2f183ba8dad68adaf1fd11ea77f3f503d953bec58d0ebf028bedbbd18162da291fa7d79c90a0ecca42a5384166b305fbcab25d09a551a7899de71e98b165cc315bf28aa01b45e865dddcefa2656a272c6e9f2513f27cab1f53ad3870eb4e16226911d11f573a7fb6438d5fd99689392bb0cc8fc7f1f11b081104d7642070b936c93a8a12f8a9cba1925a1668d9f5e64a01eb37ab5cc6186eb8bba6eebde3507a315dcbf5c3834129057c164cdfd88ec49669bad192f68d0759dd9cd356ff04cd73925f368a787d43df0c6673e01e3e898fcd839e4c8aaaf59c5e7783ba461100a1053d2ccb258a35a0de890237142c89efc0be548ec86d0cffbe6e01f7367bb78cc539ad52d8e8835a1a142a897341fc569a1aea521c81a95d89b8401200ee2c933399984f25edea6cf1d57a7216226cc99d6b8bbb8a15499edf3549513c41f601a9d6877e9d7b3f1553a0a77e3a595ec04d7ad9968a01d9004f5ec0be3c7539abd4e297b8f21500cc575ce8fd43a91abe891198815a081563651383ff86ba5a2042d86e25805b54b8ce39dceef195572f8727c4b0ecdcf59a5cc3f728e0962226338a3708778811264b8c9d5d5ea0ec49d43f2e9f7f809f48bc8f9ef35a2c6d683eb1b215bb88ca21437f9bdbba91539da174d72760c00938c31a289307fb0b236395c453c2c5ebf6d759c6e386604090a662c1ce03eb41e25741ca6c86e6274ebae2daac075e575d208e0c7541dcb79ec312e05d4bca4fb3c09b54eeae22e5a86c7099531076593033bef72bc47e185aae60f855bb1a06895e39c3ddc71b992446f4694809e563aa7f1dd52478e363513263c331ce376babe97e2def185238f3b0ef97f6374a636e5381ea1cd008138c08a1c9f9ce528e1116d2a800adae6207ba5972d78077e3d5f5ced886f2812488d4657f0b2911956375a88a4d03cea59255402d753e28ce1f2f2c3c2532c451501b8295030d5cb92a422cc80c4026e41b4ac9a085ea173a27fbb4514a0f8e72d6d73161dd96cf60ea8d99169ba46cc24059261d838f416dbd78085b8b6068f280b339421a49ae80aebb6b0f49cd667cb8959c489a9cf7f17e91142294508352f474ffad7d0e2b21c05a1dbfaa9cce3bb3cc30daf27a1fa83269f0133341166bc2b659d2d4d80fb6b1814cfcadc4ab607151f10527d4231406d96cf1090ce0aca6d6f330e01be3440c11e39d3922729028783e9492ca570d1c0df0f7058f9434ea732424aeae5af10e5178bbeed8295b44949ca97380bcde58d68db50080201a594df27a0142a69711723d43378ce2af65e0aa15375d124dab228342f33269c894682121494312e7f08cfeada0d8b8661923dbb6f92b8c23407708076aadbf5a257c5fda6fe8507af5d6bd2a0c891931f3f7af5d29affab17733f72c91db300a12329ce6c392e574c8896fa65651ba09d790cf86a6c90a550a5f049ded5ebbdc4c86df695b482a121bfb966f0e4119e62a645938e7c4244cad7f85f4c3be17378cdde8b8dfa22d4a14510fe9c83b451914ab99645cdce8378d45e454a9252a3065b3fe04a767a541c6c32566fec31bc4c3e533334945e0509ccda9940db3ffe6018368f146ae92701acbdd42145b439fdd1c11c352b7722dd01550303ea420dff8b98a3a7a33fc9d7a2de08ffb81941264b38d94ca2d63b0aef0a14c60dd443d8252928edde5ff0e540cd20cbfaa69b132abe379b211dd518f4f48291e08a5798754540f44936993d7b9cf9a0974de7b6b6e9153ebbc3f575b1719f7c9c9f21e8e8b5ad613e20a79bc74418d87fe5645c56a82e4181df086896aa1cf7c1ccb423a9d30a58dc6f49b03b9fd6c8c86e6ef9c0f5fad30d4cbfb4baa91cd16aead44d05c9e89774d46c7e4c1e6b940018d9c1e5942bb974b569cb21831a3a0e9971a97546eef6eb364c171e0e3e34a90eb29ffd580703cc66bbdcf1d424a808919d8c0fd2b2e5ebfd606eda37d79972a36b9f8452b9cdb00ff4e7ad0efc34fcf4ffc3c77545e5281b672c1cd0c155c4691b4d04a9531470c0f32f7047070e56322cbfa8068c1128b0a66bb69fa204a19e331dd223b957bee87518852c706c30a9cd436b95688d51975b6fa96ca6db704d576cf4977485975f9cc0703dde034503090a882501fe1effbc782c9b7d0e0eea9031d45dcf44b64b9a05fc5ac61f7e2d6df906de472465b8441d6108387048cc42b7cc42fdb75a67548652ee8781bbd09d72c937984a82101b0d1b12fe5c94df3a0889221f504fc4fa107b1760c38660f69209741ee3cf1404b4938db02e309690d69b6c1991efca22db3b1e6e99214c4fac80e4cb478411dbb535554095e4629b6c8b14b1c2cd7901a18a613e28f01f93ab21b5d9a6bead5f56b2e2cf6400e31e1206dd3aa41f39d375d1a7b247fcb7da048400d475bed4e288106da27811dbd7345776e99e01923d9cc615d6282a6940b028f7fc624e97cbc3142f144b807907c23a000f4acf8aefc61b887bb2ee63eb689d9d96e0f2b6a1f3ab88b425f41cd415d3dcdc06399b70cc95363c283355a9fb10e41cc828aba14a65dd94d5743326d47cac0a56793d6eb3b4870b265bff766cd8e80f56542b223f516d9a244030e7fabea2628f00596b522ace4fe9557e81cbfe607d458d80b6fcecb3406204904ef3bdad59eac6f66a45e4621e94c0aeaad66f3a79e057e69a4ea9aedc468c7d159f2044f08dda157bd2ba6e843266c4ebbf78d154c23a733ccaa25ab2ce10e5b878bf0705ce20b6eb148a70b9804ca7d9efda3aeaf108390632a925f1ee0ecf6ca4bf9edd6f9063c00e42d748f80b9e2d45f350bd51a91f3485f2f782d1f2039746ad3a5b2978d132848bc00c15e4570b15c44d90cbc1ebe35eba4d6a6c1c52c74fb03abc93f32ad4d19b876230da1b0c41982ae47fb6287134953db86830e8e2d59c9dbbfc154c68c5dc21ef1aa2b2df5f20c5b3b4c0d0aed947aa68bc73e86ddaee20ad50ff45a75c44bf71d556c12b5514d32c6c257e0f112d5c9c643b2c2d4ffe19b9b3b390ae85928539400e4e30e3bdf4bd702ec0770b70cc28bc8d470df46759345cea75c0966137c24c7b8a6ab732a6a8611d8afd99434c6de11ad3df3a3a07d632d3240f949dc15d3e3b90976f13587a324e1ac9aaab4374d7cf53246df3fa33379b1fc4f521be1fda79319544ebc01c87bc5fc2049e5af551a17c6609f984c35623cabf2bb6b1f778ddaef3759295c0a520ddad79436747fff0fb6d4edb0b71ab4f1c0663d2de5d3296dd94deb7b767f137777b28cec343e140ce670988fa5d050c552ef17f4d17cc6c53caf8e8026f6596ded851cc2c5f1a2bc7a4310efccb40160d5d8952e6029b5dba7199677daa6623176c80fb115156fa3a09317b5cf481a26806ca5d10e14e612c337790c26c4f6ed4fb791a593a7f48f5c7a1da48e3423bde1b5f7ba29b7e8a6530615be79e76850c1af693b178e69231534518b62ea91b5142ea862be4b898695c0e0b58b9e5552c5a8486bf425b02c636378e6230d19e7f117a4a7e04496b7d925470594fba5fd57a6f6a8cb685895d7469e74665d247b1d68107560ede8d8f81a4f887aebc7bba87bf31695960eb5748e9052e398c4df42f39412ab1aad895be75c8232c6b93e164fc9ccd377048b2d0515adb9da6941ba937edab63c02bc493765ec42919501ae2e239d393fe270a830c3a921b177b1bdefd609e7f1c76ba15e949e668d1d96ac38ecbac84c075f18aa10ffa5e43b6f934f6191065cd6290156a216216820ce9af444afec39ac2524e64ce26a67f950114b130243995c3b65068cc28be5aa3942c34f4c8dc0245d4dc43529be7f5c1a9c8afa7a844f31a9bf3344ea8bdbfd2ea9be4aedb9dccaf0c0a3ecd9fcd1fdab727bf6ccfd78db3f82ca877bd8a5ac59a8014a81af40f2718090db3b9099f925426351801407a150718ce68b1412d556aa6eb939e8c3f1e684f5019d260defadd68279d119dc248e923bd406e9b552024954fd151b0107db61f92a124edeed64632417aa815ac60ddc6cfb62e8be7b8432b5a35528d18f9842c71874f1990fd11ab83e1234d138b8336eb36a06cd9d42031e0921f155735b79696794e6b5c28bab4971b2df641558386f35fc0dd364c719844fcceddd1458d6822f0004857c7f6e896fbde0871342d99d51ae8467def069967dbc89336d9f647b609721445f31ea60c1107a2fce7c8bf6d153d9cf60928fc70de1878356261782a29507baa242f907da29aebd21b04158148351b5fdc00e6d6ee845c3f225f736dde6cc1cf5d24fdea0cd0a8b0747703424ab6adc7f9426777dfce5a92af70e4c340230751f373c85a22a9dba268ab2f7af86db431803cf94f2a37e9c61ffd8a1a42a3b8c30532a74bc8d5124e41a9855affe4b9017cdfc4434ee9a1aa2d3f7ffb90ddb25d0169df9615632e1162e3f3632ccecde494b25ba1e70c0fd9111eaaf1652aead856897234cf6d3a2db8a937572e1008cc2c9b390ba43a9e10e71d714e6ecbb1941b44a742dfe9b6e06e9a35daa09eabf0f2d5c49d7f41b98f68f902175a50fedca7a1cc29dd9a6b87cee186edb714a04bcb4bf7862b289803158a9a995b45e5fad7a266b3798757eb0dce7205da84d40f4e3a4cf33de0f7ca54d96313d0aaf6f1f19cc2980f894af0df0d3f0734d3ffae81c623243","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
