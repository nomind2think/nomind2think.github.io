<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8abc02f306185262de42af150b647c71abd34ef3945034ee323283889aaef05e9336a5c91c1afe2e2d28fa1157dcc30acb564c2275ca1dd334c36b645900b8b7770ebb2715f4e6296759293a42d94fff8dbc309dc8e2b9f08d9f2f1e321e4dbf35872e2728ca4bdca938df1d1521b7a0607bb86934a30e17d53cc2ab1a913333fc3aac6760de1bcaf90501e3b7f3230acbfc0f42e8de78afa9ca8f5e08ba890fd60fc763c3a20142ca352c11e22eb9eac722262162af132b6159bd145ac45c1f1ad8948054b97e7373c2d34e7e261ef0f9e124cc7ac748c91256a9fb6c6e808985b6ae1a12d76c52900506887efc750e534e4df3f3f35da3413199eb80854213403d7b6bb958260adea234c45bfb5ead154892bcf1acdb564a9b119e7b75a6449cc2685fa58a860532108faa41621470e1c83f8debc81bf43802deaa680e19ff6cea075770bb2eefd9143b0c31889c48af9b55c6df25a1b3de507c654e5ecd875635ed53805e74bd19a6d9e26ca43982edfafbaff5c9ce98cbfbc7623984390e408ea6c161b0866ae24b3488322dbb68bafbcbeda6fe30f0d87bf1234f0bd97d190f7d22792ee59e62bba43a718df1b6b385828be36b2674994028d8498fde993f3c4b1b2185a4478390116a28e629bc6b96eccf382db3b334dc658969037b77b5cfbe593f2cc3970cfc028ec699e480c10d362d5568ad225387169e6110e2ebccca207a6f1a58d0d7928d2077333c9ab1d72927282a08e5226f55e33768bbe9290f6183c6b98f3f2f35af9043cc1d751b2403a6eb6c9b60d089b80f02e933bb2f37c6d9463bb40c7ecb302f221750d520eeb41367d11e428bc76cdefd182aee749874f911ebef3e5f79e2bcc4bd87c60fdd3c0ac5b8d94642faea30b77d35b04b47a3d1a5d54ecd728e8e5c0a970d5f933a7ccea9b2dec081463ff16a09d8e0b74c2012b7789061144fbdd4220d5de7e08370f2e21fb8eea89298e24a170a02b30fd226e2044422c9f5c49e85436eded508e5f7327cf8784f13cf320cfe24bec456e4d17973f39407fcf6fb55eeb833fff4158f72df38c432c4610273d4c3d8be272401f4ff23062feb5dc74faa18cfce16c8c08b193f48704274bc4f08b5cab52bb0c7ac60daa2c942db5929c005105a8d532e889ef26417032786599b36fc0485d5e77c533809b18969028f25ed6746f4f0a69d88c75a01d2617e271c78f9da311cecc0d2550928b353f1730123c21711c437c99df88ba93f101c13a95f39e6454d8a44526b73f7f51d2c35f112a7a75b48570078609d6849924d5cf543306669686fe5faf7d3757e4b7bca4235a40fa608d074026b755d9f36ea44ac557cf33d5f4f12fd7ea9bfe5e78e0a033a2bfc7dd75bd077950dc75c7e6ad3306abb84713ed175affcfce5b36b2d65673e55d3702384e8ecc0e1c0163e021eb88a94bed61c4923c76c2caaacd1a518811999acfdb29f6506d8f69ea125e7aec7ba066dc4a72e5eba93d29cfd4e5835c570930dbd9d28cf74516c67a4015cbae025da6719718b1da83e152fb9cbe6f22679ddc80984c3d23fc1c8b7cf8c61e09567d3b0431cc4e484dd2c5f069bbfaa4b882566b9848e0d0d34873680ae62a2973ce9c40ea1a7d2e5ac2b0a5d202724f3f7e5ce2e2ff8ecc50b17c042107eb2a9b9513e36e8cb50e90962e293c93eff1da58c47d18cbcd2010cd2546e43ef5d4be651f4c8c18580cdee80a3e3eefcda1de804479e4093ca6670480717ce67ce5a42bd54cc4c62c6ce257c32a3f25e1d66ff6462e7170eaf2290a021d81c2651a43c22d2cd4a0a6469e34371f192baa0fd5dd68091a17a2b6af8322ae50fddc49bfd65c3d672b2a62ae191360e010eb1615dc16d36cdd23270ab29a007baa71e29e8f83fa58c577e8245efdf3fafafb6e9a686938bda2af73039462bc3d546d6f6c1cb46462f57f4fe031fdd8cedafd0d4c839613a7dd0abb4fde9004e2a66ddad8db6ebd3709992451a9aa8e141edfe5ad2993f53513826200973eb1cfa5c3ea4e853c4d653f6f716858c2130a53cdc7c7572eabe71525a667b987ce3d979fc6718c3209da55fabbcc68f734db6da8874fffe91d539209f1dda365b06293c2a7c15dae4ceeab535a68a78515c41e27b2c903c21ad9e754ae3eed2877a86e4518e1070c976972d5cbc93ce317084ff8872f491ef66e235bf6b09f001169b200cc9e6813b88b906e0efbd11652b2e68219f09e629bd363a6b27dcb0d2dad60094288799ce21c8da87dc51bd0fffa41397aedc67c44d3d0412fc2c2a331c7abfcf528ceb4ae8ebcd7ccd595a2394745ed5a373330c9b14c500b57d1061d69baae2e15560745b77542bce3a2124176e81de0061c7467c1c4b5271a895bc0a86a68e84b70683c02e94eb3ffc669447a7965ce063e64d954cdc4ab0d3efcce24bb23d3818b06f62b9d2f3ecff009c258c42ac4516fa4838f56ea71d0093196376493690c97de385bc77f6b5e4e16db5ce58807ded0f9d25b31085cac4e09bd16076ad3468db01a784310a5baaff1bf150fe4de618ad733458a6c19897ae125b0c51372bc9dcc9bd1761a0d3ac208a3c532c87664cbb25bae5dfc50b5602168236a16bd9c7f7deeedb12f8ca3367b06f4e605be0735c4af54ca6213a443677e40935cad0b229a9bed30389621423788464937b3d6704ca87a693224d3bb131639af28303f76f586a14d7175f9eb5585e731afeb66fd6d28c83142aa26c40597bc4f211ca66e3df8b69bda5775a9a8a416bc7e52fb68c277a9b0adc6ced1ef984e95f0bd85cda4195cbca817153590a053a0e1babf5b4f0b6f6b9b89f7c774d7630c7ee873a654fa22e6720f6ba603f1bfee90525626920e29f3ca063d1192a84ec9f30456aa1192939ecc5b1d92619f5d92d9fcefe486c52ee75752a441674b2295f9d0a8278b6b1be483c58c142b0b00abadd53428920f9d5d983e8d7c3f84b3289de12e7d5ac01bd5644672bd784d1e1d3ba0e611aed973dd3c8680361c8afe40beb4d5b36435f8dfa9f1da65a2a6fcbe21d31f102eb904c9403a427e2166dbb36bf23bf5f8d67a5b7725c5d506765d53b3847e68d9d53d403de85dc4a5cafa335941e1563e0122d58852652e20556386be33c8461a3f12393cfa057b69f47e088183ea94b835c239282a295cf6852be29d2e5ffad360e4c3239bc164ebe21b212ed35121e6ac73cf719938a3fece8c08bc1075c8a4f32e935d943d683260d05885376e3d1744df1bc6885dbb8063330de5390b2f2ea73075d978c10d3d3c20cc1ff53814072b5bb021ff3077bf7b8b425c24ab8a3a85e421bcd35ee2b256934e3434c602fd1051e8af5e3970c2d7862f77d9c83296cf09e8a709ac52d3c746850a2278575f7890870241b150dd33746d96d67ed467192f4958929d3861c2d247ddfd2e69adc19909a47e6097d0750f1b602715fd1524f839b82875c2f1f9855aca5f7df26303b812b06d0ac13597a8662ea4ce378b733d61a7c06dbec3acf618cb9b543d8bbe245b27bcbeb3f531383ebb1e3fb71bde8f18fe4eac3cd90bebd8ab63ffe717e959d1838ebb96c457aee231bd2186f0ebae103dd279ed3ba9f8798a08a7abf863f7bce1d608782a668606872fc5595983a63eed4e1404b0f4c9c7be70a1fe128d2f0a0d303f5043de0f5ee04c7cedeae6cb46f1700f4a3235acd7f547f62bca16fff291841dda73dda7313f16e89982ac6eb5beb3e79c725631944baffe1556b428330b08b9c682f2c7553e3083cf9772561fb96389a6f1236ca5f38e98437807e5ff0b0b02f0817e49a9b0ec042c2f3de817bcd257b74a90428206dfe86544f4a778c2f3ca6a81073c92903cf4bdcb654519859033ee74c6241992496a279a9d4c1934bb3be7ad6325dd5335cdfbe61230b95325f10972b8325b4434612c9dee4f3eba141529e6f5dd1f16ac4b80ec7d409ae6ac80465f6bcf19dd39f0110543f47c936afc98dbf14def69e9b908a0602344922e14dbcca54694fac3466148425899a03d8cddb671c8b89b952ad7881eb7f49975b53d49e0113364f5fa53c6d95be24182b9e4b60ba8c8563172072c7057c03c332fcab85f794c4f314c4fdaac338b22fa223223eda05a7b1cb0a0d904eaf8ded710db3328e7f8ca31345d95669a8d37ba34803ec38d6399c0d039bdc49f6b4dfe26c3e5403f21708d1ff9117e56671bf2dd034e19abc8547abfc2c8d2f0936f0215d1818a295076627cc3a9334728d1700c7f8342c32a0be02043b44c442406bc47b8de872d9f8a044d49272035612cf5a06c4d93345f8cfbf50a5f59d9a916ef334bd66f9083d6681a467762154d8ab27fbdc5910bdeeac45bee94ebdbf82ba6d3bc0f6da0d4668c0c590024dadb2e1d3d45f9b1689d4dd9560ab49c47dccd3ae15f31dc29bf1eac53b5bf88d16b5e548ce176f400c192bb98b038c7317e5d77137f161b3dfbf129a3f51e5e5cabdd44e09b8939c8d1e22a91b51bce448be159edc282e23bd338085c5c504c7c036677209af5134c15f355c0def16af040325f4f408d503c76a2f768fd56ccb06643bb1abf057da5cac97a96feb8bad8db0dcb9d4a05521031e9841403a291e9cc1517542d0f79338227b2e7b2a3b6289156bff13c3b91e862495c78a8e4df8f1f4c06e6950efcf279e0dcaeed1432e03d83dce0065976d37cf8c7f4a35a2c65cdc48bcedf9939a534f8ec64c52b7efc73d100e6a16e533b012f1ab9cebb12eb25dc6bf1f501a65050a827c78a1b1fc83c43382d78a577f79dd40bfc2f37739f39e0300c1e073875d84947922f1f1eaf93cb944934abf21218bfbb4f7063b72565a86b21affa4a1a5c68fb7f5601baf94f82ae5e6c47a323371a69ec9d69d0225e00afb5dfe010564dc6a0a9afe1f864d7f5be16701e470e8b772a77cd8d026eb24ceac25ec042bcb2628e9de1b1d5d463605858a0be330b10a2b8d99d0f059c08d2dafa00a2962ae2d896380356a61458febd61b35e96c59889dbb1c71c2a23a789c94ec115ec944257360044e13c26afda7c696e67fea33fcba6a7f2e1813f146fdde38bbfb3b5fac65df723569ad9ba27fe6dae70283f8db2144eea62111aef69bb583144e98f9895a42f9532cc274511cd546cb78db18a30f57d6f9a29eb90987f23c227f37694645b0f174caafe292b64a8633b21487bb4e2fd25c8e0b1cd086517e4e7149b4af320f24a81b0da8787f193d2f9a3e39887b82773dd42f1700e39d17da2b5eb76eb644e852551f4f7efcabd7f349bd500e6ba757c7505df1cc9c72583f7cf006ab1fa9674f5d4c850d38aa4dfc16434d7c1fc551276d657f1efe6b9812f4e8aa17ed8978b777cf800fb26b8d6b20d1047b1a068bfbd9cb8b833a36555134ca3baf0f14753b8cc26dafab1e84d07aff1b7ba4819e2b0bcdf1e0edc7e4b42f5f0322f7ea937ec10fd2921ce0d9b1d7bfafe6412f951d60793457b0a6f286beaf508c3c32870bd134e67a25f64f98c3e75b64c89455764cd19a02bb9052cf05de7844df73592ce81d78f199a165ec5c9f80885c3998f263cf57686790d802bcef76f1a80ce44c5c9159f2ab56c79a153aaf6d3dfa50a3631405fffc696024d04f360bc82b0f83626a8875137bae7ccce5670f13993e50deb2c5b3e9b8427d3d112e39ab3d4e486890720d2c42786c6d5dfb8b0919653a92a90a6c85988ab9c1b3c1afc2152a4b33e976fff3ca8a178ca9bdcfa4502a0686ca74ac8f04b3ca1a0f262e56ddbe67706377df7dbb837d947d6660f3d09870626abd592175aed9a9923d7b4459bab84e82fb34cfe657fa06f3f0692b07cb7177eb79a7c268dd1dadc6f7cad5c3a9a69a7348194b1345589e79ba3de6894b58a0ccb89fb877b3ca935c1a5264c6ac3bc6b2eb73339709bcdee69b3c3969afbebeba23e36d94f2ae191d82e5abcab6bdc463acbd7b05e6c2215ae04594987f0cb2d0c2b21c531ec2e84b9257e0edee9c8b662425ee31d9bbe9fb46e6f147b83250f4e260218c814b8f752f98d183a919e9bdef6ced4348f7cc33b0040209cee0e627b47606752ea03d6ad548ad281ad7ac929690dbf4288b2a67a8da1e0c94fb17762321d2799f642578ca8e1e99ea7a87fa4b6dc05f01ae9b5f4c13e226bf32f14e2a9b36ec0849c0a1cabe863d1036432b8bc5f4b2b3668bfc44ab75575513eef15190dd8c523740a291c3cb28b4278dcee8298b44128da7e1d4049c37d315b414f2a7ae58530097b357421454f1e63d2d6bf9cb9e54911715d0997ba9d510c890f5436d176747cec1b2beff9d91d00965b34b5692aaf6183d0282e5f425d729ccc0aa0cd5430f4d322e5003ca057bbbdcd11c6dd167f17ddcb46af24a78aeba570d59300926ef568bb35dfb92b6168bc06d3f5188ce83923f028c02bf2756dadddf794714d578f26a03d11232b2106d78e9d4cc830bf038ae724d642fab6a60720af171817a7a6a833988e4ec8daf77fe992370e145a2cfa221222fba4100b0f6e9472d06717f59b102e6edc2a956242ff449a5ff98fb6e28297a4e0c12793270705b66f7dafc4c26095efd0845dfa089e376b4d397c5d6a33a6b03fe72611bfcd25acf256767288edc0b53f7bbb98b770a1ad1d469b7389c8a62dec3474ba0e1c320ee10d9fb1b948ad6e7cb23b2a0eb4724ba49fec46ee0602663861981fe9a5f5247fd833e78e652c9fc7a6dde74fe5302d8a739ced665219c44a5488783a550b3e407ec493a56f41c2ca563c8ac0e3a5347300104eaf57f99a8587a297b5bef8392245c15d48677ee56ac4c58d6020777b6def9887d87108c4fa37c2afad6e80f2564ce640d12f5e7c4d4b3707edc22ac065b24722922950c7f82b68a098aa282002cb11bb58ff9500d3745ead7bbd39d9096187814530a239654db576e848cb80e90b339acd8e22eaa5ab63d5e69ec87b23a209e8c627c8ec7c1a3e1e24898c458c9945027f756eccbba07aa29c14317da23a57e15abb00ab535badd4c677d4ad8a60fefbfea324d45fa99609c9269ba450dd087da2234cf7c3878230d64e0e61f20ea76ae5fcfe0df5a46799ed2931c7104c70c95b0a69c993b9c10d79a938674d815ba12afbf3e7c18472449c08900311077e84553b5a90c87e05b6be35aa26cb28e333361e915746840940f17e056330a7d010fc21bdc021b062dfd4e826e26ff62671356362dad8ba0bb5177a493b8c2e60867173aaccad0fa39c84165b2c8551601e0de08c90764960728078d3bae63ec7f0098c99149415df1b737818734b003b9622808375fae9fcc799afa87d9791f22a701e5c1a655652edf0a68e82ba39650d66a5774c8bb2ab2102c262a68da176b94886a13d13b099e763de543d66da95be6ecea4e90f570d53e1082bf4b1602b5a346bae48fcbde37ef5fe77147aa1fc4c326ea3a8afa6a843f38fe0c2d0cbf9066949181d551012680f436982fa640ca869a5cfa44fe16cdffff9a647e9da83c6c295075837f9661ef3e2096f1abcaab685a1ccdef544e9a3316133da5f17068ba315b657b575f21469928b50053b9ae43d333a83c5da3cfee177582752865a1ef7ba53b5cd04506816b72c2fb7bd86fa5f92f467cf4dddb2341a408e89030a2a3297d55b8955679a2b046a91dc5ea93fdce95a677cbed2136edd804c2e4408d7832e73206d3f270a6aced01f8ce8ab0040a20c7cb66ae9af3c103da33a41cada4ffc5e5b5be2c8f1d2a429f64721d16121c8a74b8b13605b72aaed7cff671c5cd39cd0ba1e6b26ea79e10e3d844849b7ac5bd1621592e643434c561caf27c09510d159a06c001c6ec3663c0ef327bb7b0454e72c3d10783239f272f9770182d910aba561b90003a0ce17ae05520bee1b2384840e01983776ee79c4f26006fc72d0bd81aee91cd3eeb3a84e6503a3dbd8b4d3a03bf40662054ca1d8f829e632beb33f509e78fbe1d29362b2cd124d730bce8d46bce0b1ca9b12259255feb0ff1d7ec2e25d199f85fed9e32e6969048d7aabb6ee87ad28abb3fa4613ab27a3a8190754ae946d0582249740abe83d6e10ffcbe18b57fd8d3d91647fcea9775665d7efc11f5e966a9ae69aebd70ffa6d0dd6837c18736a470370cca1debad2d6b5de129e54d608afcb7f3b866692f821cea321174e4e476b84811d86f206a3403608401114f30302c04f8561784e9f3b5440ca13d8c5a32df7f4e10dec79640931d871dbdaaa125fccbc0e16a019f14b88483c76e52c1fcebc9a3abe61bc2f43b73939d044d38b53577f539daf65e1208f0e3d6e15880581ec6cff0979b86d8ea5e2c2eaa669de46accebb4b31789d62971a391f41b8bf805cf46a3b76c6d90a4fccd609cd1b04b294a7149cc3d910af030005a936ff17859b50358e5be659f01b782e2aada1a326ac905436ae0df3e25c1ec3a2170847517d49bfa8cb53e15e275813ecd6e5de7ae424c85555d2b69a2de8a487a8b0ed14472713445c84ecd69b02d0fd64b58dee75dda821ef5096a2e0635d5c3a0cf3c1c41a2803277beb87509d6dab2fa0515d6108a63549826e50d2afb0a9ece8381d529f0ae5bb1a651ab5f2353b489a9a52d20b9e256c7416443b07c0bb1492429a22dd15694628ffe140283dbb46553a75ac3fa94143039a757cd89503515294b4aa16f9a24579ffd18259cb206ec4fc6446362cbba1d062ca1c712ee693296a60812bec1ee8128f5aa34c27a6d5c1ee91ba5794558b16c650b2dd372cedf1be3e6df6c150ff2b0215f860b62e6d11030d5af4b9cfb8cfc34681f64467c3b9a8418e4f396a0431bc5cdbe889e88d19100eb42fb716998ca916651534fab27b778cf5de07b8eec2608e6096ef87215b1a9e4e06d52fd54f426984cf4bc86bb6f0b3c2f01938c16555581ad1b119491d508b2ccd506c615233e27ba601022953fc9dcf81f66b541ec9bc6da2f2fbdbc383cccb3646b004936f6a74647f407d20f8cb8ab7f243fa146163b1a4d2dca0b0bba9cdd40a15fa986a3eff3d529b2e1d78c39e9ee2d0abe4d15e87aa710476386ffc7f39f27ef086e37245903342de57fa6ea6a4ff3936362cab3411287321891b26f211b082e56bb94565e6ef0cb25193ccf2ca867d4700e2e6688e5640b4a634a8643fe43f74a14b6ddfea90a3f52df6a9c8d822f1e017178f83d681fcb76c56e8f738dca493df44ea40d8e22fcb25a211705b73f14e56ce26a95ced13ff4cca8f0b53d3a04449e19289a9629e8d6d663e1a5302195ff3943fb1b2d001017d7e9a24c73fc117192237d9e9c9632e531a305a1a5dae48c2c67198c1596a1a9a4ab9b6be7e2d374180ec12f1ca8aa5d60e2a71b9c7f7613164415a00f9b103afb6088b3a0492ea709a8e5acc6f413b31e1674fed0e994b0f6f0fa4f74668569a6f868c8b221e912056e603d8c3d569400f376be973427b2023378542924a68845f194b1a31dd90a6d8e13279616cbce44dd57ade2c90931811b65d3deec6dcc0bd5ff543f157659e58719779b71da7264a43e40fac7e5466a9d4634492755b40ac7df82853ecdc52123aad75836f2fa609f0c2d5cd2ab0eacb37ceba7d7e01c304cd191d41cf647472823658b1da648e4bee7a6ad24e83804d5b09499848e62366e305bbc7b4284f7abd16712a1523d850fc655b887337ee2caec3e72d93b1c33ba29e330a0443c2410e227ae17494fd13e3d5fe245877312a6b07964a3ab82b669830b95d28bf3e57e1bac4652f3e60d6a40844c64501c1917fa8231a314a777fa3dbcf653185690fb92181fa2bcdb9cc5c720619cedefca17d0aca0c3272a1dc309dcebd94618322b018db2948855592f38fa","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
