<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ee5fd409b90b1740d3d07ebe46793f4332a6505cee26bea852877f57ad88f35d5114cb5ba520c52db56ef7ebf68baf6530af90d91a4e65dad5644fb91bccc7a34e0e7ca942fa9391631b252a77d95d44bf1019d0278ef1e28b21019ba034d86075608f065a70e13e9b44f53a7a03c9f50efd3ea1a4f35bfd58c345fad5f8ff995347f89f3af36e1db375195d6523829d0205813cec430e75a84bd7dccf7cae12c4593c1d5eaa044cf91085d6c121d257c438230ab3a6891856f24d2df8975a485e4c79abc66b65f2a2033d75f4f0fb9709a812b7ee9c7c6f3a3e86de028ff9437e4450c9d088a970afab73917e4b2265b648cd151dcf85b30b1ee1d1af0e0ebee41733555d8754c4108f9b6784129f66b1da5f9d7fa81a4fab7203aeb7d67d1a448669b4ba431d2c99a4d75e4c6cc3b78051dcc32fac715465443c757b59a77f06819380275b39210403049a3e8db8fd55fa11dbcdf1f60abbc05789a87e3d5ade15011dc08e6203f6120542c5f89669d2ec892a92c108a32f140719f09a58c3ecd65c7c3a1bf7666034453f55b26ce8bff67aecab804c2e22def53e4658c80edca3b27cda1f420388fdec382736983364e6373a6f7b291a73f171ceadb9a84c607c866f645644c71215572ee4bbfb886923e4e0448fd917d562ec641c38ed66147b0cd8f5303e200bd8b5cbc03d0d9fe98562738c0174ff8991a4948938613de226dd343b471179c555314b9c3a7544a00781beea7511f2533d6301f731c248a04ada54391d53306d876f94ec48b3347a2028ea350804a605c9ae55bf01fcf341dd93717e8ca859be0010680bb7723c7ed9b70e191401e863718e228b2352d1c847eb075a768e18289f9bd778d083334f2c596a37ea5eaa09bcfa0c09a75c83e5809679824aa08a604d7af725bae7cf4b1ff0d93852d471abf5a76d2761cc372d277b7bb8f00a268e763232f44328c994a242388a39e4dded3f75d98eafdf26254093d32aa0f13b1442f698f691237d2d31590878d14c27a1396eb3237a3abe7c846ecf209761cfcc63eb1f998d341e731230574587f71216b3e4211b41e56dbe8eda26b872a15a96d9acb9cb800e5cb8ad28f8a2054a83f0a33ce50ac9f0203722c9970b1a4c87ce607ce33904ddd0a34802f1ea2db99910783fb19d1cbe493e0d548a0a050bf9cb21e56b52e7bc7f30f4f1af3f237353f3e738e34627c79d91a11841989bcf8a68001957748beb0b1e205e12f90d66e168268dabf7967ce5fa59fa6860a3c17917bafb8f4a4b43ef09f8ec96d8bbfa133a4dba8b43bf73532c5ab86b11cf92f1b44343f08b62a38674b8968288b01e11ebadf7750b03aa224fd89a628c6021865266a09724065b38b5d46c4a72e7e17a41508fbb307b9b0c9cc29666493dca4498019ce0953dc55b8909b69ddd7e4ef24beed35e4dd21275a863c2d8d3870056cd581dbbfc83b2a751056f9e22154817360af716f23557e69b90aacd4acfaaf28a123db4ae50ea0d812604dc1ec6cc457d9a09cba06888380b3da7537884c530a929b8130e459010060a4823508504a3b5196376fb1c9f2e8b18b9ee482bc76b678849742bb3ec5306cc5fdd23692912b83615d4e1f3517dc46268f8741420df55ee42ccbe3469d2d1bcdc574a7fd2ad03b2d6e4adefeff614db21834f1dd6850844fcba8b9d940d58fa0fc8e966d28d65a01ab8e757afba81db2d1af007bfac840b33fde6637a8110046dff7a4733fec1cd0cca0988a64c6cea67406b9df3e84663815853c9a0700be89e1202a2ade92887ada1ca5be671526f374ecc623bbe22d50bbb2fb13606e5a0c3cef91000f88d92635ab37ace3bfab4703366fd8e22030a1d3ac8a7a83e3482d7df72f33d5925a4a11026d9862bcddd2865f9aaaa72a9ec4c4b9edd01e9cacaae0a94f79d111c140d8c6d352c38f5d2398aa1810a0fffcbd6aeaf7736c749dd2a8d6af8942d262153c1097d2b29931ce9cf435a80ba90df3705033cf9ad4383aa0ad8ec7066c808d421fb7baa15a58118df230a58d724f7028367ffecff52a714af2a8c45bc195affa7d935bebdfde4798931a79743c884e711525c1fe0885429c38a5e5b32a73ad04602affdc40a6a122f8e662c1cd16df8a43b125e96f3f59980aec075f130f1a469046ae489e9baf84f6dc4bdd7c951fad68abb9b701ccbeeacd386b306c1ba33ef767a63281969dbafe2ea2edbe14d5bfc50725fe66d0275e4522a8b6b321062fa0a61a3123230372e80b985b87926c6e6a72abe5b165d591aa29311e4d1f3d80b57f9b4bed12557e123c559f456e3ac5e4140574fb89753476a586f9f895bb383b34c5486c5ff4d764f5ac497a1a5110a4c26af5f7a3acb0d9d241430254fcaf8b5cf3ce08d5ac3201a1a50051e6651096d7effdec671b73172ce731c56e62338a296802b3d0b040480fdaedb13298347eeccbb9170342468316a5397343a281b1e9e29ac99c00c17dc32668a87fe3e64765dd25a1c5a954689f47e4a47a7c56862fee0af232d9c4462f41a4fcfaf7d70f221eee642895ae87fb14c42aa9e77eddaffe0c0578fed1a537f3b44fb3e14d933550318e6fd53fe01a9e8347d897baaad4d1436cc0ea884faeadb17539e95131e1201b5528ad7a487f3c26f98afa7fe5d89b4bf1b6bbbb06d7f91e708c252efe81964e2d91024da4a8c0a536179bba3d0d7d3ece9360a69bf35c0c2f3baccafca9c7103d750c0331e257b431c1ae8f19bff6728a2e1a5a465d9573ac948be0699b62a19dbc5cd2a04c520413e4a9dbef0117855e377b3884b3120433a39b95b5d5216970b3547df07aa6e9c842ff58c56ab8a74b46546995545ad205a8eda97161d9dee68d1c6ee8375ad9b4c36246a442baee76d500533f82357d92c308a9e58f37872ceaa8d63e17a2f88cd7d4be11fad65050c89b3e46d4ae84220538cf71dbc96c32042be3575db14f257c0bec742e5bec65581163d4bac5a5bbb1db54a2ffe334aa86ab2fe51b50aef4403a1646837b9532bb3f6c6d91143cf37a24df619965c7b74a0dfbd8e83fb510d35d06855e98ea2a1139c8fae8b719108bf160bf56733bbbb7c1bd667c6d91339c252dbca81e0b3928b570f10ec1ed8647d874907a595301d2b9af16a63b5bb61c476d25f4236b1e5e63656e13a8c1c3517a71c1f765f2147f4a214bb1c4ccf4de8b3b14c1548f8e22e9224c9fb20c91a0c5a7d34b4e66cf440591eeb794d5c034eb78a7372a46605d84c53fea6e3ebd4353b939a0ca6f69813cd57260ced8100019aa8e74d4359bf4ae48cf92e6a87b8b8bb045a39f8606a9e5ed020fec77b50f74f757db2ada3cb69d102e5a44279f7b59a320ff60c5e8470817a7de9b192aac93f82efbec92dea343a536688b324c76fb0a15747d5ca9b694298a4e7a467fdfdcdd11941fd5a6fb30b182e59683cc3475b6706aacd6ab3463339fb4851e1d08862e9b891dda5376b913cf82718ed37380bddff42b3f79d42ed84796c4b01fcbc8fe5f00f6f1465db12671830e64ebb923373f14d144ce994b02a0991d6a8ddfb5af88f419a20b37795f472521ac0bdf609a6e3a4c59ab30d14a3fd9d12113c980b9e6d4e938bdeb1a4638578b51a828362c0270112ee1e280f3306e31c0050e6d886fe61ba88ee8109bbe419277a34771a03d77ce34cf344cfc1e82e27c81d03a4aba20476148640851a9830cc11a0ec908e2a662bbc8ce9e5c4235a55a170d79b1016a02c2b87713f0bd88830d6adab45ec7fb58af9a3eed459336c9e87981d3b2aa9877ddf8597c9d0c4b5dc3f6426f9ee5a9e5d24a1907ff150efda9461ffccf55a11e9c107e6df790c827b128e0032fd6650f009336a45edb416d7a21b1438e64c197c186db60fa396c68f60f11cda97478e99b4a63b4cd17053d04e8912cdf0704cb6b83d7f1299b6c4af363cdc9579635809bd39aef0a359363a3d19efb3cf4c508e2c9581354ffef34afb96205cdaf6f6680307ba632086dd6c36e559683fd98e90e813e3b078255dc842d8a8009b1af04ebe63d24fba3e78bcc6a0e4941df0590cf32e53b5675df22d2b2003bf0e799c093c7409de32dc833226926790ead9c0a3739e9c4ba421cbf16e1fa2e40c9db16ba7bfff12c947992a90973cf35d436bde02eeb392ddfba381dec6fa6d7e85cc3970ad52bc2bdd25f37a38db63a2c7c02f501f2f2bec6438c0c7771ae39203d6e47fa21fa3f967ded6f8df637bca2e419d4f4576176a921becc78540cdbe3bdd5c472d68319b67ded8ea08d6c5d1505724f382d2530622b0ff6d4cdadd7215bbbfbbd1d019bfd487882754cc4d89a2ab992e1a0c3048738a8979e5c5920b02845f28d3c87346c79092db9b015e55f4085616646308dbedb5cfa2463f91ebaebac5a5e00fb9a3b356894c5cd09964e1f937bb44fb9ada88cde7e9558307e9f6d8c1dcadbfac42da6bfaf9ab66817002b40b5c4c58db2a5cddf2a83722f370d9458b0c918da0c30eeed4be0f47236c795146f31dbf1e4fc3e23f78be337c214df63ecdff49011e3223d2cf55d5136fa9ca0e4462811d17ac2ba8d79f6b325e1d41ea43c3d4cd11f5385a0ed128df02a6c9f8e2d58b7391684d4b8e65be654570af9c35f5d18606f6f53616b59a91e602167a471f8074eaff61a46b950e832696972ac1d35edc8eaeaf06ec11f8680ad7222bf7f9c5335a2d535066f58624b7f897696fabb90d2133cd3cc87987f622634d6baec73d19054d5895fa423d878ee61a947585b71e5fc5c0b63390134b48bc7969aa5a4137069c72440b6df10e928897cefe26fda07251dab7e56ae5e52b1c52a87724e16f00d0cf33bec1f6b3a840113ffbd5003a3479ac493e318e163323bbbc7554f7ba9b50598020ed526c566eb3f35ddfe6df78b0a06cfebf413b084794d1a46d33e6b290d1cea62c48b869d9d949d53783eb4bb2804bf061bbdf71b9d8678c648aac35552c4c57621b53466a62cb6e52211d9ecdd1bb2374a07a36ca0b71f34382ab6f6a4120835be4a517bae009f7e4cde41a16addeec01636f0fbcca3a974477e43620dadb946021dc56b2083e33f7543748c7305ad8e0c9764cf90c846c5f2604063a1cbbf5d59800541771b6ba93b535865e84c588c7d3598a86a73ff0c5612e2cab493cc88f171ef5df0c41873fa8d9faabae9432e566f2fd948c77eb2663e183de4525b643e88634c7cc3fcbf8b1b9797f25acae8a78d82bc1fb419099ed22674c33685faec895cba2d71e43b48226016313ba43e7dd5e26520f9a83f0496b11642e31880267959e9e3a72b92e4c4427861ada1c79482aee28e7906e33e44d356439ba961b268b86bde3977693c76c3e1cf51df9ada69c6c5a9c913956f31ee08ee76311f33f581ce0a7b2809b3da5c8e891a6a52b7ebf91a281805e31df80c1a1f5eddfac04215d7f7765fc21d5820d60a8d182b934ecab874a0e5c75eb67cce6b15bbf3a913f9781d2f0190c07dd7fbe6c7cfc3d51274ed778f74b68033703f18cd619c93d8ee2191b8992fce2af76748a15f618bf303ffc87195c12f1cba4fb9b9ee5fc18c2984e0232ff67cb20ce548373a3cec3b5f1ea538d194f542a728a70e9be1783fd3d28b2bd3204377990cc70452d0fd573ebebb9d024f2dfa0e4ec5a743e3bf164de3e7a551e81b32f9b7b60569b1506963461a5f4a82d67cc47d4d7884c6b141ee6f48c39b3c65a68e3688e29e932e12fc1de5e737b54de26781bb2e394ca3fdf83839007285f9be35864f9aa3ae5f8c277b83eb29a97c75c77bd72db726d5c9c88cb86f5485ac4bbbba0c5203d9e89e60f5a72372cfadef86050e2fe0c392e37f8f83d235ca7604e5bd7dc21af56e240227df7a144f03ba994fc4ff9ddbfb7ec335c5a4d5c618b0494eb0d7abd4270d6c8ad9aa19be22138a4634188ac0d573a457c22fbd306f8e7f76bd344ee611b9df020e1a0ce06d71415a418ecafb8b76d051d2870c1571ec4cc7b4ce7c503ddbfeb438ecdf9b4a055efa80e002938c4cafe3ea080d7eaec716e83399d032e2e82ed371f8feafffe99a83a3db9c098ee706b3dcc59004746c2a26154f4d043fc78572217f808650d827b54f034a8cec6a2325db24eb5e27477f5722aff70ff13200b5b42b7324465c93a03f2a78da369b0d63a4db351d7681922435b0bd24af40113b6055d1518a23081392aa38f4f3818f0602d81769ba55df6f2e97011ec00a9563636f6bc3d0ed2523b8f76c061508bed0cc4f5084377651779bb77059ce1d92b7166e54e7695a0ed663830dd607adb8d17e8d9044757add26a3d84a1af9098c65fffe644e1aadd80925ce71abb24f09796ff83dc9dcc6db11df4cd500174509e8430f065dda040e1b13916f19245c38c6eeae39fd66272e0330bf1a9297e197cd13f0e4524f022616462cf54f322b3c65d4dc3766a29134983683eb5e8cae612b76adb3f6eabb9c585f8303ce09d7980824d8555f8fa3767f39fe65f74d807d696d632a05930833d63541bcd2cac3ccb4999e7177ed61bb624301ce4bab4d394ac4b1b91272a66eba5055861e6f88dd18f9e4a89fabd60284e8c771c2b6275d9f73188195752dc5c21ec98b18450178d07956fb6024eb5fd0d968eec78d9de0ad91f0aacce9ed25707043763037d0f3fa9edc01c8292d269dac70da27a67367feea8760808593eb6d5dbeca4168071dd40128b2518efb60d91c30cf935ef56057d3fc1bdecf56968c59637856dde2b6c577304d55a7aca9fa1ea9f2c86054ed5503ddfd0f30501c039bb27add2b61cc8286b0d96e51763060e373481de57514ff462cf782d715bcc2d499b6885f089bdcabd08c2c9992b872ff69dac464bf3a0ab92407ccdc219d820eff57516913555ffa161a6f85da0f55cbc35e3937a727aed1ffa1165314f3dbee64c283b104cf5ad8a1ee3ccb25811ee2e9b2588c3e87735e2feb98c3e9ab584c9603a69243a095317e149edd4d8c6b84e57c620c290f997d9253f7bcea1ffc2542126c5ad129062115d8e74a8f1866ca6a8cbf092f037dfe041e5428f48205547905f6ed58cc9339537a4c4407a737a9288d7cba135270924ee532f3596ca1340b9b26fa0b9e10002e447e1a2290242b05f2f0ca5e139655e7633a6899b6699a2de953c4a57c612fa5dc1257cafa1937091f582f10cf88d975261acaa216b7d22ae91ebcde13edcbeb517dfdeeb683c2c78bd725d762edd1b72190ec6927b84d7ff0a70b9cc4a21608a03f69c0112eaaa43f342bfa9119f39b8ac4dc7d1810044025f678b25d451b756d973d91b6ed22314153e070439f8c32938962692caceb2876ebd5971463827ad2f6d524ae3d117a183eca14ed33fd5759d368140e40d4a61f77d8cdfbc27d4b73c84cf5a9a5027f1256313f4b89c32835adb0ee4265e792e34e2a7016911a60bd0cf1357a0963670927bc9edd0eac7c24978ecc79cba4bf12d10938038e12db7b57ca0b8113b6d1656b09ca2611384526a3737ef7c8caba4be398cb14f83702c178d26b24fc59f4bb55a3280a421def2c4155e7a9089240968a90ffd8c0a82a7a2af0d76fff7dc14ae5d1e53ebbf85e060e4ccf09c0e3be5a5bec219845e77e073fc6a0b990e6c21a4ec122dccadf8f3a816efaf931950ef30b74b57bcd089960bb6f95ba21b4ee2dee4fc185b452afbfae35d8d129492a462922659151677209f0d70ae0b1457b704da4204aeb4541df5c44463c67af11704e6ad0a305afe620067671eccb32dfb36e081b3d6362af1c1fdf432bd1f36b258b7e8995557e2990e2bd254a21878beb8e5f7d0b4a5c5f0dfa624e02bd5000b1250c60d80251152155bba7e73dff1eff3ab1472e75a7ac44ded080f033516c83c80422f411262c2a8461495513b8e2346abdd2a19908abe31d0a5eb2f4c0f75d3d15eec3b1692aff53d33c433df00db73ae887efe214c8628ff78071879d09613e11db0ab23ae10961390241d4b1d40fa26cb042e7c951e3b33a415f33a512ac7316b8740cd2dc596ac2cd7578bf07bc06e4441992538a65f07c90cbc49a1805eab007f4a3b32f384e1db2a3853971ceced4bc6e8cacff3c302d5fdbdcc3337f8f6813bf28873818cfe3082c8f666c71ee27ce67ce20901ddd0a98d8519164a758c65a610de0582c0499ce95c23abf26041787d6e2be5d11882d7b7e6cb709aa19d024c9f0f6e8893ee886b619a5bf90f5c04319ce73f9ab2add92fce540775483cabecd075eda07d6ab7692a1b357ec4708ea7fc9783109f25db1da24baa05551b8f624b5ac4b73f812f6f0f7efa156658e2fccc9301a70f7fb31d6142412f4af39c6bae5faf1a54dac69d0f4e0adaec9fdd57aa4402eda7c892d29f2ec503813e466c1b902a80221807f1270adc817d3f811c2c621ae644565e96ae33c38c163386c55766c51dc4f4a10a6515e68c90aaaddc1e7f6c438c41f29f535ef8c635268e784866b642db2188aa4ea1478385943d87a046437a80bac96e0c91b70926e859b60e4491a8e8d847ce3947115ab145bd44df20ebecc2395ea07e2e37ec49b2f3b3e8bd5949a94f6899703e807b41cd0dd06a5d9189b4694ed6b313f38fe5ada5d50a3d6e40c610047a3c6160147c18e20245005add7455e8ba13233f711e5b00336592fcddb8448f59d2c4e3bf821c342968d8f449491c453e5fe2f0642118c62b84eeb61db07b207a6a663312d2e938e222d76bb2675aa0356aad504e84dbb56e51ee634d67d54e864eb2f3c34366bb9fc7d7f3bb71b23797e306103886260e7b30fa2cde3955d4debf9e0ff9550f9c47638e4ac87b12d986b7dd5e4fd104ee0f996bf822fc1b669b25b52c76f09f758947d176771ecaad7266e5080db363864a4d6796a805827ec452200ea9e3360336e2253baf84511fd88f8d70c9ed4d3b60f3ef58bfdc908eb945e851e213f4694c12d111cb605c710474f489e39e685ecdd6a3f39cce679fa15824b728864486e20642642880f21b124a6222c30714d641fe4502752090a913f3040d35bf4ed4bfdd8896b5007f1047894718db4dd0e42c1d976f264d2f78aee5ca5e733475aac7d14a0e4e728dc1ff0e544cdd50c87dfe1e94814801549ff759173cfbbfc379a10e8ddd1cc4c04c63366ed3d1adc1806c520404d34201ecf41b2efb1cd510f1fef01f95593f1f96bd5996d24690fb8cb7832dd1cc735a9717cb4b07171ea1131a5e507ee4404ff66606ccd6a00898c330212ab5a5ee352bcc1900625d6bf4d5d23bfdec4aa78ba54bf6480c0cd9bc80c795b91f83b5d714586db9be3fcd9b75f167b67b7e713445fc99b3cbd02f34a1eb94cf8c9f4833acb74358a6b58a9336161ef58e8295b3a12e4a380bf1e0ac325baa31cd344a0d6d58340fc11a13253669bc0c7875bc13331b91cb4791a8a632e96ebfda2f628866ee091990ff7cfc202a0e063743cad7875dae069b695fdc10aa70aef5cf45823438b61e22e7719e2e4f565168a81a8c52c1d4b26bab5841ce77f4248f7c44b41282cbbb250d2c1648d9015767a5f0d6ebb27bc03b111f587a58e506684414c796ab3ec27c2b7aaf9eacdd096cb18449c078178f1fabced28f9a49e72a6dca9463791b57ac9be93b42004fb2542d5289bab42955d6a84cddc59cbb95076e6aa4537b75360817658792987d4658ef14899cfc14604d66ee128286bff8003e2653ee30ab97da08d30e7acee7a88842e84ecd15eeddeccccb9b376c124d3218c8a71ba9f2984bddd4fe9be5bcb7e9583fb9165a538ca4df5c428fe5b8803ae53a3721b104e0e90f3c138cbbf20fd233d0109c60b9614a99d24bb5a37f838421bebf192bc35819dc4c241e2c121a7661912bcc6e83fbcc9497531c70665ba62f2f8869ffe81a3525a2185a8882f5872ae70463713b1eb901ac9bd6753984da7f1cb0f522a2847cddeb9bf4cb66d66af3ae52b399ea712c63c8b3e7c5460571401ec377dbfbdeb6916b2d6ce811156f1c0a19068b9acd23275896bc558a1fb01b33765e07562fe8fe9afb674e7744d13ba991a8a8513ae05d169f33e91a5a1fe79a661510a10ef4495676be0eb2208bd7607d1d6abbc4103eaa03eb0b16da4a36c4514b98019dc72f5d158d0b5a3651e628e9a0d319393107b0ec65f228a3449e3955a7bda3eeb1086ac1d605ca882cb424118335889a24995bca1278dc2d7824ae731f1cd3cfb64b273409f3e76141c52b812fa64afcd05927bca9712180d1b5ea572933e4e29742ae483b601a357796477408ae3b98b830ffbfe9a8d95878b333a7118778c176acb735d15c25928efcb5dc6c31013602b2c112164b809e0be8c9bf085dbfe4d2d4a7e9ea3dcba62df659aba740df5c5dfd0e73c0cc2b661293b0436d3a8d4cd97d7de3ca166088abd47c9270679172071d0814f23ec6eb4230cdffeb30ed76aee4480644689da14c064c28fe300080d9fd0a94afd8dc32f7801bee26129a567d8ff6138747d914d559b6d9092ba7dd4bac05ae170ef01f5c51c70b0d367bf22f13ea99638e5b2aa4795d90148a8970da5aab0e576e9ce3999490739501dd5e5c441b008018009f468049d15db95ae1775d65f80ee5e31e0e2b62e27451e4f78435ccd55b1a9c197f3f758477593d0f7db307151816dcd721e017d75a6c014368b602860fea6b2f11473da5ab91c305198c200ca9bac2bb0c1f0c121e06801a5ff1bfaf59628decd85e1dfdca3430098aed0aa8c40a25f05fa323400788283ef61d91fe1a8ef061e91982816b27aedb53081df04a5adcabe066c2b42ea1f5eacd542dab06bf09af0f205391f92294839a63116a2f30824fa6fb6714f77200d7bd73ce5c9f56940a61fb8c5579e9fafb35e25ba668a8e7e163fb3d03f79885f40ef61d798259cded9b812ae3bd635b13ae3f0523634760f09f52f09139704ace14c21c9b78c35b8ecfdd1dd874b5bb94ab1932bd0855fd56645474ea13c42957282b988698705732cb83f7c39f8c0cf4961c875ef579ac4755daea70499cbe62dde6deba881ea830881ef9ec497dad6950f5d6471584f69a7ef50cc1079dbd26f68bde82161692b725b2eb29020757e32ef934d1f650adebf4290e112d0801a2f58dfbe20a0f8d252f268fee86332e33b35683572faf80b676e2514231d5ae3e5015076ccc459bd900758b3e4a08aa8603b846d0b0d62e776c6ab0b60cb966e23631286cc4b5d5815a20e1dcdffdf9620f1268659c1b0cd52a5a58eeb743ec62a2a701cb94ecec98b40c9d10065ee0e495f895f458eaa2a583afc5a6c4004face4396d1b404efa409a3d1388cabce1a763cacb49294c440c471ea248643a88c328da9c1bf6961b788cea014322b104ef8b24c20d510b48e715e28759cfddc0c7eb5b4839f63f8da0e602acbf22bfab20e68d01ebd7366a5a6cb9eb0fea5132a39a0839d58662fcda3f8979e681b79d55b4804e261a9bbc1d9775bcc4659012d8adb7008a451ad1b60b872b4f12ae8e0b203d6ebd6a797cb9f6b4c5abca0dcd33c8d38c38215fddab638d7a16c5803d270b566c2b122febecd82ba873435b074f017a8db792e384d48e40fbd00f36ff5bda76171a427e148cd5adc514bd1503497f03eb0b4411c71e05553e4e1056f2473204e703496be2bc43376cbfd00e360c1316132d4dd01075562488223dd058331c9b3220f751e04d224beff6eaeda41cffbc312912a2dfacf6e4e3201ccf3fa1f8604aa1abfb1214b6a15b85dbc3191893a26aa564bb65243af44768564d6c51346b8a7ca8ce91b79687b8bcd760bb3112ce4ac7a5878d9134f1776ac2e103b430808799714b896f4d860a7f382640b0dcec27ca82ab17a58427aa95798610bb2b0eb08208c2de1f5677f1ad9649925baa92234e46d7774f0ac484be9b16f04515c12afb914da4a8273daf21af12a960da351c84fef8ae2277b5e9fbc7593a1e1e233c0430584bf21c110dad3921310c37b5913540c7f7ecb66c4db4b02ef67a8dd812d91f6a779a575ea9950174dc8acd0a833b30223ee2efe7e9f412ad2fb6ee4aedc36afaeb1bcf2530dd8f7bda79a537b16acd67dc9e3c344740ee70a780317b8b9cd7794a65c3beb70c5ce4ef06a790c06fa916e25db7705ea86fdc61a747b80e41994c750f856f62cbf3f02955f9b3acd73a59670abe55f8cd20c2181bc9ceded99b5e18760aca716fff469531c97767178f8d6b7c140b034f2a18b339f1de8cf41e4968416e70ca7e9a465a32f55af0773ae04e7d77c20f15b97b18c032d6afc5e26ef2a5a653753eff8dc005dd072974803a0c97071676089b8c0f7147fc5711aef14b410541700c8ee9590a400ec6fc2c1e334dd810caa58117a5f63bbbff7c2c6543bf24170dd4363e1a74cf93a18b0441f087119d0e0bdd31044863301b46f838f8c54116d1cc7dcf3b14e965dd3f815fc94e0f396da5ed42446d37d3ddbd1f65475f3263087dfcc0ae20b1e8df088d4262b6b91b0faa235aaab6bbf01aba137c0614a0ddb8788542b06ee8ac529f8990e68ad369e85bc0f7710864984a427a968624c828e8ffbbef8aaa7796c34d9399a0732f49fc571b5840adce65d06e93965e4706a6e3efa6f97a47dd4700264a8ff32dcc51d92878f6b0396d2498b28c644e1c0a4eca97dadead960478ecb4ba6dc723530cd79f080d650ffe71efb4d4025c73643d07037a97ee4f115012fe230d3ecc909b218fb9b866ef07bd31f3b1beb82f931ef022b87142de2885a16f03f20b8d55268cead3da2f2521876a093e3ef2f4168736358edd2abe9dc84bf7435cea0371f2388959749dea0cf89f43de455e85908fe1c13ce156a63c9dc5f5aed4320d4332adf9b8c70cf5353d46d33cc7d5dad2f283c1dbd5d2374a3d8b1ca39faa22193c951456dd761396fb6ac1b1f3219c366d12277629c3233f6f21045bcc2d23fb81ece86e0dc20dd960f0fd716ddf2daff487fbb5460e3ce0aa7dd80037d7d84a805c23ddd5fb56248e3c29df784a7803dd3a97dc0b06bb3ec3ebdee7b51d003a8a9182b36f9c925b6372f24a139cdda279e5e54b559f8bc53e8b5c5409dd721717216d3b664aaae104d993ad3c54630972147c1229993631e347b58159620ddde1f4a823caf1bdf2b860e6866d0b6f7ecd449a048c0ac6b24a3aae6ac4455617b02ea79604c7c634568f433af8e3f65dd98f2bcdeddf4b633539ffb6361bd1b3bfcd0dee82c4a9561e9626517270923d2be523a303c9f1179a9202d7ea6efd8b3494cab0e26dea65015f8f651304f1086c75b815011595299ab809867ce2e38e5369d8e56449f9f31af45f23c170627a375a5c446da3e6377b494b2ef491d66e07c2268324641a6ac0d232fc52690c0bede0d9d0e94fbc501476c423e7413eb1ab4112f4db36ab768e64a69e5e748f334aa7fdddea716505598fee90ee496517ef726114799855f93c54c9cc79a2db45d2705fa0a6f28dfde6c766fce7352d4fcb39ac6c0ec34014744ad32eb1c7c88b59f1264f741bf6b31e354b0da001331db41ff59935194e0850fdfaf793641d3ef9191053700a5013725c41e02ccf6fc7d0c31fbecb474c4bc24ae2abe978bae4b7ec731271e5005665f1928c9fc5687eda4718aa5fbc17738d84fedd5dd59bcc41740ebfe255b0288fbd29f43a9839f3389fccf785413ec0cec8d9cdb83bcfd4aa2186e131a4149590eb8e886d84ca6010423c1d2da49c1ac47f834cde90730a6121fd35437b25fdcc53525b9223215192106ff577b985346f58aeb5056781e624fdf263b1fa8a1755842576543efe9316b48a0714f1d1b1f6493ae3cedc6b4369016c7a4789ff216b1f29d474b4ae085eca6e965240b35daccdf556a368f30db76c16623694ff7d14c9a9b7dabd5760e00b34d7d5212c2092de52473d7e04433568f702307353d3c0e79c95d870c6dc24719c7110a3507779cc98a110e513fdc0ba126b09732f92716745bdf917f91776796482cdbb2d026d9300478998dbd489dce265381d7d9f5634b711b83498c4154d5999252a577f6667280882ee3f5056368eafbe1773644555950e02e9cf424e7a375cd9a1be82c7d9559de3978d720835c65ebe0e4b9e7ac501156e644ca7d5775abc0a822d2df11b817f96f049c152b1b8d63f73693b1e0949e6c63cec510874f5cc8458799934bcae8b6d13ea67522524dfa7bdba68debd6815f3ea4b23ea0baff4a412036e5896b5a24fff25eb0765125761d8bf19d79db4ed3c939f356cdf51492082d60791e75eadab6f86f016063ab4523e3aff728a60637cf18c8f2c5dc55bd8fc6908caaa54867aa41a32b74d1a4c2b9f3bfb28286a5a30d2671e7474919f6277a7916457caa9ee48ea769208d6ede84a98e5f2ef9c5e062c794ccdf7d9b3155bc26410020397c75d00f612c4a768c9b33b6b7b0786758ea87fb2cb24f6b25f47ed49021ec9c15f4deea9478738ec6d555cd096bd4c67f388abde6ea61c1db5de7375363c4513bbc66dd965ac3a111f0d37caf1fbbd4634d209e5541ee4cf9f72b473ed659d8f223f033e635937f93e7b1d92510a271d081c986b36e5e4e3c773195a312757c560f20214728f50f4a935c636fac94451162df0b89753a9b5e18000304dabc569087230d505c9d2e5bf16df9c984dcaaebbfd19b8275c5231a07d696cc57cb929c0cda7749cabf2ef5c9e8df8e85dd94aa42c2c60539afc2b575439e0a9cd24645fc83c32e182b59b9b4faee4c53bb2bcf90b6d280721e7e54dcc55da858b2b062ab32aff931cdc91502b6e9fffcc5b7374b828d6480efbdf468d2ecba0bc245869d5496939da622a9f990cf55c679e65a0fe29c8c3dde082c97d1e5d1281a9c6da604dd70b1ae4e020d0703176141a230f7d4b191ec92f567923eb57ed54c0e60202702afa03aed563f538c3750967c4ff7e857353b232362251a75b30be9f71a9d8ce46812fa3744af203ae9d2283edb3522b9f818b25369bd2e8ac9124508ef86c5d76d9f58971ad0b2bdaf7f13f7ca7adfb31ea7300709bdd93b8e61638a8c173779dd1bb883f92fde1d44e0278ec55ce43b73871c61dbfa5d453c7de1c55f780c94e12a4f919fb2f34e84f085bfa5a4500f27db19368bd74b6552fd50ec0750ac198c7f157ff7046d5648df051eef684dba3f9e9d5889019693e92f0098da6e36c44438c2e0a00824cb48a11f73ce9a76509cd92519634cee446973d3d2b3cf4a7ade0a3df2e9576b4333b381645b4d55361edd2879b3e7d17fa82a7e3339322a4689e035b232be0e91ed80473b90966f4eee161aacf34c4a013696273bc1ed29683b182a94d31d78de84b1089c2f70fa7c67694329823550bdc4943adb33ee15665abb69d546dd687b417c563c35a40056185b5471aff8933ca6068f6b0a43bd97dab29101631615e3a374e99879ef2f69cb694b8da9e14d3657c9efa893fe38e5b3793bdf93d7be5f2d159c0033862585e060bf5634c98978f3b7ec3024c5813e91cb6e7bf0d37ec04730d759fc3f1f7d7508c30085b8a404241a09e9d9d2b9c1c14f4e717e4f7be06e3d73cc5fab2aad065f8a526c0eed3fdaa365c146c7db40c930190ec9fb8c2637727002d4252d0ccf8afe4ca7f01acad3c09b921bdde03b65be19d82226a0191beb01b66655e86578ee3f1f6a0a1413ccec2551eba1b1ef838e5cc8d9f922bd1fa8ef8ec64defdac660335f12eb76dd9b0384cfadc905f702cdf35f352f5e8598495420274198ea3825b838e9e9b831112b871159b8bf02f950ef5562bc95153e965b529ed3f22203f1a017529f9b9050909dbad5b398987948f6eba77a325a1a03e1b674defe9fca145c06e523c111597d1edfb4c6808529a29356c4d4f8270fccceb37170935922f6caa777dc8d4d0c2d04508b321b20f4744a0d09a02cf57d2e3f1d8beac63fedab2af847384ed3b8adf099ecf55a421166c3f43d61e9f315f23d06ae839a607ecb1e1757ed1f0430422806207f9f5d76a6afbfd7cca0bd35932817146998a3f9c4c25763d3d101947d1c70280682dd9f1f67ed228c1fd6ea5597127abe7b18805ca8960a1b915b6342db3325c3ae95a78f056531d4b615ddab176cabd3770cb72169fdd511530a8ff414046ef90273558bbbc4a270540f9b41e980f84a43700eae5ccb06417a11010f77661525cdcb1d9e9ed0e42e50a3e55d352f587be8c89770706c330e7c41b334b0973dcd86a030f5855bfae73afa216fad2ca2dc1a2e4831e96fbec60da4689ae0ab1a72bfcf7b85d41df27467205712ab0b70ad3b0f4d1c1376e616f0665bae13ac57a3472e78ce668f3ba1e160e228f238311ee86398e6dbfd14a7ba7fb02e44852b9ca5332ca273085153d62ae81f8e64ec83532018a5794d7f7dab51bcba9609f1d54420365f03c4bc194749b7dd5bd87b69a2238223529d018dbd572b7466e13c8971e9d79951b480b97cf139c76ecbda02fc1f9f516409d0c91a0517ee76c313694f5dbb12bbe508f9203ffe3e2ae586a55262d789447fc97e8bc14d289bbe28de568dd672721d93776f08efa88b3c8cee885eb5d39c0f5f7974b662c79cee18d0a0f8d4f2bc6372835953a89ff5b801c60185be324fb1e886e34e5305869845f2009d29e2542e0382f2a4d525f642e9c3299df02a4afcb588134e68dd3e444fca0acfb828b4fa3045f4906411d46ea5104847413cd193a143bce56ef0ec9c82bbed24d0c28d0f9f6c7e84be71b4a478777952804756074cb0278b614e5eb5c0fd803ca1d10c863054d63f3e340a7879c89f5e0ee571e3da467cbd5acb64419fabb6eb7cbe9215c2da8ba97bbd2f391c546c500d91a8e1ee59dfe74f5a41f7b9f4c66efdefc151c4ce2aad57c4638f6ffbe9379f7b06aca77a82b3831bc92baf2fcec36e31a993847daaec4ad97e98a4c8a9f19b573d4fec4dedb2e509bfec4d2300964f8d1666660158d2d426bff6d65084cb0a4af4e33a91b444cac4be9e467b11e7d29816374f30799d99deb145f222e690ed71a10076a23d7569bd70c1150ae2a0392f74534625c12a03c97622984f35f23cd81abd30ae5cce73f9b3413cd982ed25e1b3511054280c272b3a2b064046f4d5f98490ecb3ef440fef939756e6c2fe207a7d018a59cbc94613e5aee16998964f8dc6534a7e778c1950ddfb69871a259c56374795cf36d6d47e719c496c5fc3f25b1d221dfbf9e10f7e15872b67911ba444109e700da30d8db5680bf856150c174be389a95413e7054c1d6b2678b2c8e97c174bae15aae34400ad650e0348ef007103e6cd764e602012d1c329cb411e8775bbddf6026da061ad8ed061b74b5504658a9c6c836f5cec11bbbb882c63f5ef6d4f8fb2ee1eb5ac19df65fef0c2d6632c7f10efa29acca490c1829f80f34f8cdd6700fa46f4ffdf2574136845f7a3d58afd57a71e2395aa656afbaab1f1d00f802e9191451af4753c7486997f4c6e5a6da442e898e26dc8512f7fb6542b3cf33859534cfa81fd7b3c12f12b80221f72e463d0e9798e5992f42e2770ee6753ac6ef6c9ffc25795d00c337dfd7e8108efeb351034d2d0ed0bb638f2b154572279e9e7698cfdb8ab634fdfa261ceed3936419e821f400b866576f3b886f7a3aab70ea2471eb52cde2d55df955cc122eac9d78287c72c8f59d96a4a8f176ac2ceba3b959c1ec77d11b726040ffb822901b7bff470853b650b0f263a4f3dc281ce46306f855adaccda8d676b7487fa1eac738a9ca80bf1a9ed201bc20ec7caba9e364332111c384a105a0ff71427b5d2ba91c1","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
