<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e53f7fed2300d3f5a740fad723f9413833f441fe03ef30c983370bd8ccada9741ffeb10a094d18d7939c1cdbcaa7f1c3cd498ff44aeaa3f8762a328f5235e3dc3ae933e15c18f86a8e559a029051d99516c4038e45c27df4cf8831900679f8bc43df7b60e33c3c760b960eac615d63761df9483a6b5caff4b8cff67b24d37d1df2d08fde80c59253d8eeb07538705df5cd3f6c64404a7b531a08eda836cc39f76ab05bd7da9fbfeb2fdf2d196274e78676b23ec89cef2a7f520a4b8767bbca920c98661c5f88b3391c8cf15018a2a27a9a4be01f8b389862bea859a62b14db29aa4c3866254d440d499483751f5dfd393dc1e43b50a1ca7ef44154110d5f023cdf207c214d78a3afeefc2c3847e5ee0ccdd5e964ec741e398cff04bfc8513946e70cd2287582a454f1bf02030253bc8a7e088112ab32a18ace8a42c0e1eed07617989006403c0db7319893a7336a84d3939a866c3502b9e423fdaed93c5720627fdc8e5bba6c42b108809e6537b40c67afd185e97df565f3e8e75579d81096cfea95286de1ea68eb90107658fd5f316ae32f31d167a3dfbfeaad95e98e49f217bc0cb6d1704926d96024a94fbae19f18ab60bb7a6af49382167d6876e4b4258df70082406018c275ab18bedce6af77a6de330a71ed042441018e99db7536a0aeb6db89661076e68e57a94420d35433aadba6f199702f680baab1ddc6448fec8f4f7cc03966c6dc1e1fc40f66d7b37c65ceb9f365ce704c2a44b6d724de1ede1e679144a1ea4edd8508ae7b133e81c7a00e51fc83c5de0f9af314ca23490c21cd3d8319069b7896b6967501e439ed6740a862cf041295e4a56b013ff47ca8a681320b9681c4531081e013206099fd37188dd1bfb51746cc9c69bdfd77dc760a36b9c16ea89123e9be28ef857eff7b7d480da3e3a8d501fd07a2f84e96b78c8f98a1f5fe13879e09bfa6dff2066878c61bb992756378a98a3f402d196cf40dfc2d8a7bebcdc9f352e7c78f1b866de79a37e3098a6f444435b74da5f8732b5cf432d69b50a8be0318124019e899963a42f1dbdee38e45797f690667b40e1384995cafdcaf58ad7f5f61019b232b8d56d34b83fec939a6dde5eb300c36dcf55302dcd7265403c67c4b4fa1e68ff54804a8cd45312d73cf29bc5d7d37551f28a8c3243882c36e6c97f6ffe3372cffeb8d079bc5711d74870a1bad443c1a17812ee622d82af25d5a43b3ac143b2fcad8f8c98d2c3de7d89cf467eda46059873d28cadf07631c6cfb4288d8725c813abe8590cd7efee7e2f970c09b0f3de07ad270c47f2440a56bb2a69dddcad4de20575a0db1a68bb94b881af4cb39a288f4573ef26bcc6c8897124d2fafcbc28ad9c9fcc3c12c944400d5aed63c30fe3d8bc8ae36bf5ae4f5a978dc546bdabb1b692bf3cbcb96387a82326782806586124a10c4fc366bfd4b432856020a0da7ff01fcff593808c3317dc7534e578aa46fbdca240645c485f7951cf3aa7d5fb93f8c8f8b1802b0de11daf06e99b7294b80c6eb111e706209be2b9f09369a5972d79b893fd73ad88cf20088e129486b6a2a515cba81fa37d12cbcbd04909c786f25dec928684cec88bf5f1f0c272e17ef5758708a474ff81c26845c7f9724d127b214928910d6321b928e906929cea2c5ec53d69753255539210ffb7235353bb62490e5ced7a99f897f6174045af5d9d751809c3e13599c5fa5376d3671578b0ee1a8e98bce70113f1d3cbec2993f928804f4022df55cf9aa440157272f7d39a403307a6d47ad14aeea2a28d693af9e7796f225914016b3941b421a9d5023a46b9594442162d3fc2c7d9543a9845620128cfa41ad3fdd46ef09aa300a1fc5c7643012e3f3c4addd21997af87544aa8d63afe63178f92e3adba2d48898f890472126560c2a3a05d32eb4e3e02862d4d43c5167f60e368d6a1c6d3f11f31c5c22a7078f3cdc388d1557c26174a27409a1e9900d0923edebf1080131773c1411e82c92b10f1e7eef8d4f9877d20379bf088972853221c3713fd116fffd1a5ebe934f90c2d3a7daf590d11d4cfad1994bec802c8ae24b2c2b4a00a06c4bd3e2c5051e62b5bb3c437cdc94700b6551378e5d78e874ac516f181272a0b4436366df3ef1b64852b2fa9b4531d3eb4c5c269a3034debc4837e68c2c9daa5c472ba74fd2518c4bd83a84f1ec33a38abc733152fac9ab5c3e46dadcfeb327525bee12c515ea324c0a9dda3e05c8a4997abadaa04ae683186f145133b4de738cbb3d750ddb0d511eea4fde6352d3e705502cf3216815f12e6eb6f52fbe58630ce4620afd879ba30177297984295926b6f9c1e55fa8a176303bf9cc1b57557820d055288b8df245b36429a56f3f1db39ad146df952aab1492943f4ad75bb7922e6c44e7ed0566beb6440c75af8d419acf5890d9b9d0fca8304bfbda038bf6605c9129f2a1ba75a23d0def13018593aaf35baad3e973780604acd386bf464c3670dfb096b640086bce01aff6400635feb70caa9e5e63cb6b551158a24b00c134b43bd21d9db6deec93b04c9ff2413e4a8b330958f2bdb04ac9e9d40dc1ffbf55f6fe2f511e57372933ac6f0c7f6d7a6e907c98b41cf79d0afbd78a9d007bc84001a07285f48ae6068d65adaec5c0aa2f646b93186ca8a7b86124840488eef3838d9be633ade75c8aae76c976a07f93c8aaeb877ad91a7fbbbafdf1634fa447dbb5547697283eaa3899a18d5bb4d3414888a9db420025ec5904fe3f2c7dcfe10e0727aada955054fb458d567a3a25a5ccb0d428181f233da6217b2539a689de2c54150888452670acdf157b466a60a825c519cf80c263c12545e50505ccedb5e39b2dc26e8dd2eb4588b6df2348d6443ecb0ce14f511ec6b811242997cc855337aaa2f6e17f71016aedce948dfce09490613b804d9d3b73b01475167e72967ae86f8bad228824872750904aefad64a5c02c8f2427c725630c065243c042255461c81357d495ad101413f9f437d0d58b1a36ba484bf33a79f2f4150eae37bbfceef3e1ce3eb46b55873482c187d4822ce49ce425864e37ea8009de2edc87337bf20ef8d492808fe344a1d87964abcaa02bbcb18976a76f472e738b90b1df3892acccfe58cea7a73c7bb2c02809e67abdb18b367f169e5d4c8d61fa02450f5b739b53dc3d21979b11a587482eac5c38327b88874a182882642bb0a8e76cc01a4b3ddf15f3777aec316792f01c16ba158f61b51c0d28db0a6e78a3e6bfb69728430d29cc018d444fe9d11c1d80be50bd327651797d2ea18fef8a15259828d7c3b673e79511630592e77c31fdf1b74eafada48928c0a3e1b256d30c6630dbfa3e2c1570128812ee1b7ad8855adfc1348f01a22850b995d1fbacac8c74181b06820dbf6b53c708bea2899f435b4a169c3d5928cbb08e81160df32953b002932cf82f4d1a8977868ee4742b50d07d6a51555f03307909156b4c64071cb7d47643e84ad6b12f0792eb40aff40544546b03b219e02f16b6a3e9d29c6fe6b830a6b43dc205449a5935cabc6202caf50f3462e713e6cd9e5e96803e2d44673199df2feb9ef526098411f2a2d916059cdf5ed77aab77c41488cd9d1e68d261721e64be1083df45dc14a1a334f67fe106e96abea859395193e5891e2dbd5142ead2cf5f8ff6fc400925ed1a0890c9336c22706c70d041c0c662e3f6ff810dce3f34556ce971719efbaf0b5f09b3e4a170bcb47cd31cb50203f579bb46c497a02d7a1f5be42e492ca7494ca690b359255de17bd5f89dd366b682d4203649e3a8aed925896bf375ae29e59aa52ac9f75741b747983a1fc5d0584610379eb0d8557a99414c89b7d459f98008cde000164eb821eb4dfb27c8c1372ca83c13f7cbbdc3c1477722881757f7ede313a32f73be3a91d47712301630e242334877709a846d269fd89deccdc5cc486c09c2378c25d5de30bbdf3b1eefacf6beaacc6b512e1301fe07373933a2bc89c89c24d94ef5526f4f6177ecceaddf0bddf3787a0e028b4b6e06a5a7a3c0f7b80ec4cf3b1295f4960849afabff7c601c5e34d8949dfa08718dadc5c7ab5a76dcced2476642ad5d6ab17d5a863484db70ea69bffd1d51a53ec98c754a6e395e077c752d74498533acd7092210641cf6efdfcf9d5e7aff55e8b4b3ecabb77c5410979e5390a7a55cb0116a4d288ace362fca38217a733f5c68f2c6a1444b80079b1b3e0bf2b6717087fd215ba9c0fc093e8095a17064a1af0bb0b81e439043efed27278fbcf5ee2cca463deb8310caaed18934e6d98182d2336a7e839e560df599d2e7e435e42090d7191a5897ed3d933bd2875c779612b5ae7f7750211444294806b9a9d349d65ae03b95aa58d077900eec74d3ef04b42cd243ef42cc74752732946d2db1af6cfd546c1a38d2cb33b1d0514cdc642abc97dff04e8e3a89cbc46c20bdae30660079a452c23b57f9fe7b3202f0d7eb6405eda9fb79bd6bd6b5641a5a2534bfb17305d493df604f5e36a80cd087033fe82cb6b8640d41ad5fd66027767a7bdfae13b700b9d65351b895f93f70d256f2b0248896c50e238af49c0f5c3276bdf57680225beddcf3500da5f3a14c1e392f5899289eee1edfdc0fd47f737d4caeda998940561d3b5ef867d4f00ee420444d609a30d29dbebd64ded98263f57be7f7e12017186af554e0909b5e4368721798c4baf02c0f3e0e08f7a1f573962b31bf703316e52381f673275d2d80e63adc10ac39056f0aa3d967f6f0a98e2a92ea12acb87b6ffdfe8c328143db94ed44b63803fd7ad6fc2c5a3e6e5161cd86f5e251d45ea74a6fa43b08f9b90b80f3ea4a04484e296d4bc45ea310ede1b38ee4fb0a40127c1f3b8dfa1dff782c5c617004b467a299cc2e8620947431b8f4c69945172225de2849cd41de255bd1392db4160be8c0eb427ac41e6d063280e3abcbdad8bd365ba8c743a8f644a7848d445360ded5708d74fa6126d4ac5f667190072db463fa3dd84fa1ca9683f34a09ee332fa05e7b5bc92193837580090324e91d9a13cc232f73159aa4134d484eaf3f6ef652b85df01c7b8f3151225b2a798c2cd37e65f31ec15ef488a55c26c05409b9ca98f68d218ef20751a9284f59fbdbd33e107c922471213b9d56d166dcf8314c7b90a1039110f8a174cca803abb6a9eccfffb37469d5b62ed68777c4f37b717f42a83d85d2c8959a3bac08c32d1493352878f56909b2221125399f0da9d25107c6c5db6318c2ad3f6e6682fac6f74e2ce7fac96ad061b367b03960aebd1e82b4cbd7d10c51a1f1a72eea803430256763b91aa2c7ffa8bfda43bd7a4dc7581a3d525b7bcf9ac9e156487f23da5155d974e9cc98e46e2c9ad06e04de2a5e43d9678be7337de89782424b0488ac3798ef8403c63bf07d8229faab25aae4a9be9761cfbf276163f14c8241436a789955c05b4045d85340d779dc1c00f245eea7f63f98653112a276a8130137f47c1c857c3e145267bd5cb18c4737b11ead1eb1b873d68a5e7cfcae7c7e49c2f4a72012a93b06d5eaa707c923405f4df05278edaa4e2c42c002ae9cf768ed6f0de37a73c8140d6c8fbb1bf61da81938a6f6e231ab33e23283a8afef2b108115d6005fdd76621aad05a049c605a0153940ac32d60a1ff9777f3f387dbb92ffdf87dd9a9edcf0646df57b323548343d99870104ddb4eabf69fbae19ea27cd5ffd5957d1bed31d3025d2ae2e3a7074b0946e466e0abf382de1112083503eed5e03fe7f509f7b87d830ba74e99a70f25bb1d0256d81251935845df5a2049997a774f1b14b3ae4764c892dd35f9e260139f767cbc12548843fdfd4ee89a557753da256e4b16a6b2ceac103f1b124633f05b2b254a01c3188c8ec54bf9f8d5d7fe3a35f5086c8f82a97e48531a382d1b2978b872a0c7c47b158916ecbe6a198f4e7f45a5649c0cc76a67715614c9c1943031cbd7209396e073c65c7ee2952a784149940c24b309704627a4e355775433f5ec0e04e1d3fd60afcac50c5cdc50e83e04363e617670459611f332e9cacb8a80681e79386a383fb54fcfa402a8171eeb5a2ebd2488be3d8e9d631789560233a6b633fa868ac8a6c18b9f66f248923a15b921d417cd658fe8833f77e7d1f4f050915f22663337722bf02e710483fc61be4b684a8daf242e38b246f7eec68bbabbb19746a07c1a7a1e6894bac1123b0102f2ec01f2d0ebb878324c068fc95a8fdaa6be0d6ff0c0966e94da2ca199774a3c04978f37e6138f85c47815080f7565b87972509f7c82d9194c6978c7fc677ea26a1e7e1e9adbd200e1b21033ff84de2cc48270d4fb6b3eb1b6f7cd06ee8cd41da0ed04d05d6345a3bcf5bd630d40ca91d896d7fbd59a845b8349b7599072ff5e848fd528f58b23f5c40d36642936af690392825f5003c52775bd7307470e1c0ef62d3baa1233dd398c243cbd24705a69f682aee3b389d197b315b1d2e18fd05ddc70ece4f98a4a48e191c1de52717c6c5cd89229b9c530a5f6b71e7ec30aeda98bb61bdb25d168570192feafdd82389ebee13157623242308dfaad57c77887852f827e59ff2c7b3b92f7396e25b498d24c8c3a92ca5f06147db2422e4bc83684e3b5740d716731b10246f8e65f1e388c90233e046841485ebde31cef6e9144f6ec466f454041f957a57f5ca46f08225f1a592a3eb1120c36912720b99288b2b83e599b25d37772d23e57f97716c44def97d3dac9f51d7d8386eee1475580e96dd27ecdf2b610894e9011fd28de4c39f1a8dc58c011393be5217a67d737a86df5c2381b6ae7f4455fdf86e1a1eb851d3394b3dbcdabd3f30d1a0282defd81fa83fb932be70312ff1f8d43e2f9d494fff93a60e9ecf297221ef52b0b4a43147db0a0f96842f4f0bf1536ebe89d0d30e1b4ae2b6e3d2793cf9ef30674d7406114d40330018822271a70e48adc12095c3fd024760b4651acef931f8d3a1988f5a4843997ea99abb21cb1732dd5dc706eb8cdaa33df82520d651f5d078889de6a6e921b09e99450f8568e114b6ed2a288f54c4de9c18ebd8f8edefc06025245817467f2896ca35341d48a26fd0577874c0c4727402f829dff0cc3de6138e5e1e5ccd45cacb5a8102f5764e747c4b9f3fb1248aa0584f799b3cf877e6548f1d9c596e5ef5ba1008b0d15d35f3d57544015223df5cc49bebaac094143368def5edc93aee3b9ccd236da881f2581e24b701b84f448c684118894cb38d9244cf26d6509f37613f00918af7b021ed271662af19164d43b38477395a374b4db1966e4b963fa395c272b14f599e2dc9af473b91e980243a85506d2d8ce489a794bac2090f685af17b3a8cf194a15230cc700c9ce75c24ab7bcf3de0fadf7fb862b08df9aaad199d38514a8c1e1949c9d52417d862b9483981a339b78663b0321ae7fb986573571faa2200ff6cfd1416837e1bccd7071be252c73d251f3dca027e3c47d2e72f6995acbfbd644899b033a0b297932b2449450091bf35cbc210b2b754d479d23d67e5aad6f648fd1815caa3d03375cb7894e58777d3f54a788b842a50d616a6d4dc767b720dd7cff1c68852b1af98041c4c3bf45cf39fe24bd4bbb2eab735acc12b0de258d0f7e433ee57b0e20f015637b8772b332656b774f48cf646a8487ef76860d5665986b321c94ead96d214687ae0432f44f1b6f5a36e415343e961850c0d2d52646b306c0d1020823ae9dc7e2691b1212146eaa474cac5da6dd09ae15712338a788e9d5858a5ce9cbc1aa5baf8d20becc26106e58d3a441161f91ea5c400d8031a656f4025435ea724e5bc3239f6a7819a0a183c618e0c548332e928a580c9f3a8d388969a82a7716fb501735cb696811645ad5972fb6f01d9e26e2434686748530d56c193ea53e8e9d434025492a0d566713e047b152279d486d20dc3a6f2c1c3b74087ab1cb8d53053fb2ae693f3a2ae605fd71947f49f36f948507841485eb6667d0433924f5bb812ed6618ff50b36e53b5b078a1377b8d8dd82a75414d8453f3d7e5a24fecb0fc9b67037326f17c511a83c5ce6ddcc94dbbd4280492c21414f66ac1758c4c2b46ffc4132ca0c1d1e02fcec17fbba53adb16fcc7e74c86abae91383a60e10846c19da58ffa5321efe5822fabf2221c1dc3e60e623e17f85e16b35566905f504546767d62463ed09e64b2b93eba59f8ff9e41f45bf64d21a0317ce6010ceeab12f993b48e4980910f472e76bcc1bb58c9e316e2f5a095d46d2ae9abc440497832ebb2cfb054f58386265f7af2b31ec5a8a241a3ef6e18137d5c4e03f4eb64d24c6df6da7a85701a680d554751abadb96b81b9be5606b65cebbf549cef076b7b28495814d28c15ce5097657d532bf9ba89861bda66ba0764fa5ff9cd7858f79df6cf785e86ac5da7d2b5701463782d32029ca11ac1f5063394ca52ca977dd03473bc76c77eec50ad5cbd9d6c94d3b57e2a7a648b4eb158b117d494e1a1337d3629657e931619a4d02239264d9021934b904211f936663c8f3b2a99fa59377c5fdd703c84cd7ec88a0156395aa47d82dfa6287995d438c46a1e702e47acb1f76772bfbf201a51805b777668b7f313b58d4139351cee594244d2617e3177318089f1b76470b68248a3bcb98a47b2a5ce07df759da1994965bdb90ac82fac0607b3005a3e8954aef6209fab8077527ffc64fa2713309e045521bced75501163be576a4aa9ee06612f495c75aff06cd8aa9f1904ac04487abea1e4336e82fa03fbc7d0a28296dfd0efb0f69497ae826a94fa8fbdab0eed3378935f3cadf396c51ba8be73dfd741d1ede51094808030aaaf6c44a136e59f6c0869dd9559b25b10287796c4bfbeeefdff01eff6eda04c136dcf254000d34eef6805be15e9b229951d8767742f5da316c71ab3956cb7b026f0dd2b3028a39698c5d6cd3c8b589d18f54c7db797888a5a03e281775d91371991ea6113e7500096314a525f1eeeccf07fd2186e7e8c2b1d7f491cf10a9662139fed04bc8c69d7accdb0d15de0156951cc409e5f6222b0b35057950b5484544265d34c2940f1f4c18bd6928b4402c220fc216661a24c9bd067e6810737ad2ac323f12bbdffbf85b25107fc122bf72404177cea74e8bc9f0aff36237eb0fe8b766c5f0714e957bde9a7455db06be3e6141c3f8d602cee751b9692cde45dac22b3da9c6746e9189db84b1d735239050ff4c5788ca3de74c2a1d17718af13a930c660db75ef4d8115f688b5b4c66dd537b69acd77db87db11594bd2e6a997b0924ed7db9f45b5ae900ffd7a55eb0bb069b8e5fc23fff82de7d8d7dffa37a7ea21c8c5246ca07cc1d8ccba7f7869009105fa8b53efefdd2442a4cbea47f6900bb5e58cd0fa04190face923d313c21747a5afba0a2a34409def68275996e145c528125b856361c68deba9f579386b64b1b4a5cfe1a041a0fcb71b5fbf66ff33919a0192514e09949fee8d06d74e9e7378983ddcb05368be9a126befcd3eba8a161259791646c78dc773d70a123b7dfd3098a20ff92e1eaaf183832a3b7aa272f8215c7e2f6fe9d472c30a9dc09520a93bb751696ea0e15e177acc56e4584db75d9a74373ed77e9ec65e99561359ddb0449035f595d15f818a0886b52a178376089932b52658b32647345cff2cc4e14a326f66fd8c8a091754234ae371cf01d9f7859c2bb0f4f66a33b6698a000dfde146700b808273225439319cd3438c751b68609e96d96cd9b93f58d97f91e2e74ae19aa5000c7ebb7cfa5fb066603e68de7b861593fc0ee4352501d6f29571ffd14955df211701b06574279d8c2823980292b0e7385bb0bd38f0a57eee0a75051808ecf866cd5ec9d328bf7b6529984f0e5cba2b2fb3ce3417edade4dbbd288eca749f304424d64f863e2766d6ec2a545619d870279c85e4f900dc05ae4169cf74376890b08f4049c4e163b885b15f5b4144bd313f3dabe7844829adff9be14b24150c4fdc5c483b05d74fbe196b477c39bfaee0f649b873a4b0dc5b8a5d0f7dfa7bdce759db40157fd8a0e1e5cc9bb24ff9e2c88cc47d7db5afd36b7e02ee1452286a0b73dbd58014d67bbe0fcb901248fd5cc3c11766dbbef6a88c1f9a6a562477a037bab0c5ba114b09bed50a8c2b882fbd0c57c68a13641fd0de1eae94404fcac6f12042118b82e136c5f6855f9c121c52f6f9732994b634ceb74f9178cee7ac0dcc716c594156316b0e9249901e9b4c4e29d54e6e7166b156b82ddd61a4eb54eeb630a28ac1704321016f45a167a97f44367ca3f37662d0b1b3f6a3930ba2af5d8a4de49a691e0d9da0e586e0e81afbf042574b271380c3c251e30523a1bc4cfd63d88073ec4e1873c433130b9bcd8f395bfbbd6dd84a0e0de0ee20efed13e11469b48e05d45fc75cb4b20ad6c8e4a5cf553c32c9d5db73ff834239b1ba54cd8b0c3383f4efada6e2fce9ff17f200ded37ac9b84e74a4923af7cbaac1a9db9a172d07951a7e9906eb1f6ba8b7f08fc408de38c2bafea5bef3bb8f056d843b4c867b86561af8a7af9487cde22d140bfffe39aa6de6c4b1567ad30ffb1851d2178e263892f62b6aacfe7cee69b7b0662055730c7ead00de32ad111a3b59f56570a3f2b04c4de3ee679cc56ff2bdf077119a4fb866a037af4a1209d3c18ba3dd049e6bd1a6badd078741cc7148e25e0eb62c8719887dee27a1c396670461d7cc85c50860286610f00e54ab3573574f848de8da7b8e25d8e95de65d8d97ce77ea1fa83e3a3936a396fbbaf","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
