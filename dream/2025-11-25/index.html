<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9bb3d98910e13d8b3f07607eec68d24f1268891f8e517f57e711fa80404074439d20139799ffff121cd895ccff11aed4fd70f854bb669db339c0c253b0a1bb808f3ac42bdebf044a95b4b9a8915fa9461a0aa856dbb564ebd4a4e57e42785d68ca44445e9e87bfbac46e9aa7a7b0432cf5ae125c21deff72d93da3ed0037670997db973563cd62f45f69f65a77f4613937cfc6587b23a2d72e202ca24603c216f8488d86b8f5394106739f16c13d8b0d49d9e281ab1bc42aabb3ed019ba0827996fe1d82d538a657fbc32cfb22dda4abf67ae09b7f0d72941dd8a11e3e91aa7e60b509656b948e1b2e0028c7dbbcacf3a826065f54386da0d9279ae7c593260dd0b7ca972b06c0e75dd97753d870a5bc6f331a83bdc4d8b925b49d54c2569d329aa3b4866ac3f726d6916894b4781c0c411564979e32a22e59bfeec72949746ec8060eeefc0255a055d0bfc666635c26547e642b08258e007bd2d2184660edd0742c8407724046432f187733de83fe3fd8fae2f016c9f424de953b67f2f580e1c23fbd0f7cba5f465ab8f5102f5f01a430c5fa223d9c86446b303fdfba9dfc422ab487a28a92da615fd45b0f390ed5329cf950d52481803719e099bd6a1735b93be2168fa3f2e740f6bed268d5ecd4012d52f52083684c9f96841aa4193f2144ad2a54395bed7030674769633c3df59e4e273cf67d5803a5dafd8ad2c6a53eb497aff8e1898c3b50ee4e28264912b79d52a5302360c39c21e28acc1310936f91d9d34073c0434d5d13fcbf4c4f2724afad4f8f802d7484a990dff8bacb37edab5f9f3615071b83b580c5e7424d20aa3ca80a822813147fa505355dc2fcfb8875c60bef3e36040d7822a388b36e0cebaeb8bd130451ac481945f2f49d6ac828f48db416c680bf56040f11d88315790e1a210a7ddde2b5652813db41824a46306c7614f68271953f6a6a8075d107ec1f56c97099da7eb84103194cd1adef0645715496cc282407b46fd6d12c860e9f47defb68293e5214b2537fc6992f26eb7a078d93f14c9ef1dc30a7a8307925989efe986e59163fd0e96603093eefeeb46fc733ab673bef3c75d3ee1847c53a98f1d86a98d04430e25bcd6b5775e086e83233847236d1cd24e94dcf2d5be4d31d1ba79bca18a1b0ae3fd499d7eb44c46d7f27825db9e226f13f553083b73c760072c16570a3376509ca80ef9e844e713173b0f3e305987447a87b0874cda5e189655ec8d99d8f78dd4fa65c2bcbec81bf456ae575c12db21bc54f22b0d18a41a2ec2540ea0f02e1bbc1dd099a91d32a4e8a2fb9e6cd317b86e2cf84caefcd2bc5572ead966b1f382db4c397194eced039176d25328018415d5947ecdc952460fac1e4ac892cde1e6528db9d2c7cc20220b018a4271ba017f4a70dc6ae306f5b901d5e079a98c11b5f3b3ac33622cc0e7e8e2ce3ef4f89bbc98450fd77da2d593fb373456b1003b5c2d412cd7c43b8ae496d951e0cb222468606c09fd46f145ccb2c501cf9acf291150e7096c88538c8554b77e99d5f669658d085bbc38ecaa6013d40c8070d747edd103397d45959fe0663684c0261d81cd8d2615e4c7915e3f1137a03c6108f491b6c05b09f5d48cc3ca2a076dc62960b25022475e5d386bb659aa372712846d8d2467c026b9dc35fa8b32f0440b5e4482a6aed92f7e4ced1dceaadaddbfe252267449e9e113de63f68394803820cd05794bc4075eb95d57807f98ae12bed888386e0061a19da08f494d4c38f519ffc3eb3053938fe19ce8365cebb7e01345c4f647b7539abaaaf71848314d9357e7f41d4040ea4861816f5ac879f63f834c0efcdf807feb3d93d99c01444f14391b1e2517fd293c69755935069c67959a84c9de2669c55657444fdb33a298676e96e76cbb4d338cee8b980bb0a2e5038bb00980d0fcf47b3aad64e82935e89e4ddd15858c2827ac47370f4ce3befd2182d9ebfeeb8ceb7e9827c33b34046fa56f362007927594f333c569396ec047f4dfa6b7c124d3d3ffe61bb13e6cf140bbf8e7ea1d50a5633a007e74294663f3e23a8ba5aa7cb26db2d519d3beea4e09e1cf64ef4c133044d5b28e9801bd221264d43490643d6de5bd0351dbec48a0fc788b8a002691b5703754309507ee2d0bbcec4809bfee77ee3652a6e2de73cd00ffc4481358634d42af33b6a70a46b15930235bd37a65616745b817b2ec8e25ab76a5a14614fdfca8ccbedec51e8cfc5dc2a9f685bda0e7dc8bb8bb6c9fc50120bfd620ad8b20688b2ca4d67f85820543f61a27e10e3bcd26ab1f1dcc595e1cc655ec4dfaff09bdff477faeffa7a96d057375e9604b3d8bced56aa339107f2cb31e1c111daa67b72ea887720cb01528370bac2f5f2e06375974880faa190f2020cf7c5d5ed4b8925c79b097a28260deffb0ba33bcfd8d7d0c327c308010bd48570ce97ba8428ac89fa10e333b8d26ef933c7a9b1079c543b81c74ca2a9fcb9a04826f8e22afec3e6dc8a4cf5937ab06619b89b73766cbfb8a3877d67cacbbd8dac28ec6b9dea4e38adaf97a903a649a1176fcb9517074f205f70018a87d9bad874376b992c1307af559424f3a0f2204b490ffae7a4142e6de94ca16b56b3f4a0cd3cd5c9f0ee20679c03eca4cfd5d07647db475fa82e3a65e05fa5d122a70fe5ab60452c0d6c3285794a442dce8a8f5b7cbadcb61bf1c312d214b46cfab21840576bc8fd6a689e4e8ec5ab718e1f916bff4c913209537ade2c5893b1b3690184f62b221d0f82adc94ae939902f278b615e8fa688653b7edfb0162c076760a6b22321820cfe8c2ccc53e569adc1aac924acff6e554fc64c4a31a6529825f1614b465982c2af0540eccfeb0f6ea60582ef9f52b4dc28a49d353736b22b4ca705bfab8dda3b8f0108d5698319ff18d948c8d5ab7aefd4e065826ee165b15a91ca3e8534b656a97fcab97e53b99d6cba88ad6990755a7eaf1398ce558b384f536eb9b7801050dc1c058ec3a250a9376c670a9dbc586a898f4b3b28c35c1033498e68aebb0a34df0aa05176d47b06ece484dfe21e2027fabe154bd5d9caf96b549a4e1de23a7578077d8a3291903a819ae9b70cc3e56b0748dd5e8474c5b458574715c7fac8289e04a0ebac97ab9d0180b98c933b1b1ddca9b1e828c6342cda3dfb2c2d208759fd1a7c8228fc37bea4c13f9f03121a0f643fd9c70586cce74246bc1600a612c4f51c8e770c4deeb01516032a03a2dc074f6fc71ae229359c66164c89b659ada4f6405d43dd0d22f4182ffd43a099adb092aa8f542921f44c826a3f9ae0df8dd64527000005a0d4116619008337068fa4d9c96cadc4c7d326038a170db70045399e50298957dc0d81342125eb4550dcc2bf4cb50f13a7b1f3232c1673411871ae75b13549b0943a29c4f952f384d0135e3ce7c1551c682264e8c5e4ae0bb95842b199eff5909b18a876059a48c89402224cbadced28cdfdd7b2634cf11689f5738985c69f61a737fac162ba4e8d5ada1fb44dc838404513cc0ea638b16a405a698d04f9bce3180435c7ff7284d06b13e007c522e79056a9e69aea9e6436ac6ff11540279e05f2ea47d5c7ddc1158095859943faf4edbcdca12c17a1d6480a589ea4fd975c9b88cbd38feec29e061f263601aa5c0786858af9a7614a925b0a15302a8bbaaed4e3ae480027549e7028454b26985ce55ec1c78acc00189ba1dd6b53bb20b7f04a9ce583c7a9ff0ca1f8f9a1b282fa2a44c5bbedc075e4ed21cee727ba732b228e3c46fee974938bd07c85f82b3904634e8617ce63d94b6a0065a72bc9c13cc0affdb7d03eaba720a1cf7ebec9d7ce99f1f9daa8da4585a7b118056312573be8c6bd498ac24e15e62a5ccfd39938685dba214d6bbbe2f55695739b34ba68dafdf6af2cc8bbe7a257a11f8f99612f6a856dd70536d3dce33975358e052690647564ff7c795859183283452ee12855d36d7924d764db99e0fb411248dd28d6e1e727240830e0ac4a854bae7737cd6d026700ae71042d4b04946fb9a137b02ccb5d216b5c6e96ab3fa9a5375751a887cca6ce7ea0bd9bc7b134fce225891a2827bba641d50143e6d849ec98a0cd37bebdfb5bf9b0d28b1db38eeb38287c1c1396d1664e75074f43c044956cbbc7cbfad4ef33e84bfc9bf409ef9616befca0fea1c200ca4fd7e8af543d6d1f7c01831471171cb466e78d4bfee222bd6d8496d2f9e1eebbaa9784c20e9dfbd95163329e40683fdbdd31a9abc00f85f2e459ec86e7a2daba7bae4970113cd2aa6ebce9f7548cee49bd3ecc48aba1f36181bcf9fafb4d3d3bca0cb173da871fe091a80ca540cd5e23f5742eee555aee01da7d87a3a79dbb2f4c1b7b24264badf5f537d546084fa4fbff5dda9e9fb59936031693791a0575ea073f3674e885845eef8f3f8c0f731b51d1f0d3c5ecda537b8833156dc35febc2c68a00d20d7daa2eff73b0a20d15310b71f15a359152c8fe07547a6e0836fa269974db257352c769903750e024147525f0fad33a764b75c634a7e8b3036d98c98e5dc2d14475fb5819a30970b5550f43f1840f9feaf418abd5e8ae4e0c4dbce7c0e64f94a2d5b9ba556ac14fac4c05c6f6f6377b7aeda0ead34d6b49fab3a551084291f9b7abf0ab1e2b95971a7d06ee9a99918329e5f7a70346e16271a98beb8a314e3cd98b68c5111574935d2a63ff8444ed6eba9f4b6566e7a1bbdafaad50630076282c518a9cce091b99c64a1755897116298a7155bfc07afe7efdbc677296c4b7db6a3b669dd4cc65fadb7d92227012c40b85ca8e43885983f49c8e0cf5bd90d75ad1d75bdf255e258f49eaa285ee16f4d54f346feafc2be040cf175cc5c652fa1f3fa45f0c2acf32f5642d29b417cb41a80c2cbf13e69ec13f107defe8a20d7bba8d5b354840e85552be91bceb1f8c07f29628f44dfba7de5ef8e64405bee262b981c9dbfa1f27eb64c9804b7420f64e246e6300aa8177b2e88ac7f8828d83a0a335708b8fca003b0ecec0dab6ce6ec25e3da806e5c6ca776c62e31178d96c7e6d43417568ad7dfc864384805035d73936fc80aeaffea07cd72547b537f4cf39d915c116dc86c48e03bd07cc854980bb1e56b0940a1876297b562b079ded90d4288222265ba75ebc21c54ac2b9d58d81d0e1dd4c5798f7119efba5daea045dfb5a92202d9f8a555cdf91421731c902a777b7cefd8cf014974921df3cd1574384de12a0ef09b60452ee1cdadfa5cea68bc10c68b35950fbaf004ebb6a46954b519220da9b31dd5653ec46bfbd6ce7161547be867ec3cfc4d00be57544f46fa322aae7a74b12e660b32af3af9d57c0f3ed47334b95d42e61df2c6c95590754538271a09a09a4930c474d1ec6af93e43d165abdf53e224e1fbf2357e20e595068824ab1674cc77f600c532a11204d06c9074363dfde72b2d189ea736b6f153f68c29ab44ebce35c195f8f04d1f45f0fa838195d008adb50abd95be8d7e73c422b352924bd856324467c88fad014ad971b4eeace38fb1298adc29e6999d56c2aa4f1be78c028f6c2e073b67fcdb44e4de0c01939c8f88d9a6192076b1cda5528c27f7b6511b4719493e27ff98a4ec2d5e745342924a76e1890c0b3a6d6ed1410efa7f1623966c9649b74b65c3021dc3597b7c7dc8186940934a61e565a55a4a6c3fce3dca4f4ba1b158b2d60b1b31c4243069ad583a892dd339cd8c45056c2b9887b29c8def6eeb53949b743373f3a773591256a8fcbb1432a85e96916cd88218a4cf153e6e0f199655a4776fa93ea1ed2a1c495d2aea9199b74b010cadfc4cc7a0fe8bb7fed280f8968613a9cb16737748e94e9691b9a7f41df70492e66ef5f7103bb6d5de69893e270c005bc7792ada55d28ec7d148ceb9b75a89269ca65f25d7f08798652b82f30eff95070f755868ac9fc1274b41cbd0f4b97b00200dd9693db3c3b4322d3809b60a391edd305ccfb64d5300a919af4a4ca23bed152d6bfbf364c2c34426a0adeb154167c9aa1256370de077651d5306d2fb6c72e07949fbdf3e07ef13de2c1002e7b0cebbc782ac36c2c5e2d90d9624e5f662f42caa1e7cae35e7249acf054309ab88590529643ffb9acfb2f463ab883af93a3b3cfb79d87cd0a666a4563cbfe12d5ea530962fb9c30fe987b41dba63884481c5a61e11582fbb2900f0343e0efdb8d717b25bc19d9b4cfb015e0a86c3a3ec27bf5ea920d72edbaf1be932673e529ccd6c80953a2a0e1df8a99819db3d6484369500a27ffba34c4a15ee8b9f68c66f3736ff23d6490f549fb211bc487ee5ed823b1080bd695ba7455dce266add27eda365a9d7492efc92ca433e234b4fad8510746f2796c47d59a3db58f2fef3cf690ff1b031a08e0196534f65c84fffa8721e5889e4d95b09de28971d745acfe47d01977808ad6785840c000afd82187fe1026bd88fe0d8265a4fdeeb87853b078129608dafc0d0d9d4e39c7c38634fdcb631e6792923e6261bc731c87a01d0833c0ba4edddebe5d537875e9802ea50cdf73d544000cd9e83d1c6a03ceb82db484ec412ab01853c2ff6b35f82854575e26050f4df1318ce478f35b5ded7ec3bfe1dfebfaf0d13781d7990cbc2a1ef3cd3f790296dcb089d9d0a1f25ab3c91252f27255a2bb48ed984906fdb79da835b87d52b7a0517a4a5806bae2d9c10f350350a501a7384d3b1039ebe0e9086cc25390a574a41d126575160c0cd9799e728473f2bdbe8e58d096600dc272ae20ab5742e718e56970fcd756c6bc5ef950ecd934895493e6a0f3681a53f62cc81e483614dcbb30d2195655dcbe014f6792e6b5fbfb5bb69ccde8effa598769e3be7c36b4d67cb83ae596657343c0cd23790312d3f9df74ed6ebe0f1063c455adb200b3e4dd789173c8c7e2e24f2dad1589cf91a9a2f4bc413c62b841e62ab651b6e046f1cbbd5de51535ced5d74e46fbb0a8ae4754b1138d676cdad6226269f370cc6f21d8e2b4ab69190bd88daae34ad683697fe298748e0b915eac5d3000010c3a0ee2ed2cb380d63b07c6197d8d9fb45811cca35b3a2501738884766bb2c832b262b95617a0e9a3dfe571a3387a3149dacbea6791a5e551dc8b049b93c69e88e727a1f9fd7b941f2c13df7c08f1d0acec1cf2f78e85613c933bda218c94ae2294ecf490a698875180ee937c890f5e6e5ae95882b6e52aaf033780486f8f33fa0f29e5cc6336f995cfda518a96d7630fa45763aec04584b1db00522e8425cb082f0f2dee5d7f631bafecde94499852ce1ba339d0ec1fa7c79f02c944cd395c6fd73aa38d47a33ae49b890234a53f653a39d2021b15d139983beef5f5b94a71c7a2867c66ff052a8398dd3fd6691e8e3dcc3eb73f41071f4b99e755207262bbd680a798a21ff661e5a1a339d1583735990477caf675f08c023424b5dae5d95afe92b186468ca413358aecff24a5a74a8d636f2645b3f1115f876843c5abb8103fc26be9bcee21fbbc8a41d5e2659070cc43da953918fd6c4acd7daa9016d592ed30d7cb30bfc980c0f1a536ba1c73112187234c50e2537800dfb3488fd83cb322977816b58191ac02eefbfddd989f9ead47bbc5ea45cfa8e7ddcc9dbf38891d59544e0c6e2489f3fcb55e65151c2002dc9d42fac0471912e0c01d5d58174543614af8d6f52ffbd19e055f042f1943dd3513ff5cc5c6a8c2b92c76674404bac7bb5a41f1788cdea2b3cf1f0a0b575de409f163073f1696a2ae44f941b3406b7c241f6dcb8eebec9530e477ca1ec36710f01ae4b377e0e2d40c8815b40775081fd7b9b60430fb701d083c86cc3a6794a6ebfc39314be1409bc9730d6b00b603f3fb42aa8736ca4835379fd89d463d2e51b8f2c794d74d972e632ce175edf75a06a2121eb46e5253899f9441a8c8f8b71fbdc3ef1c1221259ecbec23eb9615d17010f095992727e071299bcea6b36af57118c4f808f26ea5ccccfff12fcf177e6b9ad8fa9a8d814f0f6ec5be737c81193fd6ea7a6326392cb0942efb573a1d639dddf1c95f5b45c55ca5c978c2dec4be42bb3512320da74d18050a780966350c83a177716a5ec220191c403a43c81446f2dc2b2297b0ea89daf79575d989e3938d90561dd5f7d40d985f8c327ceec2394162b37341c0b25caaf616df81dfbf167b1cd6f074f921c3d2a12c82d60413f2d859d69f164951e056a61f3592748daa8846b58740cdd2279af6fe0f5f0244e30f43d60721a4d5bc40efb0898c3241e81d7453e865dbd4d80dc0c0d457ad1a57ce13acb876cc83f8e1347f199a4df4c2344d5ff4fed0218e38a03fa341cbb5510d6abf9d866afc274e0780234f560e6c6ed6c6d4c41b804bc46a25c7038d51383e60ba10216355e3befa87d2d5f7c9e6d087e3e6bb96fd0092b113312132853982116c7271dcd77aa8f69e25f91ac0f79ac13831cc6d825ded2e0087cc597f7fb965c88e48e36366d56a1e4ab1fca309e95ff076f51916e97cdea6f661af62eac9bcfafef6e1d524528862962504289ebd9bc2b4fc68fdc7a4e87febfdf9ac508049dc635ec7b8558830dd91198fb0a3e7929e1f67af067ab7bce440a90cf1d263d31b466531ecbd98d3658f1e67175e2b45934658e9405ddf7f9a0c6a16095ea6ab0633d1a81bab94b277afa48822f757e48e1caead7c19350460aea9f1f2de7dcd0c71882551207287964d922875431862e396402edbaaa15f3ca74eae8c9fd3982218b8026ec8577634102448bd35bc967c718abce26685f67fda116081ca943b72adfe01fd5d3f1b187484200237083204f9d3dbd74f8f3b1e7bb39db1bb7c37e6e6749b5f895650415a0e6df0c453fd2cc853d6c830e5f1276237e575d93d01e07373dba40e098fb6f3750e92b9124c3d36c7c7f9b5d207d5e7186d1f006fa70afb8ec9f1ca1ec2d3dc844bc4b9056402d4daeec87bf9577cca96c3fca431a7fed40384a434d1e7b64cc0569648c95c8a334f4572235a0d15ccf6c8ca575e32b08eb507834d2ca5ce6fa38c40f90d0a8da20019b4821b7d1dbcfe5458f6ae92b0bd30ed8a3724692cd00c69ba8631ae896296b193a4b11b8e06785bf9f4a600880ac1aafb8529094393b4262523e818cacc528e95078da462111380db309d32b0fcb0f07810e806e729eecd21dfdb6029e912b713883586400f7176b08c7797c61914a458cfeb8b245dfc7f4c69013104cdc8503bc0e82da97851863f3208ca2b26ec4d04da16922e42aa58c4207353ea2086fa84f32068ae44fc36c028792f679285de22483d57493399addc4c8d4386e6ec81e9a0e7ba8f7dbf56e2e690f47cb0cf7263716b7a1fa803e9a8dcb4023618565c9e8c5a453c8ff18bb7bc3b388beeba366f95a7a7d01541e12392787610dad77ce63026e404724d96801f5fe59284380cd15d2d968ac2ce96ae70cd81ced3d90f4b673f9023d3497e23580cce918531b9d165d7c5491e2dc51ded0782ee238277be04673973f55548347612a6446f64b3bc6a850b2a48cfb2e8ccfcaa4b77b15ae0b54ab9d5ecd1de3f89a8d65858a50d6f1727e85bb1b39eaccf3c718c60a0f864cc73325f970d21002f2511dc9b3da99c48c69f5afc79edaab68c6f545f1d0c1261ac154643bd258fdfed7498c9a89e877ac5a78f8098abff08c5d832be68272b888c6c266e28c7357a48f85adfb9fa860783e493667b71c3a7f76407729480709bc8f2bc477789d3d2c45909e7da31afc658c4486fe9b39642fb0cd3b912b178f6017e62de65aa8716cbb5b18e9ff456a11cccdc29322ae5bfa86ba6a85f6a13219c314b99aab8373ed483dd603a7f30a176f0a9a3b9f169cf364f664b393797988413df420db354128f6db0fbc695c54e03120a4bdbe5e431b7f115d63e81d19f9e4b4473d55c386fbe42d8e43fb64cc2d90b99dd77ec790fa6fd062d85cbbc286700ed2fc5a3f53d5ba968da597815aeea8ab9bb0b2483e2be4552eb44c9cda5817cf18c270d242aaac94ef129b8c578c6fe51adc30fc41b1d34f42a63304dd2bc3b9412aa1f0f611e954618fbcf35e8c8a57b015f23a20e6a05042c4b83afe34a577de7d5baed92ef7690049c6360ece94c1d15491e7c2e03463a61e6da7b622b2bdce36d01e1ac2375ac8327d84db2a2503aab47f525ea4e06fe4f0bdb5838110eece7071cc59982fd95a3530d2ef479eec7ef380a00f38f740a10478b9d24a37c528bb66a164360acb1e3b34f0be4a17f001c6e7a09ccd449a0bb0526722ca8426607769cbcc336272fdbaa0ec0dd8fa7453325ed92b27bab4142f4efcbf3cddab380dc4db96ae3b2c993e8fe2148fab68d143651447722b5c312bfcb1babbfa717b6efbf47fc8fee8907597343b1e0095be06f3dd974439aeea03f46af615d2e161c1c1d6bc10f45d3ee5af24996c8ba5e2d93c68de8c46538a873ba32be3c38bad0d7b82f54bc5142dcdf5fee610e0ae5586b05a60070d552a656b5902863a1dfd95c52768d7354aff06a6466ebeda879b62a037229c2c5a8a9c870ccf2da338dc9c589c5e8429e5955c19f6500302351a4d474ad19f6de14a97df28afac07afec5028ab9b3fb2c3d380542c2598275f3b6c9a02dea45437451e7c0837ed7ff8d9daa5662c3c51b66437c4f68e34fc579d5da1fa435c3f78b5677223addf6e08b993a127a1f3a6dde4e5b916e223ae269e43e9637367741a81ab5898ff4bb914336db206b84bcbe4d7c5af14008316ddf3a4a16b445a5ca6dde409220c7c1d942fe35302c3f55f7320e7f13b6525f753592bd017fc0b69c9df624e13c0186815a5c65b56c79518d5bd7e97fefbece62a79085d497bc6d7f9aa42fbde7fdcfd97f3f70cb75a678fefa6e65000c7d43ad4ba6c2a5fb46c1589d45f55d3af9fc4c840eb0be49960e06977aee0d4eed5edb84e331907ad12b3b0d654742d37974534821e54b104d4f8b41da981bafbdd31427281c532e16d8fd571d5c2fb87cf7695fb21a30f6622e053e237f934ab88a2507ac201fd4d3c296835130770ba80e914824448dfcfdd903cac1ac94909da52bf94903fba582c16efd5f305499b3acc5a27358dcceb5e5cb4c920acf473b6915196c50d9b472b123e80c68aad378e8dd5ff46a68210a07cd66c1013f9a730eecff1d887e542d638d7a460f2c05578ab3a96333afb38bafc8d20df7bfd00ae2b4efbaf4adf6423a419d3ec2a863312a0015fa7055267d959324581d2aace21d2763761b1e1acfc662d3c4ac4686d65efc3b51a00220d4ba43a9384b4b3b29921bc398b458572b4664c1f1ea5aed09e175acb82a9501685c3ddd8ba68b5775158b65b8572d42f650430c6ffab77c3e23d3bf837aa4e13d506f8e1f720d6c710f912cb5f08b50e3c772711a6af6a31654cac74a02e1822249b03b59f6640249fbb6b1b9f7e0460f2855407bec1a568db9dbab65083e356281c4363905ed3ab432a137d92d0d56454f2b04e3d80628f40f7ac0cbc72ecf06fa1dc3265a5313d8b612e6d48fb47ffba5a1d2baec65db3580c0d3ac7222fb3a0e107786704bd003459719ec588a8ac408890b57044ae4c95fe73bb67bc91ad100900376383e5d13432e1ff59effa3951ab21d24708a0487f4d7821ea901b4252dd341f19c356c53917b9f7d5c706ac10c40d07241dcef4a1be6c7fedf06b581c35eca7fe9fd47b922cc20d8b8ac3fb163e5414626a3efb2115341fc73cb8610d216a32576ed4fd38be4504e922d1d6265fdfb88a312a66c3854e19ab6eeded20119cde81be618c1fbd5bd106afa9bb655887f3b618ade8b963a07d69715398b7f202a48f0a7e58f676a97b690ba24a8142ca441ff5e5931d9490d76b948ff4d8b9b41f65b0a15e2dca276ab18b148b8ec873ab58e6465c983767d031e34128acb8c25b23a04f2057ee30da3c7939a0a2b447ec266e9b86dd854591579e426ba0671a8ea7c98477d5670ecbda6225c081842e4f990116b07ebb2d1840a5e66187d6f151ab437423a86eaf360ec6ce704f90ba0e3816cfd94cdb93c4fbf9c5b58d2dd3e400492592cfdf3601e292679d45828b099e32f62f55dfb523747891f3e8b79f2e3bdaf7a9dc1227ab5797b859260a4284dc832fa35fbf476f150d7c899eeed5b6979d938449acd6a80fa4c1bd67e7502462f542fe0ee2c9c702f744ec44d0117489a9e689e9f54845651b756494a52db7126dcff1bf6a1c69dbae23cc00eece45a5b4fa3163fb1f448646636262f64dfb339335127522091031a17ac68eccb5e8c2c5e8928e79344419c6a7bd0af391dd15f465290a835cfaac6d495a20852ea49b6fd60543d0a2eb253ae2d81126073c414350db40797bfed1beda72c41a7bdc52627a8e85ebb65259fbd3de5e3dba1716e5f100007cc9c49858e71639a71a1e22d8fad348b26bc6a2ac04d172eb116b1fae58d00f351fe2e223514eb7a99f753006e9f863bfe0d21ad2806a01ac040a8188a304aa6d0a995f5b8008121541469d172d14e0ae90ab9c304156ae550b29ef4ebe5a6268688ab75ac2fdfd4dc1ec05c73e722a4eb128dc0585840e540433024aabaf3255302c35cfbb67a80ffaef6ac29ec79655c1dd1ec604e33f86df8b6a2c0ccd6e95e52c599f123575c4a5197ca151a7bffe9e9ab060183fe51a9c5eee7e6066f7aed92cda772e201e93ec304e9cd7aa7458f7fe021266c0d3e36eac10866414abab7d283165b62311562a7b846c54f293c5cbbccb865ab0f1f19ebf713c8aca768bd8fceccb4dc1cbba610e187af63c226bc980686779897aaeb85113e95059e1308c7bf1ee2571f073c7ae3edf442c95c0112b24f3b0b715232545084049855fdec4acc9c31daef4688e2ef42cee653aa074b375183a7812a6fd3632e8c2eb94a04366e06f55feaa5c1a8e292ab4c658853d362bcfc6f81130dec4e11e98fa9c3f3bae1e8f9315ec8173fb84d271aa0fc6f7406f5645a4dfd207788cd8f6b3e49bea431de7a27093c31d136bd1941e2e6fac1b8009833b8903445be156e3ad465dd37062cf76cb8c1eb7299b25401a16c3b261bd033cb4a69a983c884b5d6f9ff3a27e2b42dd6c502722fb65fd35976aadf26d14eb7cc2892da341dd78943a5e70340c9b0ad850b2ace6f00a99e8eb8e0c4dc74374435424d4b32d4daf2b65846516f8b5bb0eb4b62c474288c59e131862469f29c2c0258a168fb64def4c622365d36810e071c9ddf247c8da292de3cc84269c4a7b2bc5f5c979410eff4188f2d082106735bcc92dd14c20f0b02fc74181a0d7346ecede5c5da7c7ff0e833b9d94b0d278cda48256b61e8411553f4743da7faed9d324212e7626bdb09422e8b0b8296e4a04790b3bb26aa292b4dc3189aab4f3dab947f19a3125093730513c2422412e6db18388888b95c3ba2d2f987d579962058e96ad2432a4a3f04c8d3ed1ca7a1cbdb6b6dd94044511f35d5723fcc45719fa044c5f382258ed60638bd772d46b23a2629bc5dcf2419255e1da98dd6b08ffffae433520e7e66e0d31ed0841eae9e35f4305139342f4468ad2a8f420ead33ed8f7fabb23fcb04c39112ab7549f4c79901dd63ba813879d215a48fc9ac9fff8a4eaab9dd62ff21ccb525f9bae2063ec73cb8ca512ef7dd125177cc051872e0e8168aa7d3c4dc8ed4cf1b700ae73b2cb927336cf37d47f00eac26919281079e54230ef805d4223ccee2330e47f55ce9c1ad972c679b749cf94fb59adf12ab0e941923cb00c75a3b47f19ab1d68ce5d1369085b5ecc218e2ed8f8b9f9faa4e7c306ab5d67e12837d89e7e926671de529a092d8f7c096a5ad92b59f790fcb5ab0cb2cda95b8739dfd739f81a6becf1ccb097704e90cafb783562ef10749f77a7a558d067ced6d4b290d5f86cdf887de9f5a6cccdf93be7d29aa4054eca27589732351a7d6fb7a99654557efdd85414a1568434cf9655c0f2231a73667a880066a7dd50df62ddf0d41b0bcb6c5bd12da8a7d99cb35d6431644a366df6d05b93351d904bb022718b0f590b003ee3be8756c9301f03c8eb7fffd3ff8eb978262ebbbff7538f2b10d842738496bb5529581779254bfbc1ccb6568a826183faf31c1c74a326a1f9c011e541733429a3aa647dfc53af5efe0343799946e505b6e3c9c33cc94e98db749d8433685f8c84c986f285e2b7abafb6c01854e588d7402a4a49518d3e036fb978be48f710142d4d7056338e918bca99c66ece7585f3c3abd5e59af3fb35a141167feb02c41dd733c6a6ce85c27de1306fc1fa625d04fcea917d2f4346b234df17dbd43c3f0c0ee83a265071db0c97e1a0902b90998456d7c3500d15dbc5dd1b9e2daf9c511058f817159420a400f8ee2d15e5328eb204699ee1bfe64fd1897c3edee26fe5922813360e8981676976278fceb74546043bc19240f63c23e6e68c4ad366ab26fcaa716646a16031d91b7d9168ba79b3a58788428436870a72eaa37c3065783ae86d37863a097a7a9ca5eab056eab18decbb1590434930ec77837831531961ce374009d171929fc1f7df30b22015c1ec687c1c261332424ae440b17ae51b273aa76843479787171049b83ca9517df44897756796f9eee34c3af102560a642ba48c8b6f396e6d0f0a8324865942e0aa51d2e93e2e85c52743937d71a28f4f2255e8a02f1d79e11dc4d27b63a29240f51f07f2bc4bc1e901e96606ed81c27f170b93a2c12a67ef7f81489e83962d67a3f4fee137131c7c658fe469dfbf21d5cf13f3455fd1b54be97780961c740e7054a644a1921272774790d67274b157be6de976cf40c1d7a45a1b5c5ad54b0991a26904236948a6423ce47b5f183903ba2d901b5c377380837676cfb847d42cac0d5a7f57e5f85069ac6750228d002fc6ffe890139e75beb74bca2304e5a5b2f27b93853197630c89fe4ceed0eb90a48b85375e8264cfdcf1ce8316b04ebb7d3317817d2cb6e16aadd43161026da6c2e5d3806a746945433b83f696db22b06dfaf6fb07487fbb76cb6981ba896248df4a25aefe1cc252c7367544de825a7bf88d5b0cedf06eb42150c1f32355e293ba0e01dfc3ad9533449843a092fea67978abd2bbab477e8f532ef2a03f798dd97beb4cdf003f8c2c733f3625407e06d27a2b17fd0145b2a9f25c00bc80d2267ef5eef47cf6d819f124ffcd15fd9458949180fcb9799b53eca3c79927a099e152395ac86ef9e8252d9790be8a921b4a3f035bcc3a134f1fca46ccd29ffae8cef0e5a5ec28879daa7e63fa7fbc6f2afc1a00a87dfb81d698bb1ebde0c190a8ab4d91458b639dee643f336e5f9b7614022f9d5570a2966b84c609b8fb6aeb5140895c6a86154f5f12785afe7fbfa6b9d3852d80b1ab2306a7d6ed0e70b8956c40a0522e5593b184460cfe88a88dfb101659b68e2aabe2bec83b0123c8bff66b6c7474ed036f6787616f278f152b756a8de1e69b66c12af7a4a0c9ab03551454f6310d4ae23788761296dca4d77e09667cd49037b17e87657181edf55bd6cb7c1efc469f0ee8b80b8c2ba83231ba89bdcc190b6f775cb38fc08a17a398e6349e60525a33a335c1cff7f955f6bd54398ac93125b639f09313ac236a501569449383a3ff1abfd9c2ceebdfdeb4a998896c42f37a035b3f49426efc53196971b8e4bf928a7d0e376f7f27a8657762ebbe85f91ed31c973d147a19803347824935f0644abc38528f198b04b3743d9c9edf45794ae3ec5f9cf16e3ae62e1a9ac6b4efeceb961b0b33925b0efa8a6a156df50295063e2254e097e52291a211844f2cd10bd644d25461d7143f8a5a0ab9cc9a43107da9116f2e4c3a701df1c9b459722bb7f986471b7d9c93c482788be5ce9986b02e6a85b4ea5348aad8b203e9141db02489f6ee4384bfbb9053ad14a14792a970373ca2bcb593465e05e1a92a234fb885c6653f113fa05518c6ce3240782dcee1cf84267f6462cfc2dd1c4137f91cab2116fc4a6d12e543c2035a0c87b1627ad6f10ec8c2c0299f59f7d26fef935324fd5fd73b027fe6bd247ed78b6030d2cda29de9d17c1e4fb6744ac724d91bb9534386924d363ebb1ffaec3fe3bfeb44c3415270973aea0554c81b569ec93cce15641ac48694d46b29ae686150970c8891ac71f84d5b41892b709ce1a63ec457acf84558dc2646b74cbe1d20d52798ddcfaa853cc55c403c191a1d9a5126a5d0d86f58d3bd2561cc386f0d5883418f79de0c1e8b7f913d103e6c386526d0624c97bfd6d83de993ac05c8d0edebd87316b21911cb868eaded25c2ea018bc50be22edeb13ae8d5dc527a6f0e007a2f57f888f85fbe454b8b59d5cf60221fa377113e60653fe5c7e7adb41206a813fbc9b59c7c9b33fd06cc59b4681cbf0995ae8a6d94f2ffe8815f1a5097a64da5eb1126bb782fe3f84078d9f302272dbcf2b8762f350592f743fcfe95b40cb9e4d8fd6794d109b8675b96eeb0c98baaa09813de10a5d1cdb51f7812fa61dc284a2ebfabe77ee301ff494c47dcc9d49f38fb123bd80d83304136b151dcec28d195e7e4a219020abda53b099878661944640493de46f2a60a2902b6b99fb0741f9e8befb0b9d80e0cc72c674e67d5e69911c65dc82ffd8b10a18459c22731305566c564bae8f8889275e428e579639a16fe7f260cef70fcd1036b4faad380b46c50c06659e675ef4d4fc8aec3ff520cb5393af46be5f2629a8878a29a9290f73821b5cbf10fa601aecfca298612fe72e65b16c22a5a3b70daedde01d02f74d12503d03fbf8693aed8bfe8527c9a4d3bc74bf4496fcf889544e15c8c08297bf300d8bb8fa3f1e841d993eba0e96e920ca47c8eea86cd6cb752cbe75c8a0c7673730ea95948ad9626cf4b8f601d2fd3df14d246c8645c18d4231b5597e9405414cacb59bc17d65567606fc98b4fec520ead4284e97b1942549478a496901d0eb4f7e98501c8f6a6dda19eee3741a0ab9cf52e38fda6316dde92459f0b1046c38add659e1ef3bff30c7498545bc57475025c4c10cce51f18c09e5285cb36003b5320464ae09c896612195955e8632a773df8cf3b9907139e76fe4c94bcc8c5d56583d7ec667d8d732c9d69e45037ebaafdfc5330ea5123f732ccbd1ba861c849eb4647f49bde231735724c36aa0cb6942f318f6ffc7d2f97ccb270fb769dcf8651bcd028c1146996cedcb2e2ea6d1da0f5a38be4b5bd5576aed49f07683f246ded6852a23944c39ad50cc1e41c96a4f8e2932be99a965da3ac3681f8eee6898e50f769f59b81b2a644885e769461c5876441db53bd371a2f525c7d754ddd825da0ddf9ced5864156d34aa2da21b424ecf0aedb05e776629a78371a3a6b56e9db5b11abad102dab87c9c5a151229fff9a8d0ab8ae68979c135bdb3f02222b2be1d59bf229c868511c7bdd8c1228109b9c933a9d581057a733dac9d187ed1537d49da4110db9901f04b586813cd7b29928d6e98a7608d78d048b7ffdd568a45553b61ec805b2460ad9bc1d35aa10c1fbbae7d136bc79528936454484345e5e8e821ddc688dc05c493bbbde566d10ab156c5bc27aedb77b562fa36a093696a5f6e4dea4d7305457c1653803e95ea7f67c1d199d573431beaf94b88f05000b2966407c85dc151465988dad08be2dc36d7a01240bc4b48c69a8b8b89738bd590a2f853a5bca8a018a8d7fa7108d6c83a216af2d69814155cc40d7ce8f2dd170664263ffe48022a7248e6f1eb4ffd29c8fbb4bf4bca72e3203b3596840867096ba3389467a8f89328d15a122ac4a83bcca8a922571cc6ac38947cf0675fb68c1dfa36893ec2fa45578634fc09b6656f45add20fd86a895cb78007","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
