<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"351e7ef091b5b412f3036bd7965307463694032bccf376b3dd3ddd85e2ece71b13827051ee73cfbed4403522ac8dda5dde2b904dc399366fa146b8232130d9ead69733bb6ea3f49b06d6e8fdcedc99a88cbd31e617af151dcd96b9864f8ac7afecd11176a0be800975a66b0b1d3d50af46b07008e889e6ca1fa8e25510d6348b9ac5f92fa91cb617c272dbbe7dbc968d26ccd5bd0b247732934e91131d033522bee48aa85840f5b4076816fae4bc0f4629ab39fdc9eca48d40fe46f3c0dc9edd9a7c65673fd28e2ea1713b269d98713100493db756024bb56a74ee521467d393e72418a34c4722c429b0ce88951f715fc21a64964488606c226eb7225d93654d2cc98b6ccc81583245c8ccbdf74294cde8d7f9bd6ba6884c6446d7f2b3dda29156713fb69aad8267e0ef91558309d17ab2910789e79d70fa8f458e547e13cff081b1aa9f07b0ce708241e8dd0b0cb006036dcac21a52f8f52df627998a0aa6fd01ef2b5c8c7f5a56bb5a1b7da1b70701fdb896f7173cbfdc606781402b1365285c3c4266af0e8d69096c4eb8467c009a2bd58e12289291350b804f835f783e97d6bdea2d4e1e204e32343e9376205969156e28c1e43a6b2878f4f04517c7c731aaa7a698e85b5ede7777cbebe7bc70c2d1a2fd25ad1032f0298c8657a8e0811c42803eb32baafc8b5e5b5249f1f2dfcbf597bcc57484273c1c9a8a4fd0e0ac51efc59afa00aa938c4f7854de9fce6bd843e5c47f5851f68d212ac84b6e097138c6c9a083e65562d98f5614a2ca138c11de8c5b15b7a5f8450c1323fe79bde6ba8170a25219b93edc231599fe20d120b2fbc6b86c04f8950574648e88c12747a3fc53b3172450708285f175396df2eb19c26287b67fa2ca4aec550d173395948fd18768ebbf8941be9043a84e2af83177937df631d8891238d05e535a4b1a1a1cc143b9e4763f0a76862ca5802fbc7608d91b6aa0392af4f9f44d938a5ab05b7d15347af3477a2e0ec1d6b9cbcbf71fdcb50e15587698cb842d157bfbfdaf73206192b76e6c000b8ce1c4cda770a7c999f8534e2f362bc9a6df5c6c57737eadf69838eb0959490dbd1b6d713d6cb08f487c50cf84f4c10de969c2c7b0f967d1eaa58c91f9cbc86d0e6b0fbccb2b9b321993695ff9206e84bc0672017afebe4d1d0b20942f5ad1771c57b25c41e869719e8f150124843dc354cb53061971f8730eb1709ca12941b303d0cf3e2d645d5b6e008f8fea04503e71651af9b11baab3c95f8797828dc6a823475b486b5321f0f9ebf05286acd78a57c98f79e16d3c6ce8849b8cfb3351eef6022e2adb3db768edd46b1a85210f8604acbc612429f86c9e75f0ea334c62b8f80c4df9337cfa94f964bd0b4570a88c74fad1c14857651080ee9071222fc6c6e6c20c44651645f214b6033ca605ec70d39a70b4eb911b1a1abc2d85033fe8dd64786fb2ee42add86c650023104cfda40fc504e239d0780a14f2369d084bffa30ad018d01bee335a9b8e5d0550c09aef658cd1a73adf06eb14c18732ffa186adc2c382fa3a40aea7a63335e0b1eaeda02fd7ebb6c365756acefbba49a8a4dd07bfdd71e4daae755422bd1e2f9b313197d878ce445ca7a7bc3f24aa8f94e6f3f86aee273fe297d59a8f42be3b14b369b42220c3992d881cf402e3e3791dd33f4fe46f953f34705735c7a946d81fa11234f955180551a340728a9320613af49e0a1fef538fc777679d0d6405cb7fcc37bbaa6a7b4755341b43d2a8211c6a6208928de90b4d13458dc12750c91afcfafdbe0c502d7721d3b9866f4db0e442005cb9632fc9b4a8125a581ea11291bfca2181d43ef685d0616123ba3f9a6fcff26d27de0d9735c822d6d552d26cd5670f10ab171c1cc3e0373f5e8120ca3f1c617fa87176d828841555d60d0ff6e82d692bc45b09817559fe5c3301a0207b451223c4726b6d0f47fe3243bfc9bb6b50773d7df6c591d9015fd5bb7935d8d2d6700a3e8ef69eefe43b2cd2721c296f2189e22763ce7ecdd23fff7a8399b1094ab9ee9a39901101d059f52804627ac36fd74cfc3212daf98d5ee84a75895d439005590568eecc2f32ad976a1e5e69d79ec3e854098597c28931d79fb3d103be60069eaf5bef58bffdaf886ed7c0390ff72a6a002db96940dfa874ac8a2ba01bb7fa3267e54b842b089892f58b4742afcedfd60c65cc302fc18d71fd774534755c19f8ce40aca71ad760744dffabc1826d541713d6816bd78f7755fadd1e5b0f63837e5ad3d93fddc680e3cf15ac3817e7f9795bc638cd2a7822ee512e651a07f51bbd2493f3bce546f83b1f0fc9ae4db5e4fa69241bdf6c1b405029440de626bdcf4b6bb83127f53ad1e5a015a15dee988b6e2a64f6cd5a33904416a1b3a0c81ca03c8ef0f17e11ab3ef3cd93523a7fe198dcc89279c9cbfb309d5827977fca6ab5eeeacb8a7df439857f20c38e527fc4019adc180ef12cd924079619150481a6e9f583de740e85085b3f25e61cb6e8d4826049ca370a6383b513c15f8c6992374bfbe0678448c997428fa47bf2d0378579f7f39bdcc68e6d43ed4aaac2ef16439fb31536a61f4dab6bad99172df62df05fee107432e0136cc8aacbc2871485a210da9fe0429c9d4389c83587a4b89f99a00fe80c0155c86595f2b1fb37a8bf06e88867087e84c4d727fe1e47cbd71dfebb18f2376293f5754b3acfd624985d0602af64b0ecd889fcfdda9baeb292b535bc3b62d1d5623240dd8af1d9e0123218561f2c7bc2d915d232e858de4ec4e8ec95e5bfc3c328e41e5eb394fb27068894aef37169644278cc5d32950fb0edff1eb4f7d5c3306ebc1548294376365e86122ef54c325a58dd069225a394b6dcc592f6f267b0e4bdba889a9016f1808220cd745df9517a5ba0cf17cddc121187f95911ea1407caceb0b9ee31031d9e62542f3f1fa90cfe07c68a461d3b6506840a68244016c589788655bd23bbabb24f01e928fedbf2d30c84850531577656936d76dbc9c6ffb32f1e93b2a688dceb62af063e3dc46df136451c1c054f0dcea9b8403e93626e15b7d73d6d890a79c5a007cfc7e9a81a27450f158de9114e2168488ae3b0aceb0374b5945d3bd9a2b02aed23ffe4fc56dd4b743d8f71e09d746d82786da5dd1ccbd2005367c3e40459fdaee2dd04937f61f5f7f2c5d5326e085431ccb1fbc796be0d72ae5b9ff5f88a9241fe6e0fcc7f4c26f80538c9eb1592fe941593dd7a5a8d45de56f6e91b992c8cae78b0eabdcfcddb282b1816fe9743853d03f494d610c8a78ce04b94266fa0a0afa2894b249d8e5f706b371dd2f96e12b945de5417d4b63aa670aa6771a463d5d8b05f3bbc3d12d6b39db34dd3fad7b126e68bd79d17c4671ded057c4067f5d4539dcd9bd2064fe4aec578e2e9d96dca04ba863adf982a23b0868fd49e571a538983afaf79fd528d9691a62b1076e51d7b61f31826dc76169550165745a1ef3f9337dcaf522442087c0fda387aaeb2499274db40b4f5eaf0bb38513500142c46967f45bcf2911bec763131e8a79d2f2983a69dc5a464ac22356ffbb6368ebf5a575b8deab86eb1d4986285b7347933967384fb4dc31494eec6ae53eeb47cd23e6a8f0826b5b18fdb77e70b3a13da300d6ebd13f0da4af62cdd11b27932986ae18d506fd9eb36547b0de6023a191a189f1a67d84f55691b24624a7dd1746fd5b843d1097bd0220ca4fb2415ff50f24087b61addd5d3e0c162a9c4c0ef09b3ff424069fbc79755c5e82204e03288c402b5504be33d09d04980cb91209c4c56b0e6f1a07cbda000c6ebfd286e91f68ecdec56f72a35b5c65ffa21b55a24a628c964e2c49ea91343f520a46e8395e35a42b72394f494d81de1db2b4bbbff7a5d5680f4c2d711d372a9db7a34a0d931308fba8228c2408769e812ad5e330c84bcc7d15fad84208ec263b3cae2f5da915f786a2163ddcc2a702195469e29bc42aebd669a2948de9602e14c95e53aba71b2ff44a34e68a1b662456ea611a8a118deee13bd6216489d3abfafc9877981e11f82dd77dfe593d0cff6f711505e973d996b8e138a546c51e0110fdd880862bd9eff7275a88914912a0f354d39aa0dbcb76394012dbaff9221899a7d0e1c58ddc87a8e19cbbafa4216afeb9c4a2f845cdd68ace5a55f7dd9768ffc3ae3c8764a1d24930139ed6cf3fbda41e4b04558bf7b3c27892ed38cfb40888aaedbc8bba8e676cb5bafbb4e6e9e132dc63b48253a6107a40033ba8ea63cdcc4353ce9d2e373101d475e732e340ea4f932810d51c8a331159418a9a03bc02ee81a3b00caa023b999de14683d0e15a9ee5e2751f3b546c166372341bcf7ebf0ef0ee6ded33b1d3e5e5a2e5b23e9beeca08b6f4527362c45a990792e08c6442ae8f0961ea8580cce1dcbb499b6d85bbb99a387a462d7daa1a6028da239b84b00ea142d4510229bffdd136518d9c5db42319501278f9aa511789a1be565adcdba0752ef3f8f5a82f239faf4b69197df6897bfbb3cace0965d33ca3cdb6de509b0567f184d6c30ab4aa65201fa6a2c282a2385f63a49f40d02662d7a4f2337d9f5339777b9afcf76bf4393370d05a848b0a8b40f0bcf692398ce2290474343af26ce39559dceb8f9e7a6574fbe42675f06e866ec9e5e5d0c2f9690bff168b776d25710056419d8ad513872ebdeec39b0f6a0e6276074ca86790b13057e6af4b940b545a9aa1850dd29edfd56c62cec16ea369ee001e6945a1d17f419adbd735c11fc02a77207cb6db7916018bff1e29278d9c33a62d4d330397531f2598a047e9d95be03a8ffbd19ca8937277bca20fe1b57183ed81171a0f3515ed8fc90d43662bf4e3236eac4eb72d96da85a2e1a24884c4ae430f2b87d0de44af1af10247c55a0b0f1b90c9faa086532d805127a0b3af5de4c143638f9117bd634887cec9117d97432fb9616fdb8d15246083d03c41c647e144e74993ef52f0c66c6271f6d62f169ca870faf4182ebf1a8906be640c70406b6483d03f9df33e878e3ed366c9808afedc871eb2f129613b7f4a2f1e1faecec21b73f71a6ca7653105e47781f31ea4b7e6b0c1f2582eb3122ad6fad0700c30751cdc8351223a79e8cac723d547318a1d2f20c8324744871f435c06bb1ebeb937ac92b9e52f85a12d44e93be90e1c3fbe3ac0bf91c4436b99cdef0b4b6aef357f45e5a4cd288e72f0e6c78bbf1741c00c346ba0b7f7872c90e4d68a7fa9cfeabda6bec7f72ebd0512371325a016a2e286ea87876c7412b0490137450299510c3e1743e5d505237f209a0157ed1915940a0dc0336be371ec1f5a9cfb41d4f861bded2910bbf9047ea3793a7abdc3bf22808ee41021551ea4faacf1fcf7e5de03a19d108164a51ba43a90d84ce233c9587e6b10c9271404a95d852d9c810d9921f551263aec02bce384b23b218e31f348302ab1f7e6ec9c9c4fa7aec27335833ee15b011764fa1a175e358b3944e7944439f42c3d86152dc73e8cb1d68d471e997a56cab6a3826f71e46a8feb07886bac13e46e8ea3ec3a1bc744d533b3634a3925f419322f652b2f068781e5d9ebb33f2c3861517ac1f0b9fc2d3b52a36f096fb45faf6d623090ae81d748917a9be943edcd9907e0c6acf2662155a0979a03573196baa020e4441ad9c00acb83033d2fa1cc6188e3f135458eea363a45f4979f37d5a118227d4b96ae6478a9aa2df87528fb0d91c8ce8e37ce154727658f9480ff97e97326e5417593abc790edcc47869be8a008146fc483c331d558cfbbe66e1fe6ddce286ae63199beb6093c0ee0889b892b19824ce7064ac0bc3f6ee4c777fa9ab080a7b7c20862858d939ebc933eb87106185b0055363b637ac00fc9ce46c39b9745b1d1b9df0d273478b30cc1b8ee6b508d30aac954328e7c430702140bb0be75f1c5bb4070300bf2fc48144878eae2103f4d72ede9ad44680e4614dc7c3efa69c77b7f98bec86d98a6b64ecfe86e27aae5b18a132b6a1cdb667d4610181288dffa607d3663ac8f696e2bad529a90a332d8427a06558ddf4d135deb51ef269cc8af20a091a7dde377e6350ca96cad1dad7c4c796baf410dbe6e08bd69d07f63cb575dd3d3baed595b32dd2bbcd8825d8c735d372db3257402e9fba6d5908d3c268d719c0dd65c404474d9fe907a3866d4d05c44c407e87d4ed460c60593426f5257ce2e6ffa5972b77b9c0010a65adb16c917a64a61d078372603aa20f97a4896fe1df06f65be80e884f9720b10812ae5ea97a32f137b9a5f7de95ffbe5ccac82dfe7c46b98538781ac7d6767eaadb4c40bdb52b255468363662352faf72028678a6a34825a4b6ee8cc560ac5d9ce81a1315c8e7655f83a8058e9504b104f2ae1ee610d0d0440ba64794253841ecc1091d52353d9a9051fb45ac3d8ed047b2d8c0c03887c0f9908c01993ce6497faf3dc9c0d73639439dd5bbabf586cd43f8332429fac7665ddce845889852060a2a822137904650ae556098717ad1c30c9627ba76e7e1239576088bdc883830bda13fcbbfe3215872bb8446e909ff4d55f5e96a8f2912739dfb8dffa3600adac97661eeb16f80ced060086383971067fbd3e07f51b5faa684261f42669e97608afc2ef56bb15f854b0c6dc7ad91d08b9022fef045b243e66cbce83ec291a6f9523387a3c7faf4468525aab0ceba120f6ffc3b05eb7e70d0c894c4d99872081978c0e797e5e6167d2df6ab779ab6893b7e7c640d43b58215dea4d13a95ec8781448f6e28c7eb02049f15047bf6bb49c8233f31058e27d81d13ece8f1bd2d111c0d5835d3aa71069cf5960aefd4e71e5375d388cec59686510231eef11d51baacfe9b1968f0be7b002122d58cf5a58fc2984fbc573b72d55011745805ccc4d097b12a551b3f18320744824340cc59c9ab014890ad8e915b90223c63c6bec673ab3951b8df97349abd66ad531af57a8e7d4e421f66373ae0040c936292856a7fc0106b77727d14ce960a400872e9118e063df8e38c7559f2a79a01364a3a53a8dda3090f0da42fa4ee13df2ef5693532ceba3e19c6799bc9765d8149b43ab07012298e1b0766912886f531b0fb926b4ebe3099283010f63cd1222cc1c6a04f92f770b5935517ed41ef497357e84e10b5ffde5a461b8d603637297ca00df8a6c24b42ee01fc5d565c4444c0572f253575007e6695a73f39317c8f745d940c664ffa5f26fba1ed3ecb2ac6ab7408f9571eb12ab4c91a768f287405bbcbc4276c047de9e2e85062654f73238a7515ed2456fc0030eb30f065fb48bcf583446ed2e06006362b7370c2f58494d57e0632f659f47893be17999072afc4d8e09b0a16f6b20a29a187d554aed740c2fd3c92b4d71a4e81d9710cb2de2b08549ac11ef6fe861cdf02943e412fbd07da2cb1eadc3e66d5c8ec2e5ffc9b43dcfed912b881d9dfcaa2ad392b34e50cc6db64eaee7bf5c9fe6feb1acaf31af6da5c5a6c948e371f01f9acca25856214609c1c0fa8db15c72a8ab342899dba5072257a7960b422f6eba87e2be77acfcf9581f092c997d14c911ad7ef19bab8ce8174e1e76660f822194a74f762481e450af9a656163f6e9ba824f7a9c56543f143849ffd529c654de9b5977114ea4d4d2f72a4fc0d8e3e02037449ea5c0af44a4986da6aac3e78e4f5e35a6fb557729253c6d290e9c998e1a7d4b9947b7cc1409250eb73b0e5896499bc6e1eee62d02661c70e3704d993132590655c73f9a7de1afa494a362b82a5d93f5b13f3cc440f9a3bd7884bd8f70058e89936f609c2d0c5dc1c0f910f02161aaddd6138b12ff232263608ec7c0510db5b8da46a3d708c7c43bef0927b5fcc04cf0ad8a5bf3b5e7cfbfa6f8953eb446e6af08304033e31920ac328d08df07626785aa837b774b1dfe1ac2fcd7a3efb9983fab4cda36b15d72cf2dba98cde3be1c4cc1e880005bbf38930b061e75e2b229e32cf9df781f95584141e73395070bf5e5b2c19739e4279a1954b0befe5ab596a9bc5bbb804390609ff1a46566432fd5735b272e017a21d1cdc92226aa131025f93a577cd26b4eb54fa66f169762dfd61ae835cc07390a7370dbc90adf0f7fd0ab2bfc83dc23232c1f684b007fe91a3e390e769d02570f1722e579eac571b2febc04dd4d0fafdc1edb4b07092ce6a23b7db43d6deb5c8b4cb94cc9a21e960e24d488c85d1bb37f551aafb43f8677cf29b62ac10940a14da37bb6d7edc6f63cbbe20886284e71e01e5e79c789dc7142811711cb3adce96ddd32fd0cc860d6389ae47572843679b1353549718c9d2148bd362864288a0a2ca96c08d4a96b58d705815233679304afc95b4d30aeb1530f7cca5c07d005e59b080e3e494012fae2529349b044efdea46f5536e5f59c509914ccbc610c427e00afe280e21762dc0f3774eed42885ceb6ae18e1800491402f108b46c6896293e9e6e55994ffd127e0a53a7a0310d391251199690979df495505dc6e6b5613c59f628bf40dc8ad2f811dbefc7559061b418c542ff100491c9eaa0fa00de977d0024b272c11d2a0b10bd85bbe48dc9373e081a6cb20ef9ff5df2ef6eb01e458a088cf9f9055802acbf97bbdfdc1c6757073300e7d4fca75a131865d444b8dedd6365019616cfe0f2752d6854a80c7c22811f9aeb29f72bebadf8b964f314f64eba07f728a063072864fd7e597c7d67dff10d17ab5a6f09687d8a7530a38100ec793f33c339018a553338f82b78490f356c5d42f8e2d084980f94414fce55e8e8f9269700b533243192b0089917c2bbac14a43c148bcbeac6e407bf8399f7ff4262342958a7303f354eab8d9113fb1e167571437e57c6f3baba057107441efe43f3833ddae4041664649c09f53ec0571fdffa14efd46ed2c40ba0c822d818b3c9ae490a38e91bc680c3f9a6cc83627ad78545f1f4645ae33215713d9966f20c28534e4ff0fc6ef26465a4f090ea186c7ff478c3a0657b887d23b39c94ea8e2d43374e1040063be5fc124ef92ce23248e1b913e1284dabf687897d6e78d60219055adafccd482b9f3c2e832f6acb553503a929bf72edc658ded2fc533156cf3a9eea83e10141491453add9c1090a25f344c6dde1e00224184d734b1e29acf5e5ee0c636c16b033ef457f5f867326b20e90c394fb21dd1179b36dc2538061d129fa4835cc08d3d8f4c449c924aa9ec273bccc9f8ce36d3c4935fd2c5635f96cd6e59222f7664eaea259b8c6191ee84b7d8d0ae70acf7c2756155ad6cd5aa4ba7580228753c7bec209ae3d826b8605c82a0d580a96e6a46892ce0eadfe95d04bada81e503861795e0ea8c6ea6bbd3493bfaccebfed2eb7dec1875039656ac02244d5579e9c2c50ae749f7fa448851a8534322bffd39190b8c449c92e0015252139bc6d3f6b999c8217d9a4e2389b664ef102ad1134af65b72bec93ec4fb70f4de10e22399463624d64c521c13f531bb999d823b47c7dd092146891b8363d76836b00c28cbaaca9a16e43f0f33ac7ff4fdb76591b3045c09b20f6b836b1137afac54044e07b16b4cf4121689037475cf2f1782ff60c559dfaffcddf978ca45d9487b4479b295e46db4522d415b527b11397ea5d945930fc497c25eea87931f401f90efb950b7edc744d9bcbd76a2badd5a5ce8ff9b27b51c35b2037b9659f27c09361743003a84404d3da4485ad9da0e03b3b2cef1345086289a74e627f92945c4b30c5b2528a4a0a30ebf1bf0b5887c1680d917d7c9de8b2f0ab70911f9c69a8cf451b77a1e9972cec372f488b483a920d3a97794c461187a997bb336263751165e4d967e69933c3c74c6202b559d298b04817ec269951d85b98f9e0f68c8cad4a3a1f76e227712d9d9e28b5f85433528c08d8173c80abb1718774b5f04932e37ba24377d1bbc9906583ccbb84cd26a9c2c083b654002e91c5bc3eadb728282dee4f91ded404da4f427a29ebb5342440641d7394d4bc548d3beb9c4bdcfa85742fc6a2cce6e66ac38e6887f03cc6d0f3b549bb21d261b5d500fa5dd16d999b9e9c2f9de0ac9ca389e8120a3e3979b7411caced578a3de1c964c071a62ce6686f97b41780fda68d9f704fe6b0fb1bcc4ee0be5bce23096f9d82c1e39eb4b88e7b6afb4ce09083545f903a5c885cad63943b3dc5bf885253969745d08f4d8d0ac1d2b17091f0028548cec15ff2c8765fe7ceec763dc82de9fd5dbc83d38be10dd02cf372ab677191515b78f7bf36e601c370021e7e8502748d971c8e5378200a00090edc7803d3cae7e4f0c4838f77e8c0f70a7cc9ebf92d20f3a5cab6ccf8222e78710b06c96db2464fa396f196c9e45d56e6c12f0404d9696a379995d2164e89960a324dcdb78f52add8439fe344d66bba4f9cebc80d210c7721d863926b670803e9dda4173f6c349ea2d6ed2778d802e5381990beff58d59bb226944ac9eae399603ba9ee937c84defdef623b407e1b071444555a4faa8f0be7e2784292342f05b09904d0e162d3cdf179f7cc413f3a85182fcc94a2eac024254e76b04f555f15ba2f5230bf997f11e4b72a5b11e2eae7a86d2f604826dc6da62cce5acead3c4b2f5b85902923e57c2c30ce51c874f23641bfe2475cb33fa8a87a5c779327ad1d1655e93d8076893900f9d7f3b34678f9731e3a1f36db9420b2a102c2b9aed57cfce22187a2e606e5a8dc9080ffe22dc099b205e9b21350d7669ea883383648422392c1c0f7713b34e8d810ca79b1d8707a3c34cabe20685695f1f816449c29e9f3808428df7992b830097f47a99da6568f24eada414bf3bc16c1b95c0e8fc2b2d0bc29267786f1dd2999d0c1b97051a63e4bdd370897a1b798d1060f5313ac7c830445bb053684920bff96431dd54e13adc5665a07c61f0ea386de21e637c2b17ca5cb65378e2468237a8f07e945a97de5185998cf5b9786f4fd26d3ed8b19acc9898049db9550ad13a22d0147b6438a7320b7542a9145055369ae577fcb5624d86c33f2c6129761912ae29b48f70107dba5e8433bc62109a6bcb5490e1531ac7f3aba28c32a00926cc1d5bcef75de83f732c399ed699f6a3dbd0b5aa7cf8223ec57fb0a13274c78948825f0987186efdcbb62024cc3223ede5d98c655766af65fc3252788f7259f52f5346dbe578b79e648b167f94b13d8d35ec667f52df72f8ded7817e221e835196f5cf56561527e2a71a3f5740ba91eba55cba8ee2b2c8ad44a8e67d0c12b9820dca0da57da166f8fb412732c9d90a74a671d4604e66e8e0f869d4f22567e3167eae55786c5a9305a599eb0e767071f530b371906761e772d6537cfaa5ccd7c8009d0e5d2329d6d88d66b55f866fb75e6426158abbf67fc482ea50f02a37a32f9bde7052718ce15de5826e2b2989a802f19b90b2cb89540412e0b66635b826ee9be48b703eb15aa1d10e8461f321a03a7697e1a2235f9c6afb361b5b4d40f9721efc33f763926114b5b0a4df93cf2e15a2d2bdda3144ed8e031cc6ba97a45f16976b93752497df9c54083235bface7dd78c5a3f2f6c508fc7e0a4fd89989ccf15da6ed1ee962509f599515584cc7ac34090bef0628bcd058e26b3118049a6e235d196ce024ab4e9e08155c9c6c52a9604539c445b66df283c1774de8a9c14de786c46ce92f97e4616d3c2fc2ba3d543c695cb274ce220f240c2b3ad56ef7b550ddcd709d045f0478aecdd64f258047b954908e53878b8a9664a504fd71fa39f9411e6a531792bcc2e01f3fe8a1798717a2ab6fc370c3668fef218396c7c51b7485e07479a509278678f153876f00c5688f82a4ad252a73b54067b2b33afaa2f9eaf2508b59a2ce6a42e17155f677d893314f837460308c84271f9d92ad8c4d67e062cfe43dc470c5bfb912059fafbee62887757281a8722b14092d8575402dd89f46d363c61dfa2b602d221261ac7d1e9813c1b31a6d57bb80a6f87d7ad53664ff6cbb0eaeda0c1e9a65b83a0d3d08e0bab86967ba9617f80425cf001518803dee9b40097455ec51c5cceb5509613bbe625cc7f30a9171881d6ada07bc293e6e3333683447010604f8f2c2ac074bc4dd78b38695049a8cc94b30e72ead9bb35918ea9e7ea7181d9e457291f32f664e03de2c398fc28285af225a8db6583b5a52b0e8ed600cdd7d918fe5b397a370de2fb69abe397c898eb5d266784f7235dc81f85e8f7d5fa1b971d611acc5830779d2f97c0cfc335be6105b80e392ec8abe783c864d0413da61af6152031703cc0bd809ae1bb3c69eab3ead4e7068db1543e76bc13fa5bd7e02720f15b4b254d8ff58221d5e3f13aa4b3cdfc482f360f762da26feadd3b9e57ac56054310045c19a58911a60c923e34221e6c920bfee9c68af0b219d6910490b1fea26771a130ab6178b1a5ea9b7a0932","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
