<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"36f2c58c824ac1cd087155456518a9967c34875dfea0f2bcb6820dd191f6bca98dd77c023232edcddeb13ad5191bb8c84fa4454168bb4bf2790b9d01ab0cf665fb5bbf93ac92278f2944fad471bed7f8f31623b2578da57b64ab382edd7de05417abb91495ba89a396d9c19ab4e276a7ac77f6891c2a06fefcda649252f6fc7456f38832d7bff9e1ed42d132d51a5915c5930a5146a0357d764be6b91e5ed283862acd0a53def066ee757bb18212171de2ef9695e3185bfd9589fecbe15ae1d4ef0e42b1666ef8d282a8104d8561eb1a162dfb0a6cd72d860f98b3279b01719d9b1d46c44b16616dbf0390224b14c38e4d6ab87f72b49c7fb5d643272c89d7f3e595ce10dc2543f72c53e85920000004327bed619c9736d7a36e1cd2f9068c6937dc0de9f1da5ab3b32b7488a8642894cd90e96f4ea202e501a76123fb7143fc328576008abff9afe5ae0eb35a43c189c4b04a9b6a69c8e7b787ede92c5fddef1c1b0e7f0bdb518d7ba70b7f2f313e384fdd9286c2484ecea54017479d0397e85bea35b3c853af0367b607bbae3dc214070d1dde4d1a20871c26fae3da7e71e43dc0e56cad79e743a5140dec927be41da4192e19d34ee7c1e9bcee2cbbd26184e1f091c07f032d43753997138822958b3a10f3daca49b06999c012a0e92a05db3deeebea14a2801153aa6ffac7ed4d12320c20efa492e5f9ebf23c6ed1151597c0abf26c7a09dce493867f171ef765075355eb987db0139697511b92e3f7dddba027825fecd52d196a825b3e83db684c153fe9496e43a545a7b3ca67ee9cd0945132b7341fed13e313e0f8cc71039bb31b7ec8acdc1834d8f82d16d30800e0a6d715e590c6a994f5cf59c64cb4cdf33e465b10359e03f963528218033a01341a14830e12879b12e0b5b623e98134c1a26cc59a491999e9f9845a70284ef83aed9a8edc6b5b687799ed6dfda36862e4f6ef85460c75006619bc3e3a968fd0324e43af92a19a8cb2c92aa3aa4f7e8057b75cbbe2af8d22a024ce7031f135ac6d4892a1fe05d671a581b84bd5e4252898ec5c5d87778a5839791a7defbe7951655fc84d1542596e4c480dd554a631cd752a229938f7b719707316dbed275b157bf6c58e3d5d7570a56961a2446f0c16717ba5cee7e01d30a2b302382c1d328b31ebe0168e48bbf5bb8511823a3df3b7cc47edc673ca02a38350a9a7741ea1d7a275c53d518c41cc0a8373ee87f405d3e18e456d9de2d6d301ac3a3b26ac0494c87b5fcb0d0621a758a54f3a74daa958e8de7c8189117aa61ec5b7d74d171662a0a1bec649f5e28b173590bb6d4a23dd1a362ad9e99759bd7c3d904a65b0739c32f35a5b8e5e0035ef54311861802001f1cc71585474d68d7fea2d8faeded939f9d23aa1e013ddf472d7cff2aefae09d6dc9382a9a7cfb2e5aa5e3c50c44f04d2f09cd7d9dc0578ef4b31f7bcc85c1ffe3d858e7465939773d08c0c04ee239af016daf2f6e5c108083694f98be6f289572002f1bb838ecd1e008988931cfe73f63b15651e077b2f7e43ab434cb8322fed4edcd6034e8c9d836dcf4a24c7425844cd13841a91119bd0a628a9bed8556ceeaa2c6ab96dd1436a2e36e8ba45657cf9d392575ef82e3d84d0f30802791272675d2cd9e0b35d04fb2deab8192f670f85ab17be55fb94d016a1db83961aa0ffed1c8cc13ddfba942c7884e1bdd8cc6ec5e1902440839f20461f8ef73ef8c1e95d9ff114224bb5944d6e32ac4576e934c937cd75dde436c952c4a9d5f4db90939ab990c064bb0218ab7f1a1ec3cf9430db0613286e3eb589f687d8500fdb85607a8d534f6950c82aba5af8f1437479da284f44a6bac0fed60d23a3f47a21c972270bfc4c035dac686c1703a3d9e7ac75293147e7bc1073816c0f4b050ac64a324e01da6864bd51decd54e0468bdcb88d3a6f0082abc4a15f6fa89298d96f7769f2fb1b1e1f8d1a2d0dc03f758584495fba0e4da820176dd6ad6ac431bb5d6dfa6fc6821d84591f4018de63cd939ebffa8fa90bbb41fbb18b5ba8db09ee9511e4181d16c5c10b8c44efc72299a4337460ef5c59c25ce8485008c49774c124b6e0dfd9b7051ebf55ffe03b510c83026d5357343d3bea72a7db9542696cbc24ffff04527daa78e757adfb274e9ac57514ab1888ec893bcb865c858edb8da1c96482d8542426ff85d945db8ce42fda78955be42a62f800de643de29acd790ca7bc128a4c73ca00ef17f4f2f74ad62b9cb8d61e5ab3c66ddb517ae5b389eac8de8b70a025e0b896ac01602a32185dd68a321e13e3a22fd1dbb4a38e9ea821a7fbfed489369173065a30cf910f1f885a3f440a3ac948fcda6f83f1738eba2ad4fcc78b5fc4dd06adfb6dadc1125197c6fa7b8eefa7658acce3c7e73b840cd5aebe42dd92d4062918251eca950459d14bfdd1fceffa75fdbf74ffbb9e67e2e10c85e04bee0a0969d85227ed27f103157b40592517a85bdba2129f151c359611802897f6020795c5458b98d3642822f567b9d13fbaaa34479f717045bff7168f10d09b24078a44b0ed1437512b8b9fdfec76189ff6c6d651ffe3da98ba4414c6b7e53d34b80cc95665a760728ab5fb9c49f9825c6aaa64d3aca0f2b8feb417c9846201dfbee8127e8f097ebe315da11fcd86978febb2c7c238e5dd7e54f7fc6929491d81e32aca55c633bf5b8046ba16f784eb29b3f40932b5b62cad97b07470379578944cbd923e36221fc473fa2dca0d2b16d4ce89ea68a22eed33a2bb7814c85907ff01f287528858e203a8b64fe76c438d782e06622ae93b2c92849b7f7298708a18e14670566d6a02a1b21d49c34bb059767f91ccd4440f23443682c3496f5f38e7f69d61aefa0fe109deebc6d473876791c926a59f26f28fed2b5369bf2ed10b98e069a2b2a6a8541f2c31738558ec93d3c5d9964ca33e15d99ee8d648573aab0cf2330fa84dcc97a81668d9478dd89643f47c4089834fb26e7589c9c758ae78866ea00b01c357c365ee3de659d6d1fd0a420e67a9c56efe62cd962102938ed9fd2459ad3d3f535d664380a6bb3286814d5a09a62b1c66c27d8a6b1522cd8c3e742b531555100a34129de42293d24d5b25f8a59a2d25279e856106aa759ce6a02cba8208afec09e2fc67d0fb1fd4b1a8b5c950fe0f051f58ceea3f6d87184a4fc80180db3cdf637ba9bf997d1b02804986e745e1fd52df67bf8273f94ffbf2663625e4f6f9a414ea7512545552c6f30e8259a1ba9ddc7fee2a8ae9b274285c44272279bbe96b6c64cf988e0910757c6eda04aa0b4e729c09ba4f5d9b599078567a053d9f646127f4b5b70a0c6d193a37b44b9513a0352bfa2198ce61da9007a5d0d9c12bc9bd993f1e52aff12d7a0043abd3e355a70235d6c9a15935a04f72c3d4893b4d3445ed3306e42aa9f5af132570b01ffa7cede02a198d00c09a75a82fd0a2e2a0222cfca029e7e704b5e7e57221a2bb94c753d279a0ecdb1a409837d918b482aaa8ece09dbd729500d40b6aa320825f2d2b81791e5457d668dd1751f348330aee38dfe683b07f5d30386edab834000e020533222c0479e1658c83c37995ba6f4d4d552024d772891ecfd72a53042d12638f3b6dfa309dea7a5ef084ee8fb3fe15d943a400fa49a60d9684eecfd6a3cfce4ee8266bcd6d38a28a7cd3b520526373ba6fc1afd009cc6240805b922fad5c793a3aaffeb412d68b958a25f3aec648bb9e2f36f3be6231123f5e966bca78beebf70ee7b5f4af0d28f314b094aca3a944b182d2e0f1e693b56c3b7771e57c5961cf4f1f00fa2008fceac044e5676279cae25fba5c0ff760a61e5d6a4b266079c956cad58c5d493e3715a2a49d9ac8c23765421e9856491261ce0c4a92a39f5e33b3462d37fb8acf0445f660fa50cd48588d69a37dc007cd05bca26fbb6356f1e52483eb2c7c9ab39611586ade4537a4e43a183746cce453bb0f0928bc048f87fe96cae5292fd494c10ff2a1d190ecf704d654fa0aaacfb3c44bcfc05062c06fb50dea6c9096153f4a32958291c27ce7ddaaad729a38d0aefe5eb5b955d83b75debea88304422c5218c46efca996b2f31e1cfce5608ce3d4bcf8f6104939091df1633380246c91de5f23adc09280ada46716d72b23e922fbe9e626996c33759d56297bb65d1c656d6970ea69d471928148d1b9f10a7e32dc84f8f6029062820faf0821a81f024ce499f5989328d43533b9538b877f0be3540e23d6970dcc8da6b6ba38038a1b13be839f94d45ab3b4b60f4173f048b455943608f08df06acddd8419de028213dbe3681e9baf62d5ebc149829b1c1bbd512dc69cb8211b9177e2365dfd7df1dfdb449d8a2c8858df582b20a2c62bcde64d42258c2885a0799685600051736313b506cf71d62cb43b14535a46d52a68a4c2deadcb24d9ce07a836931c97e3aa8c30372fe3133fad717f5c8890c68edb45986d1e81a1e70863fa1b937937e43e68e6e4ec9375e3b07fbd4d217e6c4e5781789876b93e45c7151327391a78c3eb80746ba61f9a05ac35d357176b6e1c51a710830be3f1a8ca3d8d93b5856f1182c29fd20f40c919e57bf46c7fa03af3266bd8d0c3ffa9492ce9e0a7ad93ced1df7c72c15dab076ebee77363b91cc7944c9c283e07c4c713a8b3e5762370980e0866fbabf30f61b864f23bd86c486399f741eafa7f5b9f4821b8da79ccecebff121f7854f4e0f103e3ea3205522c1229e3a88bdfec0ea79088042625eeac92173d206282b4119ad9c8fc5b4e3c1964326a16a91d3c507fef034161c56479f455cb84c07e728dd48a08b3ec838503185f88d4cc32a1cca4f24dfeec36920bc4ac6e929094ae96ccd790e832034e529278994268851f61475aa46cf472e6f96c18543063d37688e1f50513bdc5c5a346a99d81e13db9157848c6d347f152ba39da398406b9e130c8326c095d3c0a7a6b08f8951a6e912ba852c6cb73f81237f2cbf27067cb292b0d106defceba748a484399de6ff4b574ecac0fa5cfc6a7f50fb176d3be5e2ec077ba71a773b0b99015cb21cd86fc52d65b4af4871ec94ad9d1221b46585e30ed31bdec9efba2aabe388b2a8071ad3f6d3278b2b9270c166e465daac31481d9aebcf6817ecff31ebba967eb13981985574e3fd84b1ce11e692468697ad65ef99de254c4ad3401939da553964f5099ec84b922676b227f6b389c1447734937d1b2b6589fd10561e73dff625fb7e1394a206c4bcf38ac2aac88290ec6ad727857d75a8671af8fed29c8945b45122ce200a0fe306338eb7de99c748c8fe1fb3743d02c32bc8288205a31842dbd433fa1f9c503ef82c2694cdd09c8c7fa459b959f5bf79eace9bedff1e436a8642c49add5b0c94989d0f8885e906d94384f703442b01cf2ff5ecdb26cb062dc81b97169e03eeef1539a12b1c5d60696d9dc8f71a7ec8e18dfab860a734553cf7c2cec4995fb5969da8f8f200a26996e454b3e382a16cdea4ed9bcee47910e39033853974ed607296f4e70e49131f70f32092c06d3a51c76a348176bbd67557ecbdb44d6f910839a3fb64d39a40614bd73ce2183cc2654221e70883574d73d0496e617e52f74a33a7926e6233c2a88ad9f7541263ff10b23c9a4615776a5d66be30bd6c77884abbe004950ec032b330323b4136199b52fe7eb9cf04b5b29e2dbb0f1f46ff4fe9c7e14fe5797d3513acc899a919add64d2df976f4d81c3c68234c450e11404c2dc5151b3b250d566cb3ac14540f01610ee2d7332e3797aac3ccfe57e835c6513e3af3e65fd84fde147e127fa72570a8ab3279f5b10783c2c39d9533b440f1adce261693ad950ed43b5aa3b63b49d9b1723d9a98b61e433ad3eebe93a7b73e889408c345b59017a641f17f2c9ce282c18662766b57b1c8ac5235bfd223070b4d7c66fd046d5519cb7dcf455ac5032e441527eb805583fd8a77006360ca68d26d99a866e488ae50c978b10ac6a207089af01deff53ecf63b0cb34d8e691f33ac9b4b6920939c2e815c49586e3e1ec940c01c0e9e1e2acdbd9b1695318d2573397cca0dca0cf2395287bdfac2c7aa4d0feca2903a2290799f10f7fde42d6c10b2d6d354c06925c629c6fba53fedc6ab102e6090a6eb11b6ad0646c344b9aa98260637b96d1bd986a32bfde178eff4c7c691af89b9b6ccb21850f9f3548bfaddbdd33d382aedfca069b60a948c71112cb30882df14c1172be370031e2fed1b8e4c142212a6c96f26eb61b2388a1d99dbcb2f626dc9d09ca7f6dda90c8677f43a0835f0b354a785f4d2d17e1fe453544354c00e56dec2a9858754568301ef7c67b7fac4b15906114d24346c160ac01e7cdb74afd4d1ac60e36a864921a9302dc24d45adee26d33c01e52ee91f004eafa27c3685064283f21ad6b0bb0108b54d0976529f720144941fa7aa6e92b9fadacb93816cc260ed290454fb527f2c4388f34fcb34428613d2f0d60328e23c6b6620025a02f2740a24663b9c4ec9ac37fdd7c85881b3eeec60c728cc361b73f6b2dfccbcb1d85e3019d9d1e68bb34e244d35308872b16e9a0010381710c4337f8378d6a871a91976061a9c34751aaba13fe7962fc47af64a1b1d94aa62ae68fecbe23399953e1803b36f37d761c0472ca9cfbdae5d9ec2fe94e0aa4e1e1df27689f7c584c6489757f7cf85b2e4c0e339f924815ab1db40999c60a6ad844d7b565fcb7588a38b7625db8f4b8f709f359bd2818eaddbea0aa48908a127bf9b2265eaddc8bba993376570259569096e17164a75058775670bd7902f961f33ce9b1cfa1bc94f60f8f2e80142d743a0769b27087d8a76fc7588a5f4cf5a332b525fee0a7fc833e16f383e640b00149c6a3c49ee6a33ba8e34c2bea8560ce2565a0cacaf3ec5bb635fbcc4701c00cd3761fb69970c63fa373ad2c6775cdbbb73d3193faa0a6ae16d65c0af19723f027ab13f74b7ab5132ed2e60610720180a55b919a14a773712cb9f93c13ef6e9e8cc9a0cb0df162170416de98679501620d842771061cd691a5c10af49450ef45baa1263af8731a3984d7ca35b9ceb1c9d80d94467f717f991a7072f7696910ef1bc62a34dbb2f1a7753729309bdf32d101b12f6aefbdedd677983b104585d664001de776011becab62c0c245fee1258a0e5f176b74d4123881672b2f552f7e9f2234dace5fa6fea71f2de8d21353ca77377a26707eeff12a7c2cbec5d9bce390e4befd722481789ac333b0e9dfaa25808417f73d78fc8de20f4007c2eaf58b0a0908c616a7aa5685f0374b721138dcd55c3df0c00c87423b6db4210d4ed7d8f826bf81f998d0fddf45e70cbbb2dfc6449a7e86bab43e0aba69fbbc4c11fc5e9cb774753297804eba9ff9a0aa8e53ab5f81eb0de2205b1bdf7d03666794b4a6130dc413220ee77fd798ab4e59a71f9e31ae06eff76a4385b35f8fb2623e93ca4631af24410b7bf90beb840f3432b6c088db6354a67a2024f3e10265eec609de920dbb11c3b1afaa1a7d3e35eabddadcc638e255391117da3df81ca4c31befdc188b297571e33c737e23a7d26b35753e5a956d6afe08b9fa426cc422156c3336fe0d68d01ac995c038804cfcf4184c843f87d0984b31b387a696e0389b03cef9331081766b90320e309378e24175422fd75f6f25bdb7f4d28adb0e25955a16701ad167369d30e2ca70052e0c098fff8f89236ec965defbfa7633b03494e64da8b6d01406cc52abb137f0578c64cd4d1c8b08f968dc189b48f93a80913ad2ceec67f1f6522d36ce77f4a6e95c4dd765ae20387466693f84a0c7720d77aed07623f0914a2f5053673ddec598bba04d9bd547850237270557dee43233c857cda492aeb10449794d74916eb3926191da44946888635f1eb6d881bf009f97d1c66a45570dade89ef81d81e661ac6bc276a8312421400e528aa86b6e59800599d8212ab139da181d314b04ba19f39c9f2c28a31f7c56135b64532fd459e39ce4e5bc36d19c660d34b540d08d8b31b082a3bce40e3e0a91db35c768f6f7378e28dabbfde1568978e908d571b5bb73e11c3e623cb2e230388ed95bca44156e30184893020b8b35688e064facac8d59866157a030d788d6f1ee914b139fe006ccabc6772bb1dabd0d1ea86cab075298e44015c24c01f93c509508611a67a2d4a280f0214f4b67482c2e76e1f40db831d5e463f7123733fdb17c1b324468f69293cf9aab3687f2fe0cea07be8f3b3434febc1822ffccec0de312d5b8313eab676fdf16002c88965e0fe95fb3297705cf9a6d2c694b4a7e86ea05bd6ecbd5b5e44e0df16575ee18f23396433173b89d73c076f346671e272be6d4c2e4ca4eee2289846d6951696f753890da435e82f433f3a77b458d4cb318057a225bc8144dabf2b4ed7d9cae45eb35e2fc48e68073a91676a5f7591ded7b4147ac385e558e411800fc2932ab574b56d073b517a87c01cfe7c095497a61db4f5ad5882e5cf5f54a649d43b6e2ea011d702adeec25336aeee220091b9fc7cd864e8f329c099baf7ba6bc65de3fb624195e919b7eeb6f3a04d3403368f6fabd47bf4b59ab37d496f03c9e7aab5c9e07cf454ca40bb0236b583d6eb976d3856972dd607a940f177ef6e888e03fda8ddf3a8b48301fd546a17083f52abeea1378fe59550eb31e55cabd37278d26de74698858d8129b49a25b6d76d3992728d097fa492ae1d5d8e355db9b96835fe8a485bc5bf8599f0709ea32b5d4c57d781bd802beffe04d0f739bead293050990c23aea6c9927b13822db0d6a8523e64f7527dd2ed74412ebf1d18c68b76fcc26571ec172d4d04ad30d1581ce1f8e20e23e9eacfd6da75d51b3316f8798cc54eaa94462ddf3031841f25ad4668c6b66b6b25107b4d572359b297a56896e7c3d350f1aeaa6ba7ac327a740780a2c23b620d3195b0f3f866e4905a32b93e22089d9706e0943c69494cef16f156c278cdb774c4f001df9fc4124f6c6be4283fbae45cb0996a03b2a06001841e19f829afbdf914c29518b0e8a095ad602f72689da6edb6ef431c9fc9e36ca663c6f3ae3dc81c55207db994fbb1af11bd7682b8d9bdcfb8a58cf98f9e286df1f406d316f5b2a258a85113ac198907cfe438fbcbf181707b38968ffe50e70eab20625da279ddff123ebb9136a228f1c61c0c3957c9f2283f9d9999916c6c5199b33570df72aa221f002a278dc7f2695ee3c3da54a0057b57ff04c4dc406db10ae61f16d549a7265937b8d76ae5aaee4ba24052c3aa549fbad92b46712233d09abe53bc0af384a9fc6da776954aedf444daa4912d9c3080441fb05d52168ce802a3e754b51d9346013b9778f974797f333cc2cb2590c256feb7111801137a572e7aabb6b640972778d31ffd8ef1b88c1755b5ed56ac7954bb3d9525fc6439e06686a119c321fa8a35d199ac921835adeffce6fba02f34b4f24a31135d4a3711b29bd80f3ed23a006305573da108cd4620cfcdc24c2eabe5b4e794c901d40d40761fc42956a505777a8cfc690c56fca65352080fbbffd04981a6343372677b3c747ced64b2c88e85e69acfa68ab3cf17318890058651a8fbe5cfc72f0fac779c09758035eaf8203af6c687495c5b6ab22bdfedbd6601bbab576488311ab932d8b3d549daf97e2f542e8f5854ee03238a560c6ccc5584aa4d88bdf5e8f30c3c932271a8a370dc226ace4d6b9aabc5e84d682d62dda88bb2ae169aacafe1c6bac6959b7de49107b5aac655ac6e3d91c111b403f1e19ce4c10df024844a288f6e075f00082e5dde94ba4093067ea168f1f346baf6e32519b088b18aceb6c33493732a9a5925323818b4bb46be4cd42b338a535692984979642600bdcd400913b9d29795c590506bdf709ffa4e282ce168cbbabbfc0322b549b710476d172e4c7f0e747e028e84af54525be197c243b44a94207295df798db","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
