<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"243b46e2e5599cf72ea658af99efeb6e4682eacf76b32c58b15d556eca86957f57ac80b25685d8ff103090d7115ecc12411c83be5ba0e9f984685f708aa91d798b102eb2caf61c8b8c0fdabcea534c466ae0e3724d0fd5babf7e2a8674458ff7f2ae3fda8b29cb744cd1fd53002e8d9a6381d073b17f4762c513f97e6a4f85b43ac778a9824757ac8e97d97b867b4d26c2bf31144b98b86eeb51e5ece325d92550bb5c15602067333178966a9b2b21217a8fd4be2679f8c7d94f2846735d2f85225e2a618f8f821d00c6e5db595ee6e06b21f69b5109183b581dd836f5f90ca33a9066aeaac4e5a14313297b0f2989a6f2ecf07eab7b9ded255a703f392edf1f87ed6b0ae44c959f9796f52477c14424d71fd27c755150120364579c5b5be752d0783715b2e5df1a759b0ff8868afbfa76cad2f0ad164da7986e38013b2fe101520443e56ec94e239e7fb84625d1523b329be826d1986b557a5df3c4508a597082c3d27404f12c3209e34572b6d4c3db337930554668abd461ddcd0a118c0bbc7134c046e45cc3880a9611d1819997e70fec420acf2bb65b6da924357d7afbfb50dc328125cef71aa77a5d62045c9c86d201bd469c9e8b08a7ae867a7631502730ae9452204fe0f11c88694e1a5a42235d0a7f0e6fc194b5f47302a9596cf281a7bb4b8011a2a238adfe7ded1174e8183f88ebfba70dde6f96914bfd17d920164dc17c45b035c75b18d1cc6ecdbc9ddf72356393be03ab87f3ee667aa18b1f3f0f22a9026333d63d9417d6edb85f64b1674e9dcbddbdc87a39b7716744b75f888e22773c7357dc0e28a5729f2bfe8fe7b0a4d19187daf89db401e9e9b97b950805aaa5cedaa514ae3eb9066c356e57d983912ffeeef2f77adb725462e822e7420bf35d076c5fcb2580b3fc3576cffe33383a7a9efeabff8561a72f7ade2674a55776e686760c2c56d43ddff07fc2f4ba15aecc9b07de5e9165b3d1b17ff98c197a394c31e2af12a58b1518bcaa627e5d9f7b36520ec7722e9f8315e6c0f898a8d0ed11de5dfbe1e78b01b791aac7ae142de38083f9a5c4531d0ccb9fa41778dcc00c6c0081fd0384b411032367ac9d7316926b1060d1494c6ae1d8a8f08c6efee16eab876b97ca63478c4f9b6ba7b608af05e31a7c7fe777e44992f71b131125e1e2338d8e25531302e25fdeb43dcda9da5b8e1684598d28b731affa99854369052b6451694c30842ff841beae3abce3fc0af0decab7b4146da14951f78da368635368764274696c989ba566fc0e8794335684d2862b3650f84b233c621b15726f24030f3c314779a9102dd26c3b40391c88352f819f4ba91cd66fadc9e26b93f321481fb69e01137fef6efe3c422092004cf2c63913925657fcf99a30fdecdacdf811dced17f00bc65f228216838cde4066cdabbcf42c0422f82ac3325a4b5cde8dd6681d63508ba0889e4aecf832d67bb86d2e443b24b7dafd073661bbc4af588e850795cdafeb01843e23a11ad7a992a32f1274458c1561ed9b26b2ad953cc06555ec74f31babe1a33ba6bd891db3fb3879d8b72f91fccbb0fb799a8a784a41784b582049070e2067000e203c37d63c2dddb9dbc760ed28a967f7f39b62baaa28bb5cf3a02ce0ecefa78460b14943bd39cd7336c807e61aac693364de738bd35286b9ca1339fb1bd0f669d436ba6e1b1133726c6fa789010248d284ba8ad23c0ffa284e8939e52f8bab4f6133d9598ee8ba8e6d40165b77855b72c3753361451287caba63c79ef00363b50b8f8c5722e6362a02c45cd059182eb54d0b806d9ddffa78cf9d965e330eb5bdd2832538c1a55092251c85c30a033a9f0487787bc6e4073de8b5e2dfa358656b1a23b72be38608f965e108314f07586e569605b8e85458c012c44a307f030e5230b04ec532993ae8f66cfe07002a27ec0e6becb57bc09ee8966f06f0a87a6d061f04bf8b19db31016509a2d2c95597d75e8d5ac6ee2c0ecb5e1dbdd478456da42836b7b067415e991c6fd7c30bfcb6c1daa369dcd2dda3a6c518755a6582ed4c2f09962311a633913ad0e384990e9d7ac787776753009570d2728856581e108b10b1e479ec5eb6d464d69c79f757fb799a7e6620e78dda1f7f9c1b4f267770d0ea0187f44670670b3d1175f7f44327dfad220007d690ef3681dac3ad17cc34009968ca51e4d1a762fad7a36807846bf974033cf4fddc1f55ef73a95ff5f9e8d83bc88813f96d396777dc54c609383715c22abf834143dc94c81304e402ec31a03544fa014f8c432a6973acf3596eb4888c219313331a1c920dc8c47ebd157c50e363ae32b5fa68699b17701ac78a5a2da79e6741751af304d74f48943cbaaaba2268752f78fbdc6e24e612c2887d787bea9e0c12c22ff532969f5846338e1d296d03efbaba9c649b50158a938887f77a31f84049724ae6126aeaddffcc93374246128b0d59baebb3987da174fcae51d081759dfb33751825afad68d7df03620e62fa363c9c28f7d81aa4e5d854f17444865d682971a47b7adeedd029d6cc7a2ca216e64a0d5d0b9519e6d0514868fa2b892b7d42cb6d0cc611b0bf338ef56257191d8d930706112e6e08af73632509bf52ce16103f6731d965bdcebe985053d31ce076e2474bc0c1bb427814637dd9d130886bc79d98b110cddc713ea51487f7b8b379863208b578abb3d20e839e38319d9699fb4e1a96d1f060765f4da12d12032169e96bd30a259c92480fdeffd5ad1eb09c56e7cd0c474d43095c52fe3849a8817157607985c702232b5a609edbcca7a3ee0733e9d4119ad16484a3e18787467eeb15f541b95f6136992f6c006502f2ecf2aa6aa5743b60cc100b1c646715be036c9a160934a47b45239da5ac0339bfbca3041cbdccf6eaff4864e96b74fb7c24dae83eecddaff278bab820dfe0fcadf3012910d1e07a8cf7463850bc615bf5daddc23a0091b33287e785ce3c0d8cd20c298c0fc502549c7f2a3c7c7fa73c2ce23215242ec0e6351c376503b19e84947ac247a31f3982f821bef76432dd1eea5b336e16197b75e9c28633d5b5f7f7e459553a5fae4dd3e030ae60e162c047ee72fdbd1922969c08cffa76bb33b6b3dbd171b2b9421d69d126cd58696b2c9bfcdbbc1fbef885056ebd9c05f55dc330e8854b1273e48ed8542834af0268e30e2b909df92a20716b4dffadef20eda4c62eb02336e9f18292a7f63f1dbcaaba5ab5e6d50cd29871a62fa6d86af175718cce4c2fba5ba24d8196b4ff3fa5bf09c608278eb781ddca7532247d3315e066dbd1835997bcef18f0f10e1537c474b7aa7e27acd7c92451110173b9ee2132271fcfda00189c77390ea0c16ef569c2dc9bfed5abb8ffd065bb59dac83042033cc956588b0cf7cecf756cab6af29b44eae8e68c1e81d6db979b8cbfd80bafafb9453258da83c8da9185c71794e2fa2c9a9e72242145011eb3857d0a6c01330beafd7399125242a93fb3811b5ed945881d6d5d9686b35bb15388f6e5b5ca346f453b83d350b471cd4bccd9c7b1f990b6407feb63f5063d7cda9b73317da71a8d76853ed89a616b9901d5e433fca9b80c47df1b5b4d97697fabdbabbf288d2c441c88c131d855417acaac55784b4c462275e495cf0da7484d940d9a9b531e7a8b0c6fe00f7199916395f6bbec7516d4661b9062ba100c0a5aeda1e89ef1784c6855b65387e7afe18b9d80ea89008131469bc5c0ed31b09a3c227c1c424181cddce22b6f4f4727a35d9ba36b4600e4f671e4712775d2eee6d81aac6192604d4e5cd151b94c6d2db214ee929d8839dae362c0c2494388cc5e1063c6999b3408c9c9179f6787fa0f57b794035cdd378602b3b7d33e5a8927df62c7c19f27dcf8f4ad4537f3fc2b98fe9e1a829caf00142e5a6cf3bb8c0a2e56857467a6f8e49d2923b2e99e359a79ac7d2e00347d5fd872a0d7d734b7865398ed9c05f2c7ed49a7067287ace1732d694b8be09e7cc8edc0a4943e897223f6509c3fdcccf56c3a29010a455f5879ac82f2977721d7b16dfdc0e3bcd1dfbc5a9a52e1c9d9b5e8c17762bde9db7fea0627cecfc9ff048b18a78c4cb04631133f7300cfc62a69193ff66e87db2dd0b93021ebc9f57cbb287beea8bfa0ea0423e0dab409fc502b803040077be23ee89db449821b7376d34ecde6cd1b88787b61964a8abce9f0492c795feaef9973217868b5361691f26203c700e674f0b3e2cccf80f6524d7f496be3eed7b4256f45d5856a5ad6b1c1a1d841da78a8027acdad1a9371093659cfbc8d00389082c198c9fd3dd7717529a92d149763995267e01af3209b51f7f642044d178646facfe5b3cb11049d0bc16b02d98c0be24c5c2b33aa61a9732472bb622e2d83e319a876c4cc694f142dea2a7b17db9a14982fdbc532552329df066d73e5e053ce16dc9ada205f8ac179d5f1983ac0db9e028d9e26744bfe76162ddf1c1c9b0de7ef9acce9e25ae025ed6f1e4312d9378726818c618c3863c2a9c4a0d13203bfcb870a36e01949cb46ad159f28376d7bfc5f6011fecb85344bb9416d42493ad0542c93ac106b85c60188a88adeaecef9050e59a37d7eb5ce38b8635a4a1602d185799ce866126f9fa62c0971484d05c1d70b5378420977b12f335bbd146556e210d2a299535a20cb816102cc603a7a55af387d100124680b19f6553be26a4d5898145aef00aef5fe1025d1276245fe1654bade86dbd63baacecc30b7b858a589ba2da6b4e49b845f3ebab92ca49fb860d4ac2830e8f3fa62c29071fc184bb6fd9543400cbf47b6e646d8efeffd45aa95213b01ba65f9b8b9e7dd69eaa5039802c79a12b9a223b16b40522d94103abfb425b748c70ab429d051f459a5dd93c991d9f7fc27e01158b94551a8e0f0ee94b7afd118546c16d5e91f10be3c3eaed6559b9cfcb292106e8cbc8d294341707b7208a2dc8b618a59c2539b80cb16d93c9c9ee325d90c4c293afd6fdd3234bba9fd89c9f6d2aa572740165164696164b1d10de194dfc5ed177d7089146357b75d73eb968f8feb1ffc3cb4450a53d28031b7028bfa5da3ae69f9bb3c93516ea5488fa4bb9d24d5c9f3d72bc3a8c4a76e2b1d4f9cfe73779791dbfb4b0944c0d48de00e3f187e0b8706d1de754edd7ed0c5fe832f5c117e3ac11826ed7253900a4649f073d1d1e0783a92200f68a677e441dd160a7b31c023b559eb8182285e0b5b755522489c6b1d078a2bea3b33ded504307dbf563a8db943a3b483dd34a46391d1f207860ac995506c7b273a7096663e87fdf1fa0f8265ea065a34b6610ca0a1dcc1d7e1ec7803c6a956b918dea81e059d775bb5f5ecab9b3371ad38c2e2dbc2d12448841fe4cf6b9a62f9b6722950129dae175b46e20fa93ec8989db3e2a0f1224f0e5fad2b864b558276b75b7d3a9265d30e851b374a9f41d7842d90a100a48a33884cb37de78cc62c02f1054708138d4e6189e5d4a0eb9b4831f0880136be8461b2f6ab24ada55644bf0dd8dbcb5d1e216927ba7c8cc10feded98c046b4ea29c15bf1d4718f52e63f086a719e5379bb63910b84ac84aa621df928339f5ff1feff8c5dc0c56f1c618e5cdbe184ee2059524a9e258f715db7e57745eb8f4b74b5ed59d2615c44c2279df52823f4f47718a3591d2369bd2adf3af26aa1455aacf334137ce9c31ed6b160723b93500fe706c18fc39ac346e48ae6931d007f284f187e94f9fbbe310da841a79a2a35445cca2b1240acc3e7913c3d6b9edbda754a141b045e45a280cef52ff2e7db4c8de3f172f3af1fe09befe94d2e9ff8f9ae3bfcbcbdfaa480c3646db403a72bed46e8b0ca737843111764666b3a64e07d051fb9bc0ccf7228d1af4fa6b9d35477b07a013141f084413eecb5e201b29fe1c6de4f10d1fd7a4db9843829e86bf2c64bfadc4213109263cb4e00b32bd3c9039ec30b3b2219ebc66cc56ec62aaa92f7045fc0dbf390b96530e9ad1cd147054c58d7540a67916444b703cbe321bf7309d06181025875ba850eb45fe5ff54bd24c99b176a76ace296cd416652a8c1b16add58e1c3bdc60119e145cde008fc8b861cbae1c5a166020569a60638d1a7903a636f1885967dc5645af45dd2da6fe595cfc6585e8351224ccecb453fc4a1aa520e47f7587883d0a8e96c3aacbf2167f7befea10f0735485014b12a7fab5779edab85d7ba4697920de4bf5fa6b9bfffb4b65f8de0ef00c161d94d99d4aafa9e98677db4279e098e7451d7253708627eb793e07b1cd956dc4524d80fe326ccbc03bbe099ddefcc4f2d34c7066ec5b66c945287cb288da227ad613892ec46b1d5b3b094beb03c267ef7a6209afbba6c5a586cefa42f53f56674cca60d705768daeed0aef93e7d3cb198fa818e7761c40a98c01050c0d7880f514850265ef588489d18b1843e0a1d9a6f910ebc39a05bb8724552ed5902fd515c69e66f2d657e5db5d10d9200c3ef2990ca322dcd02c77e940331ee820c9fafc735382f22da27e0a0d670ff6abb94935ccc7f6c5185c75f2ef5a9cae6e91535655b4f3c170a24b08bbd08beb8d37e989b7e5037bfe8c05fba17345ddaba33dff4f77f4f65e7ff53e94e3404cb79abbd8f55fe0559d6e5a7f3845937a0ae06defcb50282938c0cc109c19e27e6afcd72bfc7f7c7d401290c612b9b8fb51d64a8028471bf97f6f19b79fc634f8ec50aaa8a0e166d0d42b079d951c76ca230e6f6b43b578f833816432a3d9a43c3b09fe00997d8236fba6794b16b021623ceb6b2cd0a95c58a735b343e2109f5b509b4d5cb31bdeea6d9bf5e47e7a305f6c433dfe49e18b9c0a340d6a9123eb7d9d1ce2726aa98043aa671209699743c658cd358ea90eac853047d0bfa2a9e74e29d5e3aeeb579056eaec120afae4c1350e06719da55be5b8352e25250396483aacde4ec68485cd2dd61d6e7b0209210750a943368ea171132ed988938ea7f5daa1a86395049b2defb0df2678f562932c68a6627ddfd8c2bf940dd4844240e2610698d629d688f769b2fdb83c4434ccebe5bf0f46dee15d84173f00972b15019b021b9df6842963d2a32818a31cdfa9f1f3598ae35a5acce6eae08f0b986d98f7bde7056e65ea9bdba637468b57d95de8abedbabd1264c132a1b514d2bd309743ffa50c44b440f8bbcaf54948a90bcaf53699021f330504dd1a9a4f6a43e646cd2ffbd37843f20d53895b8a003e7c0287c852f8f58f9d921816848084db26efe2bf1a025cbdde92eee26016ec3bc3b750ab120957b11193538305a7f4bd429e092cb2e50d1f9506bf990a534948274c7c6930e725eacdfc4918633f4d7dc3e7fc66bb03c09ca28c227565347379071821099c55160b707d23a709927dfbcbc6b82bed9032011b9cf0adf1f0de9ec11ecac9105e31bc9816615ee07169f0966c360faf947ab8230db892b9adaceb08ce478a5072304090e9847e83b90029e41ceae43ae202b0b5f9aa7713a4f5a0382181d38aeadb75c4df719512a22f75276b3b916abaf35ca6ab78f43fcfe6f334727868acfb9816226d7a64f7ebb2cc564a88f931a89d3e3e992ff820d6ed290f36b5fef82dd63eaf46a9a0ac7b14b44b946bbc9714effe1fe8c37377ea7c9b3733a92b84ccda101d581b78fa7c75845c75d43853f8fb794d09dbbcd7af00c77a8490d567fadaa4d4f3d10779342f45d32cd2e0b1685b84e00f71b55bd90cb7033838bf21ce713edef25acf7f111db2c2f67bca307444882dcef9632bc45c49efbe8e5c87f277db0dade0008e402b23d556b5db950a7cf0479f363a91cf4e646609d4d91bf540e1d03a446f72fdb625390534b83fd08c94d21bc666f983e712b6d7b0c7d2033dbe31f3471bd76164d8078b5c9772fabbf989d5e449c307cffb90c3aaeb17a57314719715d7ed2729606c25d3d0c8905d3162c581d7fc50e07ce7b3ac039a20dd2501c426a3c51f752568615242241c53f5175585eafe60bdc1236cf97a719e1aec3111ff1cbb18c3b766e6baa252f33704c34ed48270663ede6207f7d64027a8194eaec54fab90cff424f3d598f8da8c0fa010e26f5d38c205b1681678190e52ecd31c33cf29525fe39f33332208c2c2447fbc560000c66c4ec9393496184d765a40cdae14d4214f64c498f7693f2d15c0b49395e4711602ef440785b651e0afa849cf7597592f1b8508da3b31683afd66910834da97e11a57c62277b0491883f166203e25709811feb4c5078b7b552f1dafa5f86111d1ee5dcf75d40dae3686a8cd6f2b70be03077a374e749cda2914b0bbd6fa629258b90c2de1051c190d6abc1b0a307e7c0deb89a3459130559581b7b26bf8466c105fb9311fd373c512f787cf7218290cd6949e1d0bb6e243fa67f63ec205aeb5eba5657f81eab9ebef9e856857bffeb6c6197010485c80eff253800385632fb3754576b2718ecbffac66bf0fa04405a04a0d7a087c731a6eaba708bc797043fc431f778970be4091a7cd27f4d76d527618bac1d71694e2bb154ed6c4774b6bdd51dae4851e5c9523438bbe7c5317f3975fd83969e8ef76de50d88e4e4ca568a53ba7f4f2b6b2f51a55d37e864ac57f91a30ad0c14660a34bbad19cfd01ad3e13a8c993581bb8be46307c199214e8980c69534988ce5b3ac9574be3cb5dc18f9f6f99bf9725b313fda81e86ebb1cc443e94497df02bb0ca686f16c8ccd034991af5b73257e1b714659cb05394089f35b036e650c9714fa06e988773469b1a6dc459d3f1ee7fc129ed7c15059029e91d9d32c1554e6836193bc5ec2b031ef957b24e740da9cfdc2850582a4cca8f25869dacfe4806384097ea606f2b12a2c2142232d9be9a31a628ef3b8c7d7a35d44f416ed4db36c47b04e14603fe5d904b3a729c09b962abacd5ecfb010d2f7f2ae889db5e4b902f16b60d6d3af7fec1475278c26b066533d0b813de3ef9fd8770df7436529927018e6b0c72ac704d144787635b8fed215dd5e6188656de77345074a1193220ba3137220ae59306d7bbb1412179847f667057ee66d81fed70be35f09d94225830fd485c3208fee02f09206cd49aa1850bcddc007249d99d4f6ef190139702d1bc029c4024f2d05040cbc5bee8d2a75d1a12bd2a140703d06c13390b4a40a64e663bb8aba2f0cda318a79e0e8f32fa88f5a24be95baacb225a2b97e9cf419346fe16bd4264416ecfa252d0ec1ed2c1610fcc4c14ee73be9987babf4c918dfd19469e2ea4e7ed8b802b4833999540b454bc34e2e4eeeb53e4b620b4663070959f03804530ad347663de8ec9d47a6ed4b89d35d259414ed42493657e117f1e03068175de3b872a2b2fdfcff69bc1211e5ea671f2b414d8bb3d71481c2b975b82835955314027e56a258666579d38aece5716cc42446b26fd9dd9db1edc19680409c2216a743fab1938222635e8971eb07a4ee3029523d1b940d1ff51c0cc6e23c0aeaa183ad18be85bf62ac4f5ed4bcccfd9eb6ff8961d5c72d064a19dc3c7e026ca0be70dce993545773e508a2fbd31778395f5250f4ae3468797a7b6522235baf63f38d9c1115b2e50db96ce8e7fed56b88ee72f08692fdcb87b5322ba6f9df8bdb4c2c9c483707419df4d054ee8af87563102c734e4a6f567ef949456489914be5c44203a700ef33e4e571c70f372bb2d2733d4ae7c42b4f96cdd53e1ab0cb01a90dbb9bb0654014a5b84f2d4ab74a9e27cb55dc7baa84679969b24a29d4cbdfbd284638a133a7e892514104c192c3a107d10e2e8d416182f284dcd808aaa5736d10a9089f821595fde1e7819b50acdd255320044f912f95397a4ec4b1b1e416c315e276a8d9dacc3d57b54407d886438a1f82ee8f498989cda0621e831aa684b11c8720f1c626182604e9221cdc736529ed13a57cce4bdd64bb90fb4e52470838104fb5a13e4df9d19dbb6062417bcc9d73401e3af53dec3349ee347a8c628dc4ce592c03ba4271b7e4db57b08f28ebbfa0cc973cf5c727223bcaedba8b9584e82598227a9ca286ff37b43be775a7333e67a4a83bbc6f656ba0123a3d788dd0ef234a5baa519924aae88e7c89fe2389300eea203adbf69b17ee9a73e3dd223587efd3bc020ce9d210d1166200b1dc9d66a2baafc9119cce8174d3580142233a62b6b65da5023506990e2affc12907268f74f6320483fa02509429c75d3dc893f195f66efeed4bacbdfb43b1f17f3a3ddf5c51375cacfbed69f47866d2f15a86408dec15d72b40ab973aee7f4df5f92b9fef0f6ccb152e655e7cca3e4f263b974e2e614980a483ced953f0ad420c9930fc356f3901e24b8d73e34191acbbbe1eaba3ed6dab12331a5c582595d8494ee944b1f45aeb7cc10389bda37c8f624d7c39a35c0145a2cc14e11cfaba7ecd1eab8c8fbe160ebb6374e9d89c74de8c1ec3a3e9ee1f91f59528c7c5b8eb0762857c58788e05df96c06b3cfc52447e4f2d49d4b6277964d5b53086e873c168248ce5f6db4c235fd5dcd77bd4dc61c79e28588bb047b11451f0b0f23c52b9ec00c5aec196a3aea731df9714f617656ffaf5d4582a519f45d689b637722702be16e8650e74df2a5b7024863e182775830f2e07c2a74cb321f14413c35627aa606cc7926d632a065d05f8b260fdd491cc61c9bb29d4034222690f63ccb5cdd8040199db795eb605535067673020471312196542f6f934b4d221bc5a024c743cda05b3828cc7f53facc484df965d0d7017dd24b5fb3ab2348cbde456","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
