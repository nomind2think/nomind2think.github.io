<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e047f17b45491c9e552a81b55b7d3dc271fef91b68b6a05bae03581f9b2f5c8287eb430d1ddc8862f3c506e37c210c16242d898c9796a725e73360fb05f867a97213a21291547000fe12bdb3926a8c13db4cb91f0c7f32cd37b87a01db0075655b90359b38ba262b4adf3684b2e0c9a7cf2b3f0604f8a3384e503685bbfa82b8098b1dd10b528df4710d4852939808d77f821cbd697f367f13260c1c2484572c2a49ef42f45c9c455448aa99caa5b7c2605f8eceb663a5c770bdf5780303564eaadc63490eca83d7042fc5b46010396006305e90eceeeced89d102348642ed8a55a8fb215ba7f33ad1958deb09f306df5540feefe5daf8622b1e15729934e73eb98df7e2e1f8eac9b933f0813671534d1d6d67402daf06c1209efab6349a5f84d39100df29bad495c02df276c50167680002acf765b7bee420a34d9ecabbf5b105abe7b374303c6b6767077315d5d5bb5fad958afe792039492c11c573d00df130bb081f24876eeaea3f59aca44e629a9a66836c33f65ef46ede48318e4f93e741d6f2197d274b3cc869686643d674034e021811650becea0247214def15bc9ddb497e558b4547879575f8b3a13fb794677bfcdb5128bc287f38342ab89aa77564660b0b118f04a78564f5635ea15360750fd6874bfa14ebaba96900281b8c8fb8746aef1d62afca88c91d5b43be69fe9a5de6c41264c2b2c6de061fc5f52feacb8da9075d6a1a2884a56abed6f50534458bb87d7816ce62918c032170e3fa5138264115d6d16f2936c7c7429085d024b21ce6663ca93a4a825bdf60048a5ca22af852db7c116f1c25187018d990898571f63a8ab5ccbf4ebcf9b81cd60450e0fb02362632b414581646f40265c1f36836d05bfff1e4a6521b0a111e35ddabd94d95d0e08ab24589caa9999b0d4daf7a0cb242b4f1b302155c4809cd9b72b2d7e4b4cfe2ae17b853dd4529e4a9f8eca86d44f08c86121da6ffaef46cb40b9101f202bbae897dbe1781e033651708014d9bf1bd3c6ed82cd89c47808e58dd34b1b5087611d8c04b4fd4e9461a97606b724ba670d74f47b500fe5f0dbd7a8ce37154484c75c80ee960e5c21c225348e8e4d8e8f1d28952c9e3bedb9fe5d47b5ff739d7f1dce1f6c57d3dc72a5f52eb1f671832ffee2aee05313beda1f6c3487150cc3bba4cdd9b95e1ddae41c688d17186a8c008bb5ce94fd3c29ae3b14f109f9def10ef620b297ed34ea9064932120c12605de72e57198a36d4df662d27afd5ce9b9149114d707150c31fbb08c3fb06b3a522e4f1f9416ae4e000ca4a57a1323e602a243e707563d83807ae114ccee87831a5dd9d2345549ee736d77a7a61781868f27431790caff77794f50fc4a015a25356522b0a0c86a48445ebfab40d69f938b4e0d0dcf62926946db7664680752be04b0ce13d8a92b0a0ddaff9022298166178fd8faf5fb3d26f5a59ab112e18087a79e8a30c25eec71e2a9b79c50116b00b7c439ba6fc95d10e6a6c592ae55416c1ea3266c3dedfed220f6920acb5ada84a4d4ba5a111b90b1b0ef44b35eace48adc6064d167170f70bf8344f62dd3b9da8a9cb8b28c200df50b14e0f23a9e9771569215dc1ad17984bd71b09797877dcf1300d2623eae38200c40a4f03b13999229ac51bcbf3e355332df634d218d1c0808180717ad87f02e8457ed186bce62f0704df2ca917748ee65292dda6445b345ced96f5fa9feeb48dc554fd31e663445cf060bf15177ed2e241a44da38552d9c01d35121962188a02ec686eb36c179b5bff2d74520971c260ab72543556d42be4cdbafb4a97ebc4f4b23a89622fa9c44ddd55cbb6da3fc27e2d480dc9f6f39b657f1dfe5940088a1abb5952a054c5c5ab32f9761ad91a21b8dea19d66d0bc91fd5ece0161519984928700a668ee1c8d7322efc4a5bb31782a0af7940641c244228d3e4151289b886ce8d3a3c36c4dc366904d1289e76ed19fbba5710b40a8275689e709f25f8d9a45067cdac5d0b6827878df93bd3aaad3dd3c1d71ca17c5807a274d392c78e028190a64cd45ff46cb701db933011ff023c29ce15d63e89e250fa41302fe5bb93193bbe89681f5c526ab5f1bcf741a38b5b61a510cff11388dc2eadbe03d3ac124912fabdf82dcbc0ba47e3be6c7f2dc461369d9195a7476413837501832238d64e0ebe71886ac07b2d61c09711408d381243e05fe90ba552bd0f1e492dd1968cd29400bdddcee0f04a1652468fec822d195b3b1ce45e0963de3a53642f66134cfc1240dbb61e335430d45865653bba60f399e1d368a28d9dd595b2b7997544c61ab3725260397cc730f4586ae2481807bd656f5100e226da7021d9069e27b52616f49d5c28030fa6d626ef8f82707b5d03e2c799b480024e62475d94c817a497e6383f1a18c87a317aa27034b85db25c25c122ac0e39017cc07b158e3bb1c6ea30b4d6daa6354723ad9d9dd08bd8de2e4871d4ac941919052a46cf51b566de2d1fd95c0b672db408c4226b3abfc7f15550712ef3f6e3fb6e52c88d68335fdd90d12360da5824cf56bacfc2ed3487d776739736b2f96f6f0827b437926c8829215a3956b6224b63e4362964c6823be759b7c5920f8c41b737ee70f372dd0ee8516dc5acfb221068494fdb260e713015d7fc138cb42e628207864c678549edc89f624b70493903b4cf23367938aa3f780437d7189159a2e8038ac464788010e0535472ca51cb50391f5ee42eba652045f63e1807e489b78d2fc6d4dacefc1cc59affae9e4d1327137e51c4ec4599e35bec3807ccff6985480f7eb6d8a649829e3082657166ae101da4d28bee00bf469c79fd81e1e70d11a9ebfa17189cfd73569f56f280c5203b7a8a14a84123dd7401b1fb524a5cdf42d18cd514604642b027ac3e9edfd7c8bacdbf8156e9fe1350e0e7d30b1ae3022e3e17b6a041f7506c4c8dffd91076aeb0ecce4e43136d9d1f0ea2265774c1b2575cd146e870fad5c3316a771e843ddb71c74d7344a70c9158c38ae6a31d9a0ec3e905282c31b8f2d0cb8284b79046ec91f62d05df235acadfa3a45c7ca89761e055f5d4ce39cd99c88cbb3d763cd349721c1f9b75a8d659951ac833cd953e100c301e05e424aab3f86d4afbe4194f2270b0c54a3ce6069fa74a6da7de91bccb3432b34cc3799ef0d973f5cdf98aad7f02d05a9ae1b03c74ff3bbdb2f1eed6b229e6d5e22af7bd6667da3f7963c4395e53c93050116d31d16d788ac46309a54194b5c52245121bb75689d54abfd6766b22da54b9cbbc80933a981f7769700b1462a1a6a6cf007ac42f65c2ceec7740d0bfdf6213ec710d4b0ff908dcdc8833cfed19079df2922b40fdd3814d449548b89a2d8d6e10c65560e49d44cb6c605f28e11b6d545189fcd49e6992ed5dfdc5e2b295c6caf60b67f39df8bb4720e1efa8abd8557f9707ffa188d13cc21215f18139b3213bdaacafba741a9d9a01075969f788392e923d9e3bc840a27377110e9c38485a77940c3eaae54db60e237ff64960f28d5e5e2db661b045f5aad53ed24e7afde4043d95af750cf51066b18ac9a160d9b8bf55b7b82a1a98b17298bf66e3e086239d77fa2b5c6718e30a747fc90228d0a14460a83d88142edf01f801068f36e805dbc85dc1eee03acbdb9c73ee6eb8169e56de3b054cc566a21b1f23ffd4be8eddc280ea2d7e67bd09f65deb8b7f2f38b0f19fcf4bc91ef7680b6ee2e6d3daecfa046a9f018dcb1a14ae694f5880528dd02af2f20eea31a85e07d68de90a218552dd9adaa0be6045c04835440bab57bc0181b607c40f550fed56c5c15cc11a6e64a9dc1fab80c8357bbdf63d5e5664d61a437d45de19a8cbe67a3b422233e5f82fc5e28b33a695eb686979e122ab44229c9e4535541571ed109ddfc5fdd207c2f3d46fd32b757b7a1e0c0567ba637604a93f4c241e3fd9ae42b315e2359895c56b3cb5573364580a7b596cb576bbfb0fc0796d84221680e7caeee45b526bc3845082d7183d8c82683ddb5f9c857980bbc44737e3b0758fe869643e6ce88da9b898f0f90d78192b8c4ab1e258c5c84a94a3b22055cd12636685e6dc9a0e88b281852d7c0cc7849aa079153305fa40584886815ea222c20d66b1db93647fd733714bc06ac4664d6f9422a2aae92161bf0f162f5a0f23a14f1771ca535878c436284379839f1c5a030446ee8d6e79795eb753ee1564baadca64b3ceb465046fcfb1e1afb61214c7d7ccb3c9f38af1ddf17395f12de80d362f0ce5afa8959a7066657f476d7325670f5543c4a15ffb90d2c2e5e5d35dc23a51155f49773d2e207dfd94198fbb90da732949580801a8962a22fd096c43808d3e60577ecc7a3e3e48e5b3570b70f0d97721afde56a4cb16f415301a5e0d077bc8aafdd661b62750230ef408f7ef4190c00a6b13b829403daeaf2ac1bab21987aa110a8ab07970825f99fc78c7f928797ed0391f7073627f10f2f00c6a0c1c8dde49508301d1d8bc52991d5fe3b5f1a5747d90797caaf4456502dda8d01248fed77291634e6e2a8204a9298c03c313b2b26b414f1b4517e10ce7b8545e2859a04c4b8c200b7073b91c681461149e8aa59a75fc6f935669087101c897bc3481ec078270e458449adc9db8842649ffb06ed67f35ee6c8305dfaf58f9732a116495cb3e373400906ea033587be7aaf4431097bdf988a399c712df7a0513241da9343cb8d1abc53d50ac21a5942106c0d6c1bcbbeecf869a33704be2d90188c0352e40bcf76da0e3abb4d104c54a3ee997ea4c659c4fb0a05c2bbea005aabee5c9ed5bc0e18e47262c105870b348b64368ab4dcf83738891158c3221668676ce4f7502206396d339c3e38b98681724260177a8175d574ce553535a03a23b1376e558895e685dc1feb95662e04f9b593753c4693f11057456df19f9183f06dd7852bc96651a835f6e472074aa86fde7ff7f27436273b48a74644906523878db1984a73d411f0960ef155e223d5b41fde1300e3acb1c502c420629a43e74780801fea81c5e4840d704053f353604cc841e5c659489e52084f2bd691418b119a27d349c7ee65fec1559c0261827259bf34b6bbf0071d9c10a63066b6038acfacdb0a14c82acfaf0d09518b38ad8af276ce2ca2b0fa2b7a4ab1402b4dd7ed03e757b40063bf595ecb13cc1fd9412f0874de3928d2f870db0e5329ac07a1e444063c7638febdf5fba0a52904521da1851d86d0138287061c800969d6b8199ed650311d1377c617ad9ec728432036558ca35de60b9dbda003711a6c8cf8636e21e749b2b8478c74e9cc6787f5ca63b08fdd4732fc3bb247b1a7348543107b7bde15c0fd13b8d48141d7db98c959945064c61ffa244078b69f752dc35de225262309999d11820f8c02d3b7f8dba4a7071b90dabea57d55c42d4d78b38c01a2782d7834243b5c957b785a3182d3d44430b0be461365391c118fbd9d01e77eb320a19b55b7b143b80ab54919c10de2274246aa02aa90a247a720204ccf8d735c2d46edaf54fc5693fb6709f0a392915dd92d10666328345f6fb6e8b940b79656e6931ee903dd45a6f410155d0f888721949a4f914141b91dcfa6c4f19b652cc5e418859a0bcb94d4175905c1d3a7f59673122882c937b9e70375ea3733d5186fb85744e5df25ea2b6a60c4b0b020df009ae0c153987b6766b1cb912953c2f5b597a41631537c2d55991233f38c003e2a1697ca5ab658c9f2920439736a9abe3309173967f9b700ee5168a4ca4080e6d11048ba487d6e78ba25e78c80ba52246508c2b7b529fd3d0d17bc4a8d360ee301b7c9caaf2a061f90f902459f4da2591107c1f6b186c8232180b7d0a801539ab6c6c3f2f36504cd5ed165f0e91e715fc38e30187fbdd9eb693dc4485e3d7f1bf931b5c05a2ac3c648a818b66554a06d46705c6223eac8c4fd536e08e4e0147e39d5477db2f67bd2bce2017a746e532622e9f6f5d26c6f0b348eb3f67c7e5917baa79dae0a198f5cf8a20182a3c4a979a8f0a42c73c47e96a50a3a72684beabb2e513929b298638fa6fbd5f626ff3b90f37830c5117005f114796f97f25a92cafb7efabf3094e3bc6d0b3f41344016a0a62767cd66b05a0a234b284ee43ba09e539eb3b6053bc7928e9812842627182cdbd013d076b346bcb57e25caf04019977948d2b3947b8d11b0f50f16251dc66c96807e02425cfab272675e46aff0479bb5ffbceb2624b4822f4b5b9a75e1012def3114ae95cadee03f7806dcb1dc6ecf8ee61acee631ad93aeca2853faa5bbf1ac3504ac2c1a588cbcd4ee5c5deeef7cd5fb45211015737c6230eff4278f64eac384db41e1aff2c67ed9650cc0152cc7fa20eeb65f5bbcb8be0d69603bbb4535dca806616364d2864653cf005b43600e63978998e3f262aa9deb29677970a146d1068cb7ea34c5e874f5c348be395f849f8f78903af1fbe2af96b66b51e08ab19baea82f9d4719fe4712ae6fd3fe127f29e814b9b4e71b2049a4c0b0a57cb9e354ae6b3fd57cb14db3c886037946d60b2ee8aa5de5b53c08e0ba1b949f94da8b1f582c7600e59cf87ee3c025c4bb1882383f420abcc836ee89cf6f7b0b2f5aafdcd5827ae6984504584df0714f005e581d5c9d1c1e43d88234b46c5a82cc25a3cfd5b80779a60a7f88a2933bf0843ba92d0d91a45a611c1170387d9a837b2f7e030cc12290c53ffc3cbca3ad1b7a79eb82cdfc2525e5feb441c7568cb44247f250216173fef87b07bda25a8b9c5969dbe8add95cfcc7c9ee368059db942d558e3dc1c584953400c6fea5e5805cf889ccd96e60d4416371779f4a4b109fc51de89627e509bd5ecaf9a27c82b120c3c8bc5d232df35b76fabc1ccf04a1301310cd9ea49ac772d6a26dcaf30cb42772bb8324e3a07e06b8dd3e35ec39b95b16b65f267de7d63ad502040cde8bd21798bb315b6c72ff0efa6a3437457b2e5e7472e853baf95d10548b371217e727deea138130fd3529b2062f3351b1111f3e305ed02df57c76cc821b2c5ad2088b7613073aa638c1d78c7aa7e566f8a0ca6044bca5164032e055bf9d84399a89fc8bcd1c7894bcfe2482e44cf7c2668ac7768cf90fd3454e7ecf98ff2de199eafa169c5d6fd4c44e632d344806f87fe2b0c0bb9487b5f22ca02355365e62c76243d2a7c0c6f8f1239945a648d139fa23ef136c3dab570ccba6abc94212673ffcd9ccbeaf43da179ebe6b06af186df9da52798903d76ac5f978b7ff64cebefc7c123effd420e9b73af0757f85673517bdc9fae3772e77ba5067594f4cb28175b1b85350738420daf77fec593d2deb97b180c22c8d2e9da459716df0cfe4ac75f2ffe317066a06830d892aa9f0313764938dc8c83632f6511257668027d569651b50ed9211db463886c7805aa21ce903390917146774326cfad873900724c5e2f9ffcc87b441f1f83455433c5567a8b57623426f76cbb740a85462e7b1723d8c09e36f60b212e322b3cc7dd32ed71a87c9ffe72e7d4625b4a45e19193ec7a5522d94dcf4944e9cbb417374477c31e589f89227609de5d9142ac056061b88863fb29eae3aa51e9bdd5b744c46bb95f548aedba0f2d32f14ac25545c7e86ee5bee39adc7448a775307bd00fb15e85d8d72bc3a31dc4602532e02e9489441863deb9d972278ab9f169803d21dcc2944bbeb2e8558d1c28f2ff4aa6bfbac025e2b65e5bf4782e7bb51089bb57053b64aad490d0fb7b94ecdb9d6d77ee335a713ec1cad951938de0526d15f27591fc40f26ebc05646a3fe2a5a43ad12fc82e2cb57ea3dbd3d277b32d1726c459b8d19779ea4df2871620e80babcb5797fb46c0f9be675a53c36ab85df5c6c335ba4a0497035f86f3157d762d0080e801ad64fc48fe11d25174e3d1c084a14ffd1454fe1c4d0541dc7ae2b9933a8310d1819187276f7b7c45eb62205bf7353b5713456e7165da44b410ec51532e51bfa702b94491890a8f97b1f5f443198dfc69c7156d5ce8535d056dc9a15c81132d0479853ccdc2eb80aa1ca9b1fed597e74faf98de0c5b4a5f4dbc4ee84bb55bd43a6b1f59c9972a78249db4bfc3e1a5d3acf3a5b85e48f9f7902c55074787a634eed06cfdea77bff580e4f7b8e7ce0edadad5fd54f598c897644567f53fb7482856c987f93998797b23d1c726492d762464027d639ad9393a577f7693311671aa14fc12f3a113d6d8f2449a43ec8050e8af466098c6c3e49f13563fbb35b77e29d8c8c70277372e07eb028864131254a71106f3d24d35eaf370abc2f3801944b3479b208160ace58066c4924fb0953642345a8b8ac148d2ddd9293c8c3dfddd4a1d8e9a72962c183d3d20a4f9472955127789efecab0ccbbe5ce91d44d8c00c2a18e3fb5cf3cf21053715b21c064b48fb79f9e89ab8ba969601372ce5729d3e47d0bd03c260d7a59d863c13146712f595ab363b6dce856c9615ae3bdeb4f3ccb610edcf1a88022ebb0df84f5371b0826482cbd22a41925336cfbcad6fe7a4f4f9f3b2582e95fde567e01496bfbbf0ccd2779f5a3f49d8cecb9fbb12bcc994c5c2239d80f317a9a22debe5abd480fb26dda26287623df68449e255674e4f5e96f81bd8c5c34b900d831959e892af56f079dd4c164e1d35fc1cdbb49c0bef4226c76cbe8af7c4cc762f07a7817fb04013838b1cf9be7725905fce065854ad7ea435a76e5f88b81009159ff397eb1b3ec6b34a6aa4a3539bc08dca94ddfb50adf4d500352ce80a78ffdbd162c0443eb59108bf25d4c79cc23958ce8888da9e888b756a8bd493f6873d40561c46ad7f1e80fd7882d1c3ff92ef2134512b77412af0210398caf8b05696d3273bf2be0d56ffe96fef70b0f1b5acc13be2416c084b2bfbf153e9d3b831ddc215801ceffc68f5d8e157817693ffa6c4f1a7dad86f0d6423c6eb085cea29ebe32c5fdb95b1c1beb0f3551e53bac99a1d2d3b3c226132247449c6f228094a684cd4884a6806d3963dd8f04c2aa9c7b0296b8902a46d914ac57265536be1af5838eaaee2bc16ffdaccb3cf2395b9351831b655f3945e2baada079f3310c1e3a0d6ac13d6d7ed9a4cc11b248342df55e8d87e314fe83f859e3d1c22ccb7b3ea7f85909bbec04cce346ecd5c1b0ef556ddabb54b628a1100dfc2170c20007f3e44320cd6ad58a0b6c92fa83a9a1940b61d2e93465c1ed13687f82da94e2887db8f16b9e197b3cf0f3459749996b736b624924f0b4c13bd3790b222ec11f44292b70e4d094170774a5aae296fa0d898b8668566f823fcf77dada6ac0d5f223b23cc34bcf52b9d105316c6699a3a677611a4d484b0ca4d496766a6f4b5a2f32e1c626f93fa1ced5a256631b1ed495c08bd3bbd73b71da49f2c0e659657e6115138ebc559b1e62142d2c9cefc371b5a25312f484aa2a4dbcfcaef3cf790258b530ab958f21530f5177b5cbfb7169b22572937f79307ccf61ddd7dddf6c333bf27fc51973a15ae27b03a903001fe731de052f1b8459c08182288a09674002f99dd1df313858957858a6796879052b0c0da3e5522e0d842430f1dc19a67b52b02a0281f45c26941436eb173605b16e7be5cecb48bb5e00bf032bebd978cd4e5203dfb21b20ab5433bf67984553122db9518f56d80d7061eddf8ece0716cbde7e4362e9b8952830af973ebd3e9aa4ac512ab00e3769dd5fda48be8b7cfe04dad3b4875ca4a9809b01cb0eebed8d13596effc0143ed96969fe4be3556d2ec6e17d18da979ce6edc09b70d4b5d4460192522bba9bebb3bc3fa28d92276a191c89cb589e3b0f95c6b20b5e385643d5b652054f3ab5c911b00a24230250c3bd7c4d05316157bedff1fd1a8535f9f","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
