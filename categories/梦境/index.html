<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3079db8b1c86067dbac4f391e1b8ec6305fee8f242b2623051b6476a90fe695fe7a1681ef7c234a31a509b25d0c5476d104adbc7352b7918e6fbc2ec917a30ddfe52c3b12458f09e7ee75211165c9b7d849ef063d59f7b1d21aba1bf4c003212406313418185a59693aebac1d259372c473ee0aaffd028e0c4402abfa1c6f505c34e1a314e9f816ad7e7b686307becb5f6a44f168c0fe095ef4c71b198ca57f45b88bf5c20d4385af8ede6ed02b60f405bdeea589a241ee025b4601cbedffbdc2513810d24f7fdb7a8a7d894b5ea232662b6b39c4efff5fd34fba0aac3f1edb8240833774d6798667d4bebc519b4494270911f0b712aad4fe0585fda0b246b5dea480bfdae062aa9159c9fd538be91f9c14e3663b9fab670ed125fa89ac1585c4dbd36ea4b09e095b9cf5338bc402a77f18495bee578836f777873ce146fd20509de193b9acc28bd836f496a4466ba026adbcf714844984fb224202784834ec292b4690966a0c1a711177856845895c47be8e8c2337d51a3170ae3a3b4e83259773fe89b8e076c6dce5abb81cc924de2e85b566330398618a892637aec96b48316fee1fb74b816c6bdfac4199d765c4af82e49ca8c5968396c9af6a71b4d4cbc665fb83b29c4f6e0ee2709a0084801d170f45aa1972c098ef196a54ea89d887be00b50e01187e29c6aa776c91e8eb634c764a047bd9bc3350d3d2214f72442313fcc02743954be2217ef7dedd4f6f7e7f1389a0271f712858a991df84f81bd32736c857d402fe186c0ba98f2bc40cef9aacc84a5facc5c106144c05437db9dc5be627fee9ba23e9657ea94fd33346d185d46a0051a361b4c2d70e89b276e547c3b7f6df810a5cd83033a7d629aee84a92d3cce6795966634e39c1820ada900ac92ca83a9fb49542edf7b6916e0a66c02ccf1a7f3105b64b2a5bc7bc8a17b920f3889d936673251f48928e0f8c6f3a2d06e2571efb0ee795feb7e7e906042f6c9b3b578427a24859dd6208df7c3986075e018cffba097bf930598d4750518c7940ec3c52aa978f26e19046731a1726d41785c3ed4ef89d19fea2534b3c3edc12952776ac670075a5df5632e571406816b0699b15fdf32e9a62814529a403ee24d34b5fd4937d0d7f87a0c53360a0df2cb429b7231e7075acd85877bb7d8951376a5b37995c3244886885e798ddb07f892682091e96dd1fd53cfbc2a303efd05af5f7ee7d26e742cd1d35e5b0fc017086f67cd329fbc45dfb4d9a93f2922383207431fda74dae7462d20b5d025a5106e3f9e9b1898818ed606eecf01b175662e7dcbece8ea72238d5ece6530812e91f39cd732506236ee2e51dd85832fb7a8f2acf7c12f19221964b86f6af99476bff23bec43354ad090b30328357a75467a560e0136632d29140e71cc39d4cbdfad0f66472bc3a6a8bb56a8e816a9b65ded52ea8fc72cc8c49a505dbf32240d9812a9ad663c651c2a6c2e51c48a6885f653ce07ee8c98b7c3a7753277f0aa438b427730072e2738f52da289aa645a430120dadd803d3f408d18c30c2520acf6bb79ccbdfa9e5a17b40fcc96095ad2573ab6d274dc8046ab94b1dca29d7f98418e9299a5c01724bde38b9a176c8b06717e1bb9005a92d98d4e591e3ca6b8dce789d9e6a0e49cd17b97cff9ce54a560fdbc74623e7057328839bf2b215d3456995f1c0dcaabc7cc8d6d2de52fa8e73f49e3b18cfcb3937914c176f7d8894701103a159776bc1620c24d4337014762cec4c85f2514544b417ca6bbbb046d5ae8f1407f88e00894f8d3d977a8d8d9c4825e3e9b3ad6268bae0e46d3c65b36b203962d4a38b2680b14a6c54117022bc332b9574c0b145ca8a9c3993b558779b6fab9b2c55d003703c6562b780c51d9b4aef8a669678c408b54cefbb45daadafc8c5a0f150c3519661bde0ab620d6a10d5e5584e72af079536140b004107b5c0dc8d7725f5b4cbc3dbcb1e099015dafb2470aa6166e292e9bb861eba77c65d993409eec82795699402a53107c1fe20e304e5542fc4d89fbd4c957003cc0f2b9391981cea5e85e0509bd02a9570472841a7d75ffea08d330f3547a41a7ec47e9356520666330a84b157622c3f7248e066c94af20a7a6e1dcbfab9b40247b492c0ce61e1d77e2ac9194af70877f9989625161facc1e0519cbbbeb99be855ba1897f48a4061ecf85d7ea9a5b32c1871283fd70231d774fa6da56929182f9918d61fbba8902a83970f725de862b01209e0ab354b002b7c3327149570fe51eb844a52bfc8acbae1eae0502cca1dc3403c03679b56e1197f6752e50cef0b340f34c705f3dd3baf2f65565616b207d36c97dccbc67c0b37aecff3db72e2b86ee258bd07c75727cddb26d61a2183a43bffdc2151a554a2ab656266c6d299f9cbcf52335f9928130ce7d57d03564aab53e4e8b250681922bd09355a5cc88327f333e68ff12653359257f1ad694dcf9db5ecae360537021c9303bd80a5b841494d88045f1a89a6628a3c57fddf88fa666dbc0172ffac7067b7cf6a72ef75d273e40bdb75afc658b0dbd2d8ac84ab9c52bbb8baf39fad38ef837c580da1805836a6892e63a15dea45956254d7124d0f4c5954b878cc094d7f3339da41c3ea57a4cf1ae5c16b760b96a75e21764d7ef35e70075caf87fdf413575bf022dcb4994ecead10546afc710375a6ac5b5b04655dfd7bb9e3bae0776a281317f7552c925a056118940f4705fbb3dd676e70b7ff97bfd697bceb44a109d92dffd4f6fbdc579ee6a52efbbebc2ffd79e86a1d393011b34632c7b6f9d517e5624e6695c3d3fbe09ca3e74b45bc32356b2f873c95016a6bda1bcf5d36fcde9ddb2f209647a418697f84c5ba569608191b489ea087c4899d1c7d9f623f7dc79a3010e079c867ad866347cd54b08df036ada15260e04fdc07437299b1e0b15bed01d16f17d33c228c9d1742bdbf1ae27de360549f880ba5291eddd0a59167c7e8d84c272ffef7a7a5a79d5b4662a254d60348a51fb6e494a9dda99640c8ef8622c4182a5a4e94a7d80d1ee1bbb23825574fc38182d756bf2974272eaa2d984d07bf949c19f71a09f939883ed429b3998dbd45b552d9f24d3bf67b4ea8a1b432445925a2108e9aeb8f4f12ea2e4ff3783094b5f4839f4f46b6b7b3922ef7ed84813c20201f247709cd6425dd5e0a8bd962dbee6e38a1d808e572d16757cb5282b58c483f7557198d62c2903203d899d2a7da6a63947a9b02c2dfa9096473be1e41ba298d6f2a73b03bdcc6ad767b72605f1f970a3cb77ff243c59f35cfeee34ca26679798681a4aff6aa6475c8663522f8ed5fcdc5ff14929a221e2b6a25c2ed8bcd1588eb77bf21d993fff78dddc62683e08b5f3dead582931244b4444711cdd06910387f211cb3eeb3de7625252fb6a8cdce8289446b3a010deaa83d1bddcc2c1c975dfce1f27841cfbe12646a663cc23be747f78165ffc69493b8958a9d6002c8cc22b7948f953c8c7d3236228b0dd4cd2ba18a075ef3b9376ce7251ec60f1ec25c39fde45f81bb52f55731dab7ca7d726fcf66708d8689572976d87accb4749790c192576a7e824b1243e4d0f2fac10a6cb8c4982498aa3c3893b0e5c3d2a10c687eaae8c102ffbb9dab4e1780f82ea127b7da42a00a30a84a24eefa5f42c79f5a3479a18992531aa86fc39bca4b0cd61df5b4b88bfe7ac0d8b644a028ba63cd3982e8acdd594f85d25f7e3b26f6ce6d2c975cde8f30be42fd41eff96c1a2863f332e543353ac9536fa5a5f68e8a6fcf9fd6fff0003a6a8251c0c4c1f01737eec420942ebf50105698deaba1e2082f651f1d5c5cdf6961df3ee9fcf157dff8ffac12c31db88c80605d7cd8f43e55bc15ea09297dc503933fa9c3d24186137cbba75ac99055bba4f177e21014a5d7a54bce81bb13b0f75b014e59a1801b3a82469f559851914355bb9128cb5a37dfc7700a88e8e5b104ebf0fd3ec5dc600e579806c531709da20b4b0ff9306f8b3e29c9ba2f928c94391943852ca48000395b53f5940dc9de44a01e83d62e5c6f65162883d858fd54c4bb7b184aac0a759b9486cd329d772308f40bd16b01c0002c59fd5f3deb6147c10064cd5de63bf0754661b226b39cb88b322438cade85bd708d1a433b91ea0219325a11f4651c4cc7ff35245fbf144f547c446d1fc7b407bc013def666b7939abab7a0985ec9e6094665ed2228a6d44e7e72f2fab5bdd4c02ec7a30bb11470678938cc7323c521d0451060699ecd7eea922a3d212b7721026cb2e1be6205a9fd2addf0cc24f13a53ddcf253e4d1e7756804768afa97f000ac3594d6b6cd9b140f5b8a803cdcd52a0e7d7d8209312e3eb4e97a71d81df6b1f54211711fa794e8b490c95f90e8e25414c149c5ffdc9a92a50873366045df66a96bcffa320b1fb5d6e1149706c8de7872130934927693036c77e184fcfa8609515b0d57a5e5c772fdb3ff6d1e8dfa6bf85dabfae0db9f0667ae65b0261a5873c3a1c5b6f589edaa474c5c49f4faf0e2e9b9b81e12a7499227a5b6551fdb7702ebd9778f29aa327605d78c2d540a7a1f415497312bdc316d0a40cf0f03d9898073ab7638f31c28e7efa1d403cc9207661953018cce12e1579d52645908da3cb809f9761ab758d70c1569c3aa78c237e83ccfd2842a827c8d4313488290d2eb73f23c6000f5bd108df983daac83c614d49500c9650dfdfe8ff8050504b2189a82d2fa9fb16d557d36eaf204a1c937ca03a852b6983c244381476dd5f8c5a01da40204168daac26ba4593376b225971de08947d051dc39ab4ab1b132a60dcbb7f8bdb2ddca153ab1488eef2c4d897d599126f4315288d9bf1ddba880f85a2549ae0e090d6502f2990b100ade4cfb237798030d75a0c36c21f2585752084b0aad5527596c824fa4a0df235766540b4b89d283fa1397b94c64c1f7c86374179ec35a04d6bfa1a39dba0d6125c4f8d33ae3f88bc3b8527774473916d12a26c41911289546b4e01729773f774f37954cd2f12b795f0701c6a1ffc684be94c483a1a7e0c81c5c97fab05aefb519d28fdec52f3b72bcb4a3f45850dc4579ca7eae286524a25e37f2f3e0e9b8f490db5b346027bf900de6c269c4c4361a9c29ae4f3cf9dccff2648d90731c5a8a4eb1ba0813d107284377e7e931a5259eb65842b65355fe6ec75b848c9070f3f8bf03915e538fe9eb6a5aeeb749278d37b2fd1efdd45bbe188ce43a7ec73caa2f082033fed8d5676da0eaed8b9878013d3ecfdaeebf724fcce97d6eb2598444e384f9ef7e5b24c6f26d941675662d3820822cad9850f1df71cf5da16fe94fbb604aa5d5fd1561fcd26e05b20e9fba536db1c45dfd8c1b339a32f7ae5935b83c3008781cf9bc2da2dd81fd5934c87bdd0987f5832acc54e613cb67b750651f6facd2ea6faed11652f14e19b996527878fda91318e7ba02a747be675163031c086348fc03e7f916e225c42205e1c336c860d6938acadfe47234927e557c6e34df3374182f71dec460959006403fc30054218d86a4f80fbb84e7cc23cc5158ce42aeaeaaba6314188cd76a9847579afd13231b8be3aaaaeef619189526b8747dfbe0a54eb967d8e119d1ad96b06c682203588272051122c6492c7cbe276e7791da209ed5a1293738084695f8bdd1caa9cc6e687e64ee4fc9311ddeeec4f1191208bc59aec116e51a596b737fef25bc46d541080ee6fc8238a824fdc329491fa071de72359f34799307635f621bf62e1b887ff4207bd578cb61feb0131019d0d8560e7c310fc848f4818806c6e6532355c482603db45f461428eb0acfc179d944c44d897fbc5f29d66103297db1280d1ffbba02cb28012c723968e6e46ef2e0c50f99ece9e0cde55f450c7156209d5bf294708567839d28f359eb1e12a512231c1560512be4fab8d6db121d3de20de92597b90be15e2aafcd555787957b65b0d0912381a7a6b4d4871ea8ba38e1e391afb7f7040db32310f1d7775db963347d18dbc09fa687fbf213a1ca33587eabdff8607b315e4c61d2324681372d497c0ccd03e9efcaf2a60871bcf439ea1086be9434b831980cc36418fbea531a379de1847585e605de89a20a83ab85ce48045ed63d09319e444efac4709cead57530e475301f633fc3be4e99340efc6553d4822589aac631577086a360ac1cfe4d7c3f4bff28d30277616f2ebb9805de9e739b05f65d4b621248904d9d83e7f288477db19a354d25b96b53b189311776f7ee434acb66ca84cb72320fecc30896d73eced88a1f5a9e13dd32f47d63e25e407d81dec5b9ac62175d1557164dfe90e7b91506b5f4bdb5966fb70f6b502960501e390d0edd3acf37c9036d1836baa8bcbdd8703a03cb069838bb6f01985c2796544f1bfbba90bc7c691215fb46e426ef5e97ba3cb6f03a5824c12d08ffdfcb57aac35f36260e4af9b5543f8f5ac695dae4414d5a50d9c2e0d8f283881b4ab7607c62037c44a57d74990118461cd46dc4fe1c82a1bacbd9e92dbc31f3ba940b4de93c490ed48344cc59ddeff2566b35cc797ee4b28aac3adf3ee645c533d35e6fd81f4bfc678ad75656d5fec7e5389f60fa06840bd3a81ad2c0de7c1ffe07d79f0c0c71c956f4519c094cec3a2969627e510e78f8d4c1e7bb165c36c7e598daa83921493f9e9b1ea97d46f403e3c636a567292faaea0095513ed9822dceec844ca7b84966c315d25e43ca0845e73dfed1593d584d373d60271c294ff796b7360e6f1388ce8acc4308405ca0a4194494c7aefe054f250c2145c637ae0a08fc51bf4e2e3545aaf7112c8d9f92585e4c013fd682330001b87f54c7a994b7fb9011219e62733f13f6cd0dffbf2b2f4dad6aa7c4b94f815c4a4702bbd0aa4fd087abcf93fd55afed1a132b179911f7742695a4826fe3e404b97a83bedaf366db7cd99f2c49ad342fe0d5317de2ae56b83a5ba5a894878e8d9eb61491cde4e8679828c4724292086d6b9c06840cc07c4c32b6ffb26f5927aa1e055eea0addfd278ca2dbe253a8aa6254c235336c835e8f9a2cc47e165b3fe7a54b2e63f59979888b399dc35df00a3cddd21b531485f504ea872b752442a1842f7789e620bdf38f6293851456cb1b121de0df92722288bea1bcc8b2f24a8939184e048f432536fa713a12dddffc7767546ebbf425b0daefb28247352c9384aaf10dfb4209d84c7794268f09ee48f65565e711bdacb520573a6128142de7479eca0c0b78647fd34cc67ce5072c84fe5633dcafa27d46375d96ac15a92feaf1f9721dd44ffce5a533a85bc92b71398eb381bededcf17aa04258921e1260c56dd688ac18f11f8a91c6140e84524852000eaf7bc6a737a222e292336cd68afb48fbe7e0331d7da1a260c6e2b6a1dff5c98c6f1b3a5210b16a59eb14d98aa14375d02fddef56e3fe4681949d2af835abde5283a1edbdb859265b6d83ec5d50228aac7e9bf334f8c4070f01523930558ac8c8754190a5153fb47a3bb51b120edb61725b13cc8b72e4aab0b0c72e506b39b814628ec134991b6b6b5ef66f8ed444714065d5d76384cdc4f926edc030640ccf83c0a77e2eb39a05d44921329aeea8b17615fbb9dfc569cf0766c042119e0ac1273168a3445859fc3bdee379e42523fddd71ccc421f33e25924be78f45f1d598c9739bc31ae32f9085fc0ea46f0948e529e1e4e7cdac931a898c667d62ee19f745066c42edd1f60d3a6ea60a5db31aa8fc2930e5bcf4b443a8bd497695a2ecd001eb506d48a5dc1228e7d3bdb3174b31315364762e5bbdc5646fbc778bdcf06cce8fb3936cbfb87add4e88911ee410fcc8fa0ff22c8fa695e2d57211b632a9f80d81e3a1aded80551599d44ec1e3450e781e8b88aa8ab9340da300b0a0b44ababf11cac8d06b015b3b637cf963eab15ea58fb5f7457296d203195f5a287329a14fb544e1001163162966d0eafa156ed2233776ad832c4e1e5654458b7f7861118ef58acb0de3b309a30e46cbd9b64c379af9af72ded4b87f79872c4cb882fc873cee915629ad58f82f01974043ffa4a19aaf7fac6292de3e2a8b895eeba8034b62ae4efbfdb8591df44b8f5c3b0c2eb68ccc820d177ee281882300fc37f5ea30778f3ce2a60df0618f985bfa1c8bed139b160698bd1fee0baa1b89acf890745e86a1918608bcd3a374ecc86eb6dc8fb6713c16289dedd822f28bcbe4594e571a4bdef48ece4a98e6a5ab8f9a14873f81a95ebef5046f8768cd9dd60977475f0589e41b48362ac44d07bd987f472a5a991c00c3e972bcb4b8c91bf88fa2449fdeea9a45c905f0639f3898a471603aac0acdc9f25f3fe85020d20cc9b8614de8be4aab58de9be72f75929ee2019e7d729a234e5dd11b5b795ca791c432ec2fab4dd7d130afc67abc4c2b28282aead05e7d1d9c9caa0ac27f04bfe8e856e1b985a784f039209ccd596f13e00baedfeb805b01b3b473a20a7e1ac9c370360a5bb80601c9db7e6b581f08bc1be57338ec079c3fb85e834400532bb0deeb5768abb31a655382ea00eb018371863cd6a8df9ca1b1b4e04bedd2c7f306cb65612bccc208674402c409cb071b0f101a97684686f3536bb0f0ac4c1dd85407ca8999584b6a9bc0b550bc5e0a2c16e80d7fda0bf644f5c232d02fba5b3e3f5772c08c8ae0fdf602ad607c709e97faa805dcf107b729c8ab7aa48e7b3cabade2c5323dd3fdd4d834a29f8cdd7e7064a341d0bb729a01f10684916407cecc42f1194849c5a61cab85ed95a042ac067cc8be305295c14601a00b6dd9f338b9fe19b3fd6cf35ac53498cf20121ee383a4e6947f20bf8c23ef8455f99b02c50d70dd8ae306bf310067e96240e2577c8cd4914a1ce00f942d986e01676b15521a887d372080f27b47685eefba83615b34609363d811c0b27b5045ac16c84cbba4fa6f53dc64dabebb3444a41bce68c8c59762727162d52a37850f2d6cb67df53cbc1b3e013001639792c7aa9e44e8c51a8cdefd42db34f4b8b56f0e1440b0d8ab409b9f08f306fc917654811fe99eca1616be514f0771b8d354b1bda688a84ef47f57d7d7b97332eaa365faaf30cbee3fbb02fad5af6522f89b2fd771f5b3b5202ab70c31be03f3616fd6f3fe40bd21a77f4afbbd115a30aa55c9f7aa089dab22e9ef9e4530616f139368249d7828aac8114d87fc7f19a892e7d3551a69bcc0af0af5d07a0f869ef8ac9f3a36d3502121a24142ba412ea4c1487ed59547efbe3a30bda8e591c3840d3f55623a3fca8c570ef4d639897ef71ef6b84d2ee5d744ae36d6ff053dbef2590fdbfa101047a31d9bc9b33da141ca4657afa055a6bac8ae0a8a83b2a49629c39d569435b68ac40a226bcb0076286e0d3cab67bd7988163be775d4b9a62d371f1e11e79e9cbf96cdf35183e32c1b1acaaeeed98b65658b23cd9f6f1edecf1389ebf528a843ef12a68365f8225a219e9537154934f59399e58cde3ca68cf7619efdc282b32c71f820dbe004d81510cbf1c3d0de21cea8e1429384cd426cd02ddf01c34c408efa2a5c9d5eedc5c6ce3eb4564fc95b1c375e9f3572adaa1ccb0bdc3c485a663a851b42cacb614ed532ef8f9196ba5815d07279721f70b601f4956f0949399431016981b9530ccaae97875affa16d91beea7897f1287334e8c0471712731283caac1ac4c4de469f7928066d3054eec119ef8d0316cee73f5e64bcb0a9f29de98adb896cb440a02d0e4fd8527e94f282ae5647f5b81ae2e69624c3dc20644c61cd00735031dff446e8b9b403f908f48c9ddb5fd3809823f72f3f135ca610e6b4ef741f5d4315cfd9ee9714e9ae20360451cf620265b49a7757c5745c6eeee77560773ec59ebf4b41f9437171b313f17645dbe75d8ce9a4327b4a9e7ec9ea9c7c3e7824a3d9c89c54b83195e8cdb90b82d33e0cee5a76a91ff468bfb3660bc15c364f4d3e0d2be4ef50c9ab61baabe3ef9d5650f6f13e13cf5bb641b8f97098b8a8aa92f5a6870fb51101ec8be19e6af32f5e950b4418533346ffbffe1a789a8fe0cee8fc70e4978cdf5a1263b70b4252588488ac4c379f084a0c0ed7bc060d633b533e54a93012cc5221284155da006c7f762bfca233c0b497ad4b592da7e8638c91266d87461191e1b33de8c03e9dbb3051a619d1a0d4aa8c3c0380595d723a68dd2546d41c4709d36fad9e1c9ee1ec7cd11e1c814adaaf3a015f8479b282ba88d64ce032085955a5c2dd243e197603a3c1319e56e20101e028d281a61401a936e6c7f6be1be721eb35f5a33d8e700e580f6015d9dda508ff6ddc9804de37fc42beffef92679c7b6dedaad8149d1e584750375d45c2a6e15bd5da683ee282fb81093e55671823f73c5113c21b90edc4949fba3eee0cc5686e4afddcd45b2988b6218412ea012e2f6f1e6ce5a5b295ef38297a4ff8fa887cffcaf8ba9fe65940251a21f136f8407207fb580f43f6a834af1955141e3eb4171c31766a90018b8ee0c3fc4c0c0594e8592ce9a310ac64282d15454cc5f18aabf8f45cd720bc23aef2e00a4caae56cf45750daa97a54304da03a39e20ab5ceab45f6c8e0d8d738d6720cfb91a06d3f30dd0bbe9fbd3e0945e4b3e053212ad4c90e4871b03c48ef5d6b06650f147948a5f9b8a505f27fb3dc473803cda30c3c8b7978ad0c045179ef75a66b8f395c1a1dcd4ccc16bdf7d5abcf9be6622ec182eb7fad890a9e256af31465010ebb480d7d68aa90b5e345ac61b8445dccf152ce78b7e169ff9e6fa4f3422c7b18e771eb312","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
