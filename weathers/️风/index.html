<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54e72837be6822e1127def2407a71f4ba280cded5bef55f2d9ffaefedf8a98003e176cb77302a4bcfa5c6094d19ca4b6159950962ee4790b6df38f0881702c59d74d4bd5c162ec1a49b41f2d70ce0f8eb9181a32b2116ed65ad27c32d0577999a34f451ae4d08416131a22861d1fc4e356a897f86d295a888660d7793a365a193070d07eae583eaf2e5bae2db6190a2cd39caa967cbe4810b66b8834ba6146c1b188387898b82a06653a199e7a3ac51a7897d7510f335f7dcf343173ac4dbaa774f4ea0d8d54a5016500a8f93c152743a22968c0fa3a9fc4fa1ca678d72976e18d115f6b5dc50a7a3b6be9b67e27cdf2091bc7aeb94c314383bbee80776f887b24b5d2b9ee4d5ef4e655c826fc570415c0502dfb967bb7c9f90853e9e93933b7d8d750edc46cab948733d23812b61c86158228c5fe72315a5d51d38071b408dbe5c2d6814376623a16b0147a01ed6f2cde2aeb3d6c79ecf69f1c88847ddc33f47ea4d2f5dd09616e67e9dd223dd3659b3f5c5db72768895b722bba9f5db7e2cd47c08e232903e3a837e9efb670fbb6ae02bf9376030025e7a7ce9c6c1702934aacbe2f8424515033a0c6ae91b2cbe2738c8674a48145ea338b8cc8ff3d8a4dc82e8f9c18bbee5f058b8b04dd8691b55baf5cf022286387fe09d178d81699086f5bb4d33083f4d4ae4ba332043f395aa8a749bc89555222c577c220f569928c066ccdfe946c0d70a524cec9a6ec20c9c637e377957f4dc211fc6dd67b0423ec972d08613ac1cb8dafebe7165f0d5dab9f801738a1a8e7e33607683b2b2958f3a8461596783872e420bca305746a83828ec48593d8a9711820f3a37ed025524c5cc04bff98091de213ec364139ed61d39aaf55bcdcbfbd92921f3a63bbe82a98a602c4bbf5dc4a851eab0a4b5c1be803aa181d692f94c9c780c9710d6f23a81f200719bf1aab4ca7770ee0b5c54421879dd81d33e85ccd373513922f8eda0cb4a69bfda33c5f1847225baa3e4c34bd63f274b8e52a3fc4c49b1908520501db1572ccf071ae7b0d7b2ffdd18ce6404558183d7da8bfa414323fb1312c08540d15e515a8dd0fb6f1936d308f6a74e99414189a9950a6cc914c9e537740e20f0d00ca027fa5f404000ccb0557d5842fd8f4a04356c262dd831081af21f85941b96fdf4d53328b969719dd12ef81d4b8d29d15a54bf35af8a16ced3040c2b18b0484ecdc412557b721140108ef133b8412b52659e377b044e54c9cb11666020be5e8f22a7cc05b83014c1c8093d40cbe6866d534fd6ff56602e0f28a4a407f05362612a8b5fe9d31a6b1b53d03ac43a5367a5b945634d3aabcaf770559bd8709d6ff3c9ffa82e0dd69aa4c7f24131e8db2eba732300d415f93431be8c4c5f1c3438e85024ba5a1dd0b55048ca642d206231ab7d5f2f3588caad8c41f825898938cddf1a769425247f5b0776bc946698ef365682d81f42627c4ea57b7e6f660003e927701dcea3a14e9d39524fd416e560e588b023d337f9848119ae8fdfb8d9245e8f5a56d0f135c2a22781afd5d9bde6654b43b83026d5cdb17da517ccd92febdd1687b29cfaaee19d6077a0da2f9d5f84bb7968a98915a3634428df94ad0b70bcef8d00918199ba8625bf620642338996bcccc04bedc391f7be4fd2e479387bf62ccd50fc88b53ac4a55e973ce86551c08ee27432c419d944bb2510cb3f16110424b0770e5f66437faba50d6ebbe3b8bd94fbe1d6aba9e9909111f2b47f3d4c2215c2e6a2ae5812f52bd072b87313a3dedc13dcb684b7d3d6c3afe8020afe37d53143e528ba5d7d20737e8110f46ed143084edcd8a5b581c6dadeee2433e28829625292407bbccd89c25833fcfb5e9a5af7d00695ae246a8eb922a69b4acd85a79d7ca2f7e1d8a3ff7a625f7058e6bcb5a3a2aeada425745bdde7cf70c2843fc8a491a579e62e6e44c7c1103e5712e064934cae0f190b555439365e3ff177e6f7b464067f5966e7db6b2732b5a997272127603765923240200aef85f315c342999d26c7f0c9679a7c37007919f33bf803029eee97a8c6bd459b605014283d2080eab6c6fb978bbec7b783ad5f012c88598ea0a25d3833091f4999806aac1fa53bf1eb91e7ad480bff19f867b18c180b65d757fad797d85f2a893775dc69b4ccf06e724b036f90263bdf87e15cfc95692932ffa35494d6645e7cff21627c67c92424b4a1ad4ed663c5095f468b2bbaa566006026a8e97add50a3970e75acfca7f3004b864fb40cc9d4b966b6a9833928182d8385811c8a265a7d1c8009cdfb5c7446893a2ae88db8b432bc3b0e1aea35f55917f98b22c65931684832e3c8b089043e1f24990ffc08cc1582a6d3a3ec9ce8b5318372266924d4c1ce029937af5f0b5c8404acb217866e455af82b4e7464049156f6699ad9bbeaf8a8582ef66d916d7da2c63f4b8863c026fe543abbe56bf7f7e898bfaa3067bc3fe72aa80a5a63ea7e44bc64a33a609f14fe177f71d1e41fbf7ee88b64378be4d4a029fee239e7f0f148e67ce07c83186e6d4b371e492a628cc06122c4877e3ae24f5b3a9edff6df3cc1beda9cc8d18674d562eac9eff91396c1a36279d1f3ac63764c05239456611ead98670f5379da1bb4ac9a7d94d6091827046df397e3627c7fb4214fc0635ed331bc4f220f7a034b69a738e341d76e93997e32de4756ddd64b746a0b0c9409e1bb90c5e98ac8133bab3e287af8883806cc49e352f542ea9e32f2b3a2de4299aec83e434b79a1b45f1f3cc5a2b8b842c87546f4bf14a09acedcf397eceae772bfc7767748c435f4e0e7807121388837d342efff954796ab9fdcd6701aefbc9b54657714bb4ef3526732955ea3c6c71de63100de588d03aa8b8f3c5b8ab242759c70fd1ebb50c1947651246eb60c8475bd412077c8033c88d5d6e5386bd7062a590ff85334ae2ef24c1feff5a2b072b1785397ef36748281ad0db81ad592600a1a98d8d21fe9c9d8b84e1f04ae41398256a9c628a83fef18f4f4ede75f82523628f313ac0561c41a5464bfa850a8144d150fc2fe43ba74e872908be7ce318383ba7edabd66c1f1369a1ee70f76903ae776b107d0d96967c15a5bb9a1e5eca6a682039b8158a952b07520d6d08bec4422f03d7cdc50fb5cc0aaebe0e3aab9e1e21434080c19b4b6c0f79fecca12ce1f3165e71662997d617d09e8a8ed5f8996c1d04930afe22b879bc00295933a629a4f0f98fe2c8a8bc62867198b6c35e9fcff3653bdad1c2bc949ddb8e7097bccea5501d680a4f29f960844db1c612730853d306da771a35548fe15b4859612a2e2940119afd053aa25404577e5fb8321cba2312a17e559734c846820637a0482fa848eaa18417df83bf5dc4aba9f81b7f25c4d734a10d10a5799633fbe05e723aad8cbab24becb676fe82036f83e575654bd4bd38bdec5c5114482b66327c22929b9514c6a977c45cae06309575136a8dcdbc4df7556d3639aa727824412b23dcd1068cbe1abfbf030e1674db40e603aef66c8f3af07f386d68a5c96087c7b61a720c6040903aec80754b0dc462cc617efc5508cd648651e917cb997e115f2fb9f9ee4ae7b53b5a5fbdd72bd452c87fb8d1df4992fe3ae284e62151471361f0333e85fa3ab557a40471428dee204c3be1c36e3e98a95e48e5d8080b9075fd61882184d35efdc83694adaa8cf030e0e7cd36b3d3c3e08771d3b907f0942fa206dc4d65c5b37512b8aecc5dd196eab1014345b3ded5af8b9a1af5e50e010562b08a43e31c9936206b43b7200adaa195899579984713c31e6939f9287c1acca6c0bc1404da5aff2e261d65cba54485d4fb16e587f90275bd98cd4a7ba8a149faa16e37e86c8eab395d7fcf31a0f4872c0c73ffa66b80a012402891f9ce6c4f0ceccc9dc5932b49b52a837883887590a728596e0da5a00653541026e7073ad8b6d3c4a1c4ffe246262349e6f9f6a2ac2614db754c093455c28f179057555f35c02dd598b933761257c1b23eb72c96baea6ed5314f02a791de09904419a0a21bc40f8e5e9df4fb4fe6c1f7a0a9e9122c9c1772f3ab2dd386066953dd4caafed020306ce6897e0e69fae6b6f06d3eee2686c8f10ecb49cae9e94a317d6af8465de16e083eedd7e37252dc7646b009b32d4c5ee68db9f08c2485cbbc1d1061c4fafc34e370a9626d1de279047eafdcf2cc303786610740bc8777cea3e51e794906396f52d0f9e1e55cb189c45993d3ec6d59c7ed6236fa4df935030dd7878132e23deea7bc478c00c2c9299b6c431d409603d60666c776aa72d411ccb26f8040403f942c270e77cd5d56b9e2a0e67215558e1033cdb7b5ef804d4a904d16c010ec065515a93d37bd5689463d9e2b2856011d2b1213a199f7182ff274e5b45dbe1fe638b96d17ebe19a2a3c2eb7f3794249d9ba07c1005bfc93a730feb34131ebbc5fdc62285415de4972e5c9f4d43b3eb0365c158a78ea62d8254655603462138d8860da21b4833e61c24281da136c56f2c377846cc412be0c82c446543342907ebe09e467ce84b8e2251841c1d4e065e83d53550d22623c0a21bb333ebb63879a938ddac36b99af74d6a3a7195b4318ab29034b98317418f9f969dd7c43457970962907af8950553f1b7566325bb2748d741aa49e595f86f3b35f61d87566a925293305da09ce930081b8d99564fe8c16ddadcfd5cb51ab0c90e8e26a2a594de1a994502ea382ad947a5916bf1fa6864767c298e4d49d66c74c6f46bc6750d67b8959cc4a07998e86604810a8b409dc4dff7a3e05e02d561c627f0e241b66b149b935cf0876f79e2da5914abd01433e809c29889cd864f2f9780d8d0005f32dac2c7997933ec291ffd457cecf30bfb32bb6baa5cbabb50b849fbdbcd86def996fb72d1fef07e89deca9a261950253415c0c9782adcd686bddbb6ffbfd2d4fdf98bafc013b94963735b4017f5333e98541a389856981a6a1f0c9afff226c4ccc4ac1730e12703f01aa86276d29a0f73c330098b5726314ae04e0e90850e98b265ab4ee1187e4842eebd15066610bde19d0c9d69b336aaead3a429849aab484031b95a567adba5a8deebd315a46d9f8f96677fc42f1007c5700fe1f9261af708fea9201f1d00c7d6137e3b3b579d77991d86883bbaaca9b084568a02db1a6a574a60f80db8a2708d93a40f3ede1ad650b2b332729d09e008237fefc0112cdb85753b31c70bcb5c7c312f4ec85f8a5815b903df40e7144001283ea1f239ba510f14a59dbe424290486d1438e5d6c99a2670d46117a3d8dd98dccdbd6ca60c4a17caca4b5580ee5f781e129c1721cc4bd6cc0e9853776cac3935e95531766512856d082fa1bc1e4992056210df083f99f26c5c73acc5360582d9bdb403755425dedf656095d6f4fd137a76d3159eb89914bc0bc27fa66bb49b280aabcd07811b9714eae53640c9316000f1107f6675c82954822033ba769d536f960d51594ff5eabba7f0d52c441acb6eddcf61bdd4486f91b104cfae9e33dc5e5eda21eca353dea22f97b853ec10845ade199b72444a19c1b97e6b7cce6d5f7a2a8a4bb04bc6428c18a6faaf2d94cadd32657dc7fc075cd4d6d50190b86268a4f9bcf13b71b2d3657e770eedb89909d66b4f14c8b9beccfc076c7b36c9d49a8626c5415967ba48d94b33bd361f0d304bd70e7e74611d7d905bf61cf3ba9814f406d274db2efa98b9701d8c399226188aaf4016e018c850ce7b874b3e44869877c152be3834cc8f7d499dd3bd621473c75d844b77e9c3357d5a511c71fb88cb27686daf7b9182956f29595a3e5f3f05830cfe10e48b2f31df4ea827e070a41423f95aaded90c71b5b3fec96ad04cae55ad0972597425cf73e34114d5187a58dbba0e9508b10e027f80cef62d4aed2539bb05c02751eef044bf5e0d26af616a525a299de81d5219dfdb80f5b060f57d57cbb67fb8c7efb02166e020e569e8fea3361c19592912ef0b851cf9fd172acf43f2e6b9dc7c4310200b56d7047a14efea09b5d70390b19f020968caa87d3a7dc145472b10d8777eb085a3ed12b2ecf4ac62f37f2b39b772d0937d54f3be684a74aab239e7bab3dd3d87d17d0eb8c8da169e6f6b63cdc2df22a38fa4b644b78a3bd490a2b7a5d6558342bdf3c13c1e115d51536ef78265be846d0c4fea306877eb70553c0391392e957d29bc30511c7d50074b1555363ce4d0df9cb13e6f010a6a9b3a66887d65004b444015a3bc06dfaf7a2d4426b51e30a1b50777b06f27f9d741c143e40cbde01767fbd5f715d9a022ac49cf554910ddb5acac6602ed8e617c8e91567dc5f510152e244ebbe2899b726d38d60b14c2cc8c9df4e1d5a4a290f7208bac327d0634d5a029b2ec55710b2c2f8b8fdf150148495a8dba43c1e08fd57e8838bb67da42b6d49d1ff5a8198808931e99b357217ebf3c8c91ea0f39f47baa8d4fdd0f67b74193fbde9992cdf5bf92649c6782c3c6907a40a2e95a261179488b3ad919fdf368357c401ff759c4b04c421a899325b2a250d68524060abe5c124dfa098b6b1ca8aadd9cad33fdac82dd56a7b833e3dc50cc93f0eb6b26f1874f57bb437428b17ef82285608b97ad27cdfecf5332fac7055064d1a73bbdc1872f5187aa1d8830cc4731e97f7b2ce4aff364a1b177721ed3b52b8d48a40348cb8a89834a2d3b65a3af07491d6011595926f289bf514b4ac0d5e230179efadc4a70dcee94b65e0c745e662fd52457a2816ebf565f59377ba7900806a6e75b8c4e501d9663c61a00e9bef4d98425b2ec6a9c0236f91d5097961cff09d490e889c7948fd21ff8646700bbd170d8b0118879c4aa60922126dc1cdea25f5234fa2c641c60c29bcf3887b54f69c8125336e35752c6f15af74969a31d6203db851517c030c91b421026859d4ce49b9951c3cd43903270a1b04b02b3653511d50019d7075ed03bec40847ae9f2069dcd6b1518c3d1bdb3b0f80f702ee8f15294a718fd48eb87fb6d6ee47d1012b8b7133c174c7b059e565ccd837e651684ea478e16cbca0bbd199065bffa375a3d1c668905537f6af48db644f1ecc1eaccc7caeb21ff383720256b1e28a8edad622142fb32c4d05e3175faff998bf4b7d24c6ec11fe543f40bea574969f312a7cc7fc7015b293cd6f1d94be180a66057c4837799d7739c7b13f3d9743677fd0fed074b079be03ef1a324139c2e053281c1de12006aa678019a756bdb68a6a9202425bd013b3a9fc4c3e0a607abcb8079661702039fb4aae7e0fd725a68518e850de9ceeb7f569222f3b7eb33089229646227e7ac2bc60a218402fc60c723de67dfbf359244a53785aacc5e1127c03de1dc0a6a9a024188d740b69bdbde2a5855d3d23e2e7f571dd549c41ec4fe9fe2d7564d42e7a5c438b3c88c42cd5cb3ee69dff943a13e4717ccd2d7d2bda3bf76384eecfc5c0b63dc589c3dee877abe2f1c3261abc27e7f33761a8cc10867079b4e69b6f832a0d73f3f122e0e9dec6ba4eae61d1e7aceaf30c64b21e6dd98e1dd6f5e946418610f9faf76411b01c7f8604045f732b3b9ca6975931241ad82cb3f548c5a3bae118c4b45a888a6d09704a515ab0e24b08b078add746264d475dbb811a80e48d402899c12f74ee62ffd81824c5f8866a9a3d2432762b148834ee67f9f4c947169f9e6dbf563df3d57342fd186e04725581e6c654f185c5070bd5be595b45c0dd9f87a71b06c9d45129e4dfec055be9534ac7acd6dfce203f1ee32a30144d47120bb460cc1368284b5db1c246ee08d4949ad5a9be0a8249d6b6b8958d2a2cfac890550355287115153eaf297abb62db69ac8a294a8835e9ead4db385d5a05c2b589efb619253fe895d966d6f42057dd6adaa8394fa91d122f7974975a6e27271ba7721d2c8fa9396175a3792424d98e9c031023aa98058e53c4157f651c77f32eeaa9700b594baf5d0c9e1584e7a89156b535114efaa72abefbe81829ae86a730851fe2cb1f7eff8433e8f29ed1d4d01b63611dcbe0bd39c11b1a4a3b4d0f965cfd091184df16e2e93409d6b6fdd025b1f2ee307f215ea3ca176b974151f3d950297bd2a6036abe4443ac2e017820748156323698976682615637a2886e5126d6a3d62a021520abed084a890685432fa7562fd5774178e420583ebadaf17af6e94b57856909d2d4611fe3a886b21b31faa0f75d4aff41529fe92339fc022d085c84e4bd632a4420d41ff7034981075a320ce3c0a9e93825aa2fbb49f30f9825632cf70ac101b8142fc37f90c24dae76f0f286a374c7f3b3e2ec73bcb50892d07f095f0a7cdf284f29595cce4dda92a2939d18aa75d9e0a9eb46e276de4e173ec7c4c76837a1895c78db610182c353d0c538e97ae519e8006fffe5a0d6f801ddd2f5a1c7a0bd16ad01049274dddaa4b36ececca051a677909cd15653c6990d64f9e8569f84523e9aa71446763e93346bd722a8b3da9c3a0ccd1cac9eb129c4565103fa6815cd0f393f7f5492419f33e4365dd44d053d8d8f6a42ef3af7c26cf70261a365a9108b0ab9cafb26b0c0d22ec3d536b7bacc520b7e966f70adff103137256befd853407d47dcec18300bdbd25bd663fb45ce3064fafb02ade78962ea2f74b9ec902bc7698e9fcdda57d8876cdb9b70fccc6a5328360b1c8dedbf3d99c8f1a5d8c972bd9e3dbbaa04516ad61ab29e7cab8e595cecd9cdfd3c9c4446163073125929026583e263da801fa333faa9d9ad58529a5b7f6240d0df664e8d60998c55b4f6b63154638e75359a962f3f620c830fe71e245b0c665c1eadaf30382e21112967935edbd0d7795aec1e4ec6098c29b0cd481acd509f703c722d6452bb2298053545912c8ae0ebf8f0d16ef56605e288a9f1ce1d12173a71d52720c161847789e6035b4b8cb78e741b56ff392d0ef9ec0e9d6ac588b955ba74d96515b89b22331694e9955a33634796f77e0636b59ec3a69226a63900d9b87544d3a2fe9e26ace4588930a2b11b4622bdbec04d74c70c828c70c5e932a908843b368efb3acc24e30d6b9762063b9b40c634fd5c11b4a19823fe881a51c62c52ba0246f564589a13820be1bf1177aae9302e8cb660447c91818e55c21971f7a0c8448c041ea8bee5edcabb4544a82505a7cbca4037778c34422f2c7639e2a4a336482a3cf7f717b4d564ca27845b0aaf1cc2a7ae3dead7b58df826022f8ee27f5cffc002de344dd7f66009d566c3840a110b57e0d2bdb32183ef42bfdbf6c9acfd4bee30e31b23938bba3e4e34a7bcd2af65a8e9956c734c2b02f32ca1ec0cbf303b6cf5c86f19a69c1732535c64036a0fad5ca346e4c22d2289f4d354a6884110697d991e8ba1aef40e0db4ae87aeebc92fcfcb1359a5634c586cf290ff2e7ec68c735ba7b53e2ae22059228452cfac7e782290c46546d2e744f54af22762acf25a4ee4a3b6370c26d1edc5ed55c4737e18b516336249e1a27a5a26c65da4e498c4849dcb42162c8c046f9875b7d9dbb8d9c05bbb91bb409e4aa9f5bea217bf96ae76494dfd76f8de73937d98e581e7a6bd567c9b0b3ef999cf208ba28bb0a244b97edff39ae83167860dc42acb179857bb148b968ce9afc86c41af2ebf1c03cfd41fcb56043484f7038ea6c9494dae02c32e111fffc4a1cd4b471e8adea988f456554d4a01308b46d61b701f5c779f27ce0c8e12f254501b2ea4ceccff4cd5c7d5d463a16163c4a104e75bc8c60928216f1ecdfec5a084297b561585b8d31b18443ff7f737825ddb7df69cf9f50d03caefe9a309bf0d2013f62af8a40f6857867f3f594ee120c0a273b79ca41aabd8304d0ed6552eb66f1f7cdce6af3a031d032c1d0fdeb7bb110645e780797a5232fdb97eee200052f8b550294ffe29f3350972d5e07014a99b6c47fe986bdf81b21e4ba6b6236c2be1eeb3edbfe73a684617786ceb1034912943206b3f8f9b93195ee6223a7e7cc89db8ae2f1698058db5146300cf17831a19f538cf87b211d29c92be480e0cbe76ca5a2a6032c38e52a75ff51f7dfb8cb085af983650aff663d58493c3b9a2f0a86e5458db0c73d39c9dba3a663f2b4abd0b6a163ab2073152784729e180b71edb1d1f21e25fc00631262866e1c38ebd5fb7d61df0e1c6b3bad59d7651b5da131dfd39fead7b34fcdb358e8f8dfc9bcd1bf59cd57b14d6bc3ff3cfc9a4af9da3fd57162bc9cba634adedd04412b03283fd0c09417d9da5ce1e508124bea9ddac77fb4f96c97aac96e9d901a34c5fa7a5ab5955d84fca222251ed8c38921fc5f20e124b3b2f4c3c3de30b383f1635847118b0f5420a5006b8d1ed3d1a09d898e9a3174f25274a995eac0edc1a99ab257472e7c847d4ef5f00e94efe9d82d4403a6746cb807e19d744c3af42b2c49c4e0db59c0ec99620d2de16283a25335ba8ea47d728aa668ce4512aca58a564f2fff93a613696bcfe698c4fe4ecccf6435243811893611a8fe07a106584cf10fb3d0676d7518f9b0a8dec2fe70dbc5248647fa6ecd6cb8b05d94841cd22d74141958c1e7345392163eb0b6dca00dd3bd51affa9669135c70d085aef4456dae0cca8316e64ebb5435a180c052793ae27d9513a2d4881675bd7e6e713d73c3602b07e6539764ac0a7ea50eeb4a0118fc66270e2723e35be5b99b3d15a27f97651f6a380d4d506235c106e8a8f1614647c7991b26","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
