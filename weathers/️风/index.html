<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30a11458fd2224a6db1dff1dc92bd16b24aa036f06a0bd1ea3dc702428d8edae3ea7a37d35daf5b4f659930d0df12eba2aeddf2cf1258cdf576fc1387a5974e115460a503318a5f928bf62dc6c6a02d6ef85b174810251dbd3af09ea45c3b75a3d92c78214c2b6467776e7e043372e8ff2c15686f64d90cecd31284565d2962497aee2f29ca34e40265ee6f3b993a3111a08c1a20fa503b9a0b2fa35edb3bb6b6da4403559bf3a8b94e8232d38319ddb897c8454e3b2055089fbea922737fb34c5b57c3305a82088828eea4b8e0aeb79d8b5c68883809b1284b6739737bd0c2328b73b2bba85ea38d805d96c5d46aad5fddb27cd8c245ca5150f480d4539c987e27b9fc57cf3c1a2e3610eaaae593283acfa4bc5e918dacfbf8f96eb45968a0144eff47b5d6e6b584d89d619bff4674c07bd378fd14a76312d1c3f92dd642c9e9f69a64431e0c70c7a8d984459033ca6d2ed56ea9ccc13b7e5756cc903695077670e40940bfd2436dd6f08208ca28fff239ed338c38c1ea628a582cd88dc43bcc30a18ba4472a63489140e00b94be68f6f18266ed0155b40189bd387bed75f6b3f00f72a4155b53f52afeacbebc5e7925a278c5200339da9d36610117ad0614d0a5ba168a20e722c1e6d1eb78eaaa2d342702d214b7343a81d597bc3191dcd82aaf2bc54b1d676a38c6063333549b635e1109da2f59e0afbaf3b1abe62b3da695af782e5594b85e20bbd1205c908c27595a25d49b45ea275d7aacf65c172e968e1104151db7067482d44ba455a965aa091706836a53c74e623b6d995d2afd5ba526ad00fbb138bc129d81324fac6ee90173a5a3e39d24b080bb7dd582c7ba1c0bce615dbf85b8c39dc1291f9eca07f642c2e842e75c2eaa8eaa92c4e892607fffe56edcf1a4bc9a2020005c000d71548a04d5309e706f9e7e09940dc9325f5b412df8358208114910d1f316823f34ed4ad7fccbfa5b1f1effd9fccc01dbd21cf345d7a497eabb507db6cab1860ce549fe97969122fc70602ee858e1efe516f471373f6ae24509db79a29d935dd53428e25406c9764c0f8f7275144e46c8dd4a32b018eba7c474c0b02716cb8362f0097fbfdf76064c1a4dfee75f5709bcda576dd250d88437d46a50fb615371f1925cb5f606a63934481dbc2d828e832e2aa37162e7c134db327664b69972c33eb3dd8f1dee7c06850d1b439c88db27ddbaf9625341fcb66eaa4037326c0133954588776402bca3bc545eb50dc0ab7156b1765f0a1733812cf69d3f596f5a642a619651950780049abfc8a90fc711000ef552c3ecf6b76f81df7f278c203b9a097835a83344e3f6d1d77f9af991325822ca841d681cf50a460db40a76fe2bdbed801296c3254a9b18f0d298b1d69984dedf221aea681ce91585f7edfc4c8cab178d8db6f1ffe4ea6ccf85d4bb553ae5e3a34ed7ca6a9c621f5b89ad18b8ef09bf57b54fd6fe572ec93b8459bb1de60176bbe8f50345b84cac928a9edac5c11826a3020615e79a247126d5880cec43d7ecbc2b3bb0c1d1ce46ce431474b6c80c5a89e382b7ec3633237c1ebf066d1d8f5d56e42e4ec3de8e298d40511fa9e6f876eca767a42ded12f96f294a3200a92a92f9ed5af1ca9408f72d1e7f8a0c6d0913439f55ece0bd31c7171e714e023de5fcc7ccd87a8e4aba0e1d5ffb65761043d7067e190c0362c1ae5d0d68bae17585a8ffeaa21cd851968a9c8d18d6f3088ca3b630b342b7500be122ad24e57710621c9e83f180f6a084d257d5eb97a73c23a659670a14f7c06e8d026d02fda79a0d7288fdcdee7563bc1add57a53668e5230ae11c5255cfd46fdbdda5094598efe52430b702dbd96afdd161ae698419c38f41e374deb45df0a7bc80210f39f8386891378defd0730eb99e1ea820a67f6f2c2bd2505a3c5256fb41669cbc70cd9341a27603fca79d0c4c725b96a34c5e320d30ab15d7efc91af16d6d2bf960142034fd6b1f82bf3abfa42a5a54baa1f904ea93f379e9d1c8187ed4506e4b67f51df4dc4575ab894431a657ebd4b6544bb3bbfcff4c1ea93ddd93d4971ee6be33c416d633a4bcc7b04e4b18f446cb2bb7dea7e4c6cd4e714a43a05e923a61bf0ec81600fb7b17e9a863e16a7804a7c228440aa5f5f992b8c4cd8ad8254719a017a088ae1b1fad9db7786cf5dd0d58f6abd936b687e4fd1c1daefdb21b6e981582fd3ee1e283c5e33f49076226bbe2e9879f935d6ba9b16187b7729ac3af95ac1436ce5383eb15afeef9b765b4450d6f6bd175c905df651db45284c12726e31cfe2379f2291d960d625ef97c60396b58cf8ba12dde668409a0b0317a99c46959f86f44fb7954a2a2fbe2aea6c1eca3f01cbf7ab2c0b5bc499eb0f316750561e04e8e7cb64861387801221c3d322fd9e40e36bfc83b008d382d0bf73efb37893895b0125de8362b329b82c5105d7cccf11c14213fb452972face5732b654b965a211eabcdc0ed1378919597689f8eaffb62bbbe24f76ec74e82680abe1888b24342a57b8009852a2c1da8d572d9bf13f207a05728c9e2e36c303982d336b3419cc38b402c49c341e79df4d316f42190de6c4eefa5607eb3f6fb0b8fb067650a0f144b357b757f30dd75859cccca4adb0abdd9a5cb1b5c15ba4ff10d973551249ed7224db84067a43d91fe6fe438c3cfe8f297d5706c4fcaddff461423d5c206c54620562c1733f06a764ed70b3f41946e1373eb018acf38e782e70b444ba1bbce08ef14dc7a8d72af68b86912c77aee05beec487730a2ef83df142ceb4709a4d7bc1d10f4a42bfb504dfd5ceb1d0b2d22b0453dbe772e7a7a86293cfcc28c3b013b6f693c3e36584dc28cd4709f553eb5a136debec5c5812d6386ef20d1d24b941086d881c9d151c327ed1b90947427c41ee9904eca257872b76f48ed3590fecb3525181af2de6532ee8a90574056e8f395be83ba89cac4df279dd63599c2fffb8b73b9d060a1a96e5832f91f8eff2892e86730feca4bb008224ca6b6adbf5a2814ae12a5ab855e061dbef04ca99acebf3f6ac99fb86235d311be20192fe995b4d7d6488e5f3ab7e43823b5693a9d30398071eaa973f41fda4da4b2b9c7e14152d6467de3484d8e832171458e2cbb6185690a6be54a22e1b7cfd11667d13f4baf7a7f2feebcf0c9d5151d424570c4f57a844d5b58b9f612f416bebe50b44ca02dd51b322f9e14594204999d55d9c725f89dc8fcf3156d2f30dd851d31a9ab962dcfef53c0ec08aade3dd23b58c98606e7dcdf92cd2c8e93f3c3ebb0c83867e34c9d8ce8322b567d9edf6290242b044648d89cd55fe0f0829d159b05fe93c3c6e485f0817415b5dc2b3633e9bcd19b85af1702a90e3b3b1982cc96137df7415bd842637dd208afc3e41de4c5f229dd67321019821961322ee91e5d56f0888457ac54ec2c5f79a289fe6a3f57f4fe7552ff2bada5ae8abf3e6dd41667509f0d30dca09663d417cb167bee0da12cc60b40e2414da52580279192ca29359a42384772d147cf47c3da537695f613771caca7d7a86e10840c92a69e1a14ce0d3e48f19460093a5cd7b7803ffd22462ba0d6c012ef9c301b012858cd912221891b8407754e19480fda9157235e5969e10b4632f70270d2dd8c70a15d8fb3fc627fece4756b204b86891fe15820da75bcb3d9140ba1e038cf635cce11196549b10e9db1b78e6ff601f78555c6d1c99fe95273554a5d4685ad918d39150f6f04f0c55df6fe77453ae02ae60a137def58b986273a6c29ecddd4cec814ba7f575111fd05ceb1aa4e159b175cbb85f004f899c6a88688c4bb08b471b3641c59540dbc7e650ec24e9b5bd6ea6ce5062524e7aab83ef6f4ca5594ad59b4b5368aa6e59c397db081178b8c505747cd96c835921c47c10ebab0cf503a13a643d065a114b8a720d05ef1b3c972063015e88afc8201bbb470d23f76e27c518f8b9e19ad8f47cbbad927ce1318d81bc5a577fd96c3d8f7bbccfc904e2045830ca0f3a525f2fee912151d5c63a114e92b60e3cdfc38341d58b1b3e5d633aef118fddf5cae09ff94fe538f88bda0378c28ac8099f9d33b333e590e3952b3401ed04dbfa9f77baab7cb22088f00bd05bb5a0f4277570e93673f2497b775db5469f2aa2b068d193d03633a0b0fbc03bfc3b0b599e5797979888f5296bc35411c4163dcba756c3a8f83600f8284dd1d148c3654ff122068b48fbe69c8ac3f27ca4c1525821878fc6dfe4de159755b871b1dea75f554c685bfbf87ac985b0d257acb6423cdaf1df81dbf62232d8520f5cac15080dcd1de6d2a6fa72cbf2d9ddb4091817df956417ad0cb209b0e257970754a904e26bf3f5f6d31d8ed6c9295c8bd12f0f1c8240888b0e840ff6e8ea316bcd245b2d30a8c07478a8da3639c1a5b09adf660390c9dfd979299cebb5e306bb20383b0f1818051c87431ecba415ffdb4f3ca7ed92a9cb0d200279819ecf3f26d2ff3779cc26aa9c362bfbec58fbc3e38f6aed6296c03327aa733b6f4a6118b129c1492f5538b41372a06bc9d7e4d31f20f0e0d322ea4ae07d660f63b76523d8ff0ef3592235216345bb6b1495bd99df7903090920e291b8b05914410233638a2e699a865e6851ddfe3e80625c5f200dd417b23f14407c8b7950b945c28d76d825e4b82fad988ebc35fe792930b3dec8fe2eeddd03253985e9ec685eed1aa06e16bf63a1ba74a44301b1e25e8946afea886ff14efa38b7a44e364ec72adf98837e7ae51c441c91ca0869411d472aa1b887195598378818643e2951a03dae01085e3fe59d0759b39a527dd11a2d73626602a9232120a8ddddc840a70f419d337e3e64566e5c1e89a757682f5f7d2d80c3780a6603161f7663bf19cba8540b9703f35769de5b2a9410e0e9feb01d3f4fd4603143a04b9e1788323d20f844e5b3ff727e977bb1f2f2177c1ce9a07e2836a8bbe824d42a49ed29265665675508019917ebb0722daf43edf0d20197ace46f783a58a2b04f145db891b0df2685e8b2cad833855f2803e70c2be8732a62f9ff39576f189d842257e2b72917afe8422bc4536206543e8dd975044d41b2825708cd3ae118cc9aa557e9f135a224ee03348ee5a76cf7862feed55f79978c2f74b86697811f45fa8172b88dc291d620388384295804ba653ba1c34d5e9b41f62338febfa5d2deaf6cd9564cff1f14119c207d19ab3942d1750f236dd7942a7bc8d9c90b29e33e4a4c1a13e83b062834007ce5d2fe1703a97f4ff39c1f273de1cca7ddc136eeb7259a267223891edf713197f7217e97a9a773b70197fb200a7ed99ebbdee127888015496fd19cc99fc953ab1c65cec859933e05f0bc50330adcda6835afcdd2b397963ce5eedd8eba44bf394ced3b91f8e6513089fd45d332777fff018a6802f52eada154da9a0d8697165a6e7166ebaffb454487e8f211cf5597833dcb31f74caa8e1ad905c63c7dd8569d16d8a706d09a4b3e7572f87b96481f77991b167a4f7e8dacd0efa13523d3f6610f37d005a3ad7b68f8a131d0b0774b78450994f4b1021ca5b478fb5f0fa824f2870a584ead8c2ac917965c7723e7eb9f8d5320a62b50d842f9ac20abcba4ace2cdd51c4e0152ab6a0bb3d1fcc532dcf9543371bf8cb5737b84bcb2e203f2e1d68c4edcd15868e7c044e43854ab9889a97ba7128a4f3d8c443e6571cf5e6f60b6a7a3e3295e40e3d37628fd859319aae9b75ba4c88863ce3d427034d0fa8d67d2f7f1db02dbb98bb9280c39485eaccbb843f4ec3212c3ce0a9cf22f517c85aab6eb7decb8075542b9719573d146cfea0b3bf3ca13079327d5dc94c76815ab042fb4590d7d16e1d18775f5251450405cdf916c67b0ac2fd956575cc5084063fc21cab29343d925f38a39708a89658528ffbe39d5709611901bd83a3993e7e3057f3defa1aa11dbac9a059fb6efe8e825f0770abcfa80dfa8767a2769119b65ea09b537a58d5ebad979daf98e0af314a229dbbd3553c533cd6530459d5f77a513c653b8256ead485906d51cd132fd7570eef9ab3c2f070206c96a5aef1eb20c3a9011815a30270ccadd8c41e3944eddae18168101d1026e91bd5fa62fbcb9d7cf49c16e6f5966ac97e4b38b4bee736eed02fdba88f41dae31601dcbba6f0b4ddcaa0e0b52027d6f6427ab0edfacccaf5d44c3eadae0f5153d23fc977434b764d58e27ec8609512d2caab30205bdc2b9f150db4c1efe306041705c253d58cac56227cd63e82765cddb4ce0431254e9e5417bf948e3bada221b7c28a2960abc44d3682ca676cd08a058f953e76b49af8e9fd83084ed59740f1f47658b262a045961efd6c6ad597275c25b177da561fa1218025400bd6dd1e814bfa8321b218094bb297c1e0271bb177b8f31878f8441f92831ca9b48ef29f0809f3e235c8e85550734384ae3695846c6f3e033ef943769ec05b4ea163d85de7f79183568533fbb532537e8809cf114167f84a3c821dd35b73a5b08c44ab523a44b30ac6a5e19b624a4fb79d0c091e19e98d84434974ce22e66f3e9f226240e58cc230bd862fc7105f4a27569d0314a5cda09dd6910537cd897e85f2554ca9e6ff0b0876bc848c0a89805fbc5d38144976b6c88498c1c061a876bf9548c346a154dc05861ac2cd8a845283f56832c38d56cdb39353be92468f7c4c95f20afc2de91d7e07bc6b41673fef366f9bda210ddfc24843bce112a780686d9d048a14d710b63f9da812ce4c37db44eb328da50a56aaecadb43e0f805699c65574be0ef176d8c2b7b04e14806b56953363071434257ecc1e46f690dfbf642f5818d4f2e0958dc2f746fb25982ad16e153a363c30e59130dca79d51e4a6a5896b59b7a660cbcc4c73d8404e8caacb553caa0801a919b5fc056d984351eb017ebd01985c2af7e47d99177a4180438ee338eef52339c6014423b04b14b81cbb860b67ff9d923240509b38d2d3cf3cde6f854fa9f4a6e9397985f1b756c2012db6672562b3d4631af0c05eac5d4f8fab3d69d34eabcc3d370be71e05cf6bab01c484fdc1a1241c034249e6f546288368c3a28e46f519ca1b5dad0097a546b6db3f2492af2990504ff69f7bbe3481c0138653bbe66ff6375ed2e7625f8ff057f5df7b6ffb1fce75a7b4c5ae91eb12bd5e5d3967b97c7e3557b2c0128cad4593b4e97680791b22a5d0065356b245d4abee0b7b33715b958218ab415951f545b77ce59150a0c13e46ab1ac21173a8e5215f99b13cbecdf1f86553ef350cf8c1b08a6b4c8f69db8d40d914f9484c349b07aeeb428f138bdab7b115eefe0deebf27bbb5c7c9d270c2349f128180037510fff6b50fc875172f53966c6b0fc1842c23473ffbb829ff566caf0e5119cb1b8a519955281bdd03ae661b9c90259224bc64a776e650791970530aec08850477577e8a3fdd3654a606a477b9ab79b8ffda33fa6a7012dfa95efe1d234148a6be8eddd3bc9337d1e2fcb622f38b50961941320fe5fe747b1880cd8ebab747c584b1bb8c711f8d1f55e5d80c8dbf67d341531acc48050aac1300ddddf285c14a6da72118795b842f18176a079e3a90adb7925175de30fbc772f2377e1c37fa67e9413f0f1f73a9f56def4bd5c5b06afb0cd0014ce71be332e1bc5df09651011fbb2808ecad4ca7d6da951968db8ae7c55f9b462ac013eae7855db1f6df4727f788002e35dd1abb1a00f23460fce98a605c3dff1dc1ad98160cb59e321d79a5c55dd2c4f2a23c23cb3d119f1e3f36a7938a0c0886b0a6e62411ead849d6e678fc79235dfedc77451c68ae8b35a869cc5708a6190dda66029bf03194bff4e466624a9a63153df1a9ec914591d1f83b92d1087da643491d5e0da97941a762a867c92f5fc1df1d5f6b6c6cade9bf298cbc26e67bfb884eb1055fd1508f65dc0fe5eab11e886f7f400b0c93e025a67808fe9f5c15506276a29b13498ef21f887e9f4a1e932a9d1e0aa61ab4fe773e84001c706977fe51c2f1c4934d2dae640fcebf9116de3da43f5079aac8e213eb3d49e1efe090fe08f612411c79e285dfe65a4a7fcf203b4e28954b1e2c45f7b4e66946f8cd40fdbe519a54d8ece4d4269a4dfd2dca29195477ff351fb3cb4279873c5a25a1f0780564fca2fc97cc531a2cc8549d1ce442b5bd2eb9baacc5b73d1a404ce74e338152e1b6e3feb98eae02efbe021566d7d26776cf3e7703d285382b25ea24f8e5346e157165b9e0c8ce490b6a86baebfaf50ed4ccdb80a703a012f43d99775a3d461fa695779f8e20c6670d7d4c62ded19fa8ce5483213edc84c8c2100a48a9cef048ad780d1e24da3c952d8d7791a08539c32fb258357e968db7954d7afcb83949500ee26c1dc6672d8fda1e4b0ffcd1af5ef42a35c99679b872588a5aa9a3f5d7d9b74edb5b263e50df04b110c13387cbfebcedd082ad427e86be3456a46e9364577095356e49343e5d91d8310d437fd8512c8445d17afa6dbc8dd5f8978227ffa978390630d957c2fd5b060517d453aff1437ad67bd5fd600961b16d8cd56041f66d1042ed8c867dd6c33506c0a3f9a2a49a1c8aecb37755136fdd8dfaaeb13fa1dcf1f9b967648f697a40f20f9b76e92ff35385cc54e88f046c1d18c8b5bb78d5830b675868abb69e2f6eaa4341de741e2431cc4e6f36b575520757bcaaeba43cffd0f5b08798e47a174d1f8de1e10a6eef325300b4594ae5672b4cc04c530effe968fb4a00df8e62aa308882c3bc7c300baacdf6db9c8117e933f7471fbf27b7ffce1e514599e2fe1319f3c4412d1948f7979330b69864ffc43d828cd833a9d94e9d044d992412e5e934fde788aae35aaabb7c016c6d6e8326d1e621ca8d0c499f8c286880b056ca2c9d9e32a9372fdb5d73800a09294d1bfeaa85b6e6e703a3e7a3c3cb6e2761612faf0fc9df6d326464dda4ae2375dc519ca12398ac393c8b34b0da567a2fbc88fde6f184415718257ab7099fbecd3de34708cb55ac71059fa8f0a0c925f33160c60aa26bfa53470225124b2e4a0e7292b479cc8c7b85b734fc7881713ae719838b54b8015e250d3fbb84b80f297bf95d5ed33021dd8627b84242143ecec9e3d16d8f24055daae0cc1e3c9b9e3dafe3d82dd5f6c8ade5283f6e1542f0e0d3a51651240b4af0e926b42f4ed72763b344bcdf3edc340134710ab14e904e9e1ce7034f11792c839b9d3975ad6533fc0c6f8f74730531f27bf71a155ab42575aab9e1610c4cdc3e12940cb440e05b3cd8f36b4804d8c58ab749ef05ed9052c83ab32b7b6b9cf720bb8856c2e257650d9c14a1177915d2ff50e74d373540bf8025aa0505f9deb09cd4af5fe0673e7229e69a3ca2924dc60f7583507857bbb1f0004347f643e7b0bebf96ab5ff0d855977738820bca551ae9ba3babab6b2e999eb5fe9b6a1976f2565510b47ec74333eb759aa0c1becb509278184f8e77532fd3139cb18b6a30377753d5bdbbab79e9dff62190470f27966e2c46b4ea67a5f8d1af24f6a48374f18db6151fa237d287ea460f874eb23395e168839251dff44822495200f00f38dce541cd03540923543ca0126f4a148a582dc9ee91b4c80a1817e61ecc9a54647953d3dee85453d5e4c542f9333788611b017049edf641965d7f4679dfa58b07e56c84ff67ec16b781c703301e761395f591e437e9b9803b831bccdc686b9ea898eb06e717780cd8694fdeb4dd43f6cbb1632c0c13758ba9ddfa7babf299342d1c98ee93927d757de8d154ed34f7b75251c0c4ffe4870dcaf755119ab63e5130bce469984685bbc4c202f19d82e9572c1c358cdaac74795683af863907d123ff630eef4d1ba3a361da8e36430294cdb98a854151ecfc50c023bc62c323a9b10942282e0ba131612a039cada2d4415103ba745e92cbc824064ab5e543b48060880eaa46a467ce943077870abadd65d3faab582a524934547dc8e4397b04645fca1382afd5df81b3a95989c5dc832a111a439f4e2f36e4758f26322cbff3bd62b027b796522481d34c8a26f3880d3967f045d4efc1246dc5689174dbdfad6a8fb11b1226be223966c8c51845edaa2f2574974b18469c5d612e23fe32389c0355678e2c3e5a7bea1caee95833e0546c538399852eebff7823e5645617d75bfc5ed59810badf5da5f343fdfc87967a481d3dc48ebd1e3ee0b2c73cb494b6e4a619119f90c470a9eae08966baee76f5c94b6c3ddcb4880d1e9c293ba978063a66c91e2c8d140c914f4b6fd1995559ae9eb97959876d432d499601baca506f963e4e738ff9a8cac6a4912529e722eb9455328551c779417765be061a5332aaaba804671c83f3db2c49ab534de00117925c28b0d3d71c0f5dab5d16dc271e427b3372fa4bd71b2b7aebd4db90f36742be460464696e3ca447b9f0cadafab7bde4f878b0bed9ae1c617ea6c3695a5769f9fcde8d590cfd94d386dc249b31affc3583cdff3d08d28a159e840a32fe42a145435216fc640b52505db2d40757c83b95a16e227875448f117b151932dce5bbc35ba72b2f11efd35f1f043332d768dd94b7b5d51549c29394b540a87fb37c0f0d9ea84a56416062e77a34cc6c4b9b5f03a4b56b692b6f6c3d51c79bb14c24c49f9dffeb7fcead15fbaf2eeabba1200440ff9fef5a67492e40605501051f7ff7a83912eaec4d3a2d49a17c46223eb3c49a36264535a1469fee5220033","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
