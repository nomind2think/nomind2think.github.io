<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0554aa1fed5ac93d445ef9a106c778a221f1bed350ec8b86d8662d4c1868d759943f3dc0a59b9a58c4f43260b8df1acd9949390be0c6c6212ac34e7f09f45def2daa8c3cce688b13cbd2264e96ca55355f3b56be4777ee9c82fd86f35c6b461ae91ebc6012c1a7ab0c3caf8090789ccecacd794a7d3e05f83aedee61bb49588beec139f0169f1245124b1a3d2a50d5e5eb3bf131c66c5bfc1f4f46b837e7d0a60532775f4593009610979602d3509d7f3efd62079f57c64a08cc380374876c924d1bb977b133e5c5c3807ce80fc139f7eebcd55f87c858c00f309ed5f5a2537ab5367a422c47b567a7f98f757fd38823652fbbf22b2046a8fef5d1e7e30df45876366c5353ab070b8943939bcb77b50102e42f75e042d968c4ecf6b4bb066460b920a30125636c3cf52009948295d821b9b73d44c72eeb1d2fe7071c26977076635e05417fb18e6733512f3e6308e9d325982722fdd09e46a47499b9a969a625e88fe7a16f3ae16c7b139702b2f298c8919648462acf0fb2dde849090b1ef5ab97b04fd6ddf032cdf3c85f42ecfcaacca1818c9c71373a645d0663fe38b0dc78daf9ebfedb3dbbb8efe36b6965ee952b5bb887559e5be8a5703feeaa588dd9e3cb809088f620b0d44c8f7980225f81dfdb8cb2072e062bcbd5788a3c3a5cdc45c6176387010858cf7fc03cee4e57c96e3a2f49948024fcbc31c950097185ae31eef60a620828104d430130fc43a202c5e7ca55b583eab2bd0c9a049308150d7e1ec30fe1de90de324bf381defb53c3eb03feb022ea9401ac1a540ea4d9b0b11c840b5605f6c090d62e282faa7acd6c658ea761ead007dadd2986e8b216797af4736b3a5e54d81d217897b4018dbffe5eeb90145db84d70285034df3f180221f6ad8800d8595bec60dff8ca469cf963a6054735eaa30ad685614cb2e70eab26e348ba4c44d014a3bb4351b4d99550d5806f975652e3427631c5d7ac3babd1a59a9e57b7050179cfdda9cd9dac1c57c4a48f8c03b9e47bf969d9416b483b0cac49dae14b0204cd6fe1774dca352224cf497994224e216a92dafcf85542436da387b21ba53c02f95cef39519c7ffd748204f40432b41cbff034d00ce36fdb5581688a4659ed818ade6e02f5d92e124bd5005f2dbcc4579e83306acefc00d620c0afdbd364d55710c0a8d61f049050466dfe78d6ac9934e6c17b4aabf317236fd4353a2262e784bf1c800e6abf356f072292d6beb1c592bcb9da6c0256ad3d1eb6741b53e02ee41f37363f2365eb8328487284ede3cbad0155fbb35f139179cf7989c81dc55e4de940fcdeb49f96f23205a911fce0cd60a1bc7db28e60d5536d85af203a1980147c9258c10298efc10a91168da783b1b12d79630972d06a850954525e6b692f7291ecfd07c83392cda4299574fa26b979a789f0ed94c1b07615a2a9ca9005dc3d6cacc2b0b8d28810a1b76db5882bbaad28e78de4067b8fbb8adca6c2da8f715a007027bb30b4219e45a2234a4d971e58c6d535857405bcb7edb5b19122070dd7e073c3f2768085f2439df34083babfb9a8a34502aef44f114e1fbadf248cc7a67671cd893a02224ce104c77b254b6a914d467e87926823b48eff8f93afab8517a38dc2efcb15763e7c9835bccd1c2f1a996539b0fb04c04cb5741ab6d8ff0def1bd976ba5d9d3140bd39173d1a77eea2177c488fb4cabb2b42078b033d91368d1a30ff89880f34b0a3cd938de9a1690a02b8fabad6a099b70598cea1e50d988b99c0af6466c41ed500060efeff70759bb2b6158c468bfa84eff91e7a9867e8e3adb7855977203b1b35ff9f713def090fc1efd96f35dd37eb1722be7752c6f1f98d5e85e7510a55b2d32a6af2a3bfeeb9ce960a9acf70c8bb018a0e5664ba4b995f793bef8b80259067274593a981b00fa8382bd8b4973dd3319ef394902b2c56234cfaa6632064da9d779bf644038d22125ce70cafe13972e5f3a015c7a913e6ef41fbbee725f7bd09c5831002d71c83f2e37dc6ff3c72c22188325d845c00f6b848a11d480ea9a367d4318b2631e065ccf70d3509beede56546b8c1bd70a697d655d7fd0d6fc4460d3b8bdb2a61bf510f84c10c3ca55565c4a6beb224a32cb278ac451b7225cbb2d17e453d8bbfa9135ad70b14dc837275d4f6750cd3c30c11267c17863f086a0d810349236fea7651fe60ba5604154e42a921fd231aec554917b207fdc5efce1d92e72fb3a18559cebc25811731ca071f36c614740cd70ba051ca1c310bd0d22e940f6014dc6cd318b88cdc04e66caa317001f7b954b5fb289e68a1ddc9683884c120c0c335f4e740036e33a2571ca485a9032993e7a91ec586720a2967aa3d3fde5a641b4d1b0b77b75a54ba0b691f0dea19f6eaf55dcd7a864bfcdbf6f669f80955eea1f57dd0b800815e8f956af8238e0476f5ab1fff65e43afcc71b55a84c9d4a68d7485d4765c950f9c38d055de3afb95c9c999c7f847d3f11f345481e6ed4f1af481cf8931dc7402b4201007fb1495436ec51188e75ab78546b5262ed34b3d86c022c80ad916ce94c1983ea4d00694649c62f7c89867d4c1a66bad6170da57a88fd69a85bcc92306f2eb840b3bd53d8f1d91d2ebc3dc056a89ef153cd67f555fd52f7e63c6fd7fd0bb02b6913841d851d390642cc04a8f2e5be8e1e828e567b63fed6b233c6c71d27a19b62025f59b455e83051997c0f8ea09daabefd74dfbb8244065ded60f0b5158b131d09a41ae0ecb48eadafd798138fcfb2fe92ba83b91d434295c11a3d8356dc29ca4e0fcd58cf6240bd3146660a35a23637b95746baaefb1e3d87928a55f3de4f92ecdbfb066d8e4644fa9cfd9018afa44f9123371023b694e248fd3030a9d77878fbd99e329e8c37c38e2fc92d8b24d1c9493beed5c2a8c0d9fe4df3ae6fd4ce2e49980839c9fb21fa629738373ec42e5f6ea74d866f0374cc1be17b47abfb24f8101397de8528345de86043a4a75c81cfe540c8ca0695dffbc94ae35314de077073b0ccabbefe345ea9cb961ffe33706e37871d24f88a78e13ee6f9210c093754ca817cd2ca7d175a320160b3d54ea557d69ea4312fb35636a8003409dccb2addbaeb6d4504b0e8327c3e5fc812db7994382efcc66d3b5d03bdfbf47e4580d092355ca14be9d917a3a48fd1e6949ab88f8ea95c193433b24240ade2dbf10410803b1b8ea00572424f9455004412f8b8d5f851c027cf77c60a4e2536f8c466e262eb500136dc679dcf7bead4c84f897e5aa663a68aacbfcd0e84bea529467804adfbcbfbc362bfdf93e3e3057f6b8447a1836c71d87929f1e7e311d8976a35c22b7d8ef8f493aeb4d3dfe5433a7e9338ca505ef0c0c2f883fb0aa0b32c8f249dc8648446f5011dff4dda53a157b5e1e41db99c476c2424d72307984a9900677e24cbc730ff1dd783786b9ecd794844b1d4434b62dae999f36b2e33177e101eb6164789704afd0283011bc04cddbc87e4db4acbed4e48fe83f107ce0fc85319bd4a738b89d28c109634d9f56747cf9aee545685e4fdf53eed7897f76782c11dc23411a3a7ccbb1493f5a6a43b5491997495d09cb920b2419fc6435e041b75a796282b288aa7f72ba381394e20384f94f0fa094604aab757937d88441ef61d69cc5ce7fa9441b6c7437a6327bcdec833bdc7760e1a086cde921163789532306d7d827557cd4ecdcd4ee043413a4d3ab0c45e63a7034239d6f06ed1734a1264ef41ed4bbb14f69601a9bb7624e94393113d83a850765707804fde4f3f13239252d91c9fb8601f8a290251603e9b55fc8b10efed8fd28063988b97be3cc645017ce95e796b0eb2cbf3cd6bf11c97d56b8cc4ccebb4289c13fcbd78456bfb2f3fb9abeb0b2add38b0237f329f01ed840c1bf0e8f8d2b87b8d8aecbf1350bc714b4f718063c23fbb979b82cf7e80785809945ddcdc1dcdc7dd80a925bf727fa488749489fb633bcb5189a58f52fc2b622c6843ca8f5b10f1566f4eeb6eff70b19207ae43215f974818442b83306a4f23b77ffee522be54d688f416a0156653cd7ecf7ceecc693f40caceabd0c878ccf643bbe66c9455f3590ece1003b0180cdcee76516c19b623d1b08d922efe432155e31a8fe78e15124a6b353c2e4b10cc70f2bac6752088479c5af02f295b7d01acb23c881e3713246c3adff55724f998434cfc2f70140feb4bb4e093d36e4ca2a35f42502385522d35f9aa8d88dfd64fc798a7a58de709945df9d9660776ecb7307dc78a6f885228891ca4adb278a877550239a98d856443acc40107d60199405e642fc71c9a9a5204143b807fcc9e649e439a6d2a79f0af510844c45c07c9ac0c707fd9ed5366627048bdef9bfd985b2ffb7300f37594fa299177278247e49a856218b33327a160a7694bd5958e48757968cb47bdf0205aa7c9748cdae2922749fe8e4e878d67e0c9c3aeb6ce372e260d8a4da8c81cfbfea4cfcfd029a43865ec9317de9375406b0f0309f61a99b84a6bbfad31c141d8b0417f94cdc0ba8bb0323f03057352678b2778d0f5d4dc5ae10ca58f830c488cb4f2c822967e1c35aefb3a0945a5035e0b3b5417af64102e7f2892399208e01ad987673e85166d9e952933cea44adb3c80e55a3ffa30b7a8366fdc58eab142bce5a3f63ae5cb86e0bd68d177b861f9f3760993e441919c90007eaaec90f9d6f4e7ba3d778b6797095ef26dd3500e1cd359f7b4e1e50287032648c036e12059cb64714b68facf9096f473ca338cc593ff359ab510885ea89d3d29ea2aeeaefebe9e180c41f2653c0a9b1cf3c29e4d96f77cf64ef13783c9485840545a9fcaee438582602e5f9520a8309702862696f112e0d1c1182ea2c6a8575334568ebbfe40c21e4b2b45c1578265ff881075d7167283581240ef2f1b457117fc206060896dd0c303f7b47cf2bdd4980c96c641aad88e7072e740b34d895fef7ba143b3ae5cd469aff2363f5d53c3d40dfab1eb7337892dd97c0b8cba531b3c6c985186063fbaf47c39953d3dd84f2f58fe0be7e2b7e6339fe3686498ea0f1f8db0be7b2cbc08faf814f42c1653f7183d5d00e64d0c688566c7ff2cb13785ce8d8920fd974cf30f094a8e6029d692073bbe38b54fe2c59b494246f06eec848cc52ead8bd47cc335957007a1c28c1a73bee1deb23b9d3c935a91300fd6ed07501232007274e81107222a32a7e753919adefa789366c2b361d7f941d1860c576e90d1140ff7369b00e8da60c71e78b7f058c9cb5ed37f54bd07045b3d5bcd812d2c4db50a5490cc6a41b554ec5dfd3bedbcf8a7682df518e7539341985b95a6d3aa5339e4399425e3f037c034aa4d104e5194aca3277457567b5683d1d2f7e6c7c7629bc58f19d47b1d4053ee1379da0fa2d4fc836c2ecf3bb7d6febf734b096ec9107afa4356d88856ae2b72f3b979c7961660edcd23b277abe52f614706ef8211dfba1716c4868c5cb61684ddc2e0faf88f8f5eaa3f66a207262fac09f9ea984e4c2835259f3723a1f1353666960aa49482aa5d4c87ea0825e78277fb5ba5ada850b4cd6a09ab566295d2aacb9a6e8a7868c92c4ca91de6b915aeffa573e003dc9d05f9a6e0ac72f91b2bacedb003a640a6026516dee5b3663515a7f4e10fbecad2cc761571c89679b386ab0e015e6241185d6de245453fdc53caa33e4490a6a060a53544c30ba8575b457238e9d694db07978a0e71f7091f6561fb0a94e12e834f4c69cdee99df3ab61bfdf974154c82b7e46779e5e8d0b27728eecfe1331b9788a80f2183481f1f1c59e4fb44269da47a06b57b435d8afe3dd805d9a0cde9ee612e7a036ffa3b44ab02930483a385cc8caed026599f3c95f222bbb679d7f3655db30657e7e4d9049d2d319f08c9b242c137425f87f72c3ec04196808ec5b5d39ef1b528394ad8d5aa17fc1286d91b98ad704dda50d1c09b1f69e6ffff38f0f4c4d2f776d25b79d5ecb8feee92a487e48eda9fc09747255b60075f6b7e5e3dda8112e25219914d89261e2d5dfcd34ac94273afed15c7c62f65753e9723dd3c251c3ad91d203d152830d818670d8505631f17cb30c71cdfd8350bdb6359f5d187722a98bd24d8d09d6cb361a91279ef78d5402bb7a90f20dac0dfc44547838407048635dc72502adf84498846790e6ff2921f44c18221afae306c6219cff04ae5ae0c9d343d5515478cdf39f01db281557e594a03c759789b3fd28631fa9c52075218be083458e83a988d6795ff29e2031db1fca7c1daa7aaf7fa15ee80aaebeb5a514dbcc62d27a198327efddf33fee5c86197bf631a5216a2978e0385a0a4c506cd16cff4fd278d3fb614179c457de5fa8ee2a8317c01dd060c4d1ef4d98159c3a949670fc3e3dae6d1c35c0d3c8a42a7b770250e262db7d03eb4575d30b735f0839eef4f0fba5870cca5f92b9af9fab1a88e182aff66b8ec1e46f1160237d625488845f234b98ac4b1e05258ff0d4a268c1b67c3722fea62eb53093f1adc897727666bbda2336f16071f9454b55744e6dbeac6ea79129afdeb0d12f92ea8882d059f241ac5b0366f183778894b07905f160423c9cb2a4ff8068e5f9e0e86da213fb109e829f810ed3670a5c8c43d3473aaad72be3d8ce0f8fb99dfc7deb1798c9e64c83400c4e523075742b4835cb730180ffeb77eb6e3c27a5cb99d497bfacd2183aae3d427ece07283d16e1e287cc72b7a1f5706d8219f37c8dbec84e53e3cf6d3270db03704dd506100b6c6c85b299444212d040f00d32626a57a5a38006a6c04458309d3d2bd3dcf001489a486b8c2521e5ff940c4d310d3e5884c8654255f0fe522f1e97c9f3d72d164066f19c863123bfd275c71e337b0b1990301791b710b11af45bb1b8be721e9cf8aa8b2179e0131e3bb81459169f34f5c1c1e5ae6492d2fbb8f083a1e01a807928c4eb24a5368dc3055a4d5a27e1dee2dfd822cd2d21d8c215dd7de551dee3dfd2e479984475e404cc9cfed4d66dfd7bcb98350927adfa980506d39f90c295bc8e1fc90e316bbeaab73075cd133bb45298e75063f3734e01e5123120604b064e4fd2cfa1c3c76e60f0a97d41f2333616448d1668842577cb7f1b502aac7828135d1d3126cb8948f1d4cf30c397d60e4404442cf6184216cd7fb77b38655cd409b5e4f0dcbb557f2775049d8015a2347c9d41696be305e7bba266753e5614cfc4e34deabf877dab8af8e4c002ad3b1513971db3d7000c5ca3f71559fe89d66f9ed20af04f3d0ae6567d4215602ef722390202aef54293cf9750e0aee620d878a203d177e03c58c425d243a835962e60b22e3ae30d34adab19a45ba430cd13cde9bfb2b71801e4c08b465ee2d8074d3ab426b28edde66ecac7251ff118826231f11c3eb803708db575b6bee39447cbb92a496479f352923b6deaad44f4d65e6c592599d67da454d57a5ba056c3229586b32dccaa7bf3ada469dd59c1c1e626d86b233ea9b45881b27244f4c0886d0bde6335841509f28ec55d27555c51df6f5cd9180e9d59b11eb5f2daac0aa6c9d604e06ae602896c175a109a0cdaabfca3d33733d109864a0799138bb3332384ce2904bc57dd07c711e932f219d4236035961370a935fb3bb87f1b5f87e3ff2df25a1fae00bbd75b2df367f6935d5897e08c7def26e69e779b8ede0b04816088b2c6b42c1a21ad6a8397442219350d83dc70b675b390c18a024682e5d3015ca98e3e82c33afaf88fb759070d67ea2bff09166f45357e931f237ced5c017e91266102291b8bb78758d409303629d12b8b6de5cf88a61a0d869cfadd056c54f776d0a17740a71e6a07ef178a7d8e22906395d1a7d5047c070848997486f7ca5131f1544c8a37835736f9453e7187e498a9e645f58dd8e09d8e7f8ac10e57d82cb105eda94dd03bea0fa9d046ca783138dea234426c362cd3b9f382fde4318179a1af81e10965820e8fa8d45809e134b22b53d72e92db90aee6eb978e1e46e5b0c91b900a5b5a1461a7f1bd04170950a85c615f97336986d1d8e31a89a67e42ea062edf9226f6b33ba4086a83fc1de22bf7801375e12199834e8d3b501f9693e5623fc54c2e680a5d1d000b41ae1d15b5825e9e30714f8eddb3e0f70b72499fcd008d91b7491aff09dc5730bb6fb288df3ae4a0cc8e4f13df976c35a1c3ecad93f576e464087c9c454fa046618576bb32789a57e8ea0bb4aed524f254ffec75b45b0c6db4e6f6e4d84d69c24eb83ac892de0cea577ea4b97bca1b5d4def62e70197e690a46bed6d3f8db32ab7f1f366da60abd38b178b74ccb977278003ac2de497a56d2b53cc9ed012eaf5dfe8f811e405388d44e60e3a8d01c4da4e8283eb3f0a004aedf6fa6d5d8968dc7812d4d4510de09ecd813efcf7c7a500da3e9024f818c6816e03a88ca3be22dd2c43ecf8ac886748112bf1a163545bdb8f30f590eada5656240992bc56853a3ffd9f2eae9445314212b54961075c9cbe0ee3687e509d961e9d13aa8506a9d904db26634cad55809a87cb45a776c2b24ea89b86c6100c16ab5d8d3a2f5cb0bc4cfb601ca2b6c27766be06b41997a472e62e68ac10b63da38fba5ff8e36871f8aace9de6abaaebb8230c9523932b1d0d663d171ee87998be17eabfa7beaa57238790aba8da64a631457a0f13ff38f859f44080f90b04511ac95ae2d1a98803e36da8218419d52e3c31071fcb7776955dae24c59ab53be1344f3e1e038d8267338596b1dc54a58e7b321c4768bb24a839776bfb741d87eb25210c1f318c776a7e0686ec10ca80b467bb914b66ca0ba8893a5ad90683ff54b9daf126111716d43555ff70a431e23c634d69c88992687679c497a7e3efd953caaf194944a57b88779c58964010ec30a94d394c427a173421735125a6b52cd252e0c948e88ddae8140616daad44e0e7f44a47a43f219c20ea0d31bccc1ad6ca4ae23a4c49c0270727f21bb4af7e2b4ae9a5d2d3b1c81b62753eddfb7947cd25bc4d6f71b238ec2d091cd75b190c6f46231c57fb1d6a0089ad1a6c54f97a9962683ef2cd9a02585a3a5eb2a3b6da3a949fc8c5110f0b191bba936fecf428f7ad4f7a53091bb7624132ea97ca6e1ba665a25e6526d09d88ecedb8ef1dc3c40ef8ee8b78d58bdfffcc85e907c38acd0779804e29681824f92a7aef425106c01dd3f5229ff59626b1f960168dec4a786b4fd54c753a44973b2d92007242690a44704ea00d416a5cfdf94f17991a159bdf345a13bb176587511d94f7b8ff2003498b07c55c3ada349389e1d66f6e6b7f85291e0c851380d6663f47f918731878b622945aeb24003bec57918cd965ad795b7056f2cda01054496716386d18af5def1b4c3a11ce4a18717ab9c44a8a9256cd8aafd3ae9c2b5dfea6a20b44808820617e26526440801066b1ce770c9e7140e131c18526372113f9d676547594051abb3b785d779bcef494911cc217dedeed831d777ea99072444f409373dc346d73bcbe9456f05104bf40d810e281bf7b2a1c19ff298dd5a2483bd6d6aa6d1bc846bbe1deae5e64eb1eea876a4840434008f65ca7d4b09970984cb0870b3bd1848d380fd5bb59d24906b06569d67083baf963d9b85c1ebc95486a0740ebd0991063a06d04e665aec9179590eb261328cbfc118934d53fd1eb00b8223ea5df4a4c9de87e491b5b3bed9e447710fb20fb3bfcb99bb4e1f7d71b0fe6ed93236d6e821e65fd37e42f3aa1fe839ef5489630518ef5f8d44c9abf2b6f101ce61e7756d7b8c4f06740e87026f06a72ca622a4f9d1a230931c4101d09e95577d2003ff4d1758dc76825872bc12f44aaec3830259ef71816f64b699a6be8be1d6d63836a469d0a2ab2e875656fdbbe2737a082d583deccf41742a9950174cebac09326cafc392de4480c1d4cb4cfd07785aaa8d64bf530c07f905c100eb610a39722a9862e817e4f81cac9e75efbdaaa8c5b4eee17f2c1be79d71a1575a2d26adc485ee3e42acc1fa4ae222e68e30e7c8b0d947e302e6a84606db39deccc27c2ba31aa55246b1c8fe73ed270c70c365f5fe80cb73a08a3a09c29b92fdd9c85173668b0db6da7a47c83087dee151647f58b37f6d9535d4200d11b6ff36028e7ba1d7094c314265013111d60ebb354cc36f6ac9abc584e36259b26dca5e68309c2fc92e75856984b7aff9c900d18f70c2f668610cc2220705e75bb17bab9b10c8979c74fb73c54fc3258bce111907e92c883738c279952a348dee8753fc7231faf4da2f9e9fdbf273ec9638dafb91b62a09394b50e1460a0c55cf8b9d3dfb5ede9103dcdda1c4268f26cea597e18244f48526ab1b74268bdfa039c8b9c76e0f517d66de88f978d47fcdef3bcc10fa402545be90918f69bb0931b558b45aa4706c1dd431f1a1de2ad0cd916ec1959fc4157481756b545eba6006a6e8c2e9ab7b07ab0b03baa3fc8329558b42ce961b361db27f84c88ec47c17ca12355de928c6520f756f56cc1674fceb57113c06e12a6f763b0e9fa0939d82a4238daa4ea5a775ae0e9c4507e83ec65e0a51583e9945118549d73b65969734c6374a511f7d44bedbc19a4e94284a044ea8dd743bc7e31049783960ff4ebddd9a598b603599d7e3ce9e738244f873b83b2568049c4a26e285d166af0ec1f221db1dd9a662504d44934ba810f879e06f5eb0f7d62f9467099cb9a3c5bc4977718a47a537df59f61bffe4a773d8431574f232fd059a392521ae858c2737325ad0e58fd2fc13b4997f7a87843ebaa11ca3b2c6188b9d5a5d6c39cff751c3e6f95568d938aab748082741232c9108b2731493dcd017a695b7fb8d25ddf95d87cba5ae5299737ba84dfd86d5d8646a6f9d1dea26c7681cf8c247a46877095f3767594d4ae81b90cc93bc2670529532a3b8105b59115cf4a856bef59f72153f8279370e4fd963f4f3e680eeee70890289f518e817ea6ff66cbed77ee77fef5c77893be7e41c565f60bee100c99ade9e16ba7976346072ca330d66da49dc4c3f9060eeb2794ce822c8a4a915789ca43fbe1ba6ba627bc24c4f1641cd093f58bedb37fecdd73c475e9953fceb0a6488c6223ea21eaf89feada26c97fadade77b96dc0e0a006ef6ff245a69c99f9cb6871f76dabe4a07e74e175bfa4bb9210ccc68e281ba6887f71454c26f165a978140aca92ae55dace89d7fa599c547a52ab254f7b851fa545f9e0a90f2644129207bde56dfdcd9f432bdb281bc3e540e4078735170126d4ed2f1a56808481760d8563ca45c8803351e4ced355d507e6ab47389e1ff0057cf3ef2b5bdfb0c4adab1840528092c78370b82156fda1a5a7615dc9c18e4b27433dae1cff5039e886b13fd34c5eb054d48fab1bc3f44122fb8d5b30e80edc865c8bce0d9ce0adefadbcd39fec2b1436ff77386fa9da1f6b4eacff1375ba67e95a53ab56dd7d2344bf1a424d761b39eb6f772ddcd57ad253bceb9c3b98415d27edb7820dc9edc0b760983d5efd66bec6df373af4187b76bb2bdc97a01099d64acceeaa658bc4537300e7a724dc435a3dbd16d9ff0998f50e9f8d218a7ac186c4ebc204f5f58b36e530b0250da9f24e4426746b198705cf2067d48e840361994c764624725bd57182cdb4e8788f7e99d8d44103ed83c923a0be385ef8b2a92505c55aecf835f6a4e7934a74fd350a01d45a61f37a84a50cb4a1cc037cbc1cadea9fa94e24cec1f18e5139ae71be97f4c79403ff723b27139abb2263f94027206ff3a7990042475b48867d9450a46e10682b1d4b05fdd6a03e5523bf6f74c3b515e83911478a4771b3b33791948d27f53229a9c400aca9ed0115d67985d35b1cb8c174dcf81cccc4541f056376ffc75a66d200c2c7c9aa1b271b25598066a3d5d7a479175b5cd556c7d061ccf0296cc109368734882f19df4ed1b6d41d7b3ac925f5eaab8e677de14adc55b113b8c3671e9ce37bc330ae8b465cb8adfa1743f6fc545106da095bce0c66262c36ed3a1ceb6ab486e002bff3da6e90dc1825674b0886228deca397a20e131e2cf55f9431fb29ed9ab00d3fbbae76226cb25aeabe3acffa8b41ca2476c83c918a5eb518a27206154015e89be873621b0857a6b071a2b9b6f71090d905f4118eaf5f7b2e0d9f2f59d807fa8554a6c3bf19e21bbf42f7d73b9d11ff56572307e25aa9ac3f5b0ffa26edb4dbbd217a46d772b68c7184fe71e501aab5b9b8c830dbc913defc52f18fe50a801369d5d8dac4822a035f0cc67cd5274cb0cc21ad266c208b190bb206d879f4a3af1ac86fa7bc8702243a9fcbe9d38d773a5e0acad1d35467b593d7502e91cfdef36895fa6aef00860650412192c7256379bbdf99e391f97772da74fb19f11866b048730391deb998b94ce852444955e634b5c5c6f5b2c1155b14695f04362e491c8c0362890e3899615e087bc28cab46da428f0340cfac036267b5c0a095d3a6a753d2dd586f3fd535eb194c15f8105e743b6bb1687d64e597fb26da5ae476d18a6db9855c5399c3fa198394337fdf912f5528e3fecc7e5aa0fefceb244cde3352b589f009d3739ccbf417f2727662813a9d95b12f6b5d4bc7dbc761ea3488fae95320f681de905ac192cbffb44319671cc656b02f44888b0a2c9be2152d1ea61281813a41dcf1fb906b1c7b94340f5cc521b07535e4cbb99266864a4ad7c25d8fccd0a71ddf43c7a851c14bb1925e4dfbd35023064a0efba525736bf864f49f463ac048f3d160caa207964718665a55a9f269b88fc9a250a61c20e4149c656105b33c068dd5a7298d5a6f150d6d701b5cc5b6d8048b79a6540a45e928527777f8725c8e06f7f80d11de9cbbafdaccb547e3377710edbb8954da094504249dc3b6465b805180c089444d2514257e1ec0bf3175c7860b4e26dac17cc06bebe8c0890af3553141b84e253745168de7f6c2f4024615fa9a6393693b7a8713295ccf91dc6410767873abee8e0c86dcd18625fca3f92db1e779fe4f180e03be1fe64da8de1d314466d4f4bd259b89b73e634fb4f5197178f0baf5452a05d6bc3f9fd72cccc7955d9d0e94c18287a078cbe9c8267e8a8740929189e51259f4ed23fdd6f13dfc1745dc906ad5d43cd1061bb32182dd08e25b456af9a045fc1bd31d31c889f62023dc51b9ca796299eb8e308fc6bccb92ca537ee026671a613cfe23779dc52eed02a4d5919c42f939aaa72ce6fa1740aff4dd1e329572714393d07741071168c691cef0f57200c84b4a41cdf2753fd21721592763ddb78cc4c1499df90f94d5edbd8a7eb3e22680fdbe197318cbd02ebd18eeb4fcaa56db244eb90567280a9861e5c79a47c6849754181dc0d196257df560b1fa67df92560dd4544a529305d96e3dcf4526600f5ccaf2671e28efb805a24ff4e30aa4a2305403f7124c1fe919499009b9f4cfe3381a2a10f2fbd75b93ce1d3472f38a553019fb84dc0469a4bb8b82c28da9002a6c84ab8c4302a170c211360421ad401770dac5dd82ac233a13d4379b05fff1945ef5c64720a86b5aba8e95563f63e556f69adc33d77a018d4f21fc0c9557da0ed7dc01c67e4b7ea619eb7e11231aa4c67501e50fcf8c4cb8aba21f725e24a7f84501212817936a518cc2b5e043b8be635d2b795e9881f77a279bdb7993c7cc3fafeb61cb27c1e90b88f7e58303b37c3df4171b7f2920e03bd47e51ee8e9ea3e2c36b42a34a6a59b0b16191885a2590e97841ab3d2e5df96f9049f590bdffe81a98408ef9b79364a45723217fcc4358e6696e794958b94384315ca7cce3db4e44df7f4a8d9b65c207aebe012aef0cb3aeedb19d7faa43e4828ee9c6610ba05c51bdf1a9ab1a7dcd289f407de7e37d2070c5127707019281567544aa0db4d59827823450dc9c4dd1af908e0ca77ee627b1da42717816309a6194674789daed72a6b09498b76f2f2674dd568985d04058f03e3c88acdcfdff61dd90bb673d36863f341791f89172687db886015d5001b9e7a8f590329a38340dc9af07d9a8d2565e5ce4c5500366e00bbfdb48fea7251a69306922248872fc8d515cb6f31163ef387464a07b4804c104a511398b918b299c2dceb91c188dcb7e5aca5190150b43793a6f5a553920035d19256014f62bed2aefeeec086ab11c36483dade8a98507eab03bb76e1a590be649748bf084b73cc346dd5b3f6c1437de8121374ad064271fd634ee35ea097839751210e5346f78956beb50a557c811b86a84d816a36bc8b4b5976ae04f6a9f3fab45de753390156c282cc2f4290eb2520004b928eacf881720f11ca890cede87cfdc06ddc451f9c536ad9f3bfb24e9efe168c7160f8c6bd69a8785ac32cc3ebb540bb8b0df4a9b88d53182e7b5cf7bdf13600da83d2ce1aa670bd2e0c793287f64ba76c65b22ffa35ab3d0de1f4fdbcd0c88ab71fd3a2157a7c994b004cf99c5b3b1a7902ee2958b141e08f6476e4a728b237cd1efa55f8998d5535bfd35323c7c17745f196d0f122754c5e8d28b25a260ad34a15492c2a753f1aa08f62e1695a484674e3dc3538cac9b1bbc060bad0fd22d0dda0d5a94712df4ec5638d7ca1e8a91167524d07d8083feddf28c22aad7c34b77c097a0ef904b302a90cbd6e862b3987bfd7d8929aef690b7bc4b8734b4a7ed183117842fafb93cd88af0ec7ccb0414d00590d534aff224dff8ec2def99da4d4353e2bfb1f1cedec9668379a4898113381f3bfaebf6de5b9c9ae9d7b2373f24b18e2bb33e1fb0e3238121b391d1b633f40f4d39c6bf55366fa397150ec08669b278f76bb2507e431bb10f52beba70e4d2a52b47746a5757e7316bfdde4dc8b928ea7e74fe03c09abe7fde9f1679d846463f6167e9474edb900781ea5d279a2801022287fe71fbbc87d9223b410632200d981ad4fd80a1bee2c22b2df79ffec7936738a48e6e7c30cbb6ebbdd9c3c5c8dbf6cf1a3b213cec3eab49f04666ba2a2b37d3137c08f6d5019250eb6d5cf6e9c3c62c5d943931cd549b4cef034535ed925de11dbafdaf6e5d0d10d6860a60eec0887b160052d91f0d89279b58c42f190c1e8778b02979f29560a102c0ddc431e6a115a5d653a03d7af50f977a53a9a058176d78e955f7c166f0807dc6b16583f2bb28454fe20f7ed6d517d037cc8a40ab3080a5716b5948cf399bf23b44f55c3dfb0a607a60db7c00a08393cd81f4e81604dca978c5f52f1cfff4fbc295fead519c04f544dc3635815b756f5ae41c2118a748e11cdc97346b4db84c899cdf7670c31f5bb21855d506b2874fecbceadad6b76dbaf114ff4cb9da775eb70702bd5769c71af73c6f859ac42066784de01c8075b82907856c0bc77e2800c7a11b50315689ed0a3460021cd83d3c98d880e0a61d3652acb760ba0c3a9dc4e0289c49002cf93064043e708506a46816c4bdd92e9e2e366af7967eb71189afe912bae303fc06c802db2cdfe10604fd932bdd0560b016ef6bea754226295fd196388735db25818d55b8c18f5856a9ff3e95c421d72fa0f39266a2f8c8f83407eaa742ba53ca8970165569f0b5b1fc8586e46527c02713c1db1fd07e9e8b2c1bdf65b7097be4cff399688f025ff794960e03b2a49abdc9a6ffa242e399e8e1d6dcafedb415360d7cef115d495931673ae87c524bcf4bf8e67f6077d87cfda3d841c9aa539a4ed5e6adeec2c982b42ab60cadda418f82665952f1f0955c35532a69b995689bc41f5ed4e2f001ed88b12dd8345c7ea3ee577cfb79911755abf27a65a3a11c79c17cd69b32530db05f01d95a4e813ab4f97f49d40b2acf3e8dc49dd19183352d853678420a86733a977406cc7a39e3627db92271fc0aed489ef33a2070676fc49d027757c76b9add2c0761848ec33ba767d4f93551ed4c0892eca0050468bc7a09376a1d1554b44425f79f5fc0686cdeea2baeef6a1a82505ffd603a4dafc34f48a662862e73aeccabd6379bb4b9030353a58f6a8e8cb39b2ed86b641eb009bf646af2564af293cc750f85af198503e97f97777720792be2d99075721238942fe616aad30ea26bee99fb11890f1e0ec9d52c72970f2e51839c8a57809d5953e746ad072403effbd7af6cc199169d701b55ccca4a8c5502ef5d6c5857293eb657a0ea85f54d81c8593b91422278635fc86b691ced652a1e3ace5f116ba21420967a2d47ecfa48c4e201bb447d846f986cc02e769396666ae3e458bc80f1ffb41a1db094bc47f43c081dd3fc98ffbcfbda22fbd1f8bd52c9311c8f096f1970012a5831de7453fb5db99de4009a235300460e82ee428fc7d585001e970627008fb83e7512aeb9d7729361f7f97bd936430626454b8e1f4bc4851172cad4bc6832efc6950129dabc41415863fbd851b378808dc0f0007ec5680c9e6987593b607cfe4e38937dae88592afb0c8515dd00542cf9580e6c59571af0eecfa1d14a2d49d020cf6ff2ae6648e65eac5233e4e63e4fd2d19e506dd8457c3ac60a5b22691f57a3201a6dafd57036df482f74aaf7f38793d1b477449f1019d6dd7aa760b8107b03aa2f44f8d1d6f2e0d1eac9c63feb29837758a08211d8a0d09aa0a2d74a43e699db83295223c4e1d0c762ca817cc97f363911cc2929cf1c05312c2acf00bee09dd09e46e415f7ee8d0f6f56a3484428c7ee62221a52612e4377874027719f19aa50ceec5a31f4b1856042dcc549a729888c185f851f615e784e43896e5588871c6f5c18792727f1853c7b50d0a10bfe9875ef8aaf483628a406424ab3eb213ec9f415dc71a4da444970e17cde0d47bba7000f93c72f1ee242eef21ffcb5c39f3a7179216caf68e1e2ca7fc80fa417488e6de0b6dab9cb35e7ab6b351de35b64cf2949c626e271736f55e27c632139fbb42ddb2d7806770278d72a57fe2f7b9af95d161f3bd5089da22073fb0c170a05ccfccb8d2e3d941d6dddd1d6cc47bde02c893b218a67f076aa67192ead146729b610ed52b1f8c113e40cceda6b7d8223222bd33dd88365dfba176eecb08c927fa6c8e696001ef451d9f49c48153e4af390a9a5fc689294ba94155c9ca6dfa8d5d161c05e7d7a1be580f8a2bc05c5fde63e96f8552acabadbba867f58b0a12fefef5fb50d7c1bb3996231d38e9be9571fe828ad103035d0fe457d4777534e7d0eb9fb55a896f08db36662f32131081281bd013abc75dfac5bfba3541882e5e937bdb5af79ef648ba72cfb1d9307a2402d3f39e9b3bbc1b9483bd7a933de139f263b5978a2cbd050fb37f73b63dcb3d063b239bae7f9b5266702b5e1287a1642dbbe0fbb6836d8c79d3e8238c20e1c5cc4e4b9b0cbd5fff001ff8fc8ba1801137cca40a1eada46c51d839c9068ee8088840255b28def350542791e37840cb1947bacebd0940ba7c8df1e9ee3273c41357d791e5a442d4ddd1720513b32085400f9acc36526b18bea8b6d9998430b827adff554562934115b4aea8b79dbb966006fb47c90b7eab303ee712bce5a22cbe5320b7e7bf772bcd3c6467b6e4e79c4daad5ae9ca679638808b024f0d0ca12279fa3f9dafb35416c8fe5b072c6d214080d2ba4a1be2cbae72facb4efaaac94558980006e419a966818b2a769413c8c3fc973630d8666f385dceee42b6955641ca36d29d2da15f056f995534e5e2e7049e77e7b1d9f6dab8","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
