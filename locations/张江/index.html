<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ad225ce1cba5f67519919654370becbffa66b140a27933bfd35232d1160eb5dfd2bb93310c98059d2e622ea0d09ea7e017f8fbbc51daa593882a897024bc76f573ff769c0c5df1f855a8fec3dd17c64f0c7fa90252cc8f8ff09d4da4bec73d1d468c5d38080e8b401b099f8c89a69b76e26d35d54b5ac855d150cb1ea3fdd76f989685d612cfece1a192ca28de4b488d51d6bc5b14b07a65bd8d67d9bdad53818ac702e7ffdae5d2de2e598b90841dd7b73e52fb389cde613fa1e762736a6de400172745af66979a46ea2af44ae143f5dd9ead61974421457692dbcc8db63a7df510a158cae2d972c94bf956219154b5fa5363711a4fdae419c6c32004d1581954686695043e33af53cfd96b4010ef7f3c7d9a92fe149e6e244cc664b615b588727019c4579878b53b0bb66577962503b6481593e9cbce55bce4e8abe0950132774e38c8d4d8bd3788a5b4c467d582fbbc4239e3ffd0b8199a17c62e8f99bffb80797729f8bddccfa0dc05a186d976e85fcc2b8257029cda1234e50318f170b7f15bc7c133269385761887a657bcbce5839c83005877885341bb1b883cf676da67c498b63a6cbf9f24e72e50931921d87ecab6e38fca71bc1a93eaa9812284f626b7d299c26dec986e44397175e07b00323867061a8cc5f923ed8cf0f68da6ed3bbaeb963a1665f34398e60e3165080a28a6d9d71ac54aac8809439937b7ea5ac790273d5056edd864c3f99afbb367ae6496add6d0d927009f81d3b2e3763bdfc5104674c8e1a7aa5d91682a84ab533cd7e725ee12bccc9e8bf5e494d1db78f90833dde13c0d64d5cbd6ebab49958b80a572005f3344aa1323043d44d8eca8c82e315e3917d19f8a204d418a2819f6b9a7938fb750414db78128069652a78a5f6fdc38eef66d6cab0601ebb26e71f7e049e7679aab034e282f13383a272874f0916b0f0fc785067e6e2736202729dff42d27393fe7e1f58323046348a345c4903577d5335f4dffa7cb1229fdcffcf5317c382c10d50ed759f4c0b475fd86cbfee085412bf7e1e80d0620a36c91ad72ea7c3d54a6fed9ea1b47d8032c75540e2f0b48da8e2b07e1ba4efb44b7b570393abf7248ca14dfc7dece15857ae9d3c7747123d72ada495e3e2499b7c7c1c8489361bad355717bd00cff3aace4e0c9b2fb5f6840e13f2271136edee311c1227a186bc407acd6158dcc0b235756e8db0491693f8aa047bab4b7cfeb4951067e65be67dad3155ec074d133df3574f4f75ddedb3ea7644969d4470785d174d28eade63dfe1121a65c32cc1dd6b2cb7b91cba04fbe301d98fac90b25816a8108f2030bc0eb2e828237ed00b5161b246f4661fcfdb56dcf88994e06b7cceaa5abc3296e6be94f055a3cb279276b9b38d685ec987aef298cda8d959ee358657904592d86c4fd690a7d8a19192e885a7c8d4076e8037f208af0d8d185588d3c22ddcd34517ef17ab1aac6f5a748341037f62d98440512abc505cced968a534da9dca1a199068efdb68a23cc6c6a1905dfc1f9ab53f318f5fe402e62e73565f37070e701354a6346b5fbdb347bfc1bbc65f6e1e28c54da189b13a8811eaf5df9ab2d68975506680e77241559791c472800745306db4f417a0542fcb188ca705b5a0277fc673b3ea0fc7416744e90ab20a16225ac869505b9a9835a4297e6686a0d69d911cf45195370cb700cc6908e97c89c6729e03f1963dd272189f2d1b0da37050b4f53fe12bc23310aaef66afaf4a8e6cbcf20c19a7b88157b7fb42835b020989826a4c2d865227c375ccb99b01c3e4c63ce8388058d04a0d38d00653023f548ad1a8c811ff621792b649f267bea3689a8ae20c67536a0650e2696b2330176438aba9f8eb1ce7313039db1e94601940d3ed73dfa220328c266866075e0025f9608c1a0f75e2232cf5b7cdb8f9335944e6cacb4d78001059a3d6e8c5e749f6c08c04072bafb3b2452796b9f9dc21160df82a8767da92d899305df52a5397c206ade75537569a022445808c7636d25b86856e284a6b2019582ce4c2eeea9737ac32da06049041e271721190b0e227b8b2b8dded1c34e3322c521ba34f753fdf0160099c0b858f103a68e5f5183e319226fe8217d2d290507c1107ec1a8d1e21aa4389237059a55b568269631f3873955040cdd464e699d17424cc8893113486f5b1523abe12dc5543e19fbaa9bcc637e8a5b0e76cc5760f5d1e59a4225b67bcb5f36085280ec732c843c07734a39902db445efdcc92f1e07ee43c6863e0cb912e04bf68fa2d43a2512a99411a5dbbcdfaecf8321447a293ff3f5be21b0c59708f2df7fb8da6baec8136191e07040d0d7536ed6b77f8e89486c8c1dae7f14d46645aeed9ba58b9851cdba62d5cc11a25e2cd168e2406e1d09ebf0f77d7c7f6a4edc68adcd533660fdd4e1f9c5fc6f2679879b821656a4978cf4e701cf4790df6626ae84cfba34e58886c6f3a0a2398da32c828264bfd71cc303f4310fd83006c14fe96b5ab8d29961aac24300ee7f34e14360dcea8e3249838b3f737f09da89ef3c8dca2a3b04d432d4e61e94a5d760a87d9fa56a219a1554d427a0da66e6dea380a7c4aa27e323a6ef93ccbd82b8843b05dee976d7e69b4119971e21ac9ef3cf38500159d18e54f1f1b95c70408db0061e1f24d81abe75e02c03d14256eea3f55a2609f024ec132fcd308d338f0399ca7f8bab74f3c7b47d8125927cae27f10fc87f8608fa5dbb42a71cac6cec8e50ca58baad6adacd2db2144740f983f01dbb9db051741b714ebaadc2b10625fbdbe503a98a56a10e76ea23edc45e3e33e7ed556f9909a4d2ca000508db5ea36e9ae837b951820239c3aa0001b0b9ae3430ee988fafd6f8d35fd8f65e597da75e250aeefe12a776d77a427872b3e615c186cfb3e69ce9e3d75401744cc9932ff77bf4c4d1839382a7fe9ef862de99bef9780e1c9c50bc8ec43a76b2f56417e254225dc7c76ffae8cdc1af08c56c30dfcc980e3c751a2196acf450ae4bd68f6511eee5ac43e4b57e51c01ab14da9d5e012e600f9c2a102937e3deb63ffa8c4461add869785e0408c43b5e7cf4718c8987cb8bdafaea7f0b9d0517a4b4343f294d25c7b3852ba8fd4259c61a97854c652f203e8e142d5c949cc16353a9c2190196628ef76e9ef588e775a6f82cfe7fa7c5291423cd6ce2fade383decbc0a10d208a5a561b67c08a1adcad5651649c30dcd8ff563b4683014c72715b6347151f0574131ef6e35e0ba4ad7002cff7c97b947aaa4768350881f24714d120d7194be3d58ecc02002b6e5c03eb195e68f80033bd7a5e18681788e98488c0f418b67c0e775b9a28b2e261f0183c0006ccb3c1b4e17e7614dc6faa54bce294e859076edbec42ef72093ac07931458255feb8bc676a6256655a63d44f6836815ae4702e5857ea8ccb94b8ea675d14b796360ff7a018176f9c20cebeae4fc159dca232c0e4f9a8619ee1c14afaf1efe343d784795c870978d4f7a32b1c44e45acc060115371bd26fb508120915170a08ce8f398a88f88be814c4fa9dc430716c2e5f2e21fdf9f4a5fab1ab4bdc5bf4db46ca9633da1bb13ca66c845cdeabc8bf3df324d88bde17168973f8cd4554ec240f6edadeedd01cda84bc4b221695bc02945feeb3dd31b124c85be1e3ae54f558f5dfdd813b0a11527ff184ec2cd93b834f3b5bc88b9e4acd001437853cadfa692e3660bcd9aed30b30565bfc54b70f5e65603da956153bec43e6e805babb38ae390b39088f61366f5f3efc0051011c160e228140cdf1a3579bead493780ba3b876afc5f20159629328390c8a1b5998748e409fa1aefbec10b5217b9c7e002919725999f9f83a42bee6d02238baeed64cb43bf46ab18c076430b2c51e44815bbc08913d286fb89bd754fac5c074c3edaef8120c0d566f764c4f4a4ff502c4653ef78e3eb3da48470a9eab27775296a73525c6d78f1dda4732bb3575a354ae479b1f57f698f069b932117f52cd9bd29210284fdbd4145a382762e6c04dce1eabb37a4b06a8a22f57a16569dc2292b416c30d5d3af56bb22b98f7f53a5438484cc8bfd3c378788be59ebfa3842c9dacc10e9ca68d2fd7a4f41b8b7df4c8cf48fa00c8693cf0a54ebf883be6418c8a191062bb7087581d6e0bfe5a6c8b9211d852496e1c634d1ec14de915628c17cdcacf1c0af3bb520babca2493b42cf15c553a76787200192d5535295071f86847da5a152c435ebe6e210447b6361973c27b15f58bb7f2985ac74e0f6c8b22a67ec205286c800a779b8a0162f24a3c555b02decfe6153558ca547bb8421d2aff6ca036d6df4f35ea273bb698adedc2f5aa8176562c9e1239f565a1cb3d9b4eab0430edcd7ddc344cef3c98e0a4beac472406b8fffd38ea7d5e7998187eebffa1ff903a57746112687c4d7b2a8e79121d12c3a956532d4f071060bb6fc2d9a5c110d76ebea1e325e30400c10dd308dc59e330ce69c66b62a6cd14671f51178948124c995074496bd9c7de5d01feb29735181254195056e486841cc3a992141b6914dd814c30af9f8b8556e2525f74a3a9c50936f6457abfef9ab841487e7a866a67318325622d47ce6e04ab28db41923d67932e97bef6711b478ccde73ac4499115e42ea1a9db91d073d43b55d9bd8a693dc85dd3a5957009002f1ba4e0ada3d4140d074a065728fee2003839964be280b4cda4ed8f1f743dc456f5ec347c3ec6515caba36f43782bf2d74559b56458bfb9bb2d8dd4ef35650fca0ab4208ac36970f00265a806fe9b705c7d6f460b0638276538ecb2ad62e1d420361b1b3677bb7396529efc91840f0ff74bfd51b2624e09ac19ad73d9d790a371c82703ce9bc6aca57b0a4ddef32faea3d401f901d4c8e319462e4b0edd8bb1d917ba05f069f203c3684f2823a01573d50310607551c77b68883226e35f1b519723cedd0666f7377ffae43524e4526207fce0ae7deae648dfc2612dbf433c5e7235a0143531df58daadc4f1f3681b64e2564cabbd07639275544676d9e4ea5b8753e6a3b2b4f92500d18d6740330bfddf32c08a430213b33132bb2574b18fda1ecb47c1f364431d6872077a5f959debbc498b5d5505ab6e47f24a13fa78bc7c040f95e126961b7c921bc0981c4f1757d449633678e7a5e9a2abd3e58fc29fd4bf0596e65d7b765b38be97309f83635176dbd8b5a2875e62249144321ffc9c269964ba7edfd3bc21846917a82688965b7831be6076745722f829c781bed0dd638424a6930762a6cd88319dfbbe1429f9b7712a520314cfc016865e27b009bc49f427960b4cf1c83f946dd4ea175e62c6028eb758f3aebd05ff70231f7c5b140c99ab5176708c9b841a38ac2975ac348f87de13700ebfd67a1c482a0c9e660e18a181e132af913818d746ffdd0277d069a6d05fd3551adf9d76f1d4886d260e0362113e4ea254e1564130a1addbd72a08433478b2d978c6658a499b9c579b930740764f40162031e183e4f4a2b787b59a1c82b77ccb380679ffc2d1d8e9f293c75061c2cc6121352cbaebbd0fd4d646017d096266921e8d603871068c8d0a1e1b2484872848960c48b8167ef91058e4bdf1ed4f0a9aec1483e9e409d2e52ae075ed155c9dcc2c54dce0e4e462598747b22a1a57044774d3c35d4d36896b769e6a30d5c5ad2da779384abfc5437a0e19a5ad3938b158db1c27d2deee27dd47036dec78ce91f11be39241376e9e1292d810b076a23959b8a437be8b0775efda41043db2ce002fcc52dafe0fccd9d1963acdeff9240e57ae06681e14a8095d3279ce642b0e5b95643aed6a23d65d88b44c4633ac41d124358dfe3c19dd6b8619533ebe2170ac5c0ab28306038f0808c37c0af2e314bf51f82a89164dc0b0c93e9c26ed193ef1792f6feaed3e43eec0ec5eacab2098e4a17147c1b161bcdd67535538859cec13a3c27ff430b7a5199aa5f606ed8d368d21fb115b6999685e5363927109410e6c97f49c060bfac3bc182c7ecb831eeb05e7a2bee57136a14d6b8ab42a17f2ccdc4c60cbcf24acf11718265b670b70574cec6cbc6100d3968d5e2a6f2fb4983675120ac4c25f3f3f3c20084e7334243af1141a9ec30085e1281ac1d18e2c35c14a7f80e57e1d7d8e755c6590fa4701ba93a83dcee13a06cd15813dfc931a61f39f22c7c57d6a7d3970874739a877a939643e3a8e32a803268bfc69f5b86a630f60eb9c14f1f10e4291a44f40beb8747d796ee6724aa330e2bae7a0380ed681c80e0bb7615e15cff0785de7c0cf50e7360a21cedf0c7176e6e0b98d705f27e7199537c6ed8c289bd19d5df80e6e756a56cc97a0005fc7fb731eadb894a7a376c81b4265b2463e6d8b92a47685fdb68d0450b598b57afec37c7612d46e32a97719b91caed246b86b62469d21d5c021dc724c2ba8f1edc2eafd3104b49e4edfdca6298664d41e1d5126725a2a6f4b48c8f57cb97f8685314282c5e64b35982dc98d6e8a717b5fbaf30a66b16adacb2e5916c0443d86044ca1a7cd91b22556650a6dda3c5b4fe38f3786e52c76570e3d94aa1b274a1e04b561a62d07829b0fb88703d600dd23288ef942dad41a187beb6abf58d7af65c352ec935f05b48d1cf206801f869ab4040ce97fc492826c7abe58a0e06bbb35a8d398ce8566318dd07fc9552baa18fb89d8a7dfeb839057c8484968976ecc3e2928fa463f95cd1b3fd98d9799e13c012875fdf78391b8c0e51cb23e1f4fa0907ad3b6dbf18b49fac4738433bcdcae76aaa3da982d4e803457374ac616060d6518946d946751a3cb1a32eb124cc86deb0ce06686c5360b96913a318cb156a581ca2946b9ae45049feab86278006607d197ce75f9273870702bfbd5119f8461f4e0ebb1236bfe36c142932d8a4d4c1e8e4ce1afadadb9980f4688c44b949e4fcb217dff19da3d309cc1d2d8be9b740e55f9ae027c606e3a97a2e24cbffa66528c70bba68263a8722a6653d885b3bccde64a925bd7df652996e22722feccb1453a6cda0ea15cceda7b2d33e8340b4c963ded68f80577001d2e9ea753a07165849e19df738aeb74a08b7b2896df9801dded14236d4e905b3a4e2bdc7901a2443e4dfdeb5cb121be78d8c3262e0c018f3c1125bc446bffe5c279150462a6aab14dd902318536d27b716e5a3a6793606402440aa8cc4192e2a4ac4f1dfce600d4dfb32dd3b0a9db07d3e31fa637848a05de6dade15d87c5bf84a2153f1a70b639ac3d2a4afdf5c17471d1c41c76600357d1487eaf47e69b25933698cded31415f7d14f8dec9afb9443611f412843d9375fb79f251566a80f2f77d8da98fa309282f3ec59da98156c187e7b7115cb1148b0aadbfcab31a809c14c9c508995878ad1ea0467b589047a22dece8cb540af87bb1f1b11dc3bafb3f7e2be174c6cade7eed8bd16c12d6c5dca7c122bff6705b3b80ee8ae58a19b0c2b5e245269d3a0f4ba435089d4e512f71c83b877ddc80d1255bef80ff3cd54b885c8d7847f6281411678ebb895b07241ebc4f2a1f8e40b3f28a4bc32afc6671167480ba6c3ec0b4b3ea60c7b592c870c70d1175f0eac5153d554cacf5a5a3f2c63361c80fa15b987a77aa013d86da79481317c1e993d4fbc71fb0335a3d5a628130b6587f49169305ea47e6a3b85ce4b1294120b4405908dc0b29b7b23c3a0569265a0f82f0e2dfcccaa7393234739abe09edb617647e68004376e805cafea7a43cf79aab9f99ddf9348e8ae203db3f509ec6d7ebe81f98e5ec615ed785b17e1ea0427f5f9b0022dbd4c03debc03eddc7230c86a6a7915765b06a6a9d984affa3ac81af7b92a5626f7d5a9146bd94104105ffd32bdd8a684223870e8967ea2673553c8e19590aec817ca1a21ab4f46073c9ddd0a92a7e7317320afbcb1c2cabf16a358256b917f2587e9be99533ed9a3d4a846af225d7ca92c3f72df161ddeaa9ba007eb8487977213f0c698fed322983338d1859f4fbf417da50d455b86472e82c6d7169070c9ee9b858006c20e5208e473902a32360900ef3942ef9a8fad4f2e942c4c6eb969f833b1e9d3142f5aa75acc78bb535e529554d8b2f2d7f523997f4e1d29c41dac799842f75bdab832c18d01df843f1cab5a35646ebd7a25fe99c2718f53e74024fa4dda1228cf8f52c9c4e860576f2084f48d1f47bc56deced5188aac827acfcb24a2273672f0c5f44e061f259ba6f065f19a4ebb52b35b1f71ec66e159a639f8d74a34006488bee14544b9949b9a23738e0abe35b4d23103c159bdeabb4187d52d84a40951aefa3af857cae8d13de32ea46d5d411f2078f13f1dce13ca5d00d7d5d91c6552a32e782f55ceb03eb33c8aaf4daae2d43782962680c82e026c2eadcadbe97384e1f394d07c2903d58b9506fae9926cf77aa455131e78aaeaabd1377e1868fea5e06c930d47a528401b5259ab400cc6b976447e5681d15267e5de9ad7a927a1c0b78a9b803585a6d3461ffa48f15a57c418fe4e523dc5ea1a94f3281706ae2b8ad312d71306e54116d7dc5edeb5b46e94a196e7da7008f7fa7994e14ac2970a54c16ddf86a4ebdc99d6b33683130cac9dd9e3558ef58ae9b4d46ae55a52d322846d605b7992c0e3b2c7c536185601dc2ed45e17b7ce69e9ccf6357267f2ca9c5e2e30f1573ec72e38306171a66d8d7c248d72ecaace990779e10e64216c79174d95940fef7737c896d8a52c76638592b84f233eb7dabcef78906cce606ca6765a4e07816697be71c60dd6ccd32aa317f9044b92baa11b735968ea0b0d674decde3a90f95af208728ce9473a807d35911ae448fdb737302e4a28cd5e4809f50f7159e67c44193c0fbc3888d9b9bb97a6318b1a1d6c6f165965d0b1545aad22dbb7f6edf675371d03cd372029531f99a1c03939c90d6969e6b945ba4597249c249ef94aa30cb7f8d81373c5c595347f8b41c694548d00c47ce9e79f781717ba5beb7aa4c87caa80b1ad637881229deb3eb7b630be6d01db48c38b3d4424a13f24ac6c8d3b70b2199a4c5c1b3ac69c08f616f16da9b432d4ab2c1dc9ebb585bc2bae636c91cf7a47974d38527e7c2c5d79a8d7ddb42b17824fbe6b5208294ae32bedeb23396141a2f4a43e85b442016b5e52fdeaa34f6d93d9bc92e9c62ee981526a747c1cc7f7408226ccc60d66d78f33cac55a53c1c0e751d4d669091ff619bbdb1d51efcd9d91539b02da70da9af0e787a08550b3350659742c205d8b4b3a2b16410cbbba955545fb62753029149663584e61d6d2532cf30b1849b50470877d8074f564cdab679c3cf5536f3f57d2a92dbf31f1c21def07a8e0a22509dbed552ee5b6acafe546e93944e40b28175bc9bf7292687beb92d5f3c9a6b2310b56bbf740481038a5710f87efafff840654080068bad6bff3fb6ddf073887440417bc45dad45f67f6fca47e8463f3bfda80820c85e5683bccd2e95d09e1a74c0f5eae9a276135b2459571eade9b39c6aed27841e531dd478c6c2310f71e13301c9ea0e2f6b0cbb67b71eb5bfa3728659aaae144a14c4bed2855be49802f591e1e0f1ed6e49f88924cd73d29d4cd5fc59666ed2b5183a33974650988e0a0f3b5b3de35f9b1e0efe2d733c819ab56abeb55c301222b1d8e6af3f224c581ecf3807a413adb2bcd4126e4180c05c787952c57e3ac91d427da44e2755c137c241cbdb52310c1567a596744fd9513174c05309423df23a97a05382d4c0198213172d63aa2e9261e727460f4406f730e7974e660aa207399b9ca0a6f49c761d86f7c3d5706c4fdc5f50dfa71c07b3d26a8acc612984cb29fcc4d88506e649d8a4f29f541db8bdb4257eaf5e7e568e151f54921d1f02e7efcf2988690e866781e453baad880d1eb75fdccb000ffc11f24700817801c90933f25149c1f2bc56101da4531b0557f1fb47ce11da713852055ae03ada67452e9d4418203cb8795323b0eb7f328b7dca3251f411b19cf6a7f8171d6fbb72d30fafc56de1125b37ed63ee9d6eb2220454aad849da2221817081e04a761f8b6497aa400f649d9f09d3f84d5ecfddcd072f67b8e413280ccf0d2acf83ab6e90ed6068dac0db62376132015ef6dfdb1d68fc64eb7671208099fb32812c7dfa86daddfa707c7272092f4973590182dafb47393e8dc6ce51d2b145ab9596b62e358d6f2dfd61cf7573e9eb2795c9ab0bab97a91bd21b8e19f18b5bf14de1a15a03372ed0360f52826e0d314dc6b6c07304d0f54744aa2c32b422a65b22f50a389c4323d05168fecbc6c077a4b5146baa800bd9008098f2a46e071a9ddbeaca0ec77d389cd47e834949f9310526fbc59c9b90acb82d48613a3477e19117cdc8ca29132a7346c6e1e1f12c8dceafdf5b51096b892d93726794e8f170efd54da17a9faa4ea7e20a0e08ea109434bcdf0a968a6b6b3f12e20c28933ba85cd8aea4e30cae800830648212b56390d8b402b3914be0aab4d67e15756e64aba6a760c2983f91cd73d3216a56e50a1510bc4641eeb75d96cd423d3f6d80082f90e0176a3e55a1412ce5c13459864e5858776a89cc7722efc5863aa5c388629bc9751041968d7923a70f418de370ba47586c0aaf61fc1f6fd88e4c79588cdd2cfb02ec2c7c539078a492ebfd6ea534e69a8d37a9ed800554be669d3ce13cc06ba12c735347bb3784b0471aca278ecc23217456d97cd07fad4f7faa0511101cfcc070613d6a9d6","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
