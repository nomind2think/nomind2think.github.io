<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f32ff667079ed22d118acb03081505b2ee9fe6036e2a5ae60421869528a492bf7dd99d67da34f60f2b754e70894dd5f0a0dcc94d31b853bd9421f08a59d88ecccfa1660e332dd4bd3b037a54cc982f6a74339bfdad575e8060d26f38f0aab5ec17cf319d9509df49fdaa0b399e14a9640a8941d9a7b24fc99aee576b9f0731f6d54f285033173c3f2153a03820d64f2bf90518d04b5c63a3567fae0dade055622267349a39f25f81dccbcc3899a6bc7db0460cda1915b8eaf96233e967da916f8ef9e9a8a7e4c80b7f878075f2ad4fea3fb1f195703e2815dfd7d2dcc1425a85bfb4fa8265b3dacf87e30122f40e2b1ac8dba2c335146952bed49b2085a8a69d6eb0f3e118d3c21b28cbfda6bd87294c1e9c68c7018fabe021b09c51ce6d97e088fd70a21e348c69b27ebcc8352bd103054b16bf87684cb0e55324c0d8996fc00343be4bc1468a0e88248cd245a57f6431ec0e01e2b8fc2d55f7dfcd334fc1ad187823283e7c29ce4856b4851fdfad32add141ef03e0ed90aba53312f4bca7c668e7250f1b3f502ebbe17fdaa016ae23e85f77f5c2aad7ec6039d530dedcce2ec936f46769b31882b64a59d5df5d96240e18ce1a998a4e376050a37a273caace92473d7f58fed1fe0a19a297a4bcc0862531e7fb8eed3a48c2a76429f47f736aa32f1bdde9ede862be72cbd6efdd47a3333d850107c7a08fb8b2aee2ea93e33ede2acaa259457991894e1ef9b8689a57d3caf3e5c4bb17b7cee30d58351d1412f6a6feb5389da36c6c724498d7d5e13d6081fdf9b973a068acdae302f0a4100ffdb38a637ff3916755e6c1b67a7ec7f2dd6e12419a8301b541aeeab24aa321182f7d73b2bd646bf8519b422b03d1f6a103378e1dbb0a1fbb0692695f6adb474aa99bac38a7b75f1156a58b5d406d87c0b4ec6d7523880ddd4e303ecbf56ab83daa08986b96ebe006373cf4145a0a88ea19c086d2a18548300041031978b1015d40effa99ef2cf854941ca595b2c5386fe5b09c69493d2506330da65dc1e79041b3c815bb5da669d25857dbb5788487b60789f38a94cd54d7ac062e6b4f424d68c39197d7663c2ca60b60b3be87d561580f506db6ea58904f4535b4eb2762b70106c78762f4797870f915336d0661759ed928fceeb8eae30ac207f72c4bd0ae31e5c7e6410fcdfbe43351ce609c7f66529979ca17383b14e8f024501f64c29289b931df7c56f65ef0d1bf135a3cb618686ea494fe54210a94778858b19b4cf77a2444f27ed5fdc03e82da6682185132da0478684b00852bf25042e2733897040b98fd09fb496badd515a7eaca8a982010fb6cef0fc75329158361c84179b0385a1bee5f0640ed1d07b791af941eb9c85d35708f6db9cb825509e1f8740f6fc93cf1ac466532aa569d0ba3dd90335c7ef9f321f5746a0fac6519f9ab243c955abfc43f348f7cb8eafb5d9f328ce7ca2dce42884727a2c798424c2e7e418624e9fcccdec6ba9a7083ce07593e91c8dbba1c7b12d0feebff508af4489481d3f79ea36340e5f987b7de9a9ef6b4cbdf6645127ee7ae1ea16354d267d6f965af0c9cc3b72bf55fe223abcf32d4ff4858c6e0a985a93901abed2f0798c81687fd83e260fa89749870936b1c9f65406a2e7270ba1646c81835bd3fc863dd0bf6b6a20d64425606787c2a90ae41a0b78f3e538eae22e81fd52e0027cd79d1f22c25ff579f8f08cc0a96d02b167f8fa7031e732bdac12b11cb4d1ea5a193f671c49fe2745fb0abf99df20b6feaed30c8fa6660c9da5b38a8c1639279d76d115d9ddfa14661aa0c1751a1d10136afb759336b4e26bf04b785aad2dfe3f65c8ebcffd5ae6626a36ad876cfd6ee1b7ebb11bbdf104399aed36eb7e1f79570df3046d1ddfd522b3bb66def9c2d9c69f4064430cf31322844e7ee2a2445034e21efd4b46bbec58fc2571618e4830f1fd947ccb6559c69115bb77bd43be943381cdbfd6513ed732851357d127466d1aebd63322475b61a54e682adce576ccf63f94a3f51ee1d7a2803c8679a489e4c04ffe95d4527436e92e4197cc1b7315118a4ea0c0d341b81a4aa4afea3aa50c049a8be6d1befed440241ff64883eb865cf76252bc6aeb75a8e2d69ce8e402592a94d830e28ca7307e10ccf3ad61e189f8d6a97e42fc6a6be40cc0d919c66526de3c2a978a7bd4821fbcaeefe4062c4f49146cc690a908fbce7ce1d3851eb9fffe3b89274f74e8ff6d12093990371b40644a0937a809fd349922b82d573da991c6b6ecad3bfaf86a49f5895b4dbe0e8dabffef339f7c4e68e0adfec0b52265843fd5b6abfa800b7248967a07cdfd67ea90164f4c75058518629c3d419277cfa4a7ee4d6ba7ce9a5c022755463664550e49bef3da7242ed5fd351718537728ec19c060e0c234fbff85bbb71fb355fb8607011a237266eff687a8fb959180fd4f486d484077f30be91dea8ee67836dae8a820a47cf107796446dcb38e1e7b5996958ab874111760a2d00557aea5a5058a447dcee50d82ee51f3587f127921112dc24d457be2893a653204d4c780e610052493740d119f6f668e86593b2a0715d9386ca930b10ee414bfc1aabf8cf3e3388627612c4823d402f0853983ef3252fa0feb71c71f382277d6f033f35a4b24444dee4c13b9b7368ae664e2bf3e53f4f5243593aee822ef473a5d801a8ee5507a83616b2d864e5a3a20b0aec6ba08d40f7f434552dc25526243e47ba03224a559c150cef8b9d08f9d03d26776eaf1f183cc2d0b7515058b84b013de054d9a5b4024af66ac2adebef3ee039db460a2c75c04b9fc17059f7c276ff2ddcf78e224a7974ede268a3e66d0a21b0cc9fd15edf6872d05ddcce9f0481b9b0cb8f02b9de918fc885b1d5a1db35be0468e8841137214040dff11a033090ae137d25008af81fd015efb3153e09bd42f5576fc4c6394b7dc4ee89e9c5c2d8bbf59c905dc1a2195a62368be26f6a8ee42742d48ccc61d482509cedfecb4753bf9c479a7aefe2e899fb22ebad144be335c824a34271e16cd8c0e569cf7474e9a3f6bad8eadeae8aa79be4f5dca188e18da2a03a269d72802e5071ac649a0d2fd7167d1f0f9c5b6f331d1d0f87ea53da18d9ee14f2cb26e6f879b5b24808a21d1968e1a7525609a55986ab5b612ad3b2b28f9b3d16e9d8d7c2368322496f663fb1963ff2ed71214f8ec1a7fbdf5684cfff2f3adacf77a3d67b5b88b4314c6b5ca72c11d3bd715095078836dcdd9f60495c13fc9db6c5c788867abcaa425127090c4187e74efd725bc171125f0434a874caafb3405ea015864f211efe3c99ffc056509bfe1ba5b80fa8a41d21f27a37921d22be69143d878f0154994d639b2eb7f284f25a1e5de82d67eb93394347973809c11c68f9352319266117dd658537107ede5511dd91ab11249dd050bea7c3782a56c7cd05520449cb9ebcbeb0f3acc329bd31574695a4f0779ee1c411793460efbe0bcf9abc69796f1b626a1af06add5280484a63270c7ba6a82bfd8d4cbac3385571f22f07745983a4cedba31bb3c45fc6c88fd8b67c4b08c2ab35e94469107ef6fd913decfd18b207057bfa4a0829bee85d4bd0bc18962a47a00f652e060bab8b2763aa573ed9950b657d785f12870e5216e511236fea511433f7fccb9f861e638649ec42f92917787ade170e371c4d1817ffcaec3562f19c1cd1592f440fd79294c302694be754ea1488660d935ebe2bfd60898eaef242795760af80e3667ff37c1d1fd1b98afba14458e949b48df8ab1bd6f356ed9cc97d460fabb7c0708e1b5edd3c854423fdc2d3f066db62ce98f75560c690e1e17fdc9c0fa3832e4ac85555d127cf8581186d397e375a6dde3c4f26b85007126ccd460e7285e8377385244ab59a8968061a9f799c773f450b045e9da09291dc9c4e64a6dd8291c371644b942e2bc16be20221f39f41c71bc4c51f9e2d230c3e24a74f1c5736650945acd209739ee1b6ff95642724a8dd13d1f89e0151fe3711b1ad350b60e8a31af587616c5fc6ffbcbc9858a1093ff875f9f648b98962031ee56def4ea44d67de8e8812015e253303f0d1725e9911d06e5dccfebb100de31f0c7a1fd9dbb905c8f8dff40934536f237204307a7fc8ee5b7e7b333b40c0fe8d9ebbeb502754bb2ac95de000b010329a62de0d4e1275a686bb597f9b8b0cff648453d9715b133c8462dc5a67f975dd152847e3f2bb9e562b8f3243a26e57ccc6c7458777633e41b32fa47dcf0a372efe862cf786d8ac4e39b0ffd5e312abcbcb1ba6604b1bacbad908e87374d9ed801c847e4d7d6b4ce912ab604d6ab84673ed0a86f7ae5ee337a41329cf6f9f6df602e35df252db7ed188e928321bfb2434152ae9c36cf3dcfddbd7bfdbdfdeb0185b81c444647e8da4b565b804c00759e01344e83264258cf6b1d27de2b9084366992ed8edf72363d3d7c23514e0743edf5905205cb3bd17befc12108f44f30ff0268b4973cd2a06e6349229a174487b1252f3d4f2a0abdf097c47e877be4aa0bab3fb547745e49778c9864303ec084a56c4e6939c1ea0822bf7a11a6604f05a7cad19e282847e57e2af392e3efa814949ae7a61a9f832c750e9fdf21d2db7eb3871da6cdf2922bd8075f29fe6cbca7ba9e482595a8553795fd6ce78e3429cc1988df17ff1264c312859313837c31a7fd670004d4645b697c0ba82eb82d5fbe28b5aaa622687e0ac2c76dbe6ee1dfd96ffd4f804dcbe9930e29a2ae4c4e3b3b08b58da77b21f5b1e348a092369952983750fb46d672ba684d9ca3837ffd1d1832889891d457c65949c2c7702245ccb3dfead5a69e288b745ca931c134c61cb150f39da987aeba5e4d51dfc8c971ac99983069af3120658e64a2c5f8bd4b5f38497fc5f0fff128b3f388ec2d5d5389357d1a740aba5771154204a03930a402c71357ea8bda39ae4efd13697032acfde5501bdbf4e22209ec4c2c6172162c30640f1b72c2eeaf0079ff45f77b7027b1a9a5c776b357ac862d515d6630f853f052294e23e532addfb1ed7c53096735851ec9e588ed64f43e1c5bc6a8a7832c69ac1fda395ae0a66e00960171ec72726a610e70688dbffc925fc9d3f189930f8df50da03e38e913d7338e59a1f3834483196155aaac9f560da93677a411cdf6dd3c2a6b6c15c6a778c1c79815cdd75ca34e46b0ce24a175917335d6df94c16c798693ab555a8979d8c85d3c8301ef1fad80709d5a666b345f463e10d78497a5f716c2a837ea17c727c5818bdad53bfc9e989158c203a68434c7cf618a694764baeafc0ef2a5c8b624d2738e64e02ce9e1ecb1d5eca11f143229e7adf16200a3cb3b1fec544faca404bff44cb68d7c8731b7615ea3b3dd35455a94d5f4c17d8560f13ed1fce2fb70bb9a895ab9edb6e9b5cf9ccca9cc8c3efa5af143f248da6a7561d3b26b1edde667cf4262392db4cfc0536839c1e98de1779edc86867be5de0ffb263eb40033f84da124c73ad07180411c9550a700861adcb59a7cfc6ad2b5f09f0c527ee72cba8007471ef35603b764eae9d82db97c8d702fd9a22772a54f4566f035a942a3f8018fd6efd8d53e88b63ee7d85ddb59a90a4817ddd12aac19f28f355435a1ab19dabdda45e2509f2d6ccef1736242b136c36de79fac0e0a2583024a8d73139e6a38814a9fd3710b8717ec083b6fc5a7046e881edc3044bec776c0389d90f3a3a49562bb428dc82f98fd766872728aa65ac57dc19311fe55444e155b29c71dd8cc2f3bc5d596fffb020b5ef82a81e6437bb51e88961872e79525498d1d6ec2c34c6857b907fd56b24166aa83adaa35d9777fcba8a43cd2e006f76ec3f7dd4bc1150aafd1de16b9692096faf8dcb8b915aa31daf8ba0f16781d016f36f83747ea3e26c22f58ed4a7b157018a25c86c0fd2adb1430dde1ab8b802d9dbf4f889927aa75fed520f2b369c013f661a7fd55013a9ecdd432ca2f905f58fdc82892b0624a152dbe23a52e9e0f1f637e99ac3485447d19531eca594be192d0153ba22bbd02b3e06e28086cb190074646557b6c25a4c8f74f0306a9fe22e84399aa30fa0c3dc2b95a3552bdd1dd4ab7096983e2422330d93feebec0b576545492f17c1efd1a95201f7028b3ee1a580f1a0ff487826ddbf0f38457b4b0cc22dd031039d30ba91b6a67e7e35ea5a87cd24cf4fbce2f3a5dda4b848be8a133fcb16491cbdd49f82910f00d1c068595386577564de80122dadeca06c2dced1e7070ca6be09230db1401d50ae4a17bfa76d37043f56acd62511d406b17bb8cbe4b6b357af401e41d9528c3e4cfde4a979e6dd13c881590385086e31c5aa8445efb378b98246b40816f800b81d3cfdd89719b4d1146609daa9ba820acf461509d2c2ed684e5a4408e9a875a463ba8f0b1da2e63bfbd314a92f8689af3d43b92551f8c7e3119e722d45a6a9ed703d854611064ff34858e19d7c973263ab0010d8cbbf28e5db95ae364f808cf31e2b6100dc7dafd0e7c14d9bfd7372006ef5a7afb6e9be3809d396f885e671da844a2786919ed544c68a9543496b930d6a0c4a1f4c00fb2f08ab0131012808ca22b677fcedf59b2daf9601b04a0b565511eb3769f2b23b69f93e2848b9e0b676f4c52ffacf2dde53d0b36f9bd1717265284d4e41749abcd6c3ba9a609e89e2da66df96bed990222c6c077da92814e24319124af28a8a0404e61c4b6860b25b80cf00c839af2d3a9daa7df3ff4c73f501f4ca106b9c10674e8f96e94af535601bad1c03e88b828f6c17c0de5f1d2fbc15d38b17c30abb3f89419c0fa0e52fe8ab8b7ab819ccc0348099410df7f847dfe281be0acf1ba049b052ffbe5b8e50a72fc5717f872812cac3787cde2353dd0fb7dab1a44962009c6e6f8cbd1fb3ac4e25e5357626657814c80c50ee681dbaa9df510ddbd220add4a4aca58e32f770e827f65ac8fccd98a7b8ef5f269299f626e688794fbe675c6e33b671b5a476b5545a1c324686934b827e1d431a6630a8bf84fead0111a3ade2d7f14ebff5534145b399790e44be73cf48d06d1f45e1299fd4e9778ea56fabfd074db098b9d8569c8cc28f9fec7d311756c6d0c6fc4b1408786853421f14bcba8f805e284e4f6f6cd39d7e6232efee6498934c34819de9a4b376b737c7487721fdf9bd6e7e0e71cc56a8e4981d3a7de66cd46d595a0b221abf65941089fff9aac2dc1ffc79b82266a5d2c572c4433d684f69cf78e27ebe3b35439405e2f3f84280c5d90879c0175dc4250e83100cb1348d6725caab7b691329eb57ed0556d93ed26793f0bde4bf14e55612aa3e72744e59be9d8470231931a8f2f5ae33dea4c9b9bf5ac45b686220616a7986f07cc028c69c0873cfea345fc2681e57f531dd00171602e93208ecd45cc7177282dc1abac20a9120bfacd6c8a31de8cd4d2372b26f126fefbbd3987f8d078566addad4344301d86ae79d969ee69367239887e639da0f79c6c433ef3960b0a60b2819356ee913848590c681709c132836c819120f89e80459c755f334e205dfa773968baa8c5f5e20445d41912b1c68e571661abec3aced6f2e9b74a8d3aabd363e7b33db9087ffb7fc28ae43dc5dc2b1851a00ead7e218ee032c1fe1a14e87cfaa4d3183292c2c83f8a67dbcc55f7129516a7dfcdacd4342aa2533ed2a44944a4a447c336471667389b2da4375c2206567c6c5ff2c25c2be710e85b949e334509b30ecfae0ac68b239c396e4c1dd589d4bf4499f95fb009e16359bd2ac3072e6b050570590c540066f8f7e6df531fd47953cca068fbb1691f226cf708a23ea5241dd256411be62f8794c0553b7be0aac0833881cda68424521de70c59d2203751612b051e9ec8ee7a0c1ff5cb439ea36802133d29d881d72a8c984d74bf38d68ae464850c4018f40f0a6df3e47e9d1a76ce209c8a793a96e022039138e01205f188f5dc045e92e8eb2921860781503107ae42ae5e7bf94c861564493ea0c0d5266a512417982ed353d92c7e99d418662ff6745030ce4bfe5a98aaa84e74c16016dad29c5a09b0cef2e86b8a87d89e62c4fb697b2970cdb0ed6c1ec6b91177c09a1450c8b19700f16f6d7c82a350d11491ab5511e445748b0e83004fc5d694dc57d8bfc8b140cef14f5980c840cae3c56632a502d65267a6dc371b2481ed95068709a1a22b0cc1f23784ba58cfd61a42348a1da2832e4f0198b9273a6674d50aac65ed8d49b194a7c6fe0a2cabf3cba7693d2147d3570fe150e6ec0d6482902c695d062d07cd756599b278026bdebc27df3146d32ef1afef47f1731fa71394ff3014662b6bed9f06ba44a080972f3ef776b8f1b3ab4d1353e58c28fcc6bc8badb13a709e1e698b0d53cabdfed4a5f35cfb3e9a8db72363677ab7271bddcfcaa4e8fb458c76d5a73f82447c0089f0f039010638339e439cd2a4e266613405edae8a4c3d8cc5c76d2065563a41b46dc3b9e00f61236182a49645bb637199bd3a914f0f3385366bd996fd31c08014d6c718df46c7a46a408d9ad766d8642714987e17e9a06824059d72a5f8d128c93951d816652139caea04b5422dc24b5b53da8eea6badba6c3f159f88947cd4ace60b17633d99675cae6aa300bbcc8b83e5969375134227700cd8272225d99a6b5c61607e1f63fd689f2387e17e16ad3d98db0ee11d495c572e3ef0912d12c3efb60d32146adc4afb0a1e2baca385885d42e196fa732255a74f044726ed7aab7916107a1ee52cbc6352e5b04b206a5935e873eef3192096d59ae68e14a6fc47d91c2140be620856ef563df6ad54265f92e0f57c7a1c616005878126af25bd35dc8fcddbfb8497e6ed2b53bd95a1ff9caff061fa18e92348cb347c9bbfe1bd186b9b96a681acc4332f4dbb44ec21fcdab023222272ebe27d017a743c8ae29756f512fcfe15c82f3e9ca000f591e51eb0cd0295e6d09a0e45527db4c48c23487c5672d8eafb325dccc11ca646788b88c2b86eba39b24fa92d88553770d9bce4fd1008504a9f8a862ce835b0e197dd73bde3858a2aeff0f053cc760db193262c120ed37e7cad422676d78176d2a06d48c12088effcfc19106803801e7bb785e92c1d9eeb669ec44d5f11104fb96128902f036a188d0908e606e6d2cec3d8a569ad989238a4cc623de4247a0c98bdb5e5dc8ebe53c490c3e9252fe096a4bb61c1fe8939bfc86dffdcf80b99a8d97512cf3239498dbe600970c4ff02ced4b235dc40a4796481b2114f6efec8173e3eb6e3346b59cd7f0fabfe34f30c667c71fcd38c458e6a9c6928508dcc090eeaf1f37a41659babb00cd05c32753e79f67106a6022d1141f2d9306bb0509852d8fb1bb81edf5a328874011569026dab036a84600907165e9697a68123851174be2262792a81a6b78ab98bc9cb00987fd3933fb169379b8d56d70d28ff61923317f62b7a4cec40127ca36f0d9e6f1c63c8cff96cb85854248262b2821d3a6b762c24d2b43cbd5013f66f372deab0880188da4a6af025b16b25fcbda0e1985aa18f65838e7cbb1832654979549c50dca2a88f7f16c7ffcdeb9932dcb5682120fadd0fb4ace990f7c43cb31edd716a44eba2f909ddb37ef61fc6954155e75c68f7df93ef783cf8f379b4bb8100c8e502077b3348d7e17a03916175f651a184cb20ad907bcad92605b590da036d6b99f30da2d79b997aca17525dbb8f53df314ee3114c02b9aa1552214233877af0e9a19320e2ce2e67a76982931f09c8066115413e7629b773329665aad794592fded930d07705f4cb4934f6d1085026378089d0a9457b56b13970fb0ad550c97d34f006b74fdaac1a1c0e925eb3a993047e85df06adb52b3bf112fabff3f07ee62218c118b2e883be16c3747ba6ad9b2af91459803ba77518f011652fd5607a9cae6d16b1869a6515d898c6eabeb0b2b6aabebd4b6c43a50ebd0b7b0a5ecbbb45470cac4e1834c79a1adcb780d869916210c07a0425705edff4d7e7bb012bec36d07fe98a284c4ae616542ee9a61f599a9c3232b98ddfa58e49897c3c78d113d7c5b31595cfb31a84038ef42c2c815a04fa347434604f05e819aa8b3784d8a1f19cf0455f1fb7ce697f7b6a673c4a1d5982e477a7a9179ec7f4ff0ef78dd28ca106ecc6499e0a64481ea75951ec42de1843b10e4962e038df739d3090473f28d230e3d03de332319b937f46315dc8ce2ece2764afbfeefefb3a6a7de8367987bba3d2aa9cb74751efaadd42becc24d7d27fb8332f4fe300a2f109c2c285c4958d2a1e6eb340b84e4f8a656cf5b737dd5011b5730f26b227e1261dc17df90a524a7e3c7bb655e9bd65378852883a7e56a7717c33f5fb020ddf07d351d91bc0e2c2005eaa09cc2d63a01375701a6e137fa9870d063d4805b7335fd5aac8b6f262a549da0e189840f3970500282536de92650a3294fbf2b9c97abd802d934f3ff92f8f294ed2ac4e7d3b165b7c88a85905a3e62e1a213400d99eec851ae1032bb1e763817d1700d7ea7aae63bdaf714e7114fe7b675346670cd772c8623dc816da2e605ceab819bd2e5cdb5acddc8aef7f5ed03684c4454be05d2ce3acd0f65065c175b8692d31824fb446f223d32db12a6811ed2b662fab0c0668a2996e99656276fe3a322b58cba7b24a316e15d1a4e00e15f8b6d1bc3bd7067e74ded0f593c463c3f6e321787d5aa038b29d66a63c175d175ff3f1d586a9338f2502e76b082831a6f89e1ab15086f233be99834a2ed3975302369d985594d7aae3c80fc1c3c37fddb0efebd9cdb941b52355f21a26d5cb6a244ffb0e0ec561913503b9086437eba813a7964c3348ca0fccb56554a93343e45e481c109de99afb30855c6c530fa26a0ae394446fe2d37fa678d540b9d9cc8e48de27b5a11fb826bd6fdd0f43b38be335479960f91d489eade7bf4f942cc35fb56a59934f97d30a10cf6976797460b72191927ea131b0b5e10b721446df471a08414469bbf0abd34fd963e70ce50efe02d719554328cb3f0fb9fb37da520a7e8db49f0935442557be2baf368a43212a4a95ff7653f8ed777d85b54e576cb1e738aeb1bee57f65575ca8e7bda8b894d64db43d733fef1e59c3732f8af28f9d6671cdd2fc650ae2b97e7af5757e156a023bc66b1c4a15611b5a46fc61cf328739afe4d7218ac9f23212ed3f211cffd309ca155598469f6b12ac83f01e94ac60f8d1f9489015b1e8b7b5520b78fc382e0fe786999a0235752bd968364eae017c8b5b3d71d102425d1a8877ea2c1d1e79b05e293101c217c08bcf4f099c9f1924c454e0e04e575e66ea246a5a2009c369a78596923257e432f9045f1680dc07da16ce8bb5427b43037d1cb3e162e82f78410fff8c34130f3361ff52454ab858ee63dd5d821e0b8882891eb24384615fa949547fcd0fda48b5d80226015e170efb86765d9c357a808d68473720ca8e4984867d385578437133c0565cd3282683cceab27ed2bef9450e44c9d34328ce9e9cbc491b06d387bf453328c953264f0438fb385ff88c4d5526573fb27922e1c14f1640e2b791cf977aad06e38689df4ae9f04a0b4de4bf1e1a34b7b3571c6d316c097e733971c0d4c6deb3952533f2d6e2585eb4c075149eed113b641cb0fb863bc783f33f102e3796f61b34ec06ea39a11bf1e688a04a25e766cb9139ab529a8e1fbeb8ccad983499d25cfdb67e9cac025640707e39d30c9a1b3a7cde4c948e173dadc4a8037d1cba1a20301df0b2f1fd1f710f4f1eda3ba43ad58cf6eba80b597ecdc19875bdcda46d898b7c6ef11b36a5c19c03a88fc38a66accca92fe6fdb05d6763b55f2f142cff139876f8f6581e8b013bb4d038493de47c0b2e1d0222e4d50166244d1de80bf7cc19ea821046728e3d74af5fc46df1d63f7b7f17a0c813f6b82a780074dd6c9fd5f5fc238f186596e27ae310a3491fdfdb17519d976dd8a0d4e0edc51ac5e4bf9528778f7056466f7ee0a9711872fc12519409bc70c49e53b4aa44cc74e62466e235d963d4e70c69b65dbd16d40fac023748c30f927b2b818f79cb823f4da0d91654fbdbcfcfa2b930a0611c34ddf4cc39bf5847808b29ffcd7f178f5bdd131e942f30b31a1faf8933b846e8c3ecae37aa43271f7c02a07e0b294012da12fd18675effeb81907454d8fcc2cd5dc7d13c369aad7081f78348b19d7b0611f88e992b33ef63fecafb10e0729be5fbdefe5deda6a1fc8034a13b310ae332b16a9a95dfeca892ce3465cb8ea329a388822b1202ec9e5942b7020e26dda1e39cc3a9deb7148d3a76d0cfcde459dd4086dd89e7036565baac6641c921e1bdf1196f78684ae2adf829e3a34a8f5ebadaf50c8dba8652d6a1abe3b0b79fbc9df5d5e1fffdb4bc60aafa209dbd13ed403715e25f7a43f8f6c546e6c44054176541377a075cf0fa7c2ab852fb099cc78394450ebeae5fec80826ad0ba687ed1bca61caae700523f5bd6d8ad8236ba289031c72efd80bac8363180f1fb6c0637296d4d3b7411132b21fa0e4958db19007c543ae090ac515bfb78a551d75a90ae1348b1d4555154dc95a23b36110837663518cf5fa300c30ba731e69064bf54ba7175800b0f5fdb631e380732d1e2003a8d9153d7a166f0a8aba98763460210242dc4c787e676146eec0d0c2c3dfabca7ab04c032b145d7c20bc6b4769633d60a05d36bd7c8743c760a5598b1eedb652d6fd531ac60ed04fb496c7e893f0fadd309cf8b6e175a418508796378b3bf661543b4a1d736baafce69a2fbadf3b6652ef90068961256ace18307b7387c7e98cfde2fa945e9228baee7bdbd9a9e228140a93b78aef6e5139a3b95f420c51ee953254666ff35c3b083b6fabc8e9f0c09a67e6b96810ab343038b0bbb9ce6c2b6428437d43d77d55dc493493d11bc46def2231edcbf2ffa2c8181869da4535a4c5240fd23d1fb01ac31601c43f67a4ad28520e2dd7eca34e0ad56c7dd31e40f9b9b41f1c1d886e95bae6cd04abe00b1da37535b20fb67f23ebe07ea1a2fa26a099b976ded9a55588aaa14be74be69ac1f5ab098884b2dff789bc1e958fa7bf0170788951a5e308aec613ec38fb3a89ac7008feddf661caca70d45f821c3542b662eece0344c76e9c521b9ce4965f022a99c6fa43396ce838ce2882873ca786e751b0899326dd87d278a5844f0a52eead70db04c1419fd59976f55505674d49c9565efd870ee0bf7b284cfb7705a601f5e2f89c1d31a193d8ae9e03eeee768065608cb335d5425b870139c006671bba5fb035dad53e79f9d3c6ad553f146bef36de4152d352291f52f943532790943273ca2b8661b4c0dc66a60395e0f6c232cb0748ab8f89db990360bd4d28c6d6f54e3f61f11632781fdd99ddfc8e1941e43067b5d60561e0b9878de42ff686d296486ea84749a61249119feaa3b2d45b51ac6a4529fcb068c15d16bac09bcd338068a83bc8f56f3826d6aeea362c0308412500aaed92bec14b7e4bce6f14ef832c984c61371e3974dabb083c6ad06ce3d815f38d8c56f4bef5fab70bf7b7f7fcf11d59b6a09aa24f00409a3d2bc81518fef155d8fb07b2c68f585f79ddbf3f69be2fb26243200a1c80ebcf8e04d2603230dbf9aa18625b722003a65d64008fb6db73e051164ad688cdf5e1491531b65607945bda60c8e773f218b186be60a6d17b83abc059ea3fbf63d81943f3567ae71957a7eafedaeecdbe1e85ea2d4749198bf079901afaebe8b20ab99e43c7ae399497ac62ec18d0cacd200aa73833159f9e318d875159b06ed3c2458f558174b68b41807b21e0b866d9a7b1c966cca03edb384798da2b4106cd53da8082b23b2a399f19629b373f7246b9cfaee5df61a49f74f602d8f5f600f0c4fe5e0f6f02adf4311ac817d9289195a5556b373b9622cc62097cdd060c25c97e317f4fc6e16779eefa9485fc3fb6bc16d09c7553a0183d7ae5495244fc9533cf4fc99f881b8abe3e2af3e54287c3053bc85d3b7608260fb734a70851c224f05ab0aff4fb62adfc7ee3d9ed50ebb72cea3360e01eda373eb528c93387cc43294c242384b27648c63ea17fffad20d02bed1566a6dd930b2cfd948b6bd72dc13d03aeaa11238aa68f87790ff444ed703594ad674ca3011dc21aa41a5c115e7fa0ebf3d9465764b9564153432eb278966a04c9471963860008e67bb11254f7bc0b12d8a1e893afcee53c389177bc1af088bb53c626bd873a6f6bc22b4391624284b701d2dd3c5609bd9746c71c5cca7f0617b24be57ed54270d682849a5c8ab98141d387b1f26f040c14d70058066762b1d8184ce3c602a7b3b130e863df2b64218bc8e2174b0fedc58787107e744fd5e0f87cbc6f7b220b04f4f4117516e8a419bf02d6f0c901f37e087358946b2ae56054e7c8040ff35f28416b277c5dd990c785dfa6ee9c04e21882bc0710b2d008d07eb4a720865094f10c55bf30c1b7ebe2ee2fdabd8c72c2e54a7b047b9cfd28703c59e12464036bd98624353103e0cfd8d6bdea20b5e70bb1557b2d858a0a94629ab8ea482a919611a6fa8d6c5ee15d1a15af1764da7c7dfcd9498b874714f582bfbc8b61f3e34682eae1e7a2bde950becf5e19c75d87be933a53df47f0c3dafed91575bba3961fde11bf34a61d14f14eb18cd9a254ae4b1ce4edfd438390659e152db6cd2fa038edab5a2717261650c4fb645602eaddc77d206c5e68384b7dc3de1be87e08f663442b0ed0010613c1d1c78a3db8000ed1e180ce4b0d03e11c52f175788e1f2bcf621d2b33ce843d829e69118b3b199139d8ae3cbc2f7973523504add064aae387894f06d08a83f8bc4fa708f98b7cad0f1d715bb1b42e866b39a534753ee51f2a0905379c1f1644a0f34ddf605a3","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
