<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"55070b10cd8966be7ff5b2c2ad734b7aa694c8e6c3177974c001f283eb3f3120869de744e5efd9fc94b17060c63542872ccd5fb706c8fbf6b39b32f11915551cd0eca583df397eccf0cf3c0a230099fbbc2e1530840459f14d1faf585797ec7cd4557035b62c459a191916d1119b01e63491c7017ae46090875bfc32ab6bab37140e41a8b9ac2c6c62995cba5fa537a409b2ba5f8fd4509b679f841d5c307c701498aac7ca8399d2f09830bec9362a71820b0c5b6d4665574d643bac2d51a4e32bdeadaf7fabe1b9f23d58743b75928942ec5b220fc7855cb65096e2d374efcf3be120db05179c8903d96cc6e786cecf60ff3e4c1d65054802673998fd83ea05fc45323b16ec881dcbd2a76d7cdbfedbdd473d2a49cbf441fd78933c4a8d4652346d272ae60d004c5f1266adfc60bce6246fcb97b2b03d8fc5bbc0deb89428507651d736abc8ebc3bab1fa83d5310c5f54e4d89805d09fefff73c6780a18c6e3e869c99ef738e23acea4163edee4f576accd0e10782ecdedcb98643bfe53be78c43b57bf357f5b88019bc9ad9cae22188f50422ce6ee17478d8333d440e7df422e7386164971bf7d2a3d392449f572d8e3e5630d9e53905127fad532c5c761907af70ff4fa264e636d0eb9300d2596662a241a8914c6470947e35ef860ccc0d6f4ea70b3b2b54fd46dab1b6e2e6c76469024b8a2f0ced67c4c54c827cc95914633509e20719f95361697d4f4242f4220267bdcf8286f35c66d226b5ca1e02a033cb54c4d83cf0614398869f1cacf775c447cbd0ae64f6844f57421f1dd7e0b4d7a5c656d2f7b5703105254b9e8a627323d71929feb0d1705f5b97182b5a6eac5de3971f859e12988ecce457f9bf030fc8435dc96c51cbb1e94294d61bd8d88c51b8d7ec3b2bf4f673ddad10072f2da28121e0b4fa5faff2b044bda315f29067ed647a7289e9be34e17e96a6b96bf473295b1b66e0c9903b3904b510f9e1d3adc985cafb629327e3dc83580f278ecba7b7f31e1fe5c38d88285c2c4dd9544c3620661361d5b1a2615cf3bafff20307ba888b33ffb5623c2fb1383c65ff8629932a09d37c82eff0707a4bf9b26e51a7e248f50d6b6b122a249d0bc5711f3dead45e9108aa22b8a194738a14f74a41a3daa032c3afa48460763b11373e01ff1b7669a797a026bfa7779c1f0c283195c4c4f20e7a300b3acdc7d5528eadf157ba597be2021daf6b554a2e1a9376b1179d29699158922cbf34896c10565b523aaecc330d9b7c0e4c75f16b4f29f2649053b50af35e7fb40a7ff3860579126eb0ee698d52cf63d3c9d304753e14fcf302d0b2c1866652557e8d8a18bf9e0b44042355d2bbcb31d7f2cc77fa853f53e3aa4c77a5b6c711779f9afe1f5b5cf4aa69e681dad77ee7cfdcaab9c4899b048ae7890f03c9eb6b492119386896db0f0eea51627d17e584eca04cda6f69e2623753035ff87f985af9fc9ebc4ba568c29680f52b8d681e15c910654114a040423d13a805a7ecf424892ca99672c4677b0f70310bef68a76240da03a1c178781e2bbc790f49ff4cd35c1524c5400bb44c4caad77026ed4c168783eb9552e5dcab8e7c65f6b54d65f9aca7191a5caef9a2a83294578325c012dee04df14e0701371d6840b610b1f4efdd0254938a023089c7b6149f778de0b4ca1971fc662da64b95fdbe492928d9e979bab43977247a43a5bc0890f74618c63f26199d042b25b0445291107c11977931b9984d1a0099cc458619fd3d67feb7dbf2ec176ac58e1d4291f98e6d1075e7558cb865f7f409ce34b15ee848cd647990dd52032f89c9982c2220068ca949f8b52abf5a3c85d5d3a24d02c861b0bc2cb11d26a2446560d6ccef46265da8721781b734a9a523ad9dbaeee1013cc2f8d80d2502e5ef58b4b7c21cc2d78470599f37b077d5eb3df635ba744189fd08b4d0096f47e0b1612dddb611ad5144eab4d401aa521f37493d28788f02bb31907344effa4633900172212989b7120d684f2970d35ce7f610930026e46ae48320c27a9238c9995a1c51819bc8fbf9b5d676b8f7314d1982151da57ba368947ae78c40a0b40e2619962c51279e497038c88187fc6db9684a5c2ba7b3a0b1fc9a8a22ee5447a5e3a1ba5659b2098029baa25b75b0c4563479642ca404fa9cea392bc6d18e388287e18e3d122859ea2e329e6caea53f9b45607a0430edcec3402601d180e52f0fbf240624b313cf31fec248e38e5da375db156c718b628dfdb13eb1bdf3a541deeff60be29bafc48bed9da6581973f685686bb6943889946b0c44a0b25fdcd41270325af1e18323ad1ae59cd1443a5641e2798b7d825617a93a2bb5efaca46f59be6e88402b1c24a8e52e5e44ce1a6a797912d78ad114828183d68d82059990dc1cc07e79f8eda77e0a2cc28a1f7b400586aa8a9c36af06540f0225e11358f46c6edf64356d2ea5cba637f231de578db58de16b6705e147b4a6913438b129e18eb44d0ccea37ac40a8695c8a4190746fd6191066d7d85566fb031bb791bf1faf435f412345ebf796a65f146a1ea005267b7fbfd2734214126cbd6e8847d3128321e86db3b82d86279cf045c96b9d6da76fb65ec42c4b02409ce9e6504d5e006b15f64fd25143590c0aea022154b8dec533833c23e5e5818b87a2e94cbeba54038a10fed3018a9d52b96d4f0bb33d96086add4800bbd214f5dcfe0aef3c147416b887c828ad821a1c1503b35d16b227d3953e5808af606a0e6e582bcf29e1de01a9b4abd74d87519ef7dc382a927a6cb199d063de57b13e337fb55c7edcd8788c633812cb5b4a3de8d52e48ae94bf7b33bbb8f99683d692c6fd5a4fd1d43a8000025647c685826eb77ca48c1e96f8dac303e342747ec9191b9a93a04ebb56bb101653ac2ed5de4458dd5fb09d3f9cfe167a3a63ce1dc91a16182cd2d6eb6a59c966cb5291d4e59e8b480d1e5bf6a695f118cbf9d6844b1b4a0bca6d25d45d7c2b8a7402b7c9ed570fed444bc13c6c3a66fad8df8c645653dc11c1f238c0ad559cb000416e19abd7b9a27c3f793eb3d7e0a2c4877cb06341a3642c537ff0217cc72ff8379e9b2c38f6e79da8c4ac2f32f1ae529d19630f824dd8b948d9e0096a922dbb53cb2972a417c4c130c7013d2614b974b8d488257d6bee9f81e9e78bc2565ca54070620f7f5c97dd9d6df99d410de7dca8d6355c3823addbbaba529ddfe716d74fb1cff7c7a995612bdbf7963a19b921eb53e50c2ff60374f2505372c8770302af00b26e791670d1ff08c7bb707910b810c2ced90307535f8db6e820c2502f2b7210ff3b11cd21d03cbc1c824bd2ad5b9385600107d4779f310a00c0d0ae2550405ac149ef372d6f39575d98d8070e5b7aa8842e32403e679f583bbb9b469eac4fbdda1f534eb2d0651b8eb04bf2f157c9e1d52569b311ddc63db38ec5a9f2af68c08e7043f2ad2e634d9880a47dd35eba493f50acbc0ff69dc2aad4c4cfba3c75385212142369099e9f23fc5d9ec4cdce9eccd0a136caa6ad394e495a1874d24bbfa1f060fb3cc423103a952336563b3036b8688471b5450e9f2a95aa6970e653006b21e44237513cd4654c274e25622004a80da6c56b2cb7fa0d2d53101060a2a04546931a3a1c2742c1a10890769e63557fe97de0a15c248818106e53c69cb808f0f2c7f0cae3903470c858060e8ddfa0cef941b076ffae88217ac87312abf4100a36fc707a2783822060e836142f7e943a9b145aec45494b3217a8a784c4248a9a17d00e161bdcc77f6bc6fbfbc9b38cc225e1dbe1c6bc6a0aca2bcc75d74492fc3077d73c11166429addc998d54c2fbda499f5bf5b31a2fbaa27ba5db14d8bea285ee3667c7ad50f91f52fe8bcd49c78a561461e7da13185d83a83b0b84de75f5d97c4e5662ae21f96e4c119e4ad92c61203fe54566437f946e29bee746a336d4e039405afdab32c90f2fd962129393a814af72f4e5efda2aca5c44978ccb3672d7b80700a4dce3ea0a185591b759fd680c5a5fd500082b4a717b2ca74c387c118116e5842bca0fb69b4da0fd4ac2ca6d3efd25f614f1374a3f753fb89f64d5cad40bb3e2bb2e0d8643251a241f51a898352709e695161b26a9f40f652a47b383af7bd4d642f34e8c081f4bc4a8d8cbb5a9f8668e378fdf92c095d3bfe389ec877094f6efc49886cba459e727a1c55c0d54e3425c112fa27fb7a32bb7d0906fd6870d562ed96cf4dcbda63646c1c490b81b915132975fc7b847ccea04f6c4e20ad3abe3095a500eb60f31071a78e3a0f3bf23ed09abd0c5ef0529edb47c973d54467a064b0569f077ce5f3ec79d0faa3a7ee41e005769d7736912a25877ff623cdb97023f7c1b6fe7d5fb21f3f98d7ec0df1c6531d84a54cfa9465084181fb98300ca0da6b1a1b8d278232007549c88c2c1ad7750f6fc97819a06e95152159141a932f2417a0cbe5af9b93abf1e7b67d98764dd8c7e9d69161bc354e30f86dfba6d1c3e5d287a44cfaf332eb6eb749fd897d40d165ced127b6c29bfe5a539cb8257a7719b61093933f78ead3e1c0d3ef14037253e429270bef8f40fc9c1a7a7cb3bce7b892a3627345b1a4defba51830bedf436e14653d710454d51ad4dd1777631e1cb54dc3d5b15d4e8cd0006053303dee08c88480ac13a46da9608c6fa2523aeaac92051cfcf4108c255ddac4077efa551513baf68dcf764972fd35798f726fe57c9b8f252d70fb1872a4a83ffc86129823eeddc42ba798e8f4daf12f33a54fb675cf960f86350d770a7033bc9a10d77c9ca95032a64c5c2d1ee18ee134abb7809e1af2e65d29aa72cdcc5d1fac0f0a7613e51bc9e3600d9e41a43beb071a2b37a3de5ef3d07aff38d6dabb4182ef0c9b3e2289f44399721bd276fb2a71ee49df6ab0b864be6bda49514b2364b2c51dbde3271712ffed6794b1adb915e885eb8c9a3e21710d8b1acfcccf70febf26ac06d9eb0647dc9215897858dfb7b4a60129213cf15ab74aaeabb9ef3939860e892dc6c49b8015acb606d4edc53b6f6a2f1ebb149504a716b87748e360ac58eba19739e2df0e87c36029ca8065e65d8deef5a96e39fae943688e815dcbc51a075c0718f667d501d9f4b0e9c25990b2d49e3672223e5752055179222eeb2375d2aaa1982d2c48e66566c8d3d00ad5711a008d461a38c77c22e30c5290a921330d2b76858f4bd635bba8c4b92e9407b7476467472975ecbb522a451d4cb05b57f51ed6605be6302bb979fbce055843990e0a9f00efc5fed28ab9c820c561b2061739db7d6cccd928b29e58c67225dbda1aaadef88f26bb72d676a7c4097280e3983f4455936dac458381c29cdda1a2e27094baeb18a8f7ad7db44458114c2c73c03c941e0384d1d4adf98e8557c66f16e85ecba46325176944707061455be1eeaff2996e97013d881082c2270aac858b8d1b6b1a2a656288cd36542a2831b6641fd657db62f229380239860675392f03a07ab6f84ecec8f0e8860aafd916c08ce69c9834871773afd587dc5b3af837d3ce7c7ef2fcd0bfce2e2f1ddc891a0e3ce52742895347660ac6f49d095b8b87909c1cfec5d1c5ab89c0b202e65b907e87ccdde160d974f439531df5a06a95d02a25c3d940d96d081ce2430a52b93b96652ac9c01e22004fbfb8828b60c37e45a158a7ca7d13d0e491069893d3d043609c899dc2508eeb6d95dfb039f07154aa6a24666ba3f7f817fc4d943011854fd713d9fc8e6b0509b34424a7b0d0821bab0a6c28c3deba18064cba46864bd26c7078f12cea24dba2d1ef569259f7d4addf16457999c17af4ad4b43198ac82c32d7e03f1e24ae96d16cdb98c6632edcc1f5d8e1fa7bf3eedf7a41e3557d1ed85b302a67616b251b3dfeb600e48ad343284a4eab510c93572f31375ca1a65d9d408576a41cc70041c6b90b3beb66bc0d55f786cbf3a1bd5ce0dd4b8c30c8ebe9c00eb8c155c495e10aab9a37890c6240f6f5117d2a0ffe25efc728f42de117cf95abb77a0f56875d4fee88a8a6f384cfb1fc02e1681ccd864b39450caf600ab55586a52c082f3badcd7ace63374a3277906ba06e4b3e4c4cc6352383da00cd5d0a02b353c4e22f0b0dec872dc1a5ea66a28984a0350b85ec42ebc0fac95518fa52b8f8c5ada00202c80b0e944ac03244912fca984ea73d26f9cf54638d55b051daf3531413b55d351bf94ad6ee0a099b1efc5d4db0158173458b12de30f476c17c7d44eac68a5909e061075e558f6ea05befe2db1274dacf54f6125337b28d9f9e61310cb54ff9cbb004de1f6c2564dfe88f73bff450d69228c2c06a8efdf7365266bab2a6f5be1e7b506b4cc8bcf1f0c3835045d7d973f0ab780c689032e964ac7b9c9bed0c31dd1b7a3773e8b54b3305b6055b0edea839feb18a855e19f26482257786ad8d5bb2e65df714d6a27cd09c26aa8fe2b89972577ea2907a31862d2fbd8200f3966ec390536e4bb123f2e6fe2b7577eefdd2361e63ab5de956094580318a7238a25ae2b317f40858fc1f1f1945978e42b8a4a925554cb00b195ec7ce15391a3f988b2b7e3d01f106d3235918451e94d8451a99fc42e9a7cd3517b238215f17ebeebad9b7e4a219d5fc16c52b1465c3fb2c1b4f06f89bf1f3e270e46dcc79027bad60ca6e531e5d44a4dc75148c31d191446f7c2d7fce96c01c0d5bf1652af98d977b535f53daa55a0965d86b1c06af797a46a77cd8296efe877847411f62cdd1ea44bb8c8399e2e873c7fbb582c706463d0be2efcd0174ec6f2daab8e26e8b4d6e5e92e219644eb7f2f98391f9b6d21ca65f51e19df7a4470400135a5a20ad2b55481854b34b9fffbac1f276aac824405bf4fa397e766a10f869746ba70ab7b421f142bf691bc1d181dea6dc633ac05a3d08898a3472b2d6deb1dc5297aaeab1694e893c5b48119a4ac039291940a6d4b0c411e72a84e0fd4aa2d5adf50181f46a69e98d32ab557298fb54e3ef0e555e3841d78e504553f40e1c8a9a264ca97aaa7971504f02491d99779a8cf2e04271d245a804a2a9317ed48f28b2d2e1498dd50d95dda6c9ca8e73b2881a16f960717dec064c56ba7bffa086f8734158bbd12e0da990f14638d1253c83a1e595b7b23a90d707096b49cfbda0184722b3f8a23336c697c90652a8b49b8b8d4f39ea114294db6bb5b2d1ae6d8adc630a808968b7c3ae64fe6f289d183ea5ddd99c8e2a66807eb0eb502c2ed15466b83fc6b288c4cd79db91b02288bd7eec639b80bef582046c970479dd5e90864c64010f62987725b72314ca39a80f1d8391997eeb554c49027267cb8df5b1089ae978d56822e40b993a218f9032cd10c8d09ec5a16f1353fb2f5242a6d18ec906c916ad04b74d49e11a1d1b12cdd11ac01250835d91f3dc97f8edc08eec4a1ef82934022e3af6e87f9dde57c889ba9bdd8f46174c5b916a4790f06236df50736526e0e2eaa3ef04ba4ea41dcb7df55a6e14319e76d172ba612cdd50f0162f53c4f15d4891fe7175ced391f537ee97f997d5038132a9fc84d5c595d31d574f5ad4ae4911ca5334af6acba3ee385a1d5ca49d2f82ef3ee8373dd71d3e1cf0333b69b7037c9f492790155fadb6f02c8f2ac73ce2012b62bb94d55c2681344b0de4a8d6c8c3d00017f2b9208b7987c56c53937091dabd31b31b694d247f67ce275b577d1eb9cf6469df5f476c4de03186dda8e6de7a58fb9b82fc7e033d5578ec504f3e9a9ea2f0a1e7f988f2058fe72320e4e04de9db306b7db96d324b5fccdbe8ec9b32e9914466720ac83adb34ed131a19c2d6f03ed3ac904625d6aeba8084d5fe87ab702bf64470c67c0fb76db85d98461f4df90c7f2c7e7d7ee33ecc6420bd22ff93e1795775af402595a41b709c5bd0b0ce6c7aec7b753b17059ed57338fb81ccf49791ecf3724c75dc7b07c1ee1736e9cba8d72aaaaf521460405b2451f9e5d2f3d1e32f01f56963f053ff3b90aa9931c1fdf576debe0d9ac7c56e1718aa68a16f5d29f8999b1be2c05d6699aba61c1dc2f35ec1e6c2e1f0bf7be256c294a7eb551a0824e1392d824848bbde9722d585f0e02a8b6e764a9fba2fd7561021dca958a19846d40536418543a0e9a52fad2ee5680430dec06e000fbefc43b8fd6471aadd7067d320221a5e92375fe807b93735dd056f01ef31c341b63b316758ee00f84cfc3bb6501ba3b6771eee45bc31dac562e9d71486b51a568130f41ac6a9c53c843eecbaf32b8255336e54a54420ffbbeff38bf5562821ed9b98023f93f8ac061f8688935654bb99d82aaf85c435eebcf35cdda3c0b04623194d76efbbdfde66a4abeafac0d0ceec5c0e98736060f4f5fb03b3c3e76290aa84b359a452743b55fa9ddcfa70b463567da28f4173f36fdf105c08e33cf642cb32e76aa96abb1e06408fc20ac529f7a5a7065dc224f2a2a32ba0d4dadc3e55275054cc8aaeff1960a92847594213dd7e8492fc51fcae1bf4ec10d95620c9b9c9800c7e5d13695bc3c9a6eeec16f853b2fefc841229eebdb8127d0e2c4abe40db1c0df5119620574bda7adcfe1d9c4a0654910fe1c1c1034257e98febdbc836cd674b1e902403d9efc27620efc4b297f2ee8f1a1f7292256da9486f07818b26f1e439c7b028f5cbe49acfdf5ac421c646e6fa4b84bc97cff808ab801f5f16c10bcf665baaa8d84445edbf7b052b834eb363a4db0796e64a5bbcfd6d5b3017abefbf63ea06f03bfc712faaa60eccf8b2f1832d35a6aa4e662f9f6ea53354bc18dc57113921ade8b7457e0638382f39dde4a0dd1570a570889694d31528a0b209a9c5fd2fa142a41e3c835e44b9abadd649d9be22a8c8471b586af010a6b861422f8cb3fd38ad0a60c8094a20d3ea438ddb1b2af6f2e64fdc2aa1ef14db5f08b5701806fc41cebe27d3a8d737464977688ea54d615a08dfba5fe5a27270fff55d7863b3f80bc4065814f78d90be738f13948bf806cac1ac57c085b9e0dc074fcba42de01f5a388cb9f63399399766572e26d668905f0a5d4985571f2e1f915e4907156212e018ed4a8c4cd9b7637c2c959fbdc14ca4e262df6be8eee4764e255f5123db21ccb5f84ab0990dbb211ec0e040f6a6c8f239e5a9df3faf651ae4a1bf5aebca5c81aafb6d09d34f48b630d688974405474bacabe59741fd73af754b53908a86d1f1ce6401d503aff8a613c1cce2c5f76d96e6c168c1dade5bcd4de5bd3a49826ec82ce02c58080d8111c27f11bd7e39ac3f553ffaee656b08e93a4782e5f357972f598e4edea7cf7620e387cc4fe9dc484fd3e94ab3db45c6a8a969ed2a58932287b76bdefe706ac2f48336cec18a0f799b3f5730003fe38286de9bdb6796486b83afe6fdf36cf3f1973fbd07389a18b56478bd1eba91f0bb766a899d4ba2ac8ed62b6c72e7a5df14cb87b579aedf7a02169fd155f03555e21b6c1a85bac5b7801c670dc0e10dfa31b0f323de12e90e4ebf6e2dd5ee150a06b6c373c7421864b0a70cbf2ebe47790c8b09ce00c4fed115eea57c00a241ad471513b93bf30a9bfb0ca34ce04a8b730a42d9584c6b50f347aca0a4da199da86feaeff0afdee3e68009e069d1836da86c6d3fbb7313e359065ff7a6725674248dc9e6edb11619232b3f7cc756c9f6bd03ff1adee5e38dad0dc8baac69dda0b00ce9d9e58cbd94a3ea9494cd9f3c7ff4913e4ad1203caff7408606665daebb69d9798b19f659c908d27738720b8610e837a7e887571af744f0a923a0e226052e5dfcf52263b2d04ebd12b3f2cd40fc77ad2ec2699cbd755670820389c938cdc7533b7fecc9c6e8eff4b9cefb5be79f8df2580f0aee402f0019ebfcb66fd69a6129f9c89785a8ef0aca038272530709cea74b399512196ee77c1d4b5c6771ca9480c36df8a2ce139e0046534b57f217136a766e7fddff2d62ee4558c7c9aaec789a819a4990d91218754c1a003bae3f2db9b1786077b952e414cf000116f3692d3e7dcc149c4f9ee8d9e5f8c84b04adbfcbad069bc6180e6df2aaa328f6ec57f84429228f1f7ef149cfe3f5f60bb2aeb0c13ea1682ca6fd13269fde0d15814c0c516fab8768adbe88b3dbdbe5f85e8571c740cba31b21f80158616200bde86302d2b2d5a27eddce820f7ac3287bc1b0494cf16704a214b261c97d81327aa94f18f62755e5ceac0fe4aceb7716db33a26ca46a96f221397e050bd4f042a4fc8ac2e60487a36e5255c2163c7ed92c16c8398eee9448cd2e1139cd41f8bc5e96bc689a1bd0daab915a613016719ce9ae3890911f597827c65a645d4d6102f014ab3ae5bdae9ee87abb94786c49f05313738f62f1d214bc352f6582fe0ee4b32c692905850915a24445ffcc561f23dd668d299b97ce3e56fc6ed51580645d85d9a2669bc0f3f22f795bae0e25f3d8810cd9f14db6a46b794bf9f647f69f6cd355de361c6f53665fb5ffc7cbda53ba967916fac36d1e3d66dd2592397b004892b2d3963a53446d44cda79bff313cc70017692138b466fe7ff3e48b4d003faaf85619b8eb6b983f30f65cafe7767f1fff1cd9822d51bf7e756c01ba676b07797aa251260d3be465f3b64be88218278be1e290240d948cd3294e8539e7db0bcd5401746135101c0a95136ec23906f8e113eb82cc8b905f15b63289b95195f9cbc4b6406b89e16e28bc0aad061148da1613572afdc3bceba3287d1c2cf32b625082f2133ae624faa65d2b4638b34b68b2733edc99ae10c920707c901dacc3c927ae2ddef1bbd8f689ddba311a7ffba4e7410ceb9e3c36d19673b443427a8ee251c6eb7a9189b91e140964bd6caad2e9a892df6eceb912f6d126f1f06918c51a162e9f33661981c1b3b6fddcc110713e8763bca750868f2b03b578ac533ff53d4ead6af12af3b9d5a018666f514caba649b46eea9cad85181dd512c25f69f3a112fee1f810d8460ad4c83123afd3496a58c2764d580e1c827c31ed106ee6a07c36edc6b8596d188225d10424a24fd88a295a44f1e70284324c0d1c609684c6796b8b244a030ab5979ee5c48ada9de66ffbd75ec0d61ee7ddefdb5db30b86eea92688ba03186e9bdc5b9029ce46ec563534823c2e3f5653fb907f30deb20482ae0cfb5e51c7d252f51198b47c5b95e2b48776cc6f854c866c77e15e345ee98337e315db72523e65255c20a30607e2e613802c9b01ab89578e743163069db2b4bd4b4bee07be75fd6db314b0c3428d23f361e5f0958eaaa745476e42ef38009a7027d5978bf2436343812313ca32b2c8d16996a72c375a02520b19f605ac1d4a44df378c9a052a9fab5f9f5dc31371e47f59acd6af7a44fca6fb5b3ea3f53db130a7a878aa58790a6c8ef59bf24cb292cf0baef878a08518e98bd6a09713f52a1c7a67090f8d9fdaf019aafe8eba833ac2ebf9d00f3db56a780ee3584ff21934fc912632434cf2f09695d32ade42a02abb3e302741fa73b49895ca24f39242fe7e885feee0cae06461808718e025711d2fb702344db67726277db66ac9d69efdc4a73f50dda4e072eeb6756dc3bacce3909ddeec326d44aead49bd5f7f1d2ecda1061576953b5a5c1373f477de6e567b2fdcd0dc2410c889f8ba92f90c0609322004db554c1ffc0238a21a4e6bc144ee47e60a386efc945253ae761f723b899d144307135e88248efbbff970344161e7fdb2909b85653f557e06a76b67c30c9e7d8573d1a939e646b2b3b30333e098497f6981bffd6cd25d300e7a644356de5802868d93739cd2152ed3f6139fa1be81b84e31371d289f383f213e05931b98b08be2d96bf7f7510ec3cc7ae57bd529d2566193980a1e7a58e0e45fe73b823548d709176de0c162a8d12aa952dfb741e4b218ff8228b4e974cfb1124d525736873cd900fb3276ab27d07bafe0f2c7794df988234f6775ba701c45dc11ce77afe0d176fc46752121c7cc55c18c08428f956e8ed8fbc8ec6a3a86e83c33467d8b0733af13b3572d734ba968ed3f69be89ee9ab98ec4fe1000200f024564c1d05b1d305060abfb4f1ec18cbc1b39b431e1e3e8b4b2d516c04d2c09a3d5b6eac25270dc3909ebb18595dc7d2f7273ece2642d784f2389eb7eb075b81214de3744de49bb7dbe0598e8c61c252dd75a1aa96e02fdc75e5b2b881ba2cb6bbd369d94d16499021a6ce7069c4ff889d0dea2e1b7147407b397dd88c110c85ff81f45e219318d6a47758eca6ecb1a9e236e0850695c692f3934543da8c305249cb700dfb5d9fb83fce45b7bed09157c84d74a29c1259f962536a0e45ca68f62b4aebcac2f9ff309b127560e00af02ce5971f4d734556989a04110f7dd881557030370b5d2a6438e42ddac3905337e7418e8c9055b635a6007ceaeb8001763a526716797152b92685bdc6f92fe2ad4f077a68e8932fd6b299c1587dec46fc9f292156a13c65cb4289e672d1043d9f51bcbf24855c92cca55f92b1d551f64906c7d91891f84849ffd2bddd40cc600d61f5d0e2fbfdd477f75fb4a1a3ac03986820f64cf76f7fa3b806323e8ffef2d97cf28b1da79dfdaff4a68ec1eae570df12bbb63dcd529b50f0f524fc7f61a2cc9e39a74f5651d5db0302b6156a6a49cdce53182af3b0badf23b1669339641d042af61c75fb320ea3f574f2e5c4c933b94ec4ce1803b82bcacb3f35ed02cc93877a014a57958e248395338eb986cf6a5ef1a0bf0069bf8479d39ea3119f0a7a0960f1c749826b484ae931b19efad9a41ab21bd0646915ae8a355d2f914417d65cfacba08e4a442a4775431a7bfac766207ac66af39317ef27430f432a5a5a65ab14ee19e863574e11fe431576ac4c4e1d941d6d92673817bf613282f9a5c849c13a1467882712abf38baaaf933c692c8c90e0791bbd7cdda0458dd1db1b259f21d91fdb3d59fa4ac3e2041f934952599c6046d1db9c74e66ef01d428974859e225a4e238c1a777df6b205d6acdfcef3ef81f3e88cdbe38024a9f556ef641c4e3bec1126160b3e757d7ac9986f98aba964cbd5766982ca23488110cdf25fa21df9a9c2610569948c4ba073db959e35e3164f618f6cb9f6354ed3ebfa1c4c643499245175d655bf5aac210c36d7a494d396627c279dc6c0057f1ccfa4583806e15d7fc721ff1218c0819a3ae81413e4e08068d2151d4482d4d6d95be4024ca568dacd4d6e9f2488d1c6bb1a6d53dff69c2eff36ff25c082fa379871f96bb10f8a3b63251c64342ca0395cea1e9350f1e4dce9b4a2e3d0716a99213999eb35307962d58fe6a992b5bde0f76eddcfb369819e3bd180c1d6a3760215386791a32b0599acda13239bc2eba0bdbf2f66b6d17a0f0616675db7ba8569defb8b79992acfd15195bd2657044ed8b886f7cb38a275cb6448d91150a4937a54a30dc12edbbbde630827b8ccf75fa73f0dfd4081167607a25d06c0b342f7972379d07513faa0a356627e962fa2c762cecb6d5b1489df2ac17c56dc7e93fe301ce034fb0c9dd3cd08fee2a3f54d3d3d587ebc06739c2df723c83fb670a65efd4f00c4dd474f820d5caa9acf2efb4046d8846e41d30b0ccb95a41c85873200922f6f4a577e85eb15c61716b4dd86dadedaf8fc4f87c20ba02ffdb34b9efe04016d782a8ccb6edcc075c7d21db9ecaedc38c2c6741573ec6760eb8a869618f81fbb0478e2ef5824f2bbcc6674413d1fe930d7a2aeabfe9d6581cd4bfbe1ec162f5445a7d48cc4ce2b195da1e562664c6831d769baa6b0bfd4af2978993baaf680ef13131015e3f993074a1b2c1969729e34653317b0b887cfe98df3cc58f006432d8ac191d3f63bd36b0ce8c262066c3b2863dac84263b8ea78b66c4bbbb5c7b69b14c4a7a8a7d0a3c889d3d0cc78a4ae26ee6612ebcb91082e97673275f7031b99c802288c688baf37b1c9af07f6061c92629030b7adeda09e1378c2fdb4af77d3db884be20f86bb9cd948ea8b5b68b9c055d2c9f4be477c4701c35dfa23667b38cbe2943356f66e04e1ed76334a01e265b781a163e04031a81d119e13204a717d06aea8e374f3c56763ac044d84901f387ba8b8820eb38b6d7907dc3cb7ff3f3ad22aab7c3e55f9641adefd3ab362522229d0af924666b09cee80d2253223f4ca859b32930e08d37a1eaab5414adce5f6fbce7988e0ee1a46bb6693731d1c440999b8880265ce907672b2e52663e1daa79d147173a66b2b5f7afdd25a50ca1407132d1a9734b00f58b3b6f4dd0e634ae949cf56d7ecb49c29fa1134b5c7556e81d5511eef186c617ada62c4b6e1f8b5f70ee89de158aae8304912c81dfb3eb1f625815439aad55b0ed9ca8480a8668d8832c6aa37eb9d554a6d04597ecc9bba5ee595405e5ca7e30d24bc569c9ec0784390da7a3eec7c294f6a0f2d2ab159f754a32d3b88b79c3949998053f54eceb2501e0903f02052b92ec55947039bac069640e6134f9c7895e3b0901a098394e1c7de73582b0ced65ebb384e537ae445ac9f4d7c75015b0f843706c971444e433cead64de36740915d78038534a05e2d92b60d4eeaf98ab47bf7c7e6d4fe301c397cacbefe4130e7f3bd83b6bd0edbd403bdce488dd4d3a945370f9ed61516480bddc77124fcd9c04b083b8928b9a32154a554be4075de38cad5ad7ba82d0ea078237247121307df738337a1d0ee5db996f6bd3354120371fb2fedd3995e180bae28f810c3f9372291bd4fd1d746219ab0d435f527d80ec0cfcec1780c944be6529ab8ea7a17218a860822f1c16151b0ec94f389d92c2ba3be1758de4458a6ad4fdb8ae75bf5207838f7952486f96c10eb57e9c3624ebdc299947f425d93a48f25b9efe3f02c56dc4f6f2537f37e4c8b33d605b7d5befa846cd007a1a7da53878abf231c6b1bd710a87ccdec7d23c629eaf57f6e3389efdc2342e01eeeae64765feaef30b49d66cbb59c499f3d3cc94f3314ce103e808c49e029bac60c8211876be4c8686ca15448fa566ee915a1deda3db981aa8299f60dde95a226be257e864e2a20c75259aa664524f9727843d8fb386ef34f2a9db747bec02cf9f7ec3f35613af6a5345a61467b3a79353e5fdbad6c9a997c4a314794b968eebdddd65c69d062a9622ac2f8b03ab1eb2e111f4f81b618ae185b085eba4217b4188b7c6748e50bc3f8b288ebb6f823cd0ee6391d79cf68e3cd4e162c4eece16fae07934ce2fe637fd62befc3f09530d36fd659abb074b2ece8361d20a9701f730bca92a4f34cb1896c6420c24504426deaf8c71f4f27f5e61d44574031186e9cbf7afb32898545459fc38052b829252e47897f6cd2746e952287c5c34ea8053ecf46f792fcd1c5c2b3b879ba64050635b7035b4d67d3a37fc74da658f12b441cf05472326348b00e33d4c325041b1a04b7edb465148d01f5829ddd18c2c192faadfa0db3c8be591b2cef4f14b827bdbc2f6b0c15c6c5b2449155b756711a18f79273258d3556e129e51bbbebaffbae76b02079d335fa2620de9c00701bc135931132e039c45d3f1b6ee8a85a8699796bfa43302b3cde49055c42fca20b1a11fa6a59006fb95914e706659d7d2c5aaf362078908f1b46922d7545b0ebc401b2baa30ff86ba44f424994dcd73f47dcce501c500e24f64f5912538bd4707540f8910d2e63148d8b3c6be6d5ce9f022e9b18132e16a76eeb9c3917ae51c42a8d8e64b39ff7cfe74227d8d1f6726793106e4d8068dd5f0bd13c39828b6c75f6e0ae81c5ec071d6d11d3078a1a260d64fef29b0f63f3dca159c8dcc0cee955eacd5d32370fd774c8af9f04052a8a9a27fc061ac2fc3686f249f5c28c374b42b3a39ab38d874eb7877f23c57fe69369d302d77f6cad80c036465c486eb379d54686b925423b98e81faad05c0f5779361366334a7e3359dda9caab07c36595bda7ab4f6ff8cd753d7efb06c4a9d0d33e2ce4ca685cd81e284977bf73069ec9aa7843a59787513be320fd96fe56f5674f64edc6bdcfce01ab1e45114f16381901e421ca2b19e370cb0b2fc8e66fc97eb08821af99c7400b322234742817f1e288a9bf82f66d7a22089661af50cdb55bb1d9591fd76b4f53bfe1fdbe9b4961568aa3ba3b5babf0024c1f452623c0289732f613726b3bfcebd90828b3b7e58b9bad6a97cc099851654deacd5dd54e2223388787dc7d926bcf7a4026163127e9639c96a6e0944a40598a5224cae9d9af2674397204d6525a3ded80826e9eb597643e8590a1e7e817546233d3a558da5cc6604d9dc6e971a528b2580aaf858a73a9d7bcbfd80caead7e9ca5897e7c98351f4d56fcaa1e2633ea7f119c6bb8c62da5aac93d42fe01713e1dbc1725d99a9104fd9a00bbefd1de20deaf0ef88e820ef1a82c133d643fc907a964253e2a794d1f19118de55adf4deb5dfae9dab80e247e5e9a57d474a8355950563acb186408b25cafdf5d759929072e422ccaa9801d304e7b3fb2c8a41bb8897cbaf1304c8858c334eb44f68480077a766c991f53697cce6496f29c1660c0e36810d2ad33a9913aee55a34034bacacddfa8441ff2fb42800b7a300e768bca897e4b4a9517079017549994699abed0396b5dadbec3c2f6d5c4f48bcdee7bf08f1071aa0591a9a2190b27b9af8a0d4c92b54a5ef104c6cee6838c35611e6179c361c592e900e1f80211e9f12f9192840e937e27f69ce5b3a27700e12856ebbd58074500626298df6d9603b4625a56b5ae406330c659b8acdbb309a70bb3d02c430cfc354d08e4048efc3e12c8124b61f88ad7d0dede7b14309ae8227a21b5dd8fd810b45b5e8b26cc9a7c1d8f0f46256c195a88ca512e4b89600e7b4aa710b3f3681c7476356bdcb0e2d80d524beb9b79c943b2bc2e21950d9a769c5dcbe3f932d2a7c35d282f20a1e326a1c156bcd21c7dadb899309541a45acada9bdc7d228a66cff9387e8535e82fed076c8325a18c615b9390e596591345106ba2d2a123a67e22524c188bc063f3ee97f1b266bace3ee27a3c848fb1327a8f81cec86ec7dd6d8debab3fe727d658ed78260738a940b748ef49a9be56471bc4f33b4f2152f3751a632943600ad1045861aeae16ec735d463088b3962f215ef1e26caaa1531793f8274564053fbcdc6a5c41e4c63d69cb1d62f12c5989a113da25a42f875910913c3afde638192e3ef609b082243c73dd29a23468bda1bd287c0b2e1951f56da8e733621c6bb8189b4992861b27d1f0271a08bdf64738a9d81b6a9c621424cea46e66b5d7ea9708963f64a4cacd3549eeff6632fe0c1879c5428922b740070db682ab554faac41333065b419c2bd8f4de3941720dfeeb6ac5957e1724131ce60627b42a44bb80342834a5bad4f562b9807ad2d364807fb7212a654b0a5d94ce627fe94c86d1fc503856701cc41ea403ea7b0e0a3c1bdde4f8f85fb1cb62efccb2d34532aea7f9146a1184cf3ae80404e04ed8eda2400a8e55c08da8c9a358b02934fe54e08f20708328ee9232a0741c54eb661b271abae18f304775586aac89e62504b5524c8a90b609d181f936ffd662fe5e49b92b48201db3dda96b4cffda7fca1c10e435aaa3f644b5f8fe4f6222165b1073635dbd3cda98a3fd2f9d325382a13c49454a25f72e8bd04a31f91a7e0651c14b0bc9b7a2f33f8800d38514880feaed63e22708dc9d8f051a6990e85927e84179069ad5695b5cce038a89f616ad28c9cc37f74ebf7b608a453e28d7d593f0f13d2362f5c16108a4c75435f5907eb088e7dd5abdeaaf92ee0bb9233f5e7f2de8aae3381001cbf6feb2c580bcd13596524510dc89b8e3b962f4303e8a683e8db3002f12534f36f7961df0a25a0887109c455cf4c5ce4f3cc3db880118493a57b39e84f70dc025eafe8792810d13ec68cdc0565d7449ff21f251325234b65095a6e5eb7ff472b53ff8145b7e247af9f1813e8685a3d37f24d8abacd71fd8b6fc37f2df10dd15e50fc1bb74ae7e0dae8822c0ce4dc4204ffe77fb374a3a781fcc77e1facb23f9429d3e79b625ab8d185cb174aeb335a08d3ba5115b3ac9e6601fa7f12293e94c7571b3882f930c81d9e538edd2f6d9aa18103b49a43c7346bd3798dbd913d5eff477747b7b75866226bf7bfa97a9a060f66e47e31a8e30158b184ed39288fcae3b4fed05824bec96ddd72edbe1902490c35270b33ed847bf54bbf3906965983fd19515032d971033a0c1571d860f883fece8a48e313d25e8fa3d981f792161d1fc818b574159835dd0bc4cfdd0c6cb7db0c0078ee19b62995e14eb539bec048dde906a2122f6ae57bfe7aa279836ee24cb9455956527220c321698721063f271b66faa832a6232172732e42b93c061156d9e1b2ad6414d64d65e07771f424ce00778ebde4cffcbb8b6df24c752fe55e037cb60c933eb39567977c59d0379562fb228816197a58e8d92b9893d8466824734d7b230ac529d509a9cdf5be1ab691026a969e1e3183b055217c717a649c1d30eb739a64b607a1e69dc28819cd79134e8633fcdce8566338707f44c38c6fc57c590aae2175bde4c5bf1a94d9ad2de261ae53bfa987338a9f803db7a3b467af8f359e312d8cc4eac453e2c81b141a903ea4020ac2253f87ad997af7118ccb2464c25e3802cc9fe8ea613bf49f4bfbf168b8707254690af56f36581ca85134e3ac6c093530bd7a1ba86142116ff75714491bc7bbb8138b3b521f223822b63b5099a7e4b31f1f57c0f5cc814b08a39700c9780c9a48ac34803fcc1c7fc9a4f1d9c08a97312fdabe12aa305bc3bdb12d4ba04b724830af2fb98f386ced67693fc2c022e84b3654492eebe087786a1c9e024cb22afcd947910f7bbbf984f29657caa3cacd31262f638407ef9a6d603a599ab55bedb831fae3a88099a665a1b4f221e431b09f39","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
