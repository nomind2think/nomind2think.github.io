<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52e2fc3357fad1d8ea66de6b7cf9e93282f32bbed0f915681dd186be3cc6d53555a72b1e0ef1525800f87e1c43065381ab9699d973a845a4821d2e097d208e63327bbe42c97f2fc6ac72c64b4ce3a35b3dc17fb18fb4190fdc14f7698373362342e97395337854f8da73294c08e83c042f32ed95cefeb24c26570e65d2437299cde9fed9b3bbe2939701604e4246ede79fd46f55faf39b570ea00fd0be4d96ab0fd8349953a4f1e1a66232b3a585d7aef545e7b1cd5196176cb1e3720b7b7347e5e1364dcdec25f566386287d6c0864fe9c6d49e27b1dc2dac445d5a693ebe6213a6b3a2bed86418299e6fb50a6f8f462bf14daf66f1a167eabb83acf753a24a74afa8204941dd96ef2c7f55712eb87e8acfc234e403529db13d255b823cf237d3ccae089eb8caf71829d673cdc279703628dfcbc9e7dded53177774df8c4c09b4a3615e39e10d84f99574ea30a43b657e77f28e0146b5e2199b5ce8a76961007677889f7da58a33dc47ced15dcfc58e9efa7fe2d6dd5f40783fd1635e32c68daf32ea162656628757e0d48a9f9297f6c9f3fbfdca2b97db8ebbe878c537a6aa5df359603c2c3f7473a47d44279db7a0ad59185ca52da898ad2d38ead4e544cd3b0a4a7a70191ed658e5d40e3e97c31dd4b8515c79f4742653b4551f2d4fad6b8ed1425fd167d6bf8e363821c2cff0b486116a85e5de15462e63f47ef01323c29f00eef6224a458df2a0cd1bb3dac4287f321c2d272c6da4e1e1a28833c1a88957808fe825ba066b2fd8ad6a690338bb5c03afd750156b61666f6dae0366b84e8deb1613a13573d970016e306f5cff65bdcf877726f319ab2ae2d9736a65ce2402ffd2dbeb19921fe89c610e195d4fa7791a3d689e7c3d534b036ee0e7cf17827a91f66e335d96e2b2051bb518e157d858f7b8e8b9cd40329b1382b837e45c738ce1665fce09d563b3c883d465f830b54406c5215f85c001e59581712ca04448ae687f3b9babefb797e8eb509472cec45c9c131ffdd27bfe08b0b7dae8dff42561264b12a6eade0bd860103d6ab28281ad1d3d3faa7921ec4e2e85aa06c5d2cd166281057a3ad73b2e78926cd763a1fbf8049378927c8ec85e5998d70c97592b528a3814525512ae3a726ea0734a3a9d0244a99e73d310b3020233250cf5ea01734d237f6af872957e51bc5fece6f6723935800775399baa8950a5edd928eefc0490fcd3a9799cefb191b385d128e9d1b9b18b9260639ca0f2457001e7563c39384f7fa6631389038fa6942df3a9555c718b3b11821865a96fb3efd2bd703652a476c4eb9e72ff2f7c07e27836ff94ebe4f9d79f00eaa7ad059209b4875de408acd37db9168caf2a2d55fe9a6bc64897be47d93d139f14e0194c4dc7f04b0fe64d3df8ba47042b794bc064e9ef6dd852bed239174490c3e76257e42ed794bbd22d11ecba4aa4f455c16e5fc8e648bac224ff1ba3efb9603cf8c30b60a1ef8329f2d790451000d69da8eb3fdf2fb958bcd7b8c5eec81ef0a76dc3e7e40b1baaacbb500921d0148dcb0cb8a79da19a8d6126f0ab72018d64475fb4845e68f44c705272a93a34a8af7dcbf028c46a753b4f45212faca2c081ef2a5c8e9ee26a27ec99396aac62770be7f818b86241ba0dd3488a7586600e80fe1cab99905068f193fb1929ab6457558975268895f9fe204c282557abe166fa99052653b897f72fdfd61112f02cf12e89671673cb2a63d1a6532f6b2871c8e412fb5a09e0bf98db84e3c6d8fe3aa01e31a4bb7a5b8382d5a611b8e1c095c81a9582106547c10f1e7591200fa816362daaf477d2732570840637bcdf218eba8e95ba78973eb6561149411dfd3279f855743bef64c7832d678f3c367ea89351ffe9cd35b0ef39ff2ff4fddedefa614680811092c578f0b85fe4901480736a87affa7cd50ceb848cc00b1778d74537505e4aedda7f22715d35fc699a2441c58f78ece6658f6f8b0f3f5a8db46db6b5bc561c72fb898a43e1398bf684c4b373872b268428a996bcc083df03d046a50dd7ad0cb6f7377b7e971f80d17e9f25fcc9bb35678084ecf0636e43267df45f45a1feb37d0394e4df2b04877ba485a0b9659d714707bb94da26182bcf07870b85523b951822361730f2eee12edece8853c9c5e9e4dc31bf7c7169d6bc23fdced73a7656a7362d89255d4a55f7c6dcd9e09baea24ce7b36408b9ce766a6d27faa5aa3e567e1df213389b59bfd007877e9331ea77be8cfe5ee2f15e31ec3cf3323358417c82fbf1e152de79bdd5a8ccf83aa1d139640ad429e2373834b340ede1b45ca7ca3cafea82a6ee7a821d0ce764634fc417befa3dfecd9dc89d75234a5057d438d6b048fff58b07d9407ec4c5d2968c58a2b212257f1d95ce2088f7b689c3d1dda416003992d6be8bd099008d3d6df3b121f8b647ec1da2e105a6bd2994cfecfa3d33f6d5065e306b6722523681b1aeaf8c0479e045ba2caaa790f5f6a457c980ea811b4f420f086629c8bcc4f8d479ae1c10b417a628cc6f583e3020a5d154d56d6abdedea7e139a5f34bd5507fbd477a021b74e67de97f96930b0c69d56981ea185adf1fb0e4edac354d58a57b60bc7ce14fd225e55ffe71117560fb0615d9a8968dd5efeea27025109a63fe4a755724cae10ad8e450b12b9ab675d1ff15188ccb7315e40094c4c3795e81b9116556b84567f9e7bc61319b08d115b5bdb3dcbbca28275a0054baf0e58a5458d26394e076439df2337fa4c932fcf31ffa57c545475315fb556b43bbfa3e80742d07d73b62598603671c6fa060bd916c7cf5fffd300887bdaf7d2871762cec28d4cd85565f4faac42e6dbc6aa5d9444f454ba5efb79c86aa5dd09111a3163f09dc992c84167563b04c2dc72b2c2bb993ce74bc8c27ad1b9efe4ff4e0304edab85cbc71a29a0f829babdb5b3b1db9199cf451bef3f464704d4995b77e7dafc542b2d82ed5f41bb4ec19e6485d5046354b2048b3a90d7f8976a1cf469a6d046794ae7a6b06b830c158cc77271aaed7f190a28e43690e45f6f22a8b7afaf8acde0632f33f0f79d890afd370897c7fc75916485a6bcb86e5a0dd1470ff2cc5167502cd6a6f85f50a9c87f926dad9baee36eb56830fd427ae51ce9e128cf8792740e888c29b49ac2fe53d439bcb241db0497606265839490c77db09d657da8cdd0c1ef95981c85058cd41995de9810f21f4eebaa20f1118d4e10e75b1e1b780afc2127b5334399df7ef0a443cfba8291435c7412a329dd0d3fc3646ed2d3b51b170ebaabfd9c7ad85e07438842b9fe2249cc318bcdd0d15ac84b89837921633b6e694313f074fbfe5152e2212ae9d20e879c68ce790399edcf1db35e4b27253c35cbc099e8b1aa9740b88d4cbc0cb55fd737682be64e820738d866cc39c16880ba95f328efd66b6ea0cecccab22d6be31eb9ad3a390e555b97aa7d3b6db7a82c91485584e63d7ca0c34a9b82f913ee48a46112cfb75687b6dcf09aba1e77c519622296f9b5a8bac78f26406ecda3b279bbf9e919841de0b62b585874431d0f34a669d1045e42cf38298c2b194cea54ab8da5de1cbf4b5112f977efc686d952bab35aa48ebd11d4e6ca3d3d55694c49dc1643ebccc67b4234d0076a29ee12183eab03af48ef9b7b6fc39be0b75c921a92553d7490e4f4c4e49ad89d06e59694f63c5d858d504ba59a8adc807058d64df0f0b32220e854f89ea7b4a847fff39369218eb1b34432d3786ef6dec137db5254906e2c6f66d6ef2c84d53ffbd3f365682859f986327946d590d642e64b1cd14013d76e84aa4cb588c1d1f89a3178e3b0239ae048607fbfb8df93d618f58d9b8910e14be5c397f7283185b19380a6b71da54a7b554a9e961effa3a40c11bf947728477cccb49694bdbaa308bdc4676e42c3649515e843b5e9b6024b2e1a4d23b361448da57c7f16e4121c6821d66b3c4408d05ed93ba617a13b7bc76af212d1b585e1cfdf13d258466340e49a4e603bcde2e7d885d176192533ae9b601fe9f0137f15790427f50d58d85a1eb607313d3af2c46eeb033b08e6ba146961795de22ea0bfa4df16b10759c890f98d99d3d895938f1f3802fb04e9a0995790b20603614a18aafde895074503fcf450bc6471ae8893aa8b21f2dd9a36dfb7b37565a703298c32d0a25be1898a6f1ab26592e50839a2482c94b6554caeb3c4559d2b3ac267ed79b1c0de56627a19681d61138a38f5e6c2774fcf84d50b539c92ead8982022637b7af7aa79e607fdfaa6c6a15adb8f88161bb943a6a783bd39089a1c8947f34feb0dbda505ef85698a7073fd5b62f9ba285603253c741713bd3da408e64dbfcb206096a5e4bf89862489d29c460bd2bd55209ef1620646e2ddbf372a9c6570d6cfd0863c6abdd01d8ee529b2bccae7178b0314309106e20d3018b7db49c45264d0e3434e1f8fe3a48eabf5ea54f0ac8bc179946e60179687dae6d6f2427975984ea5aafe8ed4b7965939d762b025c891f7263de810a62f7a6431db16e2fb7d736d1ce9c53e700e3c057511353061610ac98970e1425202472ceadb8589919ed7186cb017e929fcaaf40a178720bf88cc1bb7213905ac1410002100fa22167966c15d60dbb184259225797eadcf9b0f22d72c4768768492ee01df340906db3256c78698469c9a6e87c498639871409e517a211baf33cafce7174e13aa8b8d244fff035d497e44bcd8dd96ceede6a4e3d7632c824ad9e948aff59da65eb10d7aa2dece849001d47c93e6819d56c0db41dad57d5ce550c4b4a74ee9e8c841a8115b2b3d6f589097442a060f5f5b0dd4fa90817ec3ee116ba3b6a289400b0240f121ebe01966078ce4b79c00a637c7dbccbdb2b5ac32875986317cec36cf7fa1939a01ec8d183a4c93a3ebbd31e96436db8f0d8dac3bca2483756bdefa5a208c29aeb07c7c778eca7fec0efce978149cc2b88c44a027aa923fa1f66bb27d3f8a1f1f4529610390fa6238db15ced883eed226e4add04cccea806bfc1e3c7c2ee40f682add05e4af53a7ad4956c5688c69c042c3e9d5b5efe3d3cc47bb29c7aa7f82d55b2da6abb7eceb44696bc16112ca75b962ee5882d5c736643a584623fbce57b32cedccab21ec1b67daf88b7738cdc8b0c16bf2227f75c5ec57ae8720dbb5d13be112c0f23b93cd153724edbe1c85b1adbc78395b3caed4b26cc37a478aed25bf30935f6583ad117e5498ea82a3ccdf52fc02ec8da08164112c02e7538e7a49a244657653123ebccb28db35f0c78acc4739ba1f9b551d99eedc22a73538c95ebb9f2979380c894dbc5a88162843c99a4d6fb015e94d7ec022202a8dbbeaf6839c28cedea8905183c8b60d748913da4fab4b08bd275723c0a332ffa1838bac3bf92acc412db098aa106815c745ac6447880d6d4e8ee76371c2e72af3fd6a500a8b7c925530ab92e9c04f504a11bb5066630ccb208cd1bee835f6b9bacb8b82af2f4665b7bdad19454b0d3bfaa5a984c6af6f5d22013ea2c02dbcafec8afa845395623452bbd3e372dbc06a161a9de3944e544cb5c3bc77a209d07c0e228af4b88726df25820b890e605e966cf7a2beea32f981c7c23f77a725bc018c6ffc9855d41dacbadf74b99dc42cbc08f879fdeb6cb9538224b66518e01bdb866144680b1efed749e9da88c33761fb799bc46348c8dcb0c8b486359abdc1d031270868165426acde8133370e8d470a7ca6cc4c7116b986c8321fbe58ee1b262d0784feda7e93169d1d93cf2194075e4ec522fc2c4abd9e841bd5df6799e23ccaf52480f18303d1c11437abdd86d2fc70357d01da5c79c1470416d787283fc110d50e85f3f7789e6920095eff32a73f5b5387aa5f17f33ce90128b01e3db6bc2026335509befc7b5cfc6289a2a0f543f97950220263e8a1de48b49248d04d0d2b513a500d18d4a1a61805e64144ce0078537ec481ccd199e9bbea09fb640d75d7ae8af441731f4173e92c52c7b6cb584c253440962e3d935bf941f00a95ef43c6157bcdfe2218f037e0f7622dec3d571b253bace5a1cdb02152cdb6648253ee679ab8a3ce100cc5367cddb9cf94781eb6926adc05a13b0cf474e126aa7c7418e4c30a081d5f23c7fa0f6e412097e04b6791d12ff2a644ee061b8700795093a48157881bbce101460789b3184f059437440b703df6a8bcd1a25a932aab33a963cb3935495fb6e138c775d2650828c6372bd1d7ba0052d5bb0ce525d56b40e9c8287612062e166a95dd77423413478d67a30d0b359de43886ca484dc758bf273bade1307d11cda1bfb97e0899c43ed7a4dc0b51074cb7a92a60f8c95123cd98c34af2a6188f23cd5b54a70e02e37de8115a31ee50fa6aa40c1cecc4d99358b80f541b66896a7626ad37f9164cf661f6558a71ba18ebe9fae74f7a2558742dd1c8ba01fc7e222c069e0224358d3a9ac307e020a23da1f5b4a6782438f8e33a4552647bbfcc3c756c6597c3bdb723f4c2339102f1b6bceeb6bd11038f1d8ba2a9113dad73c5115780ecc782e48222e99dff60dfb21f184c725f5fd33813683390177ad3c2d9f92ad975e0834759d9fae3dc780c93e50320bde36c00e8522f138199769c8ae5efa372b5a1a602c4a402f72f5f6eab79f667d393b0c68985d9ac4e021b0d4705d2c5389f3b711c648f0cadd898970ab15eb1865a9ba3c5bd84d09632216e577822336ec3d9c4e95fccc718d8e7e7cb69b00733d7d46303b64e76d7b8d60b62de588cd4a95d0fcce263d4e764fd0be42ac76ad846b9e2842ef8f93ce1dc995e51652382314625bc05bd3bdad4af2f6bdacb64bcf97df0370eceef9e251a5387d99f0886ab71d3a27db5cb951d00539426f5038b756985dcf200a7257f345be57638fe77fb2d8b4b6041f93585eb0de868f05d87b7ce4e9c572dfefea70d1d6fbda786d6a596b3af9042d9d5f0b93a6b0e2706fb45e413b14af35043cbd3ad2d2f014b374d436168aea48a22f70a7c294c4556d38747faf25f11b09e1ca97b443d36253996a7cf22fe973c88f1dfdc9f1f62101faf900014d27764a6dd4783a522f25a7f4ab4e65f041cef315f799862a874a43a3dc501f190938973d5c5afaa85952c458f8c88b221d2e7dd1f0a6fbac726309ddbdcd84ca5509782f56d5a77dbac1070eb512c7c5983bf7d1d33c361a90ba69ca8566464ba936ece01b84992e144ded15b793e4059fd1d82f847bac13dc4a88d3d50e6596ae5c49b591a46f3f7e305ffa2e0011c732c40b0588fe8020617bf1259d16d2f1ff632545684d637c8242157fc9558c20b33b80e986d990fcafd3f5af3069ef44cd3b47547d9e046a357c77890bc91a6d88630a6c6a1bb47945f06058ea1b186f7ee1d15d2d9200f189bb66bf95b3112184e5180bda94a5748e21b1876f3bcf4850ce9859e805d663ad9604da5539ca691f4714b6828f5f6bd5b848ec4b0dd01c32046af9190df9572dee0a9c77aa245a004f133014ace36ac826992eb0846d2eeb667dc5efe3aad932afbb060169654fd3295c468def2e15d33c8911a1285e0ccf7c7f5723e2b78495aafd0d7ca00c038d3f4550a57d32d2bd825550000bb2ccd3081d1b816c77a2ecfbb2b5b11174d256683bbe1110ba8649a6fd30433fcbd31c33aacd8ad8478621305080781ee006c23754f1dc151b455eff8c235ad60feeedd1c88767428fa24544f13b09a009af26cbdf2d8f59ff25d6c03a0e920b6e02ab673d8e75bd2fbab1cff4c973a937c8d35f2b164d48b56243715e3b1441ab5ab812196a74c61aab7bb44fbc6794f1861abc73d650d0a6985cf847691ca12546a6e5ce44d26567ab982eef23606d9f86981f3606fcc11848d27844cd564211d7a8b3bc8c387204665778f3ce1f636792b695f89a911935e6b209dbbed12061210da2e12d9b98ad2221754eee82cd3f30ca8692bd464f76a6fef6f6d74ade20388a8210c099f9345a36220f3273a2f322157440013ddd99c93d36a85dd647b65dcab3facdf12ef45e87a2dceef20ef3f47c2a258baaf36ca91f9126ef56a4abecc314e5b9e22d21d9effb9af60716aa802c913b5505126d0bee0e1cd4d3512ad333773006a2a704df5ed7f82c639596b91b07332543b2681177d2ae76c43555a946f74e3d1f619f004ea6895a476090cc98d6efca7f7410c5ac7688a000d69eaddc67a0f35a960fd7b7744fcc95e4d2e80d79a438ed2e59cb1c47e49e161b3153bc126c5e9c1ede456af7e9a02411ea5d38933b0be449f5699baf85a833a8add3ac85e817a355307dec176418961544d4c97e3e52919212e6c896e95ed0a63882e6e628c9a0568694c6d59fd70aae338c995738b8fd217a1f55df335a0ceb39b67b7c434862103fc186012372cd93b3945afdb429701d57edd44668b346592b3b38ee358c8462681bfdd6db0ba19237c3540b9099db3cb1cd847e3b75ae6d82cc473f455c49bdb393c02a29b59e16daff50d377f05bbd02bbb9807b76be5a3e661963fb0f6dc0f691909eb6aa1da45bf0c9c31aaf349b96a8857ca35ebb43bd492395f29e7dd65f302b995312297d160961bdc389be18bb00c9415919c362d5e9ba7b363e4782266754a76654e7b59a1c59452050a58a8ba3f91729795bec81f9610d8ab890d6d6fd99014196f6230eccc4476fd3addbdbef9842b78f2019a9c37945886d726492249edf14d1d73d539b35686525fd96d6d2887038d73ffd7718e8d1f2fd9eb5d2e04628d161fc1b5c96b0705281b7b436700d69c52ac440d307988e7d74bf9e66408a02644a076191f1d80f925c057b6fe636b60a73b216bb1eb97bfe73289af61a55a664e249cc296a8e8227945b53b9023e3bb74cbbc70c761bedba67939c70baee8aadac76cfe528136a444384956633c9db052dd9c3ad30deb65a298f849ce5e0d0949e82745fbeacec2cf3194b2542689cc4f3ebd52a58b945792d760f583856587823d7928777dd3609dc8d652b69c986a3b89d1c8de6850f0aad3a0ac667261266bea83e18e2d3b412fb4f0f3e80de923ce49955662f86eaaa4d01b1111c4e1341d317099b48e83549d087741ce7f9424916c9a4a6f16686379f67931b118a7d7c1146ab1d9b73724bec58169cbca4383aa1ae12c49e5d8e964ffe1e1c804c9cf7cf946eb8f442a53d977f7a9e73f3df2697e19e34e0bb384ffcd40764940e4b15640572551683bac3b8a34c9e48059553beff5d1709b6b5735cf2589a1fa04fdfb6cec52b4423a0b35b5f3189e8066cb2c5d2f328d538ea9331e84a2085c9f12ef0eb9c9cde158c7de6ea7c33b2b08271e595ac8dc79b44e1f564a5c07db0eda94b0921e3a18db8ecac85d77d07f073e477ce18bb0d445e0227af4cce5f06a18d01369d3a5af5c54e56ca757179ac64a6782af5b8addc8fd4395fb99fb8e755c363338de7fe9989f06180dec568ea189ebe638fdeb6f35e7c63aa869451f890f62c70e9c77c99fb86a89d23cdf45a041bc3b03ced43e470db0c3f754591c2ba1ce98a9b3db0f28e5d82c927df0aaf33b0c051f670780d82e4b2daa4a26bcf244cc2689ca1e9eebb84823fb8f0ca8a14b12e6d070a6edabf6e714ff54a8621b7f01622384ec2f56c6f889455e54118edf68f57552755bfeaba6b59f19f0486207ed0df5cdf568e2e313abb47273f7bf94779b1e589de63b34bbef131abbd35ffcdd0946814344c8dfe091a7c040e063e711724214aeb3c732cec5baf53fabd899cbc4525a875c77e60df7903b6182d47d43e7f09b0bf6c6d3f65cb0a7c3b91fc1352815ab1139afa50ddf80a7eac39e3f26532756e94943c4211fd2732473962cd9afb5492f1df584e14070cdc360b97838887f0804cef3dd6ad78cd16a1af3fb4d7b270bdd2eea3cc459b7c519facc6371a76909b41a863b3c61400f0ca4ab37d3512653acde0a06bd1c5e9f02bd6beb57955d250406a19256c121deda6d68e6a3b0d839c26e45d73a26146f3a75492e8e89f5edebbdf4aa0fc13cee75cd495c67c06e93d53e4bb8b5014c706059cecd1db389aa2b7a48e94684737135a4e9b41568639ade1db3209ffea84b457dbdf48cf89309548334ae879eb2dd68fbbcaf3bf8d9e913f1bcbc4b54a70b2cbb22bc97f102abc1b282ffdfc08995012e3fee3c7bb9dd69b12aa55ec9eece4d684c3f0e1c683d49b765faf4037b72132603517a2cd95a6a8e1087ad3e44d925820996aaba2f986a26aa123103dab9e0f1751bac999c2b3bff1f22a642eb3fa8e7560c642dcb6a8fa04cee0b80931f14d6a744341f1921a8814779a76aee0283b23531ff772976bb432bb5832f862c31587bc18876702247ecf4d9f281f6ae65409171daf42e1ff1e1e43d1984783554418af28841df9f1fdcded865d2441b06d4b6b1a4aaf1eeb974614a95a7b7cf90aeae27ef6395b12bbb92f24a8301c9dce848c644b890dcf9f969730987b09aa1de4d975f1d2d10e6d21fe02670eb2763b3d89c61d4702b8fd0a44a49c937bad0accf3a11abdcaa69461e4726006262c67c9a144ab0fc58e54083ac68fdeed6346712bef14745155f21c2d770ba2b6bce295f7b8868f88eca8f029b1a5eace203e292b56a1fcea77d1e25dff1ddb7b57d49ba11ac6742a0b45bb770f41a56e364d108053763f00a99e80637fd56eae87ac2170cf5dd80038a763d02e0b324e1f95e52e78be554bf2a5c0d07ada5226ab331937d0d63a3ee260401c010d150853dfaa028ac67f9dff04bef42ace0382016b3fd64ff37428b96eeaa490a47e37882f415ea8698bec5da471776b8dde588c4c544e2f1f20bf549aae4420d34495050a3c6943de6691d1ff26137061542c9c5f92ea90ccd0d8fad84905591db9f4fd650e5d75910d9308729bffafff15ba9f2e4174068a10f6e25ed46c3251f377fc3318283f3768276b753c07b9763c435c1d18b76e2e61081dccb950fdbdc0b56b66aeba4a5e0ed6277ac866b02d264c724646d7e8cdb479ceb007935e1efc1275a335e759a8030a30c394a04826f2a0f5c0f97fe926d6024c6e21623b1b15fc8c4ff9990fd28456055fcb21f11143fb1ae6de963b229c6fe7096170f573a188b66a62f6d0e4af2ea79a8e35270a9ba0c563b1bdc43a2a83120530f2dde7e53e2e05c593cbe0ffcba6818b605fff52548e6a2613c7ecf0148c45323c85415c6bfc0f5213bb43147f4d68d5a2186537b44ff315da4bd15d95e99f96002f873bfb7c26881ddd34433cba9a65b98e185b79efe92b4b001d7241b05a623176f1bf573930188212e5101a525996177bae4484e7eae0c012d62f878baf9526282f6493830be9fe74bdde95f2f2036df59d3e2b3a69ed07473c363304865b2d31f5e597d2886462e77d1ef09a1cb5d2ef87458702695b5646d60e96035ab5515cad08b3caa0b372f5453f3d1a410ce783607d97566b5e4cebf333d9ee1d0af6e2c601d3c32101e1d96f6a5975d36b96c26f21ddf3cbccbd052dbb54d6cf1568744657245479264bd6166a9d2997f40a1d53b5ebff5b455860a36252b1a9fe071ea71c46f57dd6e211b35d2964304466ca7e44164fc59441418683d905c5884697f31988b136b9cbfbe8b50b2ea2dc6b98cddddd765af23a00f3b1747a8a1c1a51ebf654b06762ce334568e6b3d87800742de4114312173b88a2654c60dfc83a783080dcdefee02529463d5e4ffa4c3b5ba843fe6e4a079a23f002f41f457aff227947016c21369d000dc3e9f0fded3769ad14e015a3005c0a6340449489930ef6e4f7bcb5c9b1b071970c44158ce382da40a48af7a91cc2c47ec6ce9a32612cf8957550074c8942dd7d06f89a8a9c2e181cc720e86e61e0d8a7f96a94cea6aa1c258bc2aa3c3884ab0735b90b16945e75878efd750c14cde314bff7583ee446c7a7e673c92ee4092ba150f1971417a0bbf3d4228e24443387aa780e14a06d8cefefc97f4194e0299706f506f98b604523da3a6a4fa52034b0aa176afc1e6d6c79490732497e0e120fcad0cc4b68f0ac82041bc10e19114265fe1e17beb680d0658446d5fcc6a69f9cca2cea2fa68a3442071433393334638bf9166f040779b12d03d27b8cab2f771c20b72e9adc91d1157dbba44d6655c91abf64680ed6cd66bda9831329dca984d7ae9178a37083214f1d7319b8a6c1ca0cf6538dbfd7999c859ebe5ecd4787d44afc1b2c887eb8ec8559e259d51dcc2e85be9b017402fb14b78ab71f1f4198fdb008ee0407c8b9e4b8bebcb7701890e03e55d5fd78422a7f154e1664f5dc5ed72e3399f2bd9175dacb4dcbbac5a5051571914374c5c25acff4cf0192bf28ee908897440c7dfb04696322787ba457fd2283c4449ca3e26ec2545668ed1f7fdce5d39f575695ae70a82811741644e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
