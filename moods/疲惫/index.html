<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69017b2be6fa635a791c3d14e6e93a8e8b3ec2bd19f34279ea3e3e4ce325abeb7bc0e885443b136920df3b15de3359b0c998ccf2c3fe608bac35357e83d0e0f0cf99fd60b8e23e4dfcf7d07b81dd0e2d2cd2cc18e6d8129fe933b4038a4f5c063c037ea219f076b0cb1b488c30918e365e1ff96787a8e510627ac3d032f4d60bbb8bae86d524a1fef880859a662129e1a81ff0dd90612258728cf27e62c336656e7975ea4fb2e746b21a0091a1aed67fa9ec0b56ebef5c97ed3d68ff1f769ea0414f5eedd7c6b63b15710a670d55ad26680ca176aba50e8383526d40cf6952ab0838b2e99759a932be987e7aeb4b66fef5d699f865ec97deec24fde6fbc3604ef7b70740495845db03be786919a3ceb68053fb0cd438c901c3abddf98487f63dfaf506dd0ff1ef91d1467b99b0018218522417200a20c01c8ecd3175e8c0769f8824ac6ecfb6b52edb4ec6a7dff8da577ec36a281e68460dc0dd2bdc21e8e5f7da864ab7206483e420c031f919212c080e880ea060424250332f86304c7a7f9ed7b6d564cd8fc26201d0426a6c27fec2b04ab6c3576ce04ab22f3aacbfa0e78478d1f615a9a168796a9b6ee88f05955b650f2e1eae59a6bc10aa4a84bb4825f8daa562d8a5ff8831733916ae15e22c02e3900339169d1083630ed878f48d786fa960605f4468c9ac1515a120c2c47dee2032a213012d4ca2494e07dd821ed8f6d734713987fc4460039693a7f65b984b5abf2ee9f58f34a0b302b8666967de0d30b250f75c7ef078c3b910122a9452e04c014db4cd3e0acd50018f1e2961efe930288df2ee72596b06e900f3c82dba5d4db1a6cee1f37cd64a71ca4f5d245f6069a6992c692a05b864248890d5120c9371f4e0244229a5025c696205238974dde35beeb7f93e5198e94a7c0cb3db736aa2340fcae0dfc1f9576381c826fa1194f643f0bc779575704939a4b9caf70bfa47e9d01b8b866a7342678d3e8b5e642c08d5cc9da41c9e0bfb8d83e853036cbc6dfb8e75a4e6624aa084085569496e50d09527d07b27ebd762c1d1ba1b4b12f2b46339bf3411b601c041c57277c056e1743a814da2302aadbf7bceb6e15e01b26f5ae63b07c423852a1a9cd0639ccd47f1299432d14ebea895f26634e8017295cdab6d0adc4f3343c1e1f316d1f40c0d6e816d095e7a7dee450209d7c2cb5ae084787741b08312a5facdc5b3dfd67da0b4dca6cfed4db7066f63436440fe1b4aa643b0f1e234d2cb17d4ec26a9363436cb2d9ecb5a83d9237bc233f1fd04faff634d5f79590f3a0a9d073c3d2e28ee638662ec8904d3f136da8e68dbfe807938f54cee433c2457ef9ab0ac1e027f0747919188aa3fd0821322a182fd5f917615640bbb9b269ff51be6737fe9def175cf542089f013d1022599123f6528f86cab622d3c1a6b451c4d801f3ca605a98069d24efc96bf2ca62c0e8d04c8341eed88af42e137133df7187c2ddb766484be670b1cd76f5e0f5e8f50fa4b5a006c5cfaa769c68d15e1ebdd5f76999e7fc38d5032634348f9eb2369ebed51d657153f8a6b44aa3b6c1111605abe6edcbbdb9b846181ccbee912199eeda5a50e254cea259bef1534378070361ccebe7c268e25286055732b5b1795adbfa5a1a49baad745c2452d994adff745eff701cb4edc5895c2fb12a2d9fba44a29f259dd5bdfe2156808c3a2c9b2ee27ed997440fe1569847960b6242dabddc7bce387c72c82b24e27927633af229e069ab4773c40252c02c7c1d5c736b13d761840eb778a10458318c2ad71a75d6988b38a33e931359001dd794847c6ff5008e6d1722b810343818309a5fdd729d325a9cffc4968f2f90fefaf5c9a5d9223ea601c9157a28b400ab0fb328f740cc30a82461eef48c98606cfad8e1a0ef15700d99ce74ef6a740972a8567335a1c6f96a4b7f66152264649f12b53c9af90492706b07ca96074966955bf80649444e3a0efe0a0536a08c5075f05e75aec6c31e7a6b53c6313980f2e3805ae00b82e1db3cdfd55f109801b64ec6ab52c86a871842575c3ceeb5d94204fa14c3b61074ec8b474a591950ce20a1a4fbe3e163515bab0df6ff21a914c0c09c0da04d0e1059fc2c214cfb50726ec8a2f1ad5251d25040d5d0384df8330ab1274fd0bde82e0cb2cbafae7f5aba2db74054f42f7f6162da032df9e30ac7dea924bf719c9bf709ea7047d72d291e97712fd4247854a1130cea4ab8f09b40986b42ebed0f71cd8bdfae4a1e82d199f86b54f940672e411e35d7324f52706602f60a87196e254c4b06ae4e6f8c08dc8251a3976598bde6b235ba911bc83b6c8a552d4fb422148797a19c5ac2f28a929588627147b0db380ae5e5cdf5642676975b2bc00a9d2181148c8380cbe6725ef7f69f2946a1f26674e3103fe7c94ca0449612326d2489244ddd232994fae8259bb78bb4bbcd6004590678be60bae644b1f80869642c83cf5250a7e64413d2256f71fc86edaf1ced33168947add604c57d8c1c7d33847f5fc2373b5bbdf5dd788548fbe40c95d67d712117f8957391825ba47dc9c11434b36bb1be2198316d67d4cdf38cbe62a190bf518bf2e869d56d32cf19169215c4925ba2e9ddf9f392d1d82929191ff4693366d76a26c06771823ad540bac1bc5f8f177aa9eb0d0f15962430d6b23ab71509571e6c137a1e06309b33df391564c4cf40c21654d1df7d09b5dfcf559975d340d2b813a72f4573d8aee0251d139057e26328ecf959ecb1de59b65b9ec2e1ae1cdd73b6ab9278f68daefd25b00ef9181f5d0e07541a54c1ef11452b19a0a599ea34248f278fee31b28b45b9ebff97ff7b9c3ca009d07ce0b46c2c5aaa73052c7beeb41cfb41f49828faafb0fe6ecb659ee39e010138f8304241ba3a55663c1ee3758e6eee544db5bb577d5f349e642982692f06faf5089523e45e01e94430bae0290fcc959698cd836195933d690d0d4b4710c2c32b71419d1b70f19e38fb354eb8527bb57256088c5e7acd633112dedfd4c2810c9893d1a0eea891f84fe30347bff10f19b61e2f6654cdfb030435fdc7e3d7262b104a0c6f45c688a1188755aa427e8340b19f48256aaebd963b2ef02d82a7dfb14153e8624d126ca9cfd2188c3cd711d2d021779786d79e627bc10e7381d41e9baff34c72fce47a3dc96a9fad80a0eb91cb0e49f17d549979fe309b5f3757c2be9b714311e299872f1ffd8d3a5e518db7b995e49804c500e3f561615fc493eefcbf24b46d14d1a5e2ac32f2514af195f30942ad81e9dceeaa873830694b01c8d08cf885379765a1ae5e25de658a922f322fd239c72ee2c7df9b52a37ae11ba29a22adeca459e801d58dd274bde5a6c243a076f39cd1ee4edbd17028874a754ea2110f054c468ddb6bdead917f016fbd327c53d1237adaaf50f528777b0017f6ef77be538ab41b9d51694b12ae5627189981f4ee36c5d35fded3bb3e9a2ee27275d6dbadeadf85b632edc5c1cb45c65fe11a802f458e63ed00f49da9497bff70f9bfc5683307886d90b7aa7f8b5318f346bb86ac6432565c62c8f6f3b2f1d5619ff7de8cb7d21dc771686d004a798fa3071609763128dead0a92ebc4809cccfd5676008c8a63c0ab61f7ce914d1c5267a4ead6bca15d8b0d9cc54d57dc9f60b7ab6eddc6202bce98af9c1eab7f564319cf611cfe750216e16741c763daf439e0529c2160789781c3dbd4850870b9a4c1d09110210f7dd819631e6475c535c126a3e1075c3aed7479fea6d9ee2c6386ab9aa921a04969304912e2a43b76d81f3faa0e5afff0b888b2a3f34eb21a427008e7c4e9887a27fc25ea407ac08af2c11c28cf349cff5a1eba5f8ccde334e7d4e9d7a264ac7873dc90ad424dfad0d8a45b4a2c307c188d9cd61f166589401f97efb3f3d105324fa2b21bca55214ee837e02a6d2b04762816b541cf791d605f9bec8e442f7aaea726e1359e6dfb20ea110360cd0924581ecdcbf22e4c309e79c802d66e7bfb44c6687cde8b4818099b48a40320ef8fd549a9ea9f174f687b39b93a6ec891c31a4285548a8c96062c7331f947501c5a8b731c79c034cd97a1a43383bd78ea0a06c33fa2f0c93e792a29630f297bca0a6fc520152fb81039d815027cbba079dc82fc50d4454034f7158c8093f76bf204257aa9482c6c7d885469048a9503079515039fde702293b4e48eefcdeef028e6a76e48395a58501ea9fa73080d38e6f6c65fcdcfc8e6a1b0625059d9cd6c3f2395a4525b890c6ba6e54ee0c09632cd93a62576ae5d2d884b204a7d6d7f50d66d16d2e72df4c8aab12a084911e5d2e3b045ce32625aca29255e993352cf05814fb38279bc56aa2c7c6a708a6322fc1e86e13d68f9c70b5964cba889f7453a156382eab85c7f65d00cbdac5622cb310a5c59d80fab4e07506f1ac799168aad8c61b0d1df7fc3a08af3a463b48b8ce2b9fd65c37f3aaa6bcf64f7ada3224256dcaeaa572977fa38d2ef8133f689d664eece4ce5c98145c3047a1083d2729510ee81993aa5489ae53f256df1a2fa4ab7f071b48a761fb4f6f691ce808d690c6718822fc22e9d2f5d9130b64ac378134f924e205beadad4637433c4d40de15a9d62b48c4f1302a1fb5d4f39aed4fcc85fda072b4aee976a26a0558d305be2c6af9be98ce2765265af4bfdbf3ed89d578e14f27fcef7c6e7906b4a011586b66daba415be598e6095c9e9aa705b633da92e959f49c2d33cecdcdafa3430dd48c44e28735f2f6386598cc6b08ac3797bedc47853cc62bd8f61a88d94153c52922520b83ca4bc08d56c401bc5b3209a921890e215259d1ccfb68aaa87d308df2366f30d24054a68695285392dd04bf67b4f77dad9eac6aac3a443479d49cbea8883220294889b3cdc58013902265b3837ea1c0530daac658e2ff798d2e8b9cf75726c2c00e86c9c0c0cc537d3dc41b8d74ff56520a65631b9902682a2896751a575f7957fd1830775d3ed2b2d92202304ce6be1ed25b89131fb5aaea54daae1bacbc4f38dc5af18cec6cd6b90d85d91f6649bf24ce023e8b49626cb38c24e009bde4bf634036af10fdc582cb389121638aa2265ed3a37190d432ed4164013c0c83489da5db8c82dc5a44cc8f8ee7ec1d002c44e5e22a3fbabf2e7f536145a7591be1e4b5f2b0d448e1b963b7cd567475ed25b789b7c90b34e51df8170946e62d298f25699b0dfc8f6282e68f916c7e37e0c8c97c61be1cdcb5c2a4c0725a7b5bb0a60cebc616f08b5f5166829d2133cb335faf1ab6464ea1859fe7281b6898f47ff1c40cc7b16c3f97065b00581d8e6ae949401022d08b9dc604791055ee5021f12c5bdb7a90f3df69fb3ecd11b35a22b31c04183de8c604925dd529761f35973b3444c6a58bee25af4ea7db6e5b222b4f46a1b8cb358ec2ba9c7a4b44f057c1dae14cdb9215049f5930cbecaea5a5e0a8ba00f7bea7d815356db1efda3e6b01fad4766c4168cc48dc7e9de6ddc1f6321768aaf99d2304e0d0bcb3dc3c5260d5995bdfbd3fcf451fa510dbb1378cabd8025179ffad36150e7861b856218e0eef7b54b8ba460690a01fd0452ea7678cf9e62737ee3e69ca4b561aace167e6decc110564a8f98c22e5b3d24027b0a6372b18a71f667fd40a81afbea441b83f3d94bd80e72e06bb90beb7ef9781132ec5e9883d9d91af6b3cc4a0419c9bbe66e60864b98c0c8630107b31b701ad97ae1a184ce8a27f65ac04da7c3643a06b4514b3d5ad16ded1ca99e80dd93dc8091cb8af3e01223dd297205e6022d8c3aae15287fc298ddc1ca8095005cab9d171744fbf67f6b54d4639a76404023b8d82b82d7461606b8cc8f0b9583aaa2fc94c29adf55c7de1613d472a3b31df04d92bca428a6d7d4ffd07cbe0d082b5b870597f7fb78f35e3a398ef5c42aa357753e35ed68737dd31bb5150ca13d0cf2977546f979b3c53c94e0fd48c9cd7cc284855ebef1abf16359339fbcd5a952e85c6f8fb4e37d0d391b7c59ab8a2f8aaa55b5abeb2c7260eba89ffcb0c80bb8aeebca51b75b59483d8d172151b1ab8e2a08be4ae9ab36b2467dd760737d77b16449b0c93aec20fafe65076a9f36a2abfb9c0363a07d9eafda903a7c5af554ba43cff8458a0916934e19cc345e39e64b47efbe2b150dc32614e564f0258130e5beda162f84dd1ba2b9a0a1956d61226ababb4d256e84bd12fa984be0740c51b538ae6ba522a3edccbd69630df94b8d4767bb6e9a95d233f2230013550ea25c44cc183754edcdb7a4bcf8449907aef43645ec2d389501455bac862ccaab8027e8ab9e0266a6190e40fac697676095388884f717f290d28a60fb2c64f5ed7b3b55a88a4aa9342d96eb6c2827607be7814ac01cb4876c4d44c05ef8641db1cfeed8ab85a0b703750407c78a7e68e4309e5e8d6d3722ad370be56bbd8d9b3fcab6989414cbd9bc26cbc4cb0a6eab4608dbf84d0fba9dc4e6f9ed91d96892f8bc999055f66a68a35d9517bf90529254617eb44148f595f74a97389c3114f74211ab94fe88be2565197aa6b1109d63c02da6ad21f237f96ad2bb916f56b0cb2401fba8f7bed8176de11670954c0a17133be4851b2f3ef1129e8cdf9c0dc2a43ea03e2de40437f443b03ba414cc52251dc5f541963ac427ffcae9a66c9f8d371f6aff7948e777fe02df7b9ac999f902869a89b0d2360229b57fe3caa1831090d713a5625ffa969aba3556d99b3b69d7951b48a6531b72b383952375597e67663444ccbaa6f5cb712c3c6b5847c7ed3f5fbf966c238fd6be27013c2a3b74a93e4cc8dc868f652ccf9b4f65b9c9c26390ababb23e4b04c03dfc970499ca798ee77e5f8fccacd3fdf639628cf2eb38be23a0d92f3422ca81c78e3ad08c0730b9696012851bb7046d78db9fdd6712e66113bad98d1e890038e266aeb8dbf85cc78caf0c12b8df24fc50dd773726c039ecae843ceef00d869fe9bcfdf1edf3bcf3c5a037105789c51da9a2ef81fceab629a12654d40579166916adebc53e29187efdebdb33d89e7bffa1edba336d873610898907f556686b6134eb559b76ae76ad661ec8c11c9e7f8db2ac0e9f2abfb7b7a2eebc2bc0bc9ca8010d61df5252e22df6779a695ddd7eb7b6890449fe9ec14884c6c5e3b1f63a0c6357c9f701bb430c284f4504a5eed27f1c355deae7832577bd243105f93a80264566ca34cbbe6ea287e933778696543e78e097581624e276d20c460704abf37cbb58ab6f67db7f7b8eef4eaaf0908a8112662ad01549061e7f251efac33d24a84ed0a9061c0565515780a24e720c245f3f841dcfa2a838b717dba5c1ddafbfa6c97e602afbb6a54ec8eca043e5c43b57f9414a681bb1dcdabe2d2404b111b8dcf84e1d4bddd9b8a32da9797356218c6e73f4fc10734d6cd44eee80a1551bea97ca8a645f74dd15a0210f7720e816b7df3453077e3099d94834c99d403d40c013a21aab58254ea7756f1b1cc9922f5114e7a33fc8c32d45a77db7a2c69c2a6075b37f58688f123aa9364aae851b3c9645d9c863bb86b77609faabebea5c501f781652dd8acd1712564517cd7cfcf876387257ed2c17900e780474e8065b61cc3997b0a774a499d0ec788ba7c12db7791bf76f7520aed78de9a2f04a413ecb2626ecde968370ddecef5b03e4c4c8d82834f018a342fca5af0d8194d7e59c61ddc4c95275bdd0ccd0dd8212a84318804ecfc33ea59b286f058d7c2426a2f02c4c51dedf83a60fdcee5cfa7fd3ecb10e6e31bfd84f2ddf3afba48927e2189232d84cbeca8ddaf24578152331e0b3c0b0e1479c4fdcc77e191c33810870092456eea7ae8ce62eb3229999886977aabd2c0ac1653b76579aa3a4d7aa4ee1d8f198585ea0dc6dc74bb4e4275dcba1cecff9581ce85f202580a3ea99003e676a6fc5c797f02e542c62db8c568fe8753473afaec48e5c946abd355765d3520e5cc3c22a21c95ec734b124c85a0357c35662d9ab026e6f675604179457ac29889bfea159f158f7c7b0a73cef5e0d61fcd6a23edc0255966e02d96ca4d2da1f964ec81c059ef08799c208693dcccaaf141979b63e7bf65517d43d8509783426f5dd32a8e4fb5cdad28c517558a8770c3577e93babd8d9d37cc030385ecb4641fad7c9633dd480ea9a76df3e6a09501949a43614c59cdf3cb3f4e227940c29ad270e182801eaa3ace43b2aae5b0977f3341329b296dbfd86a6223dad346adeb155116463bb26545870dd22e27c022d294c5f06aebbf9a66febe4bf05d447f68f118663d21af0bf5e03c72491d4944e8651f88c5258eb4a0bcde18817c54bdcb5d3fa5f4a864cd8d3881d1f3bd06fbbf7cd6e24954038ec2b29290b0f37ab6552630fd85f579c294f1ac2a0c6a950e0a3a9431b44a54a87bdcc63b91121e19294cbdd135e36d74dee4f570eec211d91f99bcbdc84ca324f412b338812f3c6e70e8a4b41da7702191439d07de20d0fa2e41a368e88d1ca3db06512a3538e05a833867826de99ccca48c20f889956e8000fa1e6e80ec248112b1d7a8114585c2b42c7c95a4803ceb4b0a1fb6e7b725943a7f6ea85e0aff326c43bf66f006df637b3daf981950654e72f253fa1fc005243982855d6f63c46cdc38d1e14d381f8b8f507d113c2acb09d5c40ff10ad56482e08eb6a7028810209c3485039a3ead7c9348db9f8aa8920bd18ae1d25bc3bc5eee54462e7ed1cd3f98fd758e0ece01821fe0970427289add579c48e796cc6936b7078434673282edc97c4262c046c28380920bc089f5576f12f831eae847400090e913c8de796bfd9ba68c93b9a15fb13ba58999bca4080240e44cb2411703347da3b93f5d3aaf10e9a9656b5fa4ce2df2fb92f2714346c53ec599e36070486cb3f9c3da2c69c894905767852b43bc8d7297da32e280e4eec6fcc0fb67e4ef62d94145a8fe321780e74743870f91ff8eef0780635d881621588617c9aa69fd117181b8335ca22af69deaa89c963e1345dfc420a9a5ec59ec863e6c3e64dcbe45c970515b363bd2eb19566382cff705469fa66b5bf72c9b28410cac575cb1e08bdbd7fe58d445b577f1d2635e2952dda3ccdb84000550e301a1321b979b473605826523460120d5d1833ac90de53bd334b1ee2a4d7e2f75632d86678cb76d0daeec2347695eef86fa1b35b9e5fbfcc6307583b349766f59e033e048561270db14a8643aa5eea2e2b9f631c6e6b130ff0ca16c15df82a4fc22e4ff4641a941b023ae02ff8674ba7873d145d9b6969928089f0663568a01d1d3851f6758432cbe18ad5486035986fdd2032b603521ff3e8abb64cde4280304e543cf5a619d3d7e17335f7eb42a4728993e7c55bfa04d2c0ba4be9c7771a682ada1109e8b33b90e75b3cbb495ca83278bfe75b979590b53e75419db6cb1bdfb837683932971f6dcabdadcd18be96c3a893b85fa21b174ba2a50ca7f384efe97ecd006873d57003ad003085cb813b7a69845fb7ad504c49f5a7bc27dd556dcbfdd0b1b1c6a8831cb367e51f1e074252b0bc06be868b59ddc8fa814f4e59214bcaff11562df5faed21754d72387366409e7f9652022b973629e8914d43503d48b1d3963afbe154f2586902db2f6d1650561925eefbff0b6595faf8d11267e64e907333c91d2e7515c85e089a6ae67b633ae2b76f3c2bd9d4eb78e6a7757b1ed98fd0067525c2f3a9ebec35b2e6a2bd70df225d08f080b60574d4568485b43f3f8b69de72ef9066dec8e1dd1061cb464c49bfc48c091690e6dd648102b75f2ba496fd4fb130adeb0ddb729c4e0c02e10788f7766d244c8f2e9d24a052cc54a27ed27499de714785d527df340a671bdb241c7cfdf3731a68f9e0b605879883828e07323d4c959a5ddfb7c3c98c835757f356981d32120d156ded53719c08ee5dc91701e8cc3fa149eaae809051dbfad23671bf8850330fe448ebb1d5f66417ef82c4cbaaad7c1d2f9748e06a75a9241335f82acc671c9d8f980bd393fafaa1a4860e58db36abdf581a27478c19ad85882cd44f8fd0361fbe3b4b394aa9872edb82887eee446d42b234b1f66c96694eb7800787ca326555ad84524df0136cf6821fa771cbb1404801026eb7cc799564b36050f8286e2dc6f4c55f599f1f19664cf228e09a03e64ce30175637512f6d899db266fd352c959e4a143e0cea0c021a0d7e8babb978e3dda18e3ffd2109a5f718f826af33b3d624543dc912f7e72235d8220ef3d8b2da759348e47014f538f469f4fb596f607509c7cdf0333e717c1f86549102171d4035211971bbd489fb48cf9baf264999deaba47ec359d491de72b38b3b131b02c73479096e4ef5b74b3cdabf3e2fb29fd5fbdd50c7cc03eac44662259893677fceb70dcf8ac747819c819f995f54723dafc3667171bed969e1db7b60edac2d4656064e3c9cd50b278fa67bc5462d90de6e38f6328bf3c7425427510d983a730e21fb0e0e95cddfb6ac21f2294b9e8654cea099e61400378ec336727a863b37e4277a15122c85d23072619449cfb1bb0117959a6eb762ae9df383c6d0ab7b9adaae4aad0b5f60c66ab56fcbe9f4b3171da12ec63b56ec9d5e8f4b4b4b310b91833e01a29fa3ddb56de8f043ce7b88527efe449496cc1d555f9c6021ab7ccf7c9c06660d804071f1c733fff9165aa05e2be82391f116663f87af0744836eaa012eabdd4fe90b4dcedbaec420142e1cfa87cf9c77065d54103f35f092d4e3ba0f0f66c5b0cacc4e079ca69f0b789c1f7e7ce4acc6cd437815e2c69cbbbebaa149e0ad3a7496af88b84f72575c88a3cb0b0854b42798de51ac56cf4771f032b9601e25a71779e03c8d9411105ea21388d654433ff74e2a323cac2f2d901e943ca271a09c63fff3dd8292610c99575959f1df9ba0653f10920b5fb293eb8c50c98ab613020db6c09c632c9966f00a26b2203fae2bacb3e4c92e282390415c60b3c1df9c310e1c2097188bba6fc9061d213b254769e5bbec6f927acbb9310d5017d8196931ed77071867f15dc1da258fe2bb368baf94c6f64f3845702fbcb67c6c980441a833028c8dd21d154b7e87ccb5101f3063a1de849197ec10fa7156d09d2238926095bf70d1bc3ac4d8c3fba26ff9fb65f8eac27bc104603a45b4c1f434aefd0581b9b16efcde67b28363bf96480d718067ac051f60dc18a61385678fb1b24be49104216decd0066a553fdc1c8dbf4e790f85436c4ae651541f027a03383a4393075e4011e32473a5fd30f3f28467b9bae8a97bfa3f85d074de0fcda4244c56fc914da172b0046ab6639417f2fb5970dcbed5f1c4d5806cd1c1a852d2563fd63320487fad9eafbeb518ecbcedb283526ac3329ecb98652741bd13f727cb39b7f75346723cafd4e529c3d03a6bf3e76b93fa238056dc2bb23dd5cb68a6cf2334d4fee5d91fc9dc40a4d7e208b77bbb6e8d3f46ada52fa945a1997b6721d57218946709a944dbe3a0a25f4b4df598ec8b1200ed62ebe8c5c707129edb54564a69eae768e183d7419e90151991a34f99f9a1fda23897f5009e4babacbfe513c4c7da89cb9187e30e003aa777e47c19adf9ef8d3799f8832cf9821f74cb5bd1a0c31f63edaf7dc95b8a0b7991d53baa6fac19ddfbbc6f586bbe927b25eb57398e649f051dae391616da418127c10881ad98096046f875139cc26d72029f4bcf592f6f0152a46325e09b2c42c6c06efdb27b69fe5447e68b85ae74cdd9e21f168135bb10f6d8b55f6c1b19b4b2d1a6fde0076b8f7da93737ae3b7b16e1ce0c1ad5fabdef94cc7cb64e422155778e25588dbf466f6881512f2c5fc9a94215a8969d03944a9c687c84573e478a7005496c2927fe92ff3d3f2902046d91e5f6c9ecd53d60a00b17145204a091f0c3607ff1a8a7687153bd31cf194962aa5a711a9222a13f5a99ac726d894deab7b24410c18448432ef8f578c9c5c5a447a10a8d8111a4658bd86bae29fbf438280f4b6971ed410297fad289ab07b33a434c3d9b0072392f3f48900f49792fe102567eaee63cd16a97baa89b458a802e7e5aee795e874b25199f5e2186747ba0b82ec70d9f29f2728be9cab491672c3b02c8f4eb12e6afad5670e9268a1c2f619322e87c0468a6d69edc86c5b6a89d091184edd17a5ab86cc482251b639a55f50396214fcf09e2080cbdf57fe647c5a3ed9f47bd50518fb15f11df80ea45da0e94a8855700576dd1c15dfc1f5952d36c950c1591b7bf86b44ffabf16cf00c82b3f27958913372aa367922ada07ac6c964eea957a7d18a647e4cc8084c3ec93cc3c4d58321ba1c9f01346aac155f43327d0a322b21bd15430389a9d6b986c838870e4e4e3920d2d9176210f8df4a2da394ba38ac0b4434c71c0bfa11b358657473cb5c07ee6e4599fdaa94e169d8bb13665ea81fca25d1ecd1eaa88618a368c6528b949457fec2d98e759a91650b900b51543f374ed708d8270affc46c274375a328e5709d88616a3ce3a504b0556cfc18139effa556e191e331cf9593170c990bd0f260fbaf7038bf7458387596385f52b0ea4781ebde07a4cb83021c5a7ac1245c0f92b5f9dcfb349c86eff15019e3671d746f30900abaea9739f2166306252e5af26e639baed736ed7b6d27560bea8f6793944a8a38a90951f1eba3ff173a7019b2ebe107494b6672ddd1606236303c003c57507b1cbea205b158e58bf0f3c7a79b6652b3b6e8fcb73dcc4895cb860fbb12ecdc30f7d41b2708b38f17235a220964ea801de42b6c009ea6a875832b33f7c882c0ad6485ca5893652fd74eb3b4b4915ad3dab1b38cdf4fbab66768d885650e5aecb800696af4dc8a7765a7f6f2d58f4994dd6fd91cdf1a8670f57cee8c0607cea246b6bb41388d3322c967b59079161f488197da2ef3840c4de8c9d9985b1b63185f4630818414c7503612b16b6e8fba3e366a57e823c3295a005d4be034a8b06a420140724d149116479ca5f190eb4b447feaeefe5611146f1ad21c27edffaefdc0304aeb6178d79024f578bde2cb7571fd4fe0bc4a319b17c1df81681c3e4c4518761a576ddc893fb41bccc6500d374804e4da458eb25d0961c489c0265776afdbedcdf25c7ee043a6383da80fbd3113aecdc298f1dc098de08e8040b0e651c7b1a65ac7538521f09c7c1eaef6c7474b4343a15b1c397a1d54af87fea99ba4c705d534a9899ec3ec2dd80f8360fcf12d44e4654f22d75a28d505595086588829280ed2e95734dbc6a5e2ecba68a43a700768d5b8aff17be9022f6a570e72806db80977130405a57474932f45f85d58145eb9733d21f5d77c4b794f69137cfe17575dd96dcbaa40ee4d9ce7d287f5b86bc67f0fb12a869b4eadccffa9e857b6227790c067dd702a1b5b8d81008813dd6534075af82462be08431936817995ea03f2aab7664d813d0b9e5dc0fc4f783f119d3f805977c8ca0cb8d3177303fb88c9e5a245f04df65baa556ef77d813f75d44318efeb9adeabc025cd263fe1076cbce9391031eeadd83631bd7925acf7fae776ecd8c19f4f3dda4f719c5c6980952515372e90374739c08e98ec84e905844e23dfa5dae98a2525dcab1bba8c49e437d601c943feb81031c3afb904a228429864b01be23aa6c967a28fa1877b3fe05e70f10345d471052878f8bc94f25ff17ff7bf98cac1f65c61493a10e87101736017103ecd6dc3812692681ff57b2df977fd93ffa3d037dbc383e4d7deef99bd739587404ef86a56c5ee2376b28a63ff9c7b52d25fc0ce55e4c7d7742a117a8bbed8ce0f387e43252c373dcd4b402e02a05f257d776bd079159f2d101d4e6b19475cba63faa7db280fe89adaf4df245faf82edf103c4d4d4a94148304157bf643239c78d8927f7e61fc6790c3ad0929aa061e4f16fe8c496368995361ac766f98e08db1291ad59a1cd937bead44a30cb9ba70c6f89a9b6683f5f3e9603392f8eedf0c1138894f27d29861d42b7e6ebb816f96c326e9060e3aef6322538084115b8b54469ac05c17fdec4dd14021b7f7b432d737862b4d1fb8ef1ece0e2c3be299564547ccc1364dccf49478b70b21310e4b5e54195beec2499fd25e44980986facbf8c76fe285e539daf5d6c371cd2ac594cf067de2d795e24cc5f237a0b6c5de7a9fee5f590caee3549a99d40004495523ca4708aaa4497aed2b2c14f7e1df8c112a08dfbeb6c0c40a7297652cbd81d80ba07bab5662b403e60f739c8571b7a7af03f72578fe3a7d186bbf6d79b61d1e4a6105ae3a07a2f02f1ff9de642afd769d6b207159403967a82ccb16d49cea9d89dfded7b55ff37d6fce78ead44b18053db5ae736908e17e8ea1aa3d4a1689c87b48da51819ac84ba6f6fa63e70ad3d1a5e0702fd4f6d0cdeffb94a98be8ebab7250374517565f7006ef5afbf1e5956f96d165ef474103ec0ba0156e6a775fe7dac5f081fd8cc6be6b765bd30435796827bcc692bae6e545cccf2a05d8e0e598648ad7243a1b4a8247b690435e14442a12263cd29fbc8810c2a2f4040d8ee7d6d515f32b8bfd37280f0104c638d89f98bb2276505fec3aea4d0622f6366de9da61bb65862e782c46b58fca6be3e6b8f44d7a980a52f03b8b379540defa0ee08a1eeda9b2882fe7ddb88fb46c67a4e105ac4478dfe59ca040ea38ad71f92db381bb7eceddfc5af0ef8e69693bd96f5ee29c2e2afeb22ed16896a1494cd8c12062f956fdcfcd7dcf806ea3aa14bc52194e097dc9908a2c08c0a2f1a2024b59477ba0526d7debaec048df237cf694d22a5b3236a9a8570cdc4b7affffc292293c7f86bc1425b407761409220c10edc515d48eadc51b1d0346082f5958906b901005f28644c45ce4528f775616d90e071e77eea8af33fb4809c704759296c36f8eadf0afb3b32df7fa3e41eaf53b10f9dba2f5c39d3f5a6317a4bed533756098b0bad615d2c8ca195b93dc3d5be8b4e02a7259e71f205ca65c08693be6d798906c9bae393b2c81434083410513867abaa157a8e28a8c0d9b000ffa1174c79d8fe51d3a8c1ff3c549e10e9cba568080de17abec0ffff8bc79740e0d354979cd9c0adeb7b40024c29be9cdd8936e6428de1461f11932f7e554a8729090263af48c896cc69b5264dff072bfce8e5225e482281811ed1c9960a99bcb8bc722fdc3fb44f75a1d3ab63e7017e42cce93b967bc505f361d893d975056a30df6056eae681fedb9fb50398c0012d96513faba2c59a57337d4f2fb9d72455f0bf1a8489c98a3480bc75f96e04d6118c7b3cdf56e8a40756d2b0c993697563093fbb693274365146d312b66d35a3cbee36c49db3e43281229c7ef6ec0d854a9c8f52cc2392051a5ccfb32046cff7c0c086f981ce805a6b42ea1df9d009ecce92b18719d63cb2633b38dc6dd296671ecded775b637890d00ba0efac2b91221610e7736401660cada9fe517dc227de0a7f44c116ff0fa0c461a4c1f420903440e1c517892bcae22295ceabf2c4e12c4b8f46e94ecca4372bbda39bda0de3cc24cf77e773eaa3181995b2027166029f42279bc301deef7279cdbe000719396da5dffdb659df62e77865630bc4901bbcf71d219f4753a7a890b5aa949ef9ced129d79780df8d68fc4b40a070c3866788da420f2d5a13a3d258b725c2838c13d250622aa6405cf9c160f19d79c6ce66da5eb4156acf8ccbc52d7db13222a2af716f643c2c9e7875374e7960304f66d525d152e697dc2c6d0cd4f066998baf38bfef5f34f55844cdaae264f69dae69b8c4aa260f00dfe15c16de623717fb85fc34c56744b349c93b35e52774f4705d8f08e4d25f58d72305cc2f3e96453f7eaedb23df41862de004ef2d56a61c0ac57e4023921072b89d5d383b5735449c534e18a1b0177644b2785192935482f696896bac1fb89ba692e31887246c2182598d1f8015c27a26ca5f8999b2e8514edfca3602dcd749f3d3298efc329ccc3d3d017deaab907b2bf8980ffa4d4ad306dc1eedb279ae698bca5800dfb46a7f190b4422e78296378fd8fcb9297a4e67baf913ee4cc45a8fae7ba3ce219cd6472613a27e0513a4f72bc1bb30805fc0b33794be318a87cecc6c2b873285a24684b1da8b702fcf0e8b58aba92476e928bfdfa7b2f212de6c9ef1cbea489840da8cb33336dc19756823af014a1674f170e64a3a470c8cdc5bdf1b50c6537504c3779714af301d2b036b24a4444d2331f33c2bb662ff03b8fec4ee50bbf75f75e2797002aabb2c0abf2f0f19ea84f1cfb0f37ed227249240e660e12cb838fa103b5fccfa04acba3b709338075481262a09732ecf58d092e5da2302272f76401901deb0b7981c9ce0372462d4a72ff942b031fbbbefdc2de54291f6051437847b36ad8c885ec5070257c07b97ac9407890ba07579bd3aaeafd9df29bed150faef2063143af182a1d9285ca4532790123657e519fb01f99c91ea76689a5de13b833ebf98ad9ecc6aa2db2288681e50a54ea334d5d871b12da85a305157659b22b571b73b870704e87b8b0a4ccfce8ef7c02398735743b233ea082e67ef6d15b147494a2afd8a7654bd03dcedb81c2b5fe3f735e8fe92dfba8352316d003cc28dd282cc5ff8a9af97f359c49bc8f315cd7f98714c396bd9fad32b16f349c18ce14dea38f3b47e7ced538bbaebf6ca3bea4fa02ad9bdbd1186fb7122a911964bda8ef07666ca215bcc48e14d5778a73ec438f6a6062b0b182a52cae","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
