<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4436bf8954ac83723aba24e2d8478c4fe8b10cae8c1f96fd3bd3e6869594db0d1dde35045133f2810f9751406bc3b3fe7bc29a15aa91fc64043e119414c69a2e9671d1558d5d0774f2a8f8128b2145a52b3c1b3453b6d8d0e2ed9bdbfa0ec668c072cb50d15a1829c7d81e922c2d4aa58a3f3a97fd78f1f38d0748a2b58b5996e0d12bcbe6a174e9a8eff01dea638b163cfe851db6001fd3bcb0b198ba87a6ad8c3afabc00fd65af492c3073529b61923b0ca545b62f7a212f52db2549b4c2d7ef3c3947b4e12e10b1dcf1403a1b2c674c06d82a8f3cf184aeb11930bf7d22ce90a7b86d31680f1739b2493b774f8057fd0c6988d801b1759148409380ca6ebcd13a5b878ee4a8ca068e4036e43c066dc19dd8f1af8daf382b6827a3662d6bc530df818c029b6c1b385294123d4d07c16671b1fecf9995340871539b1fd1d355aaa6e06591e99630f0a47f42d4c8fa1be22567839d130bca361eb629a46a94f0aaf71dbc6b05422cc15fc5cf66b3468f9ea3070a18eadb6d1340fe92bf42c72bc25b67f2c43ad5919d1092f6070570c458b6a9f31c23ff0909545b58121a47327b51f2658db1f96d132007eec4f63a7ea2ec6669451aecec6c1d7db6ad346b9a4200c109241453c18c46a8ac31146487a63a0654c59fd13a6fd5c51c103299191fcbd200cc8cee0ddec6c8c213863ad478d4cee530809f5fa60e3090ba99b455120f57682c3a1457fd985e22167b400fc5cbd33568159d16593a60a1465339b0b4bd3d813ed97e094248d4431226229153d1e0fec8266b60a1c6aa2ec3dc1b60ad3fdd4d75955db461a98495f22eb8da654fef8d32cac1cf45cdf2ac4150d9e3c1f83f120456705b3e4223b820f915cb278b467d5eb2227f84d362a9065302b0123776d15b105a1ca0430b342186dbb28d958ead0522093020ac108f3ff857a94f85ce31026792ec735425874492d0b649a4dab5b9c3805a2af89b6200f89787a8b72f423c13dd56ed7c476102e1086e8f4e6c838a5403bd48fa7e094a30cd59036366014c33a31b7a737d94fefff76df5c9757085cf05b37a820d4ae170aa1d6ce1cba35d506df9aec8f652e79b1996e3d09d1f6c21df12ced0045008c15edd17328a2d5de1fc537ed6428495c4a2afbb13eb04e770fc42a2036828c812e78cc9af224bfd57b2e17ea7e8407dcbee856f8b318eb3adb33dd43d888219a7febe890fd67b13c134baf3dcd7c40bac51483620c5d44016c791c9d3e4fe0962a64ef63fca9cd83e945e03c963f997718c650c4ebe8b44e1509a5b960cb4c56c107e9d4cd97c468845a4c46527480b7faf624e8b71f55d729a0fba96e452c018652f00aa9606ccbed4435224a869590a8939ea371c4e92409e718fe4efe1373284dde785fd78e5d65791000020e872f8a8c518b7bb9ff97d20081bcea5c59de8ae465f854a40c384ca9e60036dc831fafc9c06816e531fb5b9e1cecfb2ea807059f85d9602ba883010b84e15a22cdcb61ce933969f4cdb9caaf4ed393b2537de82f79a1902b3251444ee37cd925cd3376698670dc16295105a301913d91286f2c08e675dd03adaf5eda839f6c8c749032c2ffb025cacc4c04376175152696df529ca83008d64963dde2ef2b28100fc1680df3a352cc0ecb32bc46434089e4d05ee93594291c0408a7357f61aa0de6f1dbbddb8c6aa1bc3f42306a9091d8e63860ada253327da50710a8088cde83a27a568796ebc3a867be359b5f0c7d1b90ad3ca1d09aa309c91e3bb31282817558db5daa84dbb59473a98f37e270deba3ccffe5df71970f1034ef79fe45a9f5280bab74411658cca151af4ee6b095a01341dd0dde1faba482186f4a15f21575ea592b9dd7373d6391d6f84d0c6f160bd1d9df02f9558d4fd172c6ebcb257281904730079ff4fbaccfd1ff229c95f21414c5f050a3804166be736585a37a2be6fbb725142b0b517d98748a7f07052eb90b1ddd2641941f1c4e6bf09f9c58db927c8d3d5819a6ea0857abc2f052e4f5fba137cb723ab35953e8e4178cda51571f46999ae0bced0131981987fd3cd6c26ca4bfea36279f2ee50f6916308050bbadb6f12bf330729d357181f7188b150dbbc5466f8c00a4b43ae689216820cc5b792d75d1cccbe520c11a73308989813d8a7621d062997073a0bc6c0a525b1ff88b83c8de73c202008e70e639f647413a132e8a2aba3a2f08097731ee744a339bb6a080d9ad926b22a36cb5f7de2216810dfcdb99506ae3a2dadf074b119f2a27d98ece454f1d6e5fead114308f738ec21d52accb3fd663362cf270d18e267ec9d243c4cdbe28c5e7d847cc930e43c00566ed99c99180331c0f5a7242ff89afff54f2497a0ec6d17c690e3190613e74384806a2f63c35588fbf657413078f2452a4d41dbddb613cc6c5d7d51a4ca08ae8f68381d3227c1a4804b377e2f9fef63e00b54bfd05539b7b33b2a9491f96b31d1179519e839181199e0d79a881f1777283c13a3b6ec542fd9dfd57d044bcb2e0d0e54663ea82b53932689604f05d0a9e4241caa78ebaf6975cddfcd32f7fc8e502d6cbd69232dde73292f60b24424124b747ac21028253bb5c1b18ea4e63f6cf6709001cab0ddce76f1c4e52114b7463d632b14edf1853c4b147be573787a5346930668268dd9a88acdd16b10cb37a6d5b03ed830359cdf878f0e0eae2c503e4f55bef9538d2254413a92c3202b6740cb97680855262c4ac5611a349ab28eeb67a5caa4fcbcaf6e8d18b2580f4abfb55e08917ee2e9bb9a5da7b0ba5f5f355074ec3a263c1e665576f0c2af3b31f6869955fd2aefedd7ac002c6d071ea49a94861bb4b8bd4c85cc49be01b7d0f93e512d80b35c5bc126e9e67c5e431d380a6820c55502d729298058c0cd12b9e945143342a26f22d69c5cbae18cc7ee4c92d0756eafc7c699b0d1cb123b35e199e230320ba62c6636fcf8e36df36374240fb2f3aa64bce07d047798cfe0affda16073b844ceb39bc4b988d3b192040957671076febdba009ee1ce4b5423823ccabc44f678f9d3ab12b168be8dd6e9b2e02ceb7c02bea1807847e0e0df70123634a620e4f80ba661f3d7a628f0583694e4f0fcd3b05fb0c350a503562e1293e0a3a01bcd228edbda547fd96b735cdff8fa47d31cff45bfeccacfeff6bc25dafaea5aa38a9054af650bcd6cc639ef0ea4941c1480ebe90d121d667b91078761988fcdadccca6d5f5cc33ecccbf19170b1c948ceeaad6221bb85a112bc165327d139dd1a86dcbf64fe30108688f974967959f5c76a5a88b74ec177366efdd5c18a314927d1f8fd8a5a490dacfa115ba9717ecd0f77dda2159f291e76daaf987e71bfe6f4bc1b546d0f4156dd2a97abf8a9369ab227e921570aa027d87a61c7881f9bd7d061e6a902b07f601d6ce8d42dd78ac94fb1ba81f103c7f63d4da631bf3b3440b14d82e3fb024fe64b03d0c64ac5c799416a2f03a5b9693dd954b1baf5996d157cf21071c8719630dcf6d305480f0a6a9c535aefc61791f739815091445318ef404fe986475d2cdd9a576b1b52e4b33826e7d2e5a28afd28e36fc898d039276ce078a966d25ce7956f15f3d99c230d63f8ffb5ef4fc22b755fde2d2da01b771d8f765b242f50a39dc17eb0d152e8d749d77ee2103a6957235612811a718011566dca67954954a3e1e728b8390f108007788fc0703cc946ba931807172f2eadd9d23924994a647cae52f0c286b03b5802441061a07094a7d1aa9c697e1ff6a611aa3d01cc197162ed8e330758abb7c581c64845c8d4b3e3d9c603b0391e3e9b86b6ca4e52ac396170a77b2ec1cd1dcabcb712f879ff7e75f27d841ec8d31d4fc36eae26bdd11e588606b30db09a359200f9ebb6355cec96572a9f1a0c4825804c2d3bbeb9f50ef1405123f91fc829ffee6da6507dd3a09b14f328b8f70d0fdbfaeb29dda8c5dbc54f319d38c91c1a9b27c9db40c5c146cba64dd4a5456747361e10433d65da137b78ea2af9651e63d23768be7bb6874820acccc4710b11a081397175bb0cee1ccaf6723e1fb8d5c38e4be0a4381b5ede5e89ee1658432a26cecb195ae7faf37a7674fb913f3e63bb7f2e3bda60fe4799a5b83cbff6a37288044887648f32bffeba959fe2e440f45a2411ac8ccdc69dfdfcbcac3baa68a6755928265c5187b54b2270260695a281b5114d281fec69839a53d51038923fcaa2135caa2dc30ddfbb134d738e70e9735e5caa4a28f3a17309d380db609ea16cb57249ad12c4d75b51c36a6db92f9af8fad77ebf4aaf0889ebb88c139cb967d30a1cbf4b1632ebd4d3a363d25b968ad136ec72454dac7e85bf502e1e75902eaa14725dbdbb9ab8a5a8bb4cf1c7e05ced0c3ec619dce216324529e73196226f6023d77d8c34c84190a8f391158f9dd763dffa2437dc4f9912db720532f380a1813c30aa77ecb8811bea7ab10818320c25a86fe701f5914bef0d59991a2f4ae2fdb9da3d4a036c5633a8c9f2b419254aae142125308befef7ac52aef70711332a9f08797f4ca0d4c77df83a1d120e8aa36938655246f616fbc1cd82521a840f8192a2ae20b40f7f84fc29456110b0f5226860600b26691df8dfb4f48b8fe53b470c1f9cfe5e4aece058927ddc6d76458244ae623d106eebcad68e0fa95d84d33129c3e8b8f5c73db81f78377ea7319bc43b5f7684fb7d034515c338b3e5aa7ac6cba0baeae374e4cbb5fcce5f4f3e06630d67db8cb038a7f15bb5c9f111c6b6e0eba97ea7cde780d6e50cdb24b839c0ff7715556f72358aee7b5a6467752294ecf8bcf09f3b9116776bd48021ad1fed15e3d63969b48e1b35ec6f62a3b964f77355cb7d49f9d0238c31fdd4a7276251d010dca232e37582e7d99dba465494088cbae62621d490cf609ce0a40ff48ebda20b4cdad68b602b67c82300ec8b31544573b562936a3837fb383eee4bb0a1c6fe87bb8365d99be2f89e5750c8590c3afa6860f3aee838b4d5e5fc38447929bdd2d64cafb672464f8af431f566453d8a6d32ae9d5ce3b84826296622e54716de6a59986ecec675e35a454d393ff95202062bb5d4c30703c06530ef311ad0d7cdefacb09e795f37fb8fa097ecd69847406b470ed1e5cfe6b9e3d7d0f9f292178ef7641ec5d09d8054917b5916b33e01c5f812b236e1c0b469d1b358c00da74031ac2b27c4e9cbc5a069182de047bbaa34f045b73109478a377b50d12f8f79c881b88c2eb1e183eb6e77e8392484cb65c1b8effbf5b57e9e13952ca9ff5f3fbe08e0998673c0e5890ec338eb74c48cb9cf8d17e6919c8f875098ba50d8617da580300450ee3381502d26a07b908ece430639ca8678c528eb30f7db9d55a5f2c32b133089ffbbaf6cdabf38f01383f42bba682f1b1bb38526f7561d68a8cc42ed08f114745693996038d435bf0079904e7c61d89e9342cf672723296e96d3fa5f451cb12a75a0ff5e0ae00303f5d41f9af039f31c5cae35daa23f5c5179131bed1da3be128889267eb7558174231af9a58efb296a3a5b21b46d26da97038afeedbae913c0f892c36f34130d167580007ebec0232ec913fe8dae08e71f86729d02c6d1abc540a020330d19737eb055104a4f89f60400cb797f9103a4a5bd743f38fb4b37002c274ea5f4f05fc8d143de9363e36d405275d7be7316a1d798ca8230f4a70b41b7bc68f7603b33daff943002a2516348906a46cd0d70939be60f3c73d8ccaef6f3e757247d20b1d3b5fb57bcc10ab06ade113ca802c64b957f8b747874a1ad349cb9927dcceb3dacca820b7ff36e03d45351d427b2aec2f5826c997544a65c55ba47d4e8082e4352a33e4a5e11627c9f6281756b3f4ec95abd067c0fc8a0b5943bbf7fadcd880920e465d6118d2859c8f0895034ae6093ce018ca824a063ab662460939e8f6a8158db5abc17aa731c5e37a03b44320aa886e697e6b32960e9dd5f8a8ff469024a4054478703189e4a0f7a1073da9a0dc546a6349641386694800ca7f6749ab03183900ccb1b49cf442417571df69a5079557c33957cd2ec84ee203b24b29450ba4839b198ebfbb3c6a6c289c2572f305bc175495270fe326e8ea827941628914788b7d3b6b9201fb5041f2c70464e06144a0206f5d01c93cd1ebe275ddeefc02d6ad2cbc8c86acea28d9754c6718f82dd2a83b2fbd6b6a216fb34685d8462e425490479c5b1c8772a7efed7799a9c936dc018676f8ae4bd0137a3ca878b0a3eb2708bea56325c88bb374b9a979d877949d46d7939b3677410184331e91c7c88734e33817f6bafd395c3a2db070ce8520d86dcf8d4dd24ced36e623221ffa502bc51789ba2e433e92f996cfa4575e351b423d3d6b0c192701851e1bca1b3668eb703fb731d40ae619c29b5006a540535cf2914cac98651809a0c82a9416262542cf76b5eb4d317db4896727763fa1df19a0d7d2f5f956b4203abd4fc3a65b8f9a02f948cc7beb311b2677174044f16070904f1006d36a01c608c40f73419c83834542567ccc9fc267cec0a709e4afbc5206d03d2797ffc3a2882fdec54d25de071559f98196892ce6bff29553c2b68b148fb79504005218c0291f17f1846b0b12947afdeaddf0856f28c86faf35aab4bca265d27be6f23985c3c21402a7252540adefddf6ad884b5108f855b6006023f42bbb063d0ffd808d286b692153c79627a88de0252aab5e50dee8b55d26858192c944d6398e82afcdd00aa296c8d63b1ac54483cf6a454f265005c6bdc0c7234a9458a3237f6817503b3e6010a8eee4e413fa3ad546f0e26bb07b85f6855ede21c65067dfec5ce73b7615635a23fe96abc5a0ece41403785480080594c53f90c6e05ff398df707b16d45fc9226a2f47962f84016339017c2dd13a60c5fa65a8b0ccd909019988cdf8017d4ff91557228e64234c7629f9dd68b3b0498930f0e52128be029bf1c676f3cc7df9ecb72b41e4e74a348fad418e02d0a291cdb503a84cdfddf4caffabe3fb9b33b37a0a8a2120cc6c6a650f7f29e56ce5e51bffbd550045e5525b79fea1d10e1a3b4187529dc1fa2833f25e54ea5ea8d465ebf4ec940a52936e732be86c61545a3218f6db25f82f3aac82b9eb0710eb73f1e467a23be30bd1bf2a9bbdbc9386dddc805c5b805d5f3d78fc033a92ece26f0b2d26eed37a60f484826d42e2476ae6119866459e280cd3ef4f23da5020388eab6aa315431c459ddf02271baea0bb1f5502a03e217d3c0fa4f8db20e178bdb6c9799981f658c260fcc2593252a8b8c4c4c0b165ac9c0fd442c2934e846c087201822617185c6ff0b83fa9c78b652e6268605bf5eb258f112194d793e7767fae1a80e2f89b7314e8c9bf51034d81b8b85166b99845e23ffb192ac5d5d2184230d502259662b07077cb6eae9243d2f39f8a8065c3a2135bcd933d9027b63be0e58eaa20bf522d4e3c23b65ebb84eeaadac0b4ddb8229756ae1e520c9887607381bb433cc36fccdf31580595a50f94e511f1608f732ecb3756869a1b2ec583587719c629c6e73a1489ae17abbee5d461876754e043eca7c069607b4c197ee9f6ae4d7fcbe98b1f937144460ebc3d52c30aeb6de58961399c70708296bfb9b70844de86472a0b2984e5505f1aa2b6c91eb72db03b7ff57e4059006ad7320dbc69bbdd74369c7585493a57be6a736851cfb336ca3895e63b44e704cd06d9ce16572c9d9f66d57c30d6b4c3128e43895777f84706f7ff6356c241bc3ee1f65f0e769b81c31add5ae06bbd5cf251731bbb0e15f1b35f0519180da31d8484870a95df0759b49e9bcbfdd2e744b7090a90ed7d740cadff75a89ca02e014f64350ad3cbc3079558c45ed1802d75e5108f36b8263846d9658fcaf5ad462cd4ef48bcaeac63310b728517d5f1fabe51be1fbe4e89359cef59900d36aebee61383da9cdc1502e8a2e5aaa8f67d205afa1e355ceb339832404f5e07455034bd8f451e0f0572d6a3da30dae2940c63a2081bc4bb3c2370643dc8b52bb29446533545da91073198584023e9220e9461f16841f3d02924c0ad708a8761518f06f19d38c22f20f255066308810a54573aee732440852d8193950825564ed519af7331e20a2d105d786880120bc3958205a2a1c9482e8de5048c9a368665920ab03f8976d92905ad0e55ce642cc1953da8b08cef78a9a80e4822ebea0e8c1b8e23837934c6b78aa7ce67b82c5bbf3fb9c1f6f3caca0a80eb12abf9ab0551df02d10af6f517834eb5704fb1dddf96a2ae7af769c2c93354668cb7ee8364e4f040f1672ba25d092b07e62346640dd828dc7f91948662dfda01a64ae888d38e97aa1a62c5adb89225ca78c78b9ea6a16bcb88282aa9473bbe58f5c94f6d467083c85f1edcba8d4733a5f6ccd44e3f432e81d59a20823d9f4425c8dc5dd1f4e1b2cac16e4c3edbb5d7ef28e29fed93cd8d8d4504f1beaa63a7d718f870b2c73382e01de22ce6f064674cc2c00373fef0f74607316076f47ada1f7dc8f84e1e1905f93d4594e215d206ccca611f8ea020927e8e196bfc9ffe46889837490dc369bb5d864c5ee0da5550e3220b84d263372ca740ae3a1cdd615731c20ad9044a9d8e625ca9c80e4058a345e5168367ffc998bd1ca14347827a77a71b08acba620c6c362b9936de96f48e8553c9a1fc9264ed7f9c46737eea462a4e0c36f56dbe3f059f5ff3fc16bdf466e533c5945705f56dc5b491d342ef7d4ad4b8d249ea01af29e1b2db6cf8e3c5e61d396b7d9ce627911f7ad4fab7c8c7428152a17636e75e063a6368e087e14f1418f9b6475d167ea89e2824f325e995f4749aeb287835ec698b3119b1ee8d5bb3d9acb0abb0618cf88bc7026c101bc13da8dcb4d09e441444daed766700ab0d9365e7847d67360f2f2d72087618a963ba7eb72994f356296bd2cfaaffae0422216976558215dd907f688d86b176904d6bc6436ad1cc65c94c8912ba0198a04b7abd8e62221591feb5f869a769b008cb61e7618c8803b2d78d26fc5c7330da79dfd1d0b3aebf4759c6139db8cd9825b4b03630ad0595afbccb6fda153cb59b1785133270eda78069628cfd48f8de440e6fafa3126c8b31e4c9a506db135e5743621834d127889df6dc154f297dabdb1b61bc577668e9205e9f49acbac7d98b2e474e870ef9db81b4c32e86c5bcd13504037121e31983d5b9c3726e0048e9aaabc01c3d8d390b1320aec23f019b9cb4197cbe6db4fb597275a12dfc0006463bc06e1f9269d2041c47b801210a7e6b51434f01becf8575716c9b1f1b3991898826cdde3dfa07bc1e766099ac6e1160bbf6f220816ba7640a5298fff0c25cf4d2fdc238283c4b673e165d5017f8a9462fae0614f7d526ad32cc87cc2d651e0b9afb3d420d496cf46e201f9efcb7b4fb24f4b2e22f831162528ca681143b59c9038f584e469f88a0f63ed197e5badf6f5171feef494d7fd4b6525698efb36e81bca76a75ddd29f2deb2d5f088efc00892db66c9d054317e2a0bb54bd2c66da9a8fce81ce0a0ef46b7ff8bd5b577addb51560be2543f8abdc466a93297749d0e52adea1dd130546ef7243e58a96b2f9b829c95979e4bf2979d2d64ed0142ffece4bb4c36dc8775dc052c47c4bf74d46ea50bbab0cbf02ff3ea1ce267a7bfc2b5ff5a35a79be4be01047504be55de59ea6b989e50a73bc7c6b47d7511eaf75ffba6a039b175eeaa024de2b20c2bec3d5ca414d6ea6319f9c04ea2f5ec292f7b5772ac228f97aef723b955bf3c0cdf10c04a9b6bae55e4ac4825c541fac7aca112d492b05790bbfb25f7eb64f24a8c9d84d92ccdb3b37eb453a305c6961d084a0503131fed3081d2f216d9c2782845c6f6db4181c99efe5f3633cbe6612ad9a60f9e2db2c5cc27610b2ff5fccac104072e96ea4deb2bc25c07dd550c301c624781f5b0883107745f1d34d0bb20c7e","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
