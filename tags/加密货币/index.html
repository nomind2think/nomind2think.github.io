<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e32534375add4a182598b62fdbcc074ccf8dad055a1bb96222c6da2c254392bd2cc9d03744b36dfd5a2b14657840f5baf62cab04b04433445c724465b17cbba542ba3feb3582076fe52519bab4fc3de2fdba8bee7122ff204da066fa1cbf2cfc3b9a12aa4a8e5e1bba83315f51b783a7a6cbe8b1131726ee15a07ff3c42c66e5e67900ff012f7adb29b29df34001d5c5b4e23879114ce13813f55c3d9807076b1e88a2dff3bd43dd8d98a89dc36b96df8fa0470dea02a19f3e4ae84a26ba94a924e394034e67452b90e578811ab58f3dc95b9bd4c64ea7b05a87462b3945a94e9bb1533164b396e9f4f8e423187ce5df4b06c6a715d9e2cf96b0ba81eac6bcd701e71830e743f9cbd60fa791119653609c0935bfa0c41c5b4f8951a95490cd71f15e6b772b5f1db14bb0c5ccbb99b6fe1c19981f04fafda4fa1a23eb7be6248db0663f7a6eb020a2d980ac6f34437cecfb784c9423509789be212f4c06a6407bfdc39d5c0874a4ecb8b781a236b291afb6443fd5c2e20ae67166218a9e31c54aacf36fecee8112f84060b8e0479195688b46b9254630054abbb7b71f9882bb80e8cb46974a4a193258e08157833f9fe6c5d301577047be16f05df82c20e7173c8b5e8378b6fd8965f1b7420be3eccf994b483545f5b151462e0aa6e4fba11f9bbf873c40ef34398bda9f728e22c05174d40729a0ae6f5e1fc8727a0dfb214f2da3ba8532e254d75068fb1834f3abadc023708d9dd1f6c063d5646e32e8bcae2398c56185fa3a298333542d8ede30a7c4a505f00a4630c923e28911b1ea098d5370d47b9e4edcf806878eaaca59cdf86c3035836f34b9449cc38a05858b91d34c16cfb3e8aadb68d9a24c0340758217d166a64533c1cd96c4bdd085e4bd9904685216740c13cfa255e37b8c2c037d1d5999144e779b510ced0c3a5dbdc395948a9d527de820a63d626e0e948d0f90f1fb6a09867524e9a52ebd5fc7801b75d32d47ae83103efceb3d30c9d0074ae8eda1c0dc7c129c33424d223d71fd86d0c2caeaf99a8c91dcc1b896814c7d2211a5063194f53fbc0cf14213601d1feb0b74ca58a8c4818773e19ba80c252fe614782ba060211fb2df1168afabc2fc6135fe3cf59ffa470adc3fadc96cbfeaa2f86c12258cb4fc2f85ea929d2dc74561c59c63ceac3a6caef27c23299f168febe3c9fa079e8fc0aab9a58ef4534f3c010f888f96d27c7ef0a01eaa7a19904becd9870dd332d8bd9292e1790c41f2cfe411f9b39f515f524e212876f1a85de6b3734ca0ceb2d85ea8759ccb92a547092586884dd2d2ab4ce5680701e6531176bc7721e71d29d9242549f11fc7696a7117b5c083ee2ff4f26c47ada6590713bba9b45926ff8c933a231eaedcb6ac203c0ae1ae80d82d02eedb6f87569c7187a4a204a9901f3899d9ddfadb99f9a6678130f57b901ec8098f7e56767d8bcf3730d30d4055b6bd73c29728c9eef69c449e0b044254a2c1f346d1648b6a138eab645e182ae8ab16397ac43674028539a283602c141dccae609be5f00e23e4e1d5b7b4754d697da573f0c485e3e28adc1e238ff4f08989a35a98549761c66e583175d69b5a4be35a8a8e375817499bb8d26e635534458159f7849582401e47e2265d13a1a72a6a499a6c2943d5f0ee2cdaf131ab5b4c18d1a802f3435b3e97407c5c0b04c7235bb5b7be19514a743f8b0a0d86b89252af0aa851a3ca12f08f7d927cc0e1ef5cbd4cef863c6e69d53e5e37940dac6501140a25c497eab831a1eb212e3749b7b73754607dd7e902b17c739264dbc39f3a30bb0f104fa30ed99a0655cfaa2539b1ff8cd30992162f60180d7938b9364e408bbf497b7267dde677f2a5ecf337454334805fc8cff50c67a2772d3241d1c1e1054dac842f236d3abf4ecc71f74f6f2298acdf8e63eaa62e60c864cd0242d12632f35b261c39586081b18cc2f176f583f1807050529288f9dabcf1eb5232d4c972730cc0650ed0bb3e508eeec519092b3a7cf10cfcbf14d4d99e1d90dff313d246474b4705de2e61afe3c2c49a2b2faa5b9a94e4f23df1331def8249781b0d4bd0e646aa46b8002d58e35d4b8377555ed4ced3ef1bba7a57ff20bc719a84de403038b2f302e5c30f37b9513725a4c36cfb5620dab1cff611e0915378e9d780f9c30294afd83193be4643d6329aaed4ff3668b5b2ba5b476d4475b99d0685efb686d0686c7b1bcec65621707eb9ef9261fb92c8f2c6e1a8b68739efdcf8b274bcb2ee7c077188862a054af5f3ff620496dff2fd625d498437c5bbe7dee81c8e8ccd7f307b409cf276b7c9cb0e16b7ed62ed98c0b88fd6a05a960f6fb08f961dc90c21bc87a3fab0418160f3de5e42c508129e21f163382306551103f00c3ba9cc42e10e5c74f3f3997a37f29209304abc337598eb6162d4624ea0c82739377e3445d5985f698c9bb459926137c999d0806ee9aaeab5575c13420656ae8479f335fe480dde3b9b8e631f108f9b9abb26a84223c4d8106db9733c0c926ebd9af9932344f1ab0c40217fc125ae1ddaeef46bda33e4ae05d184b2564d4c5b7c074b23b5fe7cd8f274fe7f8cf0c22749df25bd9a3a8402c11d7587c5730d0de3894dd3c68066346b192d251ba59a1b173e7e381b87c139aa79fc73d5ac2ff8d1d116270f0eca26848096f7e7a19605f857231527114729c871bb71cdfc9ff9e629e3764eb7c0bb3bcaadbc141143fb0bec7aef85d19a5cdd04d65c3603e604abbe3b080d32fa02c4fed55b4864958f27d7c304f7a70a57893938e60d8d972d3871387562d8b196aa2511957dafec2a816610812cd83cc9924de2166bce0027bb4fa15c5245a82fcf19ba09c738950b77f81018fbf63c76207aa6bfdc454fa26e747afbe7d3007d3d3ccede1a6b55fcc652adc48ab407cea5920bf4c4df6a2ee33d0c083954b68553eec6d37d64c1520bdd6eecbb6cc6b9b5eaea4356c2a1aab41d85bd3b0b637650d62b7ad1178d77ef4e6caf158fae0012eb2dd44591105ac2a06a741a7be16acb788b2440353c41af4ed308bed40db19e750988d52e494a2cdd8a3eef5c1a01922255cf0e0911e390a4ae0a2afaa9c0b02dfdda1294b50a39e5325f50e184e74b4cbc32652aef50ef4835b5ac7ad8d9785e8804765aa3c18840fc044e711cd6608c196dd90399387ce8d2836eda306209f064c9be972dfd8c5739c805a8e09d927dc346caa5b9a87bb56178826eea33bc996f85d22127520612407972a5cb32c13d5ed3bbc6a6060c892c57e741313a1b701766ced91cec75ca93699377206e36fbdd1a631fc4581b36c4bc8c3db3a8e03643848420f82f8fda2883e9498e44912fe520dfc4eb52d69333f54880505e25dbcca013531b4c4bc00551a87105d1d8c18d1165226223a4524e828cb0cf44877979ce4552e915a7ea3914cfef9a539b17ae4dbbf85b4b7581cbf9ac79e053e4cdc4a92935f1dfaff0bda0f65caac02d8a9000da70893935be729f65ce12eb0208f58b2790ae1c1dc899b2904b50c85f4a3d52c36c4730b3388759e7dfd46906d5cd1e1d6e19effd07cbedf5ab9506735ed91c8fc1efa02197500828d8c9fd4068e6ed55bed0cd519ae698420b80f22960cacaf552bbb3e002bb1fdea5b6b3d61ad0f64ab0e9ff32d0839454ed6d663ee20921f0c6d2b33d1622589f61c414e54e16ebd97445af386239dac1ba56266da2479d44d777604d68c1d34bb2f7b51770cac37d0ef219d0f9307fed244d50ec67801579b8b500dcb47fa02d6742d7d087e0eb06479a50d2d9488c41459959b1fcd2d82c3dcfaddabafaf1de318a488b5a7f61548fecc89520fb36d113c1148b74d39a3c5ab7321edd96094e374d6db0ca37360a7bb9dd0191e5bf66a604ee52c928de1d4ae091d4cc4e408f8604624aa2523f32c2108f7d205c59deed3ef9d4530c114a5bbd98584923f74de94c8032c0d0879c8cb98b8d28c7e8bc09288f90e33caeed1cadf2b45f0d98dc1dfc1d3dbf997a360be27bdbe322bb180fd971db2627b5cc70344c3dc8ded90742491fea7ff4bc1c84c09f37e9c5a11b7a91c8f6ff12e38b559ca1152f44796b1a3270a009a7611a6c144d2aaa16ba11b7eda23d930254c68428fb029487d15ba540a6d41a6e3e082d9879d60cab471622d833e9ef42eec9308f3c45793e501dfe40f8f94bafc972909cba54e7ed9bfdef67cb0974f9c4140817b60f64dafda6c3348b3db942030a1cbc04d351c31d567d465e28be5ba85eceb9240de9922a9187b125ec339d8798f19cd84c75fc9963d21735c8ef0b4f0038a31ce7547d5885ef0453df2644e3e502f912bc0179a8c54dceae412290d76796082c85b40d89f11b1cc13398486320175a5cf2643e7a8046db701bdb38515a4e2aceb13139a868890552ad63bd94722a44cadbfbe60aae02e2250ac25842ff19f3fc3ceabd085ca747bacd57d626d51db293e77617cb83ef14f4535b4b8051175bff13acd03a4a2e1b085459db26bccab7a96f0abdc2ad7269def9255a5792d8fe082104776a8cd83b7e41f86e5609dce2949bb45abc4dd9960624dee56adf961f3aa14602e76801a4868833744668c67b0340b9a0e2a6117501f78d6b4d216df21c919098e6ff77ebacf3169969f63479b1a3a2102f113d6df157e5fa253f25fd1cd829e5c441b87c8f9f7c9fce40580769ce220799c2dedfdff0ccba0df7475d2ecaa31818e3149fdc90a8d0d5b3a6e41685f3fa89e8b4a88123cb45c367f9d0b433972dca26adc4a3a21fac785d40e3b842e3cc9c8d0c6e94f6df7b24a15c995ad17dcdaae8166026d2313245691a4563bf720fff4ef0e05a13540861b598eae2eec33d39bf270587385a456bb2a618a240f6a91afe4088f9ab072a1c8336bbef2cb817691c31168dfa4f856661e48caaffa70836842a9d9c25298a3dd24080dbc151a9fb1e8d1b0ce35b5eb8bfab3e99a0bf4f61218e10095b076d31277dbd66efeb77a8a881fb05fe24dd282b8904edf3aa27fe739e8971bc3777eb98527199df69dbc061c654cfb09ad002ace4a46ca397dfa8c6d1b6923bb0731b37eca2e00f39857d180166b9a5fabeb4bfc9a01ba8162d149ccac32fcbeae7ded06f92d30b4040e1d4616464fdd6419eef708fc7f0508927f46b6d69e1905451c964cec3e41b051aa5708eac43b86eef6123a8bb401b511e464ddd18b2ed10137b3a1e81b43867ce9be33d58cfd0a3aff3d7bd5e7aab731c2744d832ffc2fcdf790045cf11d1b12bdffb2565fee356c584739df64f310518c148e85eb1697ec1370db7677ed1d73d5a4c95c8ff4492f5230378fcadb5c97588b04870d8910a2180cfad2128b3ed6945f5df3889deda96a6c105b6927405734faea2f84594f971b788ca6af29f06f75e825c31da2bd67fa0dd3078c5759363199ff0fe10c7a7c0cdc526dd1c32f728b9d9d4a4552caa40df43b9bfb737e9dbebac21dc20f94d761f354b31cd53ea31bb076c8ee53fbaeb4e0546bb384afd7ce49b13e59d5c794b3d26b0b37be55f4310708b4ec0365159781fddd4bf5cc3c5607a8e63577eaaafe504c3f4c3251be5fe80d7828799ce492e4017895c3e64d2ad1d5cc9f35135c20cfbd80cde5d8df6953c561fea9568289372d1727dd4f9074d3803ae7296ea835d865ffe846e2513f53ff682a019b699e7fde475cd6e8b8046bcd178960d7af238a3ffc8ce0a28ccfc05699637f12eaa86427a07474c88be8e6fd49638df6d7f7d8e5fcf3305fc501481cfe79142d6799542205d8abeaa63729112d3108e2d88c3f3366d89c44498f8ae8643c0af48c416c5af9942bfc1a0cab8d9d3d929d634ff280326dedaf5e556fabee32b87723a9216007766f8093f06f89e35840eb7d42e18e529b119d19be2471e88a6925f4d60b955b5e40f668395d211ff89e074fda6a5862f815fe3fceb7fdcbb9f922c5675baff396bc2a10708e1aadc28a3bfe62d2882ffbe7737c6a441e4374ce91cf54a6dc0d19d66f26bc99e721137ea39a0760727fa1de0b1f629151c0479ee803411e485a8f68782c11179ff5cd92ca974fb5e38a3258a2429f8bd7c4b248b86781f3a198fcaddd1942e009102d37c206c5127e7fd8b16a1e2ab45397111d9d7a09e3544bb81c8cbac22727f2e5dbd707eeb51610c629e0f8218a9a06469d80eaaba8cd3ecff7799f88e1424f7e0e1c2dc09f6b63ceaff6f2935ea6249a25559e55725b4213ce472d5b74c7811418562cbb03ddb132a57b8fcb45011f01260b5195edbe06e26ce74314820004f29624fdaf131fcee34d62ba359138ba137b586ff84882b10773c090f76a875fa5b6ed81f4bb1679db97c9fbe1b784b0783816726a73e76d0e2d30d759b388b32426509c243610e9f79205672d64387b24d17dfb1a883a2632c6e1e43a7a795171797c2b2cd261946ac17d56dda2e564322d8c464d39a02aee3aefa2a56425cc030aa64158459888624a6a78cbe4d13a5fe73ede01a798a2c7ecaa4035cb224e4b677a225bcce32c63a4e804e788d2dd38a6415208d975e93d5785b55a958d8b072acad5a005753b89d05f48840677406f44439e60a083befedb22446039c6fe40039933e7878fdbb0a6f2ff62a56b78ed3b65cfdc73118170d28442b2510110b9e0e7dd455e6570274303653235ffee35e7e60dfdb5bbd72a65a138b169846289c83754c0f823e3db96f03af6a73a07ed69dfffc466a8000103a5b8d3dc8b5e263af615ce9c605cb097c5ea253f74483e1f76166bace931f575ebeba25428a61bb943f9f159f49cf7b0893cd02348326366dd9db405771583a8baa8765ddef92169cb4cc5e49688ac7b52d53e06e82d337e2b1696ded0c397964ad962da8b6200e6ff20dc4b321bf9ead218bdff45a489084d542ec0777705a74b98fe7e290d4d0c6764ce63441acacf00df6850576da77d03eb5d5eba2c1126d4512dff3944c406eed6827bcb4983d93a5727926de865e7c6e5283c69ec378beb0f086348b77c1c1cd218ae717bb0b05780381e688463d1fd25f70f3e9dda974fde1030ee2e410a06ffddc829d68302c54cd9c3fa51eeb7a0eb8e45e68af422111dee3494ffaf320cffdba95d8e03e896495d4f047dc25227c2428f16bb38f4138343a211aadb3adf7b3cc5816df299161a90295fe10a10fd09cee2d9e8cd1173a995857c4176620b3b00211bfa742df5d80a11458a5c24addd7377078dd71f845caf8540d21e0994fb709ebaf7f7d05e34c20715457730f38eaf6ac1497dbe8f907a90929ed79491865e962db1b314625dfbc795f143864d56960963d7f8b61c2f38a12a6d44f3309e363497dace2f2589d3cf0973e63a96f1a251db9ad2ced4f86bf41a95aa1b50619ae879ea8e6229a3b4874d1fd1c41b312975fc31f19dd82b0d0ecb4a2986634a493d3e661ef3ddef71b05bccfe9c3a19723c4a6a82129942a6225983fe49cd743ac79fd3c5c04c3b861949a2664c0cf7f8078028d58bb550f04f33ecb7b6130f67583e3a9ba8dd28f00a4788343517eafef6dbae64eeecacde6365f9cc62ef81047d69edb5cdc9e6e46afa0b1fd4ea7b34be895ef7b7286b6a446fb7702a5f23bee2c8483300312374aa5caedfacb5be451eda5acd3c70df93c362b1b43af6750266369d822c994f5e3a154bdb3d38eb209ec564a76a4872b5e7d22fa1f3999b8cc5f867f305edf84235bd2b29eab4a20bfc5f94f50fb49a95f464f490dc2bd65f2e8982032f62b81dbdd918f0a72d1977eb306135502c29b8e592461d52f70afe3cf2e3276725ff717e73c9fef4853beb374dec141a4181822d32f329f4008a381847ec82a458187b31bed2254d6ec8b196eea25370dc514577bfd917e990f052519175506a3db9cda5eaed330a5a0cda1287422d72b5c7402a04b1354cdb0927f916865e6f4bdc904d2db62801c2a889874b69ab639fc8505d9e3ad0499603af0df26b32d04e85e72d44bf9731d35d414ccab82f21ad4034035feb42799ea84ed0aaa1247308cad5c266565a870f675c3020a67c7312f52faac371c46a2d3c6251a1ef74a108fe203df9b8095485c213ccf4595323449af6d6c2232555ac8bab43babe500df330f7e07988e0b5909b63bb0b732ab9f1301bafa8ebbb38f49f5dcbfe8469020f9af7324104f504535942d6d41d16086d0c19345cd682a3d7f6a313d7c95f9966fd5580e321365b62b9aa0ccbf1a606da85002cc07b09e462c482f5bdf6753fafaaa236880fd07d37cb78b4a4a6d2c02e3c21e1907ee248fb64ba5e36ba29d7db320791283b36d77a6475ede3c01f3ed0041cb87a0a81c31cdf631c20211c77969a1d556fa32bd2499479c841618c88fb65b3e0259a95fe55247fd0996f1f432d0de57bf93cda2df04ca7366c123677db2ee978351c77d1c18f158b504b2b8d0ec0f68d06b4ffd9d3b4f63625bbf8d3bbe70e9093623a7278d12e2a1d5a40cd39d5cc9170816ca80fe2ec9183cbd503d86acc11dccee8252cfa6a582a0de99b0098e6450c00b03254fe9536e066b752ed8e04aa1d5b0d54928c2cadf1d5df6ff4aca4031190b900ba46064c19756115688b1ab185e33a99fdcaa2642684f6e4969a932c35d10d906a7c2a8b2b8dbd514eb4602bab18114503910248797f6290183aef56f827dce338b54699d6d8cd43be8f4917575d0ef5d3070b87125ea0bdc3a6f4aae80890f447ddfe3fe3186999995b50ef39803ff48ba7c823c7018dcd3aa9c76426a65bca9b258be0e1ec83da7558a76dfbe9c1e971c7801f90fcc001a61c24f56a2cc96b8acc248215dfecaca530e86a3e5b7eed185feec78e4cee3d7c4b1fa29367e7ed510b670e7bb4a3553257e31326f9e334a33f95eceb9e7e95e593673aeb4665c34f1d1aa50a33d7dd5acff03af7ed2c7f3fa57d66c1990b79bbfb0d355df66e481932750c72064e92bb10d402e3416ddb2e553d0a8267df92aa9a5dfd7edd2933258d7aa4792a97f07df759ffc4f7f3ddc4fb7d5627eda71a38d2343d526c46295e7f304eec3fffb4bc6491875eda60f4ccad31b54f2210b5d67c1f4abe846ebd24660c7a0337664d690e446f85a79926beefa4ff49f05b84f5d39465fd74972d7cb08da21590bb329b4017a5f3ec7cb4eaf3d397cc3fb58609903246e663248f61c8aa047cf058beecc8b075034b3ed402458b65360d03c9795e1f9a011d5da2968218b5b80ddb77827430828586861438e49574d06273416b04c0add4be5c33f56f5fb6941ccec7a1bc644042cd56467b7d4583632d812cd61b10bc96141bacd3d1ebb6c2d04588ba728f382a7fd3ee8afc6ebbb85d1672fc5d35cca26af341b04036e399f26cbd73bcfd34b05d9bd25353b2c7cb7aafc19ec147f7fcb342f055c23339016f70eb51ae2674cf502beec12edb7eb1feb068bd44e9c76e62c5a04686afa188febf2555360b7f25f8203f9e2af9704cf3eb03ea29a718d9c7a648d2379c4d4e428b987f2c47362bcba9f7af86a7eb5e7a6aab440218fb75abc324c79f7087cd61df57146757b892622731b111f4113a03ceb7e02e3c346fa97036ae12ccacbbb203ea9a5be8766238e5304bbedd839f12bdc3d6e7c8887ba262415340e98946d41a9b0c0eaf9234721986209b2cfc3f2267eb26a5b027ecf1a9d23bc70aeb925a10fbfc32b89d101a556b06db047315a33908a090bd63cfd8c6e52b54acee5de858b02e9c347a2814c3c182a35aed448b92738d56f4a4f922176722a1955789e8997161c0488fa108f1ec10c36ed6ab2f653f9b49223a0233e8701ba5a7967c5235115feac18063c28d808ddc0354c505ddb54600b2b03b7414acf611ae64dcc32334ebe949cb3c1a787e6877c57e6645ad3be4ef3b224536f09ea856c0001a162467bc5d718b82db91d5abfa7b52227d8f38646d64bd55375430b9a2dcc9c5de3dc6fab3bfad9c6053df9f8241424f56d2a04b7d6405adb91e1483d01bb62da4063022de832d490f4766cdff9090cf074e10e638e3d4a263ca8850b57e8ae923c9699ec6bbd06f39d340c4051b909b03d566b16b3ba4dc75f7b66c399824ca7f8ce86c776b7310c9e087b0600a8e3f6e5d61faa327130e72e5e2c22abc8ef2dd89121fc4ee0a9918f0ea403f87be3913d738ff454a7924e8ad691d96c690c564f7c020df150334fbada08e8e71ce1fe6f0dba3c2781ae0f62de270edc733d1d580ce3a661138e998fb2c0e8d2f542c46056d514df012eaa2fae13c3b041223cf4488c93bcd2bae4fb4f5d53f2ef74f8c1dd0ecd3fc383f14cb83edc97ef4669a0864cc328a04a45cc8515d2466c7b1277d8fc4f00a09bd508257c15d254f7fa22ceaaed431b6d058157a8b1acc024a940dcc1723188c8b992a564f375981f65e75ec85a1c6c2703f021996850236d92f11c3f5908577aeb0186199808b782c3436d7f396645de6205a6afaba429f4a64f5362dbc31c46d91e4a296e159ca7235a5c3197f53b37a480bc1b690aaf8cc9487bbb4c66c925b2ff167f5bfa2c3ca81f14b7bef9c0dd09ad8fcbfa82cf016a3723f931eb30d2d4c39e84e81e68260264796d97c8c5ac40f3abf26b3ba898cff038d966a6b59f814ceb2de4c297ab805e6eda72bf4d6fc42472c60ce9dd897a58258301a48ddef278cef29eb677bd617574e8eb04769accdcabf7dedbcedb4710552ea9890055e99ffd02cdc6ad62294df1ac761a657891b5a07623cbf075845dfd1c4678d02330cf46798c94c9e7f29e24e329896988cd2bc5d4cf37baef20c7f86e0416f0d721ad8b1d4d62ecce79808d7c5f50d136c57506a40b93bfe3d333efda0996a609f4121bd92013b617f3d1cb2986ff5357f0c96e93bcd7ebc3772df21054ee94b3901d6658437e1a1ed1ed3499431ae2239c9dda5f3608a921343b68d48676d71090244e14a6cb22bbce052208004bdce5dcd5c32919e5cb83dd60d1d8d3ac3e5ad31657ee87dae702149df99014debd114a4dd4b6e2b7d67ff7ca047c7ddd87ccd9c40a8cd2f6e50b0132c9de168833c9b280c6522e128581719dd417e52cfa323d0a2ddcdf51bf016ac3bf39726320cc673588c6f861c4687449c16fc5a8641367db101cd87bbf516ce7d30d68cc8dee2a68398a077c091b6cd3a86f2ae66a7f8ec81c4e7947d609dd08e9673c4b08e2ee4a8b15bcc62619fc6878d2c8d41538c0432decfceff339c486bbebdda517f4512144e9cbd7002c9cca92c93321cd3c852b52a284864b5b23afd81ad3578e93658f1568c08a53ee081dfb654555d7df592340423f6ad844925e586c5bb5b80e348e874e20c504316189979c420b3b30e6e4b382930a02ab4cb7d9ff64bc272ebd4d0ab3916d9f36b332642d716da8311afea0ee241ffef78982752af331f1ae6c851f8e4eb91ffb6ee7d115a5537772c4b27d999abcca7c42a736e86c44849f2b22a15dc543ac54a0f74e35b838074c37f6a56015c5e540a136a3321ddeaaedaf18e162addfc5c165f968c7a6e162f839e7fddb1a250b259283c771e90454fa797d510a328964c325d944ee9cc42db380ffb71e384bd1105359bf71a81a8ee247ef15dc49f897d0cb8faae32b77b9a41a9163c4d18f063ab6f41ec6beede97b0024fa3de06d22ba7a2c4eb4cf5d2692bebcc7da4591b3546cce21f26ce1446e9a24546e4d8ca9916a731ad509d33e579f54fb2de7c7265e39bf15101eb898d5b96303950c6e02a698dd0bd51c9485f8e798a2509a022179e1dd365f28f8459e646dc53426f77b9e4fe26971d925d8543ae93a8fbeff72597b8d0f0fdc466526c025ed13f0526ee916badafe3cf5ce43f4d6d27a38070e4eaeb372dfcf56c930980b9b391fe322ae79d09cc779ad9593afedacfe5b74010ea7f97562a14471f8f5b4a676acf0501ffe025e58f386437e540d29295c5f1b2dbaaf8f1f8353603ae374dafe89d0bfe7a5d52b00abaf9cfec936a2e8086fb98fec2b22cbf1cf92d913547c9869401f171b02494462a423fcb874c5bb0f86ca2a22321563a6d86f82a7c970c4b8fc16f1444360fd8017f2c84d7a107c014c1c9b1795e9fbbb6a4c450c68779748521de120f37155e049e26fe89c73ef0dcf0b0406aec985455965c879bb5350f84fa6fdc9c1d4101e765288646bed2ba192f09515835bca6f13b94b359492fa0b53a3558e1f486a864d5fb074d5d46bb24a781ecc8ad802ccad604d0b5c076b4a912d17101dafa5cd0a5da1aab198470b14900418592e941fb1c56b52c1f07e50ba4a6bf7a5e83b1b72d438055917d010bd0821656ab7284d8d13585c2c8061182422e63ba403517e03a3ad57d806643645c19e14ad284ea5cdacc437ee6794f3cffc7badcc567d36d","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
