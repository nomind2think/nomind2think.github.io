<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03cf18949df04056f802706e14e13bab6cdbe83bd59fd227f260463f7228ffa1114d63b22bf2035ed954e7d6557c107b5f7a18e192dee6d2a6fb7df29bf49f749da29299f7c5128d732161fd04bbd4ba6265410db546f38f17ab74bf3279494f952ada0d9e0652562b5d18559bc4fb6b3f4581cb87093d20956f7c4c6ab295841cc33c23fb86614d3c3d0e449bfd4b5aa576ef083d50834ab071aed5e76285ff33895c609323c33c06e35283905be44beaf1348624f562f588845ea7b25baa6619f88918826cb7900cd4eda478d39068baf0c5d6d9eb202218d932dc165f8dd9b6ac406f9c08274a4b4cd7576d8effc4fd9124b4a7ea7dfcd0a7c3b795de3a84ad20a4ded97863930ceebcf058e6329dec8d78e831c9c2d607c3e94a6545fb115b6f0bca9038276cdc80f15d7f9f99876fdeb1f47b345453574e988f81e7cbe33dd151b72653de3ca85f14732a4f03ffa68e751481c8ca6794ee9391a1843d4e4a8746a77e689ef3d70e6114fc22146d9523ac91dd910298711bc63b6f7bd63d5e264e1b08ec599e66591ba7ad0caccc365b4da1e4566d6af21c4111cd7aa2fd5b5b00c9c0d0108cba11c5966f9a7cb5f610376d4bcc7a10626b63409d4f0ff5774edb9336e81ae914ba41745b283c1011bf5fff99dbb8d7ed3193dd4395d72209436885929548242f99991f7dac5aa5f06060b28f7efef777b7ca085276b14e80bb34d1dd75c6ed1622fb7c9579eb922a8924722d6fa0ce048126af9a65518d9d37f520cac807de1018fbd33eb03db9a61d62694681bef47f98f9c973b0e3a41803d0c0f028961ee972844397d59695467a10f2d6c36feb464de401c8c244ba4f396b99ee4ba272795df55ad1456df3043680a1e483263ae606868044e647790688a3774e2a4d6de493549b0b3622db0c7687dcf6de31d2ab5277457d4499a2ab5882215d38ea47fc2a490322c4ad23f53b9da211849e6d19bb9320d11e93f9ba6c664add74ed78fe9b28174621221e887c8665f849ef4dd49e5353b3fa7d6fc48d242497a6e76885395eeabbcdc73ada4d77fb61912cc880941e6bd5830d1eedb101a168425d246ee09e2fbe565ce122d48f6a8d1b51df82a6c6929b6864dd5d2366aa28d52eae3e6f0cbc90b945c6af64e691edf0cdfde1f0b54405c3fb4fa4a3d48526c5f0cc1a27cbab45bb98c6f8d9c2aa7228db8ffa728279df7fe948185030baed0c8d6a73d9b87eed6021b610d33d6d60560720cc3c83d0de7237510ea8019a93504ebb5c461fa5ad1be2201ae4741156cdb0dcf86e1809de3e6e505ae315ee79891ef083f9d244051de20deccdd73830805e653f2bc0492b2d834356ba65c6fc4bba1f3e714fdef6b846624cc1f4f400a02ce3811830cc856cd5df6d429f5ca674d0b7ef723dc253dea072dfadf073f443d0dcc801b5a80393f9d1e3348dc81edb58229182d176fe17700eca51145531dba319f7fe5cd52360636e98c691b6f9ffdb63d2180d4c58e57a38c58e48b94cb96c9543cf45177976037bb6d7ea623b8f748d267b06fe958dc37ea4795e6c5a10ec6a0541467a57e34e4b949330de53140d941ca6a2ec23041be9f69406a38b50751257b59110bd49add4767ca36ca27b470f1d82f7c418baeed41ec1ad06b58152e6f22589f7b30f50e5c5abaf9c585e926c1001ea38b77f7b8267c5882fbda0e6cb12891a2a517f7f580f0226d363e02d7e204aa4bcba47a4da9a4ef966df2915d1768da69c093ce5d22151da22bfb261ca3dd30c8e67d94d5df01061e868c0bd2a51dcf46b1042a4dacf97e68144dee4c95f8abe5565e28ced1a9cc2fa3b5af8ac8ffbeac3146e1c24f7b19860ebde3e4c0ec8d95f53d6302b1306f2162df1207bad226a038affea3d78d99d016ee8476e10531b503c3365d5ab4401814e64878339418a988307c38a472470538adc1d4b7765f84e9cdaf26572a20e1b86607fbe844a1e2856bc5e645267ed1d7e6210cb92666062a0d613927abe2f9319b3a6e4c6ffd39ae821bf2073b524ee4c51dd542c85d4a5f92d22385502d9f6eb4d2ebb04187c9b715b451fb6c9853675ee03f7ea0460636b3b02faceda91ced3865aaf9cbac37070025f62e0d72a605af60f5c7ab5129833542a7df6e8b430d08ed85a925f2a198326911e35fcab407b09ff08fc1d59d99cdd74aa330a98115c11a7e800cf746d290bd3780ef15b1136c2ef26aefcb2d259b8ca2d164e4887b215147ba652c348c568eb2dd4c9c1099a881403604c7bf242781642526d68e407c4f6f44fee3c0d028d9df6b004ed2163dd5c7f20c0396924738aa8c78d89f8a3c77090b6da60c600bd89cc729bb8ff09798565d5a2c1594058b5e268a11fb6f6dc95e004a532f90c95ec532f48b924155c3a65435ae64d165017da01e6044bfb7763a247b731515db57be3b581806b044b4d70430857ca8d0e4c027ac7ead1b5d6d08ab45d4e631bb49f3de53f43eebfc54630a598fb5225ad584c5154adcac01a8708d6c86bc7b1e2d98199ca875d65d05de0c47d221e3f580ef40c9ef3fd0273aca66158271a435c1b2b8c9ae1e7e1890d0f7e0215ef6c679df62e3f2ae8b3ea28f551713efe28dd1ab65489ad41ce512180b634713296a6349c2b81706b0ad2b8f5ac6bfaa8812b46b6bf5d14443f2201b7ec00b39013d87073eb28d1368c437999b9144a45c297ed41a1c8e46a7d8d94e53e8b948bd5e37a586453f003033ed8ecfb98c3a850db2e87439e403bcffb706631f866447ce09379f0f266f9ebc1713f309d36a14aaf6f06e49524907fcdd4f0387422676cc815bb793d07f6eb04d856ca99ce187510601a4d0a4ca18240590381bb2a6407e042b3128f78d48cbaab317992356f3a306c8567276e83b17c18e311a4fcc4b9ea8ebe7d55633b107882efa9debc2bfcc3fa347a50890935f9e9b3ec086b99523bc244da5e99e8a6a740931d0bfa1546b1a7280b2f45edbf1a6569627ea2d336291e91f27f5bd55131630a8304ea204e5f860fd681dd1afc00527036ac3d0d0d131c033b2f485f436897cfc5a34ce3cd44bbf5694ace46d92d4262afc6be7dce22d5ff73b3b497fb7097bbb11c33202d89cec2926d49ed61bed9b599e58f33c2afc21e288f5f9c05c8e31fabc75f0fb72c3a5c57a91ce9d35c05e71dd5f6bab84313c4998bbe00ba0990b33a122e7abd671b7ad41815b739f8bf91f3b11b10a1c687fbcdbdbf47d64749d569a7b13bd2af8678c64295f79ddf0fe8f797b853147196bd123c3f1c25f229eeae2f973c0e31c52c6fde2005027e7868ab4c72379a49c581f4aa51e5d5b27fcaf5c5470240a6007a7550db11b756addd0ae0b625724b88f0ee8f0600c32af44d1177ef5b2c00d7e0610897d0e788edc845ef038fbc9834d5d7f2eea234d63173f972062a1630979488ca89e7c2325166db7761de43aaa740865f4bc0a13645b9e698573e962769871e4f9f112c0a6a5e161543d4a6fcccb8a3ddd36021283489f75352daaff0c2f2fdfeafc92b1350557b6095689ed65bd67efe34a5e992b7b89034d07867a48594ddd6d94f6887ca48ef99bd21d8d35135b5874677b3a06740236849dd7ff692b1dde5cc7a308e5f48b33d807784599cf89188955a5d0f84726835f8273678ed0b307d2ff097c3c581532cf167282ecac08e1de90e0f99465aacee2bb296c36028d9e46bc6ed2778d25354a51a76b1c622d2d2f5ae576d1608fa778e3cb854a0ad617cae3530fb739a2b67b98b1336c6ffb51e443e9b28bd4eb6be7e11aa23b9efe4f2c7d8f9ed3fdabc16ec75cb628b2d6d842c9799d404c97914d6a629043d2936b3d870303c578d70bb2846877cb571b3cd772e57cb4fc4ecb8ad4c41bd496adc3cad460ad8da5960becfd7293860ff72f5b19d246aedd8a4b14be4708d8d94acc57b9c76c72e18e7a025295d2dd2b78c2c202fe07f929aab9555598235d976bb50f41e1294c9fe791e086709609d9942ea249e176da7e48e30530682f68f96090b489a35075903f6196de2caba87364309bce15540eff0b0f9fb2c701017bce4f010c8a65010a44f443d8f787383b64f7f808259a6a67baa29c628b3f1a363d27030c70945ff5ea8e6e2220489d62e8d281564bc0d04a9c6faf5aba78400ba267a22561807b85360c9ba6634f2c226ff1773f06487eab049375bba36f0c09feb276d6db3331c3b23a491bf7617fb2251c774a89eb29220d7d0b902eff5a49929dd41cbff90f6bf745ec466fe1aee3280de435b627a6919d32f3730e522792db4699be75faf5c76e0b74be5237e51273d4d2669599c429adf48e3b35f634da15b16a8605039f3c3e78780bab2420023073f58177d328dc3ebd183fa0d39eaeeacc147b1cb7722cf3ce1c33bcd9a53bc98fcc9a161e0dad68c62e120f988cf1d53d7017f1b2c52363cc0ab830e0b2d0a3aefb16f60b8e4e7845b3ccd8a05a73a39f58d5a49f8564c49086d810e1139d69150da14a9acd8299845d840613a4648f6b5e6d1c160cd7930349300f4382744e0c447fb0e50746fecc2e9020fde4f2ba0b0278fce9fb05e75ab81c54eb69197576d90c8b6131676ed136f31d6577f57d72066cf14cafcd707e3a304f3f44b60bfdb7580f5a1ca5ca3d30340b4a099f1b9069f36240321b206c55dbd0c1d2aa5a3c82aef5c3a4caf07f94273132a9d99b9d884fd30e141c46ef3ac1af3264a18a31f2f8cfcbce9d0d05a7ef9956bed7d2572c7263c9a2ee1bb096976b0096891acf1c9679102a8edaae8b16dd6dd32842ed144403732226b779cdc943f9d4339302b0957a675e3049bef577fa74294ee1369ceb12d7d397a667284b88d058ca165d45cc952012d17dbe7fce3d47a0eff4e5eb54dd99a056bc7a5381c0541cc7c1bee2df2a9408e4b9cc862a7d71df7c2e36b4174dcb91724037198c1350a7c6cd8dea332071f101367c6bb42a3f9ecfbe7f623db5c43b7064c781f436e2fc1002dd92b9b8021603f328f0af363c7e7746971ac6e4e0ab9107d2a4f3d011370f577ed2d004135caed50fd18d18ba7d10d5030f2d9710de11398cdb26895f36be30921b0532dfc214982ac10b4bc547f90a5436022270caf86ca23acba8c8ef84c3d43150b82f2bccd523d37299d30da8ace27a3d5efa83248763b7bc0d9dcdab23e7968d6d36272e6fd0dfe2b2d824c805dd140b194348151e968b5d42ab72cdb653417d62faebed0aa896fad53ca5bbe10111e4b201049ae0e00a5b662e4e58aa97f4fc3f1937ef8f6c330f625d7ee738b1b23effde36e9ec275f3824c5e96d39149204d3eda4cd3c26cefb596917917a4819a412b154b6fc16e1eb55fc33ba9f535cf1950b4950b25107e25f2ca3326a674b77a541a0caeb387b1e896e5cbeaaf79a0c3a9c2a57089b198597751832cc37c10c114a6438dbf1051d784a00eaf13c3715dc64013832cfc21eb40687a15621a567fe16b9013ad1f722fb5ac8042e24cbcdd1a5698573e0655969ba83ba8397398b34725a10f85154748fcbf01429548f2746b6c7d94b1b30bcbf42febaaab7ae3bca66cff3899e5bb87dfc69cd3d87953f0cb9dbdad38cb25102f28554e354d6853b3c37b65ec2f46309e9be6f4ef4cbd54f9115f0a8dd8dff3bd7b92694135a217418adbc31107a29511697e7c06ddb80e38b63dd94954a9a8b668421f6ad5662edc94786804f99eb54a99144e9b3f00b42a2ea96845805b0d10385d5c46e3d723ec174f6e3a01aaaf80593068e6e9328d5969977fdad04f680d7b097dfff9587b50e2a0e217fc8be3795bf57b44caeea36f64d5b64fe703af69512ae4547cd052bff77ffdf0c85ab0111a70a6bb57cd8a4e03c824936a896b7d6f28841999cdd360391de77fef2aa5bd762e3923952293c29f4e5f21f07ee29268748bce7253726635c28364287dba3eb4ffd5e04c2e79d5adb39347e1f7c6552f1daaf9796b043aeb3359511b13148acfb4ca8db734fc50760d9ca0268768dcdba195b5f8e462567a683a3978e651fd7267061a59dbac95c70fa12616ad31aba3fd63e3aa2b33633b471e1394aef0171d11aa674079f2dc4f8d51c3fe37b0e4d7ec8c8e35763ffa5176b0c207bc425209aae5fa844953ec378496742c682a33a26f9a7a8102832d48d307b2a37d43c69ff8a57c3b6a2048c307bc5df16e693591edb81d6ba94230aae80e34a31a059fd1ffa39ee3eb92588c4e064f5c72c7f5b5ebc87502b67fb3e3e0b43d93730b669d06bacce193b543e58afd14fe45ab91a33eef3659e37e20ef3a0e822c2696302f650f25bb33e8ad6ae812090a6be52a25d53309571e2a3d3d30d92df777a61ae871f87c4479c9f80b32abf7a9fc610437b5d52b6cf54d4247d2e7da9430a48660745815dc28c3f85f91c84704c3f1b9890c05865053fc6711e178af04d2746e060874eebe15ffde7869106c039836a43d6ab6c4bcc6bd8ed6d3b8b6713cbbdd5fca34c82a040de37ede68c6a55e153b091fdeb128317a7868a8ce64de052138a4dc75915e19c1505b582cd164514923785db702265184f3e1f3e9971e773cd86acea57e29a9e19cb38494bcc82ec34f8e92adbefcf9cd5dc3f663e636c877b487d6703062d4bc06810140eae72f866bc52966c4e32522d61c02fa4816b53c515b179a7b87f4179d9058a82ca2dd1461d046e0a50c83f2a6a0d92d8b001dca5b71f3d3ca22acd999cb4135343e5ce5a866f5124bdf4bef78aa9c95122048bb9fcbdc8e84726084573c038c7cb09beabc1a9724918a67deebf4a6f921661f88f0d5c6176f22a48d76997c3485a62a37cbd7a8e76c1a8c36fdfaa623fef3fee623a7aebac21fbea5642f6e61ae92179cf9013ce4c95bf403eae9a642118eebe7a832f14fc9b66df05a9a39af4d1ff72ecd1e144d3b4f7fea174d439b49df376135bdc5942dccc2cf64e800377141e3439c8901521f2273298b7c959e037b615860eb9a84ba8e3a38147d79f61bcc01be5254d8a6298c611838b8c2d87328814f5ce20060129e7d1b2237527ec16e66d12c3c4a90afc8edd34f3660805d9fc6923cc4c4fd02af926d66c3e0d9a8e4f6c750c5835b44e3dbde1280b6523c82c98b14395fc6b02d511e68074b9e1a84acd2dbaf8501b466f020f9dffda39cace73ec77fc79e1d26f069ee4686df160bfe5ee5515924ed823b22ea7b38decdc8984bb7432a594292e16852cfcdbc8671cda05a4c9cf01acf2b5d96ac97da6562a32816a6bd573c5db479cdce489cd797be6f2641d692c3b8b8dd6e9ef7d5f280054a66ffb238e572aa3e052ee8073d3f9723d3e409a14979da9fff3063b63d0f1b5f01cc982fe9f244f5b6f934b90764361f10a6f0e0f793d983ccd92e1bb5019918b1d97bf572e18c9a3cf466f7c5f5d2c7c49aae00cf3e2cf11eaf43557474140f52782f27dd305515b387929bf4dd2267fa8d6cacee4ab9600d20fb548009fa6250305665a5b4abe5bb2ba7bb82e5339f636ba6cb6d9ff23ac8ddc5fba6c90370ea7f16d361fa885900548b797ec6686b8bc4436f752236e3c160eed026a36f31f29ecbc4d68498b4e5a120ffe8a5933d4e53faff852b39003ae7e12d5ae36370da166fca3f090138960ae634276ee9f6a45ef94c1a11bafaa1ea8727d1b5270b80e176c50cbe729475a356fe576abc862652a1adeda1840078633f2988e0099b0ea15e22142ac715c6f46c09f059e813344de2a4e345cd724d188b900b8613ed7f8ae167f557bc26e1afdb5e2e012858dabae7f8672dc886c0aeca1ebffd8dea1f25e772e378b390d920f24dae41800b75f824b6531ca36a6a3fe5294d98b9f32c75dc5ee8200da5c3c5a87bf486ac8e298740415d2d3504cf37bf3050ec45560ce568837fdc85104fdf36644023fa3782661d65fb724ec13a71db1e5a8a30a6ff7bb25c318f694822423b2d0aea88952824717cfe44a21a4247dfd0ef6ec2cda00093657b47d1f1eccfc5d66b6a46cbb50a200836ccaaf141910133c89a8e84b787aa19dce7963e4bc4bfb7074c05e92b6b46fdf7d241e514def700e6adc85ef232ed9325ccf96294ca267151d6b8f7ce0fae28645fd05312615dad1f3daf54fa74b5176a42033bfdb7f902610b0c827d58100262e1637424c5c3600f72e6f9dfc4f54917bb7285170a0f432afa2d9ffacf552d89a2cb8dd50256e38bf354f80193b1041da117f90c51024b590fbfadea568d35c7b714258c7f58be22580362ea324b36c26aca83bdfbfd5d11d23a167751cba4e85f260755689b0d923caf85f7a292214afe08ca8404adc78b518e9c10f952b23dfb1565f1a234cb530e55b88195ac5a96c548fd1b52a186911ed79a4672ddd66523982b0d264e301361e900404bda74eb387b4f1c623e72cc5bbe012026d554c86c6fdaec6943dc99979ba819b8b0b9023622e4832d286bce9df527a39f33b12250811669f5dbdb6197d50b13f20d8a617e279df57344b21e2ebb8750983ba4d0b317106d0feb0e02e98bb7991f35ae05204729915cd60d3bcc60171e1d2aec8d5b9f0334c0a3fde1dd2737fa9519a3535f21d89cd605de039a4fe0e4e59d28877a1e6fe24024608199e2c55818e43ff47e08064cf8bb49cdea82e43ceb17465dfbdfed0095d5b913267a0a898a769f7e589d77869533f5bfeb6e7aa416142b9be3cc084989969ca6a040bb4616bd0a25765640fa880651d574dd92b9c4b8d29a66f9a7da4bb227c2813060fb9994bcaa7ad005defb0378aa72a79820dbb442e1d596f89f21fa2b4c2a4feedec4c6e9d40210b2235c4bc1f14f79cb39c2a2c2cf280e10bae0f0b2784f75b5b2dd983124453ee35ffdc0407595ff36d064b11c08b0ddac723086f4af2c5afc77925b417dd9b1a59c1d1c598129d480b4b878df10ed1eece54a65fd4f3dc4a1638cccd8b098ba01817604b3007e27880c3f22120ccb55af231c6bf93ea4aa251b5f34cce8e4eaf697c67799dc7c251fca0269cb951f46d21ec4ff99fd6a58789ca8c00b398f90b93fbcaec0be527b1022b7f6a2b0c39d440869215295c5c968bbb6ab87f8e4e59ae93e95728abb610130d36d63c6ca1efb99234717268fbbf6db7fcdd4675bec66b3c2bfe9672417f1ed2ceb7d3983f8368c6fb355a41ee1ddb9e7427646f5ed457273416b27621d3ba52ec2b247acfbe11eb3363866a30cda9d61c6c315f86f1598577d139ecae417c5bb7bf0ab0804706fd1fd88ede845597e487427910720e99016589d322767e8fc513178b230507dc374569da83ffd165f0795b1906f295d4dc756066b4c2812ff3b5645d0a1cd504d66d25bec39ebff0cba79573617172d8b07c2398cd8f05817cf35eef094b502a998c16f704281020d3ab2d8297b3c835dcf4cde0c8bb5934f465f3288e062c1443fc036b1f7659fbfce99bcc2921cbde6b02cc115eca96b338822e83e3de2fba6c0cddedbae25e7260d99775ea6344455ea4e3bec208605fd50bd1f0ef1b8b0ac5db817348151b8de3a81a17c3b2540e7c994384689a05dbd3d2f55b15ccacc5fac53c7eb4951dc4e9de5ba8bc98536fa21baeb011e3d4658b09810a8fc3ac1c31d60b0d65a5f5681e576f496df167ccc866f3af438ab0875598f98f114433888c41988458203b503984c1b79454869bf7e7b0b0f05d5bc2bd18a1c1a23592fd787426e126d30d8d252c78e89421d43c5d41d51ee792fb9ee0989d0bbd3f5d52622c480195785104d24e87d3c60f93bb0b98bb68646dda59702826ec1f06f31bc434c391f9faddd2bec707ac5b0fbf79870a86f6f4679ea8aa68a8666c967bcf6d173bfc57a7d581e33c1420d48cd5d30a8282378cf94feb3a90bda99e34eaef644969f2d724f93599571f8945914ac89b386d791a110281ddff84b1bc584d19f3555f42ba4af0d08a75cb11e6c1abf1378b9c82b6422047c0bd20c","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
