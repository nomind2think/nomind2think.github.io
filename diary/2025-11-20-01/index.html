<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cffbe173d0520b7aa6fe23e4d966bbefee08b11cc691a794d71bed21154aa26a3f0437183c43182c418c5397993d398efcf78b613ed32ebf9c9654da90cba959e02f2e07f60fea0e3d902c6f219e1de3f3368bbecb0a1f0c639684ab6b86812415ecdfa9fc1b736cede087503d42ec1d712cc7f9ae095684638b26b1201b425d83997b762634d35861603649216fb56125a2fd10832639d6bcc8cf6a21e9e3ac7473f09cdcc6f7e0c476208b42d376911a281f3cfae11873eca13eb90e3ee64d2f458c9d6b2b5deff2c3da3b25b8e89b33734a1e6ef8559878df89f0fa3b32f53b9dce7adacb59ea3762b3a9c6070fb0ef2018b7549bf6efde156f2928d3d63a32b52b7dc07d38baf222ec2ef2e1b757d5ac110ed44d574411f356b584641eab743f9ffb89addbe9c8debffac203c882a723930b1acf583fdeccb5bee625d4e0caa0ee5a5b28f747db8c4dc9b5d9c8f9ebb0785772b72a3d067bfcd315c7b4719eee76c4d0930a4ecc165f8fc9817bc12b5df671256299b46dc2f15f677c0b7ef07a7b5ae3ee41904e42298f310712157dfad429cec3d0ddc6d51b89430a781cceaf3b2c9582b882935cfbf03848ba505afd674fd099bf1ec9be004b2105cccc110dc27d54d19b718f4965fbd09ba495bbc42615eeb14cb673841484189e8ade95e07c2437ac974b0209d423ede1163e466d01ff2bf143aba232a288a9195d4a0264b77625d67586fd81c25c381ddc722d30202a488865c398fb3d115230dbdfd390ffb506aed9b479d00860cfef446ef65d03af2ab6a2e05eb84589d02159bf45fd7965f2379ed21e9dad487dfc53cbe5f2541cb2ab4939b0e0c751783aee378a01eb8961f81deaa0975a172f1b2d06c00e25553da6c05c817245ae440f080e4ecdefe3b8b229d5e7e3dde12f4e7cc1e1494ff7ebc758d6204e6e7b49060975aed35b2dc61c4809eb41602f0922b23d2ef645070c07af946bc88874968609525c717e94624230f17911a1b2e8f4fe7689cd2eb585484a0e9f0f0339a63a6e4ea0721c1370219e9963e8932fed55c7d5b9546c0674227a1dc9b6bbe82c0f53381c1fe31459a3ee9bcd5757dc4ce9503ed814654e798ff9af43d0c5e4c5fd4e927cbd901b60a09b839e7cc1f7d1e3324bed6ae8ba98c6632426fd26077aab62070fb84373720e7db904023a32e45ac4d7764065bc9f05f0c89960af5238daee55bc874bbb7f75b73f0d6d3ea99d9cb008b646b3f01c85373e1a94d3b2e0b693ecd125e1cc17d4e33852ed9018a17a701f198955112a6e69cf15873acf14c66328f54656a4186bc2edab2fc93ae4943b8214e005eca61e7e898d8ab997f32065ed09e2d323f254f74155481d7901ba0a559da2c6911cefad6546ce90d05c742fd2daa6c6f6d624c7860ec2d0fd7d4de35df965f43ad338389a950084e7b161fb4ecd424c5e10b68e9863c4ed24f61f238c8c627ce0966b086acba6a38f0e5ab7b1045688954248096b0b402f19701c731b5e28d08efd90b3c8babe7e1b55ffd551f72ba4bac9c90924dec631749ff76c7f6374305a3f83328c607c12b25b4eb422135742ec1f604b16f62afae3333da6ef863053b357665c5fd13f2fb5dabb8ef4845bb274a83beb1f22be7ea6d49513ced3a8f0ba52217a678752df1980335759d5eadaa3064cb767d50bff791188d5ca49bb79375343195e05ac1e12779fa1c28109f584bc636790a2f1534a593e1bc67d08c3391899ba058d0a2ebfdb0b93d05beb5c6d27410a80de8f19168a0158511a36a49c80d6ea7fd81767e7578b9f7612346243537ac485ea4fc007a0144deeb7518c672eca3a1b6054b8a9c9d7264ce2abce8e97b2a774a9204f6a726333af6d3a3d8b73d9e455c577d052f862773ec01968389a1e54ad51c92312222d34fb27bc8f9a4aaebd95f34bdbf632c3e72bd2bff06dbbbad460f662f75604f3c7cf03480e1c81ec4e3822454d54ce41a35921ae22ebf32227b03b9b4d8cc4365804e36b831310508ad98123b687d8de073a21ff915218d5415450c174b898ea2c7d3f6fd00633cdc08f17b59e3b7fbc7184118656be4c0e69669122fad0b28368583b97693edb053c416188f710c804ae229e01fe88d731ff0411361d0387acaee0509de14ecb459beda16e838ba17f6828edcf8ee3236357ff4f756e0f52c04f1adf15b8abe4f6adbdf38005acc32936f84b832e07fde090fe8c8f27efb6ae30330c835826086db514bdaa5f062e500f021fb4e5e57d924f4a64bf19889054aafbda69d01df3f394c061a581869b02476b5aad3f8a6289843e5f0dcd74f75168c723ae948606a25bf8f86595d20614638e8466a819fe7d95b77f951bab6f0aa4c070be371f157a111b95c89df80b1d91f33958e419c941d0dbc9e5436d1fca9b15b930dd93fbe41f1e4d1eb440d80edf615a43b90f81675201c7c5778edd4bf17bcc8707809c495b51f3e9b07b88ddc8fe80f769f0578ba12ff0698eecb713eaf6bb8a7a17bc038fec6b213a3965f869b602725c0600fb4d0b51710e4dba427164d2707db48a887097835e03d732d2574f7e058f0a3d5e1d6084c34e07fe8edf5914edb0ae841eb4b3e95d8ef3721692ee43daef0e237cdb468437a8efe1b0e4bb16bf3291f84af94d461c79fa4989276490b5c72c4d7794bec339b20bb4deefab5bc9bf9f059d6ae95dd928d4ad5528c6d9f683d53f0ced7553f924ca99c25dc6bac8eab79fe7140cee64f192405721b912d96fbb6d56f5f4d259396f3d324cbce1fda31d1a665875e62561b3659e6f63d76ee143a4a4c97727f8a0ad0e60dfd29d914c78dc7a54385ec746cdc4d1c37b5786434135dd0cf464e000b17bb7e480266c83bdf50439fc4baadcf0380a0de102444be93e83eb39ae2bc5c6f70b4903bdd3040d57946bd3cb78720e16fb15d6e75c3fd6689d40afcd5103bb4366d5fa3bc4c2bda59a284b1cb99cb76555a15db529b84959f95f400c38397b5c87ca9859945f824c366fa3055ba9a27f7f72012836b8954f39567c238183b42e2731c569d27ec9e13916aefa703cea42ae43fc4cc98372d85f847d4e97a7c9f3f72f9d3864c84752b585b5947b444f865b88af61f9b02a0bd888ac395e1b4ce934a8bd63d73339a4cc5588c879d6f8eee7de36eb154bc687de476f2276fa3df47e12480dc87f4a1335c5d5db4285d9d96194191a963bf5bbb61dd8da57a1f110057c7d8f8660f32543bd07269bcf6cc2358e4362db2c30c4912eec2ccf0bfb4a1eac31e26ad4b55b25c57650234a3564932c5d21f8e76241e53e99305d7d229734c711dbf71387a400c93e7b3ff6026159fa9ffc3b93188b49c06207e665999bc636e87dd77ea8e24781cfd5468a37cb476bd1e24576e85e60a08e5973c794354e6c3b2713dcb60c52d5d2bdd2b2f45092f5fb2dedb010822e8b1510013e04fa33e767ef0093ed97f74ac860649cfd9f6f3601d85e790078a7d2a59655d36c7e194db4aee4dc1027399e9169d49a9f5d0d72455d0b1c3a3ed376275d7c676251dce6cd0e8faa5757c43331468e91c89fa8b39961f4959a0ed9c286f6c90fc51d26af70d8a3fdb710f94a75900c87bd51f9a6e52dba8573bfd2bcdf6e9b3de09ccc765a5fe2f8856a429bd516255f594181ebcd8d36a42c80e03ba54b9f463320c5e88090d325f64e9e6df99fdf7749d5d30f22bda137862420a18a3380a2fd7a3eb1931acfd2bb769011a10bb387ade7ad10903fd26f890a18f6969922bfa2f62fc6927f814ac19d64e256e65afb91abb3c6accb0517d70364caf86a7d73c531f4da57c446deaa9f4adfe85d92fa22c557b0537cbebeebfbb1b22f686b83b218f1eff60b116f31c1230697ca36474bc7e2b84b799b914e64550c99b53887e33ad229eb608461b20ed9df8c168fc278273ef734852b27123063ec99b8e48af65d70313b4985b53b40df9e365c2c486433c00cab29fa9e29c41847137fb946c446af1cf0267b8899d832a1ea43439c7e5ab65406e83ca97721bcf98a61e28c26951ec5c4a100d20357fe2424c8e33cea0a27431b16e842c9c2107f9b91f3cb68fc12946ee2bed1b7c592e6746ff2837282fbd8751a48ed30cb19b82f929c6d41246c8fc3ed4df9b5a7452098bc0e45176017224a7eb028b3f8c8a2f7c1f3c4d4660f71939609d2c5cea30ab2fcd6b331290a84d25b992503f2cbd81f53071ffdcb74f06957af8bb678db43f284a382a4da8228257a21e4c6f023298a7d87e8d38c7312d7173e45062319630b6789652168bebb144656da4245f78817122cfa844cd609002f842bfe90dc8731ba395e16744b9cdefbe8cf2469a2ff5a3f717a0d11eb038535e55657f956e4b285f3ddd96d1a737d3c5e79413a877cdae6b80dab59822dd76c3344082789ad9419efcc47d9a6e98c01b2ac1d1c4f47764d424e52c660c2dfa0490e047b050dfac42f8ab8d57a01bee07f19b41fbb318386c6c7363890679f86f169448f754de1c0f2ad87d281fc2692239ff5b724e7d950f1b289eacb44dc221b0c1e8c2a59a430b3bdddf90af550e875e83f889dd878095041a03cd2f63ea445d4bbd1f46a1c10af33ed32d41674c4edf48d7cf68f4f58d3d3151e60d119c1da5d6d7db135fe4ca31f9bf9eb1b5bb73ac55bb2977985f8e7b6e3d3fd5944f8b28837dbfef36c67a8888f8715ef92e25f42ebe1ef40a5b3bde90f6002a47897fa6a485ed02462ddfafc6d4ad21823b578425b71530b63d03b8fe05809a7a169d8163dae4b59a800801c846b7ec644ba37aa690b68a7d06e525a7b0c350f6f433638f62e05379aa375cc6628157c352dde83d1427994f41bf26ac4c89041547a41b821b28425d7c42100c8ec354d9dad907b4498802a77efe8ddb7af25e25c40b43ef8d05a488dcc2418fdad79b45e7a5099b0312f946f8f44377e28f0464a3639f5d766fea09d4c5d6919a7f3c248f1d437329da6fc1e6a8f0cf4f7dc3b38eb87397c5f10d4d3c0ec05df175543d1c1223ba9313838c49c1c1ed543e8488a9352299d6316c22799526b0bcbcd871f8a627df89f8c2b27399cc3fe0910647c8f1c240456e5a18e3749d57e4abf794002324aa85bad54f454c246c39164e3e57c5c9e890cf5676b85656324971d1fbd4ba801efe1c12c3c4f822a6a186bb88be08d69ccb273f6fb6225c8a18037a00958af9b75a113111866a86f1a6fba456a4710d63c512502fbd566b2e5f33d851893ddfc7088d6d02cea34c0ce69342d36d67e8c6d8f92cd52a67142a95833d70e21f041c31b8af9e4b9e7c68ac82d04d64502a12b9eb453893dfd3690f0ccad996431dceba72db5b16f1c370ef3d0b68c14fc3b0eaa5a5d4fc346afe1dd6df08fc14cccd841f35a6b1607d51c56b93e7d06e2f9d5d7b1f416c7dd29e2e97ead131b42eb704bed8010cc6d84d0cd5fc0f317603ac6fd30e3aac2212302c636b601d56901ebe4cc54286dfeb4e75bee021d6312e3d639dc5efd72aadaab5f9baec27137c6a2e6bf8ec619f110813010ae60763c6c4101c2ff2b9005c00e6f77fb12519204140cfdc3054823abb87579f7d4136b2ad6b09038b1244fecc5185893328b62c573329b8e34c0f73939e54a9b400c46f6c1f642a6324d003910baf8728416164928577a3189d7a6b590d9826bfbba59604fe6ed4807e8874b87886a7516dd1832c977c538bc3b99b26db897d0b398a9439a5c57c6c7e455eba0b2e69b428dfc6ef870ed8040ff983916a65aeb72f5b3f61ccdb749261700616a616030f7b3781444cd4665637f7510a4cae40a87a41eacda30cd6fec1dcd5293b73f82aaff0ba0008f354d30fcca70b0de871aeba97e767a3d0174f0090ebc322b32a7b95572784fa62af50584eedb3466b42548fe319b398b2c46c2ef348e065f102908ea954b047e4d32764e2faec04f72de85baeac0f735239b6d6a06e7ce64448e27633bbec501f92ff07d9eead0225d5a5239453c837c5df04533e8ae7f863f155e4f199d3e2105b0a9b2474e4912aae52f5065ad4132b47e61c856e8355ad5155615f1513749450d33afafef94dd510219c7b5df5da7f9d55cbd4f41c10e633fe234ccbf248404d9f79855f69351f0f9b93732b204892249d30eb118cb6a4920ab4eb18b98b1e506470b42635190c9de6d179a28ad8d0f3f68c1c3f5393cea797edb6172108480ec3f2bf9486728015019f00f827e55a42d2a0f3ecd7514216237bdaa674a93610a8d9a8ef1966f34b80cb980d4f817c1f11209bbff132515708fd3126bf6290fa8ec9c806bf5d724dbc670425dae94af6d5e9de1fea54cdc0a4cc037093d12bb9e620b3398ecb16c53bec7f8f974c4f64824d4523e93b54fa8377fb810b8d657b955cbc1674db3d00225ffb983b5f0cd17b010d08020829422dfabbe70def6463edb0d0f83bff14feb88d4687864e8ec7e81b42b6dbf48f5d3111b508071cf4e5df54a766e4ea325c3d6f1a4e6852ef3180ed3e654e36a727dd0d6d4ae79bcde90df2892005d6d1af94b86c766b24dd71212a63b4162513bf8d6f3dc81ad016c084134e6a62c88be3c0915cd26da332f06d3c39e8f8e444ecc9fb8d6a2d83f5df749b4b639fb67c8d1eee5e5adb8cdf3efe2d7898acb7700d46881a9e3207be7537845a68e11dcf7976dccf3e3e53e02b24e21da1faa7d2c306f7c4bfeb7d8acebf228ac940f3ffc8bc240f66f4c74dd0085052547e0efafb2c202c8c97a6739d27ad7ea06e8874128195713f6ad953b0615d548be90a01c1d022ed1e183aed9c9f709a61824ec32adbcd73503c3dd485da79729b81d0aa8977af2e5a305b7e0ca3dfde19b2837c0fe8acb0d85375f1debfb0100469eec5f056aebc28cd74f3b9a29d79d05a0550f38d0eb8a0fa0203af5948c6be97a4823e47e4fb45be98f4583c86bcf75b791d0eef8f6d83c95a47f2abc16d6d6eaa1c42b3ab8abee769c3be101609f2f0639989790d0c6db3f7d36225fa35731fe66d4b87e2e2fc23099d04cb122f4712cc8cf66069c5b86e7a44646f5a5bd01ed519706d38e93fc3db17ac5b81081d7bf63d2a62677d45ddb776f67107976c2b99a202c0d378d56ebc241ed0d7e5aaa38ff78cf6e44435221d1d73866f3e569471222e965b0fd8fa2667b94dccc6ce26a6deaa6daf00af08c5efd0b9a899cd3e94d824fb89cb96529c0b76eb5a968cb751a466b4cd206f516723d47daa295e82456696fa6f65555a9faa6b726cfbb0c40f78c5c6278f0ece65e8ed0f8d6013c1474a2e772c5e588d795c41e22bf8557c6801f1bf5552423441dbc610c50c685dd3049c092740edd8bdde2e3430aa0ed21e77368861ce56114b658210966e7f0786ea4a7a1c65d7640fdb78d4ad0b6cc9abda1bbbe67c78e957f7f22f94103f461f053c0cebdf7867719844a58ce57b8b801eb395bf8fd6331036a369ce718a08404d4b2eb52c82617da8f53ac40c4ada856f5ed3b19642deee613a5d43e26af55d52d695f587932dbc3474ff21ffe719e4fa78ea4c035b21071275e4afc4f0f1dee7269089da70c9ce90275226cd0c2fa913f0804978c589fb446c4272939e5e5911bda36870f7c9468498d9a255cf4fb6e0a783a1d7af6b900460844cbb826f5590099d8170ee4fb6759f68b34b2976b7f3e85b28e431458e22fc59d3212777fc3235a0ac99f08c01457274b9537de8f54e84ebb085e1a9919fa9b1b70408a9853d6ef3810df44af33f7b1ed9b26e9556dbc4913f3c4b6aa5ffe58b695360b9a2530f31b63792d723f0a3ce048cdd3affd68f6b998a27ba82fd19e7eedbb34ae97b458501bf7b2ecaa072849bb5745c4929a0527c00f39ed5c25d7743c0fb3f360b584fd7491371a1c41f362bc7b6e21e7c193b193e518345a1fa901185e83209119c55249ae8581e4fd009328bfe0342026ba4916c8daf1356fd04460c3065abd0b730aa85df901f712ee1a205c9161ee00fa42aa6b259fe9b68a1d3a88b201b75a34ec36cd069b0875991fa490e455a24a4d39e3631d27097d355dc50f44988c03f1265f52374fb73b98d9de8579bc6d89bd38adea93323ee51b4e99c185eb47cd6498724313395db19257599ff1b7892ed0671c4864b66e713ee9b54ada9cda0bb63296e87da5287b3a099100fda3f3d2e552ea5250a1faaadd6aec1f9ac9d836b601914ceed44cf98a1d9593d97b76ef54dcac75c08b9458968def703755a8a2ad53c850f7a49e2eda9a5ec377a2f0196bbb2c914173a2781d316d5ead4976401024a70f70f089b734ac29e99364769c7ec87cf435b995f4d7777309b20509ea2893b70f6c237a617c4593c2204de6d0771566832d78938677720424408ab3e229812d7aa8605c18c73391cf2ce48ff2f96c5dd49e1f6f5f1905937f74533e81092e8273794a7687c43b92278e08ce3b08d237c84da044548f56ba89fa8c29ed6f7150aefdd4218bc710eec23c97ec2bc888955a87ae5cfaf60a8d62ad20ea25010c9a8548a9853e6d3f66bb16f47c43157c3afb9650cd927fd564b12c4e8416247810abec38804be0f9c23d170660fdfee275f47afa47e6af096377f2aec1bcf92d23d7aac3a83a5f219922f76305081cd5c4e71427c336d1fa6f2da7cda2e0fd626d6547daf4617938509ea7ada9bac26114b6cdeaa78478f54849feb08143c5cfce16037d662fe9f9621860f805baa490eb3263765ee5fea0fd1af1dcb707814be420b82b37d984ae6de169e622e7f68f31d875e77a3841960829af892e5c360ecd267d25b6e3b53c65a630611d1ee09b1aaa8d5d8295e6985d8dd88cc9d3482a8887f5208f112c6b1df022f914d8949a63ccbfa39ba57f185e119c0b8cc6b59df39b9c568ed7bc2bbfd159bafec45e8e07225ac132431cf6e2982f7155cd3f44e26ab08b8c54d3ee720fadcf3232d34f37f643e81ffa0f043bbc0779a62555fa15b329cba4f0a42d48dc90d11fe601f5d490eb68e13ba8e2284dbe3d7e0d4389fa0c5ab0192ce13635be6251a48b87387c638ff4110950151807db245daec0dd5a565d409323e972cc99f91b5cb533b2702efc84cb4c212fe3f3f9482f7ec1477c97ca4d17221b9cacfeffdac06fc0716c3059910cff6c14e64e9e027a85c2ae73c6c29a32b23ce76b9ba245d96d19dbb1905b04aa16a3709dcad69e5b74fb000b792a7b14d23eb7d6184d3cd66a5357b56786f49be5dbaefa91fa4b49e6849e9c6db04a75e3f0b24e3fccf32094143cf718bf619738c50f9b2dc5d4a00d4d75edb4cdc3421dbc1f7b8b3279d59f3a921ce6b17c901ee3d0db8def27920387d5b538616ddc971fa7ba72d480c10c638fbb39027dca106273d91b3ed53bda5d0be0325018e47c88264ca1327c15c225a0caa83662999b496f38b5f7c1999e1d9a71f9708ac45488dcab085f6df6bbd8a4c6876987210ef34d281ebea3342b417e828f2333f6237568f16d44839c9e54ee67178b665bb7f619ea42f27fc3329cd69c270c0d9aa118b96fee6c54dbbbdfcb1de2cbaba5ff6129febf83bb284be7fafd594e20a68d03d5c38dd51985309fad0052d9278629a3c55714eaca126c86a286aa616c2db86c424ffc79ba5d2682e1406a9a87ff25e7dddeed60aa7ba9a9f27cf1b7e372d0d8df61b7d9c6452d5eac0f89d5d3e5f6611df19afa33bf7434be73a1fef8cb26229a5f76a035f2a659eb325daf3f1ed671de84c4a28ed01aab55ef29b25c8c2d38f85deb402c5b35d4c7040fb5854a3d324f9b4673e4907f30d7dd7ef334870c9a816240804d3baf1744ed10b928030a5bb8326910f4308140a2de391a01fa0063406f92b23086054f4db6356edcca2083c71b47f09550a4cc62669e1e783f16b15b2f1fa8c5ac81f51de477379f160d97ea77a32ac4316ae3d3a446a8ab29b653a5716f1943cdea4563bc7182f6b3a755b4d4f8d5c6e3401ea6e45cf9cacabd5cbcb19e2d77f539a73461cba134a546014be7db53b87c36463f89a0acf3b99752adf932b0c1f247932c4b99b6d1bf1f8f67670222e4de85c465167e0b51d94c1a3b8394833ef8ac7966be68df5fd64b81f4934ad9086fb304209a59673a98e626c3f45773f3184790ee96f75c85f8c955cd2742d76184c2e09529f6715a162679e2d224a51691f52354925c832a72248a2ed9e3b6877720f4df97780fbc926e7a9fbe3128672012cdf4c3add711d63999b01b77060ffe01eeacf369a0fa45da8a89af21363f631eff1fdf70ff713884c2d666cc2594fd8ba3a902ff875e73556edd1e2d945db49a5e27d271b8dfa29951c0520afb5966b19e2669e16c3ec2e36b179cff7344006e5eca386b5cf6bc1ffedab5771ea0d57556868eb553af59de3b6315361fca7809bac1efa4c1090606b2a03dd03e10f7c9c662ba4cba176c2deae5927ec7869c138281dfaa465e5a8dd9117b2f290f66bd1a0f374d549d15b96a66fbc5c8ff0dab8b89e8ac68cb85a614cd6a41b6d8a950aea8061c088f13654eaaf025c82d375020961a5362763d39710e9356ad33f94966af0661a930b98d039781c12351490d901c12ba6b55223ba8a8bd05a4dd0652fa50ad1dc0d177753c8d8ea6c42ce9811d30425b722c6b59adef5cb4c48d20de7bbf54cca268bf878b6aa408045d4df8d296f17c08191c3ae7420fc33f0d036136bba0cc01c0a4f18a74092daa3deafd4e91b99589273a4aa3fc65a6067833d4efb05abee209e9b1959e0693b2457689df86e93e6f4469abf6b8481f5db889a91f55d39a80cca497ab0f12d942ab3e15c4590e55e2f770ccd775462ba52b77377e54bff55844b02d43929fd60f7a2a73575331e6e1d155a3046d7c5691460154a96f77efd3672d783d130c44cd25a0b33b24e63f8ac80e60a8b84364282cec312ec06a1fb3f92c94971fa1ed5784a46f9581ffac3f0c5a2bfa726388724588b7bd5eb7e7f8404b1b04d38937596e27ee94bed0846342d59a6084a1522a92784ad88d44a209115f4d873ec4f76bf972a3917692bfa615aadcf700242843d9ff20d36ad21eab57760aa254d2e9149a332314afca25a70dd08ef7ba4813e2dd6b8ea9b55d39ac5019eed946523ef708dfbf0b7bd684618888edfa88837af2624e26b5e63674f8692a7a906cbf29b79a759700add0d43bcc87d9e063a49d9882d0b127877c9d328551366634888b1965aaf16f1d3f5359b6e416cdfecdf363e012ac9da945224c6f327130ad61a4a3a605dc327ba4ce1f2ecffe34f8d38c7a6076fb43cb2c09a62f1d581ce291727f58723739fb0632ad89f74f77e14eb7312010bbf26f1ad8d94e1438d9f4c56ef4729b24829336b6bc44fb26fb805e6438c241ae4e77c3ed521f56f6c9ac63369896c319b8710928ec31806e1ee4844f2192058f7d66a4f36a1b3e716d0cce9c7ca29d18f3ee94ae1e43892fbc92fa3118583b9c024767bd98fcba4d25d0b8bc9b36c9f59731a2e925e1b94e6c04e730b57496ffa4bbc11b0df00dd57496397fa56dd544a0075179c91281263d87a5c42f4a27ab957c8aad39789a6446804383df1e01fdc7ba2cdc8711ed325d7d6b3aa4eea0ef33feef10053f968e95d6036ed72765c0ad5cb26876847f866e811f5188226f593b9f2f9dc8ac76534555276df05fcd10b76937af44ddd1148ab6ab825337d86650b27240d96cac30d455baec30ee547204c392f8f8e942538873fc62fdb406466872a846a7296dfd5f788ca0ca1d794f2bcd9e85461be698b9ea6a3cc047a3d7d58b3de66accad3a5cc55ccb35a378ad5078c46c62cc29f48a8f08d83d5e953ca2cf7624eba85dde33bcdccc53553ed0932f4cf54faa4514d634638f6f9217554aa0dde3d22018fc92fa39ff1ea93fed0c512e22a6e3d672b371cf13a22fd62f0e67ac1975d5ef8894d5b39da4b8e102e0d76340609f5c04402a2d1eef342bf6dbedad7e72d0dcd3c16811109e9a551d63a217b6165f77f7ac92e7bd3d5878d43be7cdc864ed7f0961fd450d5776d0385f686a394d2386f3c827633846ad20603b4d53ad779d2dcbe65b64fa95f094d1636326d459642da1163ea14b47e0fd998aae5b5d5f7654eaa756d7fcf973fe2dd5cdcd598e54a2d824db86ae192fd500cd3897d96633d9b79011658a030218f62d7ab95e46cb85257ee555061ba4b58103d61a2d9487e534cc9631ab3edbc478998b4ae4a20237832ba3c00d2bb875f6375d887f8ac28c0a8ccd17dc6c393e4b74a710b76d5bc360d544601fc40c48f25e9e2fae95a5ab00fe1e4cb4f0f64028cb92d53f9a6761b5a9ad22e72b61a1e8a89884c15b020391ce7afd41362ce33b083b7b7161e510c8810f2aacaa8bc7e572b546de84ac7685350e47fc1a42b8d702bff756079483d6a604a174af824583cb8d4c1ae32303236ea404993bb675194d8b30d52c22e9095a2457a72145ead8e027b0efa8b7e978f4252c7098e9949eda4e93e5fd4e812b6ee06865043947c7b52f41da2726feda3fd632af7631bad1cd01e12a1b4e1baec91b2d8d6b4658c0b133819a5bd41b4322d8af53f9178b346f347b09a5490d7baccfda300ef587d0b672e968103c607cbc2871bce163cecf029e1d773e1b5a13e1c14d510dc5d1719374d11c3a488aff076e01f30d67a02a415aecdb1b5ffab9dc4e97f27b944d17379464e38f61be7eaab670491e982fbe5929e6777ae5d3d36f368e532f789c5b014e762c167fec3146970ae0e3c79d342ee1daac6351f4a6ee34417ccd5ec67bd0efdc5bfbbbc7e352613490ab12bdde594e7c445a31f36abed685b66fe29089135f0e52714718b4b24e80f64fc72204c4373ab63b3282ec28fc9d390f3ddc09a33f50a51ab76f3ba0b700da11384f2300bebb8810ce06627e96b4b88f296feae27b52e83633ad397c16a3a9fb733044e50b7b534dc14bdfcaa6014aef014ca04da276b9694f39c4076dde3aaa25c8ce2b3eb68a7651393d550a08390307fded157ea92a8ae3d0990e0130c75293d282b34957d02b159c248bfcc32c716dbb0ede9f8837f4336e040ba5d2f4c7a1f45b08a2b68fc1e6693c8ccbfeb7a6b53ea12aae6e888e8a454ff0c4cacee5888b7bab7e29ef75d3c9a1a6762b94b76b9aaf6948dfb09d17d629f315d77a1c73e485d639fc3c800236a888840648cf3a0d27b5c9b49a37756afad536a2a563c906007ac89498906cd60af7abc8d7151cfe6a0e2b799380b682baba5c6fcf500ab13f0c55c03754b84703892e5f69807ffa8ea01557727cbae701cfda8013fe4cf1312d704d3b6be20edcea592ae00a32f0e930a6167b65019e133c5d7eed83d99731d748bc9b60d0459c7e90f04ddd8cafa608483a3a75a1b97e7de424ca26fc0137f7e75ae703e270acd40234da9d57f1a8b8efeb5e1945b265a2667cf3e64d1ccbae7ab72d90dd3385bf7f973a8bc89b23eb41fd710a221846db34aa511604ae6ff6f59635f113cc33124fc14b08b0f362d77fc62f2cbf1d8ca2309d7998ca3ce79ee25b54eb804a4a17fae5ce67706df9fe257bddd73ce7b6ba6504aff958067b4f2a62efa99a84585c8c6a63998b36be500e1748a6a7f66a15ffdbfa4d2837a99d856d099047a80d2425cc85517ca230d9ec66391778620403a85ed5a4703a185c35a98336b9f4ef749ca0287ec5f76921c0269c641ee949f020074b91546493c72087346f0afc1af9d4ac803c75803e3d1065417eca90fac3b160da76a600cf230663c815bc0a11630a0cf311ce7544391cdb635b0432fa6ca999e0009294b28159e4a0715408b6fed657b7e649fc67efc104ff9891c65835614431d94b80cc043edf71dd8c1dbff0740926b9b449758c2a70a51560d36f1f428693a0b92c0be3fa3e6dc412a7f20dd42b99b6c447ee14a9c9fabef091d9c0fc31ae634459efe1983a688ff54992d7e14c5fb0ad50f3bc73ff348e86144d52528ca70c8c660f376c45583a003b06c3b5260c24193cff13d563b087bce8bbac92f950c26b797d543591d4b56ec9ad0a345e960f203d086937543f7002f9fe3d9ba90c330909d638618cc22e3659aa89d1a63b35eeea150830bab68af9d1ae5c5505a2cbf427b031436ecb60dce9c59c5ea489ca3bc7c9ef28ed01b86c15864735d148f777e9595533b0967689898522fe65e7fd62052dc63952f2441dd9968ef4d1e3363acc3505afa1fe64dd19ea8abf12e0be8ea265c5723f37b831a06ee85b2e81ae714f4f8ea6d0b9cae2d278f96be2f322458abbfbcd83203a870f2738a9201cc506c7f72cb013b14af8a0d0bff8ed6e3ea02f4046b1b651eac93e9f416a1a82d874bdff11970d56ae72b7899c54c86f80477ca3e8811f570b8e522c62def8f6cd9bf913676e55d28f080445c26f73a9554b37f5b2b36b66550aa332517931a0dc377409078459f5346d8407d9269c198d6295653c4071018bee02e681f29716398ae9d499d16eb858b8abfdc2e0fac5ce91d785f4053319e590699a9e04070913269de51b95e7ee1e1de4da987fb301eb4143a9abfe859b76699a989b4e4f491de29f429e8b9ec0824c2614629afbb07f919f297a9801d0d89357111d80be42cfd4e7ba0cdb1b0d2cdab70ff7bd09a956acfd08645efcd6d1c5798c050087bcd51eef0ecef56eb937de1a8a7740f73e6c0ea82489601111313c624b4ac3863339b2473c54e9aba06b1afa90db09280178b2cde986a0849c31f433ba2569254699e16764997050aff183117946a04caf2a1c015edcc012252d0fac2b045e22ca09e6d05cff7483294abfdb6d45152015a7c40d370e2dac184ab615dec4dbd58a1ac31adf8706c2fa5ba1d750f1e377b07ab1f260f89a9c63f203f8f095df41de51bd7247d013c8054870bc8ed1e1e2030828642bf9e8b560abc833f2c26b28b066cc261764cba90ddd39e59a54680b20cf1a5e5df1a6d03532983cd343213f1b9e635c652e7ba3df9fe9050ca2b95bfd4a2825e9582a9cd171a3addacae83ddca5cf86dfd93702a5e22a774b1e33bf9282199c5ec7a7f8acb8826140e6b3fd5a6c164abdfb33cb43680a884cd3f35d26423743b3135ac72954fa0ec58bff0beee6c46e42bc4dd2ac3c2d431323b706adc9b8ab24bd09cffa238698c6e17c78ef8e71b1ad2a7e22572749068bf148c8263057a695aa5f6b57eca088d3d06fb90b581a170ab684557da9b3a43e9ca6000c114d4bf0d8634519d1931fbf9cb4563cf7b0deb92b219469bce0b5e7eb6c141b9311ca071b4d143eb6c8bea7c7b0cf69cd454f989d1260fd2dedbf5b5e1653a8c0beafa7dc464523395b741aa2475b9d0784befce61b9b8aeff3df431ee922d8b4f498d7252a4cc6af790e30561429943f12d1281312e309f4417285958c4d4da97b99627afdc2e1b2ee6c42ddd92849fc3e5948b15820583f5efcce2c6ac8a5a924804a34a3ebcd7aca2c904c1ded7b16526ce201da0266d15f89b7d12eaaa77783ddbabd7bbc2892d37fa8c3f2954e5d93216d6ef2b147658897d65fb33b5e85027fd01feed2997d60c898c1298aa8f22b31ecba89e20919ba0defa06b38e05e1fca826c27096405ed1fb2566db5d8a559d9a2cc470e6c99087719da074f2cd9bffb121cd805c67f4dd25832752ee08b40e327cdee16fee95e84cd35ce996043be5034a0199604f29f05debc7e3896fe6dc8c2e54e4882a21991cfd06d1773efe957b3596048faa9ad93c5bd4997b871b1458ea59bc01f7f09aac10c45b6400a9e43b9ac070f01d1dc4f6ec88257246e53fbdcae5b8b28179fdb3a5e103401f85457db8dc0f85425701e49bb54f9c3f6ace7c972a3b2ddfff36db51e1161fc689122095edccb18fca14ccf30fc54ebd85f3c1fbb7ed7451b5f4fa93daed5284c1b0693057e4e3fdfa894fa1a30081705fbd3495baa44072b52ac2b57af0976deae58d33622e0dbcbe3bd19c1412eb5b14fa5cb21d308b682ce337713f62a87e8c0790561407932c3ed028f872289f13708566a36bcf66b4d625a02f8aa2fff66ae21228a953784654dda339401e3d115c71db1bc2807ed80990ef6ce0c59bdbfade0065df8fc0d7bb6fcbfd197791326d6bfa1635adb8275a9cba21da02550cabc579b42c432949b35ea881a89b8af9cef923e1b8e74cecb1cf9ff9a730c7c7fd9265c157904241bec584f13486581831acb76d3f0381f0f9f6a01c34d8b435babfca7e6aaaa003c91f7b646786190b509c10b06a6f7fcfe37cc52da2f0ddfa4688e5f36b96dc60009563903cc14956f3f3b5761aaa1e8e1da5cc04eeb42e1a6c20ba2d1c3f99381ea42e2f64833a073352bc300b2ff90fc15fd7b3e75ec54b3f3ffe4f3161aedba8a806dcb913c9605851153b06f33388610a60e301caeab7b1130519dd1c5e46353bd0eec16e2c11e54fce73e050e7527945ccca17cf3622e9974e8cd3e29a8d353d465ebcc58406e635d9661e1052e80c7f1e7622b71da239fe2639c6a3d4e2c8b9cc4e271be6e130b24cec3a0b62ccc972385f521fd9f125e1048e116fe5bd61f062d5089828d549e391c0f2ab4c512f52178293065751416a333c668c5b37e974e85c3dfbd6a9e61610978310adfec7d26953f27a3648c65284ba48967fe85ce837de1410cafc735d8dc9113","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
