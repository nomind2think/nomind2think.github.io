<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3577f7c70c010b9602cbc5c74d238fced99339dbbf215dc8f4f375e106383c9a3a92bf98890721e06d78b24401b800a75e6690a42a4825a81f523cba6f409d61e84077d8faf752b6b3e70b5c11e53357b37949581fc9d6988ff12ea5b2ad98b1b7eba1d828930a0399b1161ca6e7749f66a9c0cfa347a7f143125f32d326090c2e6de6763f0146a187201a56f8cf7addffd7ce3be610693fcf215f591ae7d88008209debe2127c8a6be9734ab931c0362a90ee13edca6b0777440cfe592c5309d171e6cc2c828429431a84c37176108ef7d68aa2766113cf867730f2d91d78ec6d633c80c051470987f5ca8512cc1ee7a0da8328936ac9d24f6ab512db13e24a2542d3622ddb6b280c42c440bcf1545dd98817ed976fef7d32be51cf0170ca0bc7960567f5b57e6ef0d5832f95cd34bb7c5b330b286956c73f9a9443eae44375810a54dd72aaac7432f685c57584d395264d6b86e714383596b27b2a837b3561e30e3e4b0c7af4fe474d3a35692ea438aff067a4416da3e9a77161009f1ad442cacd6923ecb826756cbfe431bede9b3e4263997191ecc05fc3c4d047ba614f584b22deca597a353532ab987572dd19548eff66e76e20fb3d987f78814076f1356ca99259ffd36057a6ece248b264497c359642cac613a4cfb1cec0814397b3535557dd69ebe18d5c3c8b34cc9acff262d6055472389cd4e0c97803d492ebca564c319838abda91f26e90bfcf4b76794c256a4666b0554dc921a6390654ddb08e9417813a4d0ed759f7a0cd2ff88563d28787b79d53b48b120fc0672d19ddc0de2d75b79e93129b8d1326cfcdd1d825d2a69f1977b3bc4010d7ffa75c04fc67e7cf1bdc2ee8c992f0c2265a425111e4183c274b5659cf66c6a2fb9795183166fa8ce0f1d9f136003fa935bfb8ae03fcc508f64dd9421831eec8328919d85db0754823396491c42368fa1fdb4cb4330cd9ec7abf471c6287ee20c4fa81a617841b046b20c4ba25301a20607bbce55792a84d1dd727e255ae67d7b1a6ca0c7a30d766d504e5ac90e58f83e5bb1a2579b0ebec3b45773719e9c57233a79f73d018f489d0b2df82f0707dbdaef5fef12f7465ef38e5e6e36fc3c23acf2fa9a19445e8740279e3963640f7f4f41001a96237a8472125aeb8aceaf62c56778a1f48563ced518034348b1765a074003541bd962ae41905e8e74b1010844029331b80172110f3dad580dd12559cb8887f553e271022f844928c93a8a0814a67442656dcc928b5db7204194a1c0d5f708b46290568449069ae540d58d16316eba1d697acef6982dd6ed4e1f544aa989f7703d121dd162730ef5c9ed9b149e00c34710fd873d839258e015536412e7891bb3a6b904f869b04c2f9da740aafbf0b17a3ee338fc95195ca845d73853600e5038ce8caf9b3bda95ee4c426da1376e825aa1754a402ea866a9ec0cef4950f87d9fe44fedfa04bf7f9471bf9e6a736c109856d1cbc66171805f91dbb5dcfa864646f148d605fd8dbad41dba022c3400a8375d971504372ab53367ac07a07a09eb5d97fa6ec1888dd7b50ead94bb544a886247faf0832cb94f3d22d84b954a4b5a8e595946294d7a863457cf0221c6a43ab061c387e0390aa7898cc5ba0aa7b9225487a2ec34e604dd1b0d44f328eff73c422d6ba27dd13e133095c695759b70892c1862945a02a0790ab0e5baf78ce0d66596fec5f51aa537e4ef62f39973f75f10c1811d76e290c2c1d4f6b5bf0b1bc5fb1bd81eea77316577f1c57415cf63c5be4a916690a7d22096a5989257312b1bb9baec5c7157f596e3122b427ad26fab7955a60e07c4cc98215bab420f95ad26a6641cb51437c148a64d80a1f7716b0dda176898f73bab1d74bcf3ff9ee8b0b729e95b59f897074e4186f8980c27791244273423c2b27aefc419629f56a61d81736a308e425306131e612a03dfc8f2321b5d4751ccc0a1f5a4de4569700a17ec3930ab8044321f95ac658dd72529e17c096e83a0d1e60f44083f4674f188a9b6884dc2eb68a0fefbf3ae244102bda1972388f7f92cd94ef9669f896d92ed33560d0ccb4e57d49b4a66b5fd11667444995dcb490266b7acb72502b828f3ba95c502a23b51f7c4c17d3c4111d03fc5888da1f4d13ac4e539589b638d5a2607f740daa9c5416fce94ba713d30fc8bb70af8b39107d6f15d051e82111c70e40b8ad286c067fbb4a5f72684ab787aaeba901e4163efe08f9a2391973cbfd086b1c3e12047a084dc981e1894783ee7e64d719c2e131144889dd62add5d1472970b4cf9fa3f03fc8a79676fe445ad24361067ee43a5b713fca3bc41c2ad2bcda654eceac2cb65cf3917d6157d448e6116c43a2a99b5c0e4791141bc81df06ae44bd1d1cc44c4c17ee698efa78a9539808ab182d38df23b93cfab436e79c5c27ce4c2378df31083433f9c1508a8095664ee27bb3a59559aaba9ba459df400941a4f343e403fd23c9ffbeccafbe3e6c01f199fbb5a9793028ebe151e5e7b70ad1c146d730f2021a0f859ac1ff856601bf2b7e095b419572facd0f6abf682b04b1969aad3047435b7f0b1384137f19dbb06a5000d366b390244ea15e8b6634c3e9971c8d4cad530930ed6b6c4a7613c195e27c78d0a0d1f077ca6e16a56014437fcd30739866d1d4b0815c02a56ec285034c4860c082aab7f5762facf6642e2d1e3b0d8c8f0b564a7d175885a0231dc9144295a9ce5a9d0f3fa493466a07e66bc5170392f401d87514f1479b7def2ddc9ac3bf94955b0464db40c456631fd6b61d30ebe295c5c3abb16283de0ccaf14783bcacdb585c16b3506108abff8b24e7f2396db5b251f93be3fafc947d1b102e57ee1d2e6019e463f8570c9ee656534c53f0ce813e2e8db8fc594f4a6061c769e1c32749a393e18dddf6b6e345eb0710cc68bb5ecc461539dd874916a4fff96a46ebb92c8cb7e8ac55ee300af1c3e4dfb2bf11759944308f735646daef05f19d56d1f8a8397454d13ef2c12d282fe676bd9715d7e69a0a8acb0aab19e037806d94a68da47ff1f7236091154ec133aa00aab5c99dd459f72e287170b2a18710888e4819a52aa67324172118da422a1a4cbb5b5a0289aa3cf649bd2d41f8a91c9bf8a6f4b0582ad89b67a624ed3ccb84cbe25d053d12dcfe133fe076910758fcd2459b0157018e2336fa92c295314ac554f1cf9bfd390fd80a23887f9b9856601527a3f1effd2a1cffad32d51fdd2ac4ca5147da685a971a6f6fd123ffa882f6419efbaf895a2cf79098ba38ffb83b6dcef0897714a64dddb1bbb5159c4ecb8b90d001c7dc75c23e722d558963e7416cdfb175ecc9bac7d8be7ba5ef24699d2f7985919ece2fd4fa5dfb43ebf790cb0d925a51ca01c6f7496c9d6ece1c6117f1e2f3e5507ed12e5c532dc25b5b56591cd14d2a28b0b0ddbbd388f96031b51366d5478ed8f22d732ef0624de5c4125ac4383d62e66cba790c68d59f6e3274f62670a25c9a6ee1fcef977a6453e9615010bfe567d0df4210e743b2f1e2dfc76375f0cde4e379dfaa243716efab4b31b07fe42232d089b163c1c894c2a7caa62e838d38ac6fc496f62d290fcaabaa3a98de7e8a29f650658a91f7fe56f40b245d2d5bcb0977de5912fbb1195f421ea8d9c82af34bfe0f1031f556b2dfcd440ad66cea9385301e7f4d760006ad72bed9c52f2da5e51059b1743842a73d2bce946787e896eae5c9859401b6ef48cf2fe7001ad916f23eab10ff7b58249fdcf78372ba81ea38b280eca5dd70bcb08c14e778d095fcd0d534fc947ea251c7d841a5fb36d98ba5e833442b46d8656af7e209e5c020294a6a4cca1ca62b114001d812a982df7f517aa7d062030ece0a63546d8f62755270932fabc5cd22f143516014752049f8543284c5dd3836af0fdf72cc88560e445002bbfd7b487b6fd592c56df463d63e385264d91013d1ca48d65ca0deb56c0b3293d6aea24772527791acc9908d4330d6adb59977b10ee94a81cab2fb4da6fff9abcbbe927b0324a311282bfff74e9e7a7f6f610ccba4cf5f822bb854f3e5079d77748963bcc816bf8d9c9f090e600d807fd175039b3a9b37e74fb5352f2cc3a2184490821531510eaecf62ca1234496666ac1b8634b982ccfbeaac3891136cacc324ef7910f29ed180ff8ae7eecd6ce2063b4203f602994b09cfd57a680e1a0992074dcfc5ffb95f55fe12d5cced87892e073e8d6ecf546cfc67a35735e19ebd9c1c9ead72b1e1810cd0b71f2ba772858605978408b64897394c64ad5ef1aef6e13d5e0d48ced07f510cbf9e6410fff098576544a2d7741f3a86adec3440434b7c673ebab5c19a4744643783efcecbb8d9d6e65256b5d639591f80aebecbf80594375a7af121566e133be20c63e3138a5fc81a1eaaebec15ae766ee0a6ee03bf1a1fc7d9c6d9257838e8dccd78c8a5b412247e0649e0db61f54ab061264aaa25572f480e3684e99a3561b401f159b185b1ca82484c69b22e88e041789355713777fcfa896f7067f1ff3e3a14f950542ad678805567e87abce1a95bef722c20ac46494a31d8601c5d469db309950e442171180659077a4768c49c0b736a13826ba2d02a9acefe9b3a4cf2db3c4a705eaa0cc273f200baca32b2870d235ced78e425228ef9880dcdb777003ce39c1e231196dc381b1b705ee28dffa48e10931fc1cf1062c62652aa0f322c903aa73792e3aebdb5efb19cdc54e9b5c24f2e22d528021ff34b744038ea1f17e79a55c67d7eb27310792573190a4319bae2b187907ef4f9dd2dcd92f1c92f4848c462166ad4926c7b6124e391e00c423db4552ba6472004430dcc15f793c5f36d3bbc7c88cb8b6472915c0e3878fd99b917e948036f81343c7028c815f4a38df707582987766d25934209054c6dec7a467c051d5afb145b46d033cf376a2a08c066bd9c944936f908138fe24bc7c8a7f1013716c2d704069bfb619907320720362f73256bb86149c44de0119664646b6580e2e6267a587d7253f0ea8fb69553d5ac4cebcd53910fa3188f2ef69ee923915160ad162f125a435ed832220b04099dd4977989abb534806f9268d8a23446899a146391f5729eeba9b2f685b3e97463ae79cf2960e96d38f529e6262d5a5817cbda6c5fe161476ee763fc6e5973cc4c04fb4e1339b7de4f16f9425478c62e35996495f7602b940504bad98328bec7b1a966efad0c22638ea9006ad2a1c9883340f57f6d585a5fd8b567ee53c0382847f36a9a81e940cb979fa710df981b79701d46c8e1fcf38aaebc97b396b6788b4cb26aca7cf25fe19bd0d2b7016c1f6141ea4523a768b4aae38adb7d427bfa34e9423a849c827deaace0b1a361633e5eca22aad0cef85f448601192daf993b82b4b0777459cdfa1b299ecc1b43775d4dec3b00de58dbcc7ac0e9e182dfa11f49bc7118004fb125ecd27342fb846d3e6bc8a8937b1886dc70c005d656a17ebb990a2fe913461a6a3b0e929ddf29723754c23a39b173b354439a0f3229474d6c61a897c3e33e203933abb524c82a905d6f530480921afcc406d9224cb994f6d1051887888aa8bc5abe788b3f246168fb1e7735bdff82d922a7e552b564b7256534a533a3251cf0f9a27e1a7c4d3c26845abd21966f32b75e1d603b3c24fc66b399b0e0b59af7cf870bd3829775e88c8e5731f9bc9ef97a6e4d192329073f0b8de7394d801d50455de428ab6cbd47792dc92c58c118b4704f39f22581c3b3f839620838acfc0f5e80c3885970d80dfcde4537ed8968474eb1cb446193f7a2c6392e7ffd1ccb9f6e2c9c2f72026012546c7c8058159e11bf3534b83e0b8091eb2ba1eb17915f9f06df33ef2eca7c7278b03c872f11abaa3bf0d6d05dc77d2656476da296cf01692b60363ddaf8466048acb3f6c674bbfead5ac597c2727517137d98c17177d7f62ef63a6486af8049a0f8d2034afe40da10484d11f92bc07fd478567ddb215759718fda2da07e5881878ced800923f330ecd73bfded1df21bd4ee90b0836bd95daac7315da7a1f4519d4bc74557727733b7047f6af4b105f8d7ab2940b04f8810f8c10843b1b01fe001f4ed90056ba1cdc3e422098878bfb6b036220bcdcc587d22742317c0a1426c5695e395faf25fcf4c13109e0543613d293a6d10c0422d145dc35dcb14a733c9d653c117fc61f381357b4b3912f2ad20db47f2fd3655b392c56fd19827ea55811f4c5f42a7583a321a45dc896cd574af5fe907099663c4f534266766b5ea33b5eb344760d322472d75ecb46cf326a4a2b04af471f5291a8691238da072fb775f7108e04937d9cd05ae80da0e7e1da2146455ae1c0c0019a9bf1fb02e999f157f8972a2ab25a5eed03f51d6bb354982c1752ad1424a2f297f44c2e8814f5c98ddf3f6a483cf4f4431516f0a68d59e5f70d2dea4dbc614dace8753055b03b4786e7a8abfcf45f3159df5dfabfb4ce92efa407eb37815d4a9a1940bd6c5dd2ba71e9e9047b22418177ce0acc262427621877c84817cdeebcae568e41ae184dc9322260cbfa05432c80560b743cd942b85fa149b1c13761957b9cd7100218c016e0f4c47e94a9b65e109ca2a9c2549548d7b0c9dc3a5ce2cd7f2be93bcf84be912565e7eb79d3d1e08abbb6096fb2051f03c521391fa1fe05a89c9bcbde6bb5149bf79886c198767cd4c10d712f2aa8e56d3209ac2dcba69870d81dd6933c03a0b1a00f3ccc26eb956088aadf9c99e398550f97eea72f782143347a5b06f51a13109efc9ad0dedc260df7a4c3b6efeed20608dbe48798d8e95a304ed390d9f3e958e846c7f32dd4c3174346c411600919d2d9047e688e6cf33fd0e996a9ace111ff16e044bc4990a9428a981cef5dd541486c091bee234f65544356ad8aab6d3faf9075fcd366cefc646dce27f9eabec91f64e7bb00629bad2d7de868549927d959b6287579a8af4513dd84e7c5e7864c6294fd73b6e76784db9c026ee8f18d5d914a3bdb3fefdc6c1ab2b69c34501198ee81b45d725df37148756e43e8caff1bef33249e74f8708ef03ea9b8fdb2580c4839d9f4afed7b07d4eeba810547a80f6b886e67952a439ad4372d93abbe7144a92d2ef0c54d0b3acdc3481a70d8e16d7e67547a821746a652a490e58931adb51921c142e3b79028bfc70346a9cbfe2a7a9be720638fcf9db5d3a70da69bda37e36fa3ae8c4b0ab42f9b358c619e6257dfff2920657523d6f50289d858b4590fdebe9b71b00df836977efabb5c096b40523b4dfa5c03a96742eb50fe798c05a75aa75fd3bc307079f61145075497c586334092199346c9ac83acff3b7c58b57da3a1fb57984c0e42d96f182c86d3787c081f389e041f9f66a05b539c5c53945c8c8806633b48e6b18e356cd60c36c94f824d66704d0e9b17a7a984904eea841c5f4b14b8229eefde8bbdb54d243a23d9b0a565349889e97ca336f9c9dc3ff83adcaae090ccfc45d4b42d0c1aaf2217f5ef7e70a5c2951e8d69ea4b4d0d8f5625ba72d3106ee20883cdc599ebc8b9ddc051899524555c9d8b1a1c7f4b79801ce879a2b0b8080b17f050b44e6a3c6d48d057dc693991f323252d3c520286f6efbbf00219ae1fafe2b524d6e365b6d72570627731d9760523642eb6751fc752aaf4db08e7a62187507cf7ca27fe9fb3ad1055f70f392353c624f460db7316bfc23f0b81993b40fd60694bf1f81961080d60003e6d57a98b3681ce6480c92830c058575b01e9472f4439afd34033321584ac7afb0f0e5c2687ff3d7066099a99002042950b5ae479dc82c5fccc0a3ac687c3e66c7eea19776ad1cd16c5803c50c67136b97761847b14a97bbc14606717f4b720c5037d053714b2199755d08c1cdb43b820025e45ef7047d2f8d31fce2a05ecdbf614b51fb076ecdce526a517345b8df55cd129c3c77a1f817799dbb9821ee35cdd8611c9afa3b12357a7af405e16e4734a508f808fbcdc57e06efa5c667fc945b0791acce7b99c17b2b85a913ea99b4fbf4e1b747fb0a1cca9535b681c59e6e13b313efd1e15b8fcddd885af5ef1fc5d9d8cb95b61c10b1bc0a9c76acd48fa2518855bd9421e7791841237d855cf59b495c7baea9fafb72f25e2b89dd0c5b8c5fae7ad980e6062ec7f4b1309d7bd627b4408af095e819e4de7225d800bc85a2493c5176f75a3791e04b477065beb1abf26d6e7189272eccb8e3844dd4d218bdfee845ce3ebab033e371c69cdd79c5296ec790ed1f8fbe4379bfd66147fb07d5ff463ff1be1f4a4c528da5adff11b975bcbc34aebc7348c77f32c76c13bed64b313fedc5f1ed2d4c596d280739520fb2574d0d4649296490d988164a5a945603973ddbf3b86a4f78dc402b59a3ba98e85cfb4a5dbf5a65c7d3c957e19044670bedf8ab1170bddb694d647f226fe642b5d87378e84d94e7fc598329f08985c3b324af3c3d43f984d992e0d0c458ff2a341b731c6d5db5eca9cf1062325a0b4330618450c5a3457241cb0565633de0d38fc6e622f9835143394cc3e86a50e8aba246aa96379615b5f85a0595d0812b9979290fa8966ab6e506c9da06ad6c022bcbc4fc52d7065ef9a82fab97d88a1890c62b0d85563c879ba89af4529c782ff1822a0fbe7e3a8834fde86f4f703babcb85f278d232aa012f924153035269375f04ac409f1c9398759ac37a970e059815382fccc86cc7e0f8d4e4b9a10692cede324032a24f95b822f42296dd03f864d6c305a8ff14bbe868c6624987867cf19a1cc9e7f8e238dc67aef770212fb73bcfaaea35773680b340ca388e5817e4d1f0b0a09a325fb737a9058a522714ab5fd70c8dc7624be671468d21b0b48f7e164f0b04b58e0974bceda19e0edb958eede86e541b2426970c6516d90920f42fd946b8b337f10b719ee5ef06e82623ea772b25ac2b8129566515b928ffe23a81431eb402deb2f315501646c4770c1c3c13bc290d1a665e94d4fc006d8696423ec8250ebb28bc8ad7b2a181162daa2b17e1fdbd85fdaa71f6d9040245e61544bc7b5f9a11b58f208cf621fa0e97b8a39e012c2c6d0504eca57213289d3ff485cf58456da7ce34c5e42aed51acb3e9cf46a69126ecfad2ee4861c8165362b3f3bd7758caefe3b122b7da2912e8f01f04c9ba8b5e6f31464f45e278d41dcad6cefda907a21d8694fbacd467507ac37e393c861094afb690111236ee61a1b795185eeb0b8b5f1be3510c19c397bc9b3f3e60ffa1ab052dbcf44c54a242fbb373f11a699c97ba0c1c7f11c5396b9806e78a9e7e776336a79cd9f8c8fe56320bb232bd93613d8f515012d7b367961ba3b5a0ec3bd080aa2f8de405e89ababc9b367317b0c2e89ae2a458049b961b79b1e7b5726f93b760822f3396d5954136bf18be91e46a1dfc8f282c659680b96d306aea10c7cf7c95abeecd58a5f82234b20a7f741bb507b19f3802efe15fa241151842689c5535b0669910bfc4ed5a329db3db4effe768af6451d460cef857e2cb783700a540a42f16bea2188a2ba9725b7fecedd6aa4b56056e29457697c0970828ce4d2d27f666ac3480ad8010d50ae156fb9de2d1e88424089def0da686c2dfe360c5cb2cc992064371c8080b67c4cb0fcb97f7161204760e7abb668140d1218e02e83659a5d1a041f739ea14210bb934cc2806df65eb78107706aafe0420f1ff44cf094f0cb8197aef6596db0e95a832764585193c5b3b5c3785a737e225072309304390d0f2cd54a3be8865a1f4560ea844e711adadae57d5c714bc8e9dd3457e0d2d735c395d9c29e32cb76d9a249802262dc59273cb5962458177601e1904811b77917b66551bb1e3faaf06c062b65f20da000aa760eb2083b8ac0599d7a2f5a7198177b0d13ba56b0e563fd3a9794f1a6fb7871cc24090d1c4b46ab002a6544022abc9dd4482445f81ecf0aa7b0d97b3e1cc7c88c7d90dd170e10b6143c983502098098e49e04e9ad0903dc95151e8317ce1a6d8ac18f543d0f332d2f26eb1e304b60bcb299e58cde7e6d30e666199ef2fefadaeb0605b6e7af57a12a8205a5b5847278316b11880cb79acb774df5276950e2bd0afad856d164b0e33cb8364d4fba6cdbf7bfe8b8a9fbe1f2c233b012249ced1851d9f51ba2c51590ad2f6dc2744c846796a6bd678e4ed6eb73fe9fd643139ded34b51664a7376495386052f6524634e8553dba8cedc8cd1a463822f0a7a25c4cd8573cd67e00c9cd5b47ee13df6643c57036ba950664a1536d3d28a55dd7b9d47165948524f5514a45f21fd1ef1646a7f9893303d59ceb405b7ae97ee1c06403b2d3fd36b080ea3f486e2d120f38feccc4003bcfb6e037d8bbfa045f939447c60f92b3a296e21a328c7361f812acc27309a3f246d241d70dd64a9eedba6545b92e0296521ae66e5e601a596f11c50a8d8b17a64ee41523713ea8edabaf220feda06e5565d7c0427862da6abe7ceb2e5ba96902e88fe81586540bf3b0212c5c0d884466649e1659b9b7d01f3e29437f484f27d7b54c0980c4d4dc88e320d65b5903f8d663cc74a1779be37e7588e2c243b55ae5a4ecab3d0e44a82a4593a3abc81530b60a7c9bfb99ab9c097200e09e8ac7158d96b593a36f52230bcbd6b39e08cec61f95de4b717ea50aff8472a5179eabb6df13c144cc41ef8452148489106c70f6c80e82f98f186b42fcca53b37fbea5","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
