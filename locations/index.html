<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9c24b4ad7edb5cb3543a8b753506360e49e530d0b555e2a883139be004e54be60ca173885e8e609ef8f79c10ad0e7fc4a243458a9a7a88debba597615856829a2285065a7eadcc16a9ff61db48e093903c1848264f06d7ea29f27ebb233b48e80dd4d06bda0fdfcadf6e9a63d18ed209078aa888020d492eba9e7f9f9167339d3fd9b137c86c73f9d9911bc1423de02227a91124984f1d23a9674a4b7689247de5769297cd9c38a5c0ee9c68291245b4cbb91056555ee9f2791b5065823fc10e8721842ed37427699db2c41cde25c92b870545b5f14a7f68c0bda869f7b50841e9325b669115dbef3b799ae45aa30a0d921c251b026bf31b514ddfcd321a5a97194dea192a5eba7a7bf2f5ad44172606b451d29eb2f3576b6101be43dbc9ee21b2a4659a5dd28137d12141c5fd38655fc3cc35e04ed74cbf64e8dcb880eb596e92db171406ad96891f130465c62a725825fa4d8a3fbb0cb80ce97cc7f43ebe0dc94e3a37f6bdbb17b0d00a80f14ec83c0993cff289c61165e13bc75820021a213ede4f0db750c51bfe3c2b86c3903ad291002280179e13d588766ed9cf16212f81b42a5107c62cea846b6e5707a3480509a61d50b9be5979e05859f445c35793fa7d142f86405b7ed3dc6725f717bb356c85b082ebbc58984ace261d7ffdb061e1063eed296ff51895faf10222e0c1514be686fb514c4f02b3b96544c88d1d65b2f9e69042b7ad71b43be0009bb7f15c86c32127128793b229105caef934aa4509685fb4f795a190d9b539649313cf1e4f63a239abdf659682c730c506eb6b737c1b7822fdba5fc63d7eb52cf3248972a59fd0edecc5373b568d05e56a326f729b50928dcfb834f1bb2f569f31976365d9eaf526d7292ac36c6a20400c8773a70d6acd8c59d43ad47e138f462277fd4c791b7c1603665418a6831fcaeefb8dacc743cc5d1f7c882249286ebedee991c480f5ce8fb0575b82beafa4f0f9e8bcf7431744cc0fa02cbe223ac85e47bb18e029d0236d70c46414cc012ba4388ff706bd7c6b7a0653c95d0317d2acd36d85d334ab8d7165ad3fe4451f2e4e2d43d47f4f31ffb076438f82c1185cd0b17f50a8d67a07f3b48ad9f1f0fc2543783cfe1af22c3a9160b8ab3f27e67cb6a74cfae8dc29256ae699b1718f122f7e53101e969de8b1829639d228c5e92970e450f355a6c298a205f9ee334f3b579778c4e0cfbc08db845b1d060dd2265fe8251b0998dbe58024e2a29cd5deaa4b59a74ea5dc7b880de22e5e05b79a497a2f0aa60d741b936f8c8da96abec4f04ce63ca2054fc8e0a06976fd392f630b936e9199126446119356ba3d2a5598db857cdf0d36c7ceadb5f1977e54a6864e5565955c3d24ad8af323219abec498a842a37b688292a4a554bec3d2e986764fe9d534181e91410d7870b3041dfe7d8c5b2fca18d98ecaaf9d167959ea931539493acfbd6a3889a8ba3297bd508298c2aeda5eb41d5fea5c4abb27a78e9b39b4af15170555affabb8fc299006d3f3b63f6db23029a75c25b6c3b4c1240a03e811bbeaf857f11d1572237d84b3a2990bc1f91ee70bcc443edb581041e8fbfeb887b5d1ae4da2ee1c9095afa06f617c0ec3de5046a9c7d295575a24edf953b5b8a26742e88fb17f69808f046549cd5aafa3c7212c540eeb35f48c20a13d2e53d38f0ba40b78b08d0cfae9e41e4aea616f7702222605a4358b99c64da40f2e85883b77a997a84671423ec209ae020a95eeb873587b0fb5a721a7450fe751e2726556bf835015c18ccb06435264531f53dc0dff41ac80f976b48dfb372aee5b251666b55ed73e88691fffd699c5ed513d3e75bb4596943af2903faa309657bd642ea492a6ef61ab301627cf4cd47e770943ed9147d119bec494e3b3ec5d9762754ff062554429e60014defbfef8113d4cafd741260b2fd955841307da4e7cf16c099fafc1f51f0850e177a23e5f5d56089c987e04cd339be9b84b331cdd73aaad11424b16bac7aa8219a8812ce79e5f5a69b4d91ded94ee92a2b781cd5e31fdd1b0d1a713da6a03daac15c81bf2fcfdc9c6c5a994b66c8943381c88db62a77416488734a19e60ad8887a763980c960093e22266e4f2d900b33c512c07761d1aef979e445cbaecaebcba5601d7a2159191e3bbf92767a0ffd626f38e11f2a807799b7c718310e2cee57f5542f3c14de498b01a95b928784dda99099f7c9f9585f0ea09408fba12622c4247a4c739d4b3cc843cf8af94f9ed0758e6f8cc21dcdeebaa357cdfc6f12cfdd2c471fc9a90cd7fef34ae91815edfcbb3d06962591da66ea2c8d3ff0a4784b4e812f300e1496ae473c038a3a7752b3bd2d16e2d3f4ba6e7ee1767c9acaf6ee51bf651b84d791c866bc06070310d1723ba0f311cf360bff38d7090982f51bd8d4ee70216a1374ffe743ab81841b36058d1bf22033b60b1fd4312884c9eb470079b45f137829b481e5dc9a0d965ccfab0ed32ca6740d67f401f57e6098ad3b2b66d8e41861bdb0dd95c13e7f05ee95ff19019cc758f07970e2fc9b50dfb334cd3b4352ee9d96bcdbb9a06d82281a604107f4a1b7ad9200a8a831f4f0d5a4401a4b3e2f8e18a915f0d9448540704a65878e5de1fe2f21a092d7c73492fb4991e4c0cc72dcc61a02b8d2b912aece388dd420bc3dbd56edd8291921a7c2859b3103b60336dda4d6a9b527234e0f63bebfb25e9b1d13ca69a487b08ab3860e0d5425b699abc65283eaa13d1dbb1085851d9e3546ea6082848866af58d536ea9ac426b9d013816592c818bdbc035ce8b5eab1a682a03a40da978b1de26b64bfad06d549e2125304476d01b84a80aa7a178831ef0d26b1f46d390d9c8e6fd1e99d5c6bcf3b9ece58c170deced1ea7e2bd6097a4c787282a5b34d023ee771d02e5bbedb4e0ab925adf26be6fd5f2864678695efe3dbc7580db28d2c861080b90f02b972f6adc0d90f3867245696b2006fc3f444fc5674ff13ca0ea8b9234ae4d3bfebd37a966322be24e8ee98542a2e1b1fff962029e73b36866c6c4a15a7cb91b45c38884a69bb030ad32ff0f56673c077bc050fc1f9c206cdf0191ca95d34d19ad89612c260c5c77c114e80e2554365278f73efff348d37f0aef7acf307b55082bf890daefd957b8c143b494d90c504f6440ea00d7a1e0028720e93d7d71acc1a37df388a11938852301fac4f2d99aa996ebd81734683742cfa48a00812935cdaea20d523aeab8dcd412c482e3e994c3c431357c567ee336eab8cecfbb1d8d3b2bf6308e723dedad5e9be4ca37610ea2f253de558dae6f6c098c3a94ffc1e39e2b86d88e23e08a9bfac845bc68c5213dbdaec6f06fea4cce66830c0a61fe64605dd56181a5f8d2aad89ce1b4430f64d2c02a00af984b6827d75460f25cf5a8ecd45c5d1b90de685e0b1cb2128753e60260b8491aeb5c1aa1d29c2b056c28e36cc6d259a15c696ecbba3f86e27d58df5ca953176d08d925425b80279faea45128c4bf80dbcceadbefa5e54ba060a1519f96c1ae7c4529134dcfa6520c4c0668170077cb5e8f522318185bbf8df0b3b56509eb9d9d3fc30aeccfa8a4e1e0aa3162c334d5599eb0090fdfc3e5f1a4c412b51615848733614a1f65b98773cd3afa573262c1844054d4bb000bea7ba12fad8e2fd7ffeb17d678155d5dd904cc8a00e710630a83eeaae8c8cd492ce6687782628b88cc751e5baca450197e39c6b37b532a5b7a4aa7a1167b4172a7ef0111758e384eff7e5f9eda0d47cf6ee43a92fb547bd414550cbb0d476e6858a3e1e929e03f9a489ba670062b6e76f4e787e2a7efc520c904997eb909d92945b6f031569c2baa0be82bf3d63184454858d53383a6b7da5cb9d17c7e7047023e488d6b00f2edd4c867e5369158f68f3a813eaa1dffd6fb3e0cab94a35684325832a2accb699e3859face79b5504929c9711b7e32373645727f7af72cce98604656fe16b9843e71d413c6077ab344da4f3344782392a77f15fd57ba921e2ace49d239f84ec118b01fbf8ac2e21b83af3b7dbb7784e052779f7fe2a88495b659000044520dcec6b6c57b7f9f64a01768924a13b0187711ffe4df6bd0cf356e9b9d6a213bf5eafe23a287f37ec88a07e534528e82d1abff433199c451ed96fa9a33df0020cb7378d8550754b6be2f1494aa5b9c9b0cff1f906fd58d01818d3c91e8e7cdf8ab480b7f5738119eb6885b98368d8d56b7e75e355cae6b345d47f9dca554adeb76806cb46ce1439733c9d72a1f358a057e413147ed80340f39a54622ce9dd117b9794ffa352c09a148c548a8fa82bfc044e490bbfce2d0bab490aa59689d6fc51ab91bbdee1dd41a40a2d3ab12b40e1f1dc9e1998d6c10734e90d9304fbb2d18cce05baff0e9c7763e1724bc1fab8b1cbbc3803a21a2f4cba75460aa22d6a5492ccf8661055ac1c22a3bc82657c445e0b41518138f7c79c3bc045fd888fd193520cf4b62049fc679904c4c18e32c86c4d4d5e74a54ed46ea586af3737462986ea0cda284a2d9716badf84717ba59e7733eafd5128b8015e5c8aa4eaab1031212661adb66605c28e9133e0d6deec890ec88f5d6111b4e035cb0b71d391aba210f154437f44a9d479ada5342df7c3e065cc97a0e82c5f33a07fefc8d9c1b76e6c028df3372966aa052bce7b8bd9a8824b49b361fadf9274d2225b9310e00510baee54b1b7546de19bd6639c197b0b14e99f87866ae3f6448f94fe21cd402109549b228767fbe294a32efd53f79bb8f80b71ed3d51b384fc8bf38231fefd013b2c628bf042baadbe4a9e559141fdf593b0e3a1a08502ce232e0ece6db79321c5a3532e916206f70eadf42d3e6c14b84763a38aecab5c8027e1abffda70f2d43b2f4542fc5764744976c9cfffd71facb738941e01c0e9e73c99ef248ce1e08e09015c5f2616338baa0755f6cdba8e0d5c056d72bef90745b1a91ce2e3dbf310c2ac127c9777fc653ace3056cb22fb1afaffd525f5ae74a3cea72832bd7627d3eb04f210ebf542da4848facffc9b7a308f7d8ba2a55ab11bd8d7552fd19eb47c01062043e51731d8db6182a736aac3c4ee1cb8f5444c3881a5a882b4dfd668701db6639a91194af10438c0aaa8471d8fd5f279b1e05f53215e09b4418111776a9b80d555aa75b2b135049b52946aa2fc3c4b043f14e276ccad29f54f2414f801202d538ef5a9a7ef041ebadb188d2d0639f1e58082ff6621e6ffaec479c0e6d2ae4e8ef7820f20276bb101f72a511656e1c9dc5070f6c27f53b9d8bf44036aecb9fcf38c19257617dd0d778aeca996363279fc686540c6e1f978ba7e4dd2221311f1d2b9360778ae29ea0adc44d0019b6d2997318a14bac821480311e1506e7e402f98e57795ad884eeee46a0a849399e9d154c1c365ab40d621520df72f6d23616968e5a49ab5322c1dd3cd4a18c1707cd531bbdc8809b8e022a24909b4b1e28035ea643f97b4d5a70a4b187dd1d1a269535d437e298f07d842ec9eca3d78188aa44c8dc81a7f94e9e35e967dd641fb182d8624cee02f8d3ee9186464121b239051d935c34a29f0512e68ac67453e87ad5b1a1ce2f7df3a88ce8270dc140a72cafec4d365ec1fe802b3cf9c9b480c7a5f8c1c5a4713e09f1006ee3f90827a769f323589ee37769e152af289ec98a51a67feb55ae3d59a01aa1d2813722f5f39fef6f6d77efd48b074633f65c43c8aa4f5763a5f402c4ae66a57e608de46537f9a00abe7c2cd8bc6ff189884c9601154970d1cc580bd4b41eded346f9b83cc3ad843962f84d2cffd651979feae5b483025f770a1e8a03fbd33aa2d63972232b50c535a54b646030addeb5fe0da8b17395e2a2fc3226a93ee86bb78aba6074969df46da1dd2e8d2351ca750bd30b2b300ce37a44bc2f6c906ce3753283acdf7012d6b03680a662c3a874e266bf3c028e669048179e2872a5080a6ef86db618c566c77b92e15154c80a6376a26dcf1bf1de34c8504eb1ef2f46350eb47f213f99f2679ee2da8f961836bec2f40714fd74163c2f85a9e4f3ec24f000df9aa0b26992ee092f263070c1803a16aa7b200d463c51a7f7cd87e6df6d64f32edc8bf824d008a24485355f62513bcbf3e8a803a5cd3725e1a45c03ca37c700b1fc14b9e7d54d34d59d6641a51ca38482a000c50de9e17d2347c6b72eeb1b1c3ffaa93401568e664c7bc16c0403ea27270954f59ccf5975c5ea767491e278d39d34714d7629ced2d75aff54e174b7dbc5579f0bc5a51eebec8a65a010ec47f7be048dd9738d6a6a533c3bc1cf108597116eff818c1e51e233be3eb2b14030668103e9728703d6a65569cd8138e51edae9633aa61b46a8ff516900862eb7c755167721d6bfa32130fc767086e59d3e001dd579ff340b7fe32f2e3fa746a6bff90963c059bf18e4ac99a43c2ab1ac81ea495f9f58528424d9fd6c08e64ee821b97f760aae3d09577ceae1934a79c9583696173e46ea162b8a8d026d83c9eb20cbbf8351db56e64e8a83acc8219960f1f616592c29d411d5adbebf1056803c2e840dbdb6e1de93971eeb85210634860b18c5c1929473ee44b8b2b413157bbf4288eec6c5d93d385352b356d40df298af282c2d02f52660b15ca80a006f97ff906f7fc9075213324ba862758740ce68027480d81f2a01041670d09b9d53051713237693d4aea79a4b0e0efd3db89506ca95e62a088da051a4cedc0ae6f394f051816326e65022b6be7d30d8e4591d65007459eb4f4d6c7cb4a430f6568d08107869c0a51fc7551949aa68f58216ed7ff31d8f2c44368dc283a3a472f03a61627bfb5c724234d2cd6cd752d288162fdf3503079f7fbc2e2900a4b0be8c1823074c38c7a1f349b209762ee05bf1bf361260949885ede0b2caab4f8763048a9bec67276c72fee15a719eb0731581408de9437ecfe25d117a9ca24802d6289b53868240543aa3037f58c972b2f138e35173922959afdbbc3633a3f8201f570cea5c0b99854a17c48469d441b06ae5fd366708ebd6adedd3b48f4bd8f6315dca7c4ee9f52a2602791e9fb6eaabcacfc10687a1e07bef373f4f25c51aeaf20d7d0a6c1570f6d87b6be8383905faf6e621670f0b85e63c7533d9ec85a585780adf187ac1cc86c38fe18d958815ea2f8edbbe2e543820f626ac448d199eb451465426cf54fa13665d89f0ed7b6c7d374c20967932faf9df8a116c91e44bcb4ff7641462bb6dc1755f3649f1b2aebfa733f242fb6340302496de33c8c14f9ad1f7a141d74f24aecc5ceec8f1d1739ef394f211efb7888100e121af3675beb87adca6db4ac4ca435e2d08f97009c8f721592842368bc9d63cea9c956c325cd1df636bf952ed0007e449872e663f174531cfbbe488ae403fe7a8eae1e2758d794f9c7ba01aed9121e6bf7dede2b4373eacd975829a07b2909d692187b312870e46991e91fb158e2ab0aedfcd89df2b3bb1890fe0974eb8cd58741ab6feae24b00266e902a1f1e23cdc5a97b5a79ad82de4eaf7c48f9fe57dd8a235576372ab3b4b906aa8249d7e58cd325bdb56dcf9e8ed90be983b2718cd2c97f04d287514a21f1e0de7654c2aa159e971b113d466d4af348e34543550001fddad17a97da28f6fcd81396780433bae9eb18ec57cb9a1b013385687e153e25fbc1bc8b814562e5060d4a46c47967184c38abe3acd7c4d5c7ce01a8e69aa8073ecf2605463b5edfa5e92aa6cfe6750efa0a141c34dd3e7f965a8a5897a06f3b1a6f8f15e1e08ad4dc99bb93eab1f0b44796ef722de4c776d4650d52741a70d8b01e1976a58d6c1fcc19d45d7e86b8641bc89bfa4ed323c8ed31ff3c9613728e76314fa6ee45c215eb1a8ee55633be88b5de74e2714580b1e1ae0e75a6ae1af870fadd7bc4e459f3d77c68ef39c4830fc450a5300a7e382e7bae4a5b40c092898aeafaa77fcc03c18b2401c38cd2eba89cb58e1851c5f6f961dfd478514b5b5f8d0f362d510e5b3b5b808f57edd3e9b5a3f04d2b506d8f82baea30eb104d9be563433eabd35d56c68bc5fb20f9389853d38892b5b0e2e0b5acd943e154a9fffdfaf565a047eecab54f547413a5085657701101b5bf5e10b2f3bcba0d8966ea2b14ce714f95f96b827116a73cb5eaea397668015c54abbcbb7d54a7c7329acd702fd12680e95d4065dd6323fa05d3225ee34fbf69f19c1551e3a1dbef9afcdbd0e2ac2fe395d28e491415d4805e23c17c5b953be3c0cb7c2762ff075d19b9aac8e57a1bb8c4cfff79da80af57e8f480232120f59b269bf91a3ea186416f6880210468a593033667ee584d343f6c76d0ef62a6b033796f28bae65683df06e59ff5de0cd52d529d247885d453d0153b15d8a35d91bdb132473cbf19e014d538af5b2bcd88a97a748bac472625abd15925b9a7bd672d946f7a9d01fdb2a7c62f9615a112668cc56af4cc5234f1c042a2344b2ae3b3ff2af4388c6cc97cd168b48140de251a80e819c90377f153d291b6794f275ab67335dcfe77fd247a773cfb38d274ebe2a9ea8ed2c8dcbf16e838a86f97e1dc3c37466927fa30164c19410e8080cdaff6fba3c4cccebc7488577a9cf71a8e13b98580b4b0e5abb7b307a9437a371ca00bd52ea4b5da3240545a34cf01e2439c4ec35d0d9b023e7d637066c5ac241d00de5c13d1fbfb2bae2cddb4fb6deee7b804b6287b5fd905f95d6dc20b2ebea581f6cb8199ec5c6d2f27012bf42fb4ee69a1a0a658fca6d71d0e7b656bd4dce5765b7448fd538c5ed25a72e320776bc62aff5da1a943d9db3e02ac87aa4d8fb418c68b343a83130e808a12fcccd85e99de14d15ffd967a6558cb7c299c35e5847cc364ff27cd9064aeaff5b905b648b74028fcc3d7a1387f7f3a3e759b6bede4798bcb2b3037b8d0f1a6dccfdd8fa070e7725765034a8c2fa89d7a7c832c8d4845393e6a200e680bc8607f5221cb5124c5118e6b6c86e68ccafcff0cdf9f0a1b17e2665fe586fa3789cb45476a6ffd6a2958992d39f3e94f22ecdc9f5592237cbbb1dc1e3e36ad110eea311991541f9cdfb400e307e0d2f9721df1712d2d5200916ff63cef064cb73c71a20b8b8b61bb660b9d14a42a2ffeeb443075f507411dc5c01a9c832de16b129f2b774fde62d2f677de22def4a1b9b22a3d2bfca0d9b6a756aebeeb3d6e3d16146504fb2ec725a6166baec80a913fb32da68ab34c68654299f42bd8e73617523202f3253ba9fdcac5cf0f3354bda4da34964db7dce060ca8e76935db4d49e3d92361d4b156be40af2ebb91f72ec859c635700b73900e6dc233c87194add0b4999928b3d8a7e698d4e5eae4b021e6ee4fa49ba850f386ebf69c3649adef1b997b00b0319648784d85fcea72689b93ad4e1454b860f555e053e7b47b11634593c8b858f807be44c9921142fb324d4e3e48c843092a45c60abf67182cfddc9c6d58e38c61c267b66b4aca43816fd7e5357d112905e45cbe1b9b01f5e2611a499fda99efdaf1ef8d3bcd487f82234cc721dc59059f6737c907266993b6c72dd16d785945d6b529d131bc6037bc0b5c86bf52c71f05594a5cae0b92772263551d13d65158222faf20f2dc506cba8363247eba901928f27e90b05e53cd4853a170f5dc95a75d45b9e8a27ec470da850fc7fdfae434565f883dd6786475345e27dfedd13bf8a22b21c97cd6086647b3edbc5c1e0cc29495d17d8a4863599b99e89f1ffe55d3342bc34d06889eca955db8a2b8a91282a0931213ed93ee3122f1d7bf7b3aac20387b7b3615ac142d19d3cc12da52b16f88dbc00071fde0bc5f4847c63c0e1747049f14213235471be8851f21b85c2ed5b0c04a74ed589543ce46406b8e087","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
