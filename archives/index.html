<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"606ebf2211a0dc9a7b48bbf46fc608af721ff5c79291546e3c121b52fe1d39c729db572e7a30175b6814f2a2511566860a5a8b1fad6d6de6a3135928c05969ed6873488f7a25f839046fcc4a8f37970b87bef2e40884ae68748f0a26572f347207c6d09d485fcf1d7bb542b102b1ed25de5c4ec71ccf2b2e2bd4222a7c481f6b8d50dc7a54bf4410ccf80d48e42da453d9d46f4badd5b3dddee86b751de9886f2e298488443f3058560032c230995f7fca61069bd8c2f33b0301c405b71a22ee613526fd463e37c7255ce1f96d199b4513f37c53f85e3d5ae54449c4a494a352fc0c78dc8a168ed3ff35527a24c8abee90eba6fc14baf3b4a84670520ac0b55ba383527db5b325ca9930bb3b4c2fb9faaf7ce7519cffee4e83031ee85fa727b2dadf03ed56a34a37e7c245972130ec4e713e67dc5c1f5d370b1491344fca593d8698e7d5213b332255150b070dfb83426f6e68001f20fe4ebd895abfacc232e74351adc29c5aad1c0269007232dbf16c2b19116963ac0160dc3fccde47fb4be92b18014c4604115070a55aee807ce2597ff729dc88c4c23c5b558d65436fe9695e29b01094536bdc7502114cddd43ea739a6cfc654c7a90baa823b60fec9f25b6f67247e6d7d57386503b419448899575c9100cf2af483b5ea9142334c176ea291849293d52d43b74ad83bef2abf8c67f0a6de14082d371d544fbd35a1165fd90bb3b58c3033144267543d9140708efe607d6708c5357652e864693e9be4491cb876e19552e18231820c3040991987148d6eaa9ec18932957da70ae426ac88c01f4f237d294cc7891f712a3d1f307df7d448822337f34515c2d70a39ea1e37fe544a761b4aad72a8866d709094b7b4c2b4e6308535d9dd56d6119120827b7597724f87f0f31bd33aa86c65fc63ad59ca44a4850def529f6d708686add4cdbbf24cd9a789e74fe14da57b3220eb3d3f0f1cb31b33ddb35600046e7e4d7e76411fa7566f81f9ad16b72fc85c0bdef3ba6c4d25aab3f8e92e15bc8b8e3f45b9f5ddf64afb99dcb92109982161c44f659f8df8e91a15fccc39c486bb2e0984f6ee80ec46888c5505473e3a368e59bcb75e2c54a3341e2875b8b1e9f5311a6b5d0838eca9188bec013850f324045c975836e8050e76c1e3a26c6f540c48a6e564c56741e67c4032747223783e5091c57ba1a693e1d446af38ee0a958532ce15d5c69b643f03b3635cdaacd027d8e7c596d8dbd363e9574327148d126baf24cd36b8d6691690f35c63632a79f690da46fe655300dde642e41cb7c1dac7da3be19d98b284ea1752261d4caac3d5444ed2058297fc8b3dfaade5119af68b0be8172880fce517b4f748897ce7709c003be1aaea923dea6921c700d50b77a7f89586a99775e5b46b5bf343db93cda87eb0b610af11fefb0bc7bf89d998c0a7f2bae9195d89b0294ab8b02f8a13e00e072c3beeb0b87ce78a03838cbb44b25ec3245167d1a557f9b74120053c8cb2848124e9429c69b9f0b75e22599e9cd349e0e56949ca8d3f40747dd50a58cd925821ab540e6f0c4d8ea757776ad8ead16e2b85ea283f0c910ae77c819f0cf50bda8070bfbe13ace870de4d6f68a35ef12ca4109d321181b7c1bf85898f386c895606f30ac9aca125dccfe6f85c7e0c8ba56aabb598c0d2c444c9f7019d3d2b4a0880ebe2f4993dfa5ea172abeeb2aa3f0da0919a6c4b9a1408d9ae58f05eab576454627e4913599babd06327ab774828d1e5f54ade3234105b59c071ce7e22a0fc25616d80119bec7a9e5e6be6f6ada4e5efede2defa5aaa93833f3eb5df8fb064d7a96b2a4a755b1fec47643661d4561215f842ce9231c02e41a65e7349804d31c4acda0ceceffb3c10dba58e692b306bedcfe3f05fdf1b2e5615c3d6814759018cdd8c0f4adf45c2af9f9eb3509e86ae5c2e81196be35d42c2c08df19fc11ae60c1c9943987ff2a5f6aa9281bebe1519a914314506e53faf01af73b89aee267ecd3fe1214d774be2bf1939beec872fc78c85d5807fad66620f7a33c29826bcc37cff182b3fd6d3839a2c5ee8c3968b95231d8ac1988a6d80e594d97323327a24e3a0ca37fc6676241062e3704eafeb6105ccfe5c2dad4dd5c16c5d7d5d4ef6424e9144c7f0be1bfddc0d2d961d452c702d219a32b6137eb0e414c4c30d24373004dbcc270843d240c4325f03eb1ffbbefa3e26a357bf69320eb6278a8a40b7bb67b2e7bfdb1c117d23d89915a5ca77c390b757fa230bad1972900318e23703b746a346712d14a77aa2999294dfc1d0fec5cb6d55da9ea6ef402423ac6843e7b6e36f20c2b2e67f6e239a6dbe3b489e2398b4a94d55ce3ac86f9966e013b961bf14d26de674f7613fe33bc437f1aea731a7cb1ab3194a1220ea309c3f044a615e6f0fc110331628dbc7b74841ab1c25b7f57d0651da0c1417ec11bbbd78466f901f53b7609e0bcefa2f86635ba9091c2be84c4170ec5ae6bec9362bf618deff6ace16dd18ec4d42adb433d54b159e227d9270f29bca1abdb54d8130fbb752a9db0d702e67f5b7ce81c0cf76c29d1fb85ceafe4a03f70ccf6191cf86315331da04336d2329d2bdb6a2807af736d462de126bd7ff86ee42bd49cc0176ed7418a8060a4e0d5a8b25f633d7b9ff758aaab713004ae96d57ff9cf3cb3ab9ee8ccd0dee9fc56cc50e22b1e3e74731c08ee97a5ba8a5496a459bb5e9740dbe60875b842d2bb7ac35365e34a9cd33fa9f908ec8a563b98f6918b0e69b167443cd1488095fc6b74bda08bf6fee5395e247c44ee436c06b003ddd8954966f48dde9da7c8fa526b6c5f9259d7bf514f4d21df06caaea520fdb38a2e0fe19373f89ba951ef1bb6be5c27414c771fb39d8f38caf763e744e9c7aaf8c00fc8d2c212c652df754ef30ce561c1bd1538f4f7c1e8e63caec82de95dcc3bfd50dc43833e1f3ae86ac06b5b4282841ff2089b5cf299dbc47c73358831d064354fdff69f30f9b6ae457ece146e912bb3cdeafea7d4200827e59c0ea03e1e273ad99c1a630ad836478f2a1918787113ed5af87ad8d56d1a098c03e947823086a7d81b8eb86b96486829a2aaf867494e7839f2c3875a7992799df1923278205b319be9fe9261564014b2fb44fe53158cbdf643433576f7301d400e75a1d78afa3d91a78eeeff1269ca3aa107d46fc9ae14a93edf60aa5127c09f56620055e0d160a293d53e950ce1e389b5cdd1e8570689cbab94180ca7ec0483bc5c1012f434153d66efaf6906efb10538a6c5eb66410a7f921d43744358c376d6b65f1be8d17adedb3084964feab4fa54196c0ec66911fe9c706a0c4300d131eba12c01560b0acdb2575ff8b5c0feb6cb8eb7cfdc94f3a5989dde443ac4ac73746bee26215b37ee01c512dbfc79a5984a006fd81f7f4fd96937fca11755244f6404f248a24cb6a9909cbd4c84e593101d44aaf655a378dec2de72cc600cd9cc02245fc250c4517d5aa5d630be04980d1b1040024cb3317aa08daf2f88ddcbc92465d0b1f4fe47d47468a867753f414064fbe745479c5bf539a05ac5e9bff4cc360031b909abd80fd5708a4cd25d8c05bf132fa1414c38efca2956fb25c02c9cb97a423873ef42cf16f0d8aee5ba951e2f383a5eb3c2b9a2403d6689700537d84ff307b7357b6f834d443454337e9d682b8a69d73d0d2ff88e970948f1f59755a30affe36052590ebccc49e708e9bfd4a5b1b400f7d92ab145386da6370068ca3c4fc3252722d6386532d892d7751b2046f98f891d014752e12870dc48ea1aee539141f62902ff5e1cb872e3cc0aa4528373ab3fe65821eec3103b9cdfc29a869f53ce5a7400f6d4e7b2027403f5880faec91cb020e8783e136c4bca16a22dfbbfc3171edfeb4247e35a9341ce86b32f5dc1667778a96b8b8c2d25937ff67d6c36a80195c06fe41f40661dabf30fa6b668062375256595ddada531162351b19e6c743f7a81a7de0365f203502e24eb591763a2571907c4f9a52f6feacd9c906a1763aeb09b3dd9bdc4eaf759a4f475130009c451fae653eb6fa259a8d873dc5eabeb5159c2508e1e0dfc9a5ca39795acd8ddbf737dcf100ec78db21ba6819c780a36c16d6adc17e9befd5082da0a3c4d425f01db2ac0aa7958703b2ff3551ebeda5620ad06700959b6e51f5ed212cea28fa2e370d57a6efcc39cd721b26462f4cb461cf6262c44f0bcdddb3af9ece4ace19353b9d1778f0ea2e3687a5f2ab9279f21ed9d93b6d89863e778d1fa356c791f887da37ee9248ce5efe53ad6424fec7f997881a3ce4f3e61d49c8bc49484f9a79a675c9b7e18cd07239405e84fa93172119a17d4066eabb0d6e3251dad9988460099d8dab1bd16201bff8573587f01d1e8382d73c286eadf506de66517625ad4186667cc28864071c9e81ab371827d39d70003c21980237a772c324ba870582af217d761e96977c0b826961528d6b4882af3763d36b0a9cd6a6738fab2a8e80ef3d700d914b53e89de96672a47c1f95670726f30be4e0b4ea997bb41285c1f9e33ff0d565bfbdd5ec785acefab1eee33322e94e00d45c33edd98f7935f639f3a348741ecad7c4f84d23fa3f27c00841e5b8e90f92ea220a1db31eef824b2490fb061c6d1837366c135a6015e115b604252e1999244491793be519414a3ec9a058b39b7eecd29afc2cd8191ab8e07d0e0c59d04a267e4fab71587b60849482d3b7fcc992fbef3a65a4e1cb10f8456cd5e3734d4899babaffba454c0957345e6252e0612d3615725111f7a8c8c801b2e4bf497a5442df09b824ac26a54690f8870bca0826a709acc766bb66ac375cd6bf96a864fbd2a7a36dd309da155724ad7a57294c5439a885c5e742562957c0f6a1e14d2e03b661748ca7a7969e14a44429b16d1df7893939a52ab2708b57a56247e1da6006c23e7894452e2ac99fc0fadc6105d8161ae8ab408a139c521dacb7d14b4691b48ae6ed0ef863414d82996ea35230986e9ebe5d98e1f065d28847c36f2b7503db807916a4a70cccddca3d064c0a2715598185c39ad34608536fbeece14c1b56964bcd18bfda6929cd07be063b86315e37ed9e4bd51b10dd4b9931f3f25d8ab1f6680f73b2155cdaedcb6aa6bf647ba7ba11867167c9b234317b99bd88244854fcd30e637f0df2a816c18af44e4dd8c5229150c4bbb24b8d368aa2da5889ad7749f4f401595dc19d058140646cee724e5bfabd748b6e843f7b69853cf9864a87efa23eccd6f2f956aefc2817f2097ccf609e2308932a662e291c5091bd862d653542aa96db8475bffdb6d9f1fe1d056ba70eec38b202f97c4f647e743f7a69ffa7349dc56bd651256d9a260d349d80314196a0f25f742e10684da270243d107569a1a3c0c620f449d386b796a1c256e280480156de1fa75f57f726dafa15a0b4f29a14b0d96cdc72d3f778f38430636a501dcb4ba4500eac62c4cb2b8164881694767b98fad15398cc27050428378b0ce7d529108a85a82b062e5ec959937535ce640dca332f4431f2fad6d918cfe1f9c9c36b8c4ad60520656a976dbc38c0f7c8c092d6d1dd7fab37931e2c4a581533bfbe49a7f8a65fcedd5eac51b4a270fde37be0b35793c9765cf42b2dc7dc35c4c2ee36c966ab2c6b7719de53f8875a1299e45fe12aa7d7e1e1003eceed80ff8c09ca994f1b25a7d2e46f049f4ebf1fc1d19fc273cec802a1d92a110ea4c5393c6f46f904ae8208c7feebf5b83f808d6bf6787078b45e0bea098092f75ec10e3c2920bbadbf08c06d539109fae9ac02909c8411eb7ff01e3000743ac0f8f5d43d09140940bffafef71239076f2c322e6aa6ca4e48c7794b3e9fdd8f52cc62aa40483a2e11613445cb9cc4119dd7b41774076cd0c4910e9ed7593d38f54a1406022d1a5c6103c86e4644a651c4a3a1135d0725d0e9df9cff203980fc74dc5b25f616ce889a22b8531b3ab60cca89581cdfe2261814e5d689709905f5f63a52cccb5962a0243e1054c1ee650898d3e04ee55d4a5c9b2fe79da3416c2cea0ba0aae098741e407a545169bcf958438904aedcfee475b52e79505bafe1369c684bff5bcc82b30862f931a1afa880809b6f5d8ef34ad84500b782c8a62acf471888e931a12c9adb09305974130a664e0dd5cebbc327628655d66cd1eac2ed44a8db28886808b8184063745b3759275ef1c077782e9736046b398cb0b4e994426b946c283f9054e51d5b12566f8ce86ac35935d92f20416def8e1b2bdb5aa0b8f3fa74a15593077999e9dc9c436086474046c1302eebb78873897470b1ed4fdf6ed8e692e16b3aa6036530b8a6d60ce806bd17f78455a5db4e37cce79a25b0d3a9ef757bd3222cadc6667058d00889b875ff5b8cf673e896d654403dd5d56a5b894c22668df3206e691d467b84f221042dad8674e16b6344b2696c5dd79d14c7c1040ce929d4e9ef556d68759d0d027284c80b4b430cf6c6f74de648bf28639a43242b317173a32c021df3a4d48d0e49c7d1ea99086979a339a41e487aa4ff71ea525a9cd00e286e4e4d54ae85be51fce00d3721cd4785770dd68e9b454423b680a0817a527e0c3b39212539bbbc701b82feffa7e241accbac79ad47e4a05ff30b9454390c225ed0238c91d45e69a7692693d2ffa6567e08109cddcc1c6235fb082a1cbab9ea95c586708514ea208c2a08734eee94f027e859aebc5ab330671f24f33f28d4c738761177288524ceed4ea69256b4903741863c2d7bfa98a54136ae8d43fcc755dbe893fb8f9facf1a5bc54fbcde4abdadad5ac76c5172702bc626aec37abbf3d34073ba051267a264f1f85fba45d82932a5da61215c5e79966cce53633adcaebd6a19118109e6c72717543315bb08b89e0f91e66662af51728b90703a98fdce97b3a091c586cec7fdd51f12e24c6d6a1d645acf505049ebc7a953f035b6441d44b969679e4ade5dbad2e1ab08ee12956286be577e3ab7cee2eaf122225e0deab08e7317d3f2b986b78459313eb5e8d58b3d412a81a95678cb3f8dc9a504ebfc14ccc3587fb92ae7773e46afbd79f80063c8a0c226f821a59e61bc62e57c82338c41d185012cd6de578876972192cc9e8b1e00a42dd4d0f162a5b63d72dab5bdf2bfe05f80f57f73b4eeab8dedb1806c0babaabee144660dfb1e1d3187a4b125aac1fd78466659bd6c3e4ea80aabb255df688d2e5fa2f297fbe88619b6f6602c87bad42fcc48b0dd27c24c919b037e1b74f292f81894cfbce64f44a3b75679cb8243bd74610fbb4b2f0e4fc8caee31cf8c25326deefa2d6ab0550e01876240aaf2e4cfc6bb8c5742bbb8945124ed28aa2f515f0ecf2918c4fa9c670a4a650bf760736066126602fddf43eb1e439b4a8cdfab2384fbc3a67835af0bd3b39c55cc4e82e9dcc0fb2be81dac1e78fa00fd252229517b4e52cfa108ff93df2fba734aa2c1cc6425e47df32165483875a0daf32218b34b9ed638a4ddf620cfa7ac49cbdc406752cc4fa7f4623365f875b3b4ec074561886697f923072a6197a0066718c90b8400e47255cf883c1c60683dad703e698fd665b3c800a77db1ece2be928589567e9729eaf6be3cd7431a505a945be08bad6c044e3979415e79d98fbd1cbc1566ed3862bf5992c1046b9f7318e29d0ab7cc3c55475e9aca670bcde74496d0603bdcaeb994a46e7a2aa37500ad27664e4f48827adca863bed6c0829d73068ef80a57da9a0d75c539a035b8cc01d754cdb5a00db6dc830afda22ad15a25337ee9afdf9e8cfeca34a57ea66bc82dc8c099998e3ec35f76f3681c4a5ebd6d77ea7eebde12e14bcc3774aef64b39f147caf98b18a3204e50bb74e7c63c2507892e4ffe7a54100907b705530dc604af1dc3451345cc0c5eda0a6374eda49a5842892220d87271df8477c6fa0a64dea18b6c09ff2b3ea5649f335f0682971f90b3484ce4574c3666f9615a77f047c104d728ebce35d7f74d7b937ec19ffa9785d70d10d7e40cae7f2b6da7e077e5b0e78e61b6314744479596b154c63c47b037fbe9b69c5f1880d59b860f1f21e28a2b2058b5af27a820d22fc25313bd6d590048afb659e3922d9879122695fa18d6e6dd6884658d5fcd04089a95683b6cd216a14085e1e888b4e3a5a63038d94ec98e39111f10dec854497f6e5b226b0c357320128278a0ff2015ff17ce48d385cf58ea87af24f1760798bef3dd8bea49cbed09570e69642bf7bb687603334f7e74809917374c23788463f05ef25fb7770adfe148a4b014d97e8bcc6783d074e789abda078f3ef9121aeff21dc91a5217121da16f07b5da842dbec87259abe998402078ce61db5a996fd41674f34de37f3b3218f920abaf23241a21e6a65996bec1d723366ca2d904c8c41090b84828d41f5b8dd6dcba316a779042509a5c2aab70dab51cde18009278dba40e110d07ec2174cf51d69b682e5ccbb943e84b09f7784367ac543245268f540c0fd93166a1893c94fb1e944c7bdef77395baa42e4b9b9d4f8f40813e5499dbbe128a3b15e84d933272d38cf3534ba7155159d89cec9665663b56cb0da8d94dcdad69678521eb87a0a1bb4f9d4d987f45486b53efb16c8f7b41d6329e4d032ee4c9d59dc20885d60c5c0544857db299b5baff4b769b39c86375a09465cfa867e2d0a400b664237ea468c9179ff9abb8652a78cbce7a1d573ee44bb026004903e19c3d600a1f1bf5cbcb67fb6118cd5d7ec68d996d0d8e211dce1cbc6ccb76e4dac210dfd24091dfdb43f12e9fcea26529a836df3209b97123a022c018dc994861769410b282e981906b1bd5fa28061c3782cba2476acd8a3757408e58fa3da07e7b5aaf85fe39f8e908b264af8e468474a6b3eecd2d849708f520352a6c00f83b6fc0bafd04a72cd280681ba2bbca3aff4d6b4df195c34501112d581dc70327b90f7ca51d72610cb538febaafe9f4b6bdf4a86f997e72ef1cd606e34a25cc0e25764fe5e7ca6925632e413fdbae5c00d2d450f91bd106fd020c248b3f3d44e35573b1c2f44e8d056a2feed730b15177589e76fe19d47a58babc221d84a22091777cbca12b72867f81de0ea8188bb63da32892afe8130670e8b623cd78cbf8c882d6165f4df08e602d07c1e405fee653f705c3a3a18f3105fe9dc52f3564239bd49ef68a3b4a69e48de2f5d3b9448fab18deaca9acb6063aec55a2132141bbb48a2b79f79a7f376ee9c2ad9077ce4080a0efc056a3f52e4cdb3b80aeb5c1be4aa05da3b6f286669fbc2366c1f54b0b6cd07b7964b5ff556e0951df0258b387b11734ec5bc81c3099c09d4092621e5b3f8dbc5b1b3f6893a83a27226a1082b545b5177d16eadeccd278a50b1528b27a945e73588b0dee8299e3df51d262f500c519f789e4caa5412a093ff6d200ee18d0430c549bb413210c80578da522940e6a5b794e4e4050bd4d0bf0bb17db7dba3e6793a26bdae53316b881336e410602bd301e356e909f234d3ff1b229d26ef4db285991ab089536cea8da2e766e5e70682adc71bb45877f66c2a9a560b00fb6c230194e4d51d28b2dd85659879d74d844457e81bda4b93c5bd7ce7cec0d8844aec1f2e1d86468a61a27175bbb564bd788e2807aafd5c9f6483fd1aa2ea046898b5ee3fbff4807a32fb0361e21e1051dd07f976480ef11b8ded341783ea1d8ea576135982eeda5c3ccfd4869edc73b981142c4cc73bf424dc74f4ffc7196a1c9a37e75875ca2d5216452d42d9dd262d6f6eabdbd39022bc95791a442c276f4ba45d41209b8553046ba8b9c580e3addcedc631fc61735cbc38f42dec7016e59ffa851d6fbbc9683f3e2fe53e6bc255feecc2a2c26bd59f30f6ea79a31218639c35572a3b3f373fb68719928b5f6d02d05f14a19ca283048141a9e921ef19be6fae11275d7ec1de4777617780cd6fea87923f9dfc32a5de12838fcc3a74c12b5aeafd4b9303f6c75cc92909a69c5dd40029219fd57d51b297b27463dd01b1033f367c6e172ec2edf6a93899b67719f8a54e2b3e5d2c89d4f57f2002efe64d1acd4fd43d57e1b677915a943c352f69a5d7fc4de07fee6b8b62416d5cbedc040435c9d324a3858b73e48f0c393b8608db8015ce188d43dd8cc920499115bc87ea7a9f3eb09f544cb637296fa5e12da7ee988c609836f98809f1b9ae4780a2431b94901363c1016e8e2bcccfb749f20a12977a18e1b39d519e7de5724780a14d4cb15213b54b9a19b7f14b58765d9b7fc1ce76b98bfea189ee137e960783a44c8e5df6f7bfa89a5008ab26cdf146ce1e2538ae0a0b5cb0d970c0e76a137372d45dde23fdeb71e58e49f760a6a3790d3af3f4edfcc8fc088604865058e3ef129bc8dbd8993d903c8a635efb60eb9f95957cb20c6e07f63634334850fadabe9ea5009c8f9421988a28ad680595f58e0b416ffeb836ea70c90c038aca6c8eabce36ee4718cd1083ec00025ec28dda158b9834ac14a7082c69f8b8919cbef8723fc80e5a2beefec9e8fc107a281a664fdb689fb45577313d1844e31b1f39ce1f5f73a89f834e0fd37193f5b6f0e053379d9e8b7aba93018ab5184ba6f157847ef8e345e10710c2cacd1c44471125599a1df004b2aaaaf3a7c7372620bad70c96f93661e9e3c358dd412673bb733935f5e7243125cd24e7c568fe4d2642f543808118e53d75e16cbe99a170bafcb14675bca098d3e3e5974d379f3bf1eb141eeba94c72b28e72ee66023af414e303b33ae3ed5183e60f6ffb4645a69f3cde33440cbcdf0c45dc7b17031c79cf7ba11a5a9ed0300a34c69b02ac8d0d97621564a4d023e093f81577919727b458cb2604baf92cd9187581d17840bccecf3d4f51252297011fcee36541254e4e21b96b1d1bacb2a201c36b65dd7c7807ab64e7d7db2a5e0cbcf1b723a63667a7027f277853aab2895670d6d45315471aaa01626a88d1a7207f26b10e16a312b60f3ab8389895f0012b2f8e71055209bf8ebbdd579f251d2ef35b1dd83e8c79502bd58762372e1953ee67584844c20ee4ab87b25d3152d2b7d18cbd40e73fac2a8772dd9a7b02e3e3c95205ffe1a553470a917ea72d1920203faf6d2ffbe89a3179451f21eff4078a730d4dd897d9d88191246c9ebedb74574f82d4909f0711f363838ef9003d6313ad99c649950b516438b6d3877a2098fcd06a0e03c5cd0c9d154efefa39f5863d174fdcf07b6c0016c66ece12efd26ec97e54907cf4259281bf080b524848063bed655557c47345b127529c6ec8063bf1c0f805df8740c3ebbbf8781bce1a2a234c11dc2161b4e117feebc7d66ce35900dd538efa8666a92d4e0aab5209dc92a7bf826210e3a9b4a64b519208377bb2a77add34150e8f1fdfce6c0c4465717b5efa48044855f68fd133d5ac00e564efd2399e2cbb39555dd9524b8a2bbad74422287cde8c0faff7ee3cfc5c07e2a1a67ab57159aebd8dd6b3632990e64c12bd5d6812bbf85b2996ece6af14599e8af2973faebabd7a23f214c6f26df05f82eb7369f0060813aac5e06296dfa39f1648a0198aed85c9509a196c376a7254dc028959075757cb28cca9c056701cf4952b510f8afc679e976b48a1a042eee2ff33cd344973c310e26bad91fff12167b9452d83bbba1127ca59ff74cf6723af4e00ccf8b5079c041767d2e237b1057c3829cae41029503343fcaa3a1b96d3a372f64195ee0519606c60f4ca62a4f7d885a6f21877a3afe1f61ed930f9c329229cde3ae20999d16df87fd340f01f0444310450608c2c779ea12e622691a53b3e28ee91c54c7647173b9d7c2eba70a7f875ad5a67d78cae3f59353a4a7c94bb11a5648d0f2b05f4295fd6707e164507a4bcfbda5f778e81a5664e07dd918b776f5b159c31cfd854a74a7df1c008894e025d38f9ed0bed9c64852e057fac474a0d6e13a57339cfa44ccb88d122bc2a7b5946bc26dea483e4000ba1ceb5aee2a1b99fb732084d313430f896bd749d9c0ebe7439216fdb1212bee8ee0ab59ab9ecb94253983f1304f74ab6876af3ed45c906c3f35126a39889b4d1132653735e69a0c17f27a95343afcf66ebafe52fc60e5f55e5bd9f063f403a2c6e4982b936adb4e5a2ff5f0a5c4c0e903e71a5d1b011855089b3f6e9561099dd6b7a987a6bff3d0c6050194d51f78f9254f347b89381e7c72e580d5a8e77977912f90a6bc6a22cbfd980e57c734679d5eab8fdc11da064cf2425b45326bafe2e11340e5e4d63b4398c9e83d59105678daf4d8e8c5753c3874a6880e0d8b9e3c002fa9bd60b59b431bb517d2a2beca530a04b542e982ca59f7686c349aebe291e2418aaed8d0747f855bb5037c8c1d826b7402a5ef0caf1b4a27c537da38443fc1f5ea966e2411a035be92a45bf88ca2f2c305c53b0c9a69c28cfcc1316bb763848b588c7e5e310ef422d42c5e92a6b54cd423cf1750ec92015b359f27d7a416e53a319fa274877921bfa464b347cda064920ca84c15d0c6e0f9d7f69216b675fb6d7e137b0e5bd5bd21a334656ce7df3e1ad16e07730f2e0bbbd93e8fed553df1684f136a4258efd5a2d0d2970560f013d02f344f70e13c8d9550c8bb08cd3d9f8bf12d79805cc74c5f8ff90c38f9295e632c34272d4b43326ea223cf1690fa176023d190439a4126a06e8503633b07173ea386f38e1dda3bc9e27b859c942d818ec5ab173a5b62b2b3a74ca2cccf36d5508b9643b29a59f305ef76f37528f3d2c97b45cd0d29bbf40de6fed3fad13759a76f20b2c13bf9d345e226b92dd23f74beeaa2bbd91e412120f37e9d009dff62a2669e1a6e924ac6bc90e2ad9996a572cb3752499944e237bc026e8fbf82836a87f7075446b06df394588761396660d5b83cf5a43e8a4409db9fb391e24d5f1c1281b70b15924626ac2e75e6a18669197f1a52d64fffa4cb091b46034fd86d97582ffd935165af57854e9b5f7588302a6c1f67146797b062fde60a3ec100f0ba415f7c43df23ef9e6129223c71c990a9ef352520bc394f84513ce748cccd61d22d5c2e2a1f505198ad7b83f02be059811c75d5d55d8a5771b1e1edda1bb48d7b5e2e608f0d9ee189b42eb86596d363961807c1799e47ebe9b0d532c655c651caa797df476be13541c7b340c195b675baeee837812afbc67af126de08ebe304eeb4bd1d70976abbd8d1df22f55ea1bf5f7a672399ae6dee9a07bbc6ec27c560b21788d873c79a32a6bb02decb1d834bfef8f5ede7136f29e5aa06a48703b9a72b5c3a9b68cf318affd06bc99c054afa629710a46b50c401fd87c6f5918878032205cfdbe54badbae8da5a72d2112080694100cefd5e87f832d17f5d6d2d8c9ba567abc4292765e7f2d60f316ab640a907e64c88de31457e58d1e5ac13976c67f4abeb0e71cb277ed2297a28b37995165d5a60671882802c4c9532857f0571e97d9d0803c46ea557eb8885753ef59bff1d54812efdc04c7aa5ba780fac6de54c6b44c71a69e26f09b08d7e92a8da1dcdaa6e9443ed38193efd7e6eaaec29f7e8c08d41348eb1733f8104060784347fa4ec5f46e52c3b23e6178a7ef58ca9eb1edf5aee0dcbd761d566cf0034359d66d8edf435a4ea7248a15c79d6367c16480d80c3bb7c3104add17fe44bd6ed4ae6edd6ff1151b53830c668cc67f051a478f3d2d401f22c7377c77bcf1cc7a331f0ae0ddf29bc3c6eec16a58668acf099e5f6341d97d11d8d4cd134300ad6622d0eba12a7dc6f6e6544948e571a431b1534b7b0f0214312ad9381d3694cb2d1856faaa73c776c2b0e48e931ed130370836f8490013ebd4d1f220d299cdd6db093b46468301329770392bebf5683116825480cc44f26b8bf2f425f89d777a762e3d8d8d2776e464cfa9fc5dcd8b0b1dcfe712c8a87f16dab082d4eba2f15213eff08bf7cff1b361195b6666839d2d49d6d80d3b53169e699354ffa137c3ecf7e348a7e2f7379ce9f4142c01c33f4bd0260c224ad96fea34b524e096cbd96918645f031fd8dd07ac91a6bb321bea74cc73f0685f2340794d781d8dd5bce7151a7cd385b06e8bcea504f876df1ca90cbeabfcfeef508c662126be30faaf5fc3181f3a7b2cc9b21f414228124723f2de6561ae55f20ef678c8dcc3ed45b7b912aef846cc836a66db56931b3838e48f322b98e19b01986c8e7fc6916eda0e3450942070a2a73cf071ace5702185491f242141cf653e9ba69e8e160f7abe449f0f3acaf8778c8210ef5727a9568becc5844e9af82936011840b524e5df99b811135e2a364cf34f9b7789fc40f7f1ff140ec0f70a87479a69527ba25f823be322b0a9be3b6812f5c42e60891e1e0cf95786b4b704a0a34f734d114bdbc82e4eee2f0d3ef2aad31bf5e21fc2ae8ccf7c6ee3a7ecf11c2607ef6c386369270753a0486955feda763b9f06a4de97d70e2f033881a1b56cefa8c5ac68d723f65e7344e980b873a7bcaf16f23448dc067ba1a6e5c524c19967d8164472dba5c0b9648d3479bd364029576b1b55986725e4e8c65c6d60d5713f01586e508bd7e5c121621a66d67216555a67ea348d82e40b5598f5f24f5bb2c96d24624dcb5e2a126a726d2f8e83b3addd70b9a80587f9cd1e1b00eca8af6f10f7892ab1ba01406d3009c868f3c30c438e789b3e2c85fea312e5a98e720adab9d1063d90866fbcde40c8b153b6e5905dc8d9d2879f2210981a23e317d69db5bf113cb9330bb5acf59d1ac6f1c0bbb159ccbc7e0f1537e9495921e5e1c15d9c39a75791471442715d200302d2778ac286353a86c698d1074470eb0e4a6c7a3c7189930ef6f8b80697025630ef3c82a80aaf92c09e7ff3427687acd64ee896f775e78f558c20440764c43ca094b9649ca7c3ed23d45ffc27528b2da23f286e2ee22315e878ade2514169f78e372cdb36553959c16be936b8c67a99d4211412541bdd3dfd970b02a1f48182637c673e71f43b086c72a7ec440a493bcf7d1ec2979bfa666c234342f3dbe5aca1e9258b298acf3d24a20fbbd20ae91de2e6e6c985724adb3b1919e8ffb53361b913efa2728bafef024f8263cd96e10b4006984a20fc1a5015ba0e68ccf347bca57488d26964d3dfb4beafc2d1e20695f439f87627d22d21f499cebde407181145a97441e6567bc44d703075d1ac4dab3b88d49188c9ca6296eb108d9b8f2d0a333fc5e8e797a950ab66d643d3bcb7eb894bc5be8f153d0c2907384315e4b43ae509d29e739ab6583d2a8ddf25de55948bc5336c80bec2e9df51f9a0e093b7b1e737b6930b3bd60b6a249a17a863c46b9acd685035c3691dcd860bd8e599dd559c3242239a9e6f670707f6d2bcc2c1e4b5fb2f629fea77b9cd4b36dbaac6e243e7d81863364ae13a5ba62d78261f5e7e602b628f2617122aed3844e5de6aa57fc883e2af5e8d8af6ea2cdb712fe4dd8f7413fd1241fd9d9c9736656019061e586856750d06f56f099c730174a77997e46dbcfd8a22cd8defbf7f488c0a0857fae77dfe6d5c7db2db896f922f6b4aae08ffc44c665bde75d16516c8c381facdf2863c4b9a6b62a4779ed70d0e6a1f8d556babbdadbaa98ac389f8bf3138fe08824d4fff4d8a318d921d7921a330fe1309d7a3b888cc7e0e06b6a4bc79bab2687954bb21a2f357c97178582d9414bf243edaa801fd64bff812ec28dff9129364de5acb64adcc771053840dcc593177f744cf32d4376c4bac76062063631669165af944af8b9af47ba08c076df09dc187707d98898cca7ffc9f803bcfebf7aae8c937c08fd2354e36e55b00d4b9f1edb1c339a2053e0ea359ad63c19d6fb4d5a03502d346f1dded5207fde95d089644ebdcdae3b796699e03282576f16f1fae12300c96364ef2a7ec8d3e469b2fddac0adee13984acbf0b12b95f093b80a1d46d0c61a4ae4c909de9b5758a239cc12bcd53110b07d01c438188a97295383984c6cde42aec4406c801901e14d1471f30287ea0726a6a16e58335f2c903e1148a999f97f4f02adf097d986600e5a3eb0b90b4767ca5e977efc25e4af1d16925046d0bbe4a85ec85ee8a07f5e2478074c73244d6b1dfa98338ffb8185ab69effe2e4602f2654a415df883ee50f5cbff66402c212badde89d07aafb203aaa647b47e7359cf59402ecd39afb48c32e877559ad8cd0342c2613d22329da6184e6948ae38ba2c69ca94059c1322129947c9f05ee289a48d181eccf1b16e4b85dd80e7c3c9890772a92e545f69462834d47ba994a9dfaa4683003c2cad253e878ed1325c3803326fe180a053d78e43b6e4aa2cc0630ec11fc19b98906a2d49f849390eb3a4ce35b3fbabf97a186f3ff9853103dab0cd0ec1f36cd4cc4093c7ebe1402e9e97e63707deda08ddff85978af724b63ced9c488c0ce13b2abe9130697950e32b53fe266826a8dfc878ae579db61aa900c7bc998644421b0d67becf196f20a14926a5ca14ebb891347939b369e88816909f9d475f08e0719e578b7e1b10cbed176e4c357bf9d06fb8e98fd61c6eb01285af35502b05bd53fbcd2721f881c1d354a79b7ed23ef54b8a695d44a06b4d75f81cf9a6abb8ea11e25e11328e5e3c4f585211259745b1483492f612a45118696f8248458cc84967a877987b37af5240bf86cb132b4b0236614ebf01c593e3e7c5857e7354f799887da7793eda9aa2586bb5211ea690f433e51771f2bc91d41806e5b2143b1ade1903d7d3e853b73c45bb102fb3c2cdab036fdd33df4b97e196c91194c56f81309edf111c2ea2d8802fe8c3af31dc078ac31daa3f13c6fefc0b668099ae28e19767215916fbf2ae0fa5f5ab50ae2d79e24c4925226da9413c2d049a4ae1e3d4b434765983c25890eb425c86d4fe74cfc4a3651de02cadf0d089c1320e657a6961523360a00efb66fbcd64c108c99a0f9c5ba1c87a80e38fcf40d052400e74318cd14a69c6767a3344696ad6d53d94167210ae98b5cdf5bfdc1b12f0cf5787480bb7bc205f62cf38b656b261934c026ab25312c237b1864f9a8e771be1669a2bad3a763557bea05a61cd615b927c03686c773285646381bd81b1d316825f6e621457d1f1d2ab28e9927def6eddbc0d8b16e9b1b57e4ebed96d3c3c42e07fd99e4f49ffdff0f8a4a730316db892c65d24898ebbe27fe1d3df51ffa827142b5d9baf8185e53a2fbeeaf2e16a3e7a4dcebd5e4d8b2b229f8db54e6f2e9a99fdaf98a4478592c5f5c31487130dd391ac35bf3d3fa52f0d150847079ada94a712f55a2492c6814f4ec4ce6e7009bd8ebd081d024862438f476d9433f54ee08c0de791e755f321986647f599181984408e11597ee99e4ca2c46fba54f26127f496eb09939ec94da38c515812081d938c13683c9b2a3afa758f2549bb72e36f846f589bb35dbbe429de63cb3c29651ae578832ebc659b065062ea24fc69e01f89fff46f1f2f4d5023fc68963aee8438401a064a887f21f91d3a4e28730185c1e8800d335795d093873c00017518d33577d60f0b7040685d871ec3dbf87c17a116adddcdd9f55df7592210287a5b2a983fe5b53b4e67dd4adb600ddef6fc46de5148e82eea637288561a8a48ee331c2400174b29cd3491e4d518390e6131730fa250d1468efa35a34a2905b113054716de3b113cb1ea5b910b2f73df391e1c5501681192d46350891e92fc49b27e10fabc76c5fb713b4749d54540e298d9981653db1226edf341b3b717e881ce5b23edddea9cd6d8d6af35466134f869f0b0d06e345014ee6829854e3949da4152ada2b4102e4bab5b69e39ebce2725c67b6a31d72d0efb929386e34d2251dad6a5b265fd97d9f3773d30b2db7fc95894972a89edc026374a12cbe9858f2ee6a1b0f00bcad0889f84e99210b3d36eae1adaab9405664f9f9151b6c219f1787fafccf50d0790e0cc555cab22bf8dd2867f75afe29e0e08a536632d1310f00e7c1ec606a2e9eed5295459111133de95e8bfdcb8a55af6b122cfc8a212910b219b93a991f68323063a0ddb417ae8ebeb4b09b2298bd275d0c3ca4a64d6820f78769284888101f1f245fa60b88b0e52caa261b051c2b7e64c7925a0ffe1877e8b82e6038b3fe69cc072d22e6247cf296f390121475d4b972a2d77937b51680ea2f551ea431fb9f06eb3c72cab9540680956213fb0c57864f574346dda694117645470b8600aebed66c3275dd773acfce1f28be8ca7ec12c993302b9d266bd72cf0e4084950832bfcddfc1024ba42857405e913a6bf64103b45391100b2193a26cc7cb81c31d3c5443ae44c0bc74e76939ebcc5fd48f11d55dc9f332199e6e6ff9b435498a35dee0501504760c67112963c01e6003f077799f28dc55e31d5642d666131df62133f689f738be56035743948fe51519826f102b9a1ebf01e1b1e07bd66e98d9e538e49c3256a100b9feeca9d376acd8c1e118075d5eb5bf911875379347c21006672c6d0e31bd6f77c9f1dcdb41e138a29249dbe13f82649c181c1cf9b42ea595ba7ac3de1adeb02dcdf71f31d629c9ee0cf5bcfe18ba7203fdb23dc6d074f308fb0073d13d20b758de5ec9621a7a00b0ffde1e5f103f1c401abbb6bd1c5961932b2c9dd88eb6335676f6bc27ca1efc68ced0800c11b805abd6c1a6018f059994914dbd3b82289808a09e4eed5fd6d11086e4cb0154182032688ebf0ec13a9a","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
