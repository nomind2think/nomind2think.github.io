<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e81e75abf8040d74d7e37308bd6ee4e33e34fdc937445cd6069cef6addc7f10cfe3dcca5a2d4fb53bbe1b580bef7cab2693ef5d0f3fcab5bd482c1183a1d24c7fc6a34d0d94853ae9adb38482ba36a0660f45474e2c6018666327c770961ede4c51948b0f5813800675e128da058bf7fb54b1244c4d23ff9030290f3f3a01cc34c48da00d2de92573d531901684d45361eb3b997e52b046fbb55843caaf840f6a0a1a6aadfd2f154062d7a5335aa0a9349aff1930fb61befb5852ba89d22e7d8bc5a639e09157b526b0c6176436bb286522b976eddfa58dd9dee8a0b65727a4cca34c84880a56cefc633e33de00e0a8c3773d686439cad1d75f62cf4a4bb695e03dc774fb8efd5e1a1ecc427b9205e47d6b3191a18fd4567b70df855ad61ded2d944917e2ee993f260a1921dc8bcd99506fc41fce1c1be1f474561a7a6d5d288063ca749dafc31c07d2611cd2682815d8cea388e72309c6c79dfe0fed6d0b2dd75de0d5bfc5dcb1a27e8ee7586c44117f95b9d6b98c1772a8e0f29cf65763c8b328671c5ecc01062548aeddb1e4982c0e5cbaf1cb16f0991814fcfcbaddfd8b7b4dd1a0227bb92c8da67b8e5682a92ed37afa8480177d61e77ba7617dad35bfe81a358a313d5689c8d0c5daff5a0607ce256168cfc5cd2d0d5b179ed682c53788cf3f6142aef1ae8ab0911d5cbbb9410344c0066c715e0fa64a937acf59c9d99559717316b93c6f09c55958d9a500a0caccc72400a477a43e76ff502c9e781659aa700bdb101b2b90c8323e86c0f45505c97e3dfa9db4d54216bedd4cfec3ce906a65701616f32b94b559869e31b4989a2ec3be30632eaee549743f7ffbb572d4eff3cdc6ded2592b269247ba7710697e708d7fcbc3fa2f7afc0af2985d2119ffff67775d0267fe3744d92f0e5be3689ecfdb8b11afca04d39ed0a517987ce662c1587afdebb82a737725abe5ddedf606ce643cffcb7b4886d446470fe885745ac677bb9b83a6a4fe4c892e62d56666e89388f419665f80cd04d3afb77321f213eb2d5eec7ab203df58af8b26cfe04908a31974cfddf8b649c15c510a1c055a59a8602f5fa8e0c621b331f6923708e81220fee84e52aa3db9ac0662d61c1d859ae335bf4e3b964235cb360b4e12e1e0c0bac6613979e3cf921f7e9f4fb63e405faa9bc4e52144cc2b86ebed5827c8ba5797d43ac10fe56bc2c5159a94427aaa31a9aa9b2dc87e5b2718b1f77eebbb0a8b6933ad349cf122ab93be68d56e04b064c2f2c76a1f11cdc6f9d5ebe14253c9b990f74149de3be4a7331c85d5e7ed369bca898a9ad9e669579c0971221d07404dce726a09a584a6d5fd15030d3c6da7b32502fa0ed3705ce48a414401ac465bfae55b655acbb2f4da39a5e2c265aa4ee27f27f1b08573bd5d9ce846766d674063e89383be60de84c1e1dfd80a82f86521b36fef904908ec99293064535df5d97bd02854012189be31fde37630d3926c99fb63b53b0c62fcfc211ac3657d5c6a76b9f8ca28cd9a5c01402c8b5f806c07bb4662b416da32166db45cacf6e0fe9045949d48b46a3fa8db259bdff274159fc84ca68f14eaa862c7eb26c2c25ad61affc06c3e1df622ae7f07ee11f10147416c11d925d468b6c9ac66da08b3374af1f89db4f6759b8f5bca0566bb0f7b67d44e97c0e2120d4630a1faba6005da3585c98e7b1bb16048b9a1d9c7bf0f2026bfeef31d462cc73b93950a906a9ce6c1a5dc32b5f67f1ebc6e19b6add92fcd2fdf1706be9706c6146a9467eb97764a3f7679e74f6d028c53bce6c02f83de89a85b882ec8fec58822553a55836c4d8e1aada5cffcb561f79ebeee37b8357bab2a5c799daa7ec9fcdef97abe46d536e36d2d2db281190429f442460097c7a8bc58c1100aa7f642ea6f23c94fb9759ee929d3845c4f7c30cab0be203e63055cc972f731af963ccd478c84006428b1c9963c9793681ae6e9dcce7e58ffac1962363ad24b68b146d8ff7c610987b715c5ad1724f6d28f7c0c3914f0b793f2494fb3ca0f7b595e73f9a467db34f90a60af6254fcd04a21253ccd02be23284ebcc145b9a94f4e44b3186cab4313b0d1b086a01392ed2e9c8c6f11daded1347b5e5c3df60a5ccdd0bfbbb2a5d85c4c52e0ace9e5cd1673faf5b9d31d2e039c7f6c91689a62457ea61f395aeb15b82937ca831571c3e4b21189be78481aed046b362cf595af1d567524655ae3c5ff374bf68865533b769ce5b7f052c7f9d73bda6b8f219872704d22434179c0cff9d2c2fbc04d0db57c5610996a86ab52b2de4ba10ad15da7965a86e42e2b093b7bcb4b2156d76655449eb9914d46896f87ddf8b32efd49fb09960ebfa23b02b139c395c969e45fb5892d5e9338f6f9f470d56c1f1e6e506677d4d2a5a60c807b107f82664cf4e77ec7083580644a16a9b3d009dc240f3ee58f949afb24a822a3603baad83de2d2c956cf86b4a2e33440fbe5faa6d07974dc672f08afb8fbcc71d58b3094b4576fd43f7c1b8273b5abb69fceada1a0e9924577db72613afa5158bcacbceab11dcef235ca6fed85952f7a418cbf1feea18d71e43232bd8add549d14f75f0fcca261164cabad4354bd11219b82fe4af52feca9be6ca57d1638a95d1be57e1113d7e0d2cf60675ca07355434e62b6b93c135a18610e7d7e53aa98762695cfbc6ada8b84ab4a2742d3c4e4c9e4efbe725d6762fa05de317cf6117ad0392326f2d791691e6b74f1bd8a1f6d9128b1310e409c39a9d28ae6549fe2a41bb7b0133b667620ca960306c99e248179b81880b2304ff7e6d2f2a219946f1e3f1abf428baca0a58c5d88aaa4989e9e1091f8226fef438060be44ad816777e75099acdee361f1003d3401daed6d86d0a49135621057829159f891289eb6b8b874e9d90a61fb87dc6fc3f221d21139bcdcc1448efc3afb49f542f5d66a535998767ba4ab82dcbb97a9404b37460052ad97b69f80349ca64e4715f008a0aadf0567ca857e45015b56eec6e7bd61bdd8b5c5d13fa76af5e00f94d6428e29ce1707e193db15535ecd3ce7a96ffd7cf390afe584405a75b09c8ad93d1c31ecf5337655ceaa5a262c7f5077dd9f62ac84dae27c342e34e759e867cf03e421cdb2563e02362377e3b0f615b2e08143880bc3c392b23b69297928fcf10fd9854d26b8d895b816231c9ef45c8276b4e41d946ecb1d1f8db30c872dc862941ea7a69d4a98baf2c70b733f0822065f44f888d0ac29d25347d4e3c23400ce41a735b19174c96871e8cce6f793ef30ee8dd0cbe968b6ddf2696aa7333293fb849abded406a1c7e0d1bf908a74ab3ed2b4fe79b729d0afa804b753762387c8d56415255368ce9f906f9e033972e118d01cf71d68f7cb4aa12247ed495324e3fb62732537342495d457710b5e69330aeb9f6edf337b1b4c4d443298a492d5ad78515aa65047fb1bb7d2a1439e77fa5e525ae76c846ade3943aa2db04b53595c90869032b5565ed1962a941c7ef1e42f88f0d8cc87cc1ded9dcc43f5cb70f5a83584db1b5145d2d88419a911ed23ee97a072c7c18081dc4f47aec2a3d4b97f2c9cdc81d519765f8eaa442aa8f11cc9003cb039301fe6bc4843b49045b2a3a9a8dff5c79456dfe3bc11b4fedaa7d89ced03c16a0acaa1c885d6742c6051f2d16755ace6281548f09ca5e3615c78aa372b04d97698cacf0c66fde9cf0d39ea15ee00434c3831b1839292fe40f12befddc7658875de9840248dc21993ab971fa0d549b333153d9217eca1c3b00bdaed460b7de71c5cfe0507c8cf345e4a15545a1d9688bf6bd570f9c7ecf18144d6d12127756deb7b89221c49532c172957aea4d3502d1ef599d87ac936243e384194fcb1492c0a4878cb6896102cec0bf15dcdb834b6cd688bb7d1db94e437ec19428fb3818e8a01489d74b1c8d3fc7b40688693fb73fedb5cf35e7d8a16bda10709555f760d9c906e62dfafed27af49ad66008db2872362b5919ff03df3a16914aa55928b134eab047ee8668ee18d9c225e50275b436991bbe83bde211924cae49422ee96654da70d670c6128ada8282b9975efdf773ba1a266857fb07474eadf88b2fcc2024b31554567d4bafad53c6f95424dab807009b8dea84527235a92e4532da9561f3fc2e9a113eb4fd85f8653f3fe10b73b36695220a832be2352d612994efb13969aa2cd6e0d9006dead0ba86d45e404d0d777b77c3a4ee8c58d49c53b1a4134b1f3c30e48925d276d5e66583b49ee672652438770e67933efcc852bf5f73017dcc45d703444760bed560099139ebe86fe4990d0cceca84fc2733b2606f77e53e22191f081103ee353b127ab5ba4dee7defae78b1856491c03dcc81161de34b07463b4d45fc970bb48a3d751d88ee4b49bc09402cccfabb47d18f5333cc1472e636a87bff218e7a242d5c0736e9a4c0b6d7449de42d30af695eb8dc84d4991a326f2f1cc03ac45d0998a7cd5fbee9c4e1154bdc31e822cbb8b5cd92065224ccf3ad428cbed5be560e710e05c68af96bfebe62fcd90122909df3d29f63abf93b378f2712016bd4e8f8c818d1e9a203e9046f22231c81d7967f6849443aac73c6d1ded3023a66ea0340683a088220aa1fad2daa22f20c0535a0333aa0aff5e03ca91f3acc98972a7d748af83d1a151752f2c4fa41ee28eb8085e6db97974471d43e5b66711edc09d7300f036f61a1318d1d2e6f74ce7dee996d03f9fff900590427eb8255f5d155aac3eee7f72ec3c52d49fcb7ca984f247732551d97c444d9b9b17c3cdd6b873c8e95df5297469aab2b07f92562d3aef04d9a9d896629c2bb5fbf48071afbf8a85b1b73002cd177ecb42be436aca02c7b7e6922e89b224986214be4f43b73d173c9130a18fb87b27e6cd571f58557d9d57dbfc977b6c89e798b35f965a7d7b4791bff2453312888640be6b4d4844c99daaa494e260ef9dfb8b02114b116cafb963a666b1bf120289423c1f30074033ff0a0068e95c0be7e500b68924e9b99be1a7454812eca03e15e93edaccf4c727e5f3cdb1a84e24b86bd1a57f1bb33a75a974b865c13ecd9cc2437c05f7db46f8c4d8c696fbcc63389e12f3591ded22dedd05ae769403227037bd1c80fb7daab94f764a52764e394c28ebbd79eb70229a8eaae3f9cc01a5f655f3494854a853cc50aa973f07ac9f554dcb7568a2bfe095620d49d9e8399cb3077d17400e29b313e4b23be3597f4dac2483ea995d5f3397edf41c2db796100289ef135f87e72502e08367132ed90dcf92ee7d9e94b206c76fd5a371fe954c325228601917154c1bb530ae578ca4e9e6be4599a59555b155a8a97d172a90cbaeb6a7d23d5090c54983ef493c1f5a67b033094d7720e85f3f03bb0da1c69ccecccda256a66ff4fc5d1c7e461aaff39335282d65e9c6fbfe0e4c9fca462926265b793fc9b7b52cd436ce40bacf742041aaac7589d1e50b2a10e5a9d225cc006d3e14c50abda602f4a972e7aacd99ff2110503ced241624339e65be498fe0c2bc1909718e2101db169af93529e200836309c3be527d582b867967cf3d96ccc98741fbdf2eb0d7b6a561b7625fcd3e16123b1f82d6856c76a02f81939f4e369bc1c718953bc8c0be1ca34aa3cc87191a13a1ea9d2cbaebf7b224be7dfdbfd1b22e0958990d82dde59ad3100a68bf5acccf203580aa76e5907061e67b1457717088568463f3616b643cd4c79d59f64c7b2777c2ca5adb268de8d1156d7f7d039f1e0b3ebf886cc477355e399c00647c49bb288f8783c53a6b1379dce6e6c8692acbac3188e10ce025d5cff0e97f4d3da57c4baa53625cf483d9c4a5db5bfd3e3c81d02c28ba39ac233485451bc0f5dabddf30b3883a4293228b1df8a9bf068e3552f5b2bf599b2f9c8189e20daf0b73ae4a2e2c56605273b1fc697f4096b4f2b37104d8886c8c0fbad35cf68f67b045ecd676113d69f30f5b9f8a0bd2f06ca65fc8d64da406822ede66f62ff98e946ce87d218bbc772c34cd8dbec3a1b9a7e59601c77e6a2db6d55bcd55dd53e5a935f1712abf25ce09cf32f75eb09516452e881f0a05b90d8539f2364484d0d6fe4cac56833f3258875f4adb3537176aa1bd341dfed28c09261b32ac3dce05a5b17797b1f504648efb7a5959593dda32018b3f14296f4f544f17794e4a5e0fb49a89f2f0d0d78d906e50402597e18609d736493d11d122aadd1272e33b88069338dfdf4a3cb2511a3bde4770bb1527cef3d25fa2fe7a61782cf5a734dc80075a6c899031c5f07fba3a62fbfcf9a696d52c5eae1a2e425fa47c467fda8af1bfe504074f47ba3c7c89c0aee434fa2ed645b6943e9333a4687ee6bbe98007fd3bfe738a04c752cd6bae3def5d0a679f6a05444c3627ec8a007efdd108ba5ab64a2aa067ee451cb1ba1248074886908ee3c43afa8a3aff27e3c71ee5e117c1f5bcfaa9dbc29e59b7f6f5c1384fdf56e98ac97eb7301c3a6427b935a0968b3bd06d85629d1bd892a606d2c2e53ed4f160df619a5bd787f5aea48abff41a16559d69d979fea2afd98dfd6a29d5aa62e9483054ca74ba336c167da407ad924a5fa7ed95ef0a72746227c0dc798f2d9e5fec38aca0c8b640ddf9f2d62dffc60ad8629960b9dc4864f905e770b5766caddd4da8d717c009810f020c1d8f0e54656b8de25bcb7d2da76bd58bef5aae01b418fb27d76187aca41bf13fe7952b34cb5473d66eb47608aca23ea954705fc2335dbbf6724f13c0293e10a4b87a2f5900f997b0f2b1c159fbf83cc394e3ffcd762f157a36c0b9985011c1ff2ce8d583f2e32dd73d0c83a8a2cb80e0ff7693476832c935f6833749db505ff5ca25e0e5db13afe8ba01a356222a720a1e87ae22d3d8c784c1103eb3af7380dc406e6003bc21b25dfaca0c337d73150eb4394ce0982c7601ab36af7aa3181329645031b5fb9138bfe9dfa53f51796629656d8145d62549a0eacf58f3b600cefb22af0ae8a823dc365cbe4b0653d63e861b0f4b6429e306f89bf859d1cb1490ae775f39aaff470b696a483e9ac365178d9d112ddd046c3fe5b54a15bb8b85248f609e443625d93edc0f2da3fe35861beda2833d679f5fcbb182d8634bbc5bb065e3b8e37a32460cd6a9083bd5cad8b1504e980276b524895a6a2bef1270606784d873092680401b6c9de23f3f3851e33e86dfd739aa2c924b5e4abbacd0d10cdd87222ecdef60ed49433f6722e1d8c50900b3c52bc8a8ccc6d2d7fd968d269fd49c74fcb0f2921f02cbdc9ae6c634077f0daf47939aaddc1ad3123818d24aa797b7fddba7df746e21276847b8fe432d036b6b32b79e7ff03abd5544dedf1c75479cc0f04ab9c030b950aea3c2e6e609db30773bdcc479c2193e44694f225f200da7d6637ea50fc87a30a7b596e5bd46c9753e6eac0cee08124556f0175844c904d47f389e1cd7d9d7903047ed784f457c2cb9f4504b9ce5b5b6482b26f1d933152e58df31474285f84e4a4c93f8a276a9987ee72c60c3df78926858c80012d32916e7ec03990037772499a555fae7d23762de92529d32706aca7a9947cdda38ea50d6480590b3314087c571c73f2ef15d4942a8db6693bedbcd513ccda5b76dd207e6acd7e87899c5684549f4c25b00569995a8b6303b50f1434f0942b3a33111ab905e460fab55e3b2803c79e52413d8f646434b1194e071aa229792e06c5418091e4a54cc99a6c48f40aca347a548fbc0efa06fc167c3a8ca044783b8f8cdd2ebdd7242048f88a6cb91521d82cbf267b6b519269dc25da3c426c457039f82581445315657bcde27d4e9d5d1e09fa22176150f27ac6f3aca2283eebfb3342a56e3e2662592140c5f40166de8568c0db65a8a7257381e7d967dc156c23592aed055783eca042e26bdaf08884baaa88ab29a174a1dfef4c28cbc22a7f7d91668fb6bdd6cdfdca90816b1b775d480c5f9c9d024974e4fe1b45388766f400e55e6d3ac0209c5b5a7b0f93f3fb7343cc253a5f7b6de401017b92af18bdf2726a664aacabe0773e2e7ea568e5df0614d02f59377dec4d62f8f9edc81560ac9fd5ff7de540633abfd13e526cf14c557888853a5e8f4ebbaf9849e934156afd48472f2043ff9ecdddfffa17a32a9f6ca69111270da938781eedb44f46c47f0005c84d2ba3cc2bbc915dffa8d0602b1ec6ef105c152b7ae2cef3ecd87711ffe1ca5b5245d1c6b26ceded9816593ecffbc41eaa5ec0b7264bf6413b8994c1154b2918d7a9f001dc060d89ec01a5cbd557a5296f3ca95ea8b68c94efad72a00aebfa316a623def9f4f7a0fd88b62d48648823584503b036c5728e1d5d80ae3629eadab3005d32c55ece439356d4c1d503caaa3122edf7c79feb83834f869e871df827f794e96e5652c5c511c1373a12c16acb6a958c22346dd8ba18c1e47ac76aab909265b6b9a38ce6fc5f0ebddb6a4197d48109f3a2a6a1379df2bb3c56d31d57e2c70d6f5a7a108f499f3f974a0943a8330f1576ea44794ff787a6f104212032fa329f5ba831f7095545499aa8b7a6e82e9aec6f06676b28cf9dee94169041c7598347d2e9c3367c90f63d367c08cf334954086f7acb8359329d1dc6f54f594b09e87c1ab61c737806950d99a417b001d66fe5fc31d555924d8bd22e421d3f475cd9d336f46574bad3338d2aa44384a376c4cc34e4b15e9eddedbc003c216e3178186be392e47bea989270678e0d315231f082acaccba57a1380d819cbf0cfec775f7c0ed2a9ad4ffbe398103a0f49a2c7a5316be5c3bf20461042344216095942d9462ef8e97cc51a39b9a06ca6d5e59190f0164fcb262f516adbed2bffab6178646b496c986eda2d1becd2c4fa47fb5dbc3963f95b6b1360f1a9ff631555b2f38445449cd1c9e247103ea48df4b789d1fff396600be2ebd4821e643b276f65585b5d7d4b2fd1b8eaf1c099e7a45e058221e5d05a8d83c45fa383331a13305d982d59e76c8e7e67819d7f8fe4d54d0604d063255285ed6273c97576a8974285df40cff99741d04f7bc5697f5af51e241b0f451a7388ab11cd6be96684d531bfb2ac9c59e449fe610d2e52c328827038b181a821a17134e8da7cf7de67dedc4a2fc46fa09d975f0b5e6888fa2507d71b7bcc5b81add10f83f0a0b31e2cd7b80aaf2202a53c9a6f89575b614e87592fc799c99fbedee9795c1a326dae8a7573c881531c192f900da579aafdb3d1ba85a70ea11859d4275c695b961dffcf8932ab05ea1810626a100e8262643184157deb2ef5bfe3c2028c388c6179b79f2859a098c02a38ecbd86096afaeec7ba5b9f1ee521dc004e9c7ab4dba68c861c2944f4bfb336546251e802b36a57775c99e6dc7c35f8015aad48642b06d9eae84aaec33a7ba67b087696005b3c1d967a7dfa6571a83660d705d428c8eae32b323e9181ff49294930aa9766267b3b54a8554741b954f75113d656fec106be2fc549d6306742c17e569fa2a0ca49cdb6dcd068b214bda92e49e8d82d5d043e48c88dcddab893b76c951dde0e4dab22385f9b378f7de8161a9b5c67099a5fbd8bfae9cb2c0a5e6d898aae7d1090cac3cb4ebe0af2d62dd716627b3cb8c19675c29b93932faa90c2a5d84008cd173804e109a3761247f2b50e3362ffbf019f6d2e21d16d99a1ae7403ff6a5987569a11bb96b4218f8d8678b1b45e8c065b5c1e105f4304b80d30e620cc96ef9c2309f35236b48c5f90cb46a92156fe331a89f6ce2cd485c5c3806aa47642253f019d938e8a08fed7aa7f3aae401f0777245e9542fd71c5975e52379a76c39c74a9276e3c1bdde1e826f8791c07b29a72ca1a4f6be1cc489506b824a6febd8a215cddad6039b230143d5006aab","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
