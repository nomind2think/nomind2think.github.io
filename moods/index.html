<!DOCTYPE html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8" />
    <title>请输入密码</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="pragma" content="no-cache" />
    <style>
        :root {
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --input-bg: #f1f5f9;
            --primary: #3b82f6;
            --primary-hover: #2563eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f172a;
                --card-bg: #1e293b;
                --text: #f1f5f9;
                --text-secondary: #94a3b8;
                --border: #334155;
                --input-bg: #334155;
                --primary: #60a5fa;
                --primary-hover: #3b82f6;
                --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.3);
                --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.3);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 380px;
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px 32px;
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon svg {
            width: 32px;
            height: 32px;
            fill: white;
        }

        .title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .instructions {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 32px;
            line-height: 1.5;
        }

        .input-group {
            position: relative;
            margin-bottom: 16px;
        }

        .input-group input {
            width: 100%;
            padding: 14px 48px 14px 16px;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--input-bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.15);
        }

        .input-group input::placeholder {
            color: var(--text-secondary);
        }

        .toggle-password {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .toggle-password:hover {
            opacity: 0.8;
        }

        .toggle-password svg {
            width: 20px;
            height: 20px;
            fill: var(--text-secondary);
        }

        .remember-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 24px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .remember-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary);
            cursor: pointer;
        }

        .submit-btn {
            width: 100%;
            padding: 14px 24px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .submit-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .submit-btn:active {
            transform: translateY(0);
        }

        .spinner-container {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .footer {
            text-align: center;
            margin-top: 24px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div id="staticrypt_loading" class="spinner-container">
        <div class="spinner"></div>
    </div>

    <div id="staticrypt_content" class="container hidden">
        <div class="card">
            <div class="icon">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 1C8.676 1 6 3.676 6 7v2H4a2 2 0 00-2 2v10a2 2 0 002 2h16a2 2 0 002-2V11a2 2 0 00-2-2h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm0 10a2 2 0 011 3.732V19a1 1 0 01-2 0v-2.268A2 2 0 0112 13z"/>
                </svg>
            </div>
            <h1 class="title">请输入密码</h1>
            <p class="instructions">此内容已加密保护，请输入访问密码</p>

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group">
                    <input
                        id="staticrypt-password"
                        type="password"
                        name="password"
                        placeholder="请输入密码"
                        autocomplete="current-password"
                        autofocus
                    />
                    <button type="button" class="toggle-password" aria-label="Show password">
                        <svg class="eye-closed" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                        </svg>
                        <svg class="eye-open hidden" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/>
                        </svg>
                    </button>
                </div>

                <label id="staticrypt-remember-label" class="remember-group hidden">
                    <input id="staticrypt-remember" type="checkbox" name="remember" />
                    <span>记住密码 7 天</span>
                </label>

                <button type="submit" class="submit-btn">解锁访问</button>
            </form>
        </div>
        <div class="footer">Powered by StatiCrypt</div>
    </div>

    <script>
        const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        const templateError = "密码错误，请重试",
            isRememberEnabled = true,
            staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"739fea3350e9b9c8304d4dbd5b7ac1bbd352e87c1efdf2fd4b9d793f76aedf0f5089b60942784fb6ade7fb4fdfa08a8f8383058112b17acc566dea1c319821eababb9de202140958577df24dd4d1d7dffb574883f10a4b208828c2733d83b77876c1c2d518de712142985d272dfceb156e35ffd908bca74998254291a251aada97040011bd5ba7f3ff3f29b2be776af1d592edb6e985335ed086e84fbb8b5e68520e3030c909bdb054cb945a229e1c201b33bbb572c658cf2dca6d168d380f301908270f82999634640e8d5078eaf5758870fd4be04ae2ac3f7b96dbc4796833667a10aa01236f4f273ad175878b01a1096e727b28c3e878320cfa85086ae93e112657a1cac59c4fc8286bc65534b33a2dc8d520557ef9d9cff6cd0a7ea5e5fb4fa54690406cb696817d9e7f0f9dc032185127296fb177f51ae6b9283545602889f5b11f33cb646e79f8d4f0ab96650891c362c08233378f8a37d1b62ae96eb201a01459a7acbe745f911cb81e24854bd1a450d3c4afbf9ea15025509fc48c19a3c9de7c3216ec07b22fef7147c41c1d0f6f8e41ed33e2f6141352454d91e29ea29d92c1708e496c0b7c5c77683b22807e088dfceb96292459566fb6f4e1bc327add16f8642d63be73e0f68f3f2b49bbbea905b23c9a6784c25434ca81fe2fcfc686822fcf686184116fe8c2beca1d086be096878a78dcbe0ab612b17802392cd7b682bb7ce84afcb981201441616929264b897983fb22b61dd3f637797bfb661b62d7fd8651226443e1226b0c9afceee9b87fee03c5a9ab24d3d65a80b1114915cd025368053e4e99c43f8f22b46b676eefe171bd7cef4d899ce4e279d8a770a6da6114ca96906c16117d0293b53b89857fd165b58e7b92610502eab6b5c8c07c864f96230f3b8fb27b911683aed55e61cbe690aac6aa913d02aed8aa6ce4289b7c4aa1bb16a7357f65aa061082606a7789ded01d5d34cd7a6b3d47ca15c332be9604cee6a0fe6c58d40441c1c9f14a6ff3bfe7ff86127eff21fc44adf55586028245a117c309922283c7633026cb53d7f62567047b8b557763b14ea27401c5c14c663a6393538cc42b5021877efe4cc92b7afe8007650b2288df9fa378a54b50951be6e8bdd2656801c43d422286beaafa853fc2c1a6969fc5386140e090b78db1b24fd6968c4dc13286519d9a8e275270a35970dbf4fab86cd910c95eba608b28f4047808554ba7ef498a2c594f06aff391af3dd9dfb2b11528f2c9ab8e3600362587713fd301aa205247a84af24d1785c115b8d44fa0afa13e0d221ccb264e7949be31ba4c04e2727e1bee5da6bee616c0ed8bf7b3469aeecb98efee3c9e466af5d5abb5b5f28f4020fe14a0370b96598849f1a462be70d9af405ce37c089e719ef64128c521723b0452aabedd247ee9f5ab164e6a86dcec11ba3309a16c8f2dc5ed70987e974f888b4c18c96c8bd62deb344f40edc4bb51c10602e732f3b6279aa8f0cd03e67f09f167780f7a74c994f65855f3bc7ce3ca1b14d8651ee474be0823e1b1eb2efe597aa36cf3ae572c8b54a1bfbd48ef9c1c928b2a7fdf8515a945b13e150204b7a6fc7648a9ce29d6fdac8a5ffe42d29f2965c63ec733f65ec7cbd4d88a139f1b96f258a1b7afbf481302b7cde5a583680fee7ea8666bc6a6e963acd9b5636ad5aef85ae4d627df85885ce845d0ccab9295d0c6aa9f5d538bc522a6472d63867662b27eaa75e2e13f7590580c3b66e30fb187f53967fa71f68383986db737e64bbe98bed4c108f099cc997f7ccbb8e9941e0c2b5aa6d6c1002c66131b19ac845c078c0e31704df0381a9276d828bc45925d5c72a4993dadadfb875b897528ba97d96f2b454912f4f08519438b7d36ab90f0ea9f3f2c8ed159f61356b7917f0886c4f99a432e37110a7064c2a1931087b56bc1e9ea7468dba2716e4ad8e0cf71c10cc3b04cff1a7e865e0477413493bf4c03aab12067b18df953ed7ed91a5bd7d869603c615fea8982aacccae1c81df35170bb88c56aa655060f925c34ce543ec63ac52ea1f7653f6bb9c4433f1d95662c0c56f5c3801763f612ddeeeccd83a61078b4ac5546ad57e019acd6c0a36258fd92d95be3f4fb6965952831a0f8ff4009e444469febc71ca9e7baafeb09286cb6241bba9f946d14f324b7f195e874d34713bfdc603a53298f3bc882ac2a1a50113953f40c36679ac04e7b4db81934248f8e3173ab50d9b5e793536a72c7eba5db361b53927b08d485971c2654d2ff2761fad4b908dec7d1508b06839063e6edfabef907fb8665069fd7fe89c7f9677fde948e4974eabf5ab727b18adf5cc8923e407f462b05529a985b10542ee71d4f6e69d3b8527e3119ec241ca70f3e7efa09792fe0e8a250398f0f62dd21754e1080ca21a39e31234a82d333b9383115f531bac451f9f4054e548651911f6d20365cbaa0d897d6f2dd26e02b948e912b82785fe99b136ab7962a4bcd050f762ca99bcabc9a4ab100d0fcf37bb35c006b35618cf2886fad5d7131daf7dfdbbb32e34104a4b6975b5137ea632b39f152ef8ebb338dbff87951681eab105c6247efed94352e5c108f7cf64a95a25a54976d828f420fac9cce7a3c6706187ccaf1ed6bc4f760e8d161d863f78bb4f88c505d63ef38dfb6f19eab2cc6f303e1576ed4240d02876a6021cd7865df24e42975e757b1538b4a2eed973feed9797d4d0f8c794164f286d690be085096fcc282d7d7501119ddf3322cfe0f2eaee96d991c938ae956007f65aced15985685eec61fa89ef14433181ee8ad53cbce77d5ea580196953b98ccfa1effb375beb8492a95848767d7a032f8f91d524111a47d7fef1e8c7d6a7f6790915b80d9b789830a2f3756387e87f88ae84a24fdef820b2c828c9d84ef2665ef8b055690ca3cafbf00d6384036b5233f5baa642f6c4cfa8fda87567b936e058915f9479f4355392f8d819b204e0b8a10ce0770f4c409cf1de7c8cf5dcfa9c4bf7791fbca273875e0d0f0c9ef212109a389dd5e09566cc64e9b220d7d190db17746f50ca82f32b3ca7322141b7612cc72b23d2c066036dae07dee77a35c765afdaa4a7942e86884a51aa31bf3c813461690a28f2c94cafe0caac071cfffb9fa18297ee0e67b09e702d8bc3e9f86ac7ff58f29b724a8a253bcc93f9c65ce8e616503254bda77176675d183c6cddd74c02d0bab335a81f97460287cfc7236012b777c4f7963726f80b10159ffa8dab9f7cbe96e7ce56ca281a6fddd7885e96103bb1dcb6f4a382c024f36a161792650b14f6936460deb77fc9dbd903f143f69fba03964f95009e1447994815b65344c4ad3e136b403be9b7722eb1f8d5baa7feb719f4657c9945279a04210ed9b91ed7055b1aa3b345b759f103fabfeb4ffcb08c3f3f599e44e22e0accddc969831f51ec2137660fa5508a4588c3ceac4dea2aa785a57c8d575e636b49546fb076b422696106cf88f099f4af5bdc8b8e63295dfac87d63370f9451dbfa53b1cc22ea8c544e59fd62044752b569533199ff08f7ea539c3b7f64e4ec2564352caa25ac1b22ffc3bae7ecc0febfbf522ede8016b47fe3264b4b2e07f55ea53fdd068d92767133dbe9cb970d0c22c3e7435cb9d66434f10422355e8e7dfe8c529a3227aa225a48499a6181318cdde389bb8b502fa9d2ef1fc69eed2ff25f6da6a9bb289cdd75473dd58a5ebfe4be1665e58cb5bf5211549bd58384869fbcecd056e1f65a6554c1065ec81281674db1653418a8fe37731c968e417304d1b97384f4b5a6adc7a32c9070dbb507777525ecef0d146349cf0e8eb2c6e36f592af24ac733eceffc0ed7d6c106f140f5e6c8853e4c859b86d73c7c56bb1543fa91e27a780e182c2eebd80b38d5846eee9c14d20c96595718629ac4c4fb413374d90e6fa04a33dd5869d9d880879727ef130663b69911f0a789a9f9a81a594f478dedd6633b221a184fcd251bc84a3092520d234d697a5286a367fb56c552c9070cfbcb33dcc3e8b8983540800a9597dfd4f0476e0396e47c996ec9388f95933ca61c5b1a88b2f9fd7cc2bd673ae257d22ae48f64aa3be8bb2cc813c886a17735c31111823a6811478d31593e16fda86d2a789b7bfe0b920f3fec8a3fdc45ee268717d919fe48dc2eae0ba96eb617b8bba6d46e4e015fac373b32fd4da205d39af31e5276021807d4a49adce2cf05b1536dd917b82283e242793a2ec1ba3836c4997d3e811be411196e0c1769648d54f75296eea85018ec5016e0e72ac3167994ece79d98bc664e3bb614e23178a2b34f413eda79b0933bfedca200ffeafb55bf4b55a3514729aba25d4a3a08f294841c7c58c8b1692126b909237fa994167250e7c90570e96c25f1b628a42035fc804efd600e3e3b7ebc6a9f31f709493178761039d049414615405cb58c61238885c60f66e76dfb3340c0eb4fa14e75ff8df98fac1b1d2e2bdec1edc34ed5dc0ee83c7dc1851eac3bba63f7183e43d75ecde0d3fb6d368a8dd1a6c1fd198777effd34a21429cde520bfcfcb32d4b8fc8a33a5b4e9eb6d1cd55606762257c21ce0e7c1ef1562c2f3c879fca70e5d5ad10e6b36b3bcc5f7fe7f564a2f20d1fa47a192f6080469e1fe6699f1402926de8573fee0e5a7b2146f691d162e7118e9162bf3c45579de1ea163ddadc587c8316d9efe155c5640159de8612d51fb583c9bc98b107b2131e0a1e8769c380617d4f54dbb39338702dfe784cc14d7651f11d579c40494db522baab95a8a34dcc555f1e2a697744e2b57baca5c569475029f3d9e7ca82f34a7afcd38e240412aae67f79e144ba5101f33a62f08b741701487bcddb50f32633fb9c1fbf0686b62dfa942eb4176b49fbabcdb26f6d3070d5b035a113b3cf9661708c4e6b67f6dfebe6a9e951efbca04939c82d3f17efc53f5c52a64b58d676449e0753708e86f797c9c7b92fed58761074f84997451bb2ef32d3dcd45aa792cd5bfc49e2ab654095dd5b66b985904fa3c0d4578827807d5ef7c0bbd5302554d24ce6fbd7a3466f6aed3336c74f195548074eaea73c5db8ce64e40e4ac2c6fe224388600d9b2495bebea1bc22cd8afde15c98e0e76ad7766ec10ea9369b781634178b41d205d1a3c5a0f516f111f54edbb6024eeeae6bb7e2a3baa8c1e243dbca83bad031d2050f52bb1c80fbf7552bcae2c2bad325c34f32f594fbe01c0febfb0ea72eb0b75d8c3d0fe064b43dcacb1a8dee88dd8e9400d2e7158e13ac59e652afe57e74b58d111be44a21049260c56d1d17de96a50843e4ae55f5913537951a0d8f69c6477abadae79d19b62969875d578a952d4a74d5e60e36ad3871e8d22c00ede8197db7c6356d2634c5d045e31113aac68dd82457e584b4c5efefa559f908cf972b5c39645243ca4e3a2c5bf03b99c9c96a614aba0460749effeb25e24f36ef542d9c415d80c907a721c4ce929a3190d49fadb62cfadfe4db4c4dec28b883ff0f6c87df32ed8d8d516b81fa88f502122eabe33b79aaf90c1e768a5d7cbe5d7f8ecc42a54062a4911b9b526a58375fdb594c90d0559e01ce3299ad07acb22d7ba2a253a53b27a37b2791ff154937ca82867388902ec7af20d5c2ab81bf695d80165b6c7ac3c1fbae3bac40be79904c4b737bc5f3365634c92832a5f1fd7eefd1d20c227152f4695f1b275ad256263f6ccdca00ebae6bdb3f0ab72a1c523fa90a95dc37965941c4c15181c9211aa6b31a26bd9cd3e6083d9cdeb83f1b84df23ca553af125e50ec8b93efdba1937e9fdd12558d44f6be43b68180e2b9e327f17aacdc6b6d504d0354a9b50ce1014e5503866ca3b9af42eee336050e381b00b7066f0d2aaa8d58d4ef15d16d921e8f5d399289521f1f3b09d8ee7d5a396b736bf92d4d24e0b5feb85201c639399eab71501ebd9fd626437cf7ec4b2059790691b6925c44de56c1c327038b39996492f6a49919cdf31bff08249c56061e67e76c69440580937871ec67044e8cfa3820c12a323deeccfcf06b5c24b528ccdb9fe8acffed295cb6f0c50e4f8f52b392e9b35c0caeaac6ff32f811157daf2a343e6e7b13284afa4775c9c3f8fa222d8282d34f38a62d3ed8f8d7b12369fedc3eb8ba96d59afff6b84bace50934ee4730e65df8db3384999e18c00390281a7aff1e5c8146887593ed001bbdad67390b223ff067e8d1043de2bbce4adb95af61e8d08300f9237448889b2fc72920f6edaa6511dd49d4d29f18bd40d264e86591525344437515db75ebd50a50543927fc23c29293dbd8b850d491cab2e6a8f4237d04e672866704361decc835073d2ade469936f397815414a9eef6241932dd672dec188a446bd247d3373aa350625da604bbaa4e797d82da58da61b5cc8ee4a5b2c584a1b6d25d0d148d173302d6f8403f2d76c8597a0c120e9ad1f909289d65d11eb62214eaaa90527e5829b34efa1e6a9a4240536ebe66bdb3f5384d5f2c142ce67269ca49ec5242dbb31f30f3248c7d70f4724eadf8e72455fd997d1ff4fe6610c02381784cb2939d08addfc4f4672d04080907aad23654cd2ed2f3548679343a412ce2f73bd712bf8c6bd51748645fea875595c9943c76f0f60c8b19eb340528bb1aeee992f4a26a423026632bbd1d1a70e102e79c020da20b535580c865571af11dc3b73fe6c145b7bd09b25a3001a026509c1acc431018b330b69d1e4bd43842c9bb3e50bbbf8b562dd40901ae7cb7b82ef575b131e4ec7232e803721ebc19dbe71ab5ed35145d72f5ca019f413c18d26ff7fe7a057a8142336c7bdca8e3c44f443660c9e272b48aed55167fc3764933c4641d968fcf4e4f05a6315c95eef1ed157de3629d8181216e3761de0c974b429f72419a354199b3b842b4116af836a4ec6215c004aca18d96ef71139db14e17e566c5627b69f8a4f869caa99386751ff603267660e1d1e690715d7dc461e8ada42367261cacdae5a0bcb05248169adb6c50a03bdfd561808682020c4db0720d718bfc7ffbca248be83edeca455f30eb65db94f7219712f1054492c79338ad64745b0a1c773c554fba38753761f37776c082da636e9f3c02ab7cd277052f1f36a53b6b67fb3b5caf8cff3dd46c3524dd348b258d9bccebf59d8e97669f9223ebfd07564ef1bcf3bb3a91606481862f66b2961c6730e129f401567f9007f131750ed8c9f9d309652e3bcee9f4ab3a30a5eded83f6b5875813525ffdf719e3cef45362f1c203a2d566381ad5d0f554bc54661a1768a577732415f2f4c6f1f030e6d7a41da0b0325f6e985c5b7d462307a01e5f493f6b6491cce1a8f4b74d3f055eedb498f0340ca55a2869916be79973f988666d01162caf2df90fe369c1dad1f99d346ba2ae20a286be69e1e9d75853e17260b91b5c11887e3fd74a08cf83b2145096e19f5b2f4c6b6a4bf283d637461d19aa0b7f9ea6bcdfdaf5a6af2b376a9cbd5e8ce16b5f227c170f2db2f454da8b78a8ffd134405ce8bf6c7fc637a89bb80b628336e73a423b501a38792f2150b0f899e8722f5f092d6db1685eeea9dd5594fdde2a4e39723a195bc61fde7db0c9de36b655ddfc47384167771afe476e98161b3014fa93e22d85fe3b3a2826e18e9c17931ff2a7c574720524786a1f2773928635c4cf33e846c456ad6dc6320704e481802a207a3d5ebed199cabfc6023f827fae5f99b8913bd46db1f4dbd1a1729c4c825e4bf2d8e8b0dc103177500d7d6025eb930646a2bf7ae65d9fe8fe6a9457708d02bbfb189f62d7c1d014b5615c1028578d27dcd7517de04eac50ae07380e74d2699be7e186f4bd4699a911c387a6805010b96b98c8f9534059ebbbf961cb1626d7ccc0ce73c80f62877f5a4684963047c2e1fe840bcec4c0340f2e57bbeb4f88a0d8d9c237d3dc17af624b3b5a6cbd3bff24b48c360481fcf7a8bf7b497d7b82bc3fe94d04594919e885df6582cf4e6ab174a6d3a9a0ff40d3b2d6fe443ecbb27658e998d31d8ef3ef3200f92f99906d8b7230eec191ab830e998fb08fa42ef1ee7cdaf47097483347612e31338974472538a9c95f70a536ae9eabdfca74756255d7241eaa508d4d73363e898d3ad0327525b63a07d767a08a9ccc040059e669a9841785a36669c620225c0f5c177bc2b72b13fdde11ec534c13242903ed4f27259c08492710c899e8c067eb3fc5f237e68b186340d52caa37dedeee6da473d8a67d25be387d1e7f826b64cd856f561c0d5c9d9db7995f1fdeefab8580c9f3ec6fe8d99bd62bda6687838b267f5966155554bd5a7a0245381fcb31f5f55fdb5ef6c29af24038e9fe7f71e29a7ae2eb5b13a2902d70758256a474ac5601f1bc2d8c7cca90f1c5003f06ea696cc1a50b581c8dbb9e2c14502d597259d2090d84daa6cca0372a9584df0312b3e75f69faffb66086791a2ca1d196f8a1ed423e148e7232c1e832e815f29a121f932fab51c73abd5ec38a6ebc7586713e93b452fddadf2f492385381af66d063adf3e2ea8b0893b958acec58ad2ec48c38059f2eb5a4fafaf89cfb03e47924b86fc637301476fe6ada128b799a55cd05d8b0a6b47478f9f79c537f709f29eac9a111383d42efffc5e8469ea8cafbade0cf9a1b3461ec356a1c35588b7c80d583ddc53fcd15443ab669157d01bec2cad65aaa07834de2594ea2f401274efdad507bea2deecd5f326a39b6a6a706ed23b6003dfa3c26d5b011111ef9c914cba43ee295db0c02972645dd8f9f08d1f8f587634f6202b8f95f2f45c9cd273a50f2796afd786d4e8a0bee73a0406bdc35d6273364c01ff661f2e00eda1dd9ad182846412fe4e4cea3ff5e3eb49b74e455c1c26ff7936084292e6239c71ab5913a5588240ee16906501768c0f45db3afb2b9831892f59c6291676ecf1e4e77b22a496933460f5eafffe432cd465625a3df7bea9786dc2154b0847d8e6585f0a1189c09588187d9a2ffbbad174bf06d2c4cc14ccf96162c3d4ba2f05ded42a61103486c2a57926b5fe116f9d2e3ddcdd5ac78252cd8b9dda459d2a8650569d59a4377ea84ba7fe55b41d56c0c4a4743e57611008a01e48674b6a18a2d9a3206cb39b386a3f362a324350e0610faa05e09030706e338e2a637943c78b9c09bc7ab2a9427a42bcf58bc9f1fd627c0858761128b4fdbaa0908a9d6b00fcfd514838cad6be6c81b257d9bf3ac4676475a962c04ae037a4642d3da1a792c3d9748ebe3e31b4d2099671360874d0ca4bf85cb894519bddbb69e0ce776e36be8ae5d6c8e961d0a7d64dbd5af5dc0bedac3bbf94d19fda7052ec771fe0e45cdb61349b02b742bc23805d691610739a7ec63e3f7af1e53018fa0efb5a532af0401877f768cb916b320a3104871fe39d2a552aecd85dc510b729695ca3a78e895ad22dd00d4887b0c35f56d7e427c4d3152fcccebc31413d4f9f58cb6fdc244fde8746cdba242a9e789dec2f209c0a70dbd0422be7ebac774d172077196fdc4a534456957715e16dc535c5f3d5e76a704716c79f09bb013667af06da8a56aabadeae8807ebc04366a58df1fff2475cb5d8ee612b47ffb6fa9b213bf5569ebf552c8cd7db9da48265336d63b7580cc239b2f269d8f34d951f961880f7bde3944161b28bda7becced9de7764a4c65a23e33b935afecad4bce780a82fb9cc9e8246563454ed321352b7daf31c834417cf599cbb50d8afa7e8e6881ad732e7e4bb770b4341cd95367eb53f8c792e883929cc0ef18c9cf1b49490c6a1bb3b4bfb8a373565928e3c7f2e0d88c01925b59d14e777fb6a23bad434b22e32193c6554f644f9c5644922dc9f916f4fad5c2a9e9e4cc4efe6528996fde55e6e74c4223d41841384d6a9592a2131163632deaf7995dcd75ed6c892ff48982d7aee101020cf2076dc4c374993d5f362c8fabf45bb07374798625324d69e91d3e5d1f6857da906b111416407b2f6958d513a7466e8f60603d10f69d2bbeb961f2c976edcef6541d6e5f32cfad1acf700bce23dfda3fb80de27c3a1f150e1a2551d6b094439e54b9d48442f7","isRememberEnabled":true,"rememberDurationInDays":7,"staticryptSaltUniqueVariableName":"e108eb465047f7873ebe9172fe8af503"};

        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        window.onload = async function () {
            const { isSuccessful } = await staticrypt.handleDecryptOnLoad();
            if (!isSuccessful) {
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // Toggle password visibility
        const toggleBtn = document.querySelector(".toggle-password");
        const eyeClosed = toggleBtn.querySelector(".eye-closed");
        const eyeOpen = toggleBtn.querySelector(".eye-open");

        toggleBtn.addEventListener("click", function () {
            const input = document.getElementById("staticrypt-password");
            if (input.type === "password") {
                input.type = "text";
                eyeClosed.classList.add("hidden");
                eyeOpen.classList.remove("hidden");
            } else {
                input.type = "password";
                eyeClosed.classList.remove("hidden");
                eyeOpen.classList.add("hidden");
            }
        });

        // Handle form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
            e.preventDefault();
            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;
            const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);
            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>
</html>
